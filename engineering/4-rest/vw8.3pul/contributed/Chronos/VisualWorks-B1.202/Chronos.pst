<?xml version="1.0"?><st-source><!-- Name: ChronosBundleName: ChronosBundleStructure: a Store.BundleForParcelComment: The Chronos Date/Time Library  (Beta version):	* Implements the ANSI-Smalltalk Standard <DateAndTime>, <DateAndTimeFactory>, <Duration> and <DurationFactory> protocols.	* Supports the full functionality of the Olson Timezone Database (the native time zone database of UNIX)- including time zone rules that vary from year to year.	* Supports various calendrical systems in addition to the international standard Gregorian calendar (e.g., Julian, Hebrew, Islamic, Persian...).	* Supports both business and scientific use cases, including time-of-day-preserving date arithmetic, holiday definition/detection, and resolution down to the nanosecond.	* Supports point-in-time values that are either invariant to universal time or invariant to nominal time.	* And much, much more...INSTALLATION : installation instructions and an archive of the Chronos Time Zone Repository (which must be installed locally for full and correct functionality) are included in the distribution, colocated with the Chronos parcel.  Usage is controlled by the Chronos License, also included in the distribution in the file chronos-license.txt.NOTICE: All code (classes and methods, and all associated documentation) distributed as part of the Chronos Date/Time library are © Copyright 2005-2007 by Alan L. Lovejoy (all rights reserved).  To obtain the latest version of Chronos, the Chronos Time Zone Repository, detailed installation instructions, code examples. porting advice or the text of the Chronos License, visit the Chronos Web Site at http://www.chronos-st.org.Parcel: nilParcelName: ChronosPrerequisiteParcels: #()Version: B1.202Post-Load Block: 	[:package | 	Transcript cr; cr; show: '## Chronos: Post-load Action Invoked.'; cr.	Chronos.ChronosEnvironment canonical reinstall]Date: 8:32:01 pm June 18, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (jun09.2) of June 12, 2009 on June 18, 2009 at 8:32:01 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Passport</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></name-space><comment><name-space-id>Passport</name-space-id><body></body></comment><name-space><name>Chronos</name><environment>Smalltalk</environment><private>false</private><imports>			ChronosContants.*			private Smalltalk.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>Chronos</name-space-id><body></body></comment><name-space><name>ChronosStandardMonthConstants</name><environment>Chronos</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>Chronos.ChronosStandardMonthConstants</name-space-id><body></body></comment><name-space><name>ChronosConstants</name><environment>Smalltalk</environment><private>false</private><imports>			Chronos.ChronosTemporalRatioConstants.*			Chronos.ChronosDaysOfWeekConstants.*			Chronos.ChronosStandardMonthConstants.*			Chronos.ChronosFactoryBindings.*			Chronos.ChronosCalendarConstants.*			Chronos.ChronosDurationConstants.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>ChronosConstants</name-space-id><body></body></comment><name-space><name>ChronosCalendarConstants</name><environment>Chronos</environment><private>false</private><imports>			Chronos.*			private Smalltalk.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>Chronos.ChronosCalendarConstants</name-space-id><body></body></comment><name-space><name>ChronosDaysOfWeekConstants</name><environment>Chronos</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>Chronos.ChronosDaysOfWeekConstants</name-space-id><body></body></comment><name-space><name>ChronosDurationConstants</name><environment>Chronos</environment><private>false</private><imports>			Chronos.TemporalRatioConstants.*			Chronos.ChronosFactoryBindings.*			private Smalltalk.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>Chronos.ChronosDurationConstants</name-space-id><body></body></comment><name-space><name>ChronosFactoryBindings</name><environment>Chronos</environment><private>false</private><imports>			Chronos.*			private Smalltalk.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>Chronos.ChronosFactoryBindings</name-space-id><body></body></comment><name-space><name>ChronosTemporalRatioConstants</name><environment>Chronos</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment</package></attributes></name-space><comment><name-space-id>Chronos.ChronosTemporalRatioConstants</name-space-id><body></body></comment><class><name>PassportObject</name><environment>Passport</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			private Smalltalk.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.PassportObject</class-id><body></body></comment><class><name>ResourceReference</name><environment>Passport</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ResourceReference</class-id><body></body></comment><class><name>LocalResourceReference</name><environment>Passport</environment><super>Passport.ResourceReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.LocalResourceReference</class-id><body></body></comment><class><name>DateSpec</name><environment>Chronos</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year calendarDay </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.DateSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>Immutable</name><environment>Passport</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lock </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.Immutable</class-id><body>Immutable	Concept:		Immutable is an abstract class whose concrete subclasses will have instances that can become immutable.  		When an object is immutable, its attributes/properties cannot be changed. In other words, the value of an immutable object is invariant: it must always be value-equal to the same thing.  HOWEVER, the instance variables of an instance of Immutable that has been made immutable may, in some situations, change the values they contain--although that should only occur when it would not result in any change to the value (public attributes/proprerties) of the object. In other words, the immutability exhibited by an immutable instance of Immutable constrains its externally-visible, "black box," encapsulated public behavior, and does not constrain its internal, private mechanisms. 	Usage:		Because Smalltalk has no way to atomically create an instance of a class that also initializes the attributes of the instance to arbitrary values as specified in the parameters of an instance creation message, the instance creation API of Immutable must provide at least one instance creation message that results in a **mutable** instance of an Immutable.  Consequently, the class message #basicNew must result in a new **mutable** instance of Immutable. The class message #new should also result in a new **mutable** instance, unless it is appropriate to fulliy initialize an instance to its final canonical state simply by sending the message #initialize to the instance (this condition is normally satisfied only by singletons (or objects that logically could be singletons.))		To instantiate and initialize an **immutable** instance of Immutable, it is necessary to first create a mutable instance of Immutable, send initialization messages to the instance, and only then make the instance immutable. Typically, instance creation messages other than #new and #basicNew would be implemented to do just that. 		An instance of Immutable should be created and initialized in some "private" scope, such that only the creator has a reference to the object. It should be made immutable before it is "published" or "exported" outside the private scope of its creator.		Since mutational methods must be provided in the API of an Immutable (so that newly-created instances can be initialized before being made immutable,) immutability cannot be implemented simply by not providing mutational instance messages.  Therefore, to implement immutability, when a mutational message is sent to an immutable instance of Immutable, an exception must be raised, and the value of the receiver must remain unchanged.		To determine the mutability status of an instance of Immutable, the messages #isMutable and #isImmutable may be sent to the instance.		To make an instance of Immutable immutable, send it the message #beImmutable.  This message is idempotent (i.e., sending it to an instance that is already immutable is a no-op.)		It is required that a copy of an Immutable (obtained by sending the ANSI-standard message #copy to an instance) have the same value as the original, and it is also required that the copy be **mutable**.  To get a mutable version of an Immutable, such that a copy is only created if the original is immutable, send the message #asMutable.  To get an immutable version of an Immutable, such that the original's status will not be changed from mutable to immutable, send the message #asImmutable.	Motivation:				There are two essential benefits to having objects that can become immutable:			1. Immutable objects provide an invariant of fundamental importance--their value cannot change. Value-invariant objects can safely be used as the value of an attributive reference. An attributive reference is one where the semantics of the reference is defined by the value of the referenced object, and not by its identity. In contrast, an associative reference is one where the semantics of the reference is defined by the identity of the referenced object, and not by its value.  For example, a Set points to its elements using an attributive reference, whereas an IdentitySet points to its elements using an associative reference. When the value of an attributive reference is a mutable object, there is always the danger that a change in the value (attributes, properties, state) of the referenced object will have undesired and/or unexpected side effects.  Typically, programs and programmers either ignore this danger (which can lead to obscure bugs that are hard to diagnose,) or else spend considerable effort trying to either prevent or otherwise deal with such mutations. So immutability either significantly simplifies the logic for managing attributive references to objects, and/or eliminates a common source of logic errors.			2. Because instances of Immutable must initially be mutable, but can then become immutable, their lifecycle has two stages.  Mutational operations are limited to the mutable stage of the lifecycle.  The typical usage pattern would be to create a vanilla instance, initialize it as desired, and then make it immutable. Consequently, it is both natural and extremely advantageous to not require that mutable instances conform to or satisfy the same constraints involving the values of their instance variables as would be applied to immutable instances. In other words, it is not necessary to require that mutable instances of Immutable be continuously kept in canonical form, or have valid internal state. Instead, the distinction between mutable and immutable serves quite well to also distinguish between objects where there is no requirement or guarantee that they be in canonical form from those where canonical/valid internal state must be guaranteed. This follows from the fact that the sole purpose of the mutable state of the lifecycle is initialization of the object. One benefit of immutability, then, is that the logic of mutational methods can be simplified--sometimes quite significantly--because they can be implemented as initializations that don't need to worry (as much or at all) about canonical form and/or the validity of internal state, instead of being implemented as "in flight" mutations where rigorous inter-variable validity and/or canonical form must be maintained at all times.	Implementation:		Instance Variables		lock	&lt;Symbol | nil&gt;	Indicates whether the object is immutable: if nil, the object is mutable, otherwise it's immutable.	Subclassing:		Since it is not permitted to change the value represented by an instance of Immutable once it has been made immutable, it may be necessary to set one or more of the instance variables of an Immutable to some canonical, default or derived value before the object is made immutable (in order to avoid a situation where an immutable object is not in a valid state.)  To accomplish this, subclasses should subimplement the method #canonicalize.  The message #canonicalize will be sent to an instance just before it is made immutable.		If a subclass implements any instance method that mutates any instance variable whose value establishes the value (attributes/properties) of an instance, then said subclass must ensure that the value of any such value-defining instance variable is never changed once an instance has been made immutable.  To aid in this, Immutable defines the method #assertMutability, which will raise an exception if sent to an immutable instance of Immutable. It is recommended that mutational methods invoke 'self assertMutatibility' before actually mutating the value of an instance.		To distinguish the mutational methods of an Immutable from those of an alyways-mutable object, a different naming convention should be used for "setter" methods than is standard Smalltalk practice.  The standard Smalltalk convention is to name a method that sets the attribute "foo" #foo: (where the new value of the "foo" attribute is the argument.)  For an Immutable, the convention used by the Chronos codebase is that the method that sets the value of the "foo" attribute should be named #setFoo:--and such methods must answer the receiver.  Additionally, a method named #foo: may optionally also be provided, but the semantics of setter methods named in that style are as follows: If the receiver is currently mutable, then sending either #foo: or #setFoo: should have exactly the same effects; however, if the receiver is currently immutable, then sending #setFoo: should result in a "modification not permitted" exception, and sending #foo: should result in a new copy of the receiver being created and answered whose "foo" attribute has been set to the value of the argument (leaving the receiver unchanged.)							</body></comment><class><name>PassportMagnitude</name><environment>Passport</environment><super>Passport.Immutable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.PassportMagnitude</class-id><body></body></comment><class><name>TemporalRule</name><environment>Chronos</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.TemporalRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})TemporalRule	Concept:		TemporalRule is an abtract class. An instance of a concrete subclass of TemporalRule represents a rule that may change over time, so that it is necessary to specify a moment in time in order to identify the version of the rule then in effect.  		Each TemporalRule instance represents a ruleform in effect for a particular period of time, and is also the head of a linked-list of TemporalRules representing either the successor or the predecessor sequence of versions of a rule. The linked list of TemporalRules, also called the "rule chain,"  provides a diachronic view of the historical versions of a rule.  It is the responsibility of subclasses to determine whether the "rule chain" (the linked list) starts with the most recent version of the rule or with the earliest version of the rule. It is also the responsibility of subclasses to implement the ruleform itself (specify the semantics/parameters of the rules,) and to define the temporal parameters necessary to determine when transitions occur from one version of a rule to another.	Usage:		See the individual method comments.	Subclassing:		Concrete subclasses must subimplement the following instance methods:			#setRigthLink:			#compareTo:			#hash		Subclasses will probably want to subimplement many (or all) of the following instance methods:			#hasRightwardLink			#isAlwaysInEffect			#rightLink			#rightLinkIfNone:			#sortOperator			#withRightLinkDo:</body></comment><class><name>AnnuallyRecurringTZPolicy</name><environment>Chronos</environment><super>Chronos.TemporalRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interYearPolicy boundTZ leftLink </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-Policies-Annual</category><attributes><package>Chronos-TimeZones-Policies-Annual</package></attributes></class><comment><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})AnnuallyRecurringTZPolicy	Concept/Usage::		AnnuallyRecurringTZPolicy is an abstract class. An instance of a concrete subclass of AnnuallyRecurringTZPolicy represents a ruleform that specifies, for all moments in time since the ruleform takes effect up until the moment it expires, the abbreviation and offset from UT that apply to all points-in-time within the territorial domain of a time zone. Each AnnuallyRecurringTZPolicy instance specifies/represents a single abbreviation and offset from UT that apply during the period of time its ruleform is in effect.  The purpose of an AnnuallyRecurringTZPolicy is to enable the binding of a point-in-time value to a particular time zone abbreviation and offset from UT (in the form of a "bound, dynamic" time zone instance.) 		An AnnuallyRecurringTZPolicy is an element in a chain (linked list) of AnnuallyRecurringTZPolicy instances (with the linked-list behavior implemented in part by inheritance from its superclass TemporalRule,) such that the "rule chain" (linked list of AnnuallyRecurringTZPolicy instances) as a whole specifies the offset/abbreviation tuples that apply within the territorial domain of a time zone during every moment of the year. The first AnnuallyRecurringTZPolicy instance in the rule chain represents a ruleform that takes effect at the first moment of each year (local time.) Any successor elements in the rule chain represent ruleforms that take effect at some annually-recurring intra-year date and time (any of local time, local "standard time," or Universal Time may be used  to designate the moment of expiry of the predecessor ruleform and transition to the successor ruleform.) An AnnuallyRecurringTZPolicy's ruleform expires either at the end of each year, or else at whatever annually-recurring intra-year date and time it specifies.  When an AnnuallyRecurringTZPolicy's ruleform expires, it is superceded by either the next rule in the chain, or else (if it's the last rule in the rule chain) by the first rule in the chain.  		The last ruleform in a rule chain must be represented by an instance of UntilEndOfYearTimeZoneTransition.  The other ruleforms in a rule chain may be instances of either UntilAnnualDateTimeZoneTransition or UntilAnnualDayOfYearTimeZoneTransition.	Implementation:		Insance Variables			interYearPolicy	&lt;TimeZonePolicy&gt; The inter-year TimeZonePolicy of the receiver that connects the receiver to the full diachronic ruleset of the instance's time zone.			boundTZ		&lt;StandardTime | NonStandardTime&gt; The "bound, dynamic" ChronosTimezone that specifies the abbreviation and offset from UT that apply within the territorial domain of that time zone while the time zone ruleform represented by the instance is in effect.			leftLink 			&lt;AnnuallyRecurringTZPolicy | nil&gt;	The AnnuallyRecurringTZPolicy that was in effect before the instance's offset/abbreviation tuple came into effect.	Subclassing:		Concrete subclasses must subimplement the following methods:			#asAnnuallyRecurringTZPolicyFactory			#printTranstionRuleOn:</body></comment><class><name>IntraYearTimeZoneTransition</name><environment>Chronos</environment><super>Chronos.AnnuallyRecurringTZPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightLink relativity transitionSecondsSinceStartOfDay </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-Policies-Annual</category><attributes><package>Chronos-TimeZones-Policies-Annual</package></attributes></class><comment><class-id>Chronos.IntraYearTimeZoneTransition</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})IntraYearTimeZoneTransition	Concept:		An IntraYearTimeZoneTransition is an abstract subclass of AnnuallyRecurringTZPolicy.  An instance of a concrete subclass of IntraYearTimeZoneTransition functions as any but the last/final ruleform in the rule chain that specifies the offset/abbreviation tuples that apply within the territorial domain of a time zone during every moment of the year. The ruleform represented by a IntraYearTimeZoneTransition instance expires at some annually-recurring intra-year date and time (any of local time, local "standard time," or Universal Time may be used  to designate the moment of expiry of the predecessor ruleform and transition to the successor ruleform.) 		See the superclass AnnuallyRecurringTZPolicy for more information.	Motivation:		Chronos represents offset/abbreviation transitions using annually-recurring dates, instead of following in the path of UNIX and using an exhaustive list of every transition specified as occurring at some absolute number of seconds since an epoch, for two independent reasons:			1. To minimize memory usage--enough said.			2. To make the representation of the moments of transition be independent of any particular timesale--in other words, to make them neutral with respect to leap seconds--a property which the source Olson time zone rules have, but the zic-generated binary time zone files do not..	Implementation:		Instance Variables  {Also see superclass}			rightLink 							&lt;AnnuallyRecurringTZPolicy&gt;	The AnnuallyRecurringTZPolicy that takes effect when the instance expires.			relativity 							&lt;Symbol&gt;	If relativity == #nominal, then the instance's moment of expiry/transition-to-successor is designated in local ("wall clock") time; if relativity == #standard,  then the instance's moment of expiry/transition-to-successor is designated in local "standard time" (without DST;) if relativity == #universal, then the instance's moment of expiry/transition-to-successor is designated in Universal Time.			transitionSecondsSinceStartOfDay 	&lt;Integer&gt;	The time of day, expressed as a number of seconds since the start of the day (0..86399,) when the ruleform represented by the instance expires and the transition to its successor (the &lt;nextLink&gt;) takes place. Specification/representation of the annually-recurring intra-year date on which the instance's ruleform expires is the responsibility of concrete subclasses.	Subclassing:		Concrete subclasses must subimplement the following instance methods:			#maxDaysFromStartOfYearUntilTransition			#minDaysFromStartOfYearUntilTransition			#transitionDayOfWeekInYear:			#transitionOccursOnOrAfterYear:dayOfYear:relativity:secondsSinceStartOfDayFunction: </body></comment><class><name>ChronosObject</name><environment>Chronos</environment><super>Passport.Immutable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.ChronosObject</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosObject	Concept:		ChronosObject is an abstract class from which most of the classes in the Chronos Date/Time library inherit a small set of standard/foundational protocol/behavior.	For details, see the method comments.	</body></comment><class><name>ChronosTimezone</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.ChronosTimezone</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosTimezone [Aliased by the global Timezone]	Concept:		ChronosTimezone is an abstract class; an instance of one of its concrete subclasses represents/implements a particular timezone. A timezone defines the civil/legal time-of-day for a particular locality (some legal jurisdiction, from as small as a city to as large as a nation-state.) Local time-of-day in a timezone is defined as some number of seconds of offset (positive or negative) from the local time-of-day in the international standard reference timezone.  For a timezone whose offset from the international reference timezone is negative 5 hours, the local time in that timezone would be 6 am when the local time of day in the international reference timezone is 11 am.  For more information on the origin and conceptual evolution of timezones, see the HISTORY section below.		Universal Time (abbreviated UT) has been the official name of the international standard zero-offset reference timezone since 1928.   This reference timezone was originally called Greenwich Mean Time (abbreviated GMT.)  Common usage is to use either GMT or UTC as the name of the international zero-offset reference timezone, in spite of the fact that neither is the formally correct name (the name GMT has been superceded by UT, and UTC is technically the abbreviation of a timescale, not a timezone.)  		Other than in comments such as this one, Chronos does not use the term "GMT." With but one exception, Chronos always uses either "Universal Time" or "UT" to refer to the international reference zero-offset timezone. Other than the name of the message #asUTC (whose name and semantics are mandated by the ANSI-Smalltalk Standard,) Chronos uses "UTC" solely as the abbreviation of the timescale "Coordinated Universal Time." The UTC timescale defines a second as an SI (metric system) second (which defines the temporal extent of one second in terms of the vibrational frequency of a particular type of atom under specific conditions,) and requires that a leap second occasionally be added to or removed from the number of seconds in a day in order to keep the UTC time-of-day to within 0.9 seconds of the UT1 time-of-day (in UT1, each day is a mean solar day of exactly 86400 seconds.) For more information on this subject, see the section on TIMESCALES presented below.		Chronos supports both "simple" timezones whose UT-offset is some invariant number of seconds, and also "complex" timezones whose UT-offset varies over time.  Variable-offset timezones may not only use different UT-offsets within a year, but may also use different rules in different years to determine the moments of transition to or from Daylight Saving Time.  See the "INVARIANT-OFFSETS AND VARIABLE-OFFSETS FROM UNIVERSAL TIME" section immediately below for more details.		Timezones are far from as simple as you probably imagine.  However, those who don't require sub-second time accuracy, and who don't care about points-in-time that occur all that far in the future or the past, may need to know nothing more than a) how to catalog all available pre-defined ChronosTimezones, b) how to instantiate a point-in-time value whose local time will be defined by a particular ChronosTimezone, and c) how to set the default ChronosTimezone to whatever the local timezone happens to be.  That information is provided in the "Usage:" section (far) below.  Everyone else is strongly encouraged to read the entire "Concept:" section of this class comment.		## INVARIANT-OFFSETS AND VARIABLE-OFFSETS FROM UNIVERSAL TIME			Chronos supports both "simple" timezones whose offset from UT never varies (from the infinite past into the infinite future) and also "real world" timezones whose offsets from UT may vary over time (diachronic offset rules.)  The simple, invariant-offset timezones are implemented by BasicTimezone.  The "real world," variable-offset timezones are implemented by VariableOffsetTimezone (both of which see.)			BasicTimezone provides an invariant offset from UT (no DST rules,) an invariant name (optional) and an invariant abbreviation (optional.)  It is provided for two reasons: 1) simplicity/performance, and 2) compatibility with the way the ANSI-Smalltalk Standard defines the timezone behavior of instances of DateAndTime. The ANSI Standard makes the (generally false) assumption that a timezone can be specified as a Duration.  Although using an invariant Duration (offset) to define a timezone can work quite well under certain conditions, it is a very poor model of the way timezones usually work in practice.			Generally, people don't conceptualize a timezone as a fixed offset from universal time.  They conceptualize a timezone as the local time at a particular location.  When you have an appointment to meet someone for some purpose at 1pm, the meaning of "1pm" is defined by the a) the location of the meeting, and 2) the legal definition of the time of day at that location at that moment in time.  Both the location and the moment in time are required in order to determine the offset from UT that will be in effect at a given location at a given time. For example, consider the following questions: If there is an event scheduled to occur (or that did occur) at "1pm" in Lihue, Hawaii (on the island of Kauai,) what is the offset from UT? What would be the date and time 100 hours later? 			Even though Daylight Saving Time is not observed in Hawaii, the answer nevertheless depends on the date--and perhaps even on the time-of-day.  Before 1947-06-08T02:00:00 HST, the offset from UT would be -10:30 (hours:mintues,) on or after that moment it would be -10:00.  So an event that occurred at 1947-06-07T13:00:00 HST would correspond to 1947-06-07T23:30:00 Universal Time--and 100 hours later would be 1947-06-11T17:30:00 HST (1947-06-12T03:30:00 UT)--5:30pm local time, 3:30am UT.			Consider also this: Hawaii could decide to start observing Daylight Saving Time at some point in the future--or the US Congress could decide that for them.  Consequently, it is not at all a guaranteed fact that the local time in Hawaii of some point-in-time in the future will have an offset from UT of -10 hours. So using "-10 hours" as the invariant offset of points-in-time for events in Hawaii will not only be wrong for moments prior to 1947-06-08T02:00:00 HST, it may also be wrong for moments in the future.  			The preceding examples demonstrate why Chronos supports not only timezones whose offsets from UT may vary "intra-year" (which is typical of the way Daylight Saving Time works,) it also supports timezones whose "standard time" offset, abbreviation or DST transition rules may vary from one year to the next.  By specifying Hawaii's local timezone as "'Pacific/Honolulu'" instead of as "Duration hours: -10", not only will one get the correct UT-offset in effect now, one will also get the correct offsets in effect prior to June 1947, as well as whatever the correct offset may be in the future.			See VariableOffsetTimezone for more details.		## HISTORY {information that may be helpful for those who aren't already rather knowledgeable about timezones and how the time-of-day is determined)}			"Standard Time"				Before the introduction of timezones, every municipality set its clock by the local position of the sun (usually "mean solar time" in the case of cultures that were using relatively accurate mechanical clocks, or else "apparent solar time" otherwise. Local solar time (whether mean or apparent) served well until the introduction of the train, when it became possible to travel fast enough to require almost constant re-setting of clocks. Timezones were invented to solve this problem by setting all clocks in a region to the same time--which was originally called "standard time" (although modernly, "standard time" means something slightly different.) 				"Standard time" (in its original meaning) divides the world into a number of "time zones", each one covering, in theory at least, 15 degrees (one hour of solar time.) All clocks within each of these zones are (theoretically) set to the same time as the others, but so as to differ by one hour from those in the neighbouring zones. The local time at the Royal Greenwich Observatory in Greenwich, England was chosen as the international reference timezone at the 1884 International Meridian Conference, leading to the now almost-universal practice of defining local (civil/legal, but perhaps not religious) time-of-day as some number of seconds of offset from that of the Universal Time (UT) timezone. Greenwich, England was chosen because by 1884 two-thirds of all charts and maps already used it as their prime meridian.				In actual practice, the amount of offset from the international reference timezone that defines local time in a region is a political matter. The offset in actual use is far from being a simple function of the local longitude. And some timezones have (or have had) fractional-hour offsets, instead of the integer-hour ideal.				The first time zone in the world was established by British railways on December 1, 1847—Greenwich Mean Time (GMT) being hand carried on chronometers. About August 23, 1852, time signals were first transmitted by telegraph from the Royal Greenwich Observatory. Even though 98% of Great Britain's public clocks were using GMT by 1855, it was not made Britain's legal time until August 2, 1880.				On November 2, 1868 New Zealand officially adopted a standard time to be observed nationally, and was perhaps the first country to do so. It was based on the longitude 172° 30' East of Greenwich, that is 11 hours 30 minutes ahead of Greenwich Mean Time. This standard was known as New Zealand Mean Time. 				In the United States and Canada, standard time zones were introduced on November 18, 1883, by American and Canadian railroads. Newspapers referred to that day as "the Day of Two Noons." There was no legislative enactment or ruling: the railroads simply adopted a five zone system and assumed the public would follow. The American Railway Association, an organization of railroad managers, had noticed growing scientific interest in standardizing time. The ARA devised their own system, which had irregular zone boundaries which followed then-existing boundaries of different (railroad) lines, partly in order to head off government action which might have been inconvenient to their operations. Most people simply accepted the new time, but a number of cities and counties refused to accept "railroad time", which, after all, had not been made law. In, for example, the expiration of a contract--what does "midnight" mean? In one Iowa Supreme Court case, the owner of a saloon argued that he operated by local (sun) time, not "railroad time," and so he had not violated laws about closing time. Standard time remained a local matter until 1918, when it was made US Federal law as part of the introduction of daylight saving time (to save fuel for World War 1.)			"Daylight Saving Time" (also known as "Summer Time")				Daylight Saving Time is the practice of temporarily adjusting a timezone's offset to a different value--usually by adding 1 hour to the offset, and usually only during local summer (note that summer in the Southern Hemisphere happens during winter in the Northern Hemisphere.) The effect is that local time advances by one hour while Daylight Saving Time is in effect, so that what was local noon (for example) becomes 1 pm. Daylight Saving Time has been used in the United States and in many European countries since World War I. 				During World War I, in an effort to conserve fuel needed to produce electric power, Germany and Austria initiated Daylight Saving Time as of 11 pm (local standard time) on the 30th of April, 1916, by advancing the hands of the local clocks by one hour. The following October, Daylight Saving Time was terminated, and the hour-hand of the local clocks was set back by one hour. This 1916 action was immediately followed by other countries in Europe, Belgium, Denmark, France, Italy, Luxembourg, Netherlands, Norway, Portugal, Sweden, and Turkey. Tasmania, and Manitoba.and Britian began "saving daylight" 3 weeks later, on 21 May 1916. In 1917, Australia, Newfoundland and Nova Scotia also began the practice. 				Daylight Saving Time was not formally adopted in the United States until 1918. 'An Act to preserve daylight and provide standard time for the United States' was enacted on 19 March 1918. It both established standard time zones and set summer DST to begin on 31 March 1918. Daylight Saving Time was observed for seven months in 1918 and 1919. After the War ended, the law, however, proved so unpopular (mostly because people rose earlier and went to bed earlier than we do today) that the law was later repealed in 1919 over President Wilson's veto. It became a local option, and was continued in a few states (Massachusetts, Rhode Island) and some cities (New York, Philadelphia, Chicago, and others).				During World War II, President Roosevelt instituted year-round Daylight Saving Time, called 'War Time' (e.g., "Eastern War Time" or "EWT,' "Pacific War Time" or "PWT.") "War Time" was in effect from 2 February 1942 to 14 August 1945, when its name was changed to "Peace Time" (but the offset wasn't changed back to "standard time" until 30 September 1945.).  				From 1945 to 1966, there was no federal law about Daylight Saving Time. So states and localities were free to choose whether to observe Daylight Saving Time or not, and could choose when it began and ended. This, however, caused confusion--especially for the broadcasting industry, and for railways, airlines, and bus companies. Because of the different local customs and laws, radio and TV stations and the transportation companies had to publish new schedules every time a state or town began or ended Daylight Saving Time.				Since the introduction of Daylight Saving Time, the term "standard time" has been redefined; it now refers to the local time defined by a time zone when Daylight Saving Time is not in effect (originally, it meant the canonical time to which all clocks in a time zone were set--a better term for that concept nowadays would be simply 'local time.')		## TIMESCALES {important technical information for those interested in the precise meaning of certain terms, such as GMT, UT1, UTC, timezone and timescale--others may skip this section}			To unambigously specify a well-defined moment in time in the terrestrial reference frame (especially with accuracy to the second or better,) a temporal coordinate must not only specify an extent of time since an epoch (the zero-point of the coordinate system used to designate a point-in-time value,) it must also specify both a timescale and a timezone.  			A timescale specifies the moment that serves as the origin point for the coordinate system used to designate temporal coordinates (the timescale's epoch,)  and also specifies the size of the time units used to count or measure extents of time since (or until) the epoch (zero point) of the timescale.  It also defines the zero-point of the time-of-day clock.			Timezones specify a number of seconds by which temporal coordinates (point-in-time values) are translated with respect to the epoch of their timescale, and so define translated timescales.  Timezones always maintain gauge-invariance--they only involve addition of a well-defined number of seconds (which may be negative,) never any gauge-changing multiplications or divisions which would change the size (gauge) of any time units.  Conversely, a timescale may define different gauges (time unit sizes) that apply during different intervals within the coordinate system defined by the timescale--in fact, the sizes of a timescale's time units may be defined by complex functions, so that they differ continuously (e.g., apparent solar time.).			The timescale of a Chronos point-in-time value (a conceputal value) is defined partly by its Calendar (which see,) and partly by a Timescale instance (once that gets implemented, which it currently is not--and until it is, the only supported timescale is UT1.) The Calendar of a Chronos point-in-time value defines the size of its day, month and year time units (a Calendar's day is a mean solar day,) and also defines the epoch of its timescale to the nearest day. The Timescale of a Chronos point-in-time value (an object--once it is implemented, which it currently is not) defines the size of one second, the number of seconds in a day (which may or may not differ from day to day, depending on the Timescale,) and defines the reference coordinate system by means of which the time-of-day of a point-in-time value may be unambigously specified in the terrestrial reference frame.			Universal Time (UT,) and any other timezone, can be used with any terrestrial timescale that uses Greenwhich Mean Time (directly or indirectly) to establish the zero-point of the time-of-day clock.  Were such not the case, it would be impossible for any country that didn't use the UTC timescale to define its timezones as offsets from Universal Time--and not all countries use the UTC timescale as the basis for their civil time-of-day, even though they all define their timezones as offsets from Universal Time. Universal Time is simply the timezone whose offset from the specific timescale of one's choice (UT0, UT1, UTC, etc) is an invariant 0.0 seconds.			Unfortunately, the names of specific timezones and/or timescales ("GMT," "UT," "UTC,") tend to be used to refer either to a timezone, or to a timescale, which leads to much confusion and bogosity.  To help clarify matters, and also to establish the technically correct meanings (which are often different than colloquial usage,) the following history and explanation of timescales should prove helpful:			In 1884, at the International Meridian Conference, GMT was officially adopted as the international reference timezone and timescale. At the time, no conscious distinction was made between a timezone and a timescale--because everyone at the conference was using mean solar time as the timescale of their timezones, viewed a timescale based on apparent solar time as a barbarous anachronism, had never heard of or imagined atomic clocks, and so saw no need to think about timezones and timescales separately.			In 1928, the International Astronomical Union (IAU) changed the official name of the international zero-offset reference timezone from Greenwich Mean Time (GMT) to Universal Time (UT) for English speakers, Temps Universel (TU) for French speakers, and Welt Zeit (WZ) for German speakers.  However, the habit of using the name of the international reference timescale as a synonym for the international reference timezone (or vice versa) was very strongly entrenched--due to the fact that the initial definition of GMT meant both or either--and so GMT continued to be used as the name for both the timezone and the timescale--a habit that continues to this day. 			In 1956, the timescales UT0 (mean solar,) UT1 (UT0 corrected for polar motion) and UT2 (UT1 corrected for predictable seasonal variations) were defined by the International Astronomical Union (IAU), with UT1 simply being a new name for the GMT timescale as it was defined in 1956 (GMT had originally used a less-rigourously-defined version of what is now called UT0.) In 1960, the Conférence Générale des Poids et Mesures (CGPM,  "General Conference of Weights and Measures") adopted the names and definitions of these timescales as international standards. Here we finally see recognition of the need to think (and speak) about timescales separately from timezones. The fact that atomic clocks had been in operation since 1949 may have had something to do with this.			Also in 1956, the International Committee for Weights and Measures, under the authority given it by the Tenth General Conference on Weights and Measures in 1954, defined the second in terms of the period of revolution of the Earth around the Sun for a particular epoch, because by then it had become recognized that the Earth's rotation on its own axis was not sufficiently uniform as a standard of time. The Earth's motion was described in Newcomb's Tables of the Sun, which provides a formula for the motion of the Sun at the epoch 1900 based on astronomical observations made during the eighteenth and nineteenth centuries (also known as the "Equation of Time.") The second thus defined is the fraction 1/31,556,925.9747 of the tropical year for 1900 January 0 at 12 hours ephemeris time. This definition was ratified by the Eleventh General Conference on Weights and Measures in 1960. Reference to the year 1900 does not mean that this is the epoch of a mean solar day of 86,400 seconds. Rather, it is the epoch of the tropical year of 31,556,925.9747 seconds of ephemeris time. Ephemeris Time (ET) was defined as the measure of time that brings the observed positions of the celestial bodies into accord with the Newtonian dynamical theory of motion. Consequently, for the first time, the second became (by official definition) an extent of time of invariant size. However, seconds with invariant size and days containing an invariant 86400 seconds are not at all consistent with keeping time according to the sun--because the Earth's rotational speed is not a constant.  But this problem was not addressed in 1956. [Measuring time is so simple! Why is this lengthy class comment necessary?!]			In 1959, the first atomic time scale was constructed by the USNO and was extrapolated back to 1956. It was named A.1. It was set equal to the UT2 point-in-time of the USNO as of 1958-01-01. In 1961 the BIH constructed a time scale named AM using radio broadcasts based on three atomic clocks. This was renamed A3, more clocks were added from 1967 through 1969, new statistical algorithms were employed, and the name became TA. This series of time scales has been extrapolated back into 1955 using broadcast time signals based on the original cesium clock at NPL. In 1971 the BIH atomic time scale became TAI (Temps Atomique International.) By the mid 1970s it was evident that the scale unit of TAI was not equal to the SI second at sea level. On 1977-01-01 the frequency of TAI was reduced by one part in 1012, and the frequency of TAI has been steered since that time. Starting 1977-01-01 the un-steered combination of atomic clocks which had formerly been TAI has been known by the new name EAL. By 1995 it was evident that blackbody radiation was affecting the frequency of cesium clocks, and that the true SI second should be measured at 0 Kelvin. Over the interval from 1995 to 1998 the length of the TAI second was decreased by about 2 parts in 1014 until it corresponded as closely as possible to cesium atoms at absolute zero. [Measuring time is so simple! Why is this lengthy class comment necessary?!]			In 1965, the Bureau International de l'Heure (BIH) developed a UT-like time scale from its atomic time scale, A3, and called it "UTC."  In 1967, at the IAU's 13th General Assembly, the Commissions on Ephemerides and Time Scales approved the name "Coordinated Universal Time" (UTC) for this new timescale.			In 1967 the Thirteenth General Conference on Weights and Measures defined the second of atomic time in the International System of Units (SI) as the duration of 9,192,631,770 periods of the radiation corresponding to the transition between the two hyperfine levels of the ground state of the caesium-133 atom. The ground state is defined at zero magnetic field. The definition of the second was later refined at the 1997 meeting of the BIPM to append the statement "This definition refers to a caesium atom at rest at a temperature of 0 K." The second thus defined is equivalent to the ephemeris second, although its (now invariant) size became even more precisely and universally defined (measurement of the Earth's motion were no longer necessary.) But the conflict between the number of invariantly-sized seconds in a day and the definition of the day as invariantly 86400 seconds was not addressed in 1967.			In 1971 the Conférence Générale des Poids et Mesures (General Conference of Weights and Measures) officially recognized the Atomic Time Scale and endorsed the BIH (now BIPM) time scale as the International Atomic Time Scale, TAI. Since the first of January 1972, most countries in the world have distributed the Atomic Time Scale. TAI is generated from data from hundreds of atomic clocks kept by laboratories around the world. Timing centers from many countries regularly contribute data to BIPM. The Consultative Committee on Radiocommunications of the International Telecommunications Union developed a scale for broadcast time signals based on TAI.  This new scale was named Coordinated Universal Time (UTC). It was defined by saying that at the beginning of 1 January 1972, UTC would be exactly 10 seconds behind TAI--but the points-in-time at which any of these 10 leap seconds should be inserted have never been specified. 			In 1975 the Conférence Générale des Poids et Mesures endorsed UTC and recommended that civil clock time be based on it. Today, the UTC timescale is the official basis for civil time in most (but not all) nations of the world. 			In order for UTC to match the Earth's rotation, some compensation for the irregularities in that rotation must be made, because there are not an invariant 86400 SI (atomic clock) seconds in a solar day.  Without corrections, the sun at noon would gradually drift from being overhead.  Prior to 1972, broadcast time services had kept in step with the Earth's rotation by subtly varying the frequency they broadcast.   For UTC, the frequency was to be held constant. Corrections are made only by adding or subtracting a whole number of seconds, to prevent UTC from differing by more than 0.7 (initially,) but now 0.9, seconds from TAI. The Bureau Internationale des Heures announces when a leap second is to be added or subtracted from UTC.  Since the Earth's rotation is slowing, it is usually necessary to add a second. The change is usually made at the last moment of June or December, but may also be made at the end of March or September. Unless the definition of either the SI second or of the UTC timescale is changed, leap seconds will eventually have to be added with ever greater frequency--at the end of any month, then at the end of any day (by about the year 52,000 Gregorian,) and in the far distant future more than one per day.			As currently specified, the UTC timescale defines the day as having either 86399, 86400 or 864001 SI seconds, and is equivalent to UT1 ("GMT") to within a tolerance of +/- 0.9 SI seconds.  Which days have which number of SI seconds is decided by the International Earth Rotation and Reference Systems Service, who publish advance notice whenever their astronomical observations and calculations show that it is necessary to add or remove a leap second. In a very real sense,  with respect to the number of seconds in a day, this makes the UTC timescale an observational one.  In contrast, UT1 (mean solar time) is observational with respect to the temporal extent of days and seconds, but not with respect to the number of seconds in a day.	Usage:		## TIMEZONE KEYS			In most cases, ChronosTimezones are uniquely identified by a well-known globally-defined key. The key of a ChronosTimezone whose offset is an invariant number of seconds from UT is simply the number of (possibly fractional) seconds in its offset (unless it's the time zone for Universal Time--see below.)   They key of a ChronosTimezone whose offset varies over time is a Symbol.  And the keys of a few other `special` time zones are also Symbols, as will be explained below. As delivered by the author, all persistently-stored, globally-well-known variable-offset time zones (and their keys) are as defined by the Olson Timezone Database (the same one used by UNIX.) The Olson time zone keys usually (but not always) have the form &lt;continent&gt;/&lt;city&gt; or &lt;ocean&gt;/&lt;city&gt;, such as 'Europe/London', 'Asia/Calcutta' or 'Pacific/Auckland'. However, clients of Chronos are allowed to define their own variable-offset time zones having any desired key--which do not have to be globally well known, and do not have to be persistently stored in the Chronos time-zones repository. 					The time zone key #system is used by Chronos whenever it constructs a variable-offset timezone as an analog or emulation of the base system's local timezone. The key #system may not even be unique within an image, let alone globally.  Variable-offset time zones created by Chronos to emulate or model the local time zone of the host system are not persistently stored in Chronos' external time-zones repository.			The canonical key of the timezone whose proper name is Universal Time is #'Universal Time'.  However, a variety of aliases are supported: #Universal, #UT, #UTC, #GMT, #Z and #Zulu. 			To retrieve the keys of all the time zones resident in Chronos' repository of pre-defined time zones, inspect the result of evaluating 'ChronosTimezone allRegisteredKeys' (if there are none, then the Chronos time-zones repository is missing.)			To see the current time in all the time zones resident in Chronos' repository of pre-defined time zones, (showing the key, current offset, and current abbreviation for each time zone,) inspect the result of evaluating 'Timepoint nowInAllTimeZones' (if there are no entries, then the Chronos time-zones repository is missing.)		## TIMEZONE LOOKUP/RETRIEVAL BY (CANONICAL CHRONOS) KEY			To retrieve a ChronosTimezone with a given Chronos timezone key, evaluate 'ChronosTimezone at: &lt;key&gt;', where &lt;key&gt; is either the number of seconds of offset from UT (a Number) or is one of the Symbols contained in the Set returned as a result of evaluating 'ChronosTimezone allRegisteredKeys.'  In place of the Symbol, one may instead use the equivalent String value.  			The class message ChronosTimezone class&gt;&gt;referencedBy: can be used to convert the value passed as its argument into a ChronosTimezone in cases where the value might be a) a String, b) a Symbol, c) a Number, d) a Duration instance or e) a ChronosTimezone instance {"ChronosTimezone referencedBy: 0". "ChronosTimezone referencedBy: 'Europe/London'"}.			The Universal timezone can be accessed by sending either #universal or #ut as messages to ChronosTimezone {Timezone universal}.			Examples:				Timezone universal.								"Timezone for Universal Time. 'ChronosTimezone ut' can also be used."				Timezone referencedBy: Duration zero.			"Equivalent to 'ChronosTimezone universal'--but not identical"				Timezone at: -25200.								"-7 hours--never any DST."				Timezone at: 19800.								"+5.5 hours--never any DST."				Timezone at: 0.9d.								"+0.9 seconds--never any DST."				Timezone at: 'America/Vancouver'.				"Pacific Time with DST rules as observed (past, present, future) in Western Canada"				Timezone at: #'America/Tijuana'.					"Pacific Time with DST rules as observed (past, present, future) in North Western Mexico"				Timezone at: 'America/Los_Angeles'.				"Pacific Time with DST rules as observed (past, present, future) in the Western US"				Timezone at: #'America/Phoenix'.					"US Mountain Time in Arizona--No DST since 1969"				Timezone at: 'America/Denver'.					"US Mountain Time"				Timezone at: #'America/Chicago'.					"US Central Time"				Timezone at: 'America/Indiana/Indianapolis'.		"US Eastern Time in most of Indiana--No DST since 1971"				Timezone at: #'America/New_York'.				"US Eastern Time with DST rules as observed in much of the US East Coast"		## VARIABLE-OFFSET TIMEZONE LOOKUP/RETRIEVAL BY ABBREVIATION OR OFFSET			The familiar timezone abbreviations are not unique on a world-wide basis.  However, a ChronosLocale provides a TimeZoneLocalizationPolicy that maps timezone abbreviations and offsets to a Chronos timezone, as is appropriate to a particular locale (e.g., the TimeZoneLocalizationPolicy provided by &lt;ChronosLocale at: 'en_US'&gt; maps the timezone abbreviation 'EST' to 'America/New_York', whereas the TimeZoneLocalizationPolicy provided by &lt;ChronosLocale at: 'en_AU'&gt; maps 'EST' to a timezone in Eastern Australia.) 			A TimeZoneLocalizationPolicy will generally map a timezone offset or abbreviation to a timezone whose standard time offset from UTC is probably correct, and whose DST offset is probably correct, but whose rules for transitioning to and/or from DST may be wrong (perhaps currently, perhaps in the past, perhaps in the future).  A pertinent example: the DST transition rules for 'America/New_York' and 'America/Detroit' have not always been the same, even though both have the abbreviation "EST" and have the same standard time and DST offsets.  When using a TimeZoneLocalizationPolicy to map an abbreviation or an offset to a well-defined timezone, one can (in fact, must) specify a boolean preference for either a timezone that does, or does not, observe daylight saving time (also known as "summer time" in many parts of the world):			TimeZoneLocalizationPolicy unitedStates 				defaultTimeZoneKeyForStandardTimeOffsetSecondsFromUT: (Duration hours: -5) asSeconds				dstPreferred: false				ifAbsent: [].			(Timezone atAbbreviation: #AST inLocale: ChronosLocale unitedStates dstPreferred: true ifAbsent: []) name			(Timezone atAbbreviation: #AST inLocale: ChronosLocale unitedStates dstPreferred: false ifAbsent: []) name			(Timezone atAbbreviation: #EST inLocale: ChronosLocale unitedStates dstPreferred: true ifAbsent: []) name			(Timezone atAbbreviation: #EST inLocale: ChronosLocale unitedStates dstPreferred: false ifAbsent: []) name			(Timezone atAbbreviation: #EST inLocale: (ChronosLocale at: 'en_AU') dstPreferred: true ifAbsent: []) name			(Timezone atAbbreviation: #EST inLocale: (ChronosLocale at: 'en_AU') dstPreferred: false ifAbsent: []) name			(Timezone atAbbreviation: #CST inLocale: ChronosLocale unitedStates dstPreferred: true ifAbsent: []) name			(Timezone atAbbreviation: #MST inLocale: ChronosLocale unitedStates dstPreferred: true ifAbsent: []) name			(Timezone atAbbreviation: #MST inLocale: ChronosLocale unitedStates dstPreferred: false ifAbsent: []) name			(Timezone atAbbreviation: #PST inLocale: ChronosLocale unitedStates dstPreferred: true ifAbsent: []) name			(Timezone atAbbreviation: #PST inLocale: ChronosLocale unitedStates dstPreferred: false ifAbsent: []) name			(Timezone atAbbreviation: #AKST inLocale: ChronosLocale unitedStates dstPreferred: true ifAbsent: []) name 			(Timezone atAbbreviation: #HAST inLocale: ChronosLocale unitedStates dstPreferred: true ifAbsent: []) name			(Timezone atAbbreviation: #HAST inLocale: ChronosLocale unitedStates dstPreferred: false ifAbsent: []) name			See ChronosLocale and TimezoneLocalizationPolicy for more information.		## LOCAL TIME: THE DEFAULT TIMEZONE &amp; THE SYSTEM TIMEZONE			Chronos supports two separate definitions of "local time." There is local time according to the host operating system, and local time as defined by clients of Chronos. Although it would normally be the case that a Chronos client would want to have the same local time as the operating system on which it runs, there are situations where that is not so.  For example, a stock-trading application might need to define it's local time to be 'America/New_York', even though the user's computer resides in 'Australia/Perth'.  Or perhaps an application hosted on a web server in 'Asia/Calcutta' wants to let each logged-in user define his or her own local time to be any timezone defined in Chronos' timezone repository. To support such use cases, Chronos defines a system timezone and a default timezone.			In order for Chronos to permit its view of "local time" to differ from that of the host system, it is absolutely necessary for Chronos to nevertheless know which timezone the host system is using to define local time. The reason is simply because the system clock on some systems keeps and reports time relative to the system's local timezone; and when that is the case, it is necessary to know the system timezone in order to know the meaning of times reported by the system clock.  Also, should one's Smalltalk environment need to interoperate or collaborate with the host system, or with some foreign component or application hosted on the same system, it may be necessary to either provide dates and/or times encoded as local time as defined by the host system, or to accept and correctly interpret such values (believe it or not, using UT-relative time values as the standard for data interchange is far from a universal practice.) 			The default timezone is the one that is used by default whenever no timezone is explicitly specified. It serves as the 'implementation-defined local time' as required by the ANSI-Smalltalk Standard.  The default timezone is the one that will be used when the ANSI-Standard message #asLocal is sent to a DateAndTime value, or when the current DateAndTime is retrieved by evaluating 'DateAndTime now'.			The default timezone is accessible by sending the message #default to ChronosTimezone {ChronosTimezone default}. A ChronosTimezone will be set as the current default timezone when sent the message #beDefault {(ChronosTimezone at: 'America/New_York') beDefault}. Setting the default timezone has no affect at all on which timezone is the system timezone.			The system timezone is intended to be as congruent as possible to whatever timezone the host operating system uses to define local time. The statement says "intended" because it may not be possible to discover which timezone the host system is using to define local time, and also because the actual binding between Chronos and the host system is the responsibility of whoever ports Chronos to a particular platform. The statement says "as congruent as possible" because it may not be possible for Chronos to provide a timezone implemented so that it behaves in all respects identically to the timezone implementation used by the host system:  The ChronosSystemFacade provides an API by which a Chronos client can choose the strategy that will be used to synchronize Chronos' system timezone with the timezone used by the base/host system.  [For more information on the different system-timezone-binding strategies see ChronosSystemFacade.  The default behavior is as follows: If and only if the TZ environment variable of the current user specifies a valid Olson timezone key, the Chronos system timezone is set to the Olson timezone with that key whenever the image is restarted after a snopshot.]			The system timezone is accessible by sending the message #system to ChronosTimezone {ChronosTimezone system}.  A ChronosTimezone will be set as the current system timezone when sent the message #beSystem {(ChronosTimezone at: 'America/Chicago') beSystem}.  Setting the Chronos system timezone in this manner may or may not change which timezone the host system uses to define local time, and it may or may not change which timezone is the Chronos default timezone.  			When no timezone has been explicitly set as the default, Chronos makes the system timezone serve as the virtual default timezone--which means that &lt;Timezone default&gt; will evaluate to &lt;Timezone system&gt;, and that changing which timezone is the system timezone automatically changes which timezone is the default.  This is the situation immediately after Chronos has been installed.  However, once any timezone (other than the current system timezone) has been explicity set as the default, changing the system timezone will not affect which timezone serves as Chronos' default timezone.  To resynchronize the default and system timezones, so that changing the system timezone also changes the default, set the system timezone to be the default: &lt;Timezone system beDefault&gt;.			The effect on the host operating system of changing the Chronos system timezone is a function of the implementation of the ChronosSystemFacade [As currently implemented for VisualWorks, there is no effect on the host operating system when the Chronos system timezone is changed from within Chronos, although the native VW default TimeZone will be redefined.]  Chronos clients are encouraged to change the implementation of ChronosSystemFacade  so that it meets their specific needs (subclassing is the recommended approach.).		## ACCESSING THE CURRENT DATE/TIME IN A SPECIFIC TIMEZONE			There are a variety of messages that can be sent to any ChronosTimezone to retrieve the current date and/or time (such that the local time of the retrieved points-in-time will be as defined by the referenced timezone):												Message Signature					Type-of-return-value		Gregorain Calendar					Specified Calendar								TimeOfDay				#timeOfDayNow						#timeOfDayNowAs:					TimeOfDay				#timeOfDayNowToTheSecond		#timeOfDayNowToTheSecondAs:					YearMonthDay			#dateToday							#dateTodayAs:						DateAndTime 			#today								#todayAs:										DateAndTime			#now								#nowAs:								DateAndTime			#nowToTheSecond					#nowToTheSecondAs:							Examples (with explanations of semantics):				Expression												Semantics				Timezone default timeOfDayNow.							"Current time-of-day in the default timezone"				Timezone system timeOfDayNowToTheSecond. 			"Current time-of-day (to the second) in the system timezone"				Timezone universal dateToday.							"Current date in the Universal timezone"				(Timezone at: 'Asia/Calcutta') today.						"DateAndTime in India as of the initial moment of today's date"				(Timezone at: 'Australia/Sydney') now.						"DateAndTime at this moment in Sydney, Australia"				Timezone default nowAs: #Hebrew.						"(Local) DateAndTime at this moment according to the Hebrew Calendar"				Timezone default nowToTheSecondAs: #Ethiopic.			"(Local) DateAndTime at this moment (to the second) according to the Ethiopic Calendar" 					(The Ethiopic Calendar's time-of-day clock starts at 6am)			Timepoint class and CalendarClock both provide a similar API for retrieving the current date and/or time.		## INSTANTIATION OF DATE/TIME VALUES WHOSE LOCAL TIME IS DEFINED BY A SPECIFIC TIMEZONE			The ANSI-Smalltalk standard defines a few DateAndTime creation messages where the final message argument is a Duration whose value specifies the timezone that will define local time for the DateAndTime instance created as a result of sending the message--these ANSI-required multi-keyword messages all have the keyword "offset:" as the final message keyword.  			Chronos provides a variety of DateAndTime (and date and time-of-day) factory methods that accept a "timeZone:" argument, the value of which can be any of a) a ChronosTimezone instance, b) a Duration instance, or c) the key of any Chronos timezone (a Symbol, a String or a Number.)  			Examples (see the class methods of Timepoint and its superclasses for the complete factory-method API):				Timepoint 	utYear: 1969 month: 7 day: 20 hour: 10 minute: 17 second: 40 timeZone: #'America/Chicago'.				Timepoint 	   year: 1969 month: 7 day: 20 hour:   5 minute: 17 second: 40 offset: (Duration hours: -5).  				Timepoint 	   year: 1969 month: 7 day: 20 hour:   5 minute: 17 second: 40 timeZone: 'America/Chicago'.				Timepoint 	   year: 1969 month: 7 day: 20 seconds: 19060 nanoseconds: 677411800 timeZone: (ChronosTimezone at: #'America/Chicago'). 				Timepoint daysSinceEpoch:  718997.220601852d timeZone: (Duration seconds: -18000).				Timepoint julianDay: 2440422.720601852d timeZone: -18000.			Note that the first example specifies the time using the Universal Time date and time (the specified time is the official point-in-time when Apollo 11 landed on the Moon,) even though the Timepoint created uses US Central Time as its local time.						## PROXY TIMEZONES {"always default", "always system" and "nominal time"}				A "proxy" timezone is one that serves as an indirect reference to some other timezone.  Chronos defines three standard "proxy" timezones: &lt;Timezone alwaysSystem&gt;, &lt;Timezone alwaysDefault&gt; and &lt;Timezone nominal&gt;. Proxy timezones are useful for cases where it is desirable that the local time of a point-in-time value dynamically change to reflect whatever timezone is currently set as the local timezone.  			The precise semantics of the three standard proxy timezones are defined as follows:				&lt;Timezone alwaysDefault&gt;						Dynamically refers by proxy to whatever Timezone is currently set as &lt;Timezone default&gt;. A Timepoint with this timezone always represents the same time UT, but its local time is dynamically determined by whatever Timezone is set as the current default timezone--in other words, its UT time is invariant, but its local time varies dynamically as a function of any change to whichever timezone == Timezone default. The key of the "always default" time zone is #alwaysDefault.				&lt;Timezone alwaysSystem&gt;						Dynamically refers by proxy to whatever Timezone is currently set as &lt;Timezone system&gt;. A Timepoint with this timezone always represents the same time UT, but its local time is dynamically determined by whatever Timezone is set as the current system timezone--in other words, its UT time is invariant, but its local time varies dynamically as a function of any change to whichever timezone == Timezone system. The key of the "always system" time zone is #alwaysSystem.				&lt;Timezone nominal&gt;							Refers to no timezone at all (or to any timezone)--used as the "timezone" of Timepoints that will/should be invariant to nominal time.  A point-in-time that is invariant to nominal time represents the same LOCAL time in any and all timezones, and so compares as equal to any other point-in-time whose local (or nominal) time matches the time it nominally designates. Timepoints with any other timezone are invariant to UT, which means that their value relative to other UT-invariant Timepoints is determined by the UT point-in-time they represent, and not by their local time (UT-invariance is the semantics required of points-in-time that conform to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol.) However, for compatibility with UT-invariant Timepoints, Timepoints whose timezone is &lt;Timezone nominal&gt; also behave to some extent as though their timezone were &lt;Timezone default&gt;. So, nominal-time invariant Timepoints always represent THE SAME LOCAL TIME in any and all time zones--in other words, their LOCAL TIME ("nominal time") is INVARIANT, but the UT time they represent varies as a function of the value of 'Timezone default.'    The key of the `nominal time` time zone is #nominal.		## RETRIEVING TIMEZONE OFFSETS FROM UT (UNIVERSAL TIME) (and also other related information) 			[Definition: A timezone's offset from UT is the value that is added to the UT point-in-time in order to derive the local point-in-time in that timezone, and is also the value that is subtracted from the local point-in-time in order to derive the UT point-in-time. It is also common to refer to a time zone offset as a number of "hours east," "minutes east" or "seconds east" of UT, and to refer to its additive inverse as a number of "hours west," "minutes west" or "seconds west" of UT. POSIX time-zone rule literals are specified using "hours:minutes:seconds" **west** (not east) of UT--so the POSIX rule literal "EST5" means 'timezone whose standard-time abbreviation is EST and whose standard-time offset (west from/behind) UT is 5 hours (which corresponds to an offset that is -5 hours east (or ahead) of UT.)']			The API for retrieving the offset of a ChronosTimezone varies depending on whether the ChronosTimezone instance is "bound" or "unbound" (the same is true of a timezone's abbreviation, but not of its key or name.) A "bound" Chronos time zone is one whose single, specific offset-abbreviation tuple is or can be "bound to" (properly associated with) a specific point-in-time.  An "unbound" Chronos time zone is one that does NOT specify a single, specific offset and abbreviation that can be "bound to" (properly associated with) a specific point-in-time. 			Chronos time zones are also classified as either "static" or "dynamic." A "static" Chronos time zone is one whose offset-abbreviation tuple is not subject to retroactive changes--for a static time zone, the binding of a point-in-time value to the offset-abbreviation tuple of its time zone is permanent for all time. A "dynamic" Chronos time zone is one whose offset-abbreviation tuple (or tuples) is subject to retroactive changes--for a dynamic time zone, the binding of a point-in-time value to the offset-abbreviation tuple currently specified by its time zone is not necessarily permanent. 		 	The following table presents the ontology of Chronos time zone types, and the names of the core classes that provide concrete implementations of each of the 3 types:											Static					Dynamic						Bound				UniversalTime			StandardTime											BasicTimezone			NonStandardTime														Unbound			&lt;non-sensical&gt;			VariableOffsetTimezone			When sent the message #isBound, a "bound" ChronosTimezone will answer true, and an "unbound" ChronosTimezone will answer false. When sent the message #isStatic, a static Chronos time zone will answer true, and a dynamic Chronos time zone will answer false.			BasicTimezone instances are "bound, static" timezones, because they have exactly one offset and one abbreviation for all time, from the infinite past to the infinite future--and the binding to the offset/abbreviation tuple is not subject to future revision, it's "static" or "constant." Instances of VariableOffsetTimezone are  "unbound, dynamic" time zones, because their offset and abbreviation can vary over time (even if their present offset and/or abbreviation have always been the same from the infinite past, either or both the offset and the abbreviation are still subject to change in the future--and even the past/current offsets and abbreviations are subject to being changed dynamically.) 			++ BOUND TIMEZONE API ++					Message							Semantics				#offsetFromUT						Answers a Duration representing the timezone's offset. 				#offsetSecondsFromUT				Answers the integer number of seconds of the timezone's 														offset (ignores any subsecond fraction.)				#stdTimeOffsetFromUT				Answers a Duration representing the timezone's offset from 														UT for "standard time" (when DST is not in effect.) 				#stdTimeOffsetSecondsFromUT		Answers the integer number of seconds of the timezone's 														offset from UT for "standard time" (when DST is not in effect; 														ignores any subsecond fraction.)				#offsetDelta							Answers a Duration representing the difference between the 														timezone's effective offset and its "standard time" offset.				#offsetDeltaSeconds					Answers the integer number of seconds of the difference 														between the timezone's effective offset and its "standard time" 														offset (ignores any subsecond fraction.)				#commonAbbreviation				Answers the timezone's commonly-used abbreviation.				Note: Bound timezones also respond correctly to the API for unbound timezones; the reverse is NOT true.			++ UNBOUND TIMEZONE  API ++ 				In order to retrieve the offset and/or abbreviation that is correct for the location of an unbound ChronosTimezone (i.e., an instance of VariableOffsetTimezone) at a particular point-in-time one must use the unbound ChronosTimezone API to resolve a "bound" ChronosTimezone with the correct offset and abbreviation, and retrieve the offset and/or abbreviation from the "bound" timezone so obtained.				The search parameters needed to resolve a bound timezone are the year, day-of-year and seconds-since-start-of-day. They can be specified either as UT values or as local time ("wall clock") values.  The message signatures for resolving a bound timezone are as follows:					#bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:		"Uses local-time search parameters"					#bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:		"Uses Universal Time search parameters"				The final parameter value (following "secondsSinceStartOfDayFunction:") is a one-argument block.  If the seconds-since-start-of-day value is needed to find the bound timezone, this block will be invoked (as a 'call-back') with an argument whose value is the offset from UT in seconds for a particular bound timezone (representing a particular set of zone properties in effect during a particular period of time.)  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary (the answered seconds-since-start-of-day should be in Universal Time if the message #bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction: was sent, but in local ("wall clock") time if the message #bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction: was sent.)  The reason for the callback block is that, during some years, a timezone may have more than one 'standard time' offset from UT, and because the offset transition rules for the same timezone for the same year can be specified as UT values for the first transition, local "wall clock" time for the second transition, but as local standard time for the third transition (yes, all that stuff actually happens--timezones are NOT simple!)				See VariableOffsetTimezone for more detailed information.				Examples: 					((Timezone at: 'America/Los_Angeles')						bindingForLocalYear: 1968						dayOfYear: 119 "Sunday, April 28"						secondsSinceStartOfDayFunction: [:offsetSecondsFromUT | 7199 "1:59:59 am local time"]) offsetFromUT					((Timezone at: 'America/Los_Angeles')						bindingForLocalYear: 1968						dayOfYear: 119 "Sunday, April 28"						secondsSinceStartOfDayFunction: [:offsetSecondsFromUT | 7200 "2:00:00 am local time"]) offsetFromUT					((Timezone at: 'Europe/London')						bindingForLocalYear: 2005						dayOfYear: 86 "Sunday, March 27"						secondsSinceStartOfDayFunction: [:offsetSecondsFromUT | 3599 "12:59:59 am local time"]) offsetFromUT					((Timezone at: 'Europe/London')						bindingForLocalYear: 2005						dayOfYear: 86 "Sunday, March 27"						secondsSinceStartOfDayFunction: [:offsetSecondsFromUT | 3600 "1:00:00 am local time"]) offsetFromUT					And finally, to contrast and compare Chronos with the functionality and performance of the VW Timestamp and TimeZone--which, to be fair, were introduced long before most languages supported any equivalent functionality (although the Standard C Library provided both more and less functionality):										[| now |					now := Timepoint nominalNow.					1000000 timesRepeat:						[(Timezone system							bindingForLocalYear: now year							dayOfYear: now dayOfYear							secondsSinceStartOfDayFunction: [:offsetSecondsFromUT | now secondsSinceStartOfDay]) 										offsetSecondsFromUT + now secondsSinceEpoch]] durationToRun.					[| now | "Will only run in VisualWorks"					now := Timestamp now.					1000000 timesRepeat:						[TimeZone default convertLocalSecondsToGMT: now asSeconds]] durationToRun.						"Design/implementation from the late 1980's--which, although ancient, is not old enough to have made it into the Squeak branch of ST80."					[| now |					now := Timepoint now.					1000000 timesRepeat:						[now utSecondsSinceEpoch]] durationToRun.	Implementation:		Instance Variables			name				&lt;StringOrSymbol | nil&gt; 	The name of the timezone represented by instance--value may be nil.		Class Variables			AlwaysDefault	&lt;AlwaysDefaultTZ&gt; 		Canonical instance of AlwaysDefaultTZ (which see.)			AlwaysSystem	&lt;AlwaysSystemTZ&gt; 	Canonical instance of AlwaysSystemTZ (which see.)			BindingRegistry	&lt;IdentityDictionary&gt; 	Cache of instances of either StandardTime or NonStandardTime that are created when instances of VariableOffsetTimezone are deserialized by means of TimeZonePolicySpecs.  The cache is used to ensure that instances of VariableOffsetTimezone that are being deserialized from the time zone repository use only a single instance of StandardTime (or NonStandardTime) with the same offset and abbreviation (this is done solely to minimize memory usage--it is not an invariant required for correct operation.) The cache is cleared once the deserialization process is complete.			Default			&lt;ChronosTimezone | nil&gt;					Specifies the current default timezone that establishes what Chronos considers to be local time--if nil, then the default timezone (that establishes local time in the context of Chronos) is the current system timezone.			Nominal			&lt;NominalTime&gt; 			Canonical instance of NominalTime (which see.)			OffsetRegistry	&lt;WeakDictionary; offsetSecondsFromUT-&gt;(Duration seconds: offsetSecondsFromUT)&gt;							Cache of Durations that serve as offsets-from-UT--the purpose is to ensure that instances of VariableOffsetTimezone that are being deserialized from the time zone repository use only a single Duration instance throughout their object graphs for a given number of offset-seconds-from-UT (this is done solely to minimize memory usage--it is not an invariant required for correct operation.) The cache is cleared once the deserialization process is complete.			System			&lt;ChronosTimezone&gt;						Specifies the current system timezone--intended to correspond to whatever timezone defines/establishes local time in the context of the host system. Should always be the same object as the value of the &lt;systemTimeZone&gt; instance variable of 'ChronosSystemFacade current.'			Universal			&lt;UniversalTime&gt; 	Canonical instance of UniversalTime (which see.)	Subclassing:		Concrete subclasses must subimplement the following instance methods:			#defaultOffsetPolicy			#isBound			#key			#processBy:</body></comment><class><name>ProxyTZ</name><environment>Chronos</environment><super>Chronos.ChronosTimezone</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.ProxyTZ</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ProxyTZ	Concept:		ProxyTZ is an abstract class that provides inheritable behavior appropriate for implementing "proxy" time zones. A "proxy" timezone is one that serves as an indirect reference to some other timezone. Proxy timezones are useful for cases where it is desirable that the local time of a point-in-time value dynamically change to reflect whatever timezone is currently set as the local timezone.  		Chronos defines three standard "proxy" timezones: &lt;Timezone alwaysSystem&gt;, &lt;Timezone alwaysDefault&gt; and &lt;Timezone nominal&gt;.		For further information, see AlwaysDefaultTZ, AlwaysSystemTZ, NominalTime and ChronosTimezone.	Usage:		A ProxyTZ conforms to both the Chronos "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.	Subclassing:		Concrete subclasses must sumplimplement the instance method #delegate</body></comment><class><name>NominalTime</name><environment>Chronos</environment><super>Chronos.ProxyTZ</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.NominalTime</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})NominalTime	Concept:		The canonical instance of NominalTime is accessible by sending the class message #nominal to ChronosTimezone ("Timezone nominal.")						An instance of NominalTime implements nominal time. A point-in-time value bound to a NominalTime instance has "nominal-time-invariant" semantics. A point-in-time value with nominal-time-invariant semantics invariantly represents the same local (nominal) time in any time zone, and is therefore said to be "invariant to nominal time." In a sense, &lt;Timezone nominal&gt; refers to no timezone at all --or to any timezone of your choice.		A point-in-time that is invariant to nominal time represents the same LOCAL time in any and all timezones, and so compares as equal to any other point-in-time whose local (or nominal) time matches the time it nominally designates. Timepoints with any other timezone are invariant to UT, which means that their value relative to other UT-invariant Timepoints is determined by the UT point-in-time they represent, and not by their local time (UT-invariance is the semantics required of points-in-time that conform to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol.) However, for compatibility with UT-invariant Timepoints, Timepoints whose timezone is &lt;Timezone nominal&gt; also behave to some extent as though their timezone were &lt;Timezone default&gt;. So, nominal-time invariant Timepoints always represent THE SAME LOCAL TIME in any and all time zones--in other words, their LOCAL TIME ("nominal time") is INVARIANT, but the UT time they represent varies as a function of the value of 'Timezone default.' 		Instances of the ST-80 "Date" and "Time" classes, and also instances of the VisualWorks "Timestamp" class, have "nominal-time-invariant" semantics.  Instances of Chronos' DateSpec, DateAndTimeSpec, YearMonthDay and TimeOfDay classes are also invariant to nominal time.	Usage:		A NominalTime conforms to the Chronos "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.		The key of the "nominal time" time zone is #nominal.	Motivation:		The minor motivation for implementing nominal time invariance is for compatibility with date and time values provided by other date/time libraries that also have nominal-time-invariant behavior (an ST80 Date or Time, or a VisualWorks Timestamp, for example.)		The major motivation for implementing nominal time invariance is so that point-in-time values with nominal-time-invariance can be instantiated that specify the point-in-time of an event that occurs at the same local time in all time zones (or in some set of time zones.) Examples would be the initial moment of New Year's Day, the time that a regularly-scheduled television show begins, a schedule of the first and last momements of a company's regular shift at all locations nationally for the next year, or the moment of insertion of a "rolling" leap second.		One should take care to use point-in-time values whose time-invariance semantics are correct for the situation at hand.  Getting this wrong is a significant source of bogosity in computer code that deals with time. 		Consider the following examples:			1. "Misusing Universal Time Invariance: Christmas Day does NOT include Christmas Day for all time zones (if only you had a dollar for every bug analogous to this one...)"				| christmasDay |				christmasDay := 					Timeperiod 						startingAt: (Timepoint year: 2005 month: 12 day: 25 hour: 0 minute: 0 second: 0 offset: (Duration hours: -5) " &lt;-- The arrow points to the problem") 						duration: (Duration days: 1).				Array					with: (christmasDay includes: ((Timepoint year: 2005 month: 12 day: 25  hour: 21 minute: 0 second: 0 offset: (Duration hours: -8))))					with: (christmasDay includes: ((Timepoint year: 2005 month: 12 day: 25  hour: 12 minute: 0 second: 0 offset: (Duration hours: 0))))					with: (christmasDay includes: ((Timepoint year: 2005 month: 12 day: 25  hour: 0 minute: 0 second: 0 offset: (Duration hours: 10))))			2. "Correctly Using Nominal-Time-Invariance: Christmas Day DOES include Christmas Day for all time zones (I don't have any dollars for you, but I do have a simple fix for the problem demonstrated above)"				| christmasDay |				christmasDay := 					Timeperiod 						startingAt: (Timepoint year: 2005 month: 12 day: 25 hour: 0 minute: 0 second: 0 timeZone: Timezone nominal " &lt;-- The arrow points to the solution") 						duration: (Duration days: 1).				Array					with: (christmasDay includes: ((Timepoint year: 2005 month: 12 day: 25  hour: 21 minute: 0 second: 0 offset: (Duration hours: -12))))					with: (christmasDay includes: ((Timepoint year: 2005 month: 12 day: 25  hour: 0 minute: 0 second: 0 offset: (Duration hours: 0))))					with: (christmasDay includes: ((Timepoint year: 2005 month: 12 day: 25  hour: 21 minute: 0 second: 0 offset: (Duration hours: 12))))				</body></comment><class><name>RangeConstraint</name><environment>Chronos</environment><super>Passport.Immutable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>semanticKey rangeViolationHandler minValidValue maxValidValue </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.RangeConstraint</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})RangeConstraint	Concept:		A RangeConstraint is an Immutable (which see) that implements the concept of a range constraint to be imposed on a numeric values.	Usage:		A RangeConstraint instance has a #minValidValue and a #maxValidValue.  There are instance creation methods which permit an instance to be created with any specified minimum and maximum valid values. The instance messages #minValidValue and a #maxValidValue can be sent to an instance to determine the instance's valid value range. In the case of #minValidValue, nil is interpreted as negative infinity. In the case of #maxValidValue, nil is interpreted as positive infinity.		Optionally, an instance can be instantiated with a #semanticKey.  The #semanticKey is used to identify the semantic role, function, purpose or usage of the instance. For example, a RangeConstraint instance  might be instantiated by evaluating 'RangeConstraint semanticKey: #GregorianMonthOrdinals minValidValue: 1 maxValidValue: 12.'  Sending the message #semanticKey to the instance would return the Symbol #GregorianMonthOrdinals. If the Symbol #GregorianMonthOrdinals is a well-known key, it would serve to identify the semantics (meaning, purpose, function) of the instance as a range constraint for valid ordinals of months in a Gregorian date.		To test whether a number is within the valid range defined by an instance, send the message #isValid: to the instance, with the number to be tested as the argument. 		To assert that a number is within the valid range defined by an instance, send the message #assertValid: to the instance, with the number to be tested as the argument. If the number is in fact within the valid range defined by the instance, nothing will happen.  However, if the assertion is false, the instance's rangeViolationHandler will be invoked (for details, see the comment for the rangeViolationHandler instance variable.)  The default rangeViolationHanlder raises an Exception.  Some of the instance creation messages permit an instance to be created with a rangeViolationHanlder provided as an argument.   	Implementation:		Instance Variables		semanticKey 			&lt;Symbol&gt;				Identifies the semantic role, function, purpose, usage of the instance.		rangeViolationHandler 	[:value :min :max | ...]	Block-3 that is invoked when the instance is presented with a value														asserted to be valid, but the value is not in the valid range defined by														the instance--the first argument is the out-of-range value, the second 														is the minimum valid value, and the third argument is the maximum valid value.		minValidValue 			&lt;Number&gt;				The minimum valid value of the range constraint that the instance enforces.	 A value of nil is treated as negative infinitiy.			maxValidValue 			&lt;Number&gt;				The maximum valid value of the range constraint that the instance enforces. A value of nil is treated as positive infinitiy.				</body></comment><class><name>ZeroSensitiveRangeConstraint</name><environment>Chronos</environment><super>Chronos.RangeConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>zeroInvalidException zeroInvalidMessage </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.ZeroSensitiveRangeConstraint</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ZeroSensitiveRangeConstraint	Concept:		ZeroSensitiveRangeConstraint is an abstract subclass of RangeConstraint. An instance of a concrete subclass of ZeroSensitiveRangeConstraint is a RangeConstraint (which see) that not only defines a numeric range constraint, but may additionally prohibit the value zero--even when zero falls inside the valid range.	Usage:		In addition to the behavior defined by RangeConstraint, a ZeroSensitiveRangeConstraint will raise an Exception when it is presented with a value asserted to be valid, but the value is zero AND zero is not a member of the set of valid values represented by the instance.  ZeroSensitiveRangeConstraint provides protocol for instantiating an instance with a) an Exception to be raised, and b) a message to be associated with that Exception, whenever an invalid zero-value is asserted to be valid.  Protocol is also provided for accessing the Exception and message.		To test whether a given value satisfies an instance's zero constraint, send the message #satisfiesZeroConstraint: to the instance, with the value to be tested as the argument.  If the set of valid values represented by the instance includes zero, sending #satisfiesZeroConstraint: will result in true being returned, regardless of the value of the argument.  However, if the set of valid values represented by the instance does NOT include zero, sending #satisfiesZeroConstraint: will result in true being returned only if the argument is not zero (if the argument is zero in such a case, the value false will be returned.)	Implementation:				Whether zero is or is not a member of the set of valid values represented by the receiver is controlled by the implmentation of the method #satisfiesZeroConstraint:, which must answer true if zero is a valid value, but false if the argument is zero and zero is NOT a valid value.  The implementation provided by ZeroSensitiveRangeConstraint itself always answer true.		Instance Variables			zeroInvalidException 	&lt;Exception&gt;	Exception that is signalled (raised) when the instance is presented with a value													asserted to be valid, but the value is zero AND zero is not a member of the set of													valid values defined by the instance.			zeroInvalidMessage 		&lt;String&gt;		Message that will be associated with the &lt;zeroInvalidException&gt; when it is signalled.	Subclassing:		Subclasses whose set of valid values does NOT contain zero should subimplement the method #satisfiesZeroConstraint: so that it returns false when invoked with an argument whose value is zero.</body></comment><class><name>NumberingPolicy</name><environment>Chronos</environment><super>Chronos.ZeroSensitiveRangeConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.NumberingPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})NumberingPolicy	Concept:		NumberingPolicy is an abstract subclass of ZeroSensitiveRangeConstraint. In addition to the functionality of a ZeroSensitiveRangeConstraint, an instance of a concrete subclass of NumberingPolicy provides an API by means of which cardinal numbers, ordinal numbers, or zeroless-ordinal numbers may be correctly interpreted and manipulated (a zeroless-ordinal number is one where the integer one less than postive one is negative one, and the integer one greater than negative one is positive one--in other words, an integer number field where zero does not exist.)		A subclass of NumberingPolicy intended to deal with zeroless-ordinal numbers (for example, year numbers in calendrical systems that don't have a year zero,) could be used to ensure that the correct result is obtained when integer values are added to and/or subtracted from a zeroless-ordinal value. For example, to subtract N years from a year in the Julian Calendar, one would use an instance of a zeroless-ordinal NumberingPolicy to a) convert the Julian year to a cardinal number, b) subtract N from the year cardinal, and then c) convert the year cardinal back into a zeroless-ordinal number.  If the starting year is the Julian year 3 AD, and we want to subtract 5 years from it, then the correct final answer would be the year 3 BC.  The math works as follows: a) Since positive Julian years are ordinal numbers, converting the year 3 into a cardinal number results in the value 2; b) Subtracting 5 from 2 results in the cardinal number -3; c) Since negative Julian years (or any other negative zeroless-ordinal numbers) happen to be cardinal numbers, converting the cardinal -3 into a zeroless-ordinal results in the year number -3.	Usage:		NumberingPolicy protocol consists of the following messages that can be sent to a NumberingPolicy instance:				Message Selector					Semantics			canonicalFromCardinal:				Answers the conversion of the cardinal number argument into the type of 												number represented by the receiver (i.e., cardinal, ordinal, zeroless-ordinal)					canonicalFromOrdinal:				Answers the conversion of the ordinal number argument into the type of 												number represented by the receiver (i.e., cardinal, ordinal, zeroless-ordinal)				canonicalFromZerolessOrdinal:		Answers the conversion of the zeroless-ordinal number argument into the 												type of number represented by the receiver (i.e., cardinal, ordinal, zeroless-ordinal)			cardinalFromCanonical:				Answers the conversion of the argument (assumed to be whatever type of 												number is represented by the receiver (i.e., cardinal, ordinal, zeroless-ordinal)) 												into a cardinal number			ordinalFromCanonical:				Answers the conversion of the argument (assumed to be whatever type of 												number is represented by the receiver (i.e., cardinal, ordinal, zeroless-ordinal)) 												into an ordinal number			zerolessOrdinalFromCanonical:		Answers the conversion of the argument (assumed to be whatever type of 												number is represented by the receiver (i.e., cardinal, ordinal, zeroless-ordinal)) 												into a zeroless-ordinal number		Conding Example:			| julianYearNumberingPolicy year |			julianYearNumberingPolicy := Calendar julian yearNumberingPolicy. 	"Get the yearNumberingPolicy of the Julian Calendar"			year:= julianYearNumberingPolicy cardinalFromCanonical: 3.			"Convert the Julian year 3 AD into the cardinal number 2" 			year := year - 5.														"Subtract 5 from the year cardinal (2), assiging the result (-3) to year"			julianYearNumberingPolicy canonicalFromCardinal: year				"Convert the year cardinal number resulting from the previous step into a zeroless-ordinal Julian year number."	Motivation:		NumberingPolicies greatly enhance the ability to correctly deal with the different conventions for numbering years used by various calendrical systems.	Subclassing:		Subclasses that implement cardinal numbering (CardinalNumberingPolicy,) ordinal numbering (OrdinalNumberingPolicy,) and zeroless-ordinal numbering (ZerolessOrdinalNumberingPolicy) are provided.</body></comment><class><name>CardinalNumberingPolicy</name><environment>Chronos</environment><super>Chronos.NumberingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.CardinalNumberingPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	CardinalNumberingPolicy: Please refer to the class comment of my superclass, NumberingPolicy</body></comment><class><name>Calendar</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clock yearNumberingPolicy secondsSinceJulianDayEpochUpToEpoch secondsSinceUnificationEpochUpToEpoch daysSinceStartOfWeekForEpochDay daysSinceStartOfISOWeekForEpochDay daysSinceStartOfANSIWeekForEpochDay minDaysPerYear maxDaysPerYear minMonthsPerYear maxMonthsPerYear minDaysPerMonth maxDaysPerMonth monthOrdinalRangeConstraint dayOfMonthOrdinalRangeConstraint dayOfYearOrdinalRangeConstraint daysSinceStartOfYearRangeConstraint monthOrdinalsByMonthKey monthKeysByMonthOrdinal monthNameKeysByMonthKey monthKeyByMonthNameKey monthOrdinalsAlwaysCorrespondToTheSameMonthKey doMonthKeysAlwaysCorrespondToTheSameMonthNameKey </inst-vars><class-inst-vars>yearNumberingPolicy </class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.Calendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})Calendar	Concept:		Calendar is an abstract class. An instance of a concrete subclass of Calendar represents and implements a particular calendrical system (or "calendar," for short.) 		A calendrical system, and therefore a Calendar instance:			* Defines an epoch date;		 (see below for the definitions of terms such as 'epoch') 			* Defines the number of days in a year--which may vary from year to year according to well-defined rules;			* Defines the number of months in a year--which may vary from year to year according to well-defined rules (TAKE NOTE!);			* Defines the number of days in each month of the year--which may vary from month to month and from year to year according to well-defined rules;			* Defines a mapping between each day-of-year ordinal and each month/day-of-month designation for a particular year--which may vary from year to year according to well-defined rules;			* Defines an algorithm by which to convert a date (year-month-day designation) into a count of days since the epoch date;			* Defines an algorithm by which to convert a count of the number of days since the epoch date into a year-month-day designation (i.e., a date.)		Definitions of Terms			A calendrical system is a system for counting time as a number of days, months and years from a "reference date."  The reference date of a calendrical system is the "zero point" from which years, months and days are counted. 'Epoch date' is the formal term for a calendrical system's reference date or "zero point"--it is usually referred to as just the "epoch" or "calendar epoch." The designation of a particular count of years, months and days from the epoch date used by a calendrical system is called a "date."  Typically (but not universally,) ordinal numbers are used to represent dates, so that a calendrical system's epoch date would be represented as 0001-01-01 (year=0001; month=01; day-of-month=01,) and would mean "zero years, zero months and zero days from the reference time of the calendar" (the ordinal number 1 corresponds to the cardinal number 0.)			For example, the epoch date (zero-point, reference date) of the modern Julian Calendar is 1-January-0001 AD (which, given that January is the first month of the Julian year, means "first day-of-month" "first month ," "first year" since the Anno Domini Era, counting years, months and days according to the rules of the Julian Calendar.) The date 1-January-2000 in the Gregorian calendar designates a count of 1999 years, 0 months and 0 days from the epoch date of the Gregorian Calendar. [Note: The Gregorian calendar is the international de facto standard calendar for civil purposes--the calendar we all use every day; the Julian Calendar is the one that was used in European nations before the Gregorian Calendar was used.]						The date on which a calendrical system comes into common or official use is called the inception date of the calendar. The epoch date of a calendar is almost always well before its inception date. A date that designates a time prior to a calendar's inception date is referred to as a "proleptic" date. "January 1, 1 AD" is a proleptic date for both the Gregorian and the modern Julian Calendars, since the epoch date of the modern Julian Calendar was first defined and used by Dionysius Exiguus in the Sixth Century AD, and the Gregorian Calendar was first defined and used in 1582 AD.  			Here are the epoch dates of various calendars, along with their translation into dates in the Gregorian and Julian calendars (Note: As required by the ANSI Smalltalk standard, Gregorian dates in Chronos use "astronomical year numbering," which means that the year before the year 0001 AD is the year 0000 AD; however, Julian year numbers follow tradition, where there is no year zero, and the year prior to 0001 is -0001):				yyyy-mm-dd [calendar]		    yyyy-mm-dd [Gregorian]	yyyy-mm-dd [Julian]				0001-01-01 [Solarian] 		= -4236-12-23 [Gregorian] = -4236-01-26 [Julian]						Winter Solstice of the year in which the Egyptian Calendar was founded;					4236 BC is the earliest recorded year in history (although -4236 is the 					translation into Gregorian/Julian Calendar years of the of the actual 					recorded date).				0001-01-01 [Hebrew] 		= -3760-09-07 [Gregorian] = -3761-10-07 [Julian]						Date of the creation of the world, according to Jewish reckoning.				0001-01-01 [Julian (Imperial)]	= -0753-12-24 [Gregorian] =  -0753-01-01 [Julian]					First day of the Julian year considered to be the year in which the City of 					Rome was founded.  In 46 B.C. Julius Caesar introduced the Imperial Julian					Calendar, replacing the ancient Roman calendar. The Imperial Julian Calendar 					set January 1 as New Year's Day, and added a leap day to the month of 					February once every four years.  However, the Romans used many different					epoch years at different times for different purposes. Whenever necessary in					order to be completely clear, the Romans would use January 1 of the year 					of the founding of Rome as the epoch date.  Imperial Julian Dates using that 					epoch were said to be dates "Ab Urbe Condita" (A.U.C.), which is Latin for 					"From the Founding of the City." 1 AUC [Imperial Julian] = 753 BC [Julian].				0001-01-01 [Julian] 			=  0000-12-30 [Gregorian] =  0001-01-01 [Julian]						First day of the Imperial Julian year 754 AUC--which is the year either before which 					(or perhaps in which--no one knows for sure) that Dionysius Exiguus reckoned 					Christ was born. During the same peroid of time that the (supposed) year of Christ's 					birth was beginning to be used as the epoch year (Sixth through the Ninth Centuries,) 					the Church took a strong dislike to using January as the first month of the year.  					Unfortunately, a variety of different days came to be used as New Year's Day (even 					though January 1 was still used for historical--and sometimes civil--purposes as the 					start of the year.) 1 AD [Julian] = 754 AUC [Imperial Julian]				0001-01-01 [Gregorian] 		=  0001-01-01 [Gregorian] =  0001-01-03 [Julian]						The Gregorian epoch date was set two days after the Julian (Dionysian) epoch date 					solely so that the date of the Vernal Equinox in the Gregorian Calendar (going forward 					from 1582) would be on or about 21 March, the same date on or about which the 					Vernal Equinox would occur when the official Church formula for computing the date 					of Easter was formally adopted at the Council of Nicaea in 325 AD.				0001-01-01 [Ethiopic] 		=  0008-08-27 [Gregorian] =  0008-08-29 [Julian]						First day of the year in the ancient Egyptian Calendar after which Christ					was born by the reckoning of the Ethiopian Orthodox Christian Church.				0001-01-01 [Indian] 			=  0079-03-22 [Gregorian] =  0079-03-24 [Julian]					The vernal equinox of the first year of the Saka Era, marking the ascension to 					the throne of King Salivahana.				0001-01-01 [Coptic] 			=  0284-08-29 [Gregorian] =  0284-08-29 [Julian]					First day of the year in the ancient Egyptian Calendar in which Diocletian 					ascended to the office of Emperor of Rome. This year marks the beginning of					what is generally known as the Diocletian Era, although Copts call it the Era 					of Martyrs in memory of the many Christians tortured to death by Emperor 					Diocletian. This year was widely used as the epoch year in Europe (along with 					the leap year rule and month structure of the Imperial Julian Calendar) until 					around the Ninth Century, when almost all Christians began to use the modern					"Anno Domini" era--with the obvious exception of the Copts.				0001-01-01 [Persian] 	=  0622-03-22 [Gregorian] =  0622-03-19 [Julian]					Vernal Equinox of the year in which the "hijra" of Mohammed to Medina					occurred ("hijra" means "flight from danger.") 				0001-01-01 [Islamic (Fatimid)] =  0622-07-19 [Gregorian] =  0622-07-16 [Julian]					Generally accepted date of the "hijra" of Mohammed to Medina ("hijra" means 					"flight from danger.")  There are some who prefer a different date in the same					year for this event.				0001-01-01 [Bahai] 			=  1844-03-21 [Gregorian] =  1844-03-09 [Julian]					Vernal Equinox of the year in which Siyyid Mírzá 'Alí-Muhammad was first recognized 					as a Manifestation of God by Mullá Husayn, and took the title "The Báb."  The Báb 					was the forerunner to Baha' Ullah, the principal figure of the Bahai religion.		Calendar Semantics			Timescale				The fundamental unit of time of any calendar system is the solar day.  Except for the issue of defining the moment that one day transitions to the next (midnight, sunrise, noon, sunset,) calendar systems are not concerned with the time of day. Calendars are responsible for converting a count days since their epoch date into a count of years, months and days (and vice-versa,) not for keeping time intra-day.  In other words, the 'time scale' of a calendrical system is always the solar day--a fundamental, universal and invariant fact about calendrical systems. Counting solar days is what calendars do, it's what they're for, it's their raison d'etre, its the justification for their existence. Consequently, issues such as 'daylight saving time' and 'leap seconds' are irrelevant to a calendrical system. Instances of Calendar, therefore, do not (and MUST not) make any adjustments to their calculations due to leap seconds, time zones or daylight saving time.  				Calendar objects deal with nominal solar days. They know and care nothing about timezone offsets or atomic clock time. Such issues are properly the responsibility of moment-in-time, timezone and/or timescale objects. 			Uniform Rule Invariance				Instances of Calendar always uniformly (without any discontinuities) implement the rules of a calendrical system from the infinite past to the infinitue future. Consequently, for dates prior to the inception date of a calendrical system, a Calendar instance expects/generates proleptic (anachronistic) dates. Such dates, especially those also prior to the epoch date, may be culturally and/or religiously objectionable in some cases.  				When necessary to avoid confusion, we will call any universally uniform, continuous calendrical system an "elemental calendrical system."				Proleptic calendrical systems will generally cause historians to complain, because their principal usage for calendrical systems is to interpret dates found in historical documents and inscriptions. This use case gives them a different perspective on calendar semantics than an astronomer, physicist or mathematician would probably have, all of whom typically use calendrical systems as tools by which to measure time, and by which to denote measuresments of time.  Historians tend to view a "calendar" as a sequence of elemental calendrical systems that were used over time by a particular culture, because the dates they encounter and must deal with come from different time periods during which different elemental calendrical systems were in common use by "the same" culture. Although each such elemental calendrical system in the diachronic sequence defines a uniform, coherent and continuous system for reckoning, encoding and interpreting dates, the "composite calendar" formed by the diachronic sequence of different elemental calendrical systems does not. But it is quite natural to perceive each such elemental calendrical system in the diachronic sequence as a variation of "the same" calendar, partly because it is used by "the same" culture, and partly because it is usually quite similar to both its predecessor and its successor.				In contrast, physicists, astronomers, mathematicians, the ISO 8601 standard for the representation of dates and times, the ANSI Smalltalk standard for DateAndTime behavior, and the Chronos Date/Time Library, all insist that a calendar, BY FORMAL DEFINITION, is a uniform, coherent and continuous system of counting the days since an epoch date as a number of years, months and days, and that any change to the rules by which such reckoning happens defines a new calendar. Consequently, Chronos holds that, by formal definition of "calendrical system," any changes to a) the epoch date, b) the number of days in a year; c) the number of months in a year; d) the number of days in any month; e) the mapping between day-of-year ordinals and month/day-of-month designations for any year; or f) the count of days from the epoch to a particular date designation, creates/defines a new calendrical system. 				The fact is, a calendrical system is best understood as a uniform, coherent and continuous system of counting days since an epoch as a number of years, months and days, such that there can be no ambiguity as to the result of converting a date designation into a count of days since the epoch, nor any ambiguity about converting a count of days since the epoch into a date designation, nor any ambiguity about the epoch date itself. The reason is because the fundamental, primary and principal purpose of a calendrical system is to define a consistent, uniform, unambigous system for the measurement of time. 				Applying the definition of calendrical system used by Chronos to a real case, we must conclude that, because their epoch dates differ, the Coptic and Ethiopic Calendars are different calendrical systems, even though they are otherwise identical.  That these two Calendars are in fact not the same is precisely what any Copt or Ethiopian will indignantly tell you, should you foolishly assert otherwise. And that's without even considering the fact that the Coptic start-of-day is sunset and the Ethiopic start-of-day is sunrise.				The fundamental truth is this: A calendrical system is not just a cultural artifact, it's also a formally well-defined system for interpreting a count of days since an epoch date as a number of years, months and days, and also for interpreting a count of years, months and days as a count of days since an epoch date. Mathematically, the counting system is applicable to any count of days since the calendar's epoch date (positive or negative,) and to any count of years, months and days (positive or negative.)  				A person who just wants to express or understand a count of time using the calendrical system with which he is familiar cares not at all whether using his preferred calendar to represent a date (that is, "to count time as a number of years, months and days, according to the rules of a calendar') would be either anachronistic or culturally out of context. For example, the fact that no one alive in what we call the year 46 BC would have labeled that year using any variation whatsoever of "negative 46" does not lessen the utility of the modern practice of labeling that year using a proleptic year ordinal (interestingly, even historians do this.)  For the same reason, when discussing events in China in the year 1000 AD, westerners (including western historians) prefer to use Julian dates, in spite of the fact that virtually no one in China at that time would have used Julian Calendar dates.  				Consider the following quotes:					"Did you know that nothing happened between 3 and 13 September 1752?" 					(http://www.didyouknow.cd/calendar.htm)					"September 1752 had only nineteen days " 					(http://www.ancestry.com/learn/library/article.aspx?article=3358)					"The year of 1752 began on March 25th and ended with December 31, 1752, 					thus the earlier days of 1752 never existed, as the deleted days of September 2--13 					also never existed. The year 1752 was a very short year; 72 days shorter, in fact." 					(http://www.crowl.org/Lawrence/time/britgreg.html)  				What these quotes are referring to is that the British Empire in the year 1752 transitioned from one calendrical system to another. In terms of the Medieval Julian Calendar (the one they transitioned from,) the year 1752 was a normal year, just like any other non-leap year in the Medieval Julian Calendar.  And 1752 was also a perfectly normal leap year in the Gregorian calendar (the one they transitioned to.)  Changing from one calendrical system to another as the official method of representing civil dates can present the appearance of abnormal years and months, but it is simply an illusion caused by changing the system of counting time, without understanding that any such change is a change of calendar, and hence a change to the system of measuring time and interpreting date designations (as opposed to a change in time itself.)  				The same sort of seemingly-amazing comparisons could be formed by considering what the recorded heights of a child would look like, when a switch is made, in the middle of the record, from Imperial units to Metric System units, when the child is 7 years of age. Clearly, nothing unusual is actually happening to the child's height.  The child does not actually experience a sudden, astonishing spurt of amazing growth, just because his height up to age 7 is recorded in inches, but his height after age 7 is recorded in centimeters. For the same reasons, 1752 was a perfectly normal year in any and all calendrical systems.				The point is that a calendar is not just a system by which dates are encoded at some point in time in some culture. A calendar also serves as a familiar/canonical measurement system by the members of a culture--which is why proleptic/anachronistic dates will be preferred by a member of a culture in cases where such a person just wants to understand (or have others understand) the meaning of a date in the past, as opposed to correctly interpreting what's written on a dusty document by a member of some historical culture. The fact that most people use dates in their native calendrical system as a canonical measure of time explains why they perceive the effects of transitioning from one calendrical system to another (e.g. Julian to Gregorian) as actually changing the length of years and/or months. Given this fact, there's nothing wrong with expressing dates using the calendrical system with which the audience is familiar, as opposed to the one that would have been natively used in the time and at the place to which the date refers. Nevertheless, many calendar programs and date/time libraries actually make proleptic dates illegal. One wonders whether the authors of such software also disapprove of using Metric System measurement units to measure, record and report the size of ancient artifacts, or to report the distances between ancient cities in Egypt?  To be consistent, they should also be in favor of requiring that  that Chinese history only be discussed in the Chinese language.  				The bottom line is that a Chronos calendar object is intended to serve as a uniform, continuous system of counting time, and is not intended to be a complete and comprehensive service for interpreting dates from historical documents and inscriptions. However, a system or application for the interpretation of dates from historical sources could certainly be built using the foundation provided by the Chronos Date/Time Library.							As a nod to the historians, one moral of this story is that when dealing with dates, one must take care to interpret them using the same calendrical system used by whoever generated/recorded/provided/specified the date. For the years 1582 in Catholic Europe and 1752 in the British Empire, this is no small problem (to use just two examples.) Nor would there be any way to define an always-correct rule to do such a thing based solely on the date itself, which is one reason for making this task the responsibility of an application, instead of the responsibility of a Calendar instance. Without an explicit specification of the calendrical system and culture, there is no reliable way to correctly interpret dates such as "02/03/784"--especially in the general case, without any context--which is exactly the situation in which a Date/Time Library such as Chronos finds itself.  Providing the necessary interpretive context is properly the responsibility of a particular application and its users.				The Julian Calendar is actually a very good example of the many issues involved in the meaning of the term 'calendrical system.' See the class comments of ImperialJulianCalendar and JulianCalendar for an in-depth discution.				The moral of the story is that dates and times are not simple--as the next sections will show even more emphatically.		Types of Calendrical Systems			There are fundamentally three different types of calendrical systems: Arithmetical, Astronomical and Observational.				Arithmetical Calendars						 Arithmetical Calendars are also known as Theoretical Calendars. An arithmetical calendar is one where:					* There is a finite and relatively small number of "year types," where a "year type" a) defines a particular way of organizing the days of a year into months/days-of-the-month, and b) defines a deterministic mapping between day-of-year ordinals and month/day-of-month designations; and					* There is an invariant, ever-repeating 'cycle of years' during which all the year types occur according to a mathematical pattern that repeats exactly every cycle. 					* The formula for determining the "year type" can be computed as a function of the year number using integer math--and does not involve or require complex astronomical calculations of the relative motion of any celestial bodies.  The year-type formula functions as a 'sieve' that, for each year, assigns that year to a particular 'cycle of years,' and then assigns each year within the 'cycle of years' to a particular year type.					The Gregorian Calendar (the de facto international standard civil calendar) is an arithmetical calendar, as are the Julian, Bahai, Coptic, Ethiopic, Fatimid (Arithmetical Islamic,) Hebrew, Indian (Civil,)  and Persian calendars. Most arithmetical calendars have only two year types: a "standard" year and a "leap" year.  The Hebrew Calendar, however, has six different year types: three with 352, 353 and 354 days per year respectively (all three of which have 12 months per year,) and three with 382, 383 and 384 days per year respectively (all three of which have 13 months per year.)			Astronomical Calendars				An astronomical calendar is one where:					* There may be a very large number of "year types," where a "year type" a) defines a particular way of organizing the days of a year into months/days-of-the-month, and b) defines a deterministic mapping between day-of-year ordinals and month/day-of-month designations; and					* There may NOT be an invariant, ever-repeating 'cycle of years' during which all the year types occur according to a mathematical pattern that repeats exactly every cycle--and if there is, the 'cycle of years' is relatively long. 					* The formula for determining the "year type" requires complex astronomical calculations of the relative motion of two or more celestial bodies, and cannot be computed as a function of the year number using integer math.				The difference between an Astronomical Calendar and an Arithmetical Calendar lies entirely in the semantics of the mathematics involved: astronomical calendars use calculations that directly model/simulate the motions of celestial bodies, and arithmetical calendars do not.				The Chinese Calendar, the religious Islamic Calendar used by Saudi Arabia and many other Islamic countries in the region, the various modern Hindu Calendars, and the French Revolutionary Calendar are examples of astronomical calendars. The initial release of Chronos does not include any astronomical calendars.  An implementation of the Chinese Calendar is planned for Chronos Release 2.0, as is an implementation of the religious Islamic Calendar (which will use the same formulae and rules as does Saudi Arabia.) Those of you who would like to use Smalltalk to compute Chinese New Year or the official dates of the Hajj will have to wait for Chronos Release 2.0.  One or more of the many variations of the Hindu Luni-Solar Calendar may also eventually be implemented.			Observational Calendars (also known as Pragmatic Calendars)				An observational calendar system is one where the number of days in a month and/or in a year (and perhaps also the number of months in a year) is determined by "real time" observation of events that regularly occur and can be empirically observed. Of course, observational calendars usually have some rules that are purely arithmetical, and not observational (e.g., a fixed number of months in a year.) Similarly, some arithmetical/astronomical calendars may rely on observation to determine when one day ends and another begins, even though all the other calendrical rules are non-observational.				All observational calendar systems in actual use require observations of astronomical events in order to determine when one month ends and another begins and/or when one year ends and another begins.  Examples of the sorts of astronomical events whose observation might be used to govern the counting of calendrical time units would be the beginning or ending of a particular phase of the moon (as defined by specific observational rules,) or the occurrence of an equinox or solstice (as defined by specific observational rules.)				The difference between an observational calendar and an astronomical calendar is a matter of whether or not computational formulae **officially define** the moment of transition from month to month and/or year to year. In an observational calendar, direct real-time observation of real-world events is the official procedure for determining when one month or year ends and another begins, whereas in an astronomical calendar (or arithmetical calendar) the official procedure for determining when one month or year ends and another begins officially (legally) requires only the evaluation of mathematical fomulae.				Since the observations required by the rules of an observational calendar may be prevented by weather conditions at the time the events actually first occur, and since weather conditions vary from place to place, and also since the observational rules may provide results that vary from one observer to another (even at the same location,)  dates a known number of days in the future cannot be deterministically computed in advance in the case of an observational calendar system (equally incomputable would be the number of days until a particular date in the future.)				Also, the relationship between past dates and the number of days since the epoch of the calendar, although well-defined, cannot be computed by computational formula, but must instead by derived from an exhaustive record of the points in time at which the pertinent events were deemed to have occurred (information that will vary from location to location, since not all observers will have always agreed as to the timing of the events in question, often precisely because of the locational difference.)				Calendars that are officially observational are often unofficially simulated using either arithmetical or astronomical computations.				The religious Islamic Calendar was originally an observational calendar, and still is in some Muslim countries and communities, but in many Islamic countries (e.g, Saudi Arabia ) it is now an astronomical calendar.  There is also an arithmetical version of the Islamic Calendar, known as the Fatimid Calendar--which is the only version that Chronos Release 1.0 implements. Although the Fatimid Calendar is not widely used, nevertheless it is used by some Muslims--even for religious purposes (e.g., the Daudi Bohras [http://ismaili.net/mirrors/108_bohras/bohras.html])--and is also commonly used to interpret dates recorded in the past when the observational calendar was still in use (due to the ambiguities inherent in an observational calendar.)  The Fatimid Calendar agrees with its astronomical cousin more often than not, and would never be off by more than a day at any time within a few millennia of the present day.				Given the nature of observational calendar systems, Chronos does not support them as such (although it may provide either arithmetical or astronomical simulations for some of them,) and there are no plans to ever directly implement any observational calendars. If such calendar systems are of interest to you, you are invited to implement them yourself.		The class Calendar has the subclasses RegularCalendar and IrregularCalendar.  RegularCalendar assumes a high degree of regularity in the month strucure of the calendar--as would be typical of an arithmetical calendar.  A "regular calendar" is one with a manageably-small number of different "year types." IrregularCalendar is intended for calendrical systems having a large (perhaps infinite) number of different year types.  In many (but not all) cases, arithmetical calendars are RegularCalendars and astronomical calendars are IrregularCalendars.		Calendrical systems--their epoch dates, their month structures, their start-of-year dates, their start-of-day times, and other issues are deeply ingrained in the members of each culture that uses a particular calendar.  Just imagine the average person's reaction to being required to use some calendrical system other than the one he or she grew up with.  Often, calendars touch on deeply held religious and/or cultural beliefs and conventions. Dates and times can be just as sensitive a subject as social or religious issues--because they in fact are social and religious issues.  Calendrical disputes have contributed to social unrest and popular revolutions. Caution is warranted.	Usage:		Calendar instances are canonically immutable; Calendar inherits (indirectly) from Immutable (which see.) Unlike most subclasses of Immutable, a Calendar instance fully initializes itself and makes itself immutable when instantiated by sending the message #new to its class--because a Calendar instance needs no external parameters to set its instance variables to their correct values.				Calendar Registration/Semantic Keys			Each concrete Calendar subclass defines a unique registration key that is used as a "well-known" semantic key to identify the calendrical system implemented by that class. The message #registrationKey may be sent to either a Calendar instance, or to its class, to retrieve its registration/semantic key. The well-known registration/semantic keys of the calendrical systems provided in Chronos Release 1.0 are #Bahai, #Coptic, #Ethiopic, #Gregorian, #Hebrew, #'Julian-Imperial', #Indian, #'Islamic-Fatimid', #Julian, #'Persian' and #Solarian.		Calendar Singletons			There is no reason to have more than one instance of any particular subclass of Calendar. Calendar class provides a framework so that a single instance of each concrete subclass can be used as a canonical singleton--but Calendar class does not require or enforce the singleton constraint  (Reason: to avoid making the development of new Calendars, or the redesign of existing ones, unnecessarily difficult.) So, although more than one instance of a Calendar is allowed to exist, the Chronos codebase assumes that there is only one canonical instance. Consequently, using a non-canonical instance of a Calendar class may produce undefined behavior in some cases. Recommendation: Don't use multiple instances of the same Calendar class simultaneously, other than for development, testing or experimental purposes.			There are several ways to access the canonical instance of a Calendar class:				* Send the message #at:ifAbsent: or #at: to Calendar class, with the registration/semantic key of the Calendar class as the argument of the #at: keyword ("Calendar at: #Hebrew");				* Send the message #canonical to the Calendar class, or to any instance of the class ("EthiopicCalendar canonical");				* Send the message #asCalendar to the Calendar class ("CopticCalendar asCalendar"; however, sending this message to an instance results in the instance itself, canonical or not);				* Send the message #referencedBy: to Calendar class, with any of the following message arguments: a) the registration key of the desired concrete subclass of Calendar, b) the concrete Calendar subclass of the desired instance, c) an instance of the desired Calendar subclass--note that the same flexibility is generally available in the case of most Chronos methods that expect a "calendar" argument;				* For the Gregorian calendar: Send the message #gregorian or #ansiStandard to Calendar class ("Calendar gregorian" or "Calendar ansiStandard"), or just use the constant Gregorian or the constant AnsiStandardCalendar (both or which should be defined in the ChronosCalendarConstants namespace or shared pool dictionary);				* For the Julian calendar: Send the message #julian to Calendar class ("Calendar julian"), or just use the constant Julian (which should be defined in the ChronosCalendarConstants namespace or shared pool dictionary.)		Year Numbering Policy			Calendars use and provide a policy object for dealing with the year-numbering conventions of a calendrical system ("What's the number of the year immediately preceding the year 1?"; "Are years counted from 1 (ordinal numbering,) or from zero (cardinal numbering, as in the Hindu Calendars)?".)  The year-numbering policy object can be accessed by sending the message #yearNumberingPolicy to either the Calendar instance, or to its class. The policy object will be an instance of one of the subclasses of NumberingPolicy. The class comment of NumberingPolicy fully explains the usage of a Calendar's yearNumberingPolicy.		Parsing Dates			Date/Time parsing is provided by the class ChronosParser (which see.)  ChronosParser depends heavily upon both a Calendar instance and an instance of ChronosLocale in order to handle both differences between locales and between Calendars.			A Calendar instance provides significant information useful for both parsing dates, and also for representing them to users.		Year Types			Calendrical systems define a set of 'year types,' where each year type defines a particular organization of the days of the year into months and days of the month, and hence a particular mapping between day-of-year ordinals and month/day-of-month designations for all years with the same year type. Most arithmetical calendars define only two year types ("standard" and "leap,") although the Hebrew Calendar defines six (it's the clear winner of the complexity competition for arithmetical calendar systems.) The number of year types in an astronomical calendar can be quite large (e.g. the Chinese and Hindu lunisolar Calendars)--although that does not have to be the case (e.g., the Persian Astronomical Calendar.)						To determine the year type code of a particular year, send the message #typeCodeOfYear: to the Calendar instance, with the year as the argument ("Calendar gregorian typeCodeOfYear: 1900."; "Calendar julian typeCodeOfYear: 1900."; "Calendar gregorian typeCodeOfYear: 2000.")  The interpretation of the type code is unique to each Calendar: the same code value may have a totally different meaning to different calendars; for some Calendars, the type code of a year may be the year itself.  Generally, it is not possible to reliably infer directly from the year type code whether or not the year is a leap year (although that's quite straightforward for all arithmetical calendars other than the HebrewCalendar.) The canonical way to determine whether a year is a leap year will be revealed below.			Many of the messages in the API of Calendar require the year type code (although many of them have alternates that take the year itself, compute the year type code for you, and then invoke the analogous message that takes a year type code instead of a year.) Since computing the year type code can be computationally quite expensive in some cases (the HebrewCalendar is the worst offender,) one should take advantage of any opportunities to compute the year type code once and reuse it for two or more subsequent message sends to a Calendar instance involving any dates in the same year.		Month Ordinals; Numerical Month Designators			Chronos requires that, for all calendars universally, the ordinal number of the month that contains the first day of the year must be 1 (in other words, the month ordinal must literally be an ordinal number that counts months since the start of the year, and so must be a number greater by one than the cardinal number of months since the month that begins a year.)  Consequently, the Chronos month ordinal for the month of Tishri in the Hebrew Calendar is 1, not 7 (this subject is fully discussed in the class comment of HebrewCalendar.)   			Calendar provides the messages #monthOrdinalFromNumericMonthDesignator:forYearTypeCode: and #numericMonthDesignatorFromMonthOrdinal:forYearTypeCode: for the purpose of translation to/from canonical month ordinals and culturally-correct "numerical month designators." Be sure to use these messages appropriately when capturing dates from, or presenting dates to, the users of an application (a ChronosPrintPolicy can be used to print dates using month ordinals, numeric month designators, month names or month abbreviations.) Applications must provide their own date capture and/or date parsing mechanisms.			Sending the message #month to a point-in-time object (a DateSpec, YearMonthDay, DateAndTimeSpec or DateAndTime/Timepoint,) provides the mathematically-correct month ordinal of the date (as required by the ANSI-Smalltalk standard.) Sending the message #numericMonthDesignator to a point-in-time object (a DateSpec, YearMonthDay, DateAndTimeSpec or DateAndTime/Timepoint,) provides the culturally-correct month ordinal.		Month Keys; Month Name Keys			Those only familiar with relatively simple and regular arithmetical calendars, such as the Gregorian Calendar, may be surprised to learn that some calendrical systems (e.g., the Hebrew, Chinese and Hindu lunisolar Calendars) have a variable number of months in a year--such calendrical systems have "leap months," in complete analogy with the familiar "leap day" that almost all calendrical systems use.  They may be even more surprised to discover that the leap months a) are often not inserted as the final month, and b) are not necessarily inserted in the same numerical sequence in different years.  Consequently, in such calendrical systems there is no invariant mapping between a month's ordinal number and the semantic identity of the month (e.g., it's name, what holidays or event annimversaries occur during the month, etc.)   For this reason, Chronos semantically identifies a month using a well-known "month key" (a Symbol.) for each month.			Using month keys enables the date of Purm (for example) to be defined as the 14th day of the month whose month key is #Adar in the Hebrew calendar.  Otherwise, the date of Purim would have to be specified as the 14th day of "month 12" (monthOrdinal=6) in non-leap years, but as the 14th day of "month 13" (monthOrdinal=7) in leap years (a Hebrew leap year is one where a leap month is inserted.)			The remaining issue is the name and abbreviation of a month.  The month ordinal should not be used as an index into a table of month names and abbreviations because not all calendars associate the same month name/abbreviation with the same month ordinal in all years. The month key should not be used as the name of a month because the key is a Symbol whose characters form an English word (or the English transliteration of a foreign word,) and not all users will want to see English month names (or ASCII representations of the names of months in a calendar.). 			Also, the month key should not be used as a key into a Dictionary of month names/abbreviations, because the name/abbreviation of a month may vary as a function of the year type. For example, in the Hebrew Calendar,  the month whose monthKey is #Adar has the month ordinal 6 and the name "Adar" (English transliteration) in a non-leap year, but has the month ordinal 7 and name "Adar Sheni," "Adar Beth" or "Adar II" in leap years. For this reason, in addition to a month key for each month, Chronos also defines a month nameKey for each month (which for most calendrical systems, will always be identical to the monthKey, but in the Hebrew, Chinese and Hindu lunisolar calendars may differ from the monthKey for some months in some years.)  ChronosLocale (which see) provides a mapping between month nameKeys, month names, and month abbreviations.		Queries about Years and Months			Year Queries								The method protocol 'API-queries-years' provides messages for querying a Calendar about its years.  See the individual methods and their comments for full details. Some examples:					EthiopicCalendar canonical eraNameForYear: -5500					Calendar gregorian maxDaysPerYear					HebrewCalendar canonical daysInYear: 5765						Month Queries				The method protocol 'API-queries-months' provides messages for querying a Calendar about its months.  See the individual methods and their comments for full details. Some examples:					Calendar julian daysInMonth: 2 inYear: 1900					Calendar gregorian maximumDayOfYearOrdinalForMonth: 3 day: 1						HebrewCalendar canonical monthKeyForMonthAt: 7 inYear: 5765					HebrewCalendar canonical 						numericMonthDesignatorFromMonthOrdinal: (HebrewCalendar canonical monthOrdinalForMonthWithKey: #Adar inYear: 5766)						inYear: 5766		Date Validation			The method protocol 'API-validation' provides messages useful for validating date designations:  				Message									Usage example				#dayOfMonthOrdinalRangeConstraint			Calendar gregorian dayOfMonthOrdinalRangeConstraint assertValid: 0				#dayOfYearOrdinalRangeConstraint			Calendar gregorian dayOfYearOrdinalRangeConstraint isValid: 367				#daysSinceStartOfYearRangeConstraint		Calendar gregorian daysSinceStartOfYearRangeConstraint minValidValue				#monthOrdinalRangeConstraint				Calendar gregorian monthOrdinalRangeConstraint maxValidValue				#assertValidDayOfYear:						Calendar gregorian assertValidDayOfYear: 367					#assertValidDaysSinceStartOfYear:			Calendar gregorian assertValidDaysSinceStartOfYear: -1				#assertValidMonth:day:						Calendar gregorian assertValidMonth: 2 day: 30				#validateYear:dayOfYear:ifInvalid:				Calendar julian validateYear: 0 dayOfYear: 366 ifInvalid: [:problem | problem]				#validateYear:month:day:ifInvalid:				Calendar gregorian validateYear: 1900 month: 2 day: 29 ifInvalid: [:problems | problems]		CalendarPeriods (YearlyCalendar, MonthlyCalendar, CalendarDay)			Calendars use CalendarPeriod objects to represent the structure/organization of months within years, and days within months.  There are three subtypes of CalendarPeriod: YearlyCalendar, MonthlyCalendar and CalendarDay (all of which see.) There is a different YearlyCalendar instance for each type of year, each of which contains a MonthlyCalendar instance for each month that occurs in the type of year represented by its containing YearlyCalendar.  Each MonthlyCalendar contains a CalendarDay instance for each day of the month that occurs in that month, in the type of year represented by the root YearlyCalendar. So each CalendarDay is bound to a particular MonthlyCalendar, which is bound to a particular YearlyCalendar, which is bound to a particular type of year and to a particular Calendar instance.			The CalendarPeriod objects used by Calendars are flyweight objects: only one instance will exist in memory representing the same calendar period for a given year type for a particular Calendar instance.  This means that there are four instances of CalendarDay that represent March 1--one for standard years in the Gregorian Calendar, one for standard years in the Julian Calendar, one for leap years in the Gregorian Calendar, and one for leap years in the Julian Calendar. 			The method protocol 'API-CalendarPeriods' provides messages for accessing the CalendarPeriod flyweights.  For full details, see the individual methods and theif comments.  A few usage examples are provided below: 				Message										Usage example				#yearlyCalendarFor:								(Calendar at: #Hebrew) yearlyCalendarFor: 5765				#calendarDayFromDayOfYearOrdinal:inYear: 		(Calendar gregorian calendarDayFromDayOfYearOrdinal: 60 inYear: 2004) isLeapDay				#calendarDayFromMonth:day: inYear: year 		(Calendar gregorian calendarDayFromMonth: 12 day: 31 inYear: 2000) dayOfYear						Date Deconstruction			The method protocol 'API-Date Deconstruction' provides messages for converting a date designation into a count of days since the epoch. See the individual methods and their comments for complete details. Usage examples of the most important such messages are presented below:						Message											Usage examples				#daysUpToMonth:day:inYear:						Calendar gregorian daysUpToMonth: 1 day: 1 inYear: 2001.																	Calendar gregorian daysUpToMonth: 9 day: 11 inYear: 2001.																	Calendar gregorian daysUpToMonth: 12 day: 31 inYear: 2001.				#daysSinceEpochUpToYear:							Calendar gregorian daysSinceEpochUpToYear: 2001. 				#daysSinceEpochUpToMonth:day:inYear:			Calendar gregorian daysSinceEpochUpToMonth: 1 day: 1 inYear: 1.																	Calendar gregorian daysSinceEpochUpToMonth: 1 day: 1 inYear: 1901.																	Calendar gregorian daysSinceEpochUpToMonth: 7 day: 20 inYear: 1969.																	Calendar gregorian daysSinceEpochUpToMonth: 9 day: 11 inYear: 2001.			Note that adding 'Calendar gregorian daysSinceEpochUpToYear: 2001 [=730485]' to 'Calendar gregorian daysUpToMonth: 9 day: 11 inYear: 2001' [=253] gives the same result as 'Calendar gregorian daysSinceEpochUpToMonth: 9 day: 11 inYear: 2001' [=730738].		Date Construction			The method protocol 'API-Date Construction' provides messages for converting a count of days since the epoch (or months since the epoch) into a date designation. 			Date designations are not simple numbers, which means that there are only two ways to provide the result of converting a count of days (or months) since the epoch into a date designation: either some sort of date object must be created and returned (even if it's just an Array instance,) or else the components of the date must be injected into a multi-argument block (more generally, a mult-argument message must be sent to a callback object.) Calendar instances use both strategies.			The date objects returned by Calendar's date construction messages are instances of DateSpec (which see.) Performance testing proved that answering a DateSpec was significantly more efficient than answering an Array object. DateSpecs are designed to be extremely efficient to create, to have a small memory footprint, and to do nothing more than to serve as extremely efficient representations of a date designation. DateSpecs are not fully ANSI compliant, although they provide a subset of the protocol ANSI specifies for DateAndTime objects.  [Full compliance with the ANSI DateAndTime protocol is provided by instances of Timepoint.]  			Calendar's date construction methods that inject the components of a date designation into a block require a two-argument block as their argument.  The first block argument is the year.  If the message is constructing a partial date from a count of months since the epoch, then the second block argument is the month ordinal. Otherwise, if the message is constructing a complete date designation from a count of days since the epoch, then the second argument is an instance of CalendarDay (see above, under "Calendar Periods.").  			See the individual methods and their comments for complete details of each message. Usage examples of the most important date construction messages are presented below:				Message											Usage examples				#forDaysSinceEpoch:setYearAndCalendarDayInto: 	Calendar gregorian 																		forDaysSinceEpoch: 0 																		setYearAndCalendarDayInto: [:year :calendarDay | Array with: year with: calendarDay].																	Calendar gregorian 																		forDaysSinceEpoch: 730485																		setYearAndCalendarDayInto: [:year :calendarDay | Array with: year with: calendarDay].																	Calendar gregorian 																		forDaysSinceEpoch: 730485 +  253																		setYearAndCalendarDayInto: [:year :calendarDay | Array with: year with: calendarDay].				#dateSpecFromDaysSinceEpoch:					Calendar gregorian dateSpecFromDaysSinceEpoch: 0																	Calendar gregorian dateSpecFromDaysSinceEpoch: 730485																	Calendar gregorian dateSpecFromDaysSinceEpoch: 730485 +  253		Days of the Week			Most calendar systems have seven days in a week. And those that don't aren't in active use (e.g., the French Revolutionary calendar.)  Chronos defines a week as 7 days.  Any other period of days, regardless of what a particular calendar system may call it, is by Chronos definition NOT a week.  There must be some invariants, and 7 days per week is so close to universal, that the benefits of this stance far outweigh the costs.			The "first day of the week" is defined by culture, and not by a calendrical system. Nevertheless, the ANSI Smalltalk standard requires that the first day of the week must be Sunday--at least in the Gregorian Calendar. Unfortunately, the ISO 8601 international standard requires that the first day of the week must be Monday (also, at least in the Gregorian Calendar.) Actually, this conflict is an excellent example of the point that the first day of the week is a cultural issue (Americans versus Europeans,) since the difference of opinion involves the same calendrical system (Gregorian.) 			Chronos provides support for both the ANSI and the ISO 8601 conventions for numbering the days of the week.  However, because Chronos must fully comply with the ANSI Smalltalk standard, methods that provide or expect day-of-week ordinals, in cases where the method selector doesn't clearly indicate whether the method provides or expects either ANSI or ISO values, will always provide or expect ANSI values for the Gregorian Calendar.  By default, the same holds for other calendars, unless they override the requisite day-of-week methods.			Code that needs to refer to day-of-week ordinals is encouraged to use the day-of-week ordinal constants defined in the ChronosDaysOfWeekConstants namespace (or "shared pool dictionary.")  The constants whose values are ANSI (American) ordinals are Sunday, Monday, Tuesday, Wednesday, Thursday, Friday and Saturday.  The constants whose values are ISO 8601 ordinals are ISOMonday, ISOTuesday, ISOWednesday, ISOThursday, ISOFriday, ISOSaturday and ISOSunday.			The names of the days of the week are also defined by culture/language, and not by a calendrical system.  Consequently, Chronos identifies days of the week by semantic keys (which are Symbols whose characters are the names in English of the days of the week.)   The ChronosDaysOfWeekConstants namespace defines both ANSIDayOfWeekKeys and ISODayOfWeekKeys, which are Arrays containing the semantic keys of the days of the week, such that the index of each key is the ordinal value as defined by either the ANSI or the ISO standards (e.g., 'ISODayOfWeekKeys indexOf: #Sunday' evaluates to the ISO 8601 ordinal number for Sunday.) Applications should use the day-of-week semantic keys to translate the day-of-week into a particular language--a task for which ChronosPrintPolicy and ChronosLocale provide the necessary infrastructure.			The method protocol 'API-Day of week' provides various messages for dealing with days of the week.  See the individual methods and their comments for more information.		Current Date &amp; Time			Each Calendar provides its own clock object (an instance of CalendarClock, which see) that provides the current time and date.  The clock can be accessed by sending the message #clock to any concrete subclass of Calendar (to either the class or the instance.)  			Here a few examples of using the CalendarClock:				Example											Comment				Calendar gregorian clock now.						Current date&amp;time in default timezone--in the Gregorian Calendar.				Calendar julian clock now.							Current date&amp;time in default timezone--in the Julian Calendar.				EthiopicCalendar clock today.						Date&amp;time at start-of-day in default timezone--in the Ethiopic Calendar (note: day starts at 6pm.)				HebrewCalendar clock dateToday localePrintString.	Date today in default timezone--in the Hebrew Calendar (note: day starts at 6pm.)		Julian Days				The Julian day or Julian day number (JDN) is the number of days that have elapsed since 12 noon Greenwich Mean Time (UT or TT) on Monday, January 1, 4713 BC in the proleptic Julian calendar; or November 24, -4713 in the proleptic Gregorian calendar. The Julian day system was invented to provide astronomers with a single system of dates that could be used when working with different calendars, and to unify different historical chronologies.			The Julian Date (JD) is the Julian day number plus the decimal fraction of the day that has elapsed since noon. Historical Julian Dates were recorded relative to GMT or Ephemeris Time, but the International Astronomical Union now recommends that Julian Dates be specified in Terrestrial Time, and that when necessary to specify Julian Dates using a different time scale, that the time scale used be indicated when required, such as JD(UT1). The fraction of the day is found by converting the number of hours, minutes, and seconds after noon into the equivalent decimal fraction.			The term 'Julian date' is also used to refer to Julian calendar dates and to ordinal dates. An ordinal date is one that designates a day-of-year (and perhaps also a year.) The use of 'Julian date' to refer to the day-of-year is generally considered to be incorrect--the correct term is ordinal date.			The method protocol 'API-Julian Days' provides messages for converting between Julian Day Numbers and a count of the number of days or seconds siince the epoch of a Calendar:				Message											Usage example				#julianDayOfEpoch									Calendar gregorian julianDayOfEpoch 				#secondsSinceJulianDayEpochUpToEpoch			Calendar julian secondsSinceJulianDayEpochUpToEpoch				#secondsFromMidnightToJulianDayStartOfDay		HebrewCalendar canonical secondsFromMidnightToJulianDayStartOfDay				#secondsSinceStartOfDayAtStartOfJulianDay			IslamicFatimidCalendar canonical secondsSinceStartOfDayAtStartOfJulianDay				#secondsSinceStartOfJulianDayAtStartOfDay			CopticCalendar canonical secondsSinceStartOfJulianDayAtStartOfDay				#daysSinceEpochFromJulianDay:					Calendar gregorian daysSinceEpochFromJulianDay: Calendar gregorian julianDayOfEpoch				#secondsSinceEpochFromJulianDay:				Calendar julian secondsSinceEpochFromJulianDay: Calendar julian julianDayOfEpoch				#julianDayFromDaysSinceEpoch:					Calendar gregorian julianDayFromDaysSinceEpoch: 0				#julianDayFromSecondsSinceEpoch:					Calendar julian julianDayFromSecondsSinceEpoch: 43200		Inter-Calendar Date Conversion			Dates are converted between calendrical systems by the following procedure:						1. Deconstructing the source date into a count of the seconds since the epoch of the source date's calendar;				2. Computing the count of seconds from the epoch of the target calendar up to the epoch of the source calendar (which may be a negative number);				3. Adding the result of step 2 to the result of step 1, resulting in a count of seconds since the epoch of the target calendar, and then 				4. Constructing a date in the target calendar from the count of seconds since its epoch that was computed in step 3.			If you tried to execute the procedure given above, using just the Calendar protocol discussed so far in this text, you'd discover that "computing the count of seconds from the epoch of the target calendar up to the epoch of the source calendar" is more easily said than done.  It might, however, occur to you that the epoch dates of a number of calendrical systems is listed above (all as dates in the Gregorian Calendar,) and that evaluating '(Calendar gregorian daysSinceEpochUpToMonth: 3 day: 22 inYear: 622) - (Calendar gregorian daysSinceEpochUpToMonth: 9 day: 7 inYear: -3760)' would compute the number of days from the Hebrew epoch up to the Persian epoch (for example,) which works out to 1600323 days. And you'd be right: this works in principle, although it doesn't account for the fact that days in the Hebrew Calendar start at sundown (modernly at 6pm,) but days in both the Gregorian and Persian Calendars start at midnight.  			The Chronos inter-calendar date conversion architecture works by a) requiring that concrete subclasses of Calendar must specify the initial moment of their epoch day as a count of seconds since the initial moment of Julian Day 0 (see discussion of Julian Days in previous section,)  and b) nominating a particular Calendar as the "unification calendar." During initialization of a Calendar instance, the instance computes the count of seconds since the initial moment of the epoch day of the unification calendar up to the initial moment of its own epoch day, and stores the result in an instance variable. The value is computed by sutracting a) the count of seconds since the initial moment of Julian Day 0 up to the initial moment of the epoch day of the unification calendar from  b) the count of seconds since the initial moment of Julian Day 0 up to its own epoch day. The computation is done using seconds, instead of days, because of the differences between calendrical systems regarding the time-of-day when one day ends and another begins. So each Calendar instance precomputes and caches the number of seconds required to convert a count of seconds since its epoch into a count of seconds since the epoch of the unification calendar (or to convert a count of seconds since the epoch of the unification calendar into a count of seconds since its own epoch.) Consequently, conversion either to or from a count of seconds since the initial moent of the epoch day of the unfication calendar and a count of seconds since the epoch day of any other calendar requires only a single addition or subtraction.			To convert a date between two calendars, where neither is the unification calendar, requires an addition to convert the count of seconds since the epoch of the source date into a count of seconds since the epoch of the unification calendar, and then a subtraction to convert the count of seconds since the epoch of the unification calendar into a count of seconds since the epoch of the target calendar. If one of the calendars happens to be the unification calendar, then either the addition or subtraction will be omitted.			Any implemented Calendar can be the unification calendar. The default unification calendar is the Gregorian Calendar--because that's the calendar most likely to be one of the calendars from or to which a date conversion operation will be performed. However, changing from one unification calendar to another is relatively trivial: It's simply a matter of changing the implementation of Calendar class&gt;&gt;unification, and then reinitializing all existing Calendar instances  Although this is not recommended for most situations, it is easy to do, and there might be special situations where it makes sense.			In their book "Calendrical Calculations," Nachum Dershowitz and Edward Reingold define an inter-calendar conversion system that is essentially the same as the one that Chronos uses.  The only differences are that a) Dershowitz/Reingold define a system that is explicitlly and canonically based on the Gregorian Calendar; by contrast,  Chronos does not architecturally define any particular calendrical systrem as the canonical "unification calendar;" and b) Dershowitz/Reingold use ordinal numbers to count the days since the epoch of the Gregorian Calendar, whereas Chronos uses cardinal numbers.  In the Dershowitz/Reingold system 0001-01-01 Gregorian is day number 1 of the Gregorian epoch; by contrast, 0001-01-01 (regardless of calendar) is Chronos day 0 of the epoch of the calendar in question. 			Dershowitz/Reingold call a date specified as the ordinal count of days since the epoch of the Gregorian Calendar a "Rata Die date". "Rata Die" is Latin for "Day of Calculation."  To convert a "Rata Die" (R.D.) date into a Chronos count of the days since the Gregorian epoch, subtract 1 day. To convert a Chronos count of the days since the Gregorian epoch into a "Rata Die" (R.D.) date, add 1 day.			The method protocol 'API-unification' provides the fundamental date-conversion operations.  See the individual methods, and their comments, for complete details.	Motivation:		The Calendar class hierarchy separates the responsiblity of performing calendrical calculations from the responsibility of representing a particular date designation.  It also enables objects that represent date designations to use Calendar instances as Strategy objects, so that the same date and/or timepoint class can be used for dates in any calendrical system.	Implementation:		Instance Variables			clock 										&lt;CalendarClock&gt;		Provides current date &amp; time--see CalendarClock.			yearNumberingPolicy 						&lt;NumberingPolicy&gt;		Provides policy for dealing with the year-numbering conventions 																				of the calendrical system implemented by the instance ("What's 																				the number of the year immediately preceding the year 1?"; "Are 																				years counted from 1 (ordinal numbering,) or from zero (cardinal 																				numbering, as in the Hindu Calendars)?".)			secondsSinceUnificationEpochUpToEpoch 	&lt;Integer&gt;				Count of the number of seconds from the epoch of the unification																				calendar up to the epoch date of the calendrical system 																				implemented by the instance.			secondsSinceJulianDayEpochUpToEpoch 	&lt;Integer&gt;				Count of the number of seconds from Julian Day Zero up to the																				epoch date of the calendrical system implemented by the instance.			minDaysPerYear 							&lt;Integer&gt;				Least number of days in any year of the calendrical system 																				implemented by the instance.			maxDaysPerYear 							&lt;Integer&gt;				Most number of days in any year of the calendrical system 																				implemented by the instance.			minMonthsPerYear 							&lt;Integer&gt;				Least number of months in any year of the calendrical system 																				implemented by the instance.			maxMonthsPerYear 							&lt;Integer&gt;				Most number of months in any year of the calendrical system 																				implemented by the instance.			minDaysPerMonth 							&lt;Integer&gt;				Least number of days in any month of any year of the calendrical 																				system implemented by the instance.			maxDaysPerMonth 							&lt;Integer&gt;				Most number of days in any month of any year of the calendrical 																				system implemented by the instance.			monthOrdinalRangeConstraint 				&lt;RangeConstraint&gt;		The range constraint for month ordinals for any year in the 																				calendrical system implemented by the instance (the range may																				include month ordinals that are not valid in some years.)			dayOfMonthOrdinalRangeConstraint 			&lt;RangeConstraint&gt;		The range constraint for day-of-month ordinals for any month in any																				year in the calendrical system implemented by the instance (the 																				range may include day-of-month ordinals that are not valid fpr some																				months and/or for some months in some years.)			dayOfYearOrdinalRangeConstraint 			&lt;RangeConstraint&gt;		The range constraint for day-of-year ordinals for any year in the 																				calendrical system implemented by the instance (the range may																				include day-of-year ordinals that are not valid in some years.)			daysSinceStartOfYearRangeConstraint 		&lt;RangeConstraint&gt;		The range constraint for day-of-year cardinals for any year in the 																				calendrical system implemented by the instance (the range may																				include day-of-year cardinals that are not valid in some years.)	Subclassing:		Concrete subclasses must subimplement the class method #registrationKey.		The fundamental instance methods that must be subimplemented by a concrete subclasss are (see the method comment for the functional specification):			Message Selector												Implementation notes			#daysSinceEpochUpToYear:			#forDaysSinceEpoch:setYearAndCalendarDayInto:				"Brute force" implementation is provided by Calendar, but it will be extremely slow.			#forMonthsSinceEpoch:setYearAndMonthsSinceStartOfYearInto:	"Brute force" implementation is provided by Calendar, but it will be extremely slow.			#typeCodeOfYear:			#computeSecondsSinceJulianDayEpochUpToEpoch				Required for both intercalendar conversion and for Julian Day functionality		The auxilliary instance methods that must be subimplemented by a concrete subclasss are (see the method comment for the functional specification)::			Message Selector															#calendarDayFromDayOfYearOrdinalforYearTypeCode:			#calendarDayFromMonth:day:forYearTypeCode:			#daysInMonth:forYearTypeCode:			#daysInYearForYearTypeCode:			#daysUpToMonth:day:forYearTypeCode:			#maximumDayOfYearOrdinalForMonth:day:			#maximumDayOfYearOrdinalForMonthWithKey:day:			#maximumDaysInMonth:			#maximumDaysInMonthWithKey:			#minimumDayOfYearOrdinalForMonth:day:			#minimumDayOfYearOrdinalForMonthWithKey:day:			#minimumDaysInMonth:			#minimumDaysInMonthWithKey:			#monthKeyForMonthAt:forYearTypeCode: 			#monthOrdinalForMonthWithKey:forYearTypeCode: 			#monthsInYearForYearTypeCode:			#monthsSinceEpochUpToYear:			#yearlyCalendarForYearTypeCode:			Other instance methods may need to be subimplemented in those cases where the default implementation provided by Calendar is not correct.  Likely candidates would include:			#ansiDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal:			#canonicalDayOfWeekOrdinalFromANSIDayOfWeekOrdinal:			#canonicalDayOfWeekOrdinalFromISODayOfWeekOrdinal:			#computeDaysSinceStartOfWeekForEpochDay			#eraNameForYear: 			#isoDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal:			#secondsSinceMidnightFromSecondsSinceStartOfDay:			#secondsSinceStartOfDayFromSecondsSinceMidnight:			#timeOfDayClockStartsAtStartOfDay			</body></comment><class><name>RegularCalendar</name><environment>Chronos</environment><super>Chronos.Calendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>yearlyCalendars </inst-vars><class-inst-vars>monthlyCalendarSpecs </class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.RegularCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ArithmeticalCalendar	Concept:		RegularCalendar is an abstract Calendar class whose subclasses implement "regular" calendars.  A regular calendar is one that has a reasonably small number of year types.  A year type defines a specific number of months in the year and a specific number of days in each month.		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of ArithmeticalCalendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		A regular calendar is one where there is a finite and relatively small number of "year types," where a "year type" a) defines a particular way of organizing the days of a year into months/days-of-the-month, and b) defines a deterministic mapping between day-of-year ordinals and month/day-of-month designations.	 		Typically, arithmetical calendars are RegularCalendars--although, at least theoretically, that does not have to be the case.		The Gregorian Calendar (the de facto international standard civil calendar) is a regular calendar, as are the Julian, Bahai, Coptic, Ethiopic, Fatimid (Arithmetical Islamic,) Hebrew, Indian (Civil,)  and Persian calendars. Most regular calendars have only two year types: a "standard" year and a "leap" year.  The Hebrew Calendar, however, has six different year types: three with 352, 353 and 354 days per year respectively (all three of which have 12 months per year,) and three with 382, 383 and 384 days per year respectively (all three of which have 13 months per year.)	Implementation:		Instance Variables			yearlyCalendars 											&lt;Array of YearlyCalendar&gt;				Every year of an ArithmeticalCalendar is a year of a particular type.  Each year type differs from other year types by reason of some difference in one or more of the following: a) the number of months in the year, b) the number of days in one or more of the months, c) the semantic key of one or more of the months, d) the name key of one or more of the months, e) the numerical month designator of one or more of the months, f) the day-of-month ordinals of one or more months that are considered to be leap days, g) the mapping between day-of-year ordinals and month/day-of-month designations, or h) the number of days in the year. There are only a small, finite number of different year types defined by any ArithmeticalCalendar.  For each such year type, there is an integer code that is used to identify the corresponding year type.  The integer year type code corresponds to the index in the Array of YearlyCalendars (referenced by &lt;yearlyCalendars&gt;) of the instance of YearlyCalendar that specifies the month structure for a year of the type identified by that integer code.  See the class comment of YearlyCalendar for more information.			doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey		&lt;boolean&gt; 				True if the association between month ordinals and month keys is invariant for all year types--otherwise false.  Generally true for all calendrical systems that have the same number of months in all year types.  A month key is a well-known key that semantically (culturally) identifies the "same month," even in cases where its month ordinal differs in different year types (this happens in the Hebrew Calendar, among others.)  The value of this variable is computed from the information in &lt;yearlyCalendars&gt;, and set during initialization of the instance.		Class Instance Variables			monthlyCalendarSpecs										&lt;Array of Array of MonthlyCalendarSpec&gt;				There must be one Array of MonthlyCalendarSpecs in the outer Array (the one referenced by &lt;monthlyCalendarSpecs&gt;) for each 'year type' of the calendrical system implemented by instances of (concrete subclasses of) ArithmeticalCalendar.  There must be a MonthlyCalendarSpec in the inner Array for each month for each year type.  The index in the outer Array of each inner Array of MonthlyCalendarSpecs is the integer code of the year type whose month structure is specified by the inner Array with that index. The index of each MonthlyCalendarSpec in its containing Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec. The value of &lt;monthlyCalendarSpecs&gt; is used to generate the value of the instance variable &lt;yearlyCalendars&gt; when an instance of (a concrete subclass of) ArithmeticalCalendar is instantiated/initialized. See the class comment of MonthlyCalendarSpec for more information.				So: "monthlyCalendarSpecs at: 2" evaluates to an Array of MonthlyCalendarSpecs that specifies the month structure for the year type identified by the integer code 2; "(monthlyCalendarSpecs at: 1) at: 7" evaluates to a MonthlyCalendarSpec that specifies the properties of the seventh month of a year whose integer year type code is 1.	Subclassing:		The class method #setMonthlyCalendarSpecs must be subimplemented.  See the method comment for more information.</body></comment><class><name>MonthsPerYearInvariantCalendar</name><environment>Chronos</environment><super>Chronos.RegularCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.MonthsPerYearInvariantCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})MonthsPerYearInvariantCalendar		Concept:		MonthsPerYearInvariantCalendar is an abstract Calendar class whose subclasses implement arithmetical calendars that have the same number of months in any and all years (most calendrical systems have this property.)  		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of ArithmetiicalCalendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.	Subclassing:		The following class methods must be subimplemented by any concrete subclass (see the method comment for the method semantics):			newMonthlyCalendarSpecsForStandardYear			newMonthlyCalendarSpecsForLeapYear</body></comment><class><name>CopticCalendar</name><environment>Chronos</environment><super>Chronos.MonthsPerYearInvariantCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.CopticCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})CopticCalendar	Concept:		CopticCalendar implements the Coptic Calendar.  The Copts are a Christian culture ethnically descended from the Pharonic Egyptians.  Their calendar is derived from the ancient Egyptian solar calendar, but unlike that calendar, uses leap years to more accurately reflect the length of the solar year.				For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Coptic Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Coptic Calendar is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		Epoch Date			The epoch date of the Coptic Calendar, 0001-01-01 [Coptic], corresponds to 0284-08-29 [Gregorian and Julian].  Coptic days begin at sunset. The Julian Date of the Coptic epoch is 1,825,029.25 (6 pm,) so the actual initial moment of the Coptic epoch corresponds to 0284-08-28T18:00:00 [Gregorian and Julian]. 			The Coptic epoch date is the first day of the year in the ancient Egyptian Calendar in which Diocletian ascended to the office of Emperor of Rome. This year marks the beginning of what is generally known as the Diocletian Era, although Copts call it the Era of Martyrs in memory of the many Christians tortured to death by Emperor Diocletian. This year was widely used as the epoch year in Europe (along with the leap year rule and month structure of the Imperial Julian Calendar) until around the Ninth Century, when almost all Christians began to use the modern "Anno Domini" era--with the obvious exception of the Copts.			The Coptic era is called "Anno Martyrum" (AM)--which is Latin for "In the Year of the Martyrs."		Time-of-Day Clock			Although Coptic days begin at sunset, Copts label the hours of the day beginning at midnight.  So the zero-point of the the time-of-day clock is midnight, although the initial moment of the day is 6 pm. 			{CopticCalendar clock today}			{CopticCalendar clock now}		Year Numbering Policy			The Coptic Calendar uses "zeroless ordinal" year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year -1.		Leap Year Rule			A year is a leap year if dividing the year ordinal by 4 leaves a remainder of 3.		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: Thoout					30/30			2: Paope					30/30			3: Athor						30/30			4: Koiak					30/30			5: Tobe						30/30			6: Meshir					30/30			7: Paremotep				30/30			8: Parmoute					30/30			9: Pashons					30/30			10: Paone					30/30			11: Epep					30/30			12: Mesore					30/30			13: Epagomene				5/6			Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name (as given here.)</body></comment><class><name>IndianCalendar</name><environment>Chronos</environment><super>Chronos.MonthsPerYearInvariantCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.IndianCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})IndianCalendar	Concept:		IndianCalendar implements the Indian Civil Calendar, which is the official, civil calendar of India. A bewildering variety of calendars have been and continue to be used in the Indian subcontinent. In 1957 the Indian government's Calendar Reform Committee adopted the National Calendar of India for civil purposes and, in addition, defined guidelines to standardise computation of the religious calendar, which is based on astronomical observations. The civil calendar is used throughout India today for administrative purposes, but a variety of religious calendars remain in use.  Most Indians use the Gregorian Calendar for business purposes, and one of the variations of the religous calendar for the purposes of observing religious holidays, festivals and ceremonies.		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Indian Civil Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Indian (Civil) Calendar is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		Epoch Date			The epoch date of the Indian Civil Calendar, 0001-01-01 [Indian Civil], corresponds to 0079-03-22 [Gregorian] and to 0079-03-24 [Julian].  The Julian Date of the epoch of the Indian Civil Calendar is 1,749,994.50 (midnight.) 				The epoch date of the Indian Civil Calendar is the vernal equinox of the first year of the Saka Era, marking the ascension to the throne of King Salivahana.			The name of the era of the Indian Civil Calendar is "Anno Sakidae" (AS)--which is Latin for "In the Year of the Saka."		Time-of-Day Clock			Midnight is both the zero-point of the time-of-day clock and also the initial moment of the day. 			{IndianCalendar clock today}			{IndianCalendar clock now}		Year Numbering Policy			The Indian Civil Calendar uses ordinal year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year 0.		Leap Year Rule			A year is a leap year if the number that results from adding 78 to the year ordinal is either a) evenly divisible by 400, or b) evenly divisible by 4 but not by 100.  		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: Caitra					30/31			2: Vaisakha					31/31			3: Jyaistha					31/31			4: Asadha					31/31			5: Sravana					31/31			6: Bhadra					31/31			7: Asvina					30/30			8: Kartika					30/30			9: Agrahayana				30/30			10: Pausa					30/30			11: Magha					30/30			12: Phalguna				30/30			Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name (as given here.)</body></comment><class><name>ChronosSystemClock</name><environment>Chronos</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ticksPerSecond </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			private Smalltalk.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System</package></attributes></class><comment><class-id>Chronos.ChronosSystemClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosSystemClock	Concept:			An instance of ChronosSystemClock serves as the encapsulation of a clock device, and provides a standard API for obtaining the following types of information:			* The current time, expressed as the count of clock ticks between the current moment and the epoch of the clock (see below for the definition of the terms 'tick' and 'epoch');			* The number of Metric System time units (seconds, milliseconds, microseconds, nanoseconds) represented by a particular number of clock ticks; 			* The number of clock ticks represented by a particular number of Metric System time units; and 			* Meta-information about the operating parameters and characteristics of the encapsulated clock device--specifically, clock resolution, clock precision, clock epoch date, and whether the clock reports time relative to UT or relative to local time (see below for a definition of the term 'UT'.)		Terminology			UT: Universal Time. UT is the international reference timezone.  UT provides the reference time-of-day relative to which local, civil time-of-day is defined all over the world (in terms of a number of seconds of offset from UT.) Originally, the start-of-day point of UT corresponded by definition to mean solar midnight in Greenwich, England.  Currently (since as early as 1956,) the precise definition of start-of-day according to UT depends upon which timescale one uses with it: UT0, UT1, UT2, UT1R, UT2R or UTC (and there are others.) Note that it is far more common than not to see either the abbreviation GMT or UTC used to refer to the timezone UT--and that such usage is technically incorrect (which tends to make it more difficult than it ought to be to tell which timescale is used or assumed, and hence to know whether or not leap seconds will be consumed and/or produced.) See the class comment of ChronosTimezone for more information.'			Resolution: The resolution of a clock is defined by the smallest non-zero interval of time that can be notationally represented by the API for retrieving the current clock time.  			Tick: One clock tick is the smallest non-zero interval of time that can be notationally represented by the API for retrieving the current clock time.  The difference between 'tick' and 'resolution' is that 'tick' is used when specifying a particular count or number of time intervals, whereas 'resolution' is used when specifying the notational limits of a particular clock API.			Precision: The precision of a clock is the smallest non-zero interval of time that can pass between changes to the value of the clock's tick counter. So the resolution of a clock represents the limits on its time measurement due to its notational model, but its precision represents the limits of its time measurement performance in practice.  The resolution is frozen into the public API (a strategic issue); the precision is a function of the implementation of the clock's hardware, and of the software used to encapsulate it (a tactical issue.)			Epoch: The epoch of a clock is the moment that serves as the zero-point for the clock's tick count.  The orignal "Blue Book" Smallalk-80 used 1901-01-01T00:00:00 UT as the epoch of its system clock, with a resolution of 1 second, and so reported the current time as the number of seconds since 12:00am, 1 January 1901 UT (the Blue Book refers to UT as GMT.)	Usage:		An instance of ChronosSystemClock is instantiated by sending the message #new to its class.		The canonical instance of the ChronosSystemClock is accessible via a global named SystemClock, or by evaluating 'ChronosSystemClock current'.		The following example demonstrates the usage of a UT-relative ChronosSystemClock instance to compute the current local time in seconds and nanoseconds:			| ticksNow secondsSinceClockEpoch secondsSinceGregorianEpoch nanosecondsSinceSecond | 	 		ticksNow := SystemClock ticksNowSinceSystemClockEpoch.       		secondsSinceClockEpoch := SystemClock secondsFromTicks: ticksNow. 	 		nanosecondsSinceSecond := SystemClock nanosecondsSinceSecondFromTicks: ticksNow.        		secondsSinceGregorianEpoch := SystemClock secondsFromGregorianEpochUpToSystemClockEpoch + secondsSinceClockEpoch.			DateAndTimeFactory utSecondsSinceEpoch: secondsSinceGregorianEpoch nanoseconds: nanosecondsSinceSecond timeZone: ChronosTimezone default		The following example demonstrates the usage of a ChronosSystemClock instance to measure the time required to execute a block of code:			DurationFactory nanoseconds: (SystemClock nanosecondsToRun: [1000 timesRepeat: [1000 factorial]])	Motivation:		By concentrating all system-specific code in the class hierarchies of ResourcePathFacade, ChronosSystemFacade, ChronosSystemClock and ChronosEnvironment, and by defining a standard API for the invocation of system clock functions, ChronosSystemClock enhances the portability of the codebase of the Chronos date/time library, both with respect to different implementations/versions of Smalltalk and also with respect to the varying needs and preferences of applications (or code libraries) that use Chronos.		For example, a particular application or use case might require the use of a specialized device for reporting the current time, such as a network time server, a GPS satellite receiver, or an atomic clock directly connected to a computer. In such cases, a sublcass of ChronosSystemClock specifically implemented for accessing some such non-standard clock device can easily be substituted in place of the 'default' system clock class that relies on the host Smalltalk implementation's system clock functionality.		Ideally, porting Chronos to a new Smalltalk implementation (or in some cases, to a new version of a Smalltalk implementation) should require nothing more than writing a new subclass of a) ChronosEnvironment, b) ChronosSystemFacade, c) ResourcePathFacade and d) ChronosSystemClock. In reality, it will probably also be necessary to add (or reuse) inter-system compatibility methods in some classes of the host Smalltalk system's base library. Examples thereof might include methods such as #readStream and #writeStream in SequenceableCollection (or its equivalent(s)), and perhaps one or more utility methods in Stream. Finally, although the ANSI standard requires the existence of a class for scaled decimals, it very unfortunately does not specify the name of the class, nor the protocol for a scaled decimal factory.  Chronos assumes that the global that references the factory object for scaled decimal values is named ScaledDecimal, and that it conforms to the instance creation protocol defined by the VisualWorks FixedPoint class. If the native Smalltalk environment does not use the global name ScaledDecimal to reference the factory object for scaled decimal values, then the method ChronosEnvironemnt&gt;&gt;nativeScaledDecimalClass must be subimplemented by the subclass of ChronosEnvironment that will be used in that environment.  If the scaled decimal factory object's instance creation protocol does not conform to that of the VisualWorks FixedPoint class, then VW compatibility methods must be added.		Modification of the Chronos codebase for the purpose of making Chronos work correctly on the Smalltalk platform to which it is being ported (other than as herein described,) is strongly not recommended. Instead, please notify the author of Chronos of the porting problem {send and e-mail to porting (at) chronos-st (dot) org} so that a general solution to the problem can be designed and incorporated into the mainline Chronos codebase. 		See also: ChronosEnvironment, ChronosSystemFacade, ResourcePathFacade	Implementation:		ChronosSystemClock itself is implemented to retrieve the current time using the Network Time Service, as defined by RFC-868, which provides the number of seconds since 1900-01-01T00:00:00 UT (so the resolution of the RFC-868 clock is 1 second, and the clock epoch is the first moment of the Gregorian year 1900.) The implementation of ChronosSystemClock&gt;&gt;ticksNowSinceSystemClockEpoch simply sends the message #rfc868SecondsSince1900 to the ChronosSystemFacade singleton (because the API for internet access is highly non-portable among the various Smalltalk implementations.) 		Of course, the 1-second resolution provided by the RFC-868 Network Time Service may be insufficient, the 200-millisecond latency required to get the answer back may be unacceptable, and the risk that reliable high-speed internet access won't be available when needed may not be tolerable.  Consequently, most clients of Chronos will want to implement and/or use a subclass of ChronosSystemClock that encapsulates a local clock device with finer tick resolution. For VisualWorks, Chronos provides and uses the class VWSystemClock, which ecapsulates the VisualWorks VM system clock (which itself encapsulates the system clock of the host operating system.)		Instance Variables					ticksPerSecond		&lt;Integer&gt;	The number of clock ticks per second.	Subclassing:		Subclasses may need to subimplement some of the following instance methods (the semantics/responsibilities for each of these methods is fully described in the method comment):			isRelativeToUT			secondsFromGregorianEpochUpToSystemClockEpoch			ticksNowSinceSystemClockEpoch			tickResolutionName		Additionally, the time-unit conversion methods may need to be subimplemented.  HOWEVER, note that the provided subclasses MillisecondSystemClock, MicrosecondSystemClock and NanosecondSystemClock already correctly subimplement the time-unit conversion methods for clock devices whose resolution is 1 millisecond, 1 microsecond or 1 nanosecond (respectively.) So if the clock to be encapsulated by a subclass of ChronosSystemClock has one of those three standard resolutions, then the subclass should inherit from the subclass of ChronosSystemClock whose implementation provides the appropriate time-unit conversion methods.  VWSystemClock, for example, inherits from MicrosecondSystemClock.</body></comment><class><name>MicrosecondSystemClock</name><environment>Chronos</environment><super>Chronos.ChronosSystemClock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System</package></attributes></class><comment><class-id>Chronos.MicrosecondSystemClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})MicrosecondSystemClock	Concept:		MicrosecondSystemClock is an abstract subclass of ChronosSystemClock. It should be used as the superclass of any concrete ChronosSystemClock class that encapsulates a clock device whose resolution is one microsecond.  See the class comment of ChronosSystemClock for more information, including the defintion of the term 'resolution.' 		</body></comment><class><name>EnvironmentFacade</name><environment>Passport</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			private Smalltalk.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.EnvironmentFacade</class-id><body></body></comment><class><name>ChronosPrintable</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.ChronosPrintable</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosPrintable	Concept:		ChronosPrintable is an abstract class that establishes a framework for instances (of a concrete subclass) to delegate to a ChronosPrintPolicy (which see) the responsibility for printing themselves on a Stream.  See the individual method comments for more information.		ChronosPrintable also provides/implements Immutable behvavior/protocol and ChronosObject behavior/protocol (by inheritance.)	Subclassing:		Concrete subclasses must subimplement the instance method #printOn:using:</body></comment><class><name>CalendarPeriod</name><environment>Chronos</environment><super>Chronos.ChronosPrintable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.CalendarPeriod</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})CalendarPeriod	Concept:				CalendarPeriod is an abstract class, whose concrete subclasses specify the properties of a particular calendrical period, such as a year, a month of the year or a day of the year. The properties (e.g, month structure) of a year of a particular type are specified by an instance of YearlyCalendar. Each different type of year (e.g., standard year, leap year) requires a different YearlyCalendar instance. Each YearlyCalendar contains some number of MonthlyCalendar objects that specify the properties of the months in a year of a particular type.  Each MonthlyCalendar instance contains some number of CalendarDay objects that specify the properties of the days of a particular month in a year of a particular type. 		For most calendrical systems, there should be only one instance of a CalendarPeriod object for each calendrical period for each type of year for each Calendar (the instances should be flyweights.) However, for calendrical systems where there are an exceedingly large number of different year types (e.g, the Chinese Calendar,) the "flyweight invariant" may not hold. 		See the class comments of Calendar, YearlyCalendar, CalendarYearPart, MonthlyCalendar and CalendarDay for more information.	Usage:		As is the case with most Chronos classes, CalendarPeriod instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Subclassing:		Concrete subclasses must subimplement the following instance methods (see the comment of each method for the required semantics):			#yearlyCalendar</body></comment><class><name>YearlyCalendar</name><environment>Chronos</environment><super>Chronos.CalendarPeriod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>calendar typeCode intercalaryMonthCount leapMonthOrdinals leapDayOrdinals daysPerYear daysPerStandardYear hasNoLeapDays </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.YearlyCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})YearlyCalendar	Concept:		YearlyCalendar is an abstract class; an instance of one of its concrete subclasses represents/specifies the properties of a calendar year (of a particular type) of a particular calendrical system (e.g., the Gregorian, Hebrew, or Persian calendar.)  It does NOT represent/specify an actual occurrence of a specific year. In other words, a YearlyCalendar would specify/represent (for example) the properties of any leap year of the Gregorian Calendar, but would not specify/represent any specific Gregorian year.		Specifically, a YearlyCalendar specifies the calendrical system for which it represents a type of year; the Chronos 'year type code' of the type of year it specifies; the number of months per year; the number of leap and intercalary months in the year; which months of the year are leap or intercalary months; the number of days per year; the number of leap days in the year; which days of the year are leap days; and the number of days in each month.  A YearlyCalendar encapsulates, and provides access to, instances of MonthlyCalendar and CalendarDay that specify the properties of each month and day of the type of year specified by the instance.		Most calendrical systems have more than one type of year.  Instances of Calendar use a different instance of YearlyCalendar to represent/specify the properties/characteristics of each type of year that occurs in the calendrical system implemented by the Calendar instance.  		StaticYearlyCalendar and DynamicYearlyCalendar are the two concrete subclasses of YearlyCalendar.  If there is a relatively small number of different year types that can occur in a calendrical system, a Calendar that implements that calendrical system instantiates a single instance of StaticYearlyCalendar for each such year type. Since there is usually only one instance of Calendar per calendrical system, StaticYearlyCalendars (and also StaticMonthlyCalendars and StaticCalendarDays) usually conform to the flyweight constraint (there's only one instance in the image per year type.)  However, if there is a relatively large (or infinite) number of distinct year types in a calendrical system, then a Calendar that implements that calendrical system instead may use instances of DynamicYearlyCalendar, DynamicMonthlyCalendar and DynamicCalendarDay, which will not conform to the flyweight constraint (so as to avoid using up excessive amounts of memory.)		A StaticYearlyCalendar is preinitialized to encapsulate a flyweight instance of StaticMonthlyCalendar for each month in the type of year it represents, and to encapsulate a flyweight StaticCalendarDay for each day of the type of year it represents.  Similarly, a StaticMonthlyCalendar is preinitialized to encapsulate a flyweight instance of StaticCalendarDay for each day in the month it represents.  In contrast, a DynamicYearlyCalendar generates a new DynamicMontlyCalendar instance or a new DynamicCalendarDay instance every time it needs one or the other.  And a DynamicMonthlyCalendar generates a new instance of DynamicCalendarDay every time one is needed.	Usage:		As is the case with most Chronos classes, YearlyCalendar instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Implementation:		Instance Variables			calendar 				&lt;Calendar&gt;				The Calendar object that implements the calendrical system for which the instance specifies the properties of a year of a particular type.			typeCode 				&lt;Object&gt;				The object that uniquely identifies the type of the year whose properties are specified by the instance (usually, but not necessarily, this is an integer code.)			intercalaryMonthCount 	&lt;Integer&gt;				The number of intercalary months in a year of the type whose properties are specified by the instance (an intercalary month is one whose purpose is to contain any days that need to be added to the year--in addition to those that are contained by normal months--so that the total number of days in all the months of the year, and the total number of days in the year, will be the same. Intercalary months that occur every year usually have a number of days in the month that substantially differs from the number of days in a "standard" month.)			leapMonthOrdinals 		&lt;Array of Integer&gt;				Contains the month ordinal of each month that is a leap month in the type of year whose properties are specified by the instance.  A leap month is any month that doesn't occur in every type of year.  All leap months are also intercalary months, although not all intercalary months are leap months.			leapDayOrdinals  		&lt;Array of Integer&gt;				Contains the day-of-year ordinal of each day of the type of year whose properties are specified by the instance that is a leap day.  A leap day is any day of any month that doesn't occur in every type of year--including all the days of any leap month.			daysPerYear 			&lt;Integer&gt;				The number of days in a year of the type whose properties are specified by the instance.			daysPerStandardYear 	&lt;Integer&gt;				The number of days in a "standard" year for the calendrical system of the instance (as specified by the value of the 'calendar' instance variable.) A "standard year" is the type of year with the fewest leap days.			hasNoLeapDays 		&lt;Boolean&gt;				Flag that indicates whether there are any leap days in the type of year whose properties are specified by the instance.	Subclassing:		Concrete subclasses must subimplement the following instance methods (see the comment of each method for the required semantics):			#basicDayAt:			#basicMonthAt:dayAt:			#dayAt:			#dayAt:monthDayDo:			#daysInMonthAt:			#daysInMonthWithKey:ifAbsent:			#daysUpToMonth:			#daysUpToMonthWithKey:ifAbsent:			#monthAt:			#monthlyCalendarClass			#monthOrdinalForMonthWithKey:ifAbsent:			#monthsPerYear			#setMonthsInYear:</body></comment><class><name>StaticYearlyCalendar</name><environment>Chronos</environment><super>Chronos.YearlyCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>months days </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.StaticYearlyCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})StaticYearlyCalendar	Concept:		A StaticYearlyCalendar is a YearlyCalendar (which see) that is preinitialized to encapsulate a flyweight instance of StaticMonthlyCalendar for each month in the type of year it represents, and to encapsulate a flyweight StaticCalendarDay for each day of the type of year it represents.  	Usage:		As is the case with most Chronos classes, StaticYearlyCalendar instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Implementation:		Instance Variables			months &lt;Array of StaticMonthlyCalendar&gt;				The StaticMonthlyCalendar at the &lt;M&gt;th index in the array specifies the properties of the &lt;M&gt;th month of the year represented by the instance.			days 	&lt;Array of StaticCalendarDay&gt;				The StaticCalendarDay at the &lt;D&gt;th index in the array specifies the properties of the &lt;D&gt;th day of the year represented by the instance.</body></comment><class><name>UntilAnnualDateTimeZoneTransition</name><environment>Chronos</environment><super>Chronos.IntraYearTimeZoneTransition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annualDate </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-Policies-Annual</category><attributes><package>Chronos-TimeZones-Policies-Annual</package></attributes></class><comment><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UntilAnnualDateTimeZoneTransition	Concept:		An UntilAnnualDateTimeZoneTransition is an IntraYearTimeZoneTransition that specifies its annually-recurring intra-year date of expiry and transition to a successor AnnuallyRecurringTZPolicy using an instance of AnnualDate.		See the superclass IntraYearTimeZoneTransition for more information.	Implementation:		Instance Variables  {Also see superclass}				annualDate	&lt;AnnualDate&gt; The annually-recurring intra-year date when the ruleform represented by the instance expires and the transition to its successor (the inherited &lt;nextLink&gt;) takes place. Specification/representation of the time-of-day of expiry/transition is implemented by the superclass.</body></comment><class><name>CalendarYearPart</name><environment>Chronos</environment><super>Chronos.CalendarPeriod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>containingPeriod monthOrdinal isLeap </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.CalendarYearPart</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})CalendarYearPart	Concept:		CalendarYearPart is an abstract class, whose concrete subclasses specify the properties of a calendrical period that forms a part of a year, such as a month of the year or a day of the month. The properties of a month of the year (for a year of a particular type) are specified by an instance of MonthlyCalendar. Each MonthlyCalendar instance must be contained by an instance YearlyCalendar. The properties of a day of the month are specified by an instance CalendarDay. 		For most calendrical systems, there should be only one instance of a CalendarYearPart object for each calendrical period for each type of year for each Calendar (the instances should be flyweights.) However, for calendrical systems where there are an exceedingly large number of different year types (e.g, the Chinese Calendar,) the "flyweight invariant" may not hold. 		See the class comments of Calendar, CalendarPeriod, YearlyCalendar, MonthlyCalendar and CalendarDay for more information.	Usage:		As is the case with most Chronos classes, CalendarYearPart instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Implementation:		Instance Variables			containingPeriod	&lt;MonthlyCalendar | YearlyCalendar&gt; 				The CalendarPeriod that contains the instance, and for which the instance represents one of its subperiods.  If the instance is a MonthlyCalendar, then its &lt;containingPeriod&gt; is a YearlyCalendar.  If the instance is a CalendarDay, then its &lt;containingPeriod&gt; is a MonthlyCalendar.			monthOrdinal		&lt;Integer&gt;				The ordinal number of the instance's month.			isLeap				&lt;Boolean&gt; 				Flag that signals whether the instance is a leap period of its year.  If the instance is a MonthlyCalendar, then the flag indicates whether it represents a leap month of its year.  If the instance is a CalendarDay, then the flag indicates whether it represents a leap day of the year (either because it's any day in a leap month, or because it's a leap day in a non-leap month.)	Subclassing:		Concrete subclasses must subimplement the following instance methods (see the comment of each method for the required semantics):			#monthlyCalendar</body></comment><class><name>CalendarDay</name><environment>Chronos</environment><super>Chronos.CalendarYearPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dayOfMonthOrdinal dayOfYearOrdinal isLeapDayInMonth </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.CalendarDay</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})CalendarDay	Concept:		CalendarDay is an abstract class; an instance of one of its concrete subclasses represents/specifies the properties of a particular day as it occurs within a particular type of year (e.g., a standard year, a leap year) of a particular calendrical system (e.g., the Gregorian, Hebrew, or Persian calendar.)  It does NOT represent/specify an actual occurrence of a specific day or date in any specific year. In other words, a CalendarDay would specify/represent (for example) the properties of February 29 as it occurs in any leap year of the Gregorian Calendar, but would not specify/represent any specific occurrence of February 29 in a specific Gregorian year. 		Specifically, in the context of a particular calendrical system and type of year, a CalendarDay specifies the following properties of a particular day of a particular month: the day-of-year ordinal, the month ordinal, the day-of-month ordinal, and whether the day is a leap day of the year and/or is a day in a leap month. Also, via a reference to the MonthlyCalendar object that specifies the properties of its month, and via a reference to the YearlyCalendar object that specifies the properties of the type of year in which it occurs, a CalendarDay also provides information about the month and year that contain it.		A CalendarDay also provides date arithmetic and comparison operations.		The two concrete subclasses of CalendarDay are StaticCalendarDay and DynamicCalendarDay.  StaticCalendarDay must be used in collaboration with a StaticMonthlyCalendar.  DynamicCalendarDay must be used in collaboration with a DynamicMonthlyCalendar.	Usage:		As is the case with most Chronos classes, CalendarDay instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Motivation:	Implementation:		Instance Variables					dayOfMonthOrdinal	&lt;Integer&gt;				The ordinal number of the day of the month represented by the instance.			dayOfYearOrdinal	&lt;Integer&gt;				The ordinal number of the day of the year represented by the instance.			isLeapDayInMonth	&lt;Boolean&gt;				Flag that signals whether the day represented by the instance is a leap day of its month.  The days of a leap month may or may not also be leap days of the month (although they will always be leap days of the year.)	Subclassing:		Concrete subclasses must subimplement the following instance methods (see the comment of each method for the required semantics):			#addingDays:			#subtractingDays:</body></comment><class><name>StaticCalendarDay</name><environment>Chronos</environment><super>Chronos.CalendarDay</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.StaticCalendarDay</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})StaticCalendarDay	Concept:		A StaticCalendarDay is a CalendarDay (which see) that is specialized for collaboration with a StaticMonthlyCalendar (also which see.)	Usage:		As is the case with most Chronos classes, StaticCalendarDay instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Implementation:</body></comment><class><name>RomanicCalendar</name><environment>Chronos</environment><super>Chronos.MonthsPerYearInvariantCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>secondsFromEpochUpToGregorianStart </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.RomanicCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})RomanicCalendar	Concept:		RomanicCalendar is an abstract class whose concrete subclasses implement calendrical systems that use the same month structure as the Julian and Gregorian calendars--which ultimately derives from ancient, Imperial Rome. It also provides for specifying the canonical moment of transition to the offical, civil usage of the Gregorian Calendar (which is currently the de-facto civil calendar for most nations of the world.)		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Julian Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: January					31/31			2: February					28/29			3: March					31/31			4: April						30/30			5: May						31/31			6: June						30/30			7: July						31/31			8: August					31/31			9: September				30/30			10: October					31/31			11: November				30/30			12: December				31/31						Days In Year				365/366	Implementation: 		Insance Variables			secondsFromEpochUpToGregorianStart	&lt;Integer&gt;				The number of seconds from the instance's epoch up to the canonical moment of official/legal transition to the Gregorian Calendar. The value of this variable is computed and set during initialization of the instance.	Subclassing:		The instance method #computeSecondsFromEpochUpToGregorianStart must be subimplemented by any concrete subclass.  See the method comment for the method semantics.	</body></comment><class><name>AbstractJulianCalendar</name><environment>Chronos</environment><super>Chronos.RomanicCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.AbstractJulianCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})AbstractJulianCalendar	Concept:		AbstractJulianCalendar is an abstract class whose concrete subclasses implement a particular variation of the Julian Calendar.  		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Julian Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		Some variation of the Julian Calendar was the official, civil calendar of the Western World from 45 BC until at least 1582 AD in Caltholic Europe, until 1752 AD in the British Empire, and until as late as the early 20th Century in a handful of locales (such as Russia.)		However, there is no such thing as "the" Julian Calendar, because there are many different Julian Calendars.  In much the same way that England and the United States are two different countries separated by the same language (to quote Winston Churchill,) the various "Julian Calendars" are different calendrical systems falsely unified by the same name.  The various "Julian" Calendars differ from each other with respect to one or more of a) New Year's Day, b) the epoch year and c) the leap year rule. Historically, the "Julian Calendar" is a set of multiple, conflicting rules for counting time unified by nothing more than the same catchy name, the same set of months and the same leap year rule (and not even by that, in the case of the Roman Clerical Julian Calendar.).		The Julian Calendar was invented by the Alexandrian astronomer Sosigenes at the request of Julius Caesar in 46 BC, who formulated the calendar based on the Roman Republican Calendar and the then best available estimate of the length of the tropical year.  Julius Caesar made it the civil calendar of the Roman Empire effective 1 January 45 BC [Julian].  There are two differences between the Imperial Julian Calendar (as used in ancient Rome) and the Modern Julian Calendar (used mainly by historians,) one "de jure" and one "de facto." 		The "de jure" difference is that the ancient Romans did not use the year of Christ's birth as their epoch year.  		The "de facto" difference is that the priests in charge of the calendar failed to correctly apply Caesar's leap year rule for the first 38 years of the calendar--requiring Emperor Augustus to order the omission of any leap days from 7 BC through 3 AD. For more information about the original Julian Calendar used in Imperial Rome, see the class ImperialJulianCalendar. For more information about the Modern Julian Calendar used by historians (and by some religions,) see the class JulianCalendar.</body></comment><class><name>JulianCalendar</name><environment>Chronos</environment><super>Chronos.AbstractJulianCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.JulianCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})JulianCalendar	Concept:		JulianCalendar implements the Modern Julian Calendar, as modernly used to designate dates prior to the adoption of the Gregorian Calendar (which happened at different times in different legal jurisdictions.)  		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Julian Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Julian Calendar is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		See the class comment of AbstractJulianCalendar for information about the Julian Calendar common to all its variations.		Epoch Date			The epoch date of the Modern Julian Calendar as used by historians is 1 January 1 AD (1 January 754 AUC,) which is the first day of the year according to the civil calendar in use in Rome of the year in which or after which (no one knows for sure) that the Catholic Church reckoned that Christ was born. This year is the beginning of the Anno Domini era ("Anno Domini" is Latin for "In the year of the Lord.") Years prior to the year 1 Anno Domini are referred to as being in the era "Before Christ" (BC)--which is in English instead of Latin simply because the era was so named (originally) by the Venerable Bede, in his 'Ecclesiastical History of the English Nation,' which was published (in Old English) in the Eighth Century AD. 			 The Julian Date of the epoch of the Modern Julian Calendar is 1,721,423.50 (midnight.) 			The idea of using the year of Christ's birth as the epoch year of the Julian Calendar was first proposed by the Monk Dionysius Exiguus in 525 AD.  At the time, a variety of epoch years were in common use, with the year when Diocletian ascended to the office of Emperor of Rome being the most widely used. Although the Imperial and post-Imperial Romans counted time from various reference points that changed frequently, there was one "epoch date" that was canonically (albeit infrequently) used to unify all their various time counts: the date of the founding of the city of Rome (an era that was called "Ab Urbe Condita," Latin for "From the Founding of the City.") Dionysius explicity specified the year that would be the year 1 of the Anno Domini Era as the year 754 A.U.C. ("Ab Urbe Condita.")  			There is much contention as to the actual year of Christ's birth, although it is almost certain that Christ was not in fact born in either 753 or 754 AUC (1 BC or 1 AD.)  However, it may be that Dionysius chose 754 AUC as the epoch year for mathematical reasons, and not because he believed that Christ was actually born in either 1 BC or 1 AD.  			Dionysius Exiguus' proposal to use the time of Christ's birth as the basis for the epoch of the Julian Calendar was not immediately adopted. In fact, it would be several centuries before the Christian/Anno Domini Era came to be the commonly used basis for counting years. But by that time, other changes in calendrical practices had taken place.			New Year's Day as decreed by Julius Caesar was January 1.  But in medieval Europe, because the celebrations accompanying the new year were considered pagan and unchristian, the Council of Tours in 755 AD abolished January 1 as the beginning of the year. Over time, the result was that New Year's Day (the day on and after which the year ordinal would be incremented by one in date designations) came to be observed on any of December 25, March 1, March 25, the Feast of the Annunciation, or even Easter--and which of those days would have been deemed New Year's Day would depend, of course, on time and place. 			The epoch date of the Modern Julian Calendar is 1 January 754 AUC. This epoch date is used by historians in order to establish a unified, canonical "Julian Calendar" for modern use when representing ancient and medieval dates. Note, however, that this epoch date makes the Modern Julian Calendar anachronistic (proleptic,) because its New Year's Day was last widely used officially (in connection with the Julian Calendar) in the Eighth Century, and its epoch year didn't become canonical until the Ninth Century. The Modern Julian Calendar as used by historians, with New Year's Day on January 1 and with 754 AUC as the epoch year, was never the official civil calendar of the Western World.		Time-of-Day Clock			Modernly, midnight is both the zero-point of the time-of-day clock and also the initial moment of the day.  However, such has not always been the case for all users of the Julian Calendar.			{JulianCalendar clock today}			{JulianCalendar clock now}		Year Numbering Policy			The Julian Calendar uses "zeroless ordinal" year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year -1.		Leap Year Rule			A year is a leap year if its ordinal is evenly divisible by 4.		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: January					31/31			2: February					28/29			3: March					31/31			4: April						30/30			5: May						31/31			6: June						30/30			7: July						31/31			8: August					31/31			9: September				30/30			10: October					31/31			11: November				30/30			12: December				31/31			Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name.	Usage:		The Chronos namespace (shared pool) defines the global variable Julian, which aliases the canonical instance of JulianCalendar.  "JulianCalendar canonical" and "Julian" should be the same object.	</body></comment><class><name>HebrewCalendar</name><environment>Chronos</environment><super>Chronos.RegularCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.HebrewCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})HebrewCalendar	Concept:		HebrewCalendar implements the Hebrew Calendar, which was and is the calendar of the Jewish people, and of the Jewish religion.  The Hebrew Calendar is, by far, the most complex arithmetical calendar ever devised.  Modernly, it is used more for religious than secular purposes, although it is one of the two official, civil calendars of the State of Israel--the other, of course, is the Gregorian Calendar. The Hebrew Calendar was given its current form (as an arithmetical, rule-based calendrical system) in the mid Fourth Century AD.  Originally, it was an observational calendar.  Consequently, using the current Hebrew Calendar (as herein implemented) for dates before the year 4120 [Hebrew] (the mid-Fourth Century AD) would be anachronistic (although it's useful as an approximation/estimate.)		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Hebrew Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The modern Hebrew Calendar is an arithmetical, luni-solar calendar. A luni-solar calendar is one that, although it attempts to match the (average) length of its years to that of mean solar years over some sufficiently long period of time, also attempts to align the day on which one month transitions to the next with the moment that the moon transitions from one phase to the next, so that each month begins within a day or so of the moment that the moon exits from or enters into a particular phase. In the case of arithmetical luni-solar calendars, the result is usually that New Year's day oscillates back and forth with a period of about 1 month around some "fixed point" with respect to the mean solar year. Also, the solar year "fixed point" itself is likely to shift through the solar year over sufficiently long periods of time.		The Hebrew Calendar seeks to transition from one month to the next as a function of each New Moon. 			Epoch Date			The epoch date of the Hebrew Calendar, 0001-01-01 [Hebrew], corresponds to -3760-09-07 [Gregorian] (astronomical year numbering) and to -3761-10-07 [Julian] (traditional year numbering.)  Hebrew days begin at sunset. The Julian Date of the Hebrew epoch is 347,997.25 (6 pm,) so the actual initial moment of the Hebrew epoch corresponds to -3760-09-06T18:00:00 [Gregorian] and to -3761-10-06T18:00:00 [Julian]. 			Jewish tradition considers the Hebrew Calendar epoch to be the date of the creation of the world, which is why the name of the Hebrew era is "Anno Mundi" (AM)--Latin for "In the Year of the World."		Time-of-Day Clock			Although Hebrew days begin at sunset, modernly the Jewish people label the hours of the day beginning at midnight.  So the zero-point of the time-of-day clock is midnight, although the initial moment of the day is 6 pm. 			{HebrewCalendar clock today}			{HebrewCalendar clock now}		Year Numbering Policy			The Hebrew Calendar uses ordinal year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year 0.		Year Type Rules			There are six different year types (which means six different month structures [see below], and six different numbers of days per year.)  The six year types result from a two-dimensional matrix, with one dimension representing a binary distinction between a standard year and a leap year, and the other dimension representing a trinary distinction between "regular," "deficient" and "complete" years:												Year Type Matrix 									Deficient		Regular		Complete				Standard Year	  353[1]		  354[2]		  355[3]				Leap Year		  383[4]		  384[5]		  385[6]					(table cells show: days-per-year[Chronos year-type code])			The Hebrew Calendar uses the 19-year metonic cycle to determine which years are leap years. Years 3, 6, 8, 11, 14, 17 and 19 of the cycle are leap years, the remaining years are standard years. Whether or not a Hebrew year is a leap year can be computed by the following predicate function:				isLeapYear(hebrewYear) = (((7 * hebrewYear) + 1)  mod 19) &lt; 7			Now comes the really complicated part: how to determine whether a Hebrew year is "regular," "deficient" or "complete" (which we will refer to here as the "completeness" of the year, for lack of a better term, since the term "type" already refers to the combination of leap-year-status and "completeness.") 			One does not first determine the completeness and leap-year-status of a year in order to determine its type (and hence the number of days in the year.) Instead, one must first determine the number of days in the year, after which the type of the year (and hence its completeness) become evident.  In other words, one first determines that a year has (for example) 353 days, from which it obviously follows that the year's Chronos year-type is 1, and that it is therefore a standard, deficient year.			The number of days in a year is a function of when its first day occurs, and when the first day of the succeeding year occurs.  The approximate first day of a year is determined by the computed occurrence of the mean new moon (earth-lunar conjunction) that is associated with the beginning of the month of Tishri (the first month of the civil year.) The date so computed is subject to possible adjustment by a set of special rules called the Dehiyyah ("delays," "postponements.") First we will explain the formula for computing the occurence of the New Moon (Molad) of Tishri, then we will explain the application of the Dehiyyah rules for the purpose of precisely determining the beginning of a year, and then we will explain how to compute the length of a year.			Computing the New Moon (Molad) of Tishri				The Hebrew day was traditionally divided into 24 hours, and each hour was traditionally divided into 1080 parts (halaqim,) which means a day consists of 25,920 parts.  The duration of a part is 3 and a third seconds. The rule for computing the new moon of Tishri is expressed in terms of parts (halaqim.)				The epochal new moon of Tishri (which occurred on 0001-01-01 Anno Mundi--year 1, month 1 day 1 of the Hebrew Calendar) is deemed by calendrical rule to have occurred at 11:11:20 pm on the epoch date of the Hebrew calendar--which is very late Sunday evening according to Julian/Gregorian reckoning, but is the 5th hour of Monday according to Hebrew reckoning (Hebrew days start at sunset, Julian/Gregorian days start at midnight.) A duration of 5 hours, 11 minutes and 20 seconds (since the start of the day at 6 pm) equates to 18,680 seconds, which is equivalent to 5 hours and 204 parts (halaqim,) or to 5,604 parts (exactly.) Because the epochal Molad of Tishri occurred on the second day of the week (Monday,) after 5 hours and 204 parts since the start of the day, it is called Molad Beharad--the appellation "Beharad" (BHRD--written Hebrew omits all vowels) being derived from the numerology of the Hebrew alphabet, where the letter Beth has the value 2 (second day of the week,) the letter Heh has the value 5 (fifth hour of the day), the letter Resh has the value 200 (parts since the hour,) and the letter Daleth has the value 4 (additional parts since the hour.) Molad Beharad is the base or pivotal occurrence of the new moon upon which all Hebrew calendrical calculations depend.				The length of a mean lunar period (the average duration between new moons) is deemed (by the rules of the Hebrew Calendar) to be 29 days, 12 hours and 793 parts--which equates to 29 days, 12 hours, 17 minutes and 37 and 1/3 seconds, or to 2549857.333... seconds (using the UT1 timescale.) Since there are 25,920 parts in a day, and since 12 hours + 793 parts is 13,753 parts, the mean lunar period also equates to 29 + (13753/25920) days.				To compute the duration of time since the Hebrew epoch of the Molad of Tishri for a given year, one simply computes the number of months since the Hebrew epoch up to that year, then multiplies that number of months by the Hebrew Calendar's canonical value for the mean lunar period--which is 29 + (13753/25920) mean solar days, as given above, and adds the result to the moment of occurrence of the Molad Beharad (the epochal new moon of Tishri.)				The formula for computing the number of months since the Hebrew epoch upto the start of a given (Hebrew) year is expressed by the following function (derived from the 19-year metonic leap-year cycle used by the Hebrew Calendar):					monthsSinceEpochUpToYear(hebrewYear) =  ((235 * hebrewYear) - 234) div 19				So the number of (UT1) seconds since the Hebrew epoch of the Molad of Tishri for a given Hebrew year is computed by the following function:						secondsSinceEpochOfMoladOfTishri(hebrewYear) = 							(((235 * hebrewYear) - 234) // 19) 	"Number of months since the Hebrew epoch up to the given year"							* ((29 + (13753/25920)) * 86400)		"times the duration in seconds of the lunar period (one Hebrew month)"							+ 18680								"plus the number of seconds from the initial moment of the epoch up to the Molad Beharad"						{Timepoint nominalSecondsSinceEpoch: (((235 * 5765) - 234) // 19) * (29 + (13753/25920)) * 86400 + 18680 calendar: #Hebrew}			The Dehiyyah: Computing Rosh ha Shannah (New Year's Day) from the Molad of Tishri				Given the Molad of Tishri for a given Hebrew year, it is necessary to apply the "postponement rules" (the Dehiyyah) to determine the actual date of the Hebrew New Year's Day ("Rosh ha Shannah.") There are four postponement rules, all of which must be satisfied by the actual first day of Tishri, with the effect that the first day of Tishri can be delayed by more than one day from the day on which the Molad of Tishri occurs:				1. 'Dehiyyah Molad Zaqen' requires that the first day of Tishri (Rosh ha Shannah; New Year's Day) be delayed by one day whenever the candidate day occurs on or after the 18th hour of the Hebrew day (that's on or after 12 noon modern clock time.) 				2. 'Dehiyyah Lo ADU Rosh' requires that the first day of Tishri be postponed to the following day whenever the candidate day occurs on a Sunday, Wednesday or Friday.  Rules 1 and 2 often both apply, resulting in a 2-day postponement of Rosh ha Shannah.				3. 'Dehiyyah GaTaRaD' requires that Tishri 1 be postponed to Thursday whenever the candidate day for a 12-month year occurs on Tuesday at 9 hours and 204 parts or later. The effect is to disallow a year from having 356 days. This rule applies roughly once every 30 years.				4. 'Dehiyyah BeTU'TeKaPoT' requires that Tishri 1 be postponed to Tuesday whenever the candidate day following a 13-month year is on Monday at 15 hours and 589 parts or later. The effect is to disallow a year from having 382 days.  This rule applies roughly once every 186 years.)			Computing the Length of a Year				To compute the length of a given &lt;year&gt;, one must compute the number of days since the Hebrew epoch up to the first day of &lt;year&gt;+ 1 and also up to the first day of &lt;year&gt;, and subtract the second value from the first.  There is no other way. 				And so now you know part of the reason the Hebrew Calendar is so complex.  The other part of the reason is because of its month structure, which is explained below.		Month Structure																				D A Y S        P E R		M O N T H				Month			Civil 		Religious			  		Standard Year					  	Leap Year								Ordinal	Ordinal			Deficient Regular Complete		Deficient Regular Complete					Tishri				1			7				30			30			30					30			30		30 				Marheshvan		2			8				29			29			30					29			29		30				Kislev				3			9				29			30			30					29			30		30				Teveth				4			10				29			29			29					29			29		29				Shevat			5			11				30			30			30					30			30		30				[Adar Rishon		nil/6		nil/12			0			0			0					30			30		30]: Leap Month				Adar (Sheni)		6/7			12/13			29			29			29					29			29 		29				Nisan 				7/8			1				30			30			30					30			30		30				Iyyar				8/9			2				29			29			29					29			29		29				Sivan				9/10		3				30			30			30					30			30		30				Tammuz			10/11		4				29			29			29					29			29		29				Av					11/12		5				30			30			30					30			30		30				Elul				12/13		6				29			29			29					29			29		29				Days/year									353		354		355				383		384	385				Chronos Year Type							  1		  	2		 	 3				 	4		 	 5		  6			Months have either 29 or 30 days. Most months always have the same number of days every year, either 29 or 30.  The two exceptions are the months of Marheshvan (civil ordinal = 2) and Kislev (civil ordinal = 3.) In a "regular" year (which has 354 days in a standard year, but 384 days in a leap year,) the month of Marheshvan has 29 days and the month of Kislev has 30 days. In a "deficient" year (which has 353 days in a standard year, but 383 days in a leap year,) Marheshvan and Kislev both have 29 days.  In a "complete" year (which has 355 days in a standard year, but 385 day in a leap year,) Marheshvan and Kislev both have 30 days.			In non-leap years, there are 12 months in a year.  However, in leap years, a 13th leap month is inserted (as month 6) after the fifth month (Shevat) and before the non-leap-year sixth month (Adar,) with the consequence that the month ordinals of the months following the inserted leap month are incremented by one in leap years. The name of the leap month is Adar Rishon ('First Adar.')  In leap years, the month of Adar is referred to as Adar Sheni ('Second Adar,') in order to disambiguate it from Adar Rishon.  The reason that Adar Sheni (instead of Adar Rishon) is considered to be the "same month" as non-leap-year Adar is because the holiday of Purim occurs on Adar 14 in non-leap years, but on Adar Sheni 14 in leap years--and those born in Adar in a non-leap year generally observe their (Jewish) birthday in Adar Sheni in a leap year.			The semantic month-key of a month is the same as the month's (English) name, except for the months of Adar Rishon and Adar Sheni.  The month-key of Adar Rishon is #AdarL, and the month-key of Adar Sheni is #Adar (the same as that of Adar, since it is semantically the same month.)			Tishri is the first month of the year.  Elul is the last.  However, the Jewish religion labels the months with a numerical designator such that the month of Nisan (which by mathematical definition is the 7th month of the year in a non-leap year) has the numerical label 1, to indicate that it is the first month of the year for religious purposes--in spite of the fact that New Year's Day (the day whose initial moment marks the transition from one year to the next) is nevertheless the first day of the month of Tishri (whose religious numerical designator is 7.) 			However, Chronos requires that, for all calendars universally, the ordinal number of the month that contains the first day of the year must be 1 (in other words, the month ordinal must literally be an ordinal number that counts months since the start of the year, and so must be a number greater by one than the cardinal number of months since the month that begins a year.)  Consequently, the Chronos month ordinal for the month of Tishri in the Hebrew Calendar is 1, not 7.			The Calendar API provides the messages #monthOrdinalFromNumericMonthDesignator:forYearTypeCode: and #numericMonthDesignatorFromMonthOrdinal:forYearTypeCode: for the purpose of translation to/from canonical month ordinals and culturally-correct "numerical month designators." Sending the message #month to a point-in-time object (a DateSpec, YearMonthDay, DateAndTimeSpec or DateAndTime/Timepoint,) provides the mathematically-correct month ordinal of the date (as required by the ANSI-Smalltalk standard.) Sending the message #numericMonthDesignator to a point-in-time object (a DateSpec, YearMonthDay, DateAndTimeSpec or DateAndTime/Timepoint,) provides the culturally-correct month number.  Be sure to use these messages appropriately when capturing dates from, or presenting dates to, the users of an application (a ChronosPrintPolicy can be used to print dates using month ordinals, numeric month designators, month names or month abbreviations.) Applications must provide their own date capture and/or date parsing mechanisms. </body></comment><class><name>CalendarClock</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>systemClock calendar secondsFromCalendarEpochUpToSystemClockEpoch secondsFromGregorianEpochUpToSystemClockEpoch </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.CalendarClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})CalendarClock	Concept:		CalendarClock is an abstract class.  An instance of a concrete subclass of CalendarClock functions as a clock that reports the current date and/or time with respect to a particular calendrical system.  The current date and/or time may be represented by "date," "time-of-day" or "point-in-time" values.  In the case of "point-in-time" values, a CalendarClock instance generates values that conform to the ANSI-Smalltalk "DateAndTime" protocol. By default, a "date" value will be an instance of YearMonthDay, a "time-of-day" value will be an instance of TimeOfDay, and a "point-in-time" value will be an instance of Timepoint (which will be aliased by the global DateAndTime, unless that name is normally assigned to some non-Chronos class.) A CalendarClock is also responsible for converting Chronos date and time objects from and to those that are native to the host Smalltalk environment.		The two standard concrete subclasses of CalendarClock--UTCalendarClock and LocalTimeCalendarClock--are specialized for dealing with the two fundamentally-different possible operational paradigms of different system clocks: those that report time relative to the UT timezone and those that report time relative to the local timezone. See the classes UTCalendarClock and LocalTimeCalendarClock for more information.		So conceptually, a CalendarClock is responsible for a) encapsulating a ChronosSystemClock (which see,) regardless of whether it reports time relative to the UT timezone or relative to the local timezone, regardless of its resolution (seconds, milliseconds, microseconds, nanoseconds...,) and regardless of its epoch (the moment-in-time represented by a zero ticks of the system clock, b) converting the current time reported by the encapsulated system clock (as a number of ticks since the system clock epoch, relative to either the UT or local timezone) into a number of seconds and nanoseconds since the epoch of the Calendar to which it is bound, c) converting the number of seconds/nanoseconds since the epoch of its Calendar into a "time-of-day," "date," or "point-in-time" value (as implemented by an appropritate class in the Chronos Date/Time library,) and d) (in collaboration with the SystemClock) converting Chronos time objects to and from their analogs provided by the native/host Smalltalk environment (if any.)		See the class comment of ChronosSystemClock for more information, including a glossary of clock terminology.	Usage:		As is the case with most Chronos classes, CalendarClock instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		Each Chronos Calendar (which see) provides its own CalendarClock flyweight object, which can be accessed by sending the message #clock to either the Calendar instance, or to its class. Each CalendarClock is bound to a particular Chronos Calendar. The time values provided by a CalendarClock specify the current date and time according to the rules of the calendrical sytem implemented by the Calendar to which the CalendarClock is bound.  For example, to access the current date and/or time in terms of the Hebrew Calendar, a CalendarClock bound to the Hebrew Calendar must be used. The following expressions evaluate to the current date and time according to various Calendars:						GregorianCalendar clock now. 			PersianCalendar clock now. 			EthiopicCalendar clock now. 					"Note: The time-of-day clock for the Ethiopic Calendar starts at 6 am (sunrise.)"		The Chronos namespace (shared pool) defines the global variable AnsiStandardCalendarClock, which aliases the CalendarClock that is bound to the GregorianCalendar.  "GregorianCalendar clock" and "AnsiStandardCalendarClock" should be the same object--as should "CalendarClock default."		The messages for accessing the current date and/or time can be categorized as follows:													Temporal Locality/Relativity Semantics			Type-of-return-value	Default Timezone				Specified Timezone				UT Timezone					Nominal Time						TimeOfDay			#timeOfDayNow					#timeOfDayNowIn:				#utTimeOfDayNow				N/A			TimeOfDay			#timeOfDayNowToTheSecond	#timeOfDayNowToTheSecondIn:	N/A								N/A			YearMonthDay		#dateToday						#dateTodayIn:					N/A								N/A			DateAndTime 		#today							#todayIn:						#utToday						#nominalToday						DateAndTime		#now							#nowIn:							#utNow							#nominalNow			DateAndTime		#nowToTheSecond				#nowToTheSecondIn:			N/A								#nominalNowToTheSecond					The difference between #now and #nowIn: (for example) is that #now provides the current time relative to the current default time zone, whereas #nowIn: provides the current time relative to the time zone provided as the message argument (each answers an object that probably represents a different local time.)		The difference between #now and #utNow (for example) is that #now provides the current time relative to the current default time zone, whereas #utNow provides the current time relative to the UT time zone (each answers an object that probably represents a different local time.)		The difference betweeen #now/#utNow/#nowIn: and #nominalNow (for example) is that #now/#utNow/#nowIn: provide answers that represent time values that are bound to a particular time zone using UT-invariant semantics (which means it represents a well-defined point-in-time relative to the international reference UT timezone,) whereas #nominalNow provides an answer that represents time using nominal-time invariant semantics (which means it represents a particular nominal time without specifying a fixed relation or mapping to any absolute temporal coordinate system.)  See the class comments of Timepoint, ChronosTimezone and NominalTimeInvariantTZ for more information about the differences between "UT-invariant semantics" and "nominal time semantics."		The difference between #dateToday and #today (for example) is that #dateToday provides an answer that is only a "date" value, and not a "point-in-time" value, whereas #today provides a "point-in-time" value that represents the first moment of the day.				The messages for getting the current time that provide DateAndTime and TimeOfDay values have variants that only provide the current time to the second, and omit any fractions of a second that the system clock may provide.  Such messages provide one way to suppress the print out of fractional seconds (using a ConfigurableChronosPrintPolicy configured to #hideSubsecondFraction is the other.)  They also provide a significant performance advantage for those situations where time-to-the second is good enough.		It should also be noted that "time-of-day" and "date" values always have nominal time semantics in Chronos--they aren't bound (specific) to any particular time zone. The same is true of "Blue Book"/ST-80 "Date" and "Time" objects (and also of  VisualWorks "Timestamp" objects.) Once created, time-valued objects that aren't bound to a specific time zone have no deterministic, precise mapping or relation to any absolute timescale.  For example, A VisualWorks Timestamp created on a computer running in Bangalore can easily be transported over a network (or in a notebook computer travelling by airplane) to New York, but absent contextual information that the object itself does not encapsulate, there is no way to deterministically convert it to local time in New York. Such is the nature of nominal time values: they specify the designation of a time value, but fail to specify how to map the designated time to any absolute reference scale--a property that is desirable in some situations, and highly undesirable in others.		Timepoint class and ChronosTimezone both provide a similar API for retrieving the current date and/or time.	Motivation:		Since the Chronos Date/Time library is intended to be portable among a wide variety of different Smalltalk implementations, it is necessary to be able to deal with the operational paradigm of whatever system clock happens to be available in a particular case. In many cases, the Smalltalk VM provides its own virtual system clock, encapsulating whatever may be available from the operating system kernel. In such cases, the VM's virtual system clock is probably the only one that's easily-accessible--which mean that it's operational paradigm is the one that must be dealt with, like it or not. Specific cases that exemplify the problem: The VisualWorks VM's virtual system clock reports time relative to the UT timezone (which the VW documentation refers to a "UTC (GMT)"--the first of which is a timescale that--unlike the VW system clock--uses leap seconds, and the second of which is no longer formally/officially defined,) but the Squeak VM's virtual system clock reports time relative to the local timezone. In neither case would it be trivial to use a system clock other than the virtual one provided by the VM.		Chronos' solution to the problem of the differences between system clock operational paradigms is to provide two distinct layers of encapsulation over whatever "system clock" may be available in a particular Smalltalk execution environment: the ChronosSystemClock class, that encapsulates the protocol for accessing the platform system clock's current tick value (and also provides the meta information necessary to interpret the meaning of the system clock's tick count,) and the CalendarClock class, that encapsulates the mechanisms by which the ChronosSystemClock's meta information is used to convert its tick count into Chronos date/time objects representing temporal values according to a particular calendrical system.	Implementation:		Instance Variables			systemClock 											&lt;ChronosSystemClock&gt;				The ChronosSystemClock encapsulated by the instance, from which the current time is obtained as a count of ticks since the epoch of the system clock, and from which the meta-information is obtained needed in order to interpret the meaning of the count of clock ticks (see ChronosSystemClock for more information.)			calendar 												&lt;Calendar&gt;				The Calnedar that implements the calendrical system that the instance will use to represent the date and/or time values it generates.			secondsFromCalendarEpochUpToSystemClockEpoch 	&lt;Integer&gt;				The number of seconds from the epoch of the instance's &lt;calendar&gt; up to the epoch of its &lt;systemClock&gt;.			secondsFromGregorianEpochUpToSystemClockEpoch	&lt;Integer&gt; 				The number of seconds from the epoch of the Gregorian Calendar up to the epoch of the instance's &lt;systemClock&gt;.	Subclassing:		Concrete subclasses must subimplement the following instance methods:			#basicDateTodayIn:			#basicTodayIn:			#nowIn:includeNanoseconds:			#timeOfDayNowIn:includeNanoseconds:			#utNow			#utTimeOfDayNow			#utToday</body></comment><class><name>LocalTimeCalendarClock</name><environment>Chronos</environment><super>Chronos.CalendarClock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.LocalTimeCalendarClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})LocalTimeCalendarClock	Concept:				A LocalTimeCalendarClock is CalendarClock (which see) specialized for encapsulating a ChronosSystemClock that reports time relative to the current default timezone.</body></comment><class><name>TemporalInterval</name><environment>Chronos</environment><super>Chronos.ChronosPrintable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.TemporalInterval</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})TemporalInterval	Concept:		TemporalInterval is an abstract class. An instance of a concrete subclass of TemporalInterval represesents a temporal interval--specifically, a left-closed, right-open interval of time.  A temporal interval is a temporal extent that starts at a particular point-in-time. A left-closed, right-open interval is one that includes its left endpoint (its starting point,) but does not include its right endpoint (its ending point, or limit value.) The left endpoint of a TemporalInterval is the initial moment contained by the interval. The right endpoint/limit value is that point-in-time computed by adding the TemporalInterval's temporal extent to its starting point-in-time. Since a TemporalInterval represents an interval that includes its starting point-in-time, but does not include its ending point, a TemporalInterval representing the interval that started at the most recent local midnight, and whose temporal extent is one calendrical/civil day, asymptotically spans up to but does not include the next day's midnight.		A TemporalInterval also represents a value associated with or related to a particular Calendar (which see.) TemporalInterval provides protocol for accessing the Calendar to which a TemporalInterval is associated, and for accessing properties of the associated Calendar (e.g, does the associated Calendar have an invariant number of months per year?)		TemporalInterval also provides/implements "Magnitude" behavior/protocol (comparison operators,) Immutable behvavior/protocol and ChronosObject behavior/protocol.		A TemporalInterval has the attributes #resolutionQuantum and #duration. The #resolutionQuantum of a TemporalInterval is the minimum non-zero interval of time by which one instance of a concrete subclass of Calendrical can differ from that of another instance of the same class. The #duration of a TemporalInterval is the interval of time spanned by the instance. Although the #resolutionQuantum and the #duration will often be the same, there are cases where they differ (see, for example, Timeperiod). The #resolutionQuantum and the #duration attributes are both represented by instances of Durational (e.g., a ScientificDuration or a CalendarDuration.)	Usage:		The starting point of a TemporalInterval can be accessed by sending the message #start to a Timeperiod instance.		The temporal extent of a TemporalInterval is represented by an instance of Durational (which see,) and can be accessed by sending the message #duration to a TemporalInterval instance. The temporal extent may be negative--in which case the TemporalInterval's endpoint (limit value) is temporally prior to its starting point.  Also, the temporal extent may be either a simple scalar number of seconds, or a vector specifying some number of years, months, days, hours, minutes and seconds. 		The end-point or "limit value" of a TemporalInterval is computed by adding its temporal extent (duration) to its starting point.  It can be accessed by sending the message #limit to an instance.  The end-point/limit is not included by the TemporalInterval.		The granularity of a TemporalInterval is defined to be the quantum of resolution of its starting point-in-time (accessible by sending the message #granularity to a Timeperiod instance.)  The quantum of resolution of a date value is one calendar day.  The quantum of resolution of a DateAndTime value is the same as that of a Duration value--currently implemented to be one nanosecond. 		In the case of a TemporalInterval with a positive duration, its "closed extent" is (conceptually) the temporal extent (duration) of the **fully-closed** interval that contains every point-in-time that is greater than or equal to the TemporalInterval's earliest point-in-time, and less than its latest point-in-time. In the case of a TemporalInterval with a negative duration, its "closed extent" is (conceptually) the temporal extent (duration) of the **fully-closed** interval that contains every point-in-time that is less than or equal to the TemporalInterval's latest point-in-time, and greater than its earliest point-in-time. Physically, its "closed extent" is defined to be the temporal extent (duration) computed by subtracting the TemporalInterval's granularity from its temporal exent (i.e., "aTimeperiod duration - aTimeperiod granularity.") It can be accessed by sending the message #closedExtent to a TemporalInterval instance.		The first element of a Timeperiod is its starting point-in-time. It can be accessed by sending the message #first to a Timeperiod instance (to provide a small degree of polymorphism with SequenceableCollections/Intervals.)  The last element of a Timeperiod is the point-in-time computed by adding the Timeperiod's closed extent to its starting point-in-time ("aTimeperiod start + aTimeperiod closedExtent." The last element of a Timeperiod can be accessed by sending the message #last to an instance. 				The quantum of resolution of the last element may or may not be the same as that of the first element, depending upon the nature of the Durational value that represents the TemporalInterval's closed extent (if it's either a non-zero ScientificDuration, or a CalendarDuration where the "seconds" element of its duration vector is non-zero, then the TemporalInterval's last element will have a 1-nanosecond quantum of resolution.)  For example, "(Timeperiod dayStartingAt: Timepoint today) last" evaluates to the final nanosecond of the current day, but "(Timeperiod quarterStartingAt: YearMonthDay today) last" evaluates to the last date of the quarter that started on today's date. The last day of the quarter, since it's a date value, conceptually includes all the points-in-time of that date, because the quantum of resolution of a Chronos date value is 1 calendar day, and a Chronos point-in-time value implicitly represents a left-closed, right-open interval, whose starting point (left endpoint) is the moment nominally designated by the value, and whose (open) temporal extent is the value's quantum of resolution.		TemporalInterval introduces the API message #compareTo:, which is used to compute the relative ordering between two values (less than, equal to or greater than.)  See the method comment of #compareTo: for specific details.		Implementation:		Unlike class Magnitude, Calendrical implements all the other comparison methods using #compareTo:.	Subclassing:		Subclasses that store an instance of Calendar must subimplment the #invalidateCalendar method.		Concrete subclasses must subimplement the following instance methods:					#compareTo:			#initializeFromLiteralArray:		(also see the class method #basicDecodeFromLiteralArray:)			#literalArrayEncoding		</body></comment><class><name>TemporalCoordinate</name><environment>Chronos</environment><super>Chronos.TemporalInterval</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.TemporalCoordinate</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>CalendricalCoordinate</name><environment>Chronos</environment><super>Chronos.TemporalCoordinate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.CalendricalCoordinate</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>AbstractDate</name><environment>Chronos</environment><super>Chronos.CalendricalCoordinate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>calendar </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.AbstractDate</class-id><body></body></comment><class><name>AnnualDate</name><environment>Chronos</environment><super>Chronos.AbstractDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.AnnualDate</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>ResourcePathFacade</name><environment>Passport</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourcePathContext rootDirectoryMetavalueString defaultRootDirectoryString </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ResourcePathFacade</class-id><body>ResourcePathFacade	Concept:		The Passport inter-Smalltalk portability library uses an instance of a concrete subclass of the abstract class ResourcePathFacade as a facade for accessing remote and/or persistent resources--resources that would usually, but not necessarily, reside in files contained in a file system. Unfortunately the API (or perhaps the language syntax) for performing such functions is generally different accross implementations of Smalltalk--and that fact is the primary motivation for the existence of this class. 		In addition to cross-platform portability, ResourcePathFacade is intended to enable access to resources that don't reside as local flat files--and perhaps aren't resident in files at all..	Usage:		Instances of concrete subclasses may or may not be stateless--so in general there is no canonical instance, and neither the Singleton nor the Flyweight patterns are assumed by the abstract superclass.		Instantiation  			A new instance of a ResourcePathFacade is created by sending the message #new to its class. 		External/Persistent/Remote Resource Operations			The Passport inter-Smalltalk portability library uses instances of the class ResourcePath (which see) in order to open external streams connected to external resources (e.g, files) for the purpose of storing/retrieving application reference data.  ResourcePaths depend upon services provided by a ResourcePathFacade instance for the implementation of their functionality.  Such services include: a) interconversion between ResourcePaths and whatever objects the native Smalltalk implementation uses to specify external/persistent/remote resources (instances of Filename in VisualWorks, instances of String more typically)--although URIs could also be used; b) "directory operations" by which external resources can be created, copied, removed, relocated and renamed, and by which external "file systems" (or more generally, namespaces containing external/persistent/remote resources  (e.g.. LDAP)) can be introspected/navigated; and c) stream creation operations for opening streams on the contents of external/persistent/remote resources (whose API is based on the API for external stream creation specified by the ANSI Smalltalk standard.)   Such services/operations must be provided by the ResourcePathFacade because their implementation is highly non-portable among the various Smalltalk implementations, and also because some applications and/or  code libraries may want/need to use something other than disk files to store/reftrieve their reference data.	Motivation:		By concentrating all system-specific code in the class hierarchies of ResourcePathFacade and EnvironmentFacade, and by defining a standard API for the invocation of non-portable services, ResourcePathFacade enhances the portability of the applications and libraries written in Smalltalk, both with respect to different implementations/versions of Smalltalk and also with respect to the varying needs and preferences of applications and/or code libraries.	Implementation:	Subclassing:		ResourcePathFacade is an abstract class.  A concrete subclass appropriate for use on a particular platform, in a particular system environment, for use by a particular client application, must be provided.  The instance methods that MUST be subimplemented in order to provide a fully operational ResourcePathFacade object (all of which have method comments documenting the behavior for which the method is responsible) are as follows:			Method Selector																		Subimplmentation Requirement			#constructResourcePathFromNativeResourceID:								Mandatory--must have substantive implementation			#resourceExists:																	Mandatory--must have substantive implementation			#resourceIsDirectory:																Mandatory--must have substantive implementation			#makeDirectory:																	Mandatory--must have substantive implementation			#newExternalReadStream:type:													Mandatory--must have substantive implementation			#newExternalWriteStream:mode:check:type: 									Mandatory--must have substantive implementation			#renameResource:to:																Mandatory--must have substantive implementation			#withResourcePathsOfResourcesInDirectory:do:								Mandatory--must have substantive implementation		Additionaly, the following instance methods may require subimplementation in some cases--Chronos doesn't use them, but users of Chronos might:			Method Selector																		Subimplmentation Requirement			#copyResource:to:																	Optional--can be no-op (present solely for API completeness.)			#deleteResource:																	Optional--can be no-op (present solely for API completeness.)			#moveResource:to:																	Optional--can be no-op (present solely for API completeness.)			#sizeOfResource:																	Optional--can be no-op (present solely for API completeness.)</body></comment><class><name>VWFilenameFacade</name><environment>Passport</environment><super>Passport.ResourcePathFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWFilenameFacade</class-id><body></body></comment><class><name>VWClassicFilenameFacade</name><environment>Passport</environment><super>Passport.VWFilenameFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWClassicFilenameFacade</class-id><body></body></comment><class><name>TimezoneProcessor</name><environment>Chronos</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth defaultZoneName </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.TimezoneProcessor</class-id><body></body></comment><class><name>Registratable</name><environment>Passport</environment><super>Passport.Immutable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registrationKey </inst-vars><class-inst-vars>registry </class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.Registratable</class-id><body>Registratable	Concept:		Registratable is an abstract class that establishes a framework for classes whose instances may optionally be registered in a registry maintained by the class. The implementation/creation of the instance registry is the responsibility of each concrete subclass.		A Registratable has a #registrationKey (for which the synonym #key is provided for polymorphism with other keyed objects.) A Registratable may be registered in its class' instance registry under its #registrationKey, and it may additionally be registered using an alias (a key other than its #registrationKey.)			Registratable also provides/implements Immutable behvavior/protocol and ChronosObject behavior/protocol (by inheritance.)	Usage:		By default, instances will only be registered when explicitly sent one of the registration messages--registration does not automatically occur when an instance is created or initialized.  Subclasses may override this behavior.		Registration forces an instance to become immutable (see the superclass Immutable.)		An instance can be retrieved from the instance registry by sending #at: or #at:ifAbsent: to its class. Also, the class method #referencedBy: (protocol inherited from ChronosObject) is subimplemented so that, if the argument is a String, the argument will be used as the key by which to retrieve an instance from the instance registry.		An instance will be deregistered when sent either the message #deregister or the message #release.  Also, if the instance registry happens to be a WeakDictionary, then the instance will be deregistered by the garbage collection mechanism once it is found to have no active references.	Implementation:				Instance Variables			registrationKey	&lt;Object&gt;	The key that will be used to register the instance in the instance registry.	Subclassing:		Concrete subclasses must subimplement the following class methods (see the method comments for more details):		#aliasRegistryIfNone:		#basicAliasRegistry		#basicRegistry		#default		#registryIfNone:		#setAliasRegistry		#setRegistry</body></comment><class><name>ChronosPrintPolicy</name><environment>Chronos</environment><super>Passport.Registratable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Printing</category><attributes><package>Chronos-Printing</package></attributes></class><comment><class-id>Chronos.ChronosPrintPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>ConfigurableChronosPrintPolicy</name><environment>Chronos</environment><super>Chronos.ChronosPrintPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>effectiveLocaleKey dayOfWeekPolicy dateAndTimeOrder datePolicy yearPolicy monthPolicy yearMonthSep monthDaySep dayYearSep yearPadChar monthPadChar dayOfMonthPadChar eraPolicy standardCalendarRegistrationKey showTimeOfDay hour24 dateAndTimeSeparator timeOfDayPrefix hourMinuteSecondSeparator hourPadChar decimalPointChar subSecondTimeMinPrecision dateAndTimeMaxPrecision timeZonePrintPolicy timeZoneSeparator timeZoneElementSeparator showNamesOfDurationElements showNamesOfCalendarDurationElements suppressZeroValuedDurationElements suppressZeroValuedCalendarDurationElements durationElementSep calendarDurationElementSep durationDayHourSep calendarDurationDayHourSep durationPadChar calendarDurationPadChar subSecondDurationMaxPrecision </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Printing</category><attributes><package>Chronos-Printing</package></attributes></class><comment><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>UrlPathFacade</name><environment>Passport</environment><super>Passport.ResourcePathFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.UrlPathFacade</class-id><body></body></comment><class><name>VWUrlPathFacade</name><environment>Passport</environment><super>Passport.UrlPathFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWUrlPathFacade</class-id><body></body></comment><class><name>VWHttpUrlFacade</name><environment>Passport</environment><super>Passport.VWUrlPathFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWHttpUrlFacade</class-id><body></body></comment><class><name>UntilEndOfYearTimeZoneTransition</name><environment>Chronos</environment><super>Chronos.AnnuallyRecurringTZPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-Policies-Annual</category><attributes><package>Chronos-TimeZones-Policies-Annual</package></attributes></class><comment><class-id>Chronos.UntilEndOfYearTimeZoneTransition</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UntilEndOfYearTimeZoneTransition	Concept:		An UntilEndOfYearTimeZoneTransition is an AnnuallyRecurringTZPolicy that functions as the last/final ruleform in the rule chain that specifies the offset/abbreviation tuples that apply within the territorial domain of a time zone during every moment of the year. The ruleform represented by an UntilEndOfYearTimeZoneTransition instance expires at the end of every year, and is succeded by the first rule in its rule chain (which may be itself, if it's the only rule in the chain.) 		See the superclass AnnuallyRecurringTZPolicy for more information.</body></comment><class><name>AnnuallyRecurringTZPolicyFactory</name><environment>Chronos</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>offsetSecondsFromUT stdTimeOffsetSecondsFromUT commonAbbreviation </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-PolicyFactories-Annual</category><attributes><package>Chronos-TimeZones-PolicyFactories-Annual</package></attributes></class><comment><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})AnnuallyRecurringTZPolicyFactory	Concept:		AnnuallyRecurringTZPolicyFactory is an abstract class. An instance of a concrete subclass of AnnuallyRecurringTZPolicyFactory specifies the offset and abbreviation that apply within the territorial domain of a time zone during some annually-recurring portion of a calendar year. 		However, the purpose of an AnnuallyRecurringTZPolicyFactory is not to actually itself provide time-zone behavior, but rather to serve as a factory for creating an AnnuallyRecurringTZPolicy instance.  Although it represents essentially the same information as an AnnuallyRecurringTZPolicy, its purpose and behavior are different. An AnnuallyRecurringTZPolicy's behavior is targeted at resolving the offset/abbreviation tuple (in the form of a "bound, dynamic" time zone instance) that applies within the territorial domain of a time zone at a particular point-in-time.  An AnnuallyRecurringTZPolicyFactory's behavior is targeted at correctly instantiating an AnnuallyRecurringTZPolicy using the minimum possible amount of memory, and also at providing an API for the construction and editing of a time zone's ruleset that is considerably easier to understand and use than is the case for an AnnuallyRecurringTZPolicy.		A list of AnnuallyRecurringTZPolicyFactoriess is used by instances of TimeZonePolicyElementFactory to specify the offset and abbreviation that apply within the territorial domain of a time zone during soem sequence of calendar years--in other words, to specify the intra-year time zone rules, including the offset/abbreviation transitions that annually recur each year (if any.)	Implementation:		Instance Variables			offsetSecondsFromUT				&lt;Integer&gt; 	The number of seconds offset from Universal Time that defines "local time" (within the territorial domain of the time zone whose ruleset is (partially) specified by the instance) during any periods of time that the time zone rule specified by the instance is in effect.			stdTimeOffsetSecondsFromUT	&lt;Integer&gt;	The number of seconds offset from Universal Time that defines "local time" (within the territorial domain of the time zone whose ruleset is (partially) specified by the instance) during any periods of time that "standard time" is in effect (e.g., whenever DST is not being observed.)			commonAbbreviation 				&lt;Symbol&gt;	The commonly-used abbreviation for the timezone whose ruleset is (partially) specified by the instance during any periods of time that the time zone rule specified by the instance is in effect.	Subclassing:		Concrete subclasses must subimplement the instance methods:	 		#asPolicyFor:			#typeKey			</body></comment><class><name>UntilEndOfYearTimeZoneTransitionFactory</name><environment>Chronos</environment><super>Chronos.AnnuallyRecurringTZPolicyFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-PolicyFactories-Annual</category><attributes><package>Chronos-TimeZones-PolicyFactories-Annual</package></attributes></class><comment><class-id>Chronos.UntilEndOfYearTimeZoneTransitionFactory</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UntilEndOfYearTimeZoneTransitionFactory	Concept:		An UntilEndOfYearTimeZoneTransitionFactory is an AnnuallyRecurringTZPolicyFactory that functions as the last/final ruleform in the sequence of ruleforms that specifies the offset/abbreviation tuples that apply within the territorial domain of a time zone during every moment of a calendar year. The ruleform represented by an UntilEndOfYearTimeZoneTransitionFactory instance expires at the end of every year, and is succeded by the first rule in its sequence (which may be itself, if it's the only rule in the sequence.) 		However, the purpose of an UntilEndOfYearTimeZoneTransitionFactory is not to actually itself provide time-zone behavior, but rather to serve as a factory for creating a UntilEndOfYearTimeZoneTransition instance.  Although it represents essentially the same information as an UntilEndOfYearTimeZoneTransition, its purpose and behavior are different. 		See the superclass AnnuallyRecurringTZPolicyFactory for more information.	</body></comment><class><name>AlwaysSystemTZ</name><environment>Chronos</environment><super>Chronos.ProxyTZ</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.AlwaysSystemTZ</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})AlwaysSystemTZ	Concept:		The canonical instance of AlwaysSystemTZ (accessible by sending the class message #alwaysSystem to ChronosTimezone) refers by proxy to whatever Timezone is currently set as &lt;Timezone system&gt;. A Timepoint with this timezone always represents the same time UT, but its local time is dynamically determined by whatever Timezone is set as the current system timezone--in other words, its UT time is invariant, but its local time varies dynamically as a function of any change to whichever timezone == Timezone system.		See ProxyTZ and ChronosTimezone for further information.	Usage:		An AlwaysSystemTZ conforms to the Chronos "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.		The key of the "always system" time zone is #alwaysSystem.	Motivation:		The "always system" time zone enables the presentation of point-in-time values as local to whatever time zone is currently set as the system time zone.</body></comment><class><name>ExternalResource</name><environment>Passport</environment><super>Passport.Registratable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ExternalResource</class-id><body></body></comment><class><name>SolarianCalendar</name><environment>Chronos</environment><super>Chronos.MonthsPerYearInvariantCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.SolarianCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})SolarianCalendar	Concept:		SolarianCalendar implements the Solarian Calendar.  The SolarianCalendar is an invention of the author of Chronos.  It was designed to ensure that, as far as possible, the solstices and equinoxes should occur on either the first of a month, or else on the last day of the previous month.  The formal, official specification of the Solarian calendrical system has not yet been finalized.		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Solarian Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Solarian Calendar is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		Epoch Date			The epoch date of the Solarian Calendar, 0001-01-01 [Solarian], corresponds to 4236-12-23 [Gregorian] (astronomical year numbering) and to -4236-01-26 [Julian] (traditional year numbering.)  The Julian Date of the epoch of the Solarian Calendar is 174,249.50 (midnight.) 			The epoch date of the Solarian Calendar is the Winter Solstice of the year in which the ancient Egyptian Calendar was founded, which corresponds to 4236 BC. This is the earliest recorded year in history.			The name of the Solarian Calendar's era is "Solarian Year" (SY)--which is in English, obviously.		Time-of-Day Clock			Midnight is both the zero-point of the time-of-day clock and also the initial moment of the day.  			{SolarianCalendar clock today}			{SolarianCalendar clock now}		Year Numbering Policy			The Solarian Calendar uses ordinal year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year 0.		Leap Year Rule			There is a master cycle of 2820 years, during which 683 years are leap years. Each standard year contains 365 days, and each leap year contains 366 days, so the master 2820-year cycle contains 1,029,983 days [(2820 * 365) + 683 = 1,029,983].  Based on the current mean length of the tropical year and solar day, there are 1,029,983.00118 days in 2820 tropical years.  So, were it not for the fact that a) the length of the tropical year and the length of a mean solar day is slowly changing, and b) the length of the tropical year (which is defined by the duration between winter solstices) is not the same as the length of the spring equinoctial year (which is defined by the duration between vernal equinoxes,) it would be fair to say that the Solarian calendar deviates from the length of a year by only 101.952 minutes in 2820 years.  But for those (and other) caveats, the Solarian calendar would slip from perfect alignment with the tropical year by only one day every 39,829.68 years--which is astounding accuracy, in spite of the caveats. 			Within each 2820-year cycle, there are 22 subcycles--the first 21 each contain 128 years, and the 22nd (final) subcycle contains 132 years [2820 = 21 * 128 + 132].			Each 128-year subcycle contains one 29-year sub-subcycle (the first,) followed by three 33-year sub-subcycles [128 = 29 + (3 * 33)].			Each 132-year subcycle contains one 29-year sub-subcycle (the first,) followed by two 33-year sub-subcycles, followed by one 37-year sub-subcycle [132 = 29 + (2 * 33) + 37].			A year in a sub-subcycle (whether it contains 29, 33 or 37 years) is a leap year if the ordinal index of the year within the cycle satisfies the following two predicate tests: 1) it's greater than 1, and 2) the remainder after dividing it by 4 is 1 (so the first year in sub-subcyle is never a leap year; the first leap year is the fifth year in the sub-subcycle.) Thus, a 29-year sub-subcycle has 7 leap years, a 33-year sub-subcycle has 8 leap years, and a 37-year sub-subcycle has 9 leap years (Note: the last year of a sub-subcycle is always a leap year, since 29, 33 and 37 all result in a remainder of 1 when divided by 4) [21 * (7 + (3 * 8)) + (7 + (2 * 8) + 9) = 683].		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: Month1					28/28			2: Month2					30/31			3: Month3					31/31			4: Month4					31/31			5: Month5					31/31			6: Month6					31/31			7: Month7					31/31			8: Month8					31/31			9: Month9					31/31			10: Month10				31/31			11: Month11				31/31			12: Month12				28/28			Days In Year				365/366			The names of the months are acutually unspecified.  It is the responsiblity of each culture/language group to devise or evolve month names that are appropriate to their language and culture. The semantic month-key of a month is the English word #Month followed by one or more digits that identify the month ordinal.				</body></comment><class><name>PassportMetanumber</name><environment>Passport</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lock </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			private Smalltalk.*			</imports><category>Passport-Magnitude-Numbers</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.PassportMetanumber</class-id><body></body></comment><class><name>PassportNotANumber</name><environment>Passport</environment><super>Passport.PassportMetanumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Magnitude-Numbers</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.PassportNotANumber</class-id><body></body></comment><class><name>ImperialJulianCalendar</name><environment>Chronos</environment><super>Chronos.AbstractJulianCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.ImperialJulianCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ImperialJulianCalendar 		Concept:		ImperialJulianCalendar implements the original Julian Calendar as used in Imperial Rome.  		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Julian Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Imperial Julian Calendar is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		See the class comment of AbstractJulianCalendar for information about the Julian Calendar common to all its variations. For more information about the Modern Julian Calendar used by historians (and by some religions,) see the class JulianCalendar.		Epoch Date			The pre-Imperial, Imperial and post-Imperial Romans counted time from various reference points that changed frequently. However, there was one "epoch year" that was canonically (albeit infrequently) used to unify all their various time counts: the year of the founding of the city of Rome. That era that was called "Ab Urbe Condita," Latin for "From the Founding of the City."  So the epoch date of the Imperial Julian Calendar is 1 January 1 Ab Urbe Condita (AUC,) which corresponds to 1 January 753 BC [Julian].			 The Julian Date of the epoch of the Imperial Julian Calendar is 1,446,389.50 (midnight.) 		Time-of-Day Clock			For this implementation, midnight is both the zero-point of the time-of-day clock and also the initial moment of the day.  However, such has not always been the case for all users of the Imperial Julian Calendar.			{ImperialJulianCalendar clock today}			{ImperialJulianCalendar clock now}		Year Numbering Policy			The Imperial Julian Calendar uses ordinal year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year 0.		Leap Year Rule			De jure, a year is a leap year if dividing its year ordinal by 4 results in a remainder of 1. The de facto situation is more complicated.			The Roman priesthood in charge of the Roman calendar (the pontiffs) were mathematically challenged, and so failed to correctly follow the de jure rules for leap years specified by Caesar. The pontiffs mistakenly failed to insert a leap day in 45 BC (709 A.U.C.,) inserting it in 44 BC (710 AUC) instead. Then, from 44 BC to 8 BC (710 A.U.C. to 746 A.U.C.), they inserted a leap day every three years, instead of every 4 (Caesar's decree making his calendar the official civil calendar of the Roman Empire required a leap year every 4 years.) When the error was discovered, Emperor Augustus (Caesar's nephew) was obliged to omit the insertion of leap days between 7 BC and 3 AD (746 A.U.C. to 756 A.U.C.) In 4 AD (757 A.U.C.,) after the extra leap day intercalations had been corrected, itercalation of the leap day was resumed. 			Which years were actually observed as leap years by the Roman pontiffs has long been a subject of some controversy. The years used by Chronos are based on a recently-published ancient document, as discussed in the following reference [http://www.nationmaster.com/encyclopedia/Julian-calendar]: 			"In 1999, an Egyptian papyrus was published which gives an ephemeris table for 24 BC with both Roman and Egyptian dates. From this it can be shown that the most likely sequence was in fact 44, 41, 38, 35, 32, 29, 26, 23, 20, 17, 14, 11, 8 BC, AD 4, 8, 12 etc., very close to that proposed by Matzat. This sequence shows that the standard Julian leap year sequence began in AD 4, the twelfth year of the Augustan reform. Also, under this sequence the actual Roman year coincided with the proleptic Julian year between 32 and 26 BC. This suggests that one aim of the realignment portion of the Augustan reform was to ensure that key dates of his career, notably the fall of Alexandria on 1 August 30 BC, were unaffected by his correction. 			Roman dates before 32 BC were typically a day or two before the day with the same Julian date, so 1 January in the Roman calendar of the first year of the Julian reform actually fell on 31 December 46 BC (Julian date). A curious effect of this is that Caesar's assassination on the Ides (15th day) of March in 44 BC fell on 14 March 44 BC in the Julian calendar."		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: January					31/31			2: February					28/29			3: March					31/31			4: April						30/30			5: May						31/31			6: June						30/30			7: July						31/31			8: August					31/31			9: September				30/30			10: October					31/31			11: November				30/30			12: December				31/31						Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name.		Motivation:			Since no one has used the Roman Imperial Julian Calendar, nor its Clerical variation, for over a thousand years, the only "use case" for this ancient calendar is the interpretation of dates in ancient documents and inscriptions. Consequently, Chronos provides the class ImperialJulianCalendar that fully implements the "de facto" Imperial Julian Calendar, using the "Ab Urbe Condita" era, and duplicating the leap-year schedule used by the Roman pontiffs.  It makes sense to combine the "Ab Urbe Condita" epoch with the "de facto" leap year rules of the Roman pontiffs, because both actually go together historically (one might actually encounter such dates in an ancient document or inscription.)  Such is not the case for dates using the "Anno Domini" era and the "Julian" calendar.</body></comment><class><name>Durational</name><environment>Chronos</environment><super>Chronos.ChronosPrintable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Duration</category><attributes><package>Chronos-Duration</package></attributes></class><comment><class-id>Chronos.Durational</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})Durational	Concept:		Durational is an abstract class. An instance of a concrete subclass of Durational represents a duration of time. A duration of time differs from a "date" or "point-in-time" value in the same way that a "distance" value differs from a "position" value. A "position" value specifies an absolute location by specifying the distance between the location and some absolute reference point (.e.g, "93 million miles from the Sun.")  Similarly, a "point-in-time" value specifies an absolute point in time by specifying the duration since (or until) a particular point-in-time and some absolute reference time (e.g., "5765 years since the creation of the world.") A durational value specifies/designates a temporal extent ("how long,") without specifying when the temporal extent begins or ends.		Chronos implemements two different types of durational ("temporal extent") values: "scientific" durations and "calendar" durations. Scientific durations are implemented by the concrete subclass ScientificDuration. Calendar durations are implemented by the concrete subclasses CalendarDuration and CivilDuration. The semantics of a ScientificDuration and of a CalendarDuration/CivilDuration differ as follows: A ScientificDuration conceptually represents a scalar value--a number of seconds (optionally including fractions of a second.) A CalendarDuration or CivilDuration conceptually represents a vector, where the elements of the vector represent years, months, days, hours, minutes and seconds (optionally including fractions of a second.) The days specified by a CalendarDuration or CivilDuration represent a number of calendar days, based on the civil (business) definition of a day.  The days of a ScientificDuration always represent 86400 seconds uniformly and invariantly. The days of a CalendarDuration or CivilDuration may have more or less than 86400 seconds, due to timezone offset changes and/or leap seconds.		See ScientificDuration, CalendarDuration and CivilDuration for more information.	Usage:		Instances of Durational can be used as arithmetic operands with each other, and with instances of TemporalCoordinate (whose concrete subclasses include Timepoint, YearMonthDay and TimeOfDay--all of which see.) TemporalCoordinates can compute the temporal extent between any two instances, providing the result as a Durational instance. A Timeperiod specifies the temporal extent of the temporal inteveral it represents using a Durational instance. A ChronosTimezone uses a ScientificDuration to represent its offset from UTC.		Key methods of Durational, CalendarDuration, CivilDuration and ScientificDuration have "do its" in their comments that provide usage examples.		Many of the methods of Durational and ScientificDuration implement message signatures as specified and required by the ANSI-Smalltalk Standard.  As is true throughout the Chronos codebase, many of the others are implemented by analogy to those required by ANSI Smalltalk (i.e., in the same style and/or spirit--both in terms of naming conventions and semantics.)		As is the case with most Chronos classes, Durational instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		Note that the instance creation messages (class messages) #days: and #seconds: (and many of the variations thereof) will correctly handle either integer or non-integer numeric arguments.	Motivation:		Firstly, the ANSI-Smalltalk Standard requires that durational values be supported as a type distinct from that of point-in-time values.		Secondly, although in some contexts/situations it is both necessary and proper to represent a duration of time using a "raw" numeric value, it is usually superior to encapsulate a durational value in an object that knows the semantics and behavior of the represented temporal extent.  This avoids the possibility that raw numeric values will be misinterpreted as a number of seconds when they actually represent a number of days, hours or tenths of a microsecond.  Even better, it enables such values to collaborate with other objects with greater semantic precision, and in ways that can be made much more specific to the functional intent of the value.  It is much easier to define and understand the meaning of adding a durational value to a point-in-time value, than it would be to define or understand the meaning of adding a raw number (a number of what?).		Thirdly, although point-in-time values represent a count of some number of years, months, days, hours, minutes and seconds (possibly including fractions of a second,) they are unsuitable for use as durational values for the following reasons:			1. Although one can interpret point-in-time values as though they also represented a temporal extent defined by the duration of time form the epoch of their calendar up to the point-in-time they designate, doing so causes such values to have two distinct (and sometimes irreconcilable) meanings. For example, if points-in-time and durations are all considered one and the same semantically, then what is the meaning of subtracting one such value from another?  Should the result of subtracting &lt;a&gt; from &lt;b&gt; be the duration of time between the points-in-time &lt;a&gt; and &lt;b&gt;, or the point-in-time that results from subtracting the durational value of &lt;b&gt; from the point-in-time value of &lt;a&gt;?  The two cases are not at all equivalent, thanks to the non-uniform and context-dependent way that the rules of most calendrical systems count seconds into days, days into months, and days/months into years.			2. Does a point-in-time value represent the number of seconds since its epoch, or the number of years, months, days and seconds?  In other words, is it a "scientific" duration, or a "calendar" duration? If one adds the number of seconds since the calendar epoch represented by the point-in-time &lt;alpha&gt; to the point-in-time &lt;beta&gt;, it is unlikely that the number of years, months, days and seconds by which the result &lt;gamma&gt; will differ from &lt;beta&gt; will be the same as the number of years, months, days and seconds since the epoch represented by &lt;alpha&gt;. Conversely, if one adds the number of years, months, days and seconds represented by the point-in-time &lt;alpha&gt; to the point-in-time &lt;beta&gt;, it is unlikely that the number of seconds by which the result &lt;gamma&gt; will differ from &lt;beta&gt; will be the same as the number of seconds since the epoch represented by &lt;alpha&gt;. Such contradictions and semantic undecidability are inherent to interpreting point-in-time values as simultaneously moments in time and also durations of time (temporal extents.)			3. Points-in-time are bound to a particular calendar, and so cannot represent temporal extents independently of any particular calendrical system.			4. Because calendrical/civil time/business semantics are not appropriate for all durational values, there must be at least one type of duration that does not count minutes, hours or days separately/independently of seconds, nor count years/months at all. But point-in-time values must do every one of those things.		Durational defines and implements, to the extent possible, the behavior and state that is common to both ScientificDurations, CalendarDurations and CivilDurations.	Implementation:		Instance Variables			NONE	Subclassing:		Concrete subclasses must subimplement the following instance methods:			#addedToCalendricalCoordinate:			#addedToDuration:			#asCalendarSeconds			#calendarDays			#calendarDaysAreZero			#calendarPeriodsAreZero			#days			#isZero			#resolutionQuantum			#setDays:			#subsecondsAreZero			#subtractedFromCalendricalCoordinate:			#subtractedFromDuration:		Concrete subclasses must subimplment the following class methods:			#zero</body></comment><class><name>ComparableDuration</name><environment>Chronos</environment><super>Chronos.Durational</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Chronos-Duration</category><attributes><package>Chronos-Duration</package></attributes></class><comment><class-id>Chronos.ComparableDuration</class-id><body></body></comment><class><name>InfiniteDuration</name><environment>Chronos</environment><super>Chronos.ComparableDuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extent </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Duration</category><attributes><package>Chronos-Duration</package></attributes></class><comment><class-id>Chronos.InfiniteDuration</class-id><body></body></comment><class><name>BoundTimezone</name><environment>Chronos</environment><super>Chronos.ChronosTimezone</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.BoundTimezone</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})BoundTimezone	Concept:		BoundTimezone is an abstract class that provides inheritable behavior appropriate for implementing "bound, static" time zones. A "bound" Chronos time zone is one whose single, specific offset-abbreviation tuple is or can be "bound to" (properly associated with) a specific point-in-time.  An "unbound" Chronos time zone is one that does NOT specify a single, specific offset and abbreviation that can be "bound to" (properly associated with) a specific point-in-time. A "static" Chronos time zone is one whose offset-abbreviation tuple is not subject to retroactive changes--for a static time zone, the binding of a point-in-time value to the offset-abbreviation tuple of its time zone is permanent for all time. A "dynamic" Chronos time zone is one whose offset-abbreviation tuple (or tuples) is subject to retroactive changes--for a dynamic time zone, the binding of a point-in-time value to the offset-abbreviation tuple currently specified by its time zone is not necessarily permanent.		A "bound, static" timezone is a "bound timezone" whose offset and abbreviation are invariant in two different senses: All points-in-time within the domain of a "bound, static" time zone, from the infinite past to the infinite future, have the same offset and abbreviation; and the offset/abbreviation tuple specified by a "bound, static" timezone will always be immutably, invariantly the same--no "ex post facto" rule changes are allowed.		However, the API (as opposed to some of the method implementations) of BoundTimezone is also appropriate for a type of time zone which Chronos refers to as a "bound, dynamic" time zone, which is a time zone whose specific offset and abbreviation are correct for (or "bound to") a specific point-in-time according to the currently-specified ruleset of an "unbound, dynamic" (variable-offset) timezone.		The offset and abbreviation of a "bound, dynamic" timezone may vary dynamically in two different senses:			1. The "bound, dynamic" time zone that is correct for (or "bound to") a specific point-in-time value at a particular location may be different from the "bound, dynamic" time zone (the offset and abbreviation tuple) that is correct for ("bound to") an infinitesimally different point-in-time value at the exact same location. In other words, adding even a nanosecond (or any non-zero duration, regardless of size) to a point-in-time value may require that the point-in-time value that results from such an addition be "bound to" a different "bound, dynamic" timezone (offset/abbreviation tuple) than the one to which the original point-in-time value was bound--even at the exact same location.			2. The time zone ruleset that specifies the correct bound time zones (offset/abbreviation tuples) for all point-in-time values within some specified area or locale may change, requiring that an offset/abbreviation tuple different than the one previously required by the former rules be "bound to" some range (or set of ranges) of the point-in-time values at all locations within the time-zone's territory.  For example, the law that determines the date or dates of transition to and/or from Daylight Saving Time may change, so that future transitions to and/or from Daylight Saving Time happen on different dates than would have been the case previously (or, a new/changed law may eliminate Daylight Saving Time altogether, or initiate Daylight Saving Time in a time zone where it had not been previously observed at all, or even just change the standard-time offset of the time zone.) Usually, such changes would only affect point-in-time values in the future, but such changes can also happen to times in the past (e.g,, due to a correction of wrong time zone rules, or due to further elaboration of incomplete rules.)		Although BoundTimezone itself implements "bound, static" time zones, subclasses may instead implement "bound, dynamic" time zones, using the same API (or an extension thereof.)	Usage:		An BoundTimezone conforms to both the Chronos "BOUND TIMEZONE API" and "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.		See either the individual method comments, or ChronosTimezone, for any further information.	Subclassing:		Concrete subclasses must subimplement the instance method #offsetFromUT, and will probably need to also subimplement the method #commonAbbreviation (see the method comments for the required behaviors.)</body></comment><class><name>BasicTimezone</name><environment>Chronos</environment><super>Chronos.BoundTimezone</super><private>false</private><indexed-type>none</indexed-type><inst-vars>offsetFromUT name commonAbbreviation </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.BasicTimezone</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})BasicTimezone	Concept:		BasicTimezone concretely implements a Chronos "bound, static" time zone, as specified and explained by the comment of the superclass BoundTimezone. BasicTimezone provides an invariant offset from UT (no DST rules,) an invariant name (optional) and an invariant abbreviation (optional.)  		See also: ChronosTimezone, UniversalTime.	Usage:		A BasicTimezone conforms to both the Chronos "BOUND TIMEZONE API" and "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.		A BasicTimezone (unnamed and with no abbreviation) is what will be created and set as a Timepoint's timezone whenever the ANSI-Smalltalk 'offset:' protocol is used to specify the timezone of a Timepoint.  There is no other choice, since it is generally impossible to uniquely and deterministically map an offset to an Olson timezone without any other contextual information.  It is more common than not for different Olson timezones (which differ because they have different DST rules and/or different abbreviations) to have the same offset as other Olson timezones (there are less than 50 distinct time zone offsets around the world (some have fractional-hour offsets,) but as of 2005 there are 409 different Olson timezone rulesets--so do the math.)		Motivation:		BasicTimezone serves two purposes: 1) It's very fast and memory efficient; and 2) it's necessary in order to reconcile the API required by real-world Timezones (such as those specified in the Olson Timezone Database) with the rather quaint notion of 'timezone offset' specified by the ANSI-Smalltalk standard for DateAndTime.		Since ANSI-Smalltalk timezone offsets are instances of Duration (Note: ScientificDuration is the actual name of the Chronos class that implements the ANSI-Smalltalk Duration protocol,) a BasicTimezone represents a timezone offset by encapsulating a Duration instance. There are no limitations on the Duration that defines the offset of a BasicTimezone--all values will work fully and correctly--from 1 nanosecond to gigayears.  		Implementation:		Instance Variables			offsetFromUT 			&lt;ScientificDuration&gt; 	The instance's offset from UT.			commonAbbreviation	&lt;Symbol | nil&gt; 			The instance`s time zone abbreviation.</body></comment><class><name>MonthlyCalendar</name><environment>Chronos</environment><super>Chronos.CalendarYearPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key nameKey isIntercalary leapDayOrdinals daysUpToMonthSinceStartOfYear </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.MonthlyCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})MonthlyCalendar	Concept:		MonthlyCalendar is an abstract class; an instance of one of its concrete subclasses represents/specifies the properties of a particular month as it occurs within a particular type of year (e.g., a standard year, a leap year) of a particular calendrical system (e.g., the Gregorian, Hebrew, or Persian calendar.)  It does NOT represent/specify an actual occurrence of a month in any specific year. In other words, a MonthlyCalendar would specify/represent (for example) the properties of the month of February as it occurs in any leap year of the Gregorian Calendar, but would not specify/represent any specific occurrence of February in a specific Gregorian year.		Specifically, a MonthlyCalendar specifies the YearlyCalendar that encapsulates it (and hence also the Calendar that implements the calendrical system for which it represents the properties/characteristics of a particular month in a particular type of year); the month ordinal of the month it represents; the "month key" that semantically identifies the month (because "the same" month may have a different ordinal in different year types); the "name key" that semantically identifies the name of the month (because the "same month" may have a different name in different year types, and also because the "same month" probably has a different name in different languages and/or cultures); whether or not the month is an intercalary or leap month; what the month's leap days are (if any); the number of days from the beginning of the year up to the first day of the month; and the properties of each day of the month (by means of an encapsulated instance of CalendarDay--one for each day of the month.)		The two concrete subclasses of MonthlyCalendar are StaticMonthlyCalendar and DynamicMonthlyCalendar. A StaticMonthlyCalendar is preinitialized to encapsulate a flyweight instance of StaticCalendarDay for each day in the month it represents.  In contrast, a DynamicMonthlyCalendar generates a new instance of DynamicCalendarDay every time one is needed. StaticMonthlyCalendar must be used in collaboration with StaticYearlyCalendar and StaticCalendarDay. DynamicMonthlyCalendar must be used in collaboration with DynamicYearlyCalendar and DynamicCalendarDay.	Usage:		As is the case with most Chronos classes, MonthlyCalendar instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Implementation:		Instance Variables			key 								&lt;Symbol&gt;				The key that semantically identifies the month represented by the instance.			nameKey 							&lt;Symbol | nil&gt;				The key that semantically identifies the name of the month represented by the instance (because what is semantically the "same month" may go by different names in different years--for example, "Adar" and "Adar Sheni" in the Hebrew Calendar.)  If the &lt;nameKey&gt; is nil, then the instance's "name key" is identical to its &lt;key&gt;.			isIntercalary 						&lt;Boolean&gt;				Flag that signals whether or not the month represented by the instance is an intercalary month. An intercalary month is one that either a) does not occur every year (it's a "leap month,") and/or b) does not have nearly the same number of days as the majority of months in the year.			leapDayOrdinals 					&lt;Collection of Integer&gt;				Collection of the day-of-month ordinals of the days of the month represented by the instance that are leaps days (days that are inserted into the month in some years but not in others--note that a leap day does NOT have to be the last day of a month.)			daysUpToMonthSinceStartOfYear	&lt;Integer&gt;				The number of days from the first day of the instance's year up to (but not including) the first day of the month represented by the instance.	Subclassing:		Concrete subclasses must subimplement the following instance methods (see the comment of each method for the required semantics):			#basicDayAt:			#calendarDayClass			#dayAt:			#daysPerMonth			#setDaysPerMonth:</body></comment><class><name>DynamicMonthlyCalendar</name><environment>Chronos</environment><super>Chronos.MonthlyCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>daysPerMonth </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Irregular</category><attributes><package>Chronos-Calendars-Irregular</package></attributes></class><comment><class-id>Chronos.DynamicMonthlyCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})DynamicMonthlyCalendar	Concept:		A DynamicMonthlyCalendar is a MonthlyCalendar (which see) that generates a new instance of DynamicCalendarDay every time one is needed.  DynamicMonthlyCalendar must be used in collaboration with DynamicYearlyCalendar and DynamicCalendarDay.	Usage:		As is the case with most Chronos classes, DynamicMonthlyCalendar instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Motivation:		DynamicMonthlyCalendar, in collaboration with DynamicCalendarDay and DynamicYearlyCalendar, avoids the utilization of too much memory in the case of calendrical systems that have too many different year types to reasonably use the flyweight pattern for representing the month structure of each type of year.	Implementation:		Instance Variables			daysPerMonth	&lt;Integer&gt; The number of days in the month represented by the instance.</body></comment><class><name>UtilityFunction</name><environment>Passport</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			private Smalltalk.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.UtilityFunction</class-id><body></body></comment><class><name>ChronosFunction</name><environment>Chronos</environment><super>Passport.UtilityFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.ChronosFunction</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosFunction	Concept: 		ChronosFunction provides selected utliity functions, implemented as class methods	Usage: 		See individual class methods.	Motivation: 		The methods provided by ChronosFunction would best be implemented as methods in certain ANSI-standard classes. However, the Chronos implementation policy is to never modify classes of the base Smalltalk library. Adding methods is considered a modification.  		One reason for the no-modification-of-base-library-class policy (which may very well not be applicable to other packages, applications or projects) is that Chronos is a widely-distributed utility package, and so may be used by many different applications (and by many other utility packages.)   The danger that methods added to base-library classes by Chronos might conflict in some way with methods added in the same inheritance hierarchy by other packages (of which Chronos could have no advance knowledge) is far from trivial or insignificant.		Another reason for the no-modification-of-base-library-class policy (which may also very well not be applicable to other packages, applications or projects) is that Chronos is intended to be portable among all Smalltalk implementations (or as many as is practical.) Any modifications to classes in the base library of one Smalltalk implementation would complicate porting to other Smalltalk implementations (and could also cause problems when porting to different versions of the same Smalltalk implementation.)		The functionality of some (or all) of the methods provided by ChronosFunction might possibly be provided (now or later) by methods in the standard class library of one or more Smalltalk implementations.  However, no such methods were provided in the standard class library of the Smalltalk implementation in which the original version of Chronos was written.  Worse, there is no standard that governs the name of any such methods, the arguments they expect, nor the class that must implement them.  Consequently, Chronos could not (and cannot) make use of any such methods.	Implementation: Not Applicable	Subclassing: Not Applicable</body></comment><class><name>TimeOfDay</name><environment>Chronos</environment><super>Chronos.TemporalCoordinate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hour minute second nanosecondsSinceSecond </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.TimeOfDay</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>ResourceBroker</name><environment>Passport</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context baseDirectoryKey factory decodeSelector encodeSelector streamType elementExtension </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ResourceBroker</class-id><body></body></comment><class><name>Timescale</name><environment>Chronos</environment><super>Passport.Registratable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>secondsSinceJulianDayEpochUpToEpoch secondsSinceUnificationEpochUpToEpoch </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timescales</category><attributes><package>Chronos-Timescales</package></attributes></class><comment><class-id>Chronos.Timescale</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>TerrestrialTimescale</name><environment>Chronos</environment><super>Chronos.Timescale</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timescales</category><attributes><package>Chronos-Timescales</package></attributes></class><comment><class-id>Chronos.TerrestrialTimescale</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})</body></comment><class><name>UT1Timescale</name><environment>Chronos</environment><super>Chronos.TerrestrialTimescale</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timescales</category><attributes><package>Chronos-Timescales</package></attributes></class><comment><class-id>Chronos.UT1Timescale</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})</body></comment><class><name>TimeZoneAnnualTransitionPolicyFactory</name><environment>Chronos</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key effectiveYear effectiveYearCalendarKey effectiveYearRelativity isSymmetric annuallyRecurringTransitions </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-PolicyFactories-Diachronic</category><attributes><package>Chronos-TimeZones-PolicyFactories-Diachronic</package></attributes></class><comment><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})TimeZoneAnnualTransitionPolicyFactory	Concept:		A TimeZoneAnnualTransitionPolicyFactory defines, for each moment in time during a calendar year, the offset/abbreviation tuple that is in effect within the territorial domain of a time zone. A TimeZoneAnnualTransitionPolicyFactory's rules may also specify annually-recurring dates and times within a year when there is a transition to a different offset/abbreviation tuple. A TimeZoneAnnualTransitionPolicyFactory's rules do not specify any particular year when such transitions occur--they occur every year, from the effective year of the ruleset until the ruleset expires and is superceded by a later rule.  		However, the purpose of a TimeZoneAnnualTransitionPolicyFactory is not to actually itself provide time-zone behavior, but rather to a) serve as a factory object for correctly instantiating a TimeZonePolicy using the minimum possible amount of memory, and b) to provide an API for the construction and editing of a time zone's ruleset that is considerably easier to understand and use than is the case for a TimeZonePolicy. 		So, allthough a TimeZoneAnnualTransitionPolicyFactory represents essentially the same information as a TimeZonePolicy (with a few differences, as will be explained in the "Motivation:" section below,) its purpose and behavior are different: A TimeZonePolicy is used to represent the full diachronic ruleset of a Chronos time zone (from the infinte past to the infinite future,) whereas a TimeZoneAnnualTransitionPolicyFactory is used as a factory for creating instances of TimeZonePolicy. 		A TimeZoneAnnualTransitionPolicyFactory encapsulates a list of AnnuallyRecurringTZPolicyFactory instances, each of which represents the time zone rules in effect for some number of years (these change from time to time--see TimeZonePolicy, TimeZonePolicySequenceFactory and VariableOffsetTimezone for more information.)	Motivation:		The key differences between the representational architectures of TimeZonePolicySequenceFactory/TimeZoneAnnualTransitionPolicyFactory/AnnuallyRecurringTZPolicyFactory and TimeZonePolicy/AnnuallyRecurringTZPolicy that motivate the existence of factory objects for the creation of TimeZonePolicies and AnnuallyRecurringTZPolicies are the following:			1. TimeZonePolicies and AnnuallyRecurringTZPolicies are elements in a linked list; TimeZonePolicySequenceFactories, TimeZonePolicyElementFactories and AnnuallyRecurringTZPolicyFactories are not. Consequently, TimeZonePolicy and AnnuallyRecurringTZPolicy instances not only represent themselves as list elements, they also represent their list (for which the serve as the head element) as a whole.  TimeZonePolicySequenceFactories, TimeZonePolicyElementFactories and AnnuallyRecurringTZPolicyFactories do not have such dual semantics, and so are less confusing, and also easier to incrementally modify. 			2. The effective year of an inter-year ruleset (one that is in effect for some number of years) is stored in TimeZonePolicyElementFactories, but not in the otherwise-analogous AnnuallyRecurringTZPolicies they create.  Conversely, the effective year is stored in TimeZonePolicy instances, but not in the otherwise-analogous TimeZonePolicySequenceFactories that serve as factories for their creation.  So when translating between the  policy factory objects and the non-factory policy objects, the responsibility for specifying the effective year of the ruleset is not handled by the analogous objects. The reason for this difference is soley a necessary side effect of the other differences between the two class hierarchies.			3. AnnuallyRecurringTZPolicies contain "bound, dynamic" time zone instances (e.g., instances of StandardTime and/or NonStandardTime)--which in turn contain a reference to the "unbound, dynamic" timezone that defines both their identity and their full diachronic ruleset (e.g., an instance of VariableOffsetTimezone).  Instances of AnnuallyRecurringTZPolicy (and hence also instances of TimeZonePolicy) cannot be in canonical form--nor be fully functional--unless they have a reference to their "root" timezone. Consequently, TimeZonePolicies and AnnuallyRecurringTZPolicies form cyclic graphs, and require the existence of the entire object graph of an "unbound, dynamic" timezone in order be in canonical form and fully functional. 			In contrast, AnnuallyRecurringTZPolicyFactories specify their offsets and abbreviations using internal instance variables that contain just an integer and a Symbol, and so do not form a cyclic graph, do not require any reference to a "root" object, and so do not require the existence of the entire object graph that defines the full diachronic ruleset of a timezone.			4. The use of factory/memento objects makes it easier to minimize the unnecessary creation of objects with duplicate values during the construction of TimeZonePolicies (specifically: StandardTime and NonStandardTime instances, Duration instances and AnnualDate instances.)	Implementation:		Instance Variables			effectiveYear						&lt;Integer&gt;		The year the instance's ruleset takes effect.			isSymmetric							&lt;Boolean&gt;	Flag that indicates whether or not the instance should instantiate a TimeZonePolicy or an AsymmetricTimeZonePolicy (see the class comment of AsymmetricTimeZonePolicy for more information.)			annuallyRecurringTransitions 	&lt;Array of AnnuallyRecurringTZPolicyFactory&gt;				Each AnnuallyRecurringTZPolicyFactory in the &lt;annuallyRecurringTransitions&gt; array specifies the abbreviation and offset from UT that apply during some part of the year within the territorial domain of the time zone whose intra-year ruleset is specified by the instance. See AnnuallyRecurringTZPolicyFactory for more information.</body></comment><class><name>StaticMonthlyCalendar</name><environment>Chronos</environment><super>Chronos.MonthlyCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prevInYear nextInYear days </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.StaticMonthlyCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})StaticMonthlyCalendar	Concept:		A StaticMonthlyCalendar is a MonthlyCalendar (which see) that is preinitialized to encapsulate a flyweight instance of StaticCalendarDay for each day in the month it represents.  StaticMonthlyCalendar must be used in collaboration with StaticYearlyCalendar and StaticCalendarDay.	Usage:		As is the case with most Chronos classes, StaticMonthlyCalendar instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Implementation:		Instance Variables			prevInYear 	&lt;StaticMonthlyCalendar | nil&gt;				The StaticMonthlyCalendar that represents the month of the instance's year type that immediately precedes the month represented by the instance (if any).			nextInYear 	&lt;StaticMonthlyCalendar | nil&gt;				The StaticMonthlyCalendar that represents the month of the instance's year type that immediately follows the month represented by the instance (if any).			days 		&lt;Array of StaticCalendarDay&gt;				The StaticCalendarDay at the &lt;D&gt;th index in the array specifies the properties of the &lt;D&gt;th day of the month represented by the instance.</body></comment><class><name>ComputedAnnualDate</name><environment>Chronos</environment><super>Chronos.AnnualDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>daysOffset </inst-vars><class-inst-vars>canonical </class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.ComputedAnnualDate</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>TimeZonePolicyFactory</name><environment>Chronos</environment><super>Passport.ExternalResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultName geographicCoordinates annualTransitionPolicies </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-PolicyFactories-Diachronic</category><attributes><package>Chronos-TimeZones-PolicyFactories-Diachronic</package></attributes></class><comment><class-id>Chronos.TimeZonePolicyFactory</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})TimeZonePolicyFactory	Concept:		A TimeZonePolicyFactory serves as a factory for creating a TimeZonePolicy instance.  Although it represents the same information as a TimeZonePolicy--the full diachronic ruleset of a time zone--its purpose and behavior are different. A TimeZonePolicy's behavior is targeted at resolving the offset/abbreviation tuple (in the form of a "bound, dynamic" time zone instance) that applies within the territorial domain of a time zone at a particular point-in-time.  A TimeZonePolicyFactory's behavior is targeted at correctly instantiating a TimeZonePolicy using the minimum possible amount of memory, and also at providing an API for the construction and editing of a time zone's full diachronic ruleset that is considerably easier to understand and use than is the case for a TimeZonePolicy.		When Chronos time zones are retrieved from the Chronos time zone repository, they are deserialized as TimeZonePolicySequenceFactories, which are then used to construct the equivalent TimeZonePolicy.  Unlike TimeZonePolicies, TimeZonePolicySequenceFactories were designed to make serialization/deserialization easy and efficient.	Implementation:		Instance Variables			annualTransitionPolicies	&lt;Array of TimeZoneAnnualTransitionPolicyFactory&gt;  				Each TimeZoneAnnualTransitionPolicyFactory in the &lt;annualTransitionPolicies&gt; array represents the ruleset of a time zone that is in effect for some number of years (each one specifies its effective year.)  The ordering does not matter, since canonicalization of the order happens as a free side effect of constructing a TimeZonePolicy rule chain--although it is of course easier to understand if the array is kept in sorted order (which the Chronos Time Zone Compiler does for precisely this reason.)</body></comment><class><name>UntilAnnualDayOfYearTimeZoneTransition</name><environment>Chronos</environment><super>Chronos.IntraYearTimeZoneTransition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitionDayOfYear </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-Policies-Annual</category><attributes><package>Chronos-TimeZones-Policies-Annual</package></attributes></class><comment><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UntilAnnualDayOfYearTZPolicy	Concept:		An UntilAnnualDayOfYearTZPolicy is an IntraYearTimeZoneTransition that specifies its annually-recurring intra-year date of expiry and transition to a successor AnnuallyRecurringTZPolicy using a day-of-year ordinal (first day of the year = 1.)		See the superclass IntraYearTimeZoneTransition for more information.	Motivation:		UntilAnnualDayOfYearTZPolicy is intended to be used for offset/abbreviation transitions that happen only once, and aren't actually annually recurring events (although it is perfectly possible and valid to use one to specify an annually-recurring transition that happens on the same day of the year every year.) However, the Chronos Time Zone Compiler uses UntilAnnualDayOfYearTZPolicyFactories (which construct instances of UntilAnnualDayOfYearTZPolicy) solely for "one time" transitions.  		Another possible reason to use UntilAnnualDayOfYearTZPolicies/UntilAnnualDayOfYearTZPolicyFactories would be in order to represent the contents of the binary time zone files used by UNIX (which are generted by the `zic` utility on UNIX that compiles Olson time zone rule specifications from their "source code" form into binary files used by the Standard C library on UNIX.)  The `zic` utility ('zic' = "zone information compiler") compiles time zone rules into a sequence of one-time offset/abbreviation transitions, where each transition is specified to occur at a particular time_t value (i.e., a specified number of seconds since 1970-01-01T00:00:00 UT; note that time_t values technically do not qualify as "UTC," because POSIX forbids UNIX from using leap seconds.) [Reference: http://www.gsp.com/cgi-bin/man.cgi?section=5&amp;topic=tzfile]	Implementation:		Instance Variables  {Also see superclass}			transitionDayOfYear	&lt;Integer&gt; The annually-recurring intra-year date, expressed as a day-of-year ordinal (first day = 1) when the ruleform represented by the instance expires and the transition to its successor (the inherited &lt;nextLink&gt;) takes place. Specification/representation of the time-of-day of expiry/transition is implemented by the superclass.</body></comment><class><name>ChronosSystemFacade</name><environment>Chronos</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showReports resourceRepositoryContext systemTimeZone systemTimeZoneBindingStrategy systemLanguageCode systemCountryCode </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System</package></attributes></class><comment><class-id>Chronos.ChronosSystemFacade</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosSystemFacade	Concept:		The Chronos date/time library uses an instance of a concrete subclass of the abstract class ChronosSystemFacade as a facade for invoking functions whose implementation is beyond the scope of the Chronos date/time library itself, and where the API (or perhaps the language syntax) for performing such functions is generally different accross implementations of Smalltalk. A ChronosSystemFacade is also used to provide a facade for invoking functions that may need to be implemented differently when Chronos is used by (or in) a particular user base, organization, use case, application, locale, legal jurisdiction or operating system.	Usage:		Singleton (&lt;ChronosSystemFacade current&gt;)			There is no need for more than one instance of the ChronosSystemFacade (in fact, multiple instances might be problematical.)  Consequently, ChronosSystemFacade implements the singleton design pattern.  The current active instance (the singleton) is accessed by evaluating 'ChronosSystemFacade current.'		Instantiation  			A new instance of a ChronosSystemFacade is created by sending the message #new to its class. However, since ChronosSystemFacade is an abstract class, and since each subclass is specific to a particular environment (Smaltalk implementation and/or client/application use case,) the  substantive issue that must be resolved is which class in the hierarchy of ChronosSystemFacade should be instantiated.  The same issue must be resolved in the case of ChronosSystemEnvironment and ChronosSystemClock.  			The solution strategy is as follows: a) ChronosEnvironment and one concrete subclass thereof, specific to a particular platform, are packaged into a separate module ("package")--a different module for each platform, so that only the concrete subclass(es) of ChronosEnvironment needed by a particular platform will be installed when loading Chronos into an image; b)  ChronosSystemEnvrionment and ChronosSystemClock, and one platform-specific subclass of each, along with several other "system" classes,  are packaged into a separate module ("package")--a different module for each platform, so that only the concrete subclassses of ChronosSystemFacade and ChronosSystemClock needed by a particular platform will be installed when loading Chronos into an image; c)  The platform-specific subclass(es) of ChronosEnviromnent must subimplement the class method #systemFacadeClass, so that the method answers the concrete subclass of ChronosSystemFacade that should be instantiated as the ChronosSystemFacade singleton; and d) the concrete subclass of ChronosSystemFacade for a particular platform must subimplement the method #newSystemClock so that it answers a new instance of the concrete subclass of ChronosSystemClock that should be instantiated for use on the same platform for which that ChronosSystemFacade subclass is intended.  Consequently, the portable way to instantiate an instance of ChronosSystemFacade that is correct for the current platform is to ask the ChronosEnvironment class for the correct subclass of ChronosSystemFacade (by evaluating  'ChronosEnvironment systemFacadeClass',) and then sending #new to the result.		Initialization			When Chronos is first installed in an image, or when the Chronos codebase is loaded by a non-image-based Smalltalk runtime, or when a Chronos-enabled image is restared after a snapshot, the ChronosSystemFacade is responsible for (among other things) a) determining the local timezone used by the host system, b) determining the ISO 939 country-code and ISO 3166 language-code of the host system's locale, and c) determining the physical resource pathnames that should be used for each logical resource pathname required by Chronos (e.g., the path to the base directory where the timezone ruleset files reside.)   In order to fulfill those responsibilities, the ChronosSystemFacade must be informed whenever Chronos is initially installed and/or whenever a Chronos-enabled image is restarted after a snapshot.			When Chronos is first installed, a singleton instance of the correct subclass of ChronosSystemFacade must be instantiated, and then this instance must be sent the message #installInitially. Doing so is the responsibility of ChronosEnvironment (see the method ChronosEnvironment&gt;&gt;installSystemFacade.)			When an image is restarted after a snapshot, the message #install must be sent to the ChronosSystemFacade singleton.  Arranging for that to happen is the responsibility of the method ChronosSystemFacade&gt;&gt;registerForStartupNotification--which should be invoked by the implementation of ChronosSystemFacade&gt;&gt;installInitially (unless the host Smtalltalk implementation is not image-based.)			However, if either a) the global #ChronosInstallationFlag is defined with the value false, or b) the environment variable CHRONOS_INSTALLATION is defined with the value 'NO', then the ChronosSystemFacade singleton will short-circuit almost all of its normal installation actions and procedures.  Avoiding the installation process may be necessary when a) doing development work on the Chronos codebase, or b) porting Chronos to a different Smalltalk system, or to a different version of the same Smalltalk environment. See the instance method #shouldSkipInstallation for more details.		ChronosSystemClock Instantiation			Since the code required to implement and encapsulate a clock device is necessarily quite system dependent (with respect to Smalltalk implementations, operating systems and perhaps even the available/desired clock hardware,) there must be a different ChronosSystemClock class for each implementation platform.  Instantiation of the appropriate ChronosSystemClock subclass is the responsibility of the ChronosSystemFacade singleton, which, in response to the message #newSystemClock, must instantiate and answer an instance of the subclass of ChronosSystemClock that is correct/appropriate for the current platform.		Current Time--Network Time Service			For situations where there is no local clock, or where it is desired to obtain the current time using the network time service as defined by RFC-868, the ChronosSystemFacade singleton responds to the message #rfc868SecondsSince1900 by answering the number of seconds since 1900-01-01T00:00:00 UT [Gregorian] (obtaining the answer from a network time server, in accordance with the protocol defined by RFC-868.) The implementation of this method is obviously highly non-portable among the various Smalltalk platforms (partly because the ANSI Smalltalk standard does not address networking.) It should be noted that the Chronos codebase only invokes the #rfc868SecondsSince1900 method in cases where the system clock singleton is actually an instance of ChronosSystemClock itself, instead of an instance of a subclass of ChronosSystemClock encapsulating access to some clock service other than that defined by RFC-868  (if the method ChronosSystemFacade&gt;&gt;newSystemClock has not been subimplemented to answer an instance of a subclass of ChronosSystemClock, then the default implementation in ChronosSystemFacade itself answers an instance ChronosSystemClock, and not an instance of a subclass.) Consequently, in the normal case, the Chronos codebase would not actually ever send the message #rfc868SecondsSince1900 to the ChronosSystemFacade singleton.		WeakDictionary Instantiation			Since there is no standard for WeakDictionaries, Chronos delegates instantiation of Dictionaries that weakly reference their elements (values) to the ChronosSystemFacade.  The ChronosSystemFacade singleton is responsible for providing a new, empty "Weak Dictionary" in response to the message #newWeakDictionary.  If porting Chronos to a Smalltalk implementation that does not support weak references, then a simple Dictionary (or its equivalent) may be used instead (most appropriately as an initial "first cut" at a port.)  However, answering a non-weak, conventional Dictionary in response to #newWeakDictionary will result in substantially suboptimal memory usage--especially in an image-based Smalltalk implementation.  The scope of the problem can be investigated by looking at all senders of #newWeakDictionary. Recommendation in such a case: Either implement weak references and WeakDictionaries, or implement/use an LRU cache instead.		Delay Instantiation			To instantiate a Delay whose delay interval is the time inverval represented by a Duration, send the message #newDelayFromDuration: to the ChronosSystemFacade singleton with a Duration as the arguement. Note: ScientificDuration (which implements the ANSI-Smalltalk protocol &lt;Duration&gt;) provides the method #asDelay, which is implemented as '^ChronosSystemFacade current newDelayFromDuration: self'.		User Interaction			When the ChronosSystemFacade is not able to resolve the host system's local timezone, it attempts to notify the user of the failure.  To do so, it sends the message #userNotify: to itself with an explanatory message as the argument.  The code required to actually present such a notification to a user is highly non-portable (and even if such code could be portable, it is highly likely that the 'look and feel' of the notification widetry would fail to thematically conform to the standard conventions of an application that uses Chronos, given such issues as colors, fonts, layout, terminology, language, visual metaphors, etc.)  And some applications are necessarily headless, and cannot have a conversational/interactive UI. Therefore, the implementation of #userNotify: is the responsibility of whoever ports Chronos to a platform (and/or of an application using Chronos that has its own specific requirements for such notifications.)		Exceptions			The Chronos codebase assumes that the ANSI-standard ExceptionFactory globals are available.  If that is not the case, they must be defined (perhaps as facades over functionality native to the platform.)			Some applications may need Chronos to raise exceptions differently than the default implementation. Consequently, the ChronosSystemFacade implements the instance method #signal:message:, and Chronos always raises Exceptions by sending the message #signal:message: the current ChronosSystemFacade singleton. The first argument is an object that plays the role of an ANSI-Smalltalk &lt;ExceptionFactory&gt;.  The second argument is a String containing the message to be associated with the raised exception.  Applications can easily subimplement #signal:message: to suit their needs.		Localization: System-Timezone; System-Locale Keys			System Timezone: 				Send #systemTimeZone to the ChronosSystemFacade singleton to get the ChronosTimezone that implements  time zone rules that match those of the host system's local time zone as closely as possible. See the comment (below) for the instance variable &lt;systemTimeZone&gt; for more information.				Send #systemTimeZone: to the singleton to set the Chronos "system timezone" to be a ChronosTimezone instance (depending on the particular implementation of the ChronosSystemFacade that receives this message, this may or may not have any effect on the host system's local timezone, although ideally, it should (and may in fact have that result.)) Currently, the VisualWorks implementation changes the reference Core.TimeZone to one that matches the Chronos time zone as closely as possible, but does not attempt to change the operating system's time zone.)			System Locale Language Code: 				Send #systemLanguageCode to the singleton to get the ISO 639 code for the language of the system's locale.			System Locale Country Code: 				Send #systemCountryCode to the singleton to get the ISO 3166 code for the country of the system's locale.			System Locale Key: 				Send #systemLocaleKey to the singleton to get the key of the ChronosLocale that represents the system's locale.		ChronosLocale Instantiation			For localization/internationalization, Chronos uses instances of ChronosLocale (because the ANSI Smalltalk standard defines no standard API--a major gap.)  However, Chronos is a date/time library, and is not intended as a library for localization/internationalization.  Consequently, constructing instances of ChronosLocale properly initialized/configured for a particular locale is the responsibility of the ChronosSystemFacade singleton. In response to the message #findOrCreateChronosLocaleAt:, the ChronosSystemFacade singleton ideally should construct and answer an instance of ChronosLocale that will provide behavior that is appropriate for the locale identified by the locale-key provided as the argument.  See ChronosLocale, and the method comment of #findOrCreateChronosLocaleAt:, for more information.			Chronos provides a "hard-coded" ChronosLocale for the United States (#en_US), which can be retrieved by evaluating 'ChronosLocale unitedStates.'. The default implementation of #findOrCreateChronosLocaleAt: provided by ChronosSystemFacade itself alwyays answers &lt;ChronosLocale unitedStates&gt;. The VisualWorks-specific ChronosSystemFacade (VWSystemFacade) creates, configures and then answers an instance of ConfigurableChronosLocale based on the information obtained from a VisualWorks Locale object.  			Those porting Chronos to other Smalltalk platforms should attempt to leverage whatever Locale functionality may be provided by the host Smalltalk implementation.  If the ChronosLocale implementation provided by whomever ported Chronos to the flavor of Smalltalk being used is not adequate, then it may be necessary to implement a repository of ChronosLocale reference data and subimplement ChronosSystemFacade&gt;&gt;#findOrCreateChronosLocaleAt: so that it gets Locale information from the repository.  Locale information may also be available from the host operating system.		Storing/Retrieving Chronos Reference Data					ChronosSystemFacade delegates the responsibility for accessing reference data (i.e., "resources") to one or more concrete subclasses of ResourcePathFacade (which see.)  ResourcePathFacade instances are only directly used by instances of ResourcePath (also which see.)			 The ChronosSystemFacade singleton is only responsible for knowing the name of the concrete subclass of ResourcePathFacade that is appropriate for use on the host platform by the client application, and for instantiating instances thereof as required. The ChronosSystemFacade singleton maintains a default instance of a ResourcePathFacade in an instance variable, and returns it in response to the message #resourcePathFacade.  However, there is no reason that instances of more than one concrete subclass of ResourcePathFacade could not simultaneously be in use in the same execution environment (image)--perhaps because some resources reside in local disk files while others reside in a remote reference data server and are accessed by means of (say) HTTP transport.		Logical to Physical File Mapping			The Chronos library does not use or depend on absolute pathnames to external resources, for three reasons: 1) Absolute pathnames are highly non-portable among different filesystems (and/or external namespace systems,)  2) Even if absolute pathnames could be specified in a portable way, the existence of the specified paths could not and should not be standardized accross platforms (e.g, there is no reason for Windows to have a c:\usr\local directory, nor for Unix to have a /Windows/system32 directory,) nor should all machines (even those running the same OS) be required to have the same directory structure, and 3) There is no way to guarantee the uniqueness of absolute pathnames (naming collisions cannot be prevented.)  These are the same issues that have motivated the existence and wide-spread usage of relative pathames in many other contexts.			In most filesystems, a relative pathname is interpreted as a suffix of the absolute pathname of the "current directory."  A more general system would enable pathnames to be interpreted as suffixes relative to any set of absolute reference pathnames, where each absolute reference pathname is identified by some well-known key or identifier.  The ChronosSystemFacade is responsible for providing precisely such a set of well-known absolute reference pathnames, which may be used as prefixes to relative pathnames. This service enables the Chronos library to operate portably and transparently on any platform, without knowing or caring about the absolute pathnames needed to access Chronos reference data.  It also makes it possible for applications using Chronos to store the Chronos reference data at whatever location may be most appropriate for their individual situations (e.g., single user/single image, single user/multiple images/same machine, multiple users/multiple images/multiple machines.)				The Chronos codebase will send the message #resourcePathTo:ifNone: to the ChronosSystemFacade singleton in order to get the absolute pathname currently bound to a particular well-known "semantic key." The "semantic key" idientifies an absolute pathname according to its intended role, function, purpose or usage.			The well-known pathnames and associated semantic keys used by the Chronos codebase:						Semantic Key							Role/function/purpose/usage of associated absolute pathname				#TZRepository							The directory that contains the Chronos TimeZone specification files, and the zone alias file 															(these files are generated by the Chronos TimeZone Compiler.)				#TZLocalizationPolicyRepository		The directory that contains the Chronos TimeZoneLocalizationPolicy definition files															(the default versions of these files are generated by the Chronos TimeZone Compiler.)				#TZForeignKeyMappings				The directory that contains files that associate foreign timezone keys with those used by Chronos.				#OlsonZoneInfoSourcesDirectory	The directory/folder containing the source files (text files using Unix line-end convertions) 															that comprise the Olson Timezone Database (used only by the Chronos TimeZone Compiler.) 															On UNIX systems, it may be desirable to make this directory be a symbolic link to the directory 															where that system keeps its own zoneinfo source files, so as to ensure that the system's binary 															timezone files and Chronos's time zone ruleset files are both derived from the same version of 															the Olson TZ Database.				#LeapSecondScheduleRepository	The directory/folder containing the schedule of leap seonds associated with particular 															timescales, such as UTC.		Accessing Chronos Resources in a Chronos Resource Repository			Persistent/remote Chronos Respositories are accessed and updated using instances of ChronosResourceRepository (which is a concrete class.) A ChronosResourceRepository is a Dictionary-like object that uses a) one instance of (a concrete subclass of) ResourceReference per element, and b) one instance of (a concrete subclass of) ResourceBroker per instance of ChronosResourceRepository to store resources into and retrieve them from a persistent/remote resource repository. A ResourceReference is an Association-like object that knows how to collaborate with the ResourceBroker that instantiated it.  A ResourceBroker is both a factory for ResourceReference instances and an implementer of read/write operations to a particular physical repository using a particular transport or access protocol (the default implementation uses ResourcePaths, but other implementations are quite possible.) The combination of the multiple levels of abstraction provided by a) a ChronosResourceRepository, b) a ResourceReference, c) a ResourceBroker, d) ResourcePaths, e) one or more ResourcePathFacades and finally a ChronosSystemFacade should be able to handle just about any host platform, any Smalltalk environment and any Use Case. Resources absolutely do not have to reside in local disk files!					It is the responsibility of the ChronosSystemFacade singleton to instantiate instances of (concrete subclasses of) ResourceBroker that bind a ChronosResourceRepository to a remote/persistent repository at a particular physical location (which might be a local file directory, a remote JNDI Context, a remote LDAP directory, or a remote Smalltalk image, Web Server or Application Server acting as a reference data server.)  			Currently, the ChronosSystemFacade singleton must instantiate and provide one instance of ResourceBroker that knows how to access the repository of time zone rule sets and another instance that knows how to access the repository of time zone localization policies.  The ChronosSystemFacade singleton must answer the ResourceBroker for time zone rule sets in response to the message #timeZoneResourceBroker, and must answer the ResourceBroker for time zone localization policies in response to the message #tzLocalizationPolicyResourceBroker.		Other Chronos Reference Data			In addition to TimeZonePolicyFactories and TimeZoneLocalizationPolicies, Chronos also needs to store/retrieve the following auxilliary reference data:					TimeZone Key List						Due to the fact that on image startup it is not a valid assumption that the set of time zones in the time zone rule set repository is the same as when the image was snapshoted, Chronos maintains a separate list (as a "file" in the time zone repository) of the keys of all timezones.  When it is sent the message #invalidateTimeZoneKeys, the ChronosSystemFacade singleton is responsbile for updating Chronos set of timezone keys maintained by the ChronosResourceRepository of time zone rule sets from the external "file" of zone keys. By default, #invalidateTimeZoneKeys is sent a) when Chronos is first installed, and b) when the image is restarted after a snapshot.				TimeZone Key Alias Registry											To enable both "backwards" and "sideways" compatibility, Chronos maintains a separate registry (as a class variable of TimeZonePolicyFactory) of "alternate keys" (aliases) for some time zones.  When it is sent the message #invalidateTimeZoneAliases, the ChronosSystemFacade singleton is responsbile for refreshing the registry of time zone aliases from the persistent reference data. By default, #invalidateTimeZoneAliases is sent a) when Chronos is first installed, and b) when the image is restarted after a snapshot.					When the Chronos TimeZone Compiler processes the Olson timezone source data, it stores any time zone aliases defined therein in the alias registry maintained by TimeZonePolicyFactory class.  Upon completion of its task of compiling the Olson timezone data into Chronos format, it sends the message #persistTimeZoneAliases to the ChronosSystemFacade singleton.  In response, the ChronosSystemFacade singleton is responsible for persistently storing the registry of timezone aliases.				Leap Second Schedules					When sent the message retrieveLeapSecondScheduleifNone:, the ChronosSystemFacade singleton is responsible for for instantiating and answering a LeapSecondSchedule for the timescale identified by the first argument (a Symbol.) The default implementation provided by ChronosSystemFacade gets the necessary leap second schedule information from a file whose name is &lt;timeScaleKey&gt;.lss.	Motivation:		By concentrating all system-specific code in the class hierarchies of ResourcePathFacade, ChronosSystemFacade, ChronosSystemClock and ChronosEnvironment, and by defining a standard API for the invocation of non-portable services, ResourcePathFacade enhances the portability of the codebase of the Chronos date/time library, both with respect to different implementations/versions of Smalltalk and also with respect to the varying needs and preferences of applications (or code libraries) that use Chronos.		Ideally, porting Chronos to a new Smalltalk implementation (or in some cases, to a new version of a Smalltalk implementation) should require nothing more than writing a new subclass of a) ChronosEnvironment, b) ChronosSystemFacade, c) ResourcePathFacade and d) ChronosSystemClock. In reality, it will probably also be necessary to add (or reuse) inter-system compatibility methods in some classes of the host Smalltalk system's base library. Examples thereof might include methods such as #readStream and #writeStream in SequenceableCollection (or its equivalent(s)), and perhaps one or more utility methods in Stream. Finally, although the ANSI standard requires the existence of a class for scaled decimals, it very unfortunately does not specify the name of the class, nor the protocol for a scaled decimal factory.  Chronos assumes that the global that references the factory object for scaled decimal values is named ScaledDecimal, and that it conforms to the instance creation protocol defined by the VisualWorks FixedPoint class. If the native Smalltalk environment does not use the global name ScaledDecimal to reference the factory object for scaled decimal values, then the method ChronosEnvironemnt&gt;&gt;nativeScaledDecimalClass must be subimplemented by the subclass of ChronosEnvironment that will be used in that environment.  If the scaled decimal factory object's instance creation protocol does not conform to that of the VisualWorks FixedPoint class, then VW compatibility methods must be added.		Modification of the Chronos codebase for the purpose of making Chronos work correctly on the Smalltalk platform to which it is being ported (other than as herein described,) is strongly not recommended. Instead, please notify the author of Chronos of the porting problem {send and e-mail to porting (at) chronos-st (dot) org} so that a general solution to the problem can be designed and incorporated into the mainline Chronos codebase. 		See also: ChronosEnvironment, ChronosSystemClock	Implementation:		Instance Variables		systemTimeZone	&lt;ChronosTimezone&gt;				The Chronos 'system timezone.' The system timezone is intended to a) define the mapping between local time and Universal Time at the location of the host sytem, and b) model, emulate and represent the time zone ruleset used by the host system to report local time to users. Note that there may be a conflict between the first and second goals, since some systems do not have a very sophisticated or accurate implementation of time zone rulesets (e.g., Windows.)						There are three different cases where the value of &lt;systemTimeZone&gt; might be changed:			1. When Chronos is first being installed in an image (or when a non-image-based Smalltalk runtime initially loads the Chronos codebase.) In this scenario, &lt;systemTimeZone&gt; will (if possible) be set to a ChronosTimezone according either to the #setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem strategy or to the #setSystemTimeZoneToAnalogOfNativeSystemTimeZone strategy (as defined below).  If the current ChronosSystemClock keeps and reports time as Universal Time, then the #setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem strategy will be used.  Otherwise, if the current ChronosSystemClock keeps and reports time as local time, then the #setSystemTimeZoneToAnalogOfNativeSystemTimeZone strategy will be used (see the comment for the instance variable &lt;systemTimeZoneBindingStrategy&gt; for the definition of these two strategies.)			2. When an image where Chronos was previously installed is restarted after a snapshot. In this situatation, &lt;systemTimeZone&gt; will be set according to whichever &lt;systemTimeZoneBindingStrategy&gt; is currently in effect. 				3. Whenever application code sends the message #beSystem to a ChronosTimezone. When this happens, the value of &lt;systemTimeZone&gt; will be set to that ChronosTimezone.		systemTimeZoneBindingStrategy &lt;Symbol&gt;				Controls the strategy that will be used to resolve the ChronosTimezone that will become the &lt;systemTimeZone&gt; whenever the image starts after a snapshot (or whenever the Chronos Date/Time library is installed.) The strategy can be changed by sending 'control' messages to the instance, such as #onStartupDoNotSetSystemTimeZoneUnlessBaseSystemTimeZoneIsAnOlsonTimeZone, #onStartupSetSystemTimeZoneToAnalogOfNativeSystemTimeZone or #onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone. The initial default value immediately after Chronos installation is determined by sending the message #defaultSystemTimeZoneBindingStrategy to the instance (see the method for it's specific behavior.)					The valid values of &lt;systemTimeZoneBindingStrategy&gt;, and the semantics of those values, are as follows:				#setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone					Strategy: If it's possible to determine that the host system is using an Olson timezone to define its local time, and if it's also possible to determine the Olson key of that timezone (to the desired degreee of certainty and precision,) then set the &lt;systemTimeZone&gt; to a Chronos VariableOffsetTimezone with the same key. Othwerwise do not change the &lt;systemTimeZone&gt;. [This strategy is preferred when a) the ChronosSystemClock keeps time relative to Universal Time, and not relative to local time, and b) when Chronos clients rarely (if ever) need to change the system timezone once it is correctly set]						#setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem					Strategy: Determine the key of the Olson timezone that is the most congruent to the host system's timezone, and set the &lt;systemTimeZone&gt; to the ChronosTimezone with that key. However, if it is not possible to obtain enough information about the host system's timezone to determine the Olson timezone key of the Olson timezone that would be reasonably congruent to the host system's timezone, then do not change the &lt;systemTimeZone&gt;.  [This strategy is preferred whenever a) the ChronosSystemClock keeps time relative to Universal Time, and not relative to local time, and b) a Chronos client/user is likely to be changing the host system's local timezone with any regularity (e.g., because of laptop/notebook users who travel)]				#setSystemTimeZoneToAnalogOfNativeSystemTimeZone					Strategy: Construct a ChronosTimezone that emulates the behavior of the host system's timezone as closely as possible (i.e., one that serves as a reasonably close--and hopefully perfect--analog of the host system's timezone,) and set the ChronosTimezone so constructed as the &lt;systemTimeZone&gt;. However, if it's not possible to get sufficient information about the host system's timezone to construct a ChronosTimezone that will serve as a reasonable analog, then do not change the &lt;systemTimeZone&gt;. Note that the best "analog" of an Olson timezone that serves as the local timezone of the host system would of course be a ChronosTimezone whose key is the same as that of the host system's Olson timezone. Note also that if an absolute perfect emulation is required, then care must be taken to ensure that both Chronos and the host system will always be using the same version of the Olson Timezone Databse. [This strategy is preferred whenever a) the ChronosSystemClock keeps time relative to local time, or b) whenever a Chronos client interacts with the host system in such a manner that matching Chronos local time to host system local time takes priority over timezone functionality that is maximally congruent to "real world" behavior]		systemLanguageCode	&lt;Symbol&gt;				The ISO 639 code for the language of the current locale. The value may be set whenever the image is restarted after a snapshot (or whenever a non-image-based Smalltalk runtime initially loads the Chronos codebase.)		systemCountryCode		&lt;Symbol&gt;				The ISO 3166 code for the country of the current locale. The value may be set whenever the image is restarted after a snapshot (or whenever a non-image-based Smalltalk runtime initially loads the Chronos codebase.)		resourcePathPrefix		&lt;String | nil&gt;			The common prefix of the pathnames of all Chronos resources to be used by default (e.g., timeone rulesets, timezone localization policies, etc.) The paths in the &lt;resourcePathMap&gt; are initialized with this value as their common path prefix. The value may be nil, which will result in the all the Chronos resource paths being relative to the current working directory.		resourcePathMap 		&lt;Dictionary: Symbol -&gt; ResourcePath&gt;			Each key represents the semantics (purpose, logical function, role) of some file, directory or external resource. Each value is an instance of ResourcePath (which see) that specifies the pathname of some file, directory or external resource.  The specified pathname may be either absolute or relative.  The paths are all initialized with &lt;resoucePathPrefix&gt; as their common prefix.			The entries may simply be hardcoded--in which case &lt;resourcePathMap&gt; only needs to be (re)initialized whenever the hardcoded pathnames are changed, or when Chronos is first installed in an image (or when the runtime of a non-image-based Smalltalk loads the Chronos codebase.)			Alternatively, the &lt;resourcePathMap&gt; may be (re)initialized from some external data source, such as a configuration file, a data base or a remotely-hosted reference data service. In this case, the &lt;resourcePathMap&gt; should be (re)initialized whenever the image is restarted after a snapshot,  (or whenever the runtime of a non-image-based Smalltalk loads the Chronos  codebase.)				The &lt;resourcePathMap&gt; may also be a proxy for a remotely-hosted Dictionary--in which case initialization of the entries is the responsibility of the remote process or image. 		resourcePathFacade 				&lt;ResourcePathFacade&gt; -- see discussion above under the heading 'Storing/Retrieving Chronos Reference Data'		timeZoneAccessor 					&lt;ResourceAccessor&gt; -- see discussion above under the heading 'Accessing Chronos Resources in a Chronos Resource Repository'		tzLocalizationPolicyAccessor 	&lt;ResourceAccessor&gt; -- see discussion above under the heading 'Accessing Chronos Resources in a Chronos Resource Repository'		showReports			&lt;Boolan&gt;			Controls whether or not, after the ChronosSystemFacade singleton has been installed and/or reinitialized after an image startup, that a) the systemTimeZoneKey, b) the systemLanguageCode, c) the systemCountryCode, and d) the current mappings form external resource semantic keys to absolute pathnames will be reported to the "System Transcript" (or its equivalent, such as "stdout" in the case of a command-line based system)	Subclassing:		ChronosSystemFacade is an abstract class.  A concrete subclass appropriate for use on a particular platform, in a particular system environment, for use by a particular client application, must be provided.  Although there are many instance methods that may need to be subimplemented in order to provide functionality optimal for a particular situation, there is fortunately a much shorter list of instance methods that MUST be subimplemented in order to provide a fully operational ChronosSystemFacade singleton (all of which have method comments documenting the behavior for which the method is responsible):			Method Selector															Subimplmentation Requirement			#constructResourcePathFromNativeResourceID:								Mandatory--must have substantive implementation			#resourceExists:																	Mandatory--must have substantive implementation			#resourceIsDirectory:																Mandatory--must have substantive implementation			#makeDirectory:																	Mandatory--must have substantive implementation			#newExternalReadStream:type:													Mandatory--must have substantive implementation			#newExternalWriteStream:mode:check:type: 									Mandatory--must have substantive implementation			#registerForStartupNotification													Mandatory--must have substantive implementation			#renameResource:to:																Mandatory--must have substantive implementation			#unregisterForStartupNotification												Mandatory--must have substantive implementation			#withResourcePathsOfResourcesInDirectory:do:								Mandatory--must have substantive implementation			#chronosDateAndTimeFromNativeCalendricalCoordinate:calendarClock:	Mandatory--unless the Chronos class is also the native one.			#chronosDateFromNativeCalendricalCoordinate:calendarClock: 			Mandatory--unless the Chronos class is also the native one.			#nativeCalendricalCoordinateFromChronosDate:								Mandatory--unless the Chronos class is also the native one.			#nativeCalendricalCoordinateFromChronosDateAndTime:					Mandatory--unless the Chronos class is also the native one.			#chronosTimezoneFromNativeTimeZone:										Mandatory--unless the Chronos class is also the native one.			#nativeTimeZoneFromChronosTimeZone:										Mandatory--unless the Chronos class is also the native one.			#chronosTimeOfDayFromNativeTimeOfDay:									Mandatory--unless the Chronos class is also the native one.			#nativeTimeOfDayFromChronosTimeOfDay:									Mandatory--unless the Chronos class is also the native one.		Additionaly, the following instance methods may require subimplementation in some cases:			Method Selector																		Subimplmentation Requirement			#installPrerequisites																Optional--subimplment to install non-Chronos modules, packages, extensions, plugins (etc.)			#valueOfEnvironmentVariableAt:													Optional--on UNIX, there may be no other way to resolve the local timezone from the host OS.			#resolveSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone			Optional--if UNIX is important, consider enhancing or subimplementing.			#windowsTimeZoneAttributes														Optional--must return nil if not hosted on a system that uses Windows timezone rulesets.			#setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem	Optional--subimplementing one or more of the other methods may suffice.			#setSystemTimeZoneToAnalogOfNativeSystemTimeZone					Optional--subimplementing one or more of the other methods may suffice.			#setBaseSystemTimeZoneFromChronosSystemTimeZone					Optional--but substantive implementation is recommended.											#handleNonExistenceOfResourcePathReferencedBy:						Optional--but substantive implementation is recommended.			#defaultSystemTimezoneBindingStrategy										Optional--change or subimplement to get desired behavior.			#copyResource:to:																	Optional--can be no-op (present solely for API completeness.)			#deleteResource:																	Optional--can be no-op (present solely for API completeness.)			#moveResource:to:																	Optional--can be no-op (present solely for API completeness.)			#rfc868SecondsSince1900														Optional--Unless the canonical ChronosSystemClock singleton will be using it.			#sizeOfResource:																	Optional--can be no-op (present solely for API completeness.)			#byDefaultShouldShowReportsOnStartup										Optional--must return true or false; the base implementation returns false.						</body></comment><class><name>VWSystemFacade</name><environment>Chronos</environment><super>Chronos.ChronosSystemFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System-VisualWorks</category><attributes><package>Chronos-System-VW</package></attributes></class><comment><class-id>Chronos.VWSystemFacade</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})VWSystemFacade is a concrete implementation of ChronosSystemFacade specific to VisualWorks Smalltalk versions later than 5i.4 (e.g., 7.0, 7.1, etc.)  See the class comment of ChronosSystemFacade for more information.</body></comment><class><name>ClassicVWEnvironmentFacade</name><environment>Passport</environment><super>Passport.EnvironmentFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.ClassicVWEnvironmentFacade</class-id><body></body></comment><class><name>VW3xEnvironmentFacade</name><environment>Passport</environment><super>Passport.ClassicVWEnvironmentFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VW3xEnvironmentFacade</class-id><body></body></comment><class><name>VW5iEnvironmentFacade</name><environment>Passport</environment><super>Passport.VW3xEnvironmentFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VW5iEnvironmentFacade</class-id><body></body></comment><class><name>EffectiveYearTemporalRule</name><environment>Chronos</environment><super>Chronos.TemporalRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightLink effectiveYear </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.EffectiveYearTemporalRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})EffectiveYearTemporalRule	Concept:		EffectiveYearTemporalRule is an abstract subclass of TemporalRule.  An instance of a concrete subclass of EffectiveYearTemporalRule serves as a TemporalRule (which see) where transitions from one version of the rule to another may happen at the start of any year.	Usage:		See the individual method comments.	Implementation:				EffectiveYearTemporalRule implements the rule chain so that the first link in the chain is the most recent rule, and a rule's nextLink refers to its predecessor rule. Subclasses may invert the semantics.		Instance Variables					rightLink			&lt;EffectiveYearTemporalRule&gt;										The next EffectiveYearTemporalRule in the instance's rightward "rule chain" 									(the rigthward linked list of versions of the "same" rule in effect during different, 									non-overlapping periods of time.) EffectiveYearTemporalRule interprets									the &lt;rightLink&gt; as a reference to a predecessor rule that was previously									in effect. A subclass may define the &lt;rightLink&gt; to be either the 									predecessor or the successor rule (a decision that must apply to all									instances of the same class.)			effectiveYear	&lt;Integer&gt; 															The version of the rule represented by the instance came into effect									at the start of the year &lt;effectiveYear&gt;.	Subclassing:		In order to invert the temporal ordering of the "rule chain," subclasses may want to subimplement the instance methods #sortOperator and #compareEffectiveYearTo:. Subclasses are responsibile for defining and implementing the semantics of the ruleforms.</body></comment><class><name>TimeZonePolicy</name><environment>Chronos</environment><super>Chronos.EffectiveYearTemporalRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>effectiveYearCalendar effectiveYearRelativity registrationKey defaultName geographicCoordinates leftLink annualPolicy rootTZ </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-Policies-Diachronic</category><attributes><package>Chronos-TimeZones-Policies-Diachronic</package></attributes></class><comment><class-id>Chronos.TimeZonePolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})TimeZonePolicy	Concept:		A TimeZonePolicy represents the full diachronic ruleset of a time zone, from the inifinite past up until the moment it is superceded by a more recent ruleform. It's purpose is to enable the binding of a point-in-time value to a particular time zone abbreviation and offset from UT (in the form of a "bound, dynamic" time zone instance.) 		A TimeZonePolicy uses the behavior inherited from EffectiveYearTemporalRule to implement a `rule chain` of ruleforms, where each ruleform in the chain defines a time zone's abbreviation and offset from UT for each moment in time since the start of the effective year of the ruleform until it is superceded by a succcessor ruleform.  The predecessor link in the chain of ruleforms specifies the time zone rules that were in effect prior to the rules specified by the successor.  Each ruleform in the chain of ruleforms specifies only its effective year, it does not specify the year it is superceded by a successor ruleform.		The ruleform specified by a TimeZonePolicy instance may specify that a time zone has a single abbrevation and a single offset from UT, without any variation, throughout the period of time during which it is in effect, or else it may specify that the abbreviation and/or the offset from UT transition to new values during its effective period.  Transitions to new offset and/or abbreviation values are specified to occur as of an annually recurring date and time (e.g., every year on April 15 at noon local time, every year on the last Sunday in November at 1 am Universal Time.)		In rare cases, it is necessary to use the subclass AsymmetricTimeZonePolicy instead of using TimeZonePolicy.  Such is required whenever a time zone transitions to a new offset and/or abbreviation on either the first or the last day of the year.	Usage:		To create a new instance that represents a single ruleform (a "rule chain" with only one element/ruleform), send the class message #effectiveYear:annualPolicy: to TimeZonePolicy.  See the method comment for details. See the documentation in the superclasses TemporalRule and EffectiveYearTemporalRule for information about constructing a chain of ruleforms from individual elements. Hint: See the inherited instance method #asListSortedInCanonicalOrderByTransitionTimeAdding:.		To create a new "rule chain" that represents a full diachronic time zone ruleset, deserialized from the time zone ruleset specification persistently stored in the external Chronos time-zones repository, send the class message #for:ifNone: to TimeZonePolicy.  See the method comment for details.  		For a variety of reasons, it is highly recommended that the Chronos TimeZonePolicy factory objects be used to create TimeZonePolicy rule chains.  The Chronos TimeZonePolicy factory objects are instances of TimeZonePolicySequenceFactory, TimeZonePolicyElementFactory and the concrete subclasses of AnnuallyRecurringTZPolicyFactory. See TimeZonePolicySequenceFactory for more information.	Implementation:		Instances of TimeZonePolicy themselves directly implement the rule chain. Each instance specifies the effective year of the ruleform it represents.  All other  properties and behaviors of the ruleforms themselves are specified and provided by instances of (concrete subclasses of) AnnuallyRecurringTZPolicy.		Instance Variables {Also see superclass}			leftLink 			&lt;TimeZonePolicy | nil&gt;	The TimeZonePolicy whose annual policy will be in effect after the instance's &lt;annualPolicy&gt; expires.			annualPolicy	&lt;AnnuallyRecurringTZPolicy&gt; 				The &lt;annualPolicy&gt; specifies the annually-recurring intra-year rules of the instance's ruleform. The &lt;annualPolicy&gt; defines, for each moment in time since the start of the effective year of the instance, until the instance is superceded by a later ruleform, the abbreviation and offset from UT of the time zone whose ruleset is (partially or fully) represented by the instance. The &lt;effectiveYear&gt; instance variable inherited by a TimeZonePolicy specifies the first year its ruleform is in effect, and consequently the first year its predecessor ruleform is no longer in effect. The &lt;effectiveYear&gt; is specified in the local ("wall clock") time defined by the time zone whose ruleset is represented by the instance.  The ruleform specified by the instance goes into effect as of the initial moment of its &lt;effectiveYear&gt; (and expires as of the last moment--local time--of the year prior to the &lt;effectiveYear&gt; of its successor in the rule chain, if any.)</body></comment><class><name>AsymmetricTimeZonePolicy</name><environment>Chronos</environment><super>Chronos.TimeZonePolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utEffectiveYear utEffectiveDayOfYear utEffectiveSecondsSinceStartOfDay </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-Policies-Diachronic</category><attributes><package>Chronos-TimeZones-Policies-Diachronic</package></attributes></class><comment><class-id>Chronos.AsymmetricTimeZonePolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})AsymmetricTimeZonePolicy	Concept:		An AsymmetricTimeZonePolicy is a TimeZonePolicy specialized for handling the rare cases where a time zone transitions to a new offset and/or abbreviation on either the first or the last day of the year.  A correctly-initialized AsymmetricTimeZonePolicy can be used in place of any instance of TimeZonePolicy regardless of the transitions it specifies, but that is only necessary when the ruleform to be represnted by a TimeZonePolicy (referring to the type, not to the class in this case) specifies an offset/abbreviation transition on the first day of the year, or when the predecessor ruleform specifies an offset/abbreviation transition on the last day of the year--and even then, it's only necessary when the "transition" actually results in a different offset-abbreviation tuple (there are cases in the Olson rules where such "no-op" transitions are specified.)		The Chronos TimeZonePolicy factory objects (see the comment in the superclass) automatically create an instance AsymmetricTimeZonePolicy whenever necessary--which is one reason that it is strongly recommended that the factory objects should be used to create TimeZonePolicy rule chains .	Implementation:		Instance Variables			utEffectiveYear 							&lt;Integer&gt;	The instance's &lt;effectiveYear&gt; (see superclasses) in Universal Time.			utEffectiveDayOfYear 					&lt;Integer&gt;	The oridinal (first = 1) day of year (in Universal Time) the instance's ruleform takes effect.			utEffectiveSecondsSinceStartOfDay		&lt;Integer&gt; 	The seconds-since-start-day (0..86400, in Universal Time) at which the instance's ruleform takes effect.</body></comment><class><name>PersianCalendar</name><environment>Chronos</environment><super>Chronos.MonthsPerYearInvariantCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.PersianCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})PersianCalendar	Concept:		PersianCalendar implements the arithmetical version of the Persian Calendar.  There is also an astronomical version of the Persian Calendar, which some authorities claim is the one actually used in Iran, although other authorities claim otherwise.  Chronos does not currently provide implementations of any astronomical calendars. The astronomical version of the Persian Calendar will (eventually) be implemented by class named AstronomicalPersianCalendar, whose registration key will be #'Persian-Astronomical'.		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Persian Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Persian Calendar (as implemented here) is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.  		Epoch Date			The epoch date of the Persian Calendar, 0001-01-01 [Persian], corresponds to 0622-03-22 [Gregorian] and to 0622-03-19 [Julian].  The Julian Date of the epoch of the Persian Calendar is 1,948,320.50 (midnight.) 			The epoch date of the Persian Calendar is the vernal equinox of the year in which the "hijra" of Mohammed to Medina occurred ("hijra" means "flight from danger.") 			The era of the Persian Calendar is called "Anno Persico" or "Anno Persarum" (AP)--which is Latin for "In the Year of Persia/the Persians."		Time-of-Day Clock			Modernly, midnight is both the zero-point of the time-of-day clock and also the initial moment of the day.  However, such has not always been the case for all users of the Persian Calendar.			{PersianCalendar clock today}			{PersianCalendar clock now}		Year Numbering Policy			The Persian Calendar uses "zeroless ordinal" year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year -1.		Leap Year Rule			According to Birashk [A. Birashk, "A Comparative Calendar of the Iranian, Muslim Lunar, and Christian Eras for Three Thousand Years," Mazda Publishers (in association with Bibliotheca Persica,) Costa Mesa, CA, 1993], the arithmetical form of the Persian Calendar uses the following rather complicated leap year rules:			There is a master cycle of 2820 years, during which 683 years are leap years. Each standard year contains 365 days, and each leap year contains 366 days, so the master 2820-year cycle contains 1,029,983 days [(2820 * 365) + 683 = 1,029,983].  Based on the current mean length of the tropical year and solar day, there are 1,029,983.00118 days in 2820 tropical years.  So, were it not for the fact that a) the length of the tropical year and the length of a mean solar day is slowly changing, and b) the length of the tropical year (which is defined by the duration between winter solstices) is not the same as the length of the spring equinoctial year (which is defined by the duration between vernal equinoxes,) it would be fair to say that the Persian arithmetical calendar deviates from the length of a year by only 101.952 minutes in 2820 years.  But for those (and other) caveats, the Persian arithmetical calendar would slip from perfect alignment with the tropical year by only one day every 39,829.68 years--which is astounding accuracy, in spite of the caveats. 			Within each 2820-year cycle, there are 22 subcycles--the first 21 each contain 128 years, and the 22nd (final) subcycle contains 132 years [2820 = 21 * 128 + 132].			Each 128-year subcycle contains one 29-year sub-subcycle (the first,) followed by three 33-year sub-subcycles [128 = 29 + (3 * 33)].			Each 132-year subcycle contains one 29-year sub-subcycle (the first,) followed by two 33-year sub-subcycles, followed by one 37-year sub-subcycle [132 = 29 + (2 * 33) + 37].			A year in a sub-subcycle (whether it contains 29, 33 or 37 years) is a leap year if the ordinal index of the year within the cycle satisfies the following two predicate tests: 1) it's greater than 1, and 2) the remainder after dividing it by 4 is 1 (so the first year in sub-subcyle is never a leap year; the first leap year is the fifth year in the sub-subcycle.) Thus, a 29-year sub-subcycle has 7 leap years, a 33-year sub-subcycle has 8 leap years, and a 37-year sub-subcycle has 9 leap years (Note: the last year of a sub-subcycle is always a leap year, since 29, 33 and 37 all result in a remainder of 1 when divided by 4) [21 * (7 + (3 * 8)) + (7 + (2 * 8) + 9) = 683].			The base year of the 2820 cycle of years is NOT the Persian year zero or 1, however.  The base year of the 2820-year cycle of years is the Persian year 475 (which starts on 21 March 1096 [Gregorian] or 15 March 1096 [Julian].)  However, to facilitate the use of modular arithmetic, the Chronos implementation uses Persian year 474 as the zeroeth year of the 2820-year cycle.			Algorithm of Predicate Function that answers true if a &lt;persianYear&gt; is a leap year (input arg=&lt;persianYear&gt;):				1. If &lt;persianYear&gt; &gt;= 1 then					set &lt;cardinalYear&gt; to &lt;persianYear&gt; - 1;				   else					set &lt;cardinalYear&gt; to &lt;persianYear&gt;;				   end				2. Set &lt;dividend&gt; to &lt;cardinalYear&gt; - 473.				3. Set &lt;year&gt; to (dividend mod 2820) + 474.				4. Return (((&lt;year&gt; + 38) * 682) mod 2816) &lt; 682		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: Farvardin					31/31			2: Ordibehesht				31/31			3: Xordad					31/31			4: Tir						31/31			5: Mordad					31/31			6: Shahrivar					31/31			7: Mehr						30/30			8: Aban						30/30			9: Azar						30/30			10: Dey						30/30			11: Bahman					30/30			12: Esfand					29/30			Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name (as given here.)				</body></comment><class><name>IslamicFatimidCalendar</name><environment>Chronos</environment><super>Chronos.MonthsPerYearInvariantCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.IslamicFatimidCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})IslamicFatimidCalendar	Concept:		IslamicFatimidCalendar implements the Islamic Fatimid Calendar.  The Islamic Fatimid Calendar (also called the Tabular Islamic Calendar) is an arithmetical variation of the Astronomical Islamic Calendar (the one most Muslims use for religious purposes.) It has the same year numbers and months, but the months are determined by arithmetic rules rather than by observation or astronomical calculations. It was developed by early Muslim astronomers of the second Hijra century (the eighth century AD) to provide a predictable time base for calculating the positions of the moon, sun, and planets. Historians use it to convert an Islamic date into a Western calendar date when no other information (like the day of the week) is available. Some Muslims (e.g, the Daudi Bohras, the Isma'ilis) also use the arithmetical calendar for regligous purposes [reference: http://archive.mumineen.org/publications/oup/bohras.html].  All Muslims commonly use it to estimate future (and sometimes past) dates.		Many authoritative reference works claim that almost all Muslims use an observation-based calendar. While that used to be true, it is no longer the case--at least not for legal/civil purposes. A substantial percentage of Muslims now use astronomical calculations to determine when each month will be deemed to have started and ended for civil/legal matters. Such is the case in Saudi Arabia and most of the Gulf countries. Although few Muslims currently use an astronomical version of the Islamic calendar for religious purposes, such use is beginning to be discussed and considered. [References: http://www.jas.org.jo/sau.html; http://www.phys.uu.nl/~vgent/islam/mecca/ummalqura.htm; http://www.amperspective.com/html/the_hijra_calender_2005.html; http://www.abc.net.au/science/news/space/SpaceRepublish_1352797.htm]		Chronos may provide an implementation of the official Saudi astronomical Islamic Calendar in the future. If so, the calendar registration key will be #'Islamic-Saudi'.  The registration key #'Islamic-Astronomical' is reserved until there is some astronomical Islamic calendar which is widely accepted as the standard or canonical Islamic Calendar (which the Saudi version may become, but it's too soon to accord it such status at present.)		For now, however, Chronos only provides the Fatimid (arithmetical) Islamic Calendar, for the following reasons: 1) Chronos will never support any purely observational calendars, 2) Chronos does not yet support any astronomical calendars, and 3) there is as yet no widely-accepted, standard/canonical astronomical Islamic calendar (although this may be in the process of changing.)		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Islamic Fatimid Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Islamic Fatimid Calendar is an arithmetical, lunar calendar. A lunar calendar is one that attempts to align the day on which one month transitions to the next with the moment that the moon transitions from one phase to the next, so that each month begins within a day or so of the moment that the moon exits from or enters into a particular phase. A lunar calendar makes no attempt to match the length of its years to the length of the solar year.		The Islamic Calendar transitions from one month to the next as a function of each New Moon. 		Epoch Date			The epoch date of the Islamic Fatimid Calendar, 0001-01-01 [Islamic-Fatimid], corresponds to 0622-07-19 [Gregorian] and to 0622-07-16 [Julian].  Islamic days begin at sunset. The Julian Date of the Islamic epoch is 1,948,439.25 (6 pm,) so the actual initial moment of the Islamic epoch corresponds to 0622-07-18T18:00:00 [Gregorian] and to 0622-07-15T18:00:00 [Julian]. 			The epoch date of the Islamic Calendar marks the generally accepted date of the "hijra" of Mohammed to Medina ("hijra" means "flight from danger.")  There are some who prefer a different date in the same year for this event, but the Islamic Calendar uses the generally-accepted date as its epoch.			The Islamic era is called "Anno Hegirae" (AH,) which is Latin for "In the Year of the Hijra."		Time-of-Day Clock			Although Islamic days begin at sunset, Muslims modernly label the hours of the day beginning at midnight.  So the zero-point of the the time-of-day clock is midnight, although the initial moment of the day is 6 pm.			{IslamicFatimidCalendar clock today}			{IslamicFatimidCalendar clock now}		Year Numbering Policy			The Islamic Calendar uses ordinal year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year 0.		Leap Year Rule				A year is a leap year if the following function evaluates to true: isIslamicLeapYear(calendarYear) =&gt; ((calendarYear * 11) + 14) \\ 30 &lt; 11.		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: Muharram				30/30			2: Safar						29/29			3: Rabi1					30/30			4: Rabi2					29/29			5: Jumada1					30/30			6: Jumada2					29/29			7: Rajab					30/30			8: Shaban					29/29			9: Ramadan					30/30			10: Shawwal				29/29			11: Dhu al-Qa'ada			30/30			12: Dhu al-Hijja				29/30			Days In Year				354/355			The semantic month-key of a month is the same as the month's (English) name (as given here.)			</body></comment><class><name>InfiniteTimepoint</name><environment>Chronos</environment><super>Chronos.TemporalInterval</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isNegative </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.InfiniteTimepoint</class-id><body></body></comment><class><name>SemanticDateObservanceRule</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>yearBase yearPeriod expirationYear dayOfWeekPolicy dayOfMonthConstraints </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Semantic Dates</category><attributes><package>Chronos-Semantic Dates</package></attributes></class><comment><class-id>Chronos.SemanticDateObservanceRule</class-id><body></body></comment><class><name>YearMonthDay</name><environment>Chronos</environment><super>Chronos.AbstractDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year calendarDay </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.YearMonthDay</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>Timepoint</name><environment>Chronos</environment><super>Chronos.YearMonthDay</super><private>false</private><indexed-type>none</indexed-type><inst-vars>daysSinceEpoch secondsSinceStartOfDay nanosecondsSinceSecond timeZone </inst-vars><class-inst-vars>universalTZ nominalTZ utcTZ </class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.Timepoint</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})Timepoint [Aliased by the global DateAndTime, unless that conflicts with a native global of the host Smalltalk environment]	Concept:		## NOMINAL TIME INVARIANCE vs. UNIVERSAL TIME INVARIANCE {this section is strongly recommended for all Chronos users}				## UNIVERSAL TIME (UTC,) COORDINATED UNIVERSAL TIME (UTC) and LEAP SECONDS {if you don't care about timescales and/or leap seconds, you may skip this section}			The formal name of the standard international reference zero-offset timezone is Universal Time (UT, although it is colloquially referred to as GMT more often than not--even by techies.) The formal name of the standard international reference timescale is Coordinated Universal Time (UTC.) However, UT and UTC are technically not the same thing at all: UT is a timezone; UTC is a timescale.  			Universal Time, and any other timezone, can be used with any terrestrial timescale that uses Greenwhich Mean Time (directly or indirectly) to establish the zero-point of the time-of-day clock.  Were such not the case, it would be impossible for any country that didn't use the UTC timescale to define its timezones as offsets from Universal Time--and not all countries use the UTC timescale as the basis for their civil time-of-day, even though they all define their timezones as offsets from Universal Time. Universal Time is simply the timezone whose offset from the specific timescale of one's choice (UT0, UT1, UTC, etc) is an invariant 0.0 seconds.			UTC is also quite commonly used as a synonum for UT, even though the former is technically a timescale and the latter is technically a timezone. In addition to the use of GMT as a synonym for UT, this can create no small amount of confusion and/or bogosity.  For example, many date/time libraries use the term UTC to mean the timezone UT.  They cannot possibly be literally referring to the UTC timescale, since they do not support leap seconds.  The same is true of international standards such as POSIX and the ANSI Smalltalk Standard.			For example, the ANSI-Smalltalk standard says the following with respect to the behavior of the &lt;DateAndTime&gt; protocol:				"This protocol describes the behavior that is common to date time objects. Date time objects represent individual points in Coordinated Universal Time (UTC) as represented in an implementation defined local time. The exact properties of local times are unspecified. Local times may differ in their offset from UTC. A given local time may have different offsets from UTC at different points in time. All dates and times in the UTC local time are in the Gregorian calendar. Date times prior to the adoption of the Gregorian calendar are given in the retrospective astronomical Gregorian calendar. The year 1 B.C. is astronomical Gregorian year 0. The year 2 B.C. is astronomical Gregorian year-1. The year 1 A.D. is astronomical Gregorian year 1. The offset of the UTC local time is zero."			Given the precisely-specified requirements, the lack of any mention of leap seconds stands out. The X3J20 committee's specification does bother to define UTC as the timezone whose local time offset is zero. But why say that much, while saying nothing about leap seconds? 			If the X3J20 committe intended "Coordinated Universal Time (UTC) " to be a reference to UTC as a timescale, including its use of leap seconds, then why did they take such care in the specification of the semantics of &lt;DateAndTime&gt; values, without any explicit requirement to handle leap seconds?  To be consistent with the level of detail on other matters, had the committee intended to require the proper handling of leap seconds, they should have a) said so explicity, b) specified the moment of insertion of the 10 "floating" leap seconds from 1955 to 1972 whose moments of insertion are not specified anywhere by any international standard, and c) specified how leap seconds in the future, and before 1955, should be dealt with (Ignore them? Estimate them? Provide for dynamic leap second notification? Leave such questions as implementation defined--which they usually **explicitly** do for other issues?).			Consider also the ANSI-Smalltalk Standard's documentation of the message DateAndTime&gt;&gt;second, which says the following: "Answer a &lt;number&gt; greater than or equal to 0 and strictly less than 60 representing the second of the minute of the local time of the receiver."  This statement actually forbids leap seconds, since a leap second would have the cardinal value 60, which is not legal (the cardinal number of seconds must be "strictly less than 60.")			Finally, there is the fact that earlier draft versions of the Standard did explicitly require the correct handling of leap seconds.  The statements in the X3J20 specification that required leap second handling were deliberately removed from the later (and final) versions of the standard, because the members of the X3J20 committee decided that mandatory support for leap seconds would be too great a burden (that information comes from public statements made by members of the X3J20 committee, including a written statement by Douglas Surber, who was the principal author of the section of the standard that deals with date and time protocols.)  So, although the ANSI Smalltalk standard states that &lt;DateAndTime&gt; values are coordinate points in UTC, it is beyond reasonable doubt that "UTC" is being (incorrectly) used in this case as a synonym for Universal Time, without reference to a specific timescale.  Such (mis)usage of the term "UTC" is quite common, even in contexts where one might rightly expect a high level of rigour and precision in the use of technical terms.			Similarly, the VisualWorks documentation says the following with respect to the operation of the VisualWorks system clock primitive (which returns the number of clock ticks since 1901-01-01T00:00:00+00:00 as a count of microseconds):  "With the arrival of the object engine's microsecond clock, which provides the time in UTC (GMT) for all platforms, all users must now set the TimeZone."  However, it is easy to prove either that the implementation is broken, or that the author of this statement meant the timezone UT, not the timescale UTC. Without even considering the actual behavior of the VW system clock, the parenthetical "GMT" in this statement strongly suggests the latter interpretation.			To the best of the author's knowledge, the "vanilla" version (as delivered in the default image) of all date/time libraries that claim to be compliant with the ANSI-Smalltalk Standard do not handle leap seconds, and use the UT1 timescale.  However, David T. Lewis has implemented an optional module for Squeak (available from SqueakMap) that enhances Brent Pinkney's ANSI-compliant Chronology Date/Time library (currently the native date/time library of Squeak) so that it supports leap seconds.			The fact is, few computer operating systems natively support leap seconds.  Windows does not.  MacOS and MacOS-X do not.  POSIX-compliant systems are forbidden from doing so. The fact that POSIX systems emit timestamp strings that use "UTC" to indicate the UT timezone just adds to the general confusion.  POSIX is far from the only offender in this regard (e.g, Java.).  It would be easier to list the systems that do use the term UTC correctly--or that actually correctly implement leap seconds.			The bottom line is this: any system which expects sub-second timing precision needs to be very carefully designed, taking into account all of the sources of delay and error. In more plain language, what the *&amp;%#$! are you thinking if you expect to use the system clock in your computer for precision timing? Few computer clocks are accurate to anywhere near one second every year--and that's the level of accuracy needed before the distinction between UT1 and UTC begins to have any relevance whatsoever.  Nevertheless, some use cases actually do require that degree of accuracy, and some applications have to correctly handle very precise UTC timestamps--perhaps generated by special (and expensive) clocks other than those installed on the motherboard of a laptop or desktop personal computer, or else generated by local clocks that are disciplined by means of the Network Time Protocol (which periodically synchronizes local clocks with atomic clocks over a network, and measures and corrects for the inaccuracies of the local clocks, greatly enhancing the effective accuracy of the local clocks.) For this reason, full support for leap seconds is planned for a future release of the Chronos Date/Time library.	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>Pathname</name><environment>Passport</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.Pathname</class-id><body>Pathname	Concept:				A pathname is a hierarchical key referencing some value in a hierarchy of namespaces.  Mathematically, it is an N-tuple of N keys whose sequence specifies a dereferencing path through a lattice of namespaces.  Specifically, given the namespaces Root, Alpha and Beta, where Root is the pre-agreed starting point for dereferencing keys in a particular context, where Alpha is a namespace defined in Root, where Beta is a namespace defined in Alpha, and where gamma is some value defined in Beta, then the pathname (Alpha, Beta, gamma) is a 3-tuple hierarchical key (or pathname) that specifies the value that results from using Root to dereference Alpha, then using Alpha to dereference Beta, and finally using Beta to dereference gamma.		A common example of a pathname would be a filename.  For example, the UNIX filename /usr/local/bin/tool is a 4-tuple hierarchical key whose components are (usr, local, bin, tool).  Similarly, the Windows filename WINDOWS\I386\SYSTEM32\NTDLL.DLL is a 4-tuple hierarchical key whose components are (WINDOWS, I386, SYSTEM32, NTDLL.DLL). In either case, the first component of the pathname is dereferenced using a standard or pre-agreed namespace (in the context of filenames, this is usually either the "root directory" or else the "current directory.") So, in the given filename examples, both "usr" and "WINDOWS" refer to "namespaces" defined in the "root" namespace (or "root directory.")  Applying the same pattern, "local" refers to a namespace (directory) that is defined in the "user" namespace (directory,) and "I386" refers to a namespace (directory) that is defined in the "WINDOWS" namespace (directory.) Inductively applying the same dereferencing strategy ultimately results in dereferencing the file named "tool" from the namespace (directory) "bin," and the file named "NTDLL.DLL" from the namespace (directory) "SYSTEM32." Note that all but the final component of a pathname must be able to function as namespaces by which to dereference the value of the next key in the sequence. In the case of a file pathname, this means that all but the final component of the pathname must refer to a "file directory."		It is common practice to represent pathnames by means of encoded Strings--especially in the case of file pathnames. However, in order to represent any hierarchical key as a String, a syntax must be defined which makes it possible to distinguish the components of the hierarchical key from each other.  For this purpose, UNIX filenames use a "/" character, Windows filenames use a "\" character, and Macintosh (HFS+) filenames use a ":" character. And other syntax is used in domains other than filenames.  Such syntactical differences make it difficult to represent pathnames in a portable way.		Instances of Pathname are intended to represent hierarchical keys, such as file pathnames, in a syntax-independent form. Additionally, an instance of Pathname, unlike a String instance, provides protocol and behavior appropriate to the function and purpose of a hierarchical key/pathname.		Pathname inherits from Immutable (which see.) Once initialized, a Pathname instance becomes immutable.	Usage:		A Pathname is a sequence of components, where each component is a String (or a String-like object, such as a Symbol or a Text).  		A Pathname can be created directly from an Array of Strings, by sending the message #components: to the class with an Array of Strings as the argument {Pathname components: #('usr' 'local' 'bin' 'tool')}. A Pathname can also be created by parsing an encoded String, by sending the message #fromString:separator: to the class, with the encoded String as the first argument and the "separator character" as the second argument {Pathname fromString: 'foo/bar/mitzvah' separator: $/} {Pathname fromString: 'foo\bar\mitzvah' separator: $\}.		Instance protocol is provided by which to:			* Enumerate the components;			* Extract a subsquence of the components;			* Create a new Pathname by appending a suffix; 			* Create a new Pathname by removing a component;			* Create a new Pathname that is a subsequence of the components of another;			* Create a new Pathname that is a prefix of another; and			* Create a new Pathname that is a suffix of another.		Examples (executable):						(Pathname components: #('usr' 'local' 'bin' 'tool')) withFirst			(Pathname components: #('usr' 'local' 'bin' 'tool')) withLast			(Pathname components: #('usr' 'local' 'bin' 'tool')) withAllButFirst			(Pathname components: #('usr' 'local' 'bin' 'tool')) withAllButLast			(Pathname components: #('usr' 'local' 'bin' 'tool')) prefixTo: 3			(Pathname components: #('usr' 'local' 'bin' 'tool')) suffixFrom: 2			(Pathname components: #('usr' 'local' 'bin' 'tool')) from: 2 to: 3			(Pathname components: #('usr' 'local' 'bin' 'tool')) removing: 'local'			(Pathname components: #('foo' 'bar')) appending: 'baz'			(Pathname components: #('foo' 'bar')) appendingAll: #('and' 'grill')			(Pathname components: #('foo' 'bar')) appendingPathname: (Pathname components: #('and' 'grill'))			(Pathname components: #('foo' 'bar')), 'baz'			(Pathname components: #('foo' 'bar')), #('and' 'grill')			(Pathname components: #('foo' 'bar')), (Pathname components: #('and' 'grill'))	Motivation:				To provide a representation of a hierarchical key/pathname that is syntax-neutral; to provide protocol/behavior specific and appropriate to a value whose function/purpose is a hierarchical key/pathname--but with an implementation that is independent of any particular domain (e.g., file pathnames.)	Implementation:		Instance Variables			components		&lt;Array of String&gt; The components of the hierarchical key/pathname represented by the instance.</body></comment><class><name>CalendricalAnnualDate</name><environment>Chronos</environment><super>Chronos.AnnualDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.CalendricalAnnualDate</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>ChronosEnvironment</name><environment>Chronos</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Environment</category><attributes><package>Chronos-Environment</package></attributes></class><comment><class-id>Chronos.ChronosEnvironment</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosEnvironment	Concept:				ChronosEnvironment is an abstract class. A concrete subclass of ChronosEnvironment provides namespace definition/initialization functionality whose implementation is necessarily specific to a particular Smalltalk platform/system (e.g., VisualWorks, Squeak, STX, Dolphin, GNU Smalltalk, etc.) The concrete ChronosEnvironment subclass specific to a particular Smalltalk system/environment is called the "platform class."		The ChronosEnvironment platform class is responsible for defining certain namespaces (or "shared pool" Dictionaries,)  and for defining the bindings (entries, name-value associations) in those namespaces. Either the ChronosEnvironment platform class, or else its singleton instance, is responsible for initializing those bindings to appropriate values.  (Note: In the terminology of the orginal Smalltalk-80, a "binding" is an Association in a Dictionary, a "global binding" is an Association in the canonical instance of SystemDictionary, and a "shared pool binding" is an Association in a "shared pool dictionary" containing non-global variables shared among a set of classes that may or may not be in the same inheritance hierarchy).  		The namespaces (or "shared pool" Dictionaries) that the ChronosEnvironment platform class is responsible for defining are as follows:			Namespace name						Namespace purpose			Chronos								Serves as the naming scope for the classes of the Chronos Date/Time Library, used 													so as to avoid class-name collisions with other class libraries and/or applications.													The Chronos namespace may or may not actually be defined, depending on whether													or not the host Smalltalk system and tooling adequately support defining, browsing													and editing classes in multiple, independent namespaces.			ChronosTemporalRatioConstants			Defines constant ratios between temporal units (e.g., 'SecondsPerDay').			ChronosDaysOfWeekConstants			Defines named constants for day-of-week ordinals (both ANSI Smalltalk and ISO 8601 values).			ChronosStandardMonthConstants		Defines named constants for Gregorian/Julian month ordinals (must have ISO 8601 values).			ChronosFactoryBindings					Defines aliases for certain Chronos classes where name collisions with other date/time 													libraries would be especially likely.The Chronos codebase always uses the aliases 													defined in ChronosFactoryBindings to refer to these particular classes. This strategy													also facilitates using alternative implementations of the standard Chronos classes,													should such be desired.			ChronosCalendarConstants				Defines constants referring to the GregorianCalendar and JulianCalendar singletons, 													and to the AnsiStandardCalendar singleton and its associated CalendarClock instance.			ChronosDurationConstants				Defines constants for common Duration and CalendarDuration values.			ChronosConstants						Defines all the Chronos constants in a single namespace.  Where possible, this should													be implemented using namespace import (otherwise, the existing bindings (Associations) 													defined in the 'home' namespace (Dictionary) should be added into ChronosConstants,													so that the same binding (Association instance) exists in both the 'home' namespace 													and also in ChronosConstants.)		Additionally, the ChronosEnvironment singleton is responsible for defining the global names DateAndTime, Duration, Timezone, SystemClock and ScaledDecimal (as entries in the canonical global namespace of the host Smalltalk implementation--which is usually referenced using the global name 'Smalltalk.'  **** However, if any of these globals are members of the Set of 'protected global variables,' then they will NOT be defined in the global namespace if already present, nor will the values of their global bindings be changed by Chronos. The Set of 'protected global variables' can be retrieved by evaluating 'ChronosEnvironment platformClass protectedGlobalVariables', and its contents are established by the class method #setProtectedGlobalVariables (which should be sub-implemented as is appropriate for each Smalltalk environment/system.) **** 		DateAndTime is the ANSI-standard name for a factory object (which doesn't have to be a class) responsible for instantiating objects that conform to what the ANSI Standard refers to as the &lt;DateAndTime&gt; protocol.  The Chronos class that implements both the ANSI &lt;DateAndTime&gt; protocol and the ANSI &lt;DateAndTimeFactory&gt; protocol is named Timepoint (partly because that name is less likely to conflict with any class name defined in some other Date/Time library.)		Duration is the ANSI-standard name for a factory object (which doesn't have to be a class) responsible for instantiating objects that conform to what the ANSI Standard refers to as the &lt;Duration&gt; protocol.  The Chronos class that implements both the ANSI &lt;Duration&gt; protocol and the ANSI &lt;DurationFactory&gt; protocol is actually called ScientificDuration (because it implements temporal durations in a way that is compatible with scientific/technical use cases, as opposed to CalendarDuration, which implements temporal durations in a way that is compatible with civil/business use cases, and partly because that name is less likely to conflict with any class name defined in some other Date/Time library.)		Timezone is an alias for the class ChronosTimezone. Timezone is a convenient and communicative name--but it may unfortunately already be taken by some class belonging to some other date/time library (VisualWorks has the class TimeZone in its standard library, which doesn't actually collide with Timezone, but it's a very near miss). Timezone (ChronosTimezone) and the VisualWorks TimeZone class are completely incompatible.  		SystemClock is the current canonical ChronosSystemClock instance (which see.)		ScaledDecimal is the name of the protocol specified and required by the ANSI-Smalltalk Standard for implementing scaled decimal values.  Unfortunately, the Standard fails to define the &lt;ScaledDecimalFactory&gt; protocol, and also fails to require that there be any particular "standard global" by which the factory object for creating instances of the &lt;ScaledDecimal&gt; protocol can be referenced.  Consequently, since Chronos needs to create scaled decimal values, if ScaledDecimal is not already defined as a global, Chronos will define ScaledDecimal as a global whose value is whatever native class implements scaled decimals (under the assumption that the existing global, if defined, in fact references the class that implements scaled decimals for the native Smalltalk environment.)  Note, however, that the instance creation protocol for scaled decimal values is not specified by the ANSI-Smalltalk Standard, and so Chronos uses the instance creation protocol defined by VisualWorks.  To port to other Smalltalk implementations, the recommended approach is to add VW compatibility methods to the ScaledDecimal class (if necessary.)		Clients of Chronos (or of any other ANSI-compliant date/time library) who desire to create date/time instances in a way that conforms to the ANSI Smalltalk Standard should use the global name DateAndTime to refer to whatever factory object they wish to use to create ANSI-standard-compliant timepoints, using ANSI-standard instance creation protocol.  Clients of Chronos (or of any other ANSI-compliant date/time library) who desire to create duration instances in a way that conforms to the ANSI Smalltalk Standard should use the global name Duration to refer to whatever factory object they wish to use to create ANSI-standard-compliant time durations, using ANSI-standard instance creation protocol.  Changing the implementation class then becomes a matter of either reassigning the value of the names DateAndTime and/or Duration in the namespace used when the code was compiled, or else recompiling the code using a different namespace (or shared pool Dictionary.)		To handle situations where there are multiple classes that implement the ANSI &lt;DateAndTime&gt;, &lt;DateAndTimeFactory&gt;, &lt;Duration&gt;  and &lt;DurationFactory&gt; protocols, it is suggested that all such classes should either be named something other than DateAndTime and Duration, or else they should all be resident in namespaces specific to the date/time library of which they are a part. In the case of Smalltalk systems that don't have good tool support for multiple namespaces wherein classes can natively reside,  shared-pool Dictionaries should be used to define DateAndTime and Duration as aliases. This strategy permits the clients of date/time libraries to decide for themselves, independently of other modules in the same image, and if necessary on a class-by-class basis, which date/time library they would like to use, and which classes will be referenced by the names DateAndTime and Duration. It also permits such decisions to be changed without actually modifying any source code.		The Chronos codebase itself always uses the alias DateAndTimeFactory in order to create instances of Timepoint, and always uses the alias DurationFactory to create instances of ScientificDuration--unless 'self new', 'self class new' or 'self copy' can be used instead.  In addition to aiding in the avoidance of name collisions, this strategy also enables changing the behavior of the Chronos codebase, so that (when and as desired) it will uniformly use classes other than Timepoint and/or ScientificDuration as the canonical DateAndTime and Duration implementations--without needing to actually modify any Chronos source code.		Finally, the ChronosEnvironment singleton is responsibible for purging any entries from the "Undeclared" namespace that may remain after Chronos has been "filed in to" (or otherwise installed in) an image, for specifying the concrete subclass of ChronosSystemFacade that should be instantiated during the installation of Chronos, and for performing the "post file-in/installation" initialization of the Chronos date/time library.	Usage:		The ChronosEnvironment singleton is intended solely for the private, internal usage of the Chronos date/time library.  Normally, it would only be used during the installation of Chronos.  However, it might also need to be used pursuant to significant modifications of the Chronos codebase that occur after Chronos has already been installed.  Also, anyone porting Chronos to a new environment may need to understand the intended usage of the ChronosEnvironment class and its singleton.		The class ChronosEnvironment, and the concrete subclass specific to a particular environment into which Chronos will be installed, must be "loaded" or "filed in" before any other modules (or "packages") of the Chronos codebase.  On installation, the method ChronosEnvironment class&gt;&gt;initialize must be invoked.  Most Smalltalk implementations will automatically invoke the #initialize method of a class when it is first "filed in" (or otherwise installed from a persistent external source.) 		In response to the message #initialize, the ChronosEnvironment class will perform the following operations:			1) Determine the concrete subclass of ChronosEnvironment that is appropriate to the environment in which it finds itself ("set the platform class."). 				The implementation strategy is as follows: 				1. There is a completely different "ChronosEnvironment" module defined for each platform, which may contain one or more subclasses of ChronosEnvironment. If the module contains multiple subclasses of ChronosEnvironment, then each such subclass is implemented for some range of versions of that particular Smalltalk environment (e.g., VisualWorks 3.x, VisualWorks 5i.x, etc.)				2. The procedure for setting the platform class begins when the message #setPlatformClass is sent to ChronosEnvironment (the class itself, not an instance.) The class method &lt;ChronosEnvironment class&gt;&gt;setPlatformClass&gt; simply sends the message #setPlatformClass to the first subclass of ChronosEnvironment that is enumerated by sending #do: to &lt;ChronosEnvironment subclasses&gt; (so all direct subclasses of ChronosEnvironment must subimplement #setPlatformClass as a class method.)  This strategy makes ChronosEnvironment itself depend only on the invariant that its direct subclasses are all platform/environment specific, but not depend in any way on the platform or environment on/in which it may find itself.  				3. Any direct subclass of ChronosEnvironment must, in response to the message #setPlatformClass, select the appropriate "Chronos Environment" class (perhaps itself) as the platform class. The selection of the platform class must of course depend on which version of the platform/environment is detected.  The class selected as the platform class must then be set as the value of the class variable PlatformClass. 				The strategy also avoids any necessity to install "foreign" subclasses of ChronosEnvironment, meant for other platforms, that would never be used (some of which would probably not even be compilable in some cases.) 			2) Define the namespaces used by Chronos. 				Namespace definition is the responsibility of the ChronosEnvironment class itself, and not the responsibility of its instance. The ChronosEnvironment platform class will define the Chronos namespaces when sent the message #defineChronosNamespaces.  See the Implementation section of the class comment for a discussion of namespace implementation on various platforms.			3) Define (as constants, if possible) the bindings (key to value associations) that should reside in each of the Chronos namespaces (or in the global namespace.) 				The initial phase of defining the Chronos constant bindings will be performed when the message #defineChronosSharedAndGlobalVariables is sent to the ChronosEnvironment platform class. During this phase of Chronos installation/initialization, the value of the bindings in the Chronos namespaces must in many cases be set to nil, because the code needed to instantiate the canonical value of the binding may either not yet be installed, or else may not yet be ready to be successfully invoked.  Assigning the canonical values to any Chronos constants that cannot be set during this initial phase of Chronos installation/initialization is deferred to a later step in the installation/initialization process, and is the responsibility of the singleton instance of the ChronosEnvironment platform class. 				The reason that all the Chronos constant bindings are defined during this phase, even when the canonical value of the binding may not yet be instantiable, is to guarantee that, when the rest of the Chronos codebase is "filed in" (or otherwise installed,) the binding's name will be correctly resolved to an entry in the correct Chronos namespace, and will not be resolved as an entry in some non-Chronos namespace (not a problem in modern VisualWorks, but the goal here is maximum inter-Smalltalk portability.)		Once the three steps listed above have been completed, the rest of the Chronos codebase may be "filed in" (or otherwise installed.)  		After the Chronos codebase has been successfully filed in (or otherwise installed,) Chronos must still be properly initialized.  One way to initiate the final Chronos initialization procedure is to file in the class ChronosInstaller, which is provided in a separate module.  ChronosInstaller defines #initialize as a class method, which should automatically be invoked when the class is filed in.  ChronosInstaller class&gt;&gt;initialize delegates all responsibility for the final phase of Chronos initialization to the ChronosEnvironment platform class: the method's only statement is 'ChronosEnvirionment install.' The bottom line is that the message #install must be sent to the class ChronosEnvironment before Chronos will work as intended.  Ensuring that that happens can be done in whatever way is most appropriate in context. 		In response to the #install message, ChronosEnvironment class sends the message #install to the singleton instance of the ChronosEnvironment platform class, which in response performs the following actions (in the order presented):			1) Assigns the canonical values to the bindings in the ChronosFactoryBindings namepace (or shared pool Dictionary);			2) Assigns the canonical values to the bindings in the ChronosCalendarConstants namepace (or shared pool Dictionary);			3) Assigns the canonical values to the bindings in the ChronosDurationConstants namepace (or shared pool Dictionary);			4) Assigns the canonical values to the global bindings for DateAndTime, Duration, Timezone and SystemClock (if and only if these variable names are not included in the 'protected variable names' Set--see the class method #setProtectedVariables);			5) Removes any bindings (associations) from the Undeclared namespace (Dictionary) for which there are no active references in the system codebase.			6) Installs the ChronosSystemFacade (by sending #installInitially to the ChronosSystemFacade singleton.)	Motivation:		The responsibility for defining global and/or "shared pool" bindings is assigned to a ChronosEnvironment instance for four reasons: 			1) Chronos uses a large number of "shared pool" values.  No other class clearly owns the responsibility for constructing such "shared pools" (or namespaces, to use a more generic term.)  Nor is there any non-proprietary standard syntax or construct for defining and loading global and/or "shared pool" variables. 			2) The code and/or syntax for defining global and/or "shared pool" bindings is not portable accross all Smalltalk implementations--a problem that is especially acute when one would like to use namespace-like functionality (where such is available) to avoid global name collisions, and when one would prefer that the name-to-value binding be immutable (if possible). By concentrating all system-specific code in the class hierarchies of ResourcePathFacade, ChronosSystemFacade, ChronosSystemClock and ChronosEnvironment, and by defining a standard API for the definition and initialization of the namespaces and globals needed by Chronos, ChronosEnvironment enhances the portability of the codebase of the Chronos date/time library, both with respect to different implementations/versions of Smalltalk and also with respect to the varying needs and preferences of applications (or code libraries) that use Chronos.			3) Encapsulating the responsibility for both defining a global and/or "shared pool" binding, and initializing each binding to its appropriate value, enables and/or facilitates the requisite degree of control over the sequencing of the following procedural steps: the definition of the binding,  the loading of the code required to instantiate the value that should be assigned to the binding, and the initialization of the binding to its canonical value. 			4) Ideally, porting Chronos to a new Smalltalk implementation (or in some cases, to a new version of a Smalltalk implementation) should require nothing more than writing a new subclass of a) ChronosEnvironment, b) ChronosSystemFacade, c) ResourcePathFacade and d) ChronosSystemClock. In reality, it will probably also be necessary to add (or reuse) inter-system compatibility methods in some classes of the host Smalltalk system's base library. Examples thereof might include methods such as #readStream and #writeStream in SequenceableCollection (or its equivalent(s)), and perhaps one or more utility methods in Stream. Finally, although the ANSI standard requires the existence of a class for scaled decimals, it very unfortunately does not specify the name of the class, nor the protocol for a scaled decimal factory.  Chronos assumes that the global that references the factory object for scaled decimal values is named ScaledDecimal, and that it conforms to the instance creation protocol defined by the VisualWorks FixedPoint class. If the native Smalltalk environment does not use the global name ScaledDecimal to reference the factory object for scaled decimal values, then the method ChronosEnvironemnt&gt;&gt;nativeScaledDecimalClass must be subimplemented by the subclass of ChronosEnvironment that will be used in that environment.  If the scaled decimal factory object's instance creation protocol does not conform to that of the VisualWorks FixedPoint class, then VW compatibility methods must be added.		Modification of the Chronos codebase for the purpose of making Chronos work correctly on the Smalltalk platform to which it is being ported (other than as herein described,) is strongly not recommended. Instead, please notify the author of Chronos of the porting problem {send and e-mail to porting (at) chronos-st (dot) org} so that a general solution to the problem can be designed and incorporated into the mainline Chronos codebase. 		See also: ChronosSystemFacade, ResourcePathFacade, ChronosSystemClock	Implementation:		Smalltalk-80, as defined by the "Blue Book" (Smalltalk-80: The Language and its Implementation; by Adele Goldberg and David Robson; Addison-Wesley 1983; ISBN 0-201-11371-6,) serves as the best "common denominator" among all extant implementations of Smalltalk. Consequently, the base class ChronosEnvironment itself is implemented so that it should work as-is for any Smalltalk-80 ("Blue Book") compliant implementation of Smalltalk (although the methods ChronosEnvironment class&gt;&gt;setPlatformClass, ChronosEnvironment class&gt;&gt;systemFacadeClass and ChronosEnvironment&gt;&gt;purgeUnusedBindingsFromUndeclaredNamespace must always be subimplmented.)  Subclasses of ChronosEnvironmnent intended for use on Smalltalk platforms that have richer namespace facilities are encouraged to make optimal use of whatever namespace functionality may be available for that particular Smalltalk system. Particularly, the classes of the Chronos codebase should, when possible, be defined in an independent namespace named 'Chronos.'		Smalltalk-80 implements namespaces in three different ways: 1) The class SystemDictionary and its canonical instance, which is referenceable as the global binding "Smalltalk, " and which is used to store global values, especially classes; 2) "Class Pool" Dictionaries, which are used to define class variable bindings, and 3) "Shared Pool" Dictionaries, which are used to define non-global bindings to be shared among selected classess without regard to inheritance relationships.  Blue-Book Smalltalk-80 does not have sufficient system/tool support for defining the classes of the Chronos Date/Time Library in their own independent namespace.   However, "shared pool" Dictionaries will function quite adequately in the role of namespaces for the purpose of defining the constants and aliases used by Chronos.		If not subclassed, or if the methods of ChronosEnvironment class that define the Chronos namespaces are not subimplemented, then ChronosEnvironment class will define a namespace as a "shared pool" Dictionary. Also, if the method ChronosEnvironment class&gt;&gt;defineChronosNamespace is not subimplemented, then ChronosEnvironment class will not attempt to define the namespace 'Chronos' for the purpose of defining the classes of the Chronos codebase in their own independent namespace. (The namespace 'Chronos' should be defined/used only if there is sufficient system/tool support for defining, browsing and editing classes in multiple, independent namespaces.) The default implementation provided by ChronosEnvironment itself is appropriate in cases where a) the host Smalltalk system supports "shared pool" Dictionaries, and b) there is insufficient system/tool support for any better implementation approach.	Subclassing:		Subclasses must subimplment the class methods ChronosEnvironment class&gt;&gt;setPlatformClass and ChronosEnvironment class&gt;&gt;systemFacadeClass, and also the instance method ChronosEnvironment&gt;&gt;purgeUnusedBindingsFromUndeclaredNamespace. The method comments fully specify the required behavior (as does this class comment in the text above.)		Subclasses may need to subimplement the instance method #nativeScaledDecimalClass (as explained above.)		The method ChronosEnvrionment&gt;&gt;defineVariable:in:withValue:constant:category:rebindIfPresent:onCollision: should be subimplemented if doing so would add value to the default implementation provided by ChronosEnvironment itself (which just uses #at:put: to add an entry to a namespace (or Dicitionary, as the case may be.)) For example, protocol and/or syntax may be available to make the binding constant (immutable,) and/or to classify the binding in a category (the latter has no effect on the behavior of Chronos, but when the system/tools provide support for organizing elements by category, it's best to avoid having elements show up in the 'As yet unspecified' category.)		Subclasses specific to a Smalltalk system that provides robust support for multiple, independent namespaces (such that classes can be defined in multiple namespaces, with sufficient system/tool support for defining, browsing and editing such classes) are strongly encouraged to subimplement the following methods so that optimal use is made of the host Smalltalk system's namespace functionality (the method comments fully specify the required behavior):			ChronosEnvironment class&gt;&gt;chronosNamespace						ChronosEnvironment class&gt;&gt;chronosNamespaceName					ChronosEnvironment class&gt;&gt;addImport:in:private:			ChronosEnvironment class&gt;&gt;defineChronosCalendarConstantsNamespace			ChronosEnvironment class&gt;&gt;defineChronosConstantsNamespace			ChronosEnvironment class&gt;&gt;defineChronosConstantsNamespaceImports			ChronosEnvironment class&gt;&gt;defineChronosDaysOfWeekConstantsNamespace			ChronosEnvironment class&gt;&gt;defineChronosDurationConstantsNamespace			ChronosEnvironment class&gt;&gt;defineChronosFactoryBindingsNamespace			ChronosEnvironment class&gt;&gt;defineChronosNamespace			ChronosEnvironment class&gt;&gt;defineChronosStandardMonthConstantsNamespace			ChronosEnvironment class&gt;&gt;defineChronosTemporalRatioConstantsNamespace					</body></comment><class><name>ClassicVWChronosEnvironment</name><environment>Chronos</environment><super>Chronos.ChronosEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Environment</category><attributes><package>Chronos-Environment-VW</package></attributes></class><comment><class-id>Chronos.ClassicVWChronosEnvironment</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ClassicVWChronosEnvironment	Concept:		ClassicVWChronosEnvironment is a concrete implementation of ChronosEnvironment specific to versions of VisualWorks Smalltalk that DO NOT support Namespaces (any version prior to  5i.0.)			See the class comment of ChronosEnvironment for more information.</body></comment><class><name>IntraYearTimeZoneTransitionFactory</name><environment>Chronos</environment><super>Chronos.AnnuallyRecurringTZPolicyFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relativity transitionSecondsSinceStartOfDay </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-PolicyFactories-Annual</category><attributes><package>Chronos-TimeZones-PolicyFactories-Annual</package></attributes></class><comment><class-id>Chronos.IntraYearTimeZoneTransitionFactory</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})IntraYearTimeZoneTransitionFactory	Concept:		An IntraYearTimeZoneTransitionFactory is an abstract subclass of AnnuallyRecurringTZPolicyFactory.  An instance of a concrete subclass of IntraYearTimeZoneTransitionFactory functions as any but the last/final ruleform in the sequence of ruleforms that specifies the offset/abbreviation tuples that apply within the territorial domain of a time zone during every moment of a calendar year. The ruleform represented by an IntraYearTimeZoneTransitionFactory instance expires at some annually-recurring intra-year date and time (any of local time, local "standard time," or Universal Time may be used  to designate the moment of expiry of the predecessor ruleform and transition to the successor ruleform.) 		However, the purpose of an IntraYearTimeZoneTransitionFactory is not to actually itself provide time-zone behavior, but rather to serve as a factory for creating an IntraYearTimeZoneTransition instance.  Although it represents essentially the same information as an IntraYearTimeZoneTransition, its purpose and behavior are different. 		See the superclass AnnuallyRecurringTZPolicyFactory for more information.	Motivation:		Chronos represents offset/abbreviation transitions using annually-recurring dates, instead of following in the path of UNIX and using an exhaustive list of every transition specified as occurring at some absolute number of seconds since an epoch, for two independent reasons:			1. To minimize memory usage--enough said.			2. To make the representation of the moments of transition be independent of any particular timesale--in other words, to make them neutral with respect to leap seconds--a property which the source Olson time zone rules have, but the zic-generated binary time zone files do not..	Implementation:		Instance Variables  {Also see superclass}			relativity								&lt;Symbol&gt;	If relativity == #nominal, then the instance's moment of expiry/transition-to-successor is designated in local ("wall clock") time; if relativity == #standard,  then the instance's moment of expiry/transition-to-successor is designated in local "standard time" (without DST;) if relativity == #universal, then the instance's moment of expiry/transition-to-successor is designated in Universal Time.			transitionSecondsSinceStartOfDay 	&lt;Integer&gt;	The time of day, expressed as a number of seconds since the start of the day (0..86399,) when the ruleform represented by the instance expires and the transition to its successor (the &lt;nextLink&gt;) takes place. Specification/representation of the annually-recurring intra-year date on which the instance's ruleform expires is the responsibility of concrete subclasses.</body></comment><class><name>UntilAnnualDayOfYearTimeZoneTransitionFactory</name><environment>Chronos</environment><super>Chronos.IntraYearTimeZoneTransitionFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitionDayOfYear </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-PolicyFactories-Annual</category><attributes><package>Chronos-TimeZones-PolicyFactories-Annual</package></attributes></class><comment><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UntilAnnualDayOfYearTimeZoneTransitionFactory	Concept:		An UntilAnnualDayOfYearTimeZoneTransitionFactory is an IntraYearTimeZoneTransitionFactory that specifies its annually-recurring intra-year date of expiry and transition to a successor AnnuallyRecurringTZPolicyFactory using a day-of-year ordinal (first day of the year = 1.)		See the superclass IntraYearTimeZoneTransitionFactory for more information.	Motivation:		UntilAnnualDayOfYearTimeZoneTransitionFactory is intended to be used for offset/abbreviation transitions that happen only once, and aren't actually annually recurring events (although it is perfectly possible and valid to use one to specify an annually-recurring transition that happens on the same day of the year every year.) However, the Chronos Time Zone Compiler uses UntilAnnualDayOfYearTimeZoneTransitionFactories solely for "one time" transitions.  		Another possible reason to use UntilAnnualDayOfYearTimeZoneTransitionFactories would be in order to represent the contents of the binary time zone files used by UNIX (which are generted by the `zic` utility on UNIX that compiles Olson time zone rule specifications from their "source code" form into binary files used by the Standard C library on UNIX.)  The `zic` utility ('zic' = "zone information compiler") compiles time zone rules into a sequence of one-time offset/abbreviation transitions, where each transition is specified to occur at a particular time_t value (i.e., a specified number of seconds since 1970-01-01T00:00:00 UT; note that time_t values technically do not qualify as "UTC," because POSIX forbids UNIX from using leap seconds.) [Reference: http://www.gsp.com/cgi-bin/man.cgi?section=5&amp;topic=tzfile]	Implementation:		Instance Variables  {Also see superclass}			transitionDayOfYear	&lt;Integer&gt; The annually-recurring intra-year date, expressed as a day-of-year ordinal (first day = 1) when the ruleform represented by the instance expires and the transition to its successor takes place. Specification/representation of the time-of-day of expiry/transition is implemented by the superclass.</body></comment><class><name>ChronosLocale</name><environment>Chronos</environment><super>Passport.Registratable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>languageCode countryCode timeZoneLocalizationPolicy temporalPrintPolicy </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Localization</category><attributes><package>Chronos-Localization</package></attributes></class><comment><class-id>Chronos.ChronosLocale</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>DynamicCalendarDay</name><environment>Chronos</environment><super>Chronos.CalendarDay</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Irregular</category><attributes><package>Chronos-Calendars-Irregular</package></attributes></class><comment><class-id>Chronos.DynamicCalendarDay</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})DynamicCalendarDay	Concept:		A DynamicCalendarDay is a CalendarDay (which see) that is specialized for collaboration with a DynamicMonthlyCalendar (also which see.)	Usage:		As is the case with most Chronos classes, DynamicCalendarDay instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Motivation:		DynamicCalendarDay, in collaboration with DynamicMonthlyCalendar and DynamicYearlyCalendar, avoids the utilization of too much memory in the case of calendrical systems that have too many different year types to reasonably use the flyweight pattern for representing the month structure of each type of year.	Implementation:</body></comment><class><name>MillisecondSystemClock</name><environment>Chronos</environment><super>Chronos.ChronosSystemClock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System</package></attributes></class><comment><class-id>Chronos.MillisecondSystemClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})MillisecondSystemClock	Concept:		MillisecondSystemClock is an abstract subclass of ChronosSystemClock. It should be used as the superclass of any concrete ChronosSystemClock class that encapsulates a clock device whose resolution is one millisecond.  See the class comment of ChronosSystemClock for more information, including the defintion of the term 'resolution.' </body></comment><class><name>ConfigurableChronosLocale</name><environment>Chronos</environment><super>Chronos.ChronosLocale</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegate standardCalendarRegistrationKey semanticDatePolicyKey notationalPolicies characters properNames abbreviations singularNouns pluralNouns </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Localization</category><attributes><package>Chronos-Localization</package></attributes></class><comment><class-id>Chronos.ConfigurableChronosLocale</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>CalendarDuration</name><environment>Chronos</environment><super>Chronos.Durational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>years months days </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Duration</category><attributes><package>Chronos-Duration</package></attributes></class><comment><class-id>Chronos.CalendarDuration</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})CalendarDuration	Concept:		A CalendarDuration is a "temporal extent" or "duration of time" specified in terms of calendrical periods--years, months and days. A CalendarDuration differs both in its semantics and interface from an ANSI-Smalltalk Duration in important ways. Semantically, a CalendarDuration represents "civil," "legal," business" or "calendrical" time, as opposed to "scientific," "metric system" or "atomic" time (which is implemented by the other subclass of Durational, ScientificDuration.)  Also see CalendarDuration's subclass CivilDuration, which adds support for hours, minutes, seconds and nanoseconds.		Conceptually and mathematically, a CalendarDuration represents a duration vector with three elements: years, months and days. The number of years, months and days represented by a CalendarDuration are each independent of each other, and (unlike seconds and nanoseconds, for example) cannot be deterministically/universally translated from one to the other.  		Changing the number of days represented by a CalendarDuration will have no effect on its extent in months or years (and vice versa,) because each component is a separate and independent vector element.  CalendarDurations are so implemented because conversions among years, months and days are not uniform. Generally, there is no way to determine how many days make a month, nor how many months make a year, because a) Durational instances are agnostic with respect to any particular calendrical system,  b) months and years usually have more than one size in days, and c) years in some calendrical systems have more than one size in months (e.g, Hebrew, Chinese, Hindu.)		CalendarDuration semantics defines the duration of a day based on its civil or business interpretation, by which 'one day' means whatever number of hours, minutes or seconds are required to go from a particular civil time-of-day on day 0 to the same civil time-of-day on day 1.  Due to such things as leap seconds and Daylight Saving Time (also known as "Summer Time" in most places outside North America,) such "civil" or "calendar" days may have more or less than 86400 seconds (as the second is currently defined by SI, the international metric system.)		For more in depth conceptual discussion, see the class comment of Durational (the superclass.)	Usage:		Instances of CalendarDuration can be used as arithmetic operands with each other, and with instances of TemporalCoordinate (whose concrete subclasses include Timepoint, YearMonthDay and TimeOfDay--all of which see.) TemporalCoordinates can compute the temporal extent between any two instances, providing the result as a Durational instance. A Timeperiod specifies the temporal extent of the temporal inteveral it represents using a Durational instance. 		Key methods of Durational, CalendarDuration, CivilDuration and ScientificDuration have "do its" in their comments that provide usage examples.		Many of the methods of Durational and ScientificDuration (and some methods of CalendarDuration and CivilDuration) implement message signatures as specified and required by the ANSI-Smalltalk Standard.  As is true throughout the Chronos codebase, many of the others are implemented and/or named by analogy to those required by ANSI Smalltalk (i.e., in the same style and/or spirit--both in terms of naming conventions and semantics.)		As is the case with most Chronos classes, instances of CalendarDuration will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		Note that the instance creation messages (class messages) #days: and #seconds: (and many of the variations thereof) will correctly handle either integer or non-integer numeric arguments. 		CalendarDuration has instance creation methods that will instantiate instances of CivilDuration in cases where the semantics of the message require the representation of some non-zero number of hours, minutes or seconds.	Motivation:		The ANSI-Smalltalk standard requires that durational values be supported as a type distinct from that of point-in-time values.		Secondly, although in some contexts/situations it is both necessary and proper to represent a duration of time using a "raw" numeric value, it is usually superior to encapsulate a durational value in an object that knows the semantics and behavior of the represented temporal extent.  This avoids the possibility that raw numeric values will be misinterpreted as a number of seconds when they actually represent a number of days, hours or tenths of a microsecond.  Even better, it enables such values to collaborate with other objects with greater semantic precision, and in ways that can be made much more specific to the functional intent of the value.  It is much easier to define and understand the meaning of adding a durational value to a point-in-time value, than it would be to define or understand the meaning of adding a raw number (a number of what?).		Thirdly, the scientific/technical view of durations, as implemented by ScientificDuration, is not appropriate for most legal, business and religious use cases. Generally, outside of scientific/technical use, the ability to specifiy some combination of an invariant number of years, months and days--without regard to the number of seconds that may happen to elapse--is absolutely necessary. 	Implementation:		Conceptually, a CalendarDuration represents a temporal extent as a vector whose elements represent a number of 1) years, 2) months and 3) days. Physically, it uses a different instance variable for each element of the vector. 		Although the number of seconds/nanoseconds specified collectively by the instance variables 'seconds' and 'nanosecondsSinceSecond' are independent of the number of years, months or days represented by an instance, when an instance is in canonical form, the absolute value of the "seconds" element of its duration vector must not be greater than the number of seconds in a UT1 (mean solar) day (86400.) Therefore, when an instance canonicalizes itself, if the absolute number of seconds in the "seconds" element of its duration vector is greater than or equal 86400, it converts the overflow into days.		Instance Variables			days 		&lt;Integer&gt;				The number of days in the duration vector that represents the instance's temporal extent--this value is independent of the number of years, months or seconds represented by the instance.			months		&lt;Integer&gt; 				The number of months in the duration vector that represents the instance's temporal extent--this value is independent of the number of years, days or seconds represented by the instance.			years		&lt;Integer&gt; 				The number of years in the duration vector that represents the instance's temporal extent--this value is independent of the number of months, days or seconds represented by the instance.		Class Variables			Zero		&lt;CalendarDuration&gt;				A constant CalendarDuration that represents a temporal extent of zero.  Accessed by sending the message #zero to the class. The global ZeroCalendarDuration (defined in the namespace ChronosDurationConstants) serves as an alias of 'CalendarDuration zero'.</body></comment><class><name>CivilDuration</name><environment>Chronos</environment><super>Chronos.CalendarDuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds nanosecondsSinceSecond </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Duration</category><attributes><package>Chronos-Duration</package></attributes></class><comment><class-id>Chronos.CivilDuration</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})CivilDuration	Concept:		A CivilDuration is a "temporal extent" or "duration of time" specified in terms of both calendrical periods--years, months and days--and also in terms of hours, minutes and seconds (including fractions of a second.) A CivilDuration differs both in its semantics and interface from an ANSI-Smalltalk Duration in important ways. Semantically, a CivilDuration represents "civil," "legal," business" or "calendrical" time, as opposed to "scientific," "metric system" or "atomic" time (which is implemented by ScientificDuration.)  		Also see CivilDuration's superclass CalendarDuration, which provides the implementation of the "years, months, days" portion of a CivilDuration's behavior.		Conceptually and mathematically, a CivilDuration represents a duration vector with seven elements: years, months, days, hours, minutes, seconds and nanoseconds. The number of years, months and days are each independent of each other, and (unlike seconds and nanoseconds, for example) cannot be deterministically/universally translated from one to the other.  In contrast, nanoseconds and seconds are interconvertible by a factor of 1,000,000,000, seconds and minutes are interconvertible by a factor of 60, minutes and hours are interconvertible by a factor of 60, and hours and days are interconvertible by a factor of 24.  Although CivilDuration itself converts between seconds and minutes, seconds and hours and seconds and days using invariant conversion factors, other Chronos objects may use either different conversion factors, and/or may convert seconds into minutes, hours and days using occasional 'leap seconds' (and in the future, perhaps also leap minutes or leap hours.)		CivilDuration semantics defines the duration of days, hours, minutes and seconds based on their civil, legal or business semantics, by which 'one day' means whatever number of seconds are required to go from a particular civil time-of-day on day 0 to the same civil time-of-day on day 1, 'one hour' is the temporal extent between T23:00:00 and T24:00:00 (regardless of any leap seconds or leap minutes,) 'one minute' is the temporal extent between T23:59:00 and T24:00:00 (regardless of any leap seconds,) and 'one second' is the temporal extent between T23:59:59 and T24:00:00 (also regardless of any leap seconds.)  Due to such things as leap seconds such "civil" or "calendar" time extents may have more or less than the regular number of SI (metric system) seconds (as measured by an atomic clock.) There may be more or less than 24 metric system ("scientific") hours in a day, due to Daylight Saving Time transitions (Daylight Saving Time is known as "Summer Time" in most places outside North America,)		For more in depth conceptual discussion, see the class comments of CalendarDuration and Durational (the superclasses.)	Usage:		Instances of CivilDuration can be used as arithmetic operands with each other, and with instances of TemporalCoordinate (whose concrete subclasses include Timepoint, YearMonthDay and TimeOfDay--all of which see.) TemporalCoordinates can compute the temporal extent between any two instances, providing the result as a Durational instance. A Timeperiod specifies the temporal extent of the temporal inteveral it represents using a Durational instance. 	Implementation:		Conceptually, a CivilDuration represents a temporal extent as a vector whose elements represent a number of 1) years, 2) months, 3) days, 4) hours, 5) minutes and 6) seconds (including fractions of a second.) Physically, it uses a different instance variable for each element of the vector--except for the "seconds" element, where it uses two instance variables--one for the integer number of seconds, and one for the integer number of nanoseconds. Two instance variables are used for this purpose: 'seconds' and 'nanosecondsSinceSecond.' 		Although the number of seconds/nanoseconds specified collectively by the instance variables 'seconds' and 'nanosecondsSinceSecond' are independent of the number of years, months, days, hours and minutes represented by an instance, when an instance is in canonical form, the absolute value of the "nanoseconds" element in its duration vector must not be greater than or equal to 1,000,000,000, and the "seconds" element of its duration vector must not be greater than or equal to the number of seconds in a mean solar minute (i.e., must be less than 60.) Similarly, the number of minutes must be less than 60 and the number of hours must be less than 24. Therefore, when an instance canonicalizes itself, if any such vector element has a value greater than is canonical (or less,) the overflow (or underflow) is propagated upward, which may result in adding to or subtracting from the number of days (or hours, or minutes, etc.)		Instance Variables			hours 		&lt;Integer&gt;				The number of hours in the duration vector that represents the instance's temporal extent. When the instance is in canonical form, the value of &lt;hours&gt; must be positive or zero if the value of &lt;days&gt; is positive, and must be negative or zero if the value of &lt;days&gt; is negative--and the absolute value of &lt;hours&gt; must be less than the number of hours in a day (HoursPerDay = 24)			minutes		&lt;Integer&gt; 				The number of minutes in the duration vector that represents the instance's temporal extent. When the instance is in canonical form, the value of &lt;minutes&gt; must be positive or zero if the value of &lt;hours&gt; is positive, and must be negative or zero if the value of &lt;hours&gt; is negative--and the absolute value of &lt;minutes&gt; must be less than the number of minutes in an hour (MinutesPerHour = 60)			seconds 					&lt;Integer&gt;				The integer part of the "seconds" element of the instance's duration vector. When the instance is in canonical form, the value of &lt;seconds&gt; must be positive or zero if the value of &lt;minutes&gt; is positive, and must be negative or zero if the value of &lt;minutes&gt; is negative--and the absolute value of &lt;seconds&gt; must be less than the number of seconds in a minute (SecondsPerMinute = 60)			nanosecondsSinceSecond	&lt;Integer&gt;				Represents, as an integer number of nanoseconds, the fractional part of the "seconds" element of the instance's duration vector. When the instance is in canonical form, the value of &lt;nanosecondsSinceSecond&gt; must be positive or zero if the value of &lt;seconds&gt; is positive, and must be negative or zero if the value of &lt;seconds&gt; is negative--and the absolute value of &lt;nanosecondsSinceSecond&gt; must be less than the number of nanoseconds in a second (NanosecondsPerSecond = 1,000,000,000.)		</body></comment><class><name>VWv5iSystemFacade</name><environment>Chronos</environment><super>Chronos.VWSystemFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System-VW</package></attributes></class><comment><class-id>Chronos.VWv5iSystemFacade</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})VWv5iSystemFacade is a concrete implementation of ChronosSystemFacade specific to VisualWorks Smalltalk versions 5i.0 to 5i.4 (NC or otherwise.)  See the class comment of ChronosSystemFacade for more information.</body></comment><class><name>VWClassicSystemFacade</name><environment>Chronos</environment><super>Chronos.VWv5iSystemFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System-VW</package></attributes></class><comment><class-id>Chronos.VWClassicSystemFacade</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})VWv3xSystemFacade is a concrete implementation of ChronosSystemFacade specific to VisualWorks Smalltalk versions 3.0 and 3.1 (NC or otherwise.)  See the class comment of ChronosSystemFacade for more information.</body></comment><class><name>VWv7xSystemClock</name><environment>Chronos</environment><super>Chronos.MicrosecondSystemClock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System-VisualWorks</category><attributes><package>Chronos-System-VW</package></attributes></class><comment><class-id>Chronos.VWv7xSystemClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})VWv7xSystemClock	Concept:		An instance of VWv7xSystemClock encapsulates the system clock provided by the object engine ("virtual machine") of VisualWorks Smalltalk, version 7x or later.  For more information (including the definitions of terms,) see the class comment of ChronosSystemClock and MicrosecondSystemClock.	Implementation:		This implementation is specific to versions of VisualWorks Smalltalk where the system clock provided by the VW object engine a) has a resolution of 1 microsecond, b) reports time relative to UTC on all platforms, and c) is accessible using primitive 351.  Prior to VisualWorks version 7, the VW object engine's system clock had a resolution of 1 second, reported time relative to UT on most platforms, but relative to local time on Windows and MacOS (pre OSX,) and was accessed using primitive 98.  According to the Blue Book, the original Xerox Smalltalk-80 (of which VisualWorks is a direct descendant) used a system clock that reported the time in seconds relative to UT. </body></comment><class><name>VariableOffsetTimezone</name><environment>Chronos</environment><super>Chronos.ChronosTimezone</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaceKey key policy </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.VariableOffsetTimezone</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})VariableOffsetTimezone	Concept:		A VariableOffsetTimezone iimplements "unbound, dynamic" time zones.  A "bound" Chronos time zone is one whose single, specific offset-abbreviation tuple is or can be "bound to" (properly associated with) a specific point-in-time.  An "unbound" Chronos time zone is one that does NOT specify a single, specific offset and abbreviation that can be "bound to" (properly associated with) a specific point-in-time. A "static" Chronos time zone is one whose offset-abbreviation tuple is not subject to retroactive changes--for a static time zone, the binding of a point-in-time value to the offset-abbreviation tuple of its time zone is permanent for all time. A "dynamic" Chronos time zone is one whose offset-abbreviation tuple (or tuples) is subject to retroactive changes--for a dynamic time zone, the binding of a point-in-time value to the offset-abbreviation tuple currently specified by its time zone is not necessarily permanent.		Although it may not in fact do so, a VariableOffsetTimezone is intended to represent the full diachronic history of the timezone rules for a particular location, such as New York, New York {Timezone at: 'America/New_York'}, Davos, Switzerland {Timezone at: 'Europe/Zurich'} or Ulaan Bator, Mongolia {Timezone at: 'Asia/Ulaanbaatar'}.  A VariableOffsetTimezone will normally have at least two offsets from Universal Time, and at least two abbreviations.  Most will have more.  So you can't just ask a VariableOffsetTimezone for its offset from Universal Time--it almost certainly has more than one (and even if it did have only one, the fact that its ruleset is subject to retroactive change would still require that it be not treated as equivalent to either a "bound" or a "static" timezone.) 		See the class comment of ChronosTimezone for more in depth conceptual information about time zones, and for more information about the general characteristics and API of all Chronos time zones.	Usage:		A VariableOffsetTimezone conforms to and directly reimplements the Chronos "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.) 		## KEYS; IDENTITY; LOOKUP			Usually, VariableOffsetTimezones are uniquely identified by well-known, globally-defined keys and their rulesets are persistently stored in an external repository. However, it is also possible to create ad-hoc/transient instances of VariableOffsetTimezone whose keys are not globally well-known and/or whose rulesets are not persistently stored externally. However, since it is not possible to authoritatively determine whether the key of a VariableOffsetTimezone is in fact a globally well-known value, Chronos simply assumes that the key of any VariableOffsetTimezone stored in the peristent, external time zone repository is globally well known [for Chronos as delivered by the author, this assumption is valid--but it is possible for clients of Chronos to define and add their own time zone ruleset definitions, identified by keys of their choice,  to the Chronos time zones repository--although how to do this is currently not documented, and parhaps won't ever be unless it's requested.]  			The key of a VariableOffsetTimezone is a Symbol.  As delivered by the author, all persistently-stored, globally-well-known VariableOffsetTimezones (and their keys) are as defined by the Olson Timezone Database (the same one used by UNIX.) The Olson time zone keys usually (but not always) have the form &lt;continent&gt;/&lt;city&gt; or &lt;ocean&gt;/&lt;city&gt;, such as 'Europe/London', 'Asia/Calcutta' or 'Pacific/Auckland'. However, as previously mentioned, clients of Chronos are allowed to define their own variable-offset time zones having any desired key--which do not have to be globally well known, and do not have to be persistently stored in the Chronos time-zones repository. 			Note: The canonical key of the timezone whose proper name is Universal Time is #Universal.  However, a variety of aliases are supported: #'Universal Time', #UT, #UTC, #GMT, #Z and #Zulu. Although some of the same keys are defined (and in some cases, used without any definition) in the Olson Time Zone databse, Chronos ignores and does not use the Olson definition of Unversal Time.  The ChronosTimezone that implements Universal Time is the canonical instance of the class UniversalTime--it's not a VariableOffsetTimezone (although that could be done, it's neither necessary nor desirable--using atom bombs to swat flys should be avoided whenever possible.)			In some circumstances, ad-hoc/transient VariableOffsetTimezones may be created by the current ChronosSystemFacade to represent/model/emulate the base system's local time zone.  The key of such a VariableOffsetTimezone created by the ChronosSystemFacade will be the Symbol #system.  The key #system may not even be unique within an image, let alone globally. For the precise behavior in the current Smalltalk environment and system platform, see ChronosSystemFacade and its subclass that implements the current ChronosSystemFacade singleton--the details may well vary by environment/platform.			To retrieve a VariableOffsetTimezone by its key, use either the class message #at: or #at:ifAbsent:, with the time zone key as the first argument--the key may be either a Symbol or a String (e.g., {VariableOffsetTimezone at: 'Europe/Berlin'}.)			To retrieve the keys of all the time zones resident in Chronos' repository of persistently-stored time zones, inspect the result of evaluating 'ChronosTimezone allRegisteredKeys' (if there are none, then the Chronos Time Zone Repository is missing, and should be obtained from the Chronos web site and installed according to the instructions (http://www.chronos-st.org/).)			To see the current time in all the time zones resident in Chronos' repository of persistently-stored time zones, (showing the key, current offset, and current abbreviation for each time zone,) inspect the result of evaluating 'Timepoint nowInAllTimeZones' (if there are no entries, then the Chronos Time Zone Repository is missing, and should be obtained from the Chronos web site and installed according to the instructions (http://www.chronos-st.org/).)		## USEFUL 'DO ITS' FOR MANUALLY SETTING THE SYSTEM/DEFAULT TIMEZONE			Also see the "Usage:" section of the class comment of ChronosTimezone for an explanation of the terms 'system timezone' and 'default timezone.'																						POSIX Rule Literal			(Timezone at: #'America/Puerto_Rico') beSystem					"AST4"			(Timezone at: #'America/New_York') beSystem					"EST5EDT4"			(Timezone at: #'America/Indiana/Indianapolis') beSystem		"EST4"			(Timezone at: #'America/Indiana/Knox') beSystem				"EST4"				(Timezone at: #'America/Indiana/Marengo') beSystem			"EST4"			(Timezone at: #'America/Indiana/Vevay') beSystem				"EST4"			(Timezone at: #'America/Chicago') beSystem						"CST6CDT5"			(Timezone at: #'America/Boise') beSystem							"MST7MDT6"			(Timezone at: #'America/Denver') beSystem						"MST7MDT6"			(Timezone at: #'America/Phoenix') beSystem						"MST7"			(Timezone at: #'America/Los_Angeles') beSystem				"PST8PDT7"			(Timezone at: #'America/Anchorage') beSystem					"AKST9AKDT8"			(Timezone at: #'America/Juneau') beSystem						"AKST9AKDT8"			(Timezone at: #'America/Nome') beSystem							"AKST9AKDT8"			(Timezone at: #'America/Adak') beSystem							"HAST10HADT9"			(Timezone at: #'Pacific/Honolulu') beSystem						"HAST10"			Timezone system beDefault	"Ensures that 'Timezone system == Timezone default' will still be true even after the system time zone is changed."					## RETRIEVING TIMEZONE OFFSETS FROM UT (UNIVERSAL TIME)			In order to retrieve the offset and/or abbreviation that is correct for the territorial domain of an instance of VariableOffsetTimezone at a particular point-in-time one must use the unbound ChronosTimezone API to resolve a "bound" ChronosTimezone with the correct offset and abbreviation for a given point-in-time, and retrieve the offset and/or abbreviation from the "bound" timezone so obtained. The bound time zone that results will be an instance of StandardTime if "standard time" is in effect at the point-in-time specified in the search parameters, but an instance of NonStandardTime otherwise.			The search parameters needed to resolve a bound timezone are the year, day-of-year and seconds-since-start-of-day. They can be specified either as UT values or as local time ("wall clock") values.  The message signatures for resolving a bound timezone are as follows:				#bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:		"Uses local-time search parameters"				#bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:		"Uses Universal Time search parameters"			The final parameter value (following "secondsSinceStartOfDayFunction:") is a one-argument block.  If the seconds-since-start-of-day value is needed to find the correct bound timezone, this block will be invoked (as a 'call-back') with an argument whose value is the offset from UT in seconds for a particular bound timezone (representing a particular set of zone properties in effect during a particular period of time.)  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary (the answered seconds-since-start-of-day should be in Universal Time if the message #bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction: was sent, but in local ("wall clock") time if the message #bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction: was sent.)  The reason for the callback block is that, during some years, a timezone may have more than one 'standard time' offset from UT, and because the offset transition rules for the same timezone for the same year can be specified as UT values for the first transition, local "wall clock" time for the second transition, but as local standard time for the third transition (yes, all that stuff actually happens--timezones are NOT simple!)			Instances of both StandardTime and NonStandardTime are "bound, dynamic" time zones (in the Chronos ontology of time zones.) Both will respond to the message #asUnbound by answering the "unbound, dynamic" time zone instance that defines the complete diachronic ruleset of the time-zone identified by their time zone key. A VariableOffsetTimezone instance (or any "unbound" Chronos time zone object) responds to the message #asUnbound with itself.			Note: Most of the same information is presented near the end of the "Usage:" section of the class comment of ChronosTimezone--including eample "do its" that illustrate actual usage.	Motivation:		Real-world timezones are never invariant.  They always change over time: they change their abbreviations, their standard-time offsets from Universal Time, their DST offset deltas from standard time, and of course the dates and times when they transition to and or from DST. They can change any of these attributes any number of times during the year.  This is NOT theoretical--it's real, it happens, and a library and/or application that is serious about time has to deal with it.  UNIX does--and has been doing so for decades.		Timezone rules and attributes are a political matter.  Legislatures, bureaucrats or other officials can and do set and change the timezone rules in their jurisdictions whenever they so please.  Perhaps a war prompts Congress to decree that the United States will transition to Daylight Saving Time and stay there until the war ends (World Wars I and II, for example.)  Perhaps the good people of Phoenix strongly prefer to use standard time all year round--except in 1967, when a change to Federal law forced them to observe DST for that year, until their State Legislature could pass the necessary law to get rid of the unpopular DST.  Welcome to the real world of timezones.		If you only care about one point-in-time value (and don't have to deal with times in the future where the time zone rules might change before the future point-in-time you've designated transitions from future to past,) then a single offset from Universal Time is sufficient.  But if you want to compute new points-in-time using date/time arithmetic, then you have to deal with the fact that the offset of such computed points-in-time is undecidable in the absence of an unambiguous specification of which timezone ruleset should be used to determine the Universal Time offset of the computed timepoint.  Unambigously specifying the complete timezone ruleset in effect for a particular region, diachronically for all time, is what a VariableOffsetTimezone does (or at least enables.)	Implementation:		See TimeZonePolicy for information regarding the actual mechanisms by which a VariableOffsetTimezone implements and represents diachronic time zone rulesets.		## INSTANCE REGISTRATION IN THE CACHE			VariableOffsetTimezone maintains a cache of its instances. An instance will be registered in the cache when sent the message #register, provided the following conditions are satisfied: 1) the instance's key is not nil, 2) the instance's key is not the value #system, and 3) the instance has a non-nil TimeZonePolicy. Although it is not required that all instances be in the cache, all instances that are made immutable will be sent the message #register.  Instances deserialized from the external time-zones repository are always made immutable.  The cache is supposed to be a WeakDictionary, but what it actually is depends upon the current ChronosSystemFacade (see the implementation of the method #newWeakDictionary that is either implemented or inherited by the class of the current ChronosSystemFacade singleton.)		Instance Variables			key			&lt;Symbol&gt;	The key that identifies the time zone represented by the instance. If and only if it's the key of an Olson time zone (or it it's otherwise a universally well-known key,) it must be universally unique. Unless it's the special value #system, it must be unique within an image (or within an OS process, if the Smalltalk environment is not image based.)			policy 		&lt;TimeZonePolicy&gt;	The TimeZonePolicy that specifies the ruleset of the time zone represented by the instance.  The ruleset of a time zone specifies for all time values, from the infinite past to the infinite future, the (possibly varying) time zone offsets and abbreviations that apply to points-in-time within the territorial domain of the time zone. Note, however, that the "policy" (time zone ruleset) can be changed retroactively--and this is rather likely to happen for times in the future (but can also happen to times in the past.)		Class Variables			Registry 	&lt;WeakDictionary&gt; Cache of VariableOffsetTimezones that have been instantiated in the image. Instances are usually (but not always) registerd in this cache.  </body></comment><class><name>DateAndTimeSpec</name><environment>Chronos</environment><super>Chronos.DateSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hour minute second nanosecondsSinceSecond </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.DateAndTimeSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>MonthOfYear</name><environment>Chronos</environment><super>Chronos.CalendricalAnnualDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>monthKey monthOrdinal minDayOfYearOrdinal maxDayOfYearOrdinal </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.MonthOfYear</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>WeekOfMonthDayOfWeek</name><environment>Chronos</environment><super>Chronos.MonthOfYear</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dayOfWeekOrdinal minDayOfMonthCardinal maxDayOfMonthCardinal daysOffset </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.WeekOfMonthDayOfWeek</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>VWChronosEnvironment</name><environment>Chronos</environment><super>Chronos.ClassicVWChronosEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Environment-VisualWorks</category><attributes><package>Chronos-Environment-VW</package></attributes></class><comment><class-id>Chronos.VWChronosEnvironment</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})VWChronosEnvironment	Concept:		VWChronosEnvironment is a concrete implementation of ChronosEnvironment specific to versions of VisualWorks Smalltalk that support Namespaces (any version greater than or equal to 5i.0.)			See the class comment of ChronosEnvironment for more information.</body></comment><class><name>ExternalResourceRepository</name><environment>Passport</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultBroker references aliases </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ExternalResourceRepository</class-id><body></body></comment><class><name>EthiopicCalendar</name><environment>Chronos</environment><super>Chronos.CopticCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.EthiopicCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})EthiopicCalendar	Concept:		EthiopicCalendar implements the Ethiopic Calendar.  The Ethiopic Calendar  is the principal calendar used in Ethiopia. The Ethiopic Calendar is derived from the ancient Egyptian solar calendar, but unlike that calendar, uses leap years to more accurately reflect the length of the solar year. It has the same leap year rule, month structure and New Year's Day as the Coptic Calendar, but has a different epoch year. Culturally, the usage of the Ethiopian Calendar in Ethiopia is strongly motivated by Ethiopia's main religions, the Coptic Church and the Ethiopian Orthodox Tewahido Church.		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Ethiopic Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Ethiopic Calendar is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		Epoch Date			The epoch date of the Ethiopic Calendar, 0001-01-01 [Ethiopic], corresponds to 0008-08-27 [Gregorian] and to 0008-08-29 [Julian].  Ethiopic days begin at sunrise. The Julian Date of the Ethiopic epoch is 1,724,220.75 (6 am,) so the actual initial moment of the Ethiopic epoch corresponds to 0008-08-27T06:00:00 [Gregorian] and to 0008-08-29T06:00:00 [Julian]. 				The Ethiopic epoch date is the first day of the year in the ancient Egyptian Calendar after which Christ was born by the reckoning of the Ethiopian Orthodox Christian Church.			Years on or after the epoch of the Ethiopic Calendar are said to be in the era "Zemene Haddis" (ZH)--which is Ethiopian for "Incarnation Era"  Alternatively, this era is also called "Amete Mihret" (AM)--which is Ethiopian for "years of mercy".  Chronos does not use "AM" in connection with the Ethiopic Calendar in order to avoid confusion with both "Anno Mundi" and "Anno Martyrum."  Years before the epoch are said to be in the era "Zemene Bluy" (ZB)--which is the Ethiopian equivalent of "Before Christ."		Time-of-Day Clock			Sunrise (6 am) is both the zero-point of the time-of-day clock and also the initial moment of the day. 			{EthiopicCalendar clock today asGregorian}			{EthiopicCalendar clock now}		Year Numbering Policy			The Ethiopic Calendar uses "zeroless ordinal" year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year -1.		Leap Year Rule			A year is a leap year if dividing the year ordinal by 4 leaves a remainder of 3.		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: Maskaram				30/30			2: Teqemt					30/30			3: Khedar					30/30			4: Takhsas					30/30			5: Ter						30/30			6: Yakatit					30/30			7: Magabit					30/30			8: Miyazya					30/30			9: Genbot					30/30			10: Sane					30/30			11: Hamle					30/30			12: Nahase					30/30			13: Paguemen				5/6			Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name (as given here.)</body></comment><class><name>UTCalendarClock</name><environment>Chronos</environment><super>Chronos.CalendarClock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.UTCalendarClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UTCalendarClock	Concept:		A UTCalendarClock is CalendarClock (which see) specialized for encapsulating a ChronosSystemClock that reports time relative to the UT timezone.</body></comment><class><name>VWAbstractFileUrlFacade</name><environment>Passport</environment><super>Passport.VWUrlPathFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWAbstractFileUrlFacade</class-id><body></body></comment><class><name>ISO8601PrintPolicy</name><environment>Chronos</environment><super>Chronos.ChronosPrintPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Printing</category><attributes><package>Chronos-Printing</package></attributes></class><comment><class-id>Chronos.ISO8601PrintPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>SemanticDatePolicy</name><environment>Chronos</environment><super>Passport.Registratable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>effectiveYearCalendar dayOfWeekSemanticKeys semanticAnnualDates semanticUniqueDates </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Semantic Dates</category><attributes><package>Chronos-Semantic Dates</package></attributes></class><comment><class-id>Chronos.SemanticDatePolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>ReversibleTransformer</name><environment>Passport</environment><super>Passport.Immutable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ReversibleTransformer</class-id><body>	</body></comment><class><name>VWHttpsUrlFacade</name><environment>Passport</environment><super>Passport.VWHttpUrlFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWHttpsUrlFacade</class-id><body></body></comment><class><name>SimpleDateTransformer</name><environment>Chronos</environment><super>Passport.ReversibleTransformer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>calendarDelta </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Duration</category><attributes><package>Chronos-Duration</package></attributes></class><comment><class-id>Chronos.SimpleDateTransformer</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})</body></comment><class><name>ResourcePath</name><environment>Passport</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context protocol hostname port user password namespace pathname query fragment </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ResourcePath</class-id><body>ResourcePath	Concept:		Instances of ResourcePath represent pathnames to files or other external/remote/persistent resources (e.g., LDAP namespace entries.) Unlike a String, an instance of ResourcePath provides protocol and behavior appropriate to the function and purpose of an object that identifies ("references") an external file/resource. Additionally, ResourcePaths provide a much more portable way to represent and manipulate pathames of external/persistent/remote resources in a platform-independent way. 		ResourcePath inherits from Immutable (which see.) Once initialized, a ResourcePath instance becomes immutable.	Usage:		A ResourcePath has three attributes: a hostname, a namepace and a pathname.  		The hostname attribute identifies the network-addressable host on which the resource (e.g., a file) resides. 		The namespace attribute represents the platform-specific prefix of the full resource pathname--it's a String whose syntax is that of the native/host filesystem (or other resource storage/retrieval system.) Although the namespace String can contain any prefix of the full resource pathname, up to and including the pathname in its entirety, the intent is that it should only contain whatever pathname prefix is minimally necessary to specify the "root" volume/device/drive/directory/naming-context of the full resource pathname (because that's always the part of a resource pathname whose syntax differs from that of  the rest of the pathname (if it does,) and because it's the part that generally cannot be syntactically translated between different systems for the storage/retrieval of external/remote/persistent resources due to the differences in the ways that such systems conceptualize, model, name and specify their root namespace or namespaces--such differences are not just syntactical.) 		The namespace attribute MUST identify a resource that serves as a directory--in other words, the resource named by the namespace String must function as a namespace containing named resources (examples: a virtual root directory, a directory or folder, a JNDI Context, a drive, a volume, or a device.).		If the namespace attribute is nil, then the ResourcePath is interpreted as relatitive to the "current directory" (or whatever namespace is currently the default.)  Conversely, if the namespace attribute is NOT nil, then the ResourcePath is interpreted as an absolute pathname. Consequently, a non-nil namepace attribute must be a syntactically-valid specification of the prefix of an absolute resource pathname. Absolute ResourcePaths (whose namespace attributes are non-nil) are generally NOT portable between systems. Absolute pathname prefixes should be obtained at runtime from platform-specific configuration data.		The pathname attribute contains a platform-independent representation of the resource pathname. It's represented by an instance of Pathname (which see.) The pathname attribute is intended to contain the part of a file pathname that can be translated between systems solely by means of syntactical changes (i.e., replacing one separator character with another: "foo/bar/baz" -&gt; "foo\bar\baz" -&gt; ":foo:bar:baz".)		So the Windows file pathname "\\gandalf\c:\foo\bar" would be canonically represented by a ResourcePath whose hostname attribute would be #gandalf, whose namespace attribute would be 'c:\' and whose pathname attribute would be ('foo' 'bar'). The UNIX file pathname "/usr/local/bin" would be canonically represented by a ResourcePath whose hostname would be #localhost, whose namspace would be '/' and whose pathname would be ('usr' 'local' 'bin').		Instance protocol is provided by which to access, enumerate and manipulate the pathname structure of a ResourcePath, such as the following types of operations:			* Enumerate the prefixes of a ResourcePath's pathname (first to last, last to first);			* Create a new ResourcePath that is a prefix of another; 			* Create a new ResourcePath that is a suffix of another;			* Create a new ResourcePath by appending a suffix; and			* Create a new ResourcePath by appending or removing an "extension" to/from the final component of the pathname.		Instance protocol is also provided by which to perform the following types of operations on the resource referenced (specified, named) by a ResourcePath:			* Retrieve the status/attributes of the referenced resource (whether or not the resource exists, whether or not it is a directory (namespace,) its size in bytes, what resources it contains if it happens to be a directory);			* Move the resource so that it will be located at a different pathname;			* Rename the resource;			* Copy the resource to a new location;			* Delete the resource;			* Create a directory whose pathname will be that represented by the ResourcePath;			* Open a read or write stream for reading or writing the contents of the resource as a sequence of values (usually characters or bytes, but potentially anything.).		See the comments of the individual methods for more information.	Motivation:		ResourcePath provides a standard, portable API by wich external/persistent/remote resources can be named and accessed, by which resource pathnames can be manipulated, and by which hierarchical structures containing resources can be navigated.  	Implementation:		Operations that are system-dependent, such as moving a resource, opening a stream on the contents of a resource, enumerating the contents of a directory, or accessing the size of a resource, are all delegated to the ChronosSystemFacade singleton (see the class comment of ChronosSystemFacade.)  The ChronosSystemFacade singleton also prodes the characters used by the native resource storage/retrieval system (e.g., the native filesystem) to separate pathname components and pathname extensions.		Instance Variables			hostname 		&lt;Symbol&gt;		A Symbol representing the network-addressable hostname of the internet node on which the resource referenced by the instance resides. Default value=#localhost.			namespace 		&lt;String&gt;		A String that identifies the absolute pathname of a root namespace (volume, device, drive, directory, naming context) in which the resource referenced by the instance resides.  If the instance represents a relative  pathname (relative to the current directory,) then &lt;namespace&gt; is nil. If the instance is an absolute pathname, then the value should specify (as a String using native syntax) a syntactically-valid absolute pathname (which will be interpreted as a prefix to the &lt;pathname&gt;.) Canonically, &lt;namespace&gt; is either nil, or else does no more than name some root volume, device, drive, directory or naming context. The value of &lt;namespace&gt;, if it is not nil, MUST name a resource that functions as a namespace containing named resources.			pathname 		&lt;Pathname&gt;	A Pathname instance that represents the "pure pathname" suffix of the resource pathname represented by the receiver.  The "hostname" and "root" volume, device, drive, directory, or other root naming context/environment must NOT be included.	</body></comment><class><name>ChronosParser</name><environment>Chronos</environment><super>Passport.Registratable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>calendar locale defaultTimeZone timeZoneSeparators twoDigitYearBackwardBias monthNameKeysByMonthName monthNameKeysByMonthAbbreviation minMonthNameSize maxMonthNameSize monthNumberInterpretationPolicy dayOfWeekKeysByName dayOfWeekKeysByAbbreviation minDayOfWeekNameSize maxDayOfWeekNameSize meridianNames meridianNameCharSet minMeridianNameSize maxMeridianNameSize </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Parsing</category><attributes><package>Chronos-Parsing</package></attributes></class><comment><class-id>Chronos.ChronosParser</class-id><body></body></comment><class><name>AbstractSemanticAnnualDateRule</name><environment>Chronos</environment><super>Chronos.EffectiveYearTemporalRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Semantic Dates</category><attributes><package>Chronos-Semantic Dates</package></attributes></class><comment><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id><body></body></comment><class><name>Timeperiod</name><environment>Chronos</environment><super>Chronos.CalendricalCoordinate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start duration </inst-vars><class-inst-vars></class-inst-vars><imports>			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><comment><class-id>Chronos.Timeperiod</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})Timeperiod	Concept:		A Timeperiod is a TemporalInterval (which see) whose duration may be specified to be any durational value.	Usage:		The starting point of a Timeperiod may be any TemporalCoordinate (which see,) and can be accessed by sending the message #start to a Timeperiod instance. The Calendar associated with a Timeperiod is the same as the Calendar of its starting point.		A Timeperiod can be used for the following purposes:			1. To determine whether a point-in-time occurs during a particular temporal interval (e.g., "Timeperiod today includes: Gregorian clock now.")			2. To determine whether one temporal interval intersects, contains or is adjacent to another (e.g., "Timeperiod today isAdjacentTo: YearMonthDay today tomorrow asTimeperiod.") 			3. To compute the union or intersection of two temporal intervals (e.g., "Timeperiod currentYear * (Timeperiod yearStartingAt: YearMonthDay today).").			4. To compute the temporal interval that results from adding/subtracting a temporal extent to/from a temporal interval's starting point-in-time--preserving the interval's exent (e.g., "(Timeperiod dayStartingAt: Gregorian clock now) + (CalendarDuration months: 6)").			5. To compute and/or enumerate over a sequence of smaller temporal intervals contained by a larger temporal interval (e.g., "(Timeperiod yearStartingAt: YearMonthDay today) quartersDo: [:eachQuarter | Transcript cr; show: eachQuarter printString].")			6. To compute and/or enumerate over a succession of temporal intervals, each starting at the endpoint of its predecessor, and having the same temporal extent (e.g., "(Timeperiod from: TimeOfDay now duration: HourDuration) next: 24.")		See the individual method comments for more details.	Implementation:		Instance Variables			start 		&lt;TemporalCoordinate&gt;				The starting point-in-time ("left endpoint") of the temporal interval represented by the instance--this moment is included in the interval.			duration 	&lt;Durational&gt;				The temporal extent of the temporal interval represented by the instance.  The point-in-time computed by adding the &lt;duration&gt; to the &lt;start&gt; is the "right endpoint" or "limit" of the instance's temporal interval--and is NOT included in the interval (although all points-in-time asymptotically approaching the limit value "from the left" (from the &lt;start&gt; value) are included.) The &lt;duration&gt; may be either a scalar number of seconds (as implemented by ScientificDuration) or a vector specifying some number of years, months, days and seconds (as implemented by CalendarDuration.) The &lt;duration&gt; may be either positive or negative.</body></comment><class><name>ChronosInstaller</name><environment>Chronos</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Chronos.*			</imports><category>Chronos-Installation</category><attributes><package>Chronos-Installation</package></attributes></class><comment><class-id>Chronos.ChronosInstaller</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChronosInstaller's sole purpose is to send the message #install to the class ChronosEnvironment--which should not happen until the entire Chronos codebase has been filed in (or otherwise installed.)  The class method #initialize (the only method) sends the message #install to ChronosEnvironment.  It is expected that ChronosInstaller's class method #initialize will automatically be invoked by the "file in" machinery (or its equivalent, in the case of binary module loading/installation.) ChronosInstaller is used to trigger the final Chronos installation procedure because there is no other standard mechamism (available in all Smalltalk implementations) to trigger an event that must only happen "post load" or "post file-in."Unless you intend to do development work on the Chronos Date/Tme Library, and distribute the results, there is no reason that ChronosInstaller cannot be removed from the system.</body></comment><class><name>NanosecondSystemClock</name><environment>Chronos</environment><super>Chronos.ChronosSystemClock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System</package></attributes></class><comment><class-id>Chronos.NanosecondSystemClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})NanosecondSystemClock	Concept:		NanosecondSystemClock is an abstract subclass of ChronosSystemClock. It should be used as the superclass of any concrete ChronosSystemClock class that encapsulates a clock device whose resolution is one nanosecond.  See the class comment of ChronosSystemClock for more information, including the defintion of the term 'resolution.' </body></comment><class><name>GregorianCalendar</name><environment>Chronos</environment><super>Chronos.RomanicCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.GregorianCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})GregorianCalendar	Concept:		GregorianCalendar implements the Gregorian Calendar. The Gregorian Calendar is the official, civil calendar of most (but not all) nations of the world.  It uses the same month structure and epoch year as the Julian Calendar, but uses a leap year rule that (compared to the Julian Calendar) more accurately keeps the mean length of the Gregorian calendar year the same as the mean length of the solar year. 		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Gregorian Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Gregorian Calendar is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		The Gregorian Calendar became the official, civil calendar of most of the Catholic countries of Europe (replacing the Julian Calendar) by the decree of Pope Gregory on October 15, 1582 AD [Gregorian], which corresponds to October 5, 1582 AD [Julian]. The British Empire switched from the Julian Calendar to the Gregorian Calendar on 14 September 1752 AD [Gregorian], which corresponds to 3 September 1752 AD [Julian]. Other European countries switched at other times. Some European countries did not switch from the Julian to the Gregorian Calendar until the early 20th Century.		Epoch Date			The epoch date of the Gregorian Calendar is, of course, 1 January 1 AD [Gregorian], which corresponds to 3 January 1 AD [Julian]. The Gregorian epoch date was set two days after the Julian (Dionysian) epoch date solely so that the date of the Vernal Equinox in the Gregorian Calendar (going forward from 1582) would be on or about 21 March, the same date on or about which the Vernal Equinox would have occurred when the official Church formula for computing the date of Easter was formally adopted at the Council of Nicaea in 325 AD.  [Note: Fixing the date of Easter was the sole motivation behind the Catholic Church's decision to adopt the Gregorian Calendar].			 The Julian Date of the epoch of the Gregorian Calendar is 1,721,425.50 (midnight.) 			Year 1 of the Gregorian Calendar is the first year of the Anno Domini era ("Anno Domini" is Latin for "In the year of the Lord.") Years prior to the year 1 Anno Domini are referred to as being in the era "Before Christ" (BC)--which is in English instead of Latin simply because the era was so named (originally) by the Venerable Bede, in his 'Ecclesiastical History of the English Nation,' which was published (in Old English) in the Eighth Century AD. 			For information about a) the epoch year shared by both the Gregorian and Julian Calendars, and b) the Anno Domini Era (which begins in that year,) see the class comment of JulianCalendar.		Time-of-Day Clock			Modernly, midnight is both the zero-point of the time-of-day clock and also the initial moment of the day.  However, such has not always been the case for all users of the Gregorian Calendar.			{GregorianCalendar clock today}			{GregorianCalendar clock now}		Year Numbering Policy			The Gregian Calendar uses ordinal year numbering (as required by the ANSI Smalltalk standard.)  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year 0.		Leap Year Rule			A year is a leap year if its ordinal is evenly divisible by 400, or else if its ordinal is evenly divisible by 4 but not by 100.  Consequently, the year 2000 is a leap year (evenly divisible by 400,) the year 1900 is not a leap year (evenly divisible by 100, but not by 400,) the year 2008 is a leap year (evenly divisible by 4, but not by 100,) and the year 2010 is not a leap year (divisible neither by 4 nor by 400.)		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: January					31/31			2: February					28/29			3: March					31/31			4: April						30/30			5: May						31/31			6: June						30/30			7: July						31/31			8: August					31/31			9: September				30/30			10: October					31/31			11: November				30/30			12: December				31/31			Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name.	Usage:		In the case of class APIs where some messages provide for specifying a Calendar, but other variations of semantically "the same" message omit any "calendar:" parameter, the Gregorian Calendar is the implied (default) Calendar that will be used.  The reaons for this behavior are that 1) the Gregorian Calendar is the de facto international standard calendar--many people never use any other calendar, and are at best only vaguely aware that other calendars even exist, and 2) in some cases, the message-variants that omit the "calendar:" parameter are required by the ANSI-Smalltalk standard to function as though the Gregorian Calendar were the implied parameter (e.g., the DateAndTimeFactory protocol defined by the ANSI-Smalltalk standard.)		The Chronos namespace (shared pool) defines the global variable Gregorian, which aliases the canonical instance of GregorianCalendar.  "GregorianCalendar canonical" and "Gregorian" should be the same object.</body></comment><class><name>ExternalResourceReference</name><environment>Passport</environment><super>Passport.ResourceReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>broker </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ExternalResourceReference</class-id><body></body></comment><class><name>DerivedSemanticAnnualDateRule</name><environment>Chronos</environment><super>Chronos.AbstractSemanticAnnualDateRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseRule derivationIsNominal dateTransformer </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Semantic Dates</category><attributes><package>Chronos-Semantic Dates</package></attributes></class><comment><class-id>Chronos.DerivedSemanticAnnualDateRule</class-id><body></body></comment><class><name>StandardTime</name><environment>Chronos</environment><super>Chronos.BasicTimezone</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.StandardTime</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})StandardTime	Concept:		StandardTime implements "bound, dynamic" time zones, as described in the superclass BoundTimezone.  A StandardTime represents the (offset, abbreviation) tuple that defines local "standard time" during some range (or ranges) ot point-in-time values within the territorial domain of a time zone.  For example, the StandardTime instance whose key is #'Pacific/Honolulu', whose offset from UT is -10 hours, and whose abbreviation is #HST functions as the "bound, dynamic" time-zone for all point-in-time values in Hawaii from 1947-06-08T02:00:00 HST up until the time that his comment was written (2005,) and for for some presently-unknown span of time into the future (i.e., until either the State of Hawaii decides to change one or both of those values yet again--or perhaps to begin observing Daylight Saving Time.)	Usage:		A StandardTime conforms to both the Chronos "BOUND TIMEZONE API" and "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.		==&gt;&gt; Note that `bound, dynamic` time zones (such as instances of StandardTime or NonStandardTime) are not allowed to have offsets from UT that have fractional seconds. &lt;==		See either the individual method comments, or the superclasses BasicTimezone, BoundTimezonie or ChronosTimezone, or the collaborating class VaraibleOffsetTimezone, for any further information.	Implementation:		Instance Variables			key			&lt;Symbol&gt;	The key that identifies the time zone represented by the instance. If and only if it's the key of an Olson time zone (or it it's otherwise a universally well-known key,) it must be universally unique. Unless it's the special value #system, it must be unique within an image (or within an OS process, if the Smalltalk environment is not image based.)	</body></comment><class><name>GeographicCoordinateSpec</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>degreesOfLattitude degreesOfLongitude </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.GeographicCoordinateSpec</class-id><body></body></comment><class><name>IrregularCalendar</name><environment>Chronos</environment><super>Chronos.Calendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Irregular</category><attributes><package>Chronos-Calendars-Irregular</package></attributes></class><comment><class-id>Chronos.IrregularCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})IrregularCalendar	Concept:		IrregularCalendar is an abstract Calendar class whose subclasses implement "irregular" calendars.  An irregular calendar is one that does not have a reasonably small number of year types, and/or where the computation of the year type involves relatively complex math (typically astronomical calculations using real numbers.)  A year type defines a specific number of months in the year and a specific number of days in each month.		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of AstronomicalCalendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		An irregular calendar is one where there is a rather large number of "year types," where a "year type" a) defines a particular way of organizing the days of a year into months and days-of-the-month, and b) defines a deterministic mapping between day-of-year ordinals and month/day-of-month designations.		Typically, astronomical calendars are IrregularCalendars--but that's not always the case.		IrregularCalendar is not yet implemented.</body></comment><class><name>OrdinalNumberingPolicy</name><environment>Chronos</environment><super>Chronos.NumberingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.OrdinalNumberingPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	OrdinalNumberingPolicy: Please refer to the class comment of my superclass, NumberingPolicy</body></comment><class><name>ConfigurableChronosParser</name><environment>Chronos</environment><super>Chronos.ChronosParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expectDayOfWeekName dateSyntax dateAndTimeSyntax </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Parsing</category><attributes><package>Chronos-Parsing</package></attributes></class><comment><class-id>Chronos.ConfigurableChronosParser</class-id><body></body></comment><class><name>GregorianEaster</name><environment>Chronos</environment><super>Chronos.ComputedAnnualDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.GregorianEaster</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>VWEnvironmentFacade</name><environment>Passport</environment><super>Passport.VW5iEnvironmentFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWEnvironmentFacade</class-id><body></body></comment><class><name>ZerolessOrdinalNumberingPolicy</name><environment>Chronos</environment><super>Chronos.NumberingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><comment><class-id>Chronos.ZerolessOrdinalNumberingPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	ZerolessOrdinalNumberingPolicy: Please refer to the class comment of my superclass, NumberingPolicy</body></comment><class><name>BahaiCalendar</name><environment>Chronos</environment><super>Chronos.MonthsPerYearInvariantCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Regular</category><attributes><package>Chronos-Calendars-Regular</package></attributes></class><comment><class-id>Chronos.BahaiCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})BahaiCalendar	Concept:		BahaiCalendar implements the Bahai Calendar, the official calendar of the Bahai religion. Although the Bahai Calendar is at this time officially specified as an arithmetical calendar, the Bahais apparently intend at some future point to change their calendar from an arithmetical to an astronomical calendar, wherein leap years would be determined by astronomical calculations (as a function of the number of astronomically-computed days between vernal equinoxes.)		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Bahai Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		The Bahai Calendar (as implemented here) is an arithmetical, solar calendar. A solar calendar is one that attempts to match the (average) length of its years to that of mean solar years.		Epoch Date			The epoch date of the Bahai Calendar, 0001-01-01 [Bahai], corresponds to 1844-03-21 [Gregorian] and to 1844-03-09 [Julian].  Bahai days begin at sunset. The Julian Date of the Bahai epoch is 2,394,646.25 (6 pm,) so the actual initial moment of the Bahai epoch corresponds to 1844-03-20T18:00:00 [Gregorian] and to 1844-03-08T18:00:00 [Julian]. 			The Bahai epoch is the Vernal Equinox of the year in which Siyyid Mírzá 'Alí-Muhammad was first recognized as a Manifestation of God by Mullá Husayn, and took the title "The Báb."  The Báb was the forerunner to Baha' Ullah, the principal figure of the Bahai religion.			The Bahai era is called just that: the "Bahai Era" (BE)--which is in English, obviously.		Time-of-Day Clock			Although Bahai days begin at sunset, Bahais label the hours of the day beginning at midnight.  So the zero-point of the the time-of-day clock is midnight, although the initial moment of the day is 6 pm. 			{BahaiCalendar clock today}			{BahaiCalendar clock now}		Year Numbering Policy			The  Bahai Calendar uses ordinal year numbering.  This means that the epoch year is an ordinal number whose value is 1, and the year that immediately precedes the year 1 is the year 0.		Leap Year Rule			A year is a leap year if its ordinal is evenly divisible by 400, or else if its ordinal is evenly divisible by 4 but not by 100.  Consequently, the year 400 is a leap year (evenly divisible by 400,) the year 300 is not a leap year (evenly divisible by 100, but not by 400,) the year 180 is a leap year (evenly divisible by 4, but not by 100,) and the year 166 is not a leap year (divisible neither by 4 nor by 400.)		Month Structure			Month					Days In Month								Standard Year/Leap Year								1: Bahá						19/19			2: Jalál						19/19			3: Jamál					19/19			4: 'Azamat					19/19			5: Núr						19/19			6: Rahmat					19/19			7: Kalimát					19/19			8: Kamál					19/19			9: Asmá'					19/19			10: 'Izzat					19/19			11: Mashíyyat				19/19			12: 'Ilm						19/19			13: Qudrat					19/19			14: Qawl					19/19			15: Masá'il					19/19			16: Sharaf					19/19			17: Sultán					19/19			18: Mulk					19/19			19: Ayyám-i-Há				4/5			20: 'Alá						19/19					Days In Year				365/366			The semantic month-key of a month is the same as the month's (English) name (as given here.)</body></comment><class><name>TimeZoneLocalizationPolicy</name><environment>Chronos</environment><super>Passport.ExternalResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>zoneMap defaultTimeZoneKeysByStandardTimeOffsetFromUT defaultTimeZoneKeysByCommonAbbreviation </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Localization</category><attributes><package>Chronos-Localization</package></attributes></class><comment><class-id>Chronos.TimeZoneLocalizationPolicy</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>NonStandardTime</name><environment>Chronos</environment><super>Chronos.StandardTime</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stdTimeOffsetFromUT </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.NonStandardTime</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})NonStandardTime		Concept:		NonStandardTime implements "bound, dynamic" time zones, as described in the superclass BoundTimezone.  A NonStandardTime represents the (offset, abbreviation) tuple that defines local "daylight saving time" (also called "summer time" in much of the world, and generically referred to as "non-standard time" by Chronos) during some range (or ranges) ot point-in-time values within the territorial domain of a time zone.  For example, the NonStandardTime instance whose key is #'America/Phoenix', whose offset from UT is -6 hours, and whose abbreviation is #MDT functions as the "bound, dynamic" time-zone for all point-in-time values in Arizona from 1967-04-02T03:00:00 MDT up until 1967-10-29T01:00:00 MST (Arizona has occasionally observed DST for brief perionds.)	Usage:		A NonStandardTime conforms to both the Chronos "BOUND TIMEZONE API" and "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.		See StandardTime, BasicTimezone, BoundTimezone, ChronosTimezone and VariableOffsetTimezone for more informaiton.	Implementation:		Instance Variables			stdTimeOffsetFromUT	&lt;ScientificDuration&gt; 	The offset from UT that would be in effect during "standard time" in the territorial domain of the time zone whose non-standard time properties are represented by the instance..</body></comment><class><name>PassportSignedMetanumber</name><environment>Passport</environment><super>Passport.PassportMetanumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isNegative </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Passport-Magnitude-Numbers</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.PassportSignedMetanumber</class-id><body></body></comment><class><name>PassportInfinity</name><environment>Passport</environment><super>Passport.PassportSignedMetanumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Magnitude-Numbers</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.PassportInfinity</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>UntilAnnualDateTimeZoneTransitionFactory</name><environment>Chronos</environment><super>Chronos.IntraYearTimeZoneTransitionFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annualDate </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TimeZones-PolicyFactories-Annual</category><attributes><package>Chronos-TimeZones-PolicyFactories-Annual</package></attributes></class><comment><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UntilAnnualDateTimeZoneTransitionFactory	Concept:		An UntilAnnualDateTimeZoneTransitionFactory is an IntraYearTimeZoneTransitionFactory that specifies its annually-recurring intra-year date of expiry and transition to a successor AnnuallyRecurringTZPolicyFactory using an instance of AnnualDate.		See the superclass IntraYearTimeZoneTransitionFactory for more information.	Implementation:		Instance Variables  {Also see superclass}			annualDate	&lt;AnnualDate&gt; The annually-recurring intra-year date when the ruleform represented by the instance expires and the transition to its successor takes place. Specification/representation of the time-of-day of expiry/transition is implemented by the superclass.</body></comment><class><name>VWClassicSystemClock</name><environment>Chronos</environment><super>Chronos.ChronosSystemClock</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isRelativeToUT </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System-VW</package></attributes></class><comment><class-id>Chronos.VWClassicSystemClock</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})VWClassicSystemClock	Concept:		An instance of VWClassicSystemClock encapsulates the system clock provided by the object engine ("virtual machine") for all versions of VisualWorks Smalltalk prior to version 7.0.  For more information (including the definitions of terms,) see the class comment of ChronosSystemClock.	Implementation:		This implementation is specific to versions of VisualWorks Smalltalk where the system clock provided by the VW object engine a) has a resolution of 1 second, b) reports time relative to UTC on UNIX but relative to local time on Windows and classic MacOs, and c) is accessible using primitive 98.  Form VisualWorks version 7 forward, the VW object engine's system clock has a resolution of 1 microsecond and reports time relative to UT on ALL platforms, and is accessed using primitive 351.  According to the Blue Book, the original Xerox Smalltalk-80 (of which VisualWorks is a direct descendant) used a system clock that reported the time in seconds relative to UT. 		Instance Variables			isRelativeToUT	&lt;Boolean&gt;	Initialized when the instance is created, reset when the instance is sent the message #invalidateRelativity. This value serves as a flag that indicates whether or not the instance keeps/reports time relative to UT or relative to local time.  </body></comment><class><name>UniversalTime</name><environment>Chronos</environment><super>Chronos.BoundTimezone</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.UniversalTime</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})UniversalTime	Concept:		UniversalTime implements the international reference zero-offset time zone whose formal name is Universal Time, and whose formally-correct abbreviation is UT.  However, this time zone is quite commonly referred to by a variety of other names and abbreviations--some of which are more widely used than the formally-correct ones.  Such names/abbreviations include Greenwich Mean Time (which is technically a timescale, not a time zone,) GMT (which is the abbreviation for Greenwich Mean Time,) Coordinated Universal Time (which is also technically a timescale, not a time zone,) UTC (which is the abbreviation for Coordinated Universal Time,) Zulu and Z (and there are others, especially in languages other than English.) [Briefly: A time zone is an offset or translation from a timescale or from some other time zone; a timescale defines an absolute temporal coordinate system by specifying an epoch (the zero-point of the timescale) and the temporal extent (size, duration) of the units used to measure the passage of time relative to the epoch. What those who use 'UTC' as the abbreviation of a timezone ought to (metaphorically) mean by such usage (although they typically don't) is 'the international reference timezone whose offset from the UTC timescale is zero.' The moral of the story is to be aware that "UTC" is quite often (incorrectly) used to mean 'the international reference timezone whose offset from the Greenwich Mean Time timescale is zero')--and, although the difference between the incorrect and correct meaning of UTC is never more than 0.9 seconds, that may be quite a large discrepancy in some technical/scientific contexts.]		An instance of UniversalTime is a Chronos "bound, static" time zone, as specified and explained by the comment of the superclass BoundTimezone..		See the class comments of BoundTimezone, ChronosTimezone and Timescale (once it's implemented, which it currently is not) for more information.	Usage:		The canonical instance of UniversalTime can be accessed by sending the (class) messages #universal or #ut to ChronosTimezone (e.g., 'ChronosTimezone universal',) or by using any of the following timezone keys to look up a time zone by its key: #Universal, #'Universal Time', #UT, #UTC, #GMT, #Zulu or #Z (e.g., 'ChronosTimezone at: #GMT.') The canonical key of the Universal time zone is #Universal.</body></comment><class><name>ResourcePathContext</name><environment>Passport</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultProtocol facadesByProtocol defaultHostNamesAndPortsByProtocol defaultNamespacesByProtocol pathMap pathDescriptions defaultUser defaultPassword </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.ResourcePathContext</class-id><body></body></comment><class><name>ChronosResourceRepositoryContext</name><environment>Chronos</environment><super>Passport.ResourcePathContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version timestamp resourcePathPrefix timeZoneResourceBroker tzLocalizationPolicyResourceBroker </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-System</category><attributes><package>Chronos-System</package></attributes></class><comment><class-id>Chronos.ChronosResourceRepositoryContext</class-id><body></body></comment><class><name>MonthlyCalendarSpec</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key nameKey daysPerMonth occurrenceType leapDayOrdinals </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Foundation</category><attributes><package>Chronos-Calendars-Foundation</package></attributes></class><comment><class-id>Chronos.MonthlyCalendarSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})MonthlyCalendarSpec	Concept:		A MonthlyCalendarSpec represents/specifies the properties of a particular month as it occurs within a particular type of year (e.g., a standard year, a leap year) of a particular calendrical system (e.g., the Gregorian, Hebrew, or Persian calendar.)  It does NOT represent/specify an actual occurrence of a month in any specific year. In other words, an instance of MonthlyCalendarSpec would specify/represent (for example) the properties of the month of February as it occurs in any leap year of the Gregorian Calendar, but would not specify/represent any specific occurrence of February in a specific Gregorian year.		MonthlyCalendarSpecs are used by instances of Calendar (which see) as factory objects in order to create and initialize instances of YearlyCalendar (which also see.)	Implementation:		Instance Variables			key 								&lt;Symbol&gt;				The key that semantically identifies the month represented by the instance.			nameKey 							&lt;Symbol | nil&gt;				The key that semantically identifies the name of the month represented by the instance (because what is semantically the "same month" may go by different names in different years--for example, "Adar" and "Adar Sheni" in the Hebrew Calendar.)  If the &lt;nameKey&gt; is nil, then the instance's "name key" is identical to its &lt;key&gt;.			daysPerMonth 						&lt;Integer&gt;				The number of days in the month represented by the instance.			occurrenceType 					&lt;Integer&gt;				Integer enumeration code, with the following encoding:					0 = standard month that occurs every year ("standard month,") 					1 = short month that occurs every year ("intercalary month,") and 					2 = leap month that does not occur every year ("leap month.")			leapDayOrdinals 					&lt;Collection of Integer&gt;				Collection of the day-of-month ordinals of the days of the month represented by the instance that are leaps days (days that are inserted into the month in some years but not in others--note that a leap day does NOT have to be the last day of a month.)</body></comment><class><name>DayOfYear</name><environment>Chronos</environment><super>Chronos.CalendricalAnnualDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dayOfYearOrdinal </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.DayOfYear</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>UTCTimescale</name><environment>Chronos</environment><super>Chronos.TerrestrialTimescale</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timescales</category><attributes><package>Chronos-Timescales</package></attributes></class><comment><class-id>Chronos.UTCTimescale</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})</body></comment><class><name>ChineseCalendar</name><environment>Chronos</environment><super>Chronos.IrregularCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Irregular</category><attributes><package>Chronos-Calendars-Irregular</package></attributes></class><comment><class-id>Chronos.ChineseCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ChineseCalendar	Concept:		ChineseCalendar implements the Chinese Calendar.  		For any and all discussion of what a 'Calendar' is conceptually, how an instance of a Calendar can and/or should be used, the general implementation requirements for subclasses of Calendar, or the architectural requirements and responsibilities of Calendar instances with respect to the rest of the Chronos Date/Time Library, please refer to the documentation of class Calendar.  The remainder of this text discusses the specific nature of the Chinese Calendar itself (and its implementation by this class,) and assumes that the reader has already become familiar with all the concepts and terminology documented in class Calendar.		ChineseCalendar is not yet implemented		Epoch Date		Leap Year Rule		Month Structure</body></comment><class><name>ScientificDuration</name><environment>Chronos</environment><super>Chronos.ComparableDuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seconds nanosecondsSinceSecond </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Duration</category><attributes><package>Chronos-Duration</package></attributes></class><comment><class-id>Chronos.ScientificDuration</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})ScientificDuration [Aliased by the global Duration, unless that conflicts with a native global of the host Smalltalk environment]	Concept:		ScientificDuration implements the protocol &lt;Duration&gt; (and ScientificDuration class implements the protocol &lt;DurationFactory&gt;) as defined and specified by the ANSI-Smalltalk Standard. As required by the Standard, the global Duration is defined as an alias for ScientficDuration (unless there is already a global by that name defined in the standard environment of the host Smalltalk system in which this copy of the Chronos Date/Time library happens to be installed.)		A ScientificDuration (or an ANSI-Smalltalk Duration) is a "temporal extent" or "duration of time" that represents a scalar number of seconds (including fractions of a second.) It is one of the two different types of Durational (the superclass) provided by Chronos. The other type of Durational provided by Chronos is implemented by the classes CalendarDuration and CivilDuration (which see.)		For more in depth conceptual discussion, see the class comment of Durational (the superclass.)	Usage:		Instances of ScientificDuration can be used as arithmetic operands with each other, and with instances of TemporalCoordinate (whose concrete subclasses include Timepoint, YearMonthDay and TimeOfDay--all of which see.) TemporalCoordinates can compute the temporal extent between any two instances, providing the result as a Durational instance. A Timeperiod specifies the temporal extent of the temporal inteveral it represents using a Durational instance. A ChronosTimezone uses a ScientificDuration to represent its offset from Universal Time.		Key methods of Durational, CalendarDuration, CivilDuration and ScientificDuration have "do its" in their comments that provide usage examples.		Many of the methods of Durational and ScientificDuration implement message signatures as specified and required by the ANSI-Smalltalk Standard.  As is true throughout the Chronos codebase, many of the others are implemented as an analogy to those required by ANSI Smalltalk (i.e., in the same style and/or spirit--both in terms of naming conventions and semantics.)		As is the case with most Chronos classes, instances of ScientificDuration will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		Note that the instance creation messages (class messages) #days: and #seconds: (and many of the variations thereof) will correctly handle either integer or non-integer numeric arguments.	Motivation:		The ANSI-Smalltalk standard requires that durational values be supported as a type distinct from that of point-in-time values.		Secondly, although in some contexts/situations it is both necessary and proper to represent a duration of time using a "raw" numeric value, it is usually superior to encapsulate a durational value in an object that knows the semantics and behavior of the represented temporal extent.  This avoids the possibility that raw numeric values will be misinterpreted as a number of seconds when they actually represent a number of days, hours or tenths of a microsecond.  Even better, it enables such values to collaborate with other objects with greater semantic precision, and in ways that can be made much more specific to the functional intent of the value.  It is much easier to define and understand the meaning of adding a durational value to a point-in-time value, than it would be to define or understand the meaning of adding a raw number (a number of what?).		Thirdly, because calendrical/civil time/business semantics are not appropriate for all durational values, there must be a type of duration that does not count days separately/independently of seconds, nor count years/months at all. Scientific and technical use cases require temporal extents that have a well-defined physical meaning, and that function as scalar values in a monotonic, uniform and gauge-invariant manner.  ScientificDuration is implemented to meet such needs.	Implementation:		The implementation represents a temporal extent as a count of seconds and nanoseconds, converting seconds to nanoseconds and nanoseconds to seconds as necessary.  The reason for this architecture is to hopefully minimize the usage of LargeIntegers, and also because an integer number of seconds is so commonly and generally needed, that it makes sense to store the durational information as a number of integer seconds. The instance variables (and many of the methods) used for this purpose are inherited from Durational (which see.)		Instance Variables			seconds 					&lt;Integer&gt;				The integer part of the "seconds" element of the instance's duration vector. 			nanosecondsSinceSecond	&lt;Integer&gt;				Represents, as an integer number of nanoseconds, the fractional part of the "seconds" element of the instance's duration vector. When the instance is in canonical form, the value of &lt;nanosecondsSinceSecond&gt; must be positive or zero if the value of &lt;seconds&gt; is positive, and must be negative or zero if the value of &lt;seconds&gt; is negative--and the absolute value of &lt;nanosecondsSinceSecond&gt; must be less than the number of nanoseconds in a second (NanosecondsPerSecond = 1,000,000,000.)		Class Variables			Zero		&lt;ScientificDuration&gt;				A constant ScientificDuration that represents a temporal extent of zero.  Accessed by sending the message #zero to the class (as specified and required by the ANSI-Smalltalk Standard.)  The global ZeroDuration (defined in the namespace ChronosDurationConstants) serves as an alias of 'ScientificDuration zero'.</body></comment><class><name>JulianEaster</name><environment>Chronos</environment><super>Chronos.ComputedAnnualDate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.JulianEaster</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>DynamicYearlyCalendar</name><environment>Chronos</environment><super>Chronos.YearlyCalendar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>monthSpecs daysUpToMonthSinceStartOfYear </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Calendars-Irregular</category><attributes><package>Chronos-Calendars-Irregular</package></attributes></class><comment><class-id>Chronos.DynamicYearlyCalendar</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})DynamicYearlyCalendar	Concept:		A DynamicYearlyCalendar is a YearlyCalendar (which see) that generates a new DynamicMontlyCalendar instance or a new DynamicCalendarDay instance every time it needs one or the other.	Usage:		As is the case with most Chronos classes, DynamicYearlyCalendar instances will normally be immutable, although mutable instances can also be instantiated (see the superclass Immutable for more information.)		For specific usage information, see the method comments.	Motivation:		DynamicYearlyCalendar, in collaboration with DynamicCalendarDay and DynamicMonthlyCalendar, avoids the utilization of too much memory in the case of calendrical systems that have too many different year types to reasonably use the flyweight pattern for representing the month structure of each type of year.	Implementation:		Instance Variables			monthSpecs 						&lt;Array of MonthlyCalendarSpec&gt;				The MonthlyCalendarSpec at the &lt;M&gt;th index in the array specifies the properties of the &lt;M&gt;th month of the year represented by the instance.			daysUpToMonthSinceStartOfYear 	&lt;Array of Integer&gt;				The integer value at the &lt;M&gt;th index in the array specifies the number of days from the first day of the year up to (but not including) the first day of the &lt;M&gt;th month of the year represented by the instance.</body></comment><class><name>PassportInfinitesimal</name><environment>Passport</environment><super>Passport.PassportSignedMetanumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Magnitude-Numbers</category><attributes><package>Passport-Kernel</package></attributes></class><comment><class-id>Passport.PassportInfinitesimal</class-id><body></body></comment><class><name>LeapSecond</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prev next secondsDelta preNetLeapSeconds postNetLeapSeconds daysSinceEpoch secondsSinceStartOfDay calendricalSecondsSinceEpoch firstScientificSecondSinceEpoch lastScientificSecondSinceEpoch isRelativeToUT </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timescales</category><attributes><package>Chronos-Timescales</package></attributes></class><comment><class-id>Chronos.LeapSecond</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:Instance Variables:	daysSinceEpoch	&lt;ArithmeticValue&gt;	description of daysSinceEpoch	isRelativeToUT	&lt;Boolean&gt;	description of isRelativeToUT	postNetLeapSeconds	&lt;SmallInteger&gt;	description of postNetLeapSeconds	preNetLeapSeconds	&lt;ArithmeticValue&gt;	description of preNetLeapSeconds	secondsDelta	&lt;SmallInteger&gt;	description of secondsDelta	secondsSinceStartOfDay	&lt;SmallInteger&gt;	description of secondsSinceStartOfDay	ut1SecondsSinceEpoch	&lt;ArithmeticValue&gt;	description of ut1SecondsSinceEpoch	utcSecondsSinceEpoch	&lt;SmallInteger&gt;	description of utcSecondsSinceEpoch	Subclassing:</body></comment><class><name>AlwaysDefaultTZ</name><environment>Chronos</environment><super>Chronos.ProxyTZ</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timezones</category><attributes><package>Chronos-TimeZones</package></attributes></class><comment><class-id>Chronos.AlwaysDefaultTZ</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})AlwaysDefaultTZ	Concept:		The canonical instance of AlwaysDefaultTZ (accessible by sending the class message #alwaysDefault to ChronosTimezone) refers by proxy to whatever Timezone is currently set as &lt;Timezone default&gt;. A Timepoint with this timezone always represents the same time UT, but its local time is dynamically determined by whatever Timezone is set as the current default timezone--in other words, its UT time is invariant, but its local time varies dynamically as a function of any change to whichever timezone == Timezone default.		See ProxyTZ and ChronosTimezone for further information.	Usage:		An AlwaysDefaultTZ conforms to the Chronos "UNBOUND TIMEZONE API" as specified and explained in the "Usage:" section of the class comment of ChronosTimezone (about 10% from the bottom of the extensive and long class comment.)  Support for the Chronos "UNBOUND TIMEZONE API" is inherited from the superclass ChronosTimezone.		The key of the "always default" time zone is #alwaysDefault.	Motivation:		The "always default" time zone enables the presentation of point-in-time values as local to whatever time zone is currently set as the default.</body></comment><class><name>VWFtpUrlFacade</name><environment>Passport</environment><super>Passport.VWAbstractFileUrlFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWFtpUrlFacade</class-id><body></body></comment><class><name>DayOfMonth</name><environment>Chronos</environment><super>Chronos.MonthOfYear</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dayOfMonthOrdinal </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Annual Dates</category><attributes><package>Chronos-Annual Dates</package></attributes></class><comment><class-id>Chronos.DayOfMonth</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>SemanticAnnualDateRule</name><environment>Chronos</environment><super>Chronos.AbstractSemanticAnnualDateRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>observanceRule nominalAnnualDate </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Semantic Dates</category><attributes><package>Chronos-Semantic Dates</package></attributes></class><comment><class-id>Chronos.SemanticAnnualDateRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:	Subclassing:</body></comment><class><name>VWFileUrlFacade</name><environment>Passport</environment><super>Passport.VWAbstractFileUrlFacade</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel-VW</category><attributes><package>Passport-Kernel-VW</package></attributes></class><comment><class-id>Passport.VWFileUrlFacade</class-id><body></body></comment><class><name>LeapSecondSchedule</name><environment>Chronos</environment><super>Passport.Registratable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLeapSecond lastLeapSecond recentlyAccessedLeapSecond map daysSinceEpochOfFirstLeapSecond daysSinceEpochOfLastLeapSecond secondsSinceEpochOfFirstLeapSecond calendricalSecondsSinceEpochOfLastLeapSecond scientificSecondsSinceEpochOfLastLeapSecond </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Timescales</category><attributes><package>Chronos-Timescales</package></attributes></class><comment><class-id>Chronos.LeapSecondSchedule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html})	Concept:	Usage:	Motivation:	Implementation:Instance Variables:	daysSinceEpochOfFirstLeapSecond	&lt;SmallInteger&gt;	description of daysSinceEpochOfFirstLeapSecond	daysSinceEpochOfLastLeapSecond	&lt;SmallInteger&gt;	description of daysSinceEpochOfLastLeapSecond	map	&lt;Dictionary&gt;	description of map	registrationKey	&lt;ByteSymbol&gt;	description of registrationKey	secondsSinceEpochOfFirstLeapSecond	&lt;SmallInteger&gt;	description of secondsSinceEpochOfFirstLeapSecond	sequence	&lt;SequenceableCollection&gt;	description of sequence	ut1SecondsSinceEpochOfLastLeapSecond	&lt;SmallInteger&gt;	description of ut1SecondsSinceEpochOfLastLeapSecond	utcSecondsSinceEpochOfLastLeapSecond	&lt;SmallInteger&gt;	description of utcSecondsSinceEpochOfLastLeapSecond	Subclassing:</body></comment><class><name>ChronosPrintableDecorator</name><environment>Chronos</environment><super>Chronos.ChronosPrintable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegate defaultPolicy </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Printing</package></attributes></class><comment><class-id>Chronos.ChronosPrintableDecorator</class-id><body></body></comment><shared-variable><name>Default</name><environment>Chronos.ChronosParser</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Parsing</package></attributes></shared-variable><shared-variable><name>ISO8601</name><environment>Chronos.ChronosParser</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Parsing</package></attributes></shared-variable><shared-variable><name>ANSIStandard</name><environment>Chronos.ChronosParser</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Parsing</package></attributes></shared-variable><shared-variable><name>SpecRegistry</name><environment>Chronos.ChronosParser</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Parsing</package></attributes></shared-variable><shared-variable><name>MeridianKeys</name><environment>ChronosConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>February</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>March</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>April</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>May</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>June</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>July</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>August</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>September</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>October</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>November</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>December</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISOMonthKeys</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>January</name><environment>Chronos.ChronosStandardMonthConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NotAValue</name><environment>Passport.EnvironmentFacade</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>RestartNotificationSubscribers</name><environment>Passport.EnvironmentFacade</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>PlatformClass</name><environment>Passport.EnvironmentFacade</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>ResourcePathFacadeFactoryReferences</name><environment>Passport.EnvironmentFacade</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>Empty</name><environment>Passport.Pathname</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>Negative</name><environment>Passport.PassportInfinity</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>Positive</name><environment>Passport.PassportInfinity</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>StandardYearTypeCode</name><environment>Chronos.RegularCalendar</environment><private>false</private><constant>false</constant><category>constants</category><initializer>1</initializer><attributes><package>Chronos-Calendars-Regular</package></attributes></shared-variable><shared-variable><name>Current</name><environment>Chronos.ChronosSystemFacade</environment><private>false</private><constant>false</constant><category>globals</category><initializer></initializer><attributes><package>Chronos-System</package></attributes></shared-variable><shared-variable><name>Zero</name><environment>Chronos.ScientificDuration</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Duration</package></attributes></shared-variable><shared-variable><name>SecondsSinceStartOfDayRangeConstraint</name><environment>Chronos.TemporalCoordinate</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>MinutesSinceHourRangeConstraint</name><environment>Chronos.TemporalCoordinate</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>HoursSinceStartOfDayRangeConstraint</name><environment>Chronos.TemporalCoordinate</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>NanosecondsSinceSecondRangeConstraint</name><environment>Chronos.TemporalCoordinate</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>SecondsSinceMinuteRangeConstraint</name><environment>Chronos.TemporalCoordinate</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>ISO8601</name><environment>Chronos.ChronosPrintPolicy</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Printing</package></attributes></shared-variable><shared-variable><name>ANSIStandard</name><environment>Chronos.ChronosPrintPolicy</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Printing</package></attributes></shared-variable><shared-variable><name>SpecRegistry</name><environment>Chronos.ChronosPrintPolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Printing</package></attributes></shared-variable><shared-variable><name>PaschalMoonTable</name><environment>Chronos.JulianEaster</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Annual Dates</package></attributes></shared-variable><shared-variable><name>EnglishProperNamesBySemanticKey</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>EnglishNotationalPolicies</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>EnglishSemanticCharacters</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>RootSemanticCharacters</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>Root</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>US</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>RootNotationalPolicies</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>English</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>System</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>EnglishAbbreviationsBySemanticKey</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>EnglishPluralNounsBySemanticKey</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>USEnglishSemanticCharacters</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>USEnglishNotationalPolicies</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>EnglishSingularNounsBySemanticKey</name><environment>Chronos.ChronosLocale</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>SecondsPerMinute</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>DaysPerWeek</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>SecondsPerHour</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NanosecondsPerMicrosecond</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>MillisecondsPerSecond</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NanosecondsPerMillisecond</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>MicrosecondsPerSecond</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>MinutesPerDay</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NanosecondsPerMinute</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NanosecondsPerHour</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>MicrosecondsPerMillisecond</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NanosecondsPerSecond</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>MinutesPerHour</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NanosecondsPerDay</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>SecondsPerDay</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>HoursPerDay</name><environment>Chronos.ChronosTemporalRatioConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Current</name><environment>Chronos.ChronosSystemClock</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-System</package></attributes></shared-variable><shared-variable><name>CountryNames</name><environment>Chronos.TimeZoneLocalizationPolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>Unique</name><environment>Chronos.TimeZoneLocalizationPolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>Root</name><environment>Chronos.TimeZoneLocalizationPolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Chronos.TimeZoneLocalizationPolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Localization</package></attributes></shared-variable><shared-variable><name>Canonical</name><environment>Chronos.ChronosEnvironment</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NotAValue</name><environment>Chronos.ChronosEnvironment</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>PlatformClass</name><environment>Chronos.ChronosEnvironment</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>InstallationCount</name><environment>Chronos.ChronosEnvironment</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ProtectedGlobalVariables</name><environment>Chronos.ChronosEnvironment</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>OffsetRegistry</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>System</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>Nominal</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>AlwaysSystem</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>AlwaysDefault</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>BindingRegistry</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>Universal</name><environment>Chronos.ChronosTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>SystemClock</name><environment>Smalltalk</environment><private>false</private><constant>false</constant><category>Chronos-Aliases</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ScaledDecimal</name><environment>Smalltalk</environment><private>false</private><constant>true</constant><category>Chronos-Aliases</category><attributes><package>Passport-Kernel-VW</package></attributes></shared-variable><shared-variable><name>Timezone</name><environment>Smalltalk</environment><private>false</private><constant>true</constant><category>Chronos-Aliases</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Duration</name><environment>Smalltalk</environment><private>false</private><constant>true</constant><category>Chronos-Aliases</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>DateAndTime</name><environment>Smalltalk</environment><private>false</private><constant>true</constant><category>Chronos-Aliases</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Chronos.VariableOffsetTimezone</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones</package></attributes></shared-variable><shared-variable><name>LeapIntercalary</name><environment>Chronos.MonthlyCalendarSpec</environment><private>false</private><constant>false</constant><category>constants</category><initializer>2</initializer><attributes><package>Chronos-Calendars-Foundation</package></attributes></shared-variable><shared-variable><name>EveryYearIntercalary</name><environment>Chronos.MonthlyCalendarSpec</environment><private>false</private><constant>false</constant><category>constants</category><initializer>1</initializer><attributes><package>Chronos-Calendars-Foundation</package></attributes></shared-variable><shared-variable><name>Standard</name><environment>Chronos.MonthlyCalendarSpec</environment><private>false</private><constant>false</constant><category>constants</category><initializer>0</initializer><attributes><package>Chronos-Calendars-Foundation</package></attributes></shared-variable><shared-variable><name>LeapYearTypeCode</name><environment>Chronos.RomanicCalendar</environment><private>false</private><constant>false</constant><category>constants</category><initializer>2</initializer><attributes><package>Chronos-Calendars-Regular</package></attributes></shared-variable><shared-variable><name>Negative</name><environment>Passport.PassportInfinitesimal</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>Positive</name><environment>Passport.PassportInfinitesimal</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>WindowsToOlsonTZKeyMap</name><environment>Chronos.TimeZonePolicyFactory</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones-PolicyFactories-Diachronic</package></attributes></shared-variable><shared-variable><name>OlsonToWindowsTZNameMap</name><environment>Chronos.TimeZonePolicyFactory</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TimeZones-PolicyFactories-Diachronic</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Chronos.SemanticDatePolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Semantic Dates</package></attributes></shared-variable><shared-variable><name>USDefault</name><environment>Chronos.SemanticDatePolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Semantic Dates</package></attributes></shared-variable><shared-variable><name>USFederalHolidaySemanticKeys</name><environment>Chronos.SemanticDatePolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Semantic Dates</package></attributes></shared-variable><shared-variable><name>NYSEHolidays</name><environment>Chronos.SemanticDatePolicy</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Semantic Dates</package></attributes></shared-variable><shared-variable><name>Backward</name><environment>Chronos.InfiniteDuration</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Duration</package></attributes></shared-variable><shared-variable><name>Negative</name><environment>Chronos.InfiniteDuration</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Duration</package></attributes></shared-variable><shared-variable><name>Positive</name><environment>Chronos.InfiniteDuration</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Duration</package></attributes></shared-variable><shared-variable><name>Forward</name><environment>Chronos.InfiniteDuration</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Duration</package></attributes></shared-variable><shared-variable><name>Gregorian</name><environment>Chronos.ChronosCalendarConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Julian</name><environment>Chronos.ChronosCalendarConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>AnsiStandardCalendar</name><environment>Chronos.ChronosCalendarConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>AnsiStandardCalendarClock</name><environment>Chronos.ChronosCalendarConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>UTC</name><environment>Chronos.LeapSecondSchedule</environment><private>true</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Timescales</package></attributes></shared-variable><shared-variable><name>ISOSunday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISOThursday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISOWednesday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISOFriday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISOSaturday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISOMonday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Monday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Tuesday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Wednesday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Thursday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Friday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Saturday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Sunday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISOTuesday</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ISODayOfWeekKeys</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ANSIDayOfWeekKeys</name><environment>Chronos.ChronosDaysOfWeekConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Canonical</name><environment>Passport.PassportNotANumber</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>DefaultPortsByProtocol</name><environment>Passport.ResourcePathContext</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>PlatformDefault</name><environment>Passport.ResourcePathContext</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Passport.ResourcePathContext</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>ClassRegistry</name><environment>Chronos.Calendar</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Calendars-Foundation</package></attributes></shared-variable><shared-variable><name>InstanceRegistry</name><environment>Chronos.Calendar</environment><private>false</private><constant>false</constant><category>constants</category><initializer>WeakDictionary new</initializer><attributes><package>Chronos-Calendars-Foundation</package></attributes></shared-variable><shared-variable><name>Past</name><environment>Chronos.InfiniteTimepoint</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>Future</name><environment>Chronos.InfiniteTimepoint</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>StartOfDay</name><environment>Chronos.TimeOfDay</environment><private>false</private><constant>false</constant><category>constants</category><initializer></initializer><attributes><package>Chronos-DateTimeInterval</package></attributes></shared-variable><shared-variable><name>TransparentCharSet</name><environment>Passport.UrlPathFacade</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Passport-Kernel</package></attributes></shared-variable><shared-variable><name>ClassByTypeKeyRegistry</name><environment>Chronos.AnnuallyRecurringTZPolicyFactory</environment><private>false</private><constant>false</constant><category>private</category><initializer></initializer><attributes><package>Chronos-TimeZones-PolicyFactories-Annual</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Chronos.AnnualDate</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-Annual Dates</package></attributes></shared-variable><shared-variable><name>CalendarDurationFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>DayOfYearFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>DateAndTimeFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>SequenceFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>CivilDurationFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>DayOfMonthFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>TimeperiodFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>TimeOfDayFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>DateFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>WeekOfMonthDayOfWeekFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>DurationFactory</name><environment>Chronos.ChronosFactoryBindings</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>WeekDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>YearDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>SecondDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>NanosecondDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>HourDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>MinuteDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>MonthDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>CivilSecondDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>CalendarDayDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ZeroDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ZeroCalendarDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>ClockDayDuration</name><environment>Chronos.ChronosDurationConstants</environment><private>false</private><constant>true</constant><category>public</category><attributes><package>Chronos-Environment</package></attributes></shared-variable><shared-variable><name>Zero</name><environment>Chronos.CalendarDuration</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-Duration</package></attributes></shared-variable><methods><class-id>Passport.PassportObject</class-id> <category>console reporting</category><body package="Passport-Kernel" selector="newLineToConsole">newLineToConsole	EnvironmentFacade newLineToConsole</body><body package="Passport-Kernel" selector="reportToConsole:">reportToConsole: message	"EnvironmentFacade reportToConsole: 'Hello, world'"	self reportToConsole: message newLineCount: 1</body><body package="Passport-Kernel" selector="reportToConsole:message:">reportToConsole: contextName message: message	"EnvironmentFacade reportToConsole: 'Hello, world'"	self reportToConsole: contextName message: message newLineCount: 1</body><body package="Passport-Kernel" selector="reportToConsole:message:newLineCount:">reportToConsole: contextName message: message newLineCount: newLineCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 2"	self reportToConsole: contextName message: message newLineCount: newLineCount tabCount: 0</body><body package="Passport-Kernel" selector="reportToConsole:message:newLineCount:tabCount:">reportToConsole: contextName message: message newLineCount: newLineCount tabCount: tabCount	"EnvironmentFacade reportToConsole: 'Test' message: 'Hello, world' newLineCount: 1 tabCount: 0"	"EnvironmentFacade reportToConsole: 'Test' message: 'Hello, world' newLineCount: 0 tabCount: 2"	EnvironmentFacade reportToConsole: contextName message: message newLineCount: newLineCount tabCount: tabCount</body><body package="Passport-Kernel" selector="reportToConsole:newLineCount:">reportToConsole: message newLineCount: newLineCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 2"	self reportToConsole: message newLineCount: newLineCount tabCount: 0</body><body package="Passport-Kernel" selector="reportToConsole:newLineCount:tabCount:">reportToConsole: message newLineCount: newLineCount tabCount: tabCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 0 tabCount: 2"	self reportToConsole: self appOrLibraryName message: message newLineCount: newLineCount tabCount: tabCount</body></methods><methods><class-id>Passport.PassportObject</class-id> <category>error signalling</category><body package="Passport-Kernel" selector="signal:message:">signal: anExceptionFactory message: message	^EnvironmentFacade signal: anExceptionFactory message: message contextName: self class name</body><body package="Passport-Kernel" selector="signal:message:contextName:">signal: anExceptionFactory message: message contextName: contextName	"Using &lt;anExceptionFactory&gt;, raise an exception with the given &lt;message&gt;"	^EnvironmentFacade signal: anExceptionFactory message: message contextName: contextName</body><body package="Passport-Kernel" selector="signalError:">signalError: message	"Using the general 'Error' exception factory, raise an exception with the given &lt;message&gt;"	^self signal: Error message: message</body></methods><methods><class-id>Passport.PassportObject</class-id> <category>accessing</category><body package="Passport-Kernel" selector="appOrLibraryName">appOrLibraryName	^self class appOrLibraryName</body><body package="Passport-Kernel" selector="comparisonClassIdentifier">comparisonClassIdentifier		"Answer a value that identifies the group of comparable values to which the receiver belongs.  The value might be a Smalltalk class, or might be a Symbol, or might be something else."	^self globalNameOfClass</body><body package="Passport-Kernel" selector="globalNameOfClass">globalNameOfClass	"Answer the fully-qualified (usable anywhere) name of the receiver's class."	^EnvironmentFacade current fullyQualifiedNameOfClass: self class</body></methods><methods><class-id>Passport.PassportObject</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="initialize">initialize		"Initialize a newly created instance. This method must answer the receiver."	"By default, do nothing"</body></methods><methods><class-id>Passport.PassportObject</class-id> <category>finalization</category><body package="Passport-Kernel" selector="executor">executor	"Answer an object to execute the finalization for the receiver. Subclasses might want to override this method.		This method is necessary in VisualWorks. Without it, WeakDictionaries fail to properly release their members when they no longer have any active references."	^nil "If the receiver needs to take finalization action just before being garbage-collected, it should answer either a shallowCopy, or some other object empowered to act as the executor for the receiver's 'last wishes.'"</body></methods><methods><class-id>Passport.PassportObject</class-id> <category>converting</category><body package="Passport-Kernel" selector="literalArrayEncoding">literalArrayEncoding	"Answer an Array of values that canonically represent the value of the receiver, where each value is stored in a canonical position of the Array, such that the Array can be used as the argument to the message #initializeFromLiteralArray: to initialize a different instance of the receiver's class to have the same value as the receiver, and can be used as an argument to the class message #decodeFromLiteralArray: to instantiate a new instance of the receiver's class whose value is the same as the receiver's.  The first element of the Array must be the name of the receiver's class."	"{Timepoint now literalArrayEncoding decodeAsLiteralArray}"	"{(CalendarDuration years: 4 months: 3 days: 15) literalArrayEncoding decodeAsLiteralArray}"	"{Timeperiod today literalArrayEncoding decodeAsLiteralArray}"	"{ChronosPrintPolicy universal literalArrayEncoding decodeAsLiteralArray}"	"{ChronosLocale unitedStates literalArrayEncoding decodeAsLiteralArray}"	"{TimeZoneLocalizationPolicy unitedStates literalArrayEncoding decodeAsLiteralArray}"	"{SemanticDatePolicy default literalArrayEncoding decodeAsLiteralArray}"	"{(VariableOffsetTimezone		key: #nonGlobalKey name: #SouthernHemisphereNormalOrder		initialOffset: (Duration hours: 10) withAbbreviation: #WADT 			until: (WeekOfMonthDayOfWeek month: 4 week: 0 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #nominal		thenOffset: (Duration hours: 9)  withAbbreviation: #WAST  			until: (WeekOfMonthDayOfWeek month: 9 week: 1 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #nominal)				nowToTheSecond literalArrayEncoding decodeAsLiteralArray}"	| stream |	stream := Array new writeStream.	self encodeAsLiteralArrayOn: stream.	^stream contents</body></methods><methods><class-id>Passport.PassportObject</class-id> <category>private</category><body package="Passport-Kernel" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	stream nextPut: self globalNameOfClass</body></methods><methods><class-id>Passport.PassportObject class</class-id> <category>instance creation</category><body package="Passport-Kernel" selector="decodeFromLiteralArray:">decodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;."	| class |	class := self resolveClassFromLiteralArray: literalArray.	^class basicDecodeFromLiteralArray: literalArray</body><body package="Passport-Kernel" selector="new">new	^self basicNew initialize</body></methods><methods><class-id>Passport.PassportObject class</class-id> <category>private</category><body package="Passport-Kernel" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="resolveClassFromLiteralArray:">resolveClassFromLiteralArray: literalArray 	| className |	className := literalArray first asSymbol.	^EnvironmentFacade current resolveClassFromFullyQualifiedName: className		ifAbsent: 			[(EnvironmentFacade current namespaceOfClass: self) "namespace of the receiver, not necessarility that of the class in which this method is defined"				at: className				ifAbsent: [self signalError: '&lt;#decodeFromLiteralArray:&gt; The class named in the first element of the literal Array can not be resolved.']]</body></methods><methods><class-id>Passport.PassportObject class</class-id> <category>error signalling</category><body package="Passport-Kernel" selector="signal:message:">signal: anExceptionFactory message: message	^EnvironmentFacade signal: anExceptionFactory message: message contextName: self name</body><body package="Passport-Kernel" selector="signal:message:contextName:">signal: anExceptionFactory message: message contextName: contextName	"Using &lt;anExceptionFactory&gt;, raise an exception with the given &lt;message&gt;"	^EnvironmentFacade signal: anExceptionFactory message: message contextName: contextName</body><body package="Passport-Kernel" selector="signalError:">signalError: message	"Using the general 'Error' exception factory, raise an exception with the given &lt;message&gt;"	^self signal: Error message: message</body></methods><methods><class-id>Passport.PassportObject class</class-id> <category>console reporting</category><body package="Passport-Kernel" selector="newLineToConsole">newLineToConsole	EnvironmentFacade newLineToConsole</body><body package="Passport-Kernel" selector="reportToConsole:">reportToConsole: message	"EnvironmentFacade reportToConsole: 'Hello, world'"	self reportToConsole: message newLineCount: 1</body><body package="Passport-Kernel" selector="reportToConsole:message:">reportToConsole: contextName message: message	"EnvironmentFacade reportToConsole: 'Hello, world'"	self reportToConsole: contextName message: message newLineCount: 1</body><body package="Passport-Kernel" selector="reportToConsole:message:newLineCount:">reportToConsole: contextName message: message newLineCount: newLineCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 2"	self reportToConsole: contextName message: message newLineCount: newLineCount tabCount: 0</body><body package="Passport-Kernel" selector="reportToConsole:message:newLineCount:tabCount:">reportToConsole: contextName message: message newLineCount: newLineCount tabCount: tabCount	"EnvironmentFacade reportToConsole: 'Test' message: 'Hello, world' newLineCount: 1 tabCount: 0"	"EnvironmentFacade reportToConsole: 'Test' message: 'Hello, world' newLineCount: 0 tabCount: 2"	EnvironmentFacade reportToConsole: contextName message: message newLineCount: newLineCount tabCount: tabCount</body><body package="Passport-Kernel" selector="reportToConsole:newLineCount:">reportToConsole: message newLineCount: newLineCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 2"	self reportToConsole: message newLineCount: newLineCount tabCount: 0</body><body package="Passport-Kernel" selector="reportToConsole:newLineCount:tabCount:">reportToConsole: message newLineCount: newLineCount tabCount: tabCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 0 tabCount: 2"	self reportToConsole: self appOrLibraryName message: message newLineCount: newLineCount tabCount: tabCount</body></methods><methods><class-id>Passport.PassportObject class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="appOrLibraryName">appOrLibraryName	^'Passport'</body></methods><methods><class-id>Passport.ResourceReference</class-id> <category>accessing</category><body package="Passport-Kernel" selector="key">key	^key</body><body package="Passport-Kernel" selector="key:">key: aKey	key := aKey</body><body package="Passport-Kernel" selector="key:value:">key: aKey value: aValue	self subclassResponsibility</body><body package="Passport-Kernel" selector="value">value	^self valueIfNone: []</body><body package="Passport-Kernel" selector="value:">value: aValue	^self subclassResponsibility</body><body package="Passport-Kernel" selector="valueIfNone:">valueIfNone: ifNone	^self subclassResponsibility</body><body package="Passport-Kernel" selector="valueIfNonePut:">valueIfNonePut: valueBlock	^self subclassResponsibility</body><body package="Passport-Kernel" selector="valueIfNoneThenAt:put:">valueIfNoneThenAt: writeKey put: valueBlock 	^self subclassResponsibility</body></methods><methods><class-id>Passport.ResourceReference</class-id> <category>testing</category><body package="Passport-Kernel" selector="valueIsDefined">valueIsDefined	^self subclassResponsibility</body></methods><methods><class-id>Passport.ResourceReference</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	key := nil</body></methods><methods><class-id>Passport.LocalResourceReference</class-id> <category>accessing</category><body package="Passport-Kernel" selector="key:value:">key: aKey value: aValue	key := aKey.	value := aValue</body><body package="Passport-Kernel" selector="value:">value: aValue	value := aValue</body><body package="Passport-Kernel" selector="valueIfNone:">valueIfNone: ifNone	^value == nil		ifTrue: [ifNone value]		ifFalse: [value]</body><body package="Passport-Kernel" selector="valueIfNonePut:">valueIfNonePut: valueBlock	^value == nil		ifTrue: [value := valueBlock value]		ifFalse: [value]</body><body package="Passport-Kernel" selector="valueIfNoneThenAt:put:">valueIfNoneThenAt: writeKey put: valueBlock 	^value == nil 		ifTrue: 			[key := writeKey.			value := valueBlock value]		ifFalse: [value]</body></methods><methods><class-id>Passport.LocalResourceReference</class-id> <category>testing</category><body package="Passport-Kernel" selector="valueIsDefined">valueIsDefined	^value ~~ nil</body></methods><methods><class-id>Passport.LocalResourceReference</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	value := nil</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="/">/ aTemporalCoordinateOrADurational	^aTemporalCoordinateOrADurational asTimeperiodStartingAt: self asCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="&lt;&lt;">&lt;&lt; aChronosTimezone 	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but convert the date and time-of-day as though the receiver represented a date and time in the current default time zone (i.e,. preserve date and time-of-day in Universal Time as though the receiver represented a date and time in the current default time zone.)	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is the same as that of the receiver (i.e,, preserve local date and local time-of-day, don't preserve date or time-of-day in Universal Time.)"	"YearMonthDay today asSpec &lt;&lt; 10 hours"	"YearMonthDay today asSpec &lt;&lt; #nominal"	"YearMonthDay today asSpec &lt;&lt; 'Australia/Adelaide'"	"YearMonthDay today asSpec &lt;&lt; #default"	"YearMonthDay today asSpec &lt;&lt; #system"	| timeZone dateAndTime |	timeZone := ChronosTimezone referencedBy: aChronosTimezone.	timeZone isInvariantToNominalTime ifTrue: [^self].	timeZone isDefault 		ifTrue: [dateAndTime := self asDateAndTime]		ifFalse: 			[dateAndTime := self asMutableDateAndTime.			dateAndTime				deproxifyTimeZone;				convertToTimeZone: timeZone;				beImmutable].	^self duration asTimeperiodStartingAt: dateAndTime</body><body package="Chronos-DateTimeInterval" selector="&gt;&gt;">&gt;&gt; aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"YearMonthDay today asSpec &gt;&gt; 10 hours"	"YearMonthDay today asSpec &gt;&gt; #nominal"	"YearMonthDay today asSpec &gt;&gt; 'Australia/Adelaide'"	"YearMonthDay today asSpec &gt;&gt; #default"	"YearMonthDay today asSpec &gt;&gt; #system"	"{YearMonthDay today asSpec &gt;&gt; 'America/Phoenix'}"	"{YearMonthDay today asSpec &gt;&gt; 'Asia/Calcutta'}"	| timeZone |	timeZone := ChronosTimezone referencedBy: aChronosTimezone.	timeZone isInvariantToNominalTime ifTrue: [^self].	^self duration asTimeperiodStartingAt: (self asDateAndTimeIn: timeZone)</body><body package="Chronos-DateTimeInterval" selector="@">@ timeOfDay 	"(DateSpec year: 1999 month: 12 day: 31) @ (TimeOfDay hour: 23 minute: 59 second: 59)"	^(DateAndTimeFactory basicNew)		setCalendar: self calendar;		basicSetTimeZone: self timeZone;		basicSetYear: year calendarDay: calendarDay;		setTimeOfDay: timeOfDay;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="\">\ calendar	^self as: calendar</body><body package="Chronos-DateTimeInterval" selector="as:">as: otherCalendar 	"Answer the result of converting the receiver into a calendrical coordinate whose Calendar is &lt;otherCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history)."	"{(DateSpec year: 1941 month: 12 day: 7 calendar: Calendar gregorian) as: Julian}"	| newCalendar |	newCalendar := Calendar referencedBy: otherCalendar.	self calendar == newCalendar ifTrue: [^self copy].	^(self copy)		setDaysSinceEpoch: 			(newCalendar 				daysSinceEpochFromForeignDaysSinceEpoch: self daysSinceEpoch				convertingFrom: self calendar)		calendar: newCalendar</body><body package="Chronos-DateTimeInterval" selector="asAll:">asAll: anCollectionOfCalendars	"NOTE: If &lt;anCollectionOfCalendars&gt; is a Set, the result will be a Set with only one member, because Calendrical instances compare as equal to all others that represent the same moment in time."	^anCollectionOfCalendars asArray collect: [:aCalendar | self as: aCalendar]</body><body package="Chronos-DateTimeInterval" selector="asBoundToStaticTimeZone">asBoundToStaticTimeZone	"YearMonthDay today asBoundToStaticTimeZone"	^self asDateAndTime asBoundToStaticTimeZone</body><body package="Chronos-DateTimeInterval" selector="asBoundToTimeZone">asBoundToTimeZone	^self asDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asCalendricalCoordinate">asCalendricalCoordinate	"Answer the conversion of the receiver into its equivalent value implemented as a CalendricalCoordinate.  If the receiver is already a CalendricalCoordinate, answer the receiver."	^self asDate</body><body package="Chronos-DateTimeInterval" selector="asDate">asDate	"Answer the conversion of the receiver into a date-valued CalendricalCoordinate that represents the same date as does the receiver.  If the receiver is already a date-valued CalendricalCoordinate, answer the receiver.  A date-valued CalendricalCoordinate is one that specifies a date without specifying a particular time-of-day nor a particular timezone (i.e., it has nominal time semantics, and its quantum of resolution is 1 calendar day.)"	^DateFactory basicNew		setCalendar: self calendar;		basicSetYear: self year calendarDay: self calendarDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asDateAndTime">asDateAndTime	"Answer the conversion of the receiver into a DateAndTime value that represents the same point-in-time as does the receiver.  If the receiver is already a DateAndTime value, answer the receiver.  A DateAndTime value is a CalendricalCoordinate that specifies a point-in-time, with a quantum of resolution no larger than one second, with behavior/semantics that is invariant to UT, and that conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol. See the class comment of Timepoint for further clarification."	^self &gt;&gt; ChronosTimezone default</body><body package="Chronos-DateTimeInterval" selector="asDateAndTimeIn:">asDateAndTimeIn: aChronosTimezone	"{YearMonthDay today asSpec asDateAndTimeIn: 'Asia/Calcutta'}"	"{Timepoint now asSpec asDateAndTimeIn: 'Asia/Calcutta'}"	"{Timepoint now asSpec asDateAndTimeIn: ChronosTimezone nominal}"	^DateAndTimeFactory basicNew		setCalendar: self calendar;		setTimeZone: aChronosTimezone;		setNanosecondsSinceSecond: self nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: self secondsSinceStartOfDay;		basicSetYear: self year calendarDay: self calendarDay;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asGregorian">asGregorian	^self as: Gregorian</body><body package="Chronos-DateTimeInterval" selector="asInvariantToNominalTime">asInvariantToNominalTime	"Answer a value equivalent to that of the receiver in all respects, except that its semantics/behavior is invariant to nominal time.  If the receiver is already nominal-time invariant, answer the receiver. See the class comment of Timepoint for further clarification."	^self</body><body package="Chronos-DateTimeInterval" selector="asInvariantToUT">asInvariantToUT	"Answer a value equivalent to that of the receiver in all respects, except that it has UT-invariant behavior/semantics.  If the receiver is already invariant-to-UT, answer the receiver. See the class comment of Timepoint for further clarification."	^self &gt;&gt; ChronosTimezone default</body><body package="Chronos-DateTimeInterval" selector="asJulian">asJulian	^self as: Julian</body><body package="Chronos-DateTimeInterval" selector="asLocal">asLocal	^self &gt;&gt; ChronosTimezone default</body><body package="Chronos-DateTimeInterval" selector="asNative">asNative	"Answer the native system's 'Date' analog (or 'Timestamp' analog, if no Date analog is available) that semantically corresponds as closely as possible to the receiver."	"{(DateSpec year: 1941 month: 12 day: 7 calendar: Calendar gregorian) asNative}"	^self calendar clock nativeCalendricalCoordinateFromChronosDate: self</body><body package="Chronos-DateTimeInterval" selector="asNominalDateAndTime">asNominalDateAndTime	"Answer the conversion of the receiver into a nominal-time-invariant DateAndTime value that represents the same local point-in-time as does the receiver.  If the receiver is already a nominal-time-invariant DateAndTime value, answer the receiver.  A nominal-time-invariant DateAndTime value is a CalendricalCoordinate that nominally specifies a point-in-time without reference to any particular timezone, and has a quantum of resolution no larger than one second. A nominal-time-invariant DateAndTime value conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol EXCEPT that its behavior/semantics is invariant to nominal time, as opposed to being UT invariant. See the class comment of Timepoint for further clarification."	^self &gt;&gt; ChronosTimezone nominal</body><body package="Chronos-DateTimeInterval" selector="asSpec">asSpec	^self</body><body package="Chronos-DateTimeInterval" selector="asTemporalCoordinate">asTemporalCoordinate	"Answer the conversion of the receiver into its equivalent value implemented as a TemporalCoordinate.  If the receiver is already a TemporalCoordinate, answer the receiver."	^self asCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="asUT">asUT	^self &gt;&gt; ChronosTimezone ut</body><body package="Chronos-DateTimeInterval" selector="asUTC">asUTC	"Specified and required by the ANSI-Smalltalk Standard."	^self asUT</body><body package="Chronos-DateTimeInterval" selector="dateAndTimeSpec">dateAndTimeSpec	^DateAndTimeSpec 		year: self year		calendarDay: self calendarDay		seconds: self secondsSinceStartOfDay		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="dateSpec">dateSpec	^self</body><body package="Chronos-DateTimeInterval" selector="in:">in: aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"{DateAndTimeFactory now in: 'Asia/Calcutta'}"	"{DateAndTimeFactory nominalNow in: 'Asia/Calcutta'}"	"{DateAndTimeFactory now in: ChronosTimezone nominal}"	^self &gt;&gt; aChronosTimezone</body><body package="Chronos-DateTimeInterval" selector="inAll:">inAll: aCollectionOfTimeZones	"NOTE: If &lt;aCollectionOfTimeZones&gt; is a Set, the result will be a Set with only one member, because all DateAndTime instances compare as equal to all others that represent the same moment in time."	^aCollectionOfTimeZones  collect: [:tz | self  in: tz]</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>private-comparing</category><body package="Chronos-DateTimeInterval" selector="compareToAnnualDate:">compareToAnnualDate: anAnnualDate	^(anAnnualDate compareToDate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToCalendricalCoordinate:">compareToCalendricalCoordinate: aCalendricalCoordinate	^self compareToTemporalCoordinate: aCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="compareToDate:">compareToDate: aDate	^self calendar == aDate calendar		ifTrue: [aDate daysSinceEpoch - self daysSinceEpoch]		ifFalse: [aDate daysSinceUnificationEpoch - self daysSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="compareToDateAndTime:">compareToDateAndTime: aDateAndTime	^self compareToTemporalCoordinate: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="compareToDayOfMonth:">compareToDayOfMonth: aDayOfMonth	^(aDayOfMonth compareToDate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToDayOfYear:">compareToDayOfYear: aDayOfYear	^(aDayOfYear compareToDate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToTemporalCoordinate:">compareToTemporalCoordinate: aTemporalCoordinate	| diff |	diff := aTemporalCoordinate basicSecondsSince: self.	diff = 0 ifFalse: [^diff].	^aTemporalCoordinate nanosecondsSinceSecond - self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="compareToTimeperiod:">compareToTimeperiod: aTimeperiod 	^(aTimeperiod compareToTemporalCoordinate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToWeekOfMonthDayOfWeek:">compareToWeekOfMonthDayOfWeek: aWeekOfMonthDayOfWeek	^(aWeekOfMonthDayOfWeek compareToDate: self) negated</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="ansiDayOfWeekOrdinal">ansiDayOfWeekOrdinal	^self calendar ansiDayOfWeekOrdinalFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="calendar">calendar	^calendarDay calendar</body><body package="Chronos-DateTimeInterval" selector="calendarDay">calendarDay	^calendarDay</body><body package="Chronos-DateTimeInterval" selector="calendarRegistrationKey">calendarRegistrationKey	^self calendar registrationKey</body><body package="Chronos-DateTimeInterval" selector="clock">clock	^self calendar clock</body><body package="Chronos-DateTimeInterval" selector="closedExtent">closedExtent	"Answer the `closed extent` of the receiver. Conceptually, the closed extent of a Timeperiod is the temporal extent (duration) of the **fully-closed** temporal interval that contains every representable point-in-time contained by the Timeperiod. Physically, it is defined to be the temporal extent (duration) computed by subtracting the Timeperiod's granularity from its temporal exent (i.e., {aTimeperiod duration - aTimeperiod granularity}.) See the comment of the receiver's #granularity method (and also the class comment.)"	"{Timeperiod currentWeek closedExtent}"	"{Timeperiod currentHour closedExtent}"	^self duration - self granularity</body><body package="Chronos-DateTimeInterval" selector="dayOfMonth">dayOfMonth	^calendarDay dayOfMonth</body><body package="Chronos-DateTimeInterval" selector="dayOfMonthOrdinal">dayOfMonthOrdinal	^calendarDay dayOfMonthOrdinal</body><body package="Chronos-DateTimeInterval" selector="dayOfWeek">dayOfWeek	^self calendar dayOfWeekOrdinalFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="dayOfWeekAbbreviation">dayOfWeekAbbreviation	^ChronosLocale default abbreviationAtSemanticKey: self dayOfWeekKey</body><body package="Chronos-DateTimeInterval" selector="dayOfWeekKey">dayOfWeekKey	^ANSIDayOfWeekKeys at: self ansiDayOfWeekOrdinal</body><body package="Chronos-DateTimeInterval" selector="dayOfWeekName">dayOfWeekName	^ChronosLocale default properNameAtSemanticKey: self dayOfWeekKey</body><body package="Chronos-DateTimeInterval" selector="dayOfYear">dayOfYear	^calendarDay dayOfYearOrdinal</body><body package="Chronos-DateTimeInterval" selector="dayOfYearOrdinal">dayOfYearOrdinal	^calendarDay dayOfYearOrdinal</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch">daysSinceEpoch	^(self calendar daysSinceEpochUpToYear: self year) + self daysSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpochUpToYear">daysSinceEpochUpToYear	^self calendar daysSinceEpochUpToYear: year</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfANSIWeek">daysSinceStartOfANSIWeek	^self calendar daysSinceStartOfANSIWeekFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfISOWeek">daysSinceStartOfISOWeek	^self calendar daysSinceStartOfISOWeekFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfMonth">daysSinceStartOfMonth	"Answer the number of days since the first day of the receiver's month up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the month represented by the receiver."	^calendarDay daysSinceStartOfMonth</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfYear">daysSinceStartOfYear	"Answer the number of days since the first day of the receiver's year up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the year represented by the receiver."	^calendarDay daysSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="daysSinceUnificationEpoch">daysSinceUnificationEpoch	^self daysSinceEpoch + self calendar unificationDayNumberOfEpoch</body><body package="Chronos-DateTimeInterval" selector="defaultLocale">defaultLocale	^ChronosLocale default</body><body package="Chronos-DateTimeInterval" selector="defaultPrintPolicy">defaultPrintPolicy	^ChronosPrintPolicy ansiStandard</body><body package="Chronos-DateTimeInterval" selector="duration">duration	"Answer a Duration whose value represents the receiver's temporal extent."	^self resolutionQuantum</body><body package="Chronos-DateTimeInterval" selector="earliest">earliest	"Compare the first and last element of the receiver (see the class comment,) and answer whichever one temporally precedes the other. If neither one precedes the other, answer either the receiver's first or last element."	^self first min: self last</body><body package="Chronos-DateTimeInterval" selector="earliestAndLatestDo:">earliestAndLatestDo: block2	"Evaluate &lt;block2&gt; with 'self earliest' as the first argument and with 'self latest' as the second argument."	| first last |	first := self first.	last := self last.	^last &gt;= first 		ifTrue: [block2 value: first value: last]		ifFalse: [block2 value: last value: first]</body><body package="Chronos-DateTimeInterval" selector="eitherYearMonthDayDo:orYearMonthkeyDayDo:">eitherYearMonthDayDo: block3a orYearMonthkeyDayDo: block3b	"If the receiver's month ordinal is unambigously specified, evaluate &lt;block3a&gt; with the receiver's year, its month ordinal and its day-of-month ordinal as the arguments. Otherwise, evaluate &lt;block3b&gt; with the receiver's year,  the semantic key that identifies the receiver's month and its day-of-month ordinal as the arguments."	^self yearMonthDayDo: block3a</body><body package="Chronos-DateTimeInterval" selector="eraName">eraName	^self calendar eraNameForYear: self year</body><body package="Chronos-DateTimeInterval" selector="first">first	"Answer the first element of the receiver, which is defined to be its starting point-in-time."	^self start</body><body package="Chronos-DateTimeInterval" selector="globalNameOfClass">globalNameOfClass	"Answer the fully-qualified (usable anywhere) name of the receiver's class." 	^EnvironmentFacade current fullyQualifiedNameOfClass: self class</body><body package="Chronos-DateTimeInterval" selector="granularity">granularity	"Answer the receiver's granularity, which is defined to be the quantum of resolution of its starting point-in-time (the quantum of resolution of any Chronos point-in-time value is accessible by sending it the message #resolutionQuantum.)  The quantum of resolution of a date value is one calendar day.  The quantum of resolution of a DateAndTime value is the same as that of a Duration value--currently implemented to be one nanosecond. The granularity of Timeperiod contributes to the definition of its closed extent (see the comment of the #closedExtent method, and also the class comment.)"	^self start resolutionQuantum</body><body package="Chronos-DateTimeInterval" selector="hour">hour	^self secondsSinceStartOfTimeOfDayClock // SecondsPerHour</body><body package="Chronos-DateTimeInterval" selector="hour12">hour12	| hour |	hour := self hoursSinceMidnight \\ 12.	^hour = 0		ifTrue: [12]		ifFalse: [hour]</body><body package="Chronos-DateTimeInterval" selector="hour24">hour24	^self hoursSinceMidnight</body><body package="Chronos-DateTimeInterval" selector="hoursSinceMidnight">hoursSinceMidnight	^self secondsSinceMidnight // SecondsPerHour</body><body package="Chronos-DateTimeInterval" selector="hoursSinceStartOfDay">hoursSinceStartOfDay 	^self secondsSinceStartOfDay // SecondsPerHour</body><body package="Chronos-DateTimeInterval" selector="isMonthDuration">isMonthDuration	"Answer whether the receiver's temporal extent is one month."	^self duration isMonthDuration</body><body package="Chronos-DateTimeInterval" selector="isYearDuration">isYearDuration	"Answer whether the receiver's temporal extent is one year."	^self duration isYearDuration</body><body package="Chronos-DateTimeInterval" selector="isoDayOfWeekOrdinal">isoDayOfWeekOrdinal	^self calendar isoDayOfWeekOrdinalFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="julianDay">julianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs. However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered."	^self calendar julianDayFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="julianDayNumber">julianDayNumber	"Answers the Julian Day Number of the Julian Day that starts at Noon on the date represented by the receiver."	^self calendar julianDayFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="last">last	"Answer the last element of the receiver, which is defined to be the point-in-time computed by adding the receiver's closed extent to its starting point-in-time ({self start + self closedExtent.} Also see the class comment."	"{(Timeperiod 		startingAt: (YearMonthDay year: 1901 day: 1)		duration: (CalendarDuration years: 100)) last}"	^self start + self closedExtent</body><body package="Chronos-DateTimeInterval" selector="latest">latest	"Compare the first and last element of the receiver (see the class comment,) and answer whichever one temporally follows the other. If neither one temporally follows the other, answer either the receiver's first or last element."	^self first max: self last</body><body package="Chronos-DateTimeInterval" selector="limit">limit	"Answer the end-point or `limit value` of the receiver, which is defined to be the point-in-time computed by adding the temporal extent (duration) of a Timeperiod to its starting point. The end-point/limit is not included in the Timeperiod's temporal interval (although the points-in-time that asymptotically approach the limit from its starting point-in-time are all included in a Timeperiod's temporal interval.)"	^self start + self duration</body><body package="Chronos-DateTimeInterval" selector="microsecondsSinceEpoch">microsecondsSinceEpoch	^self secondsSinceEpoch * MicrosecondsPerSecond + self microsecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="microsecondsSinceSecond">microsecondsSinceSecond	^(self nanosecondsSinceSecond bitShift: -3) // 125</body><body package="Chronos-DateTimeInterval" selector="microsecondsSinceStartOfDay">microsecondsSinceStartOfDay	^self nanosecondsSinceStartOfDay // NanosecondsPerMicrosecond</body><body package="Chronos-DateTimeInterval" selector="millisecond">millisecond	^(self nanosecondsSinceSecond bitShift: -6) // 15625</body><body package="Chronos-DateTimeInterval" selector="millisecondsSinceEpoch">millisecondsSinceEpoch	^self secondsSinceEpoch * MillisecondsPerSecond + self millisecond</body><body package="Chronos-DateTimeInterval" selector="millisecondsSinceStartOfDay">millisecondsSinceStartOfDay	^self nanosecondsSinceStartOfDay // NanosecondsPerMillisecond</body><body package="Chronos-DateTimeInterval" selector="minute">minute	^self minutesSinceStartOfTimeOfDayClock \\ MinutesPerHour</body><body package="Chronos-DateTimeInterval" selector="minutesSinceMidnight">minutesSinceMidnight	^self secondsSinceMidnight // SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfDay">minutesSinceStartOfDay 	^self secondsSinceStartOfDay // SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfTimeOfDayClock">minutesSinceStartOfTimeOfDayClock	^self secondsSinceStartOfTimeOfDayClock // SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="month">month	^calendarDay month</body><body package="Chronos-DateTimeInterval" selector="monthAbbreviation">monthAbbreviation	^self 		forLocale: ChronosLocale default		monthAbbreviationIfResolvable: [:name | name]		ifNot: [self calendarDay monthAbbreviation]</body><body package="Chronos-DateTimeInterval" selector="monthKey">monthKey	^calendarDay monthKey</body><body package="Chronos-DateTimeInterval" selector="monthName">monthName	^self 		forLocale: ChronosLocale default		monthNameIfResolvable: [:name | name]		ifNot: [self calendarDay monthName]</body><body package="Chronos-DateTimeInterval" selector="monthOrdinal">monthOrdinal	^calendarDay monthOrdinal</body><body package="Chronos-DateTimeInterval" selector="monthsSinceEpoch">monthsSinceEpoch	^(self calendar monthsSinceEpochUpToYear: self year) 		+ self monthsSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="monthsSinceStartOfYear">monthsSinceStartOfYear	^calendarDay monthsSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceEpoch">nanosecondsSinceEpoch	^self secondsSinceEpoch * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceMidnight">nanosecondsSinceMidnight	^self secondsSinceMidnight * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceSecond">nanosecondsSinceSecond		^0</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceStartOfDay">nanosecondsSinceStartOfDay	^self secondsSinceStartOfDay * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceUnificationEpoch">nanosecondsSinceUnificationEpoch	^self secondsSinceUnificationEpoch * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="numericMonthDesignator">numericMonthDesignator	"Answer the culturally-correct numerical label for the receiver's month (usually, this is the ordinal number of the month in the sequence of months since the month that begins a year, but such is not the case in all cultures.)"	^self calendar numericMonthDesignatorFromMonthOrdinal: self monthOrdinal		forYearTypeCode: self yearTypeCode</body><body package="Chronos-DateTimeInterval" selector="relativity">relativity	^#nominal</body><body package="Chronos-DateTimeInterval" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^calendarDay resolutionQuantum</body><body package="Chronos-DateTimeInterval" selector="second">second	^self secondsSinceStartOfTimeOfDayClock \\ SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch">secondsSinceEpoch	^(self daysSinceEpoch * 675 bitShift: 7) + self secondsSinceStartOfDay	"86400 = 128 * 675"</body><body package="Chronos-DateTimeInterval" selector="secondsSinceMidnight">secondsSinceMidnight	^self midnightIsStartOfDay 		ifTrue: [self secondsSinceStartOfDay]		ifFalse: 			[(self calendar 				secondsSinceMidnightFromSecondsSinceStartOfDay: self secondsSinceStartOfDay) 					\\ SecondsPerDay]</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay">secondsSinceStartOfDay		^0</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfMonth">secondsSinceStartOfMonth	^self daysSinceStartOfMonth * SecondsPerDay + self secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfTimeOfDayClock">secondsSinceStartOfTimeOfDayClock	^self timeOfDayClockStartsAtStartOfDay 		ifTrue: [self secondsSinceStartOfDay]		ifFalse: [self secondsSinceMidnight]</body><body package="Chronos-DateTimeInterval" selector="secondsSinceUnificationEpoch">secondsSinceUnificationEpoch	^self calendar secondsSinceUnificationEpochFromSecondsSinceEpoch: self secondsSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="start">start	^self</body><body package="Chronos-DateTimeInterval" selector="timeOfDay">timeOfDay	^self hourMinuteSecondDo: 			[:h :m :s | 			TimeOfDayFactory 				hour: h				minute: m				second: s				nanosecond: self nanosecondsSinceSecond]</body><body package="Chronos-DateTimeInterval" selector="timeOfDaySinceMidnight">timeOfDaySinceMidnight	^self timeOfDayClockStartsAtMidnight 		ifTrue: [self timeOfDay]		ifFalse: 			[ChronosFunction 				fromSeconds: self secondsSinceMidnight				hourMinuteSecondDo: 					[:h :m :s | 					TimeOfDayFactory 						hour: h						minute: m						second: s						nanosecond: self nanosecondsSinceSecond]]</body><body package="Chronos-DateTimeInterval" selector="timeZone">timeZone	^ChronosTimezone nominal</body><body package="Chronos-DateTimeInterval" selector="weekOfMonthOrdinal">weekOfMonthOrdinal	"Answer the ordinal number of the week of the month in which the day represented by the receiver occurs.  The first seven days of the month are the first week of the month."	^self weeksSinceStartOfMonth + 1</body><body package="Chronos-DateTimeInterval" selector="weekOfYearOrdinal">weekOfYearOrdinal	"NOT ISO 8601"	^self weeksSinceStartOfYear + 1</body><body package="Chronos-DateTimeInterval" selector="weeksSinceStartOfMonth">weeksSinceStartOfMonth	"Answer the CARDINAL number of the week of the month in which the day represented by the receiver occurs.  The first seven days of the month are in the week whose CARDINAL number is zero."	^self daysSinceStartOfMonth // DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="weeksSinceStartOfYear">weeksSinceStartOfYear	"NOT ISO 8601"	^self daysSinceStartOfYear // DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="year">year	^year</body><body package="Chronos-DateTimeInterval" selector="yearAndDayOfYearOrdinalAndYearTypeCodeDo:">yearAndDayOfYearOrdinalAndYearTypeCodeDo: block3	^block3 		value: year		value: self dayOfYearOrdinal		value: self yearTypeCode</body><body package="Chronos-DateTimeInterval" selector="yearAndDaysSinceStartOfYearAndYearTypeCodeDo:">yearAndDaysSinceStartOfYearAndYearTypeCodeDo: block3	^block3 		value: year		value: self daysSinceStartOfYear		value: self yearTypeCode</body><body package="Chronos-DateTimeInterval" selector="yearCardinal">yearCardinal	^self calendar yearNumberingPolicy cardinalFromCanonical: self year</body><body package="Chronos-DateTimeInterval" selector="yearOrdinal">yearOrdinal	^self calendar yearNumberingPolicy ordinalFromCanonical: self year</body><body package="Chronos-DateTimeInterval" selector="yearTypeCode">yearTypeCode	^calendarDay yearTypeCode</body><body package="Chronos-DateTimeInterval" selector="yearsSinceEpoch">yearsSinceEpoch	^self yearCardinal</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>arithmetic</category><body package="Chronos-DateTimeInterval" selector="addingDays:setYearAndCalendarDayInto:">addingDays: dayDelta setYearAndCalendarDayInto: block2OrYearMonthDaySpec 	^calendarDay 		startingWithYear: year		addingDays: dayDelta		setYearAndCalendarDayInto: block2OrYearMonthDaySpec</body><body package="Chronos-DateTimeInterval" selector="secondsSince:">secondsSince: aTemporal	| seconds |	seconds := self basicSecondsSince: aTemporal.	^(self basicNanosecondsSinceSecondSince: aTemporal) &gt;= 0 		ifTrue: [seconds]		ifFalse: [seconds - 1]</body><body package="Chronos-DateTimeInterval" selector="secondsUntil:">secondsUntil: aTemporal	| seconds |	seconds := self basicSecondsUntil: aTemporal.	^(self basicNanosecondsSinceSecondUntil: aTemporal ) &gt;= 0 		ifTrue: [seconds]		ifFalse: [seconds - 1]</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setDaysSinceEpoch: (literalArray at: 3) asNumber		calendar: (Calendar referencedBy: (literalArray at: 2) asSymbol)</body><body package="Chronos-DateTimeInterval" selector="invalidateCalendar">invalidateCalendar	calendarDay := calendarDay == nil ifFalse: [calendarDay canonical]</body><body package="Chronos-DateTimeInterval" selector="setDaysSinceEpoch:calendar:">setDaysSinceEpoch: daysSinceEpoch calendar: calendar	calendar		forDaysSinceEpoch: daysSinceEpoch truncated		setYearAndCalendarDayInto: self</body><body package="Chronos-DateTimeInterval" selector="setJulianDay:calendar:">setJulianDay: julianDay calendar: calendar	self setDaysSinceEpoch: (calendar daysSinceEpochFromJulianDay: julianDay) calendar: calendar</body><body package="Chronos-DateTimeInterval" selector="setYear:calendarDay:">setYear: y calendarDay: cd	year := y.	calendarDay := cd.</body><body package="Chronos-DateTimeInterval" selector="setYear:dayOfYearOrdinal:calendar:">setYear: y dayOfYearOrdinal: dayOfYearOrdinal calendar: calendar 	self 		setYear: y		calendarDay: ((calendar yearlyCalendarFor: y) basicDayAt: dayOfYearOrdinal)</body><body package="Chronos-DateTimeInterval" selector="setYear:monthOrdinal:dayOfMonthOrdinal:calendar:">setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: calendar	self setYear: y calendarDay: ((calendar yearlyCalendarFor: y) basicMonthAt: m dayAt: d).</body><body package="Chronos-DateTimeInterval" selector="value:value:">value: y value: cd	year := y.	calendarDay := cd.</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>queries</category><body package="Chronos-DateTimeInterval" selector="forLocale:monthAbbreviationIfResolvable:ifNot:">forLocale: aChronosLocale monthAbbreviationIfResolvable: resolvable ifNot: notResolvable 	"Evaluate &lt;resolvable&gt; with the abbreviation of the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self calendarDay forLocale: aChronosLocale monthAbbreviationIfResolvable: resolvable ifNot: notResolvable</body><body package="Chronos-DateTimeInterval" selector="forLocale:monthNameIfResolvable:ifNot:">forLocale: aChronosLocale monthNameIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKkey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self calendarDay forLocale: aChronosLocale monthNameIfResolvable: resolvable ifNot: notResolvable</body><body package="Chronos-DateTimeInterval" selector="monthKeyIfResolvable:ifNot:">monthKeyIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the key that semantically identifies the receiver's month as the sole argument. However, if the month's semantic key is not unambiguously resolvable, answer the result of evaluationg &lt;notResolvable&gt;. Answer the result of the evaluated block."	^resolvable value: self monthKey</body><body package="Chronos-DateTimeInterval" selector="secondsInDay">secondsInDay	^SecondsPerDay</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isAtStartOfDay">isAtStartOfDay	^true</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfMonth">isAtStartOfMonth	^self isFirstDayOfMonth and: [self isAtStartOfDay]</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfYear">isAtStartOfYear	^self isFirstDayOfYear and: [self isAtStartOfDay]</body><body package="Chronos-DateTimeInterval" selector="isBoundToTimeZone">isBoundToTimeZone	^false</body><body package="Chronos-DateTimeInterval" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^self duration isDayDuration</body><body package="Chronos-DateTimeInterval" selector="isFirstDayOfMonth">isFirstDayOfMonth	^calendarDay isFirstDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="isFirstDayOfYear">isFirstDayOfYear	^calendarDay isFirstDayOfYear</body><body package="Chronos-DateTimeInterval" selector="isGregorian">isGregorian	^self calendar isGregorian</body><body package="Chronos-DateTimeInterval" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer true if the receiver always represents an invariant nominal local time ('3 pm local time') in whatever Timezone to which it may be bound. Otherwise, answer false."	^true</body><body package="Chronos-DateTimeInterval" selector="isInvariantToUT">isInvariantToUT	"Answer true if the receiver always represents an invariant nominal UT time ('3 pm UT') in whatever Timezone to which it may be bound. Otherwise, answer false."	^self isInvariantToNominalTime not</body><body package="Chronos-DateTimeInterval" selector="isLastDayOfMonth">isLastDayOfMonth	^calendarDay isLastDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="isLastDayOfYear">isLastDayOfYear	^calendarDay isLastDayOfYear</body><body package="Chronos-DateTimeInterval" selector="isLeapYear">isLeapYear	^calendarDay yearHasLeapDays</body><body package="Chronos-DateTimeInterval" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^self duration isNanosecondDuration</body><body package="Chronos-DateTimeInterval" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the receiver's calendrical system starts each day at local midnight."	^self calendar midnightIsStartOfDay</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtMidnight">timeOfDayClockStartsAtMidnight	"Answer true if the zero-point of the time-of-day clock coincides with midnight"	^self calendar timeOfDayClockStartsAtMidnight</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the receiver's calendrical system coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^self calendar timeOfDayClockStartsAtStartOfDay</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="&lt;">&lt; aMagnitude 	"Answer whether the receiver is less than the argument."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison negative]</body><body package="Chronos-DateTimeInterval" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	self == aMagnitude ifTrue: [^true].	^(self compareTo: aMagnitude) = 0</body><body package="Chronos-DateTimeInterval" selector="&gt;">&gt; aMagnitude 	"Answer whether the receiver is greater than the argument."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison positive]</body><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToDate: self] 			on: MessageNotUnderstood 			do: [:ex | 				((ex receiver == aCalendrical) and: [#compareToDate: == ex message selector])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-DateTimeInterval" selector="hash">hash	^(year + calendarDay hash) hash</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="hour12MinuteSecondDo:">hour12MinuteSecondDo: block3 	^self hourMinuteSecondDo: block3 hour24Format: false</body><body package="Chronos-DateTimeInterval" selector="hour24MinuteSecondDo:">hour24MinuteSecondDo: block3 	^self hourMinuteSecondDo: block3 hour24Format: true</body><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:">hourMinuteSecondDo: block3 	^self hourMinuteSecondDo: block3 hour24Format: true</body><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:hour24Format:">hourMinuteSecondDo: block3 hour24Format: hour24	^ChronosFunction 		fromSeconds: 			(hour24 				ifTrue: [self secondsSinceStartOfTimeOfDayClock]				ifFalse: [self secondsSinceMidnight])		hourMinuteSecondDo:  block3</body><body package="Chronos-DateTimeInterval" selector="yearAndCalendarDayDo:">yearAndCalendarDayDo: block2 	^block2 value: year value: calendarDay</body><body package="Chronos-DateTimeInterval" selector="yearMonthDayDo:">yearMonthDayDo: block3	"Evaluate &lt;block3&gt; with the calendar year number, month ordinal and day-of-month ordinal of the day represented by the receiver as the first, second and third arguments (respectively.) If the receiver is not bound to a particular year, use nil as the value of the year."	^block3 		value: year		value: self month		value: self dayOfMonth</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>printing</category><body package="Chronos-Printing" selector="%">% aChronosPrintPolicyOrSpec	^self printStringUsing: aChronosPrintPolicyOrSpec</body><body package="Chronos-DateTimeInterval" selector="basicPrintOn:">basicPrintOn: stream	super printOn: stream</body><body package="Chronos-Printing" selector="localePrintString">localePrintString	^self printStringUsing: self defaultLocale temporalPrintPolicy</body><body package="Chronos-Printing" selector="longPrintString">longPrintString	^self printStringUsing: (self defaultLocale temporalPrintPolicy 				apply: #(#showDayOfWeekName 						#useMonthName 						#showTimeOfDay 						#showTimeZoneOffset 						#timeZoneSeparator: $  						#timeZoneElementSeparator: nil 						#showNamesOfDurationElements 						#showNamesOfCalendarDurationElements))</body><body package="Chronos-Printing" selector="printOn:">printOn: stream	self printOn: stream using: self defaultPrintPolicy</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	"If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy default (or ChronosPrintPolicy ansiStandard or ChronosPrintPolicy iso8601,) then the receiver's printString will be formatted as required by the ISO 8601 Standard."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printDate: self on: stream</body><body package="Chronos-Printing" selector="printStringForLocale:">printStringForLocale: aLocale	"Answer the printString of the receiver as generated by the temporal print policy of the ChronosLocale specified by &lt;aLocale&gt;."	^self printStringUsing: (ChronosLocale referencedBy: aLocale) temporalPrintPolicy</body><body package="Chronos-Printing" selector="printStringUsing:">printStringUsing: aPrintPolicy	| stream |	stream := (String new: 30) writeStream.	self printOn: stream using: aPrintPolicy.	^stream contents</body><body package="Chronos-Printing" selector="shortPrintString">shortPrintString	"Timepoint now shortPrintString"	^self printStringUsing: (self defaultLocale temporalPrintPolicy 				apply: #(#hideDayOfWeek 						#useMonthAbbreviation 						#showTimeOfDay 						#hideSubsecondFraction 						#showTimeZoneOffset 						#timeZoneSeparator: $  						#timeZoneElementSeparator: nil 						#hideNamesOfDurationElements 						#durationDayHourSeparator: ' T ' 						#durationElementSeparator: $: 						#durationPadChar: $0 						#hideNamesOfCalendarDurationElements 						#showZeroValuedDurationElements 						#hideZeroValuedCalendarDurationElements))</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTime">asMutableDateAndTime	^(DateAndTimeFactory basicNew)		basicSetCalendar: self calendar;		basicSetYear: year calendarDay: calendarDay;		canonicalize</body><body package="Chronos-DateTimeInterval" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self calendarRegistrationKey;		nextPut: self daysSinceEpoch</body></methods><methods><class-id>Chronos.DateSpec</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondSince:">basicNanosecondsSinceSecondSince: aTemporal	^aTemporal basicNanosecondsSinceSecondUntilNominal: self</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondSinceNominal:">basicNanosecondsSinceSecondSinceNominal: aTemporal	^self nanosecondsSinceSecond - aTemporal nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondSinceUT:">basicNanosecondsSinceSecondSinceUT: aTemporal	^self nanosecondsSinceSecond - aTemporal nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondUntil:">basicNanosecondsSinceSecondUntil: aTemporal 	^aTemporal basicNanosecondsSinceSecondSinceNominal: self</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondUntilNominal:">basicNanosecondsSinceSecondUntilNominal: aTemporal 	^aTemporal nanosecondsSinceSecond - self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondUntilUT:">basicNanosecondsSinceSecondUntilUT: aTemporal 	^aTemporal nanosecondsSinceSecond - self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSince:">basicSecondsSince: aTemporal	^aTemporal basicSecondsSinceEpochUntilNominal: self</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochSinceNominal:">basicSecondsSinceEpochSinceNominal: aDateAndTimeInvariantToNominalTime	^self calendar == aDateAndTimeInvariantToNominalTime calendar		ifTrue: [self secondsSinceEpoch - aDateAndTimeInvariantToNominalTime secondsSinceEpoch]		ifFalse: [self secondsSinceUnificationEpoch - aDateAndTimeInvariantToNominalTime secondsSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochSinceUT:">basicSecondsSinceEpochSinceUT: aDateAndTimeInvariantToUT	^self calendar == aDateAndTimeInvariantToUT calendar 		ifTrue: [self secondsSinceEpoch - aDateAndTimeInvariantToUT secondsSinceEpoch]		ifFalse: [self secondsSinceUnificationEpoch - aDateAndTimeInvariantToUT secondsSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochUntilNominal:">basicSecondsSinceEpochUntilNominal: aDateAndTimeInvariantToNominalTime	^self calendar == aDateAndTimeInvariantToNominalTime calendar 		ifTrue: [aDateAndTimeInvariantToNominalTime secondsSinceEpoch - self secondsSinceEpoch]		ifFalse: [aDateAndTimeInvariantToNominalTime secondsSinceUnificationEpoch - self secondsSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochUntilUT:">basicSecondsSinceEpochUntilUT: aDateAndTimeInvariantToUT	^self calendar == aDateAndTimeInvariantToUT calendar 		ifTrue: [aDateAndTimeInvariantToUT secondsSinceEpoch - self secondsSinceEpoch]		ifFalse: [aDateAndTimeInvariantToUT secondsSinceUnificationEpoch - self secondsSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsUntil:">basicSecondsUntil: aTemporal	^aTemporal basicSecondsSinceEpochSinceNominal: self</body></methods><methods><class-id>Chronos.DateSpec class</class-id> <category>instance creation</category><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:">daysSinceEpoch: daysSinceEpoch 	^(self new)		setDaysSinceEpoch: daysSinceEpoch calendar: AnsiStandardCalendar</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:calendar:">daysSinceEpoch: daysSinceEpoch calendar: calendar 	^(self new)		setDaysSinceEpoch: daysSinceEpoch calendar: (Calendar referencedBy: calendar)</body><body package="Chronos-DateTimeInterval" selector="decodeFromLiteralArray:">decodeFromLiteralArray: literalArray	| class |	class := ChronosObject resolveClassFromLiteralArray: literalArray.	^class basicDecodeFromLiteralArray: literalArray</body><body package="Chronos-DateTimeInterval" selector="julianDay:">julianDay: julianDay	"DateSpec julianDay: YearMonthDay today julianDay"	^self new setJulianDay: julianDay calendar: AnsiStandardCalendar</body><body package="Chronos-DateTimeInterval" selector="julianDay:calendar:">julianDay: julianDay calendar: calendar 	"DateSpec julianDay: YearMonthDay today julianDay calendar: #Hebrew"	^self new setJulianDay: julianDay calendar: (Calendar referencedBy: calendar)</body><body package="Chronos-DateTimeInterval" selector="year:calendarDay:">year: y calendarDay: cd	^self new		setYear: y calendarDay: cd</body><body package="Chronos-DateTimeInterval" selector="year:day:">year: y day: d 	^self new		setYear: y dayOfYearOrdinal: d calendar: AnsiStandardCalendar</body><body package="Chronos-DateTimeInterval" selector="year:day:calendar:">year: y day: d calendar: calendar 	^self new		setYear: y dayOfYearOrdinal: d calendar: (Calendar referencedBy: calendar)</body><body package="Chronos-DateTimeInterval" selector="year:month:day:">year: y month: m day: d 	^self new		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: AnsiStandardCalendar</body><body package="Chronos-DateTimeInterval" selector="year:month:day:calendar:">year: y month: m day: d calendar: calendar 	^self new		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: (Calendar referencedBy: calendar)</body></methods><methods><class-id>Chronos.DateSpec class</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray	^self new		initializeFromLiteralArray: literalArray</body></methods><methods><class-id>Chronos.DateSpec class</class-id> <category>class initialization</category><body package="Chronos-DateTimeInterval" selector="invalidateCalendarBindings">invalidateCalendarBindings	"DateSpec invalidateCalendarBindings"	self allInstancesDo: [:calendrical | calendrical invalidateCalendar].	self subclasses do: [:class | class invalidateCalendarBindings]</body></methods><methods><class-id>Chronos.DateSpec class</class-id> <category>instance creation-ST80 Compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="fromDays:">fromDays: daysSince1901	^self daysSinceEpoch: daysSince1901 + 693960 "1901-01-01."</body></methods><methods><class-id>Passport.Immutable</class-id> <category>copying</category><body package="Passport-Kernel" selector="copy">copy	"Answer a copy of the receiver which 1) is mutable,  2) compares (#=) as equal to the receiver, and 3) satisfies the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the behavior of the copy it answers in response to this message will not be changed, and b) whenever the copy answered by the receiver in response to this message mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the behavior of the receiver will not be changed.  An associative reference is one where the semantics of the reference are defined by the object identity (#==) of the referenced object.  An attributive reference is one where the semantics of the reference are defined by the value (#=) of the referenced object."	"Subclasses should override this message for only one reason: to raise a 'NotCopyable' exception.  To change the behavior of #copy, subimplment #postCopy."	^self shallowCopy postCopy</body></methods><methods><class-id>Passport.Immutable</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="beImmutable">beImmutable	"Make the receiver immutable.  Idempotent.  Must answer the receiver."	lock == nil 		ifTrue: 			[self canonicalize.			lock := #immutable]</body><body package="Passport-Kernel" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	"By default, do nothing"</body><body package="Passport-Kernel" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	self assertMutability.</body></methods><methods><class-id>Passport.Immutable</class-id> <category>testing</category><body package="Passport-Kernel" selector="isImmutable">isImmutable	^lock ~~ nil</body><body package="Passport-Kernel" selector="isMutable">isMutable	^lock == nil</body></methods><methods><class-id>Passport.Immutable</class-id> <category>private</category><body package="Passport-Kernel" selector="assertMutability">assertMutability	lock == nil ifFalse: [self signalMutationException]</body><body package="Passport-Kernel" selector="isImmutable:">isImmutable: aBoolean	"Prevent VW from making me immutable at the VM level, because that's much too strict and draconian."	aBoolean ifTrue: [self beImmutable]	"I can't become mutable--and I'm always mutable in the VW sense, anyway."</body><body package="Passport-Kernel" selector="nilFields">nilFields	"Store nil into all pointer fields of the receiver."	EnvironmentFacade current makeMutable: self.	super nilFields</body><body package="Passport-Kernel" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	lock := nil.	EnvironmentFacade current makeMutable: self</body></methods><methods><class-id>Passport.Immutable</class-id> <category>error signalling</category><body package="Passport-Kernel" selector="signalMutationException">signalMutationException	^self signal: Error message: 'Attempt to mutate an immutable instance'</body></methods><methods><class-id>Passport.Immutable</class-id> <category>converting</category><body package="Passport-Kernel" selector="asImmutable">asImmutable	^self isMutable 		ifTrue: [self copy beImmutable]		ifFalse: [self]</body><body package="Passport-Kernel" selector="asMutable">asMutable	^self isMutable 		ifTrue: [self]		ifFalse: [self copy]</body></methods><methods><class-id>Passport.PassportMagnitude</class-id> <category>comparing</category><body package="Passport-Kernel" selector="&lt;">&lt; aMagnitude 	"Answer whether the receiver is less than the argument."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &lt; 0]</body><body package="Passport-Kernel" selector="&lt;=">&lt;= otherMagnitude 	"Answer whether the receiver is less than or equal to the argument."	^(self &gt; otherMagnitude) not</body><body package="Passport-Kernel" selector="=">= otherMagnitude	self == otherMagnitude ifTrue: [^true].	^(self compareTo: otherMagnitude) = 0</body><body package="Passport-Kernel" selector="&gt;">&gt; aMagnitude 	"Answer whether the receiver is greater than the argument."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &gt; 0]</body><body package="Passport-Kernel" selector="&gt;=">&gt;= otherMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	^(self &lt; otherMagnitude) not</body><body package="Passport-Kernel" selector="between:and:">between: min and: max 	"Answer whether the receiver is less than or equal to the argument, max,	and greater than or equal to the argument, min."	^self &gt;= min and: [self &lt;= max]</body><body package="Passport-Kernel" selector="compareTo:">compareTo: otherMagnitude	"Compare the value of the receiver to that of &lt;otherMagnitude&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;otherMagnitude&gt; are the same.)"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="hash">hash	"Answer a SmallInteger that is equal to the hash value of any object that is equal to (=) the receiver. 	When two objects are not =, their hash values may or may not be the same.	The hash value may change whenever any attribute of the receiver changes."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="max:">max: otherMagnitude 	"Answer the receiver or the argument, whichever has the greater magnitude."	self &gt; otherMagnitude		ifTrue: [^self]		ifFalse: [^otherMagnitude]</body><body package="Passport-Kernel" selector="min:">min: otherMagnitude 	"Answer the receiver or the argument, whichever has the lesser magnitude."	self &lt; otherMagnitude		ifTrue: [^self]		ifFalse: [^otherMagnitude]</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>comparing</category><body package="Chronos-Foundation" selector="=">= otherTemporalRule 	"Answer whether the receiver is equal to the argument."	self == otherTemporalRule ifTrue: [^true].	^self comparisonClassIdentifier 		= otherTemporalRule comparisonClassIdentifier and: 				[(self compareTo: otherTemporalRule) = 0]</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="depth">depth	"Answer the number of rules in the receiver's rule chain, counting from the receiver to the end of the chain."	^(self rightLinkIfNone: [^1]) depth + 1</body><body package="Chronos-Foundation" selector="leftLink">leftLink	"Answer the next rule `to the left` in the receiver's rule chain, if there is one.  If there is not, answer nil."	^nil</body><body package="Chronos-Foundation" selector="leftLinkIfNone:">leftLinkIfNone: block0	"Answer the next rule `to the left` in the receiver's rule chain, if there is one.  If there is not, answer the result of evaluating &lt;block0&gt;."	^block0 value</body><body package="Chronos-Foundation" selector="rightLink">rightLink	"Answer the next rule `to the right` in the receiver's rule chain, if there is one.  If there is not, answer nil."	^nil</body><body package="Chronos-Foundation" selector="rightLinkIfNone:">rightLinkIfNone: block0	"Answer the next rule `to the right` in the receiver's rule chain, if there is one.  If there is not, answer the result of evaluating &lt;block0&gt;."	^block0 value</body><body package="Chronos-Foundation" selector="sortOperator">sortOperator	"Answer the comparison operator (as a message selector Symbol) to be used to sort the receiver's rule chain in canonical order."	^#&gt;</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>testing</category><body package="Chronos-Foundation" selector="hasLeftwardLink">hasLeftwardLink	"Answer whether there is anonther rule after the receiver in the receiver's leftward rule chain."	^false</body><body package="Chronos-Foundation" selector="hasRightwardLink">hasRightwardLink	"Answer whether there is anonther rule after the receiver in the receiver's rightward rule chain."	^false</body><body package="Chronos-Foundation" selector="isAlwaysInEffect">isAlwaysInEffect	"Answer whether thre rule represented by the receiver is always in effect."	^self isAtom</body><body package="Chronos-Foundation" selector="isAtom">isAtom	^(self hasRightwardLink or: [self hasLeftwardLink]) not</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>converting</category><body package="Chronos-Foundation" selector="asAtom">asAtom	"Answer the receiver as a rule chain containing only the receiver itself. If the receiver is immutable, answer a mutable copy of the receiver whose rightLink and leftLink are both nil."	^self isAtom 		ifTrue: [self]		ifFalse: 			[(self asMutable)				setRightLink: nil;				setLeftLink: nil]</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>initialize-release</category><body package="Chronos-Foundation" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	self isMutable 		ifTrue: [self withRightLinkDo: [:rightLink | rightLink beImmutable]].</body><body package="Chronos-Foundation" selector="setLeftLink:">setLeftLink: aTemporalRule	"Set &lt;aTemporalRule&gt; as the next rule `to the left` in the receiver's chain of  TemporalRules."	"By defrault, do nothing."</body><body package="Chronos-Foundation" selector="setRightLink:">setRightLink: aTemporalRule	"Set &lt;aTemporalRule&gt; as the next rule `to the right` in the receiver's chain of  TemporalRules."	aTemporalRule == nil 		ifFalse: [aTemporalRule setLeftLink: self].</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>enumerating</category><body package="Chronos-Foundation" selector="withLeftLinkDo:">withLeftLinkDo: block1	"Evaluatue &lt;block1&gt; with the next leftward link in the receiver's rule chain as the argument.  If there is no such link, do nothing."	"By default, do nothing"</body><body package="Chronos-Foundation" selector="withRightLinkDo:">withRightLinkDo: block1	"Evaluatue &lt;block1&gt; with the next rightward link in the receiver's rule chain as the argument.  If there is no such link, do nothing."	"By default, do nothing"</body><body package="Chronos-Foundation" selector="withSelfAndAllLeftwardLinksDo:">withSelfAndAllLeftwardLinksDo: block1	"Evaluatue &lt;block1&gt; with the receiver as the argument, then evaluate &lt;block1&gt; with all the subsequent links in the receiver's leftward rule chain (if any.)"	block1 value: self.	self withLeftLinkDo: [:leftLink | leftLink withSelfAndAllLeftwardLinksDo: block1]</body><body package="Chronos-Foundation" selector="withSelfAndAllRightwardLinksDo:">withSelfAndAllRightwardLinksDo: block1	"Evaluatue &lt;block1&gt; with the receiver as the argument, then evaluate &lt;block1&gt; with all the subsequent links in the receiver's rightward rule chain (if any.)"	block1 value: self.	self withRightLinkDo: [:rightLink | rightLink withSelfAndAllRightwardLinksDo: block1]</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>private</category><body package="Chronos-Foundation" selector="addRight:">addRight: aTemporalRule	"Answer the result of adding &lt;aTemporalRule&gt; to the rightward side of the receiver's rule chain at the canonical position. If the receiver is immutable, use a mutable copy of the receiver as the head of the chain, and a mutable copy of each link in the chain upto the point of insertion.  Fail if the canonical position of &lt;aTemporalRule&gt; is to the left of the receiver."	^self asMutable basicAddRight: aTemporalRule</body><body package="Chronos-Foundation" selector="basicAddRight:">basicAddRight: aTemporalRule 	"Add &lt;aTemporalRule&gt; as one of the rules in the receiver's rightward rule chain."	aTemporalRule == self 		ifTrue: 			[self 				signalError: 'The rightward link of a TemporallRule cannot be itself.'].	aTemporalRule == nil 		ifTrue: [self setRightLink: nil]		ifFalse: 			[| rightLink |			rightLink := self rightLinkIfNone: [^self setRightLink: aTemporalRule].			rightLink == aTemporalRule 				ifFalse: 					[self setRightLink: 						(rightLink asListSortedInCanonicalOrderByTransitionTimeAdding: aTemporalRule)]]</body></methods><methods><class-id>Chronos.TemporalRule</class-id> <category>concatenation</category><body package="Chronos-Foundation" selector="asListSortedInCanonicalOrderByTransitionTimeAdding:">asListSortedInCanonicalOrderByTransitionTimeAdding: aTemporalRule	"Answer a rule chain sorted in canonical order that includes a) all the rules in the receiver's rule chain, and b) &lt;aTemporalRule&gt;. If the receiver is immutable, the answered rule chain will contain mutable copies of the rules in the receiver's rule chain."	| concatenation |	concatenation := self.	aTemporalRule withSelfAndAllRightwardLinksDo: 			[:each | 			| atom |			atom := each asAtom.			concatenation := 				(concatenation perform: self sortOperator with: atom)					ifTrue: [concatenation addRight: atom]					ifFalse: 						[concatenation = atom 							ifTrue: [atom addRight: concatenation rightLink]							ifFalse: [atom addRight: concatenation]]].	^concatenation</body></methods><methods><class-id>Chronos.TemporalRule class</class-id> <category>private</category><body package="Chronos-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body></methods><methods><class-id>Chronos.TemporalRule class</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="appOrLibraryName">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>testing</category><body package="Chronos-TimeZones-Policies-Annual" selector="hasLeftwardLink">hasLeftwardLink	"Answer whether there is anonther rule after the receiver in the receiver's leftward rule chain."	^leftLink notNil</body><body package="Chronos-TimeZones-Policies-Annual" selector="hasName">hasName	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="hasSubsecondOffset">hasSubsecondOffset	"Answer whether the receiver has fractional seconds of offset."	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="isBound">isBound	"Answer whether the receiver is a bound time zone. A bound time zone is one that defines a single offset/abbreviation tuple, and that conforms to the `BOUND TIMEZONE API` (as defined in the class comment of ChronosTimezone.)"	^true</body><body package="Chronos-TimeZones-Policies-Annual" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to nominal time."	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="isInvariantToUT">isInvariantToUT	^true</body><body package="Chronos-TimeZones-Policies-Annual" selector="isProxy">isProxy	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="isProxyAndInvariantToUT">isProxyAndInvariantToUT	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="isProxyOrStatic">isProxyOrStatic	"Answer whether the receiver is either a proxy time zone or a static time zone."	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="isStandardTime">isStandardTime	"Answer whether or not the offset from UT specified by the receiver defines the `standard time` of the time zone represented by the receiver (as opposed to `daylight saving time`, `summer time`, `war time`, 'three-year-long-year-round energy-saving-during-a-crisis time', etc)."	^boundTZ isStandardTime</body><body package="Chronos-TimeZones-Policies-Annual" selector="isStatic">isStatic	"Answer whether or not the timezone policy (key, offset, name and abbreviation) of the timezone represented by the receiver is invariant, constant and never subject to change or revision.  If the receiver's timezone policy is dynamically redefinable, answer false."	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="isTimezone">isTimezone	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="isUniversalTime">isUniversalTime	"Anwser whether the receiver has all the properties and behaviors of the international reference zero-offset time zone."	^false</body><body package="Chronos-TimeZones-Policies-Annual" selector="offsetIsZero">offsetIsZero	"Anwser whether the receiver's offset from UT is zero."	^boundTZ offsetIsZero</body><body package="Chronos-TimeZones-Policies-Annual" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^boundTZ specifiesCommonAbbreviation or: [leftLink notNil and: [leftLink specifiesCommonAbbreviation]]</body><body package="Chronos-TimeZones-Policies-Annual" selector="specifiesIntraYearTransition">specifiesIntraYearTransition	^false</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>accessing</category><body package="Chronos-TimeZones-Policies-Annual" selector="abbreviation">abbreviation	"Answer the abbreviation for the timezone represented by the receiver--according to the default locale if possible."	^boundTZ abbreviation</body><body package="Chronos-TimeZones-Policies-Annual" selector="binding">binding	^boundTZ</body><body package="Chronos-TimeZones-Policies-Annual" selector="commonAbbreviation">commonAbbreviation	^boundTZ commonAbbreviation</body><body package="Chronos-TimeZones-Policies-Annual" selector="defaultAnnualPolicy">defaultAnnualPolicy	"Answer the AnnuallyRecurringTZPolicy that specifies the time zone rules that are in effect during the current year."	^interYearPolicy defaultAnnualPolicy</body><body package="Chronos-TimeZones-Policies-Annual" selector="interYearPolicy">interYearPolicy	^interYearPolicy</body><body package="Chronos-TimeZones-Policies-Annual" selector="key">key	"Answer the key that identifies the receiver."	^interYearPolicy key</body><body package="Chronos-TimeZones-Policies-Annual" selector="leftLink">leftLink	^leftLink</body><body package="Chronos-TimeZones-Policies-Annual" selector="leftLinkIfNone:">leftLinkIfNone: block0	"Answer the next rule `to the left` in the receiver's rule chain, if there is one.  If there is not, answer the result of evaluating &lt;block0&gt;."	^leftLink == nil		ifTrue: [block0 value]		ifFalse: [leftLink]</body><body package="Chronos-TimeZones-Policies-Annual" selector="name">name	^boundTZ name</body><body package="Chronos-TimeZones-Policies-Annual" selector="offsetDeltaSeconds">offsetDeltaSeconds	^boundTZ offsetDeltaSeconds</body><body package="Chronos-TimeZones-Policies-Annual" selector="offsetFromUT">offsetFromUT	^boundTZ offsetFromUT</body><body package="Chronos-TimeZones-Policies-Annual" selector="offsetSecondsFromUT">offsetSecondsFromUT	^boundTZ offsetSecondsFromUT</body><body package="Chronos-TimeZones-Policies-Annual" selector="policy">policy	"Answer the TimeZonePolicy that specifies the ruleset of the time zone represented by the instance.  The ruleset of a time zone specifies for all time values, from the infinite past to the infinite future, the (possibly varying) time zone offsets and abbreviations that apply to points-in-time within the territorial domain of the time zone. Note, however, that the `policy` (time zone ruleset) can be changed retroactively--and this is rather likely to happen for times in the future (but can also happen to times in the past.)"	^interYearPolicy</body><body package="Chronos-TimeZones-Policies-Annual" selector="root">root	^interYearPolicy root</body><body package="Chronos-TimeZones-Policies-Annual" selector="sortOperator">sortOperator	"Answer the comparison operator (as a message selector Symbol) to be used to sort the receiver's rule chain in canonical order."	^#&lt;</body><body package="Chronos-TimeZones-Policies-Annual" selector="stdTimeOffsetFromUT">stdTimeOffsetFromUT	^boundTZ stdTimeOffsetFromUT</body><body package="Chronos-TimeZones-Policies-Annual" selector="stdTimeOffsetSecondsFromUT">stdTimeOffsetSecondsFromUT	^boundTZ stdTimeOffsetSecondsFromUT</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>printing</category><body package="Chronos-TimeZones-Policies-Annual" selector="printOn:">printOn: stream	stream		nextPut: ${;		nextPutAll: self class name;		nextPutAll: ' commonAbbreviation=';		nextPutAll: self commonAbbreviation;		nextPutAll: ' offsetSecondsFromUT=';		print: self offsetSecondsFromUT;		nextPutAll: ' until='.	self printTranstionRuleOn: stream.	self printSuccessorOn: stream.	stream nextPut: $}</body><body package="Chronos-TimeZones-Policies-Annual" selector="printSuccessorOn:">printSuccessorOn: stream	"By default, do nothing."</body><body package="Chronos-TimeZones-Policies-Annual" selector="printTranstionRuleOn:">printTranstionRuleOn: stream	^self subclassResponsibility</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>converting</category><body package="Chronos-TimeZones-Policies-Annual" selector="asAnnuallyRecurringTZPolicyFactory">asAnnuallyRecurringTZPolicyFactory	"Answer the AnnuallyRecurringTZPolicyFactory that would serve as a factory to recreate an instance of the receiver's class with the same value as the receiver."	^self subclassResponsibility</body><body package="Chronos-TimeZones-Policies-Annual" selector="asAnnuallyRecurringTZPolicyFactoryArray">asAnnuallyRecurringTZPolicyFactoryArray	"Answer an Array of the AnnuallyRecurringTZPolicyFactories that would serve as a factory to recreate an instance of the receiver's class with the same value as the list of AnnuallyRecurringTZPolicies represented by the receiver."	| atomStream |	atomStream := Array new writeStream.	self withSelfAndAllRightwardLinksDo: [:offsetPolicy | atomStream nextPut: offsetPolicy asAnnuallyRecurringTZPolicyFactory].	^atomStream contents</body><body package="Chronos-TimeZones-Policies-Annual" selector="asChronosValue">asChronosValue	"Answer the translation of the receiver into an object that is an instance of whichever class in the Chronos Date/Time Library would be most appropriate for the instantiation of an object equal and/or analogous to the receiver ."	^self</body><body package="Chronos-TimeZones-Policies-Annual" selector="asNonProxy">asNonProxy	"Answer the time zone to which the receiver indirectly refers by proxy.  If the receiver is not a proxy for a time zone other than itself, answer the receiver."	^self</body><body package="Chronos-TimeZones-Policies-Annual" selector="asTimezone">asTimezone	"Answer the conversion of the receiver into a time zone it either references or describes. If the receiver is itself a time zone, answer the receiver."	^self root</body><body package="Chronos-TimeZones-Policies-Annual" selector="asUnbound">asUnbound	"Answer the unbound time zone that specifies the full diachronic ruleset of the time zone represented by the receiver."	^interYearPolicy</body><body package="Chronos-TimeZones-Policies-Annual" selector="canonical">canonical	"Answer the canonical instance of the receiver's root time zone."	^self root canonical</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-TimeZones-Policies-Annual" selector="canonicalizeFromLocal:">canonicalizeFromLocal: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time in the local time defined by the receiver, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use Universal Time coordinates instead of local time coordinates.)"	^boundTZ canonicalizeFromLocal: aDateAndTime</body><body package="Chronos-TimeZones-Policies-Annual" selector="canonicalizeFromUT:">canonicalizeFromUT: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time using Universal Time coordinates, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use coordinates in the local time defined by the receiver instead of using Universal Time coordinates.)"	^boundTZ canonicalizeFromUT: aDateAndTime</body><body package="Chronos-TimeZones-Policies-Annual" selector="netSecondsAfterAddingOffsetFromUTToSeconds:nanosecondsSinceSecond:">netSecondsAfterAddingOffsetFromUTToSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond 	"Answer the net number of integer seconds (truncated towards zero) that result from adding the receiver's offset from UT to the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^boundTZ 		netSecondsAfterAddingOffsetFromUTToSeconds: seconds		nanosecondsSinceSecond: nanosecondsSinceSecond</body><body package="Chronos-TimeZones-Policies-Annual" selector="netSecondsAfterSubtractingOffsetFromUTFromSeconds:nanosecondsSinceSecond:">netSecondsAfterSubtractingOffsetFromUTFromSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from subtracting the receiver's offset from UT from the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^boundTZ		netSecondsAfterSubtractingOffsetFromUTFromSeconds: seconds 		nanosecondsSinceSecond: nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-Policies-Annual" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self shouldNotImplement</body><body package="Chronos-TimeZones-Policies-Annual" selector="release">release	super release.	boundTZ release.</body><body package="Chronos-TimeZones-Policies-Annual" selector="setBoundTZ:">setBoundTZ: aBoundTimezone 	self assertMutability.	boundTZ := aBoundTimezone</body><body package="Chronos-TimeZones-Policies-Annual" selector="setInterYearPolicy:">setInterYearPolicy: anInterYearTimeZonePolicy	self assertMutability.	interYearPolicy := anInterYearTimeZonePolicy.</body><body package="Chronos-TimeZones-Policies-Annual" selector="setInterYearPolicy:offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:">setInterYearPolicy: anInterYearTimeZonePolicy offsetSeconds: offsetSeconds stdTimeOffsetSeconds: stdTimeOffsetSeconds commonAbbreviation: abbreviation 	self setInterYearPolicy: anInterYearTimeZonePolicy.	self setBoundTZ: 		(ChronosTimezone			bindingForKey: self key			offsetSecondsFromUT: offsetSeconds			stdTimeOffsetSecondsFromUT: stdTimeOffsetSeconds			commonAbbreviation: abbreviation)</body><body package="Chronos-TimeZones-Policies-Annual" selector="setLeftLink:">setLeftLink: aTimeZonePolicy	"Set &lt;aTimeZonePolicy&gt; as the leftward link in the receiver's chain of TimeZonePolicies."	self assertMutability.	leftLink := aTimeZonePolicy.</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>queries</category><body package="Chronos-TimeZones-Policies-Annual" selector="bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in the local time defined by the receiver.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in local (`wall clock`) time as defined by the receiver."	^interYearPolicy		bindingForLocalYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones-Policies-Annual" selector="bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in Universal Time.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in Universal Time."	^interYearPolicy		bindingForUTYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones-Policies-Annual" selector="intraYearPolicyForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">intraYearPolicyForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).  Assume the receiver's policy is in effect during the specified year.	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^self subclassResponsibility</body><body package="Chronos-TimeZones-Policies-Annual" selector="intraYearPolicyForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">intraYearPolicyForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).  Assume the receiver's policy is in effect during the specified year.	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^self subclassResponsibility</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year	^self subclassResponsibility</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>private</category><body package="Chronos-TimeZones-Policies-Annual" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	self shouldNotImplement</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy</class-id> <category>processing</category><body package="Chronos-TimeZones-Policies-Annual" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	self asAnnuallyRecurringTZPolicyFactoryArray do: [:each | each processBy: aTimezoneProcessor]</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy class</class-id> <category>private</category><body package="Chronos-TimeZones-Policies-Annual" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self shouldNotImplement</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicy class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-Policies-Annual" selector="for:offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:">for: anInterYearTimeZonePolicy offsetSeconds: offsetSeconds stdTimeOffsetSeconds: stdTimeOffsetSeconds commonAbbreviation: abbreviation 	^self new 		setInterYearPolicy: anInterYearTimeZonePolicy		offsetSeconds: offsetSeconds		stdTimeOffsetSeconds: stdTimeOffsetSeconds		commonAbbreviation: abbreviation</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>accessing</category><body package="Chronos-TimeZones-Policies-Annual" selector="maxDaysFromStartOfYearUntilTransitionForYearOfType:">maxDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^self subclassResponsibility</body><body package="Chronos-TimeZones-Policies-Annual" selector="minDaysFromStartOfYearUntilTransitionForYearOfType:">minDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^self subclassResponsibility</body><body package="Chronos-TimeZones-Policies-Annual" selector="relativity">relativity	^relativity</body><body package="Chronos-TimeZones-Policies-Annual" selector="rightLink">rightLink	"Answer the next rule `to the right` in the receiver's rule chain, if there is one.  If there is not, answer nil."	^rightLink</body><body package="Chronos-TimeZones-Policies-Annual" selector="rightLinkIfNone:">rightLinkIfNone: block0	"Answer the next rule `to the right` in the receiver's rule chain, if there is one.  If there is not, answer the result of evaluating &lt;block0&gt;."	^rightLink == nil		ifTrue: [block0 value]		ifFalse: [rightLink]</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionSecondsSinceStartOfDay">transitionSecondsSinceStartOfDay	^transitionSecondsSinceStartOfDay</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionTimeOfDay">transitionTimeOfDay	^TimeOfDayFactory secondsSinceStartOfDay: transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-Policies-Annual" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	relativity := #nominal.	transitionSecondsSinceStartOfDay := 0</body><body package="Chronos-TimeZones-Policies-Annual" selector="setRightLink:">setRightLink: anAnnuallyRecurringTZPolicy	"Set &lt;anAnnuallyRecurringTZPolicy&gt; as the next rule `to the right` in the receiver's chain of  AnnuallyRecurringTZPolicies."	self assertMutability.	rightLink := anAnnuallyRecurringTZPolicy.	super setRightLink: anAnnuallyRecurringTZPolicy.</body><body package="Chronos-TimeZones-Policies-Annual" selector="setTransitionSecondsSinceStartOfDay:relativity:">setTransitionSecondsSinceStartOfDay: seconds relativity: aRelativitySymbol	self assertMutability.	transitionSecondsSinceStartOfDay := seconds.	relativity := aRelativitySymbol asSymbol.</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>testing</category><body package="Chronos-TimeZones-Policies-Annual" selector="hasRightwardLink">hasRightwardLink	"Answer whether there is anonther rule after the receiver in the receiver's rightward rule chain."	^rightLink notNil</body><body package="Chronos-TimeZones-Policies-Annual" selector="isAlwaysInEffect">isAlwaysInEffect	"Answer whether thre rule represented by the receiver is always in effect."	^self isAtom and: [interYearPolicy isAlwaysInEffect]</body><body package="Chronos-TimeZones-Policies-Annual" selector="isSpecifiedAsLocalTime">isSpecifiedAsLocalTime	^relativity == #nomimal</body><body package="Chronos-TimeZones-Policies-Annual" selector="isSpecifiedAsStandardTime">isSpecifiedAsStandardTime	^relativity == #standard</body><body package="Chronos-TimeZones-Policies-Annual" selector="isSpecifiedAsUT">isSpecifiedAsUT	^relativity == #universal</body><body package="Chronos-TimeZones-Policies-Annual" selector="specifiesIntraYearTransition">specifiesIntraYearTransition	^true</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>queries</category><body package="Chronos-TimeZones-Policies-Annual" selector="intraYearPolicyForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">intraYearPolicyForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).  Assume the receiver's policy is in effect during the specified year.	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^(self 		transitionOccursOnOrAfterYear: year		dayOfYear: dayOfYear		relativity: #nominal		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) 			ifTrue: 				[rightLink 					intraYearPolicyForLocalYear: year					dayOfYear: dayOfYear					secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction]			ifFalse: [self]</body><body package="Chronos-TimeZones-Policies-Annual" selector="intraYearPolicyForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">intraYearPolicyForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).  Assume the receiver's policy is in effect during the specified year.	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^(self 		transitionOccursOnOrAfterYear: year		dayOfYear: dayOfYear		relativity: #universal		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) 			ifTrue: 				[rightLink 					intraYearPolicyForUTYear: year					dayOfYear: dayOfYear					secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction]			ifFalse: [self]</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDayOfWeekInYear:">transitionDayOfWeekInYear: year	^self subclassResponsibility</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>enumerating</category><body package="Chronos-TimeZones-Policies-Annual" selector="withRightLinkDo:">withRightLinkDo: block1	"Evaluatue &lt;block1&gt; with the next rightward link in the receiver's rule chain as the argument.  If there is no such link, do nothing."	^rightLink == nil ifFalse: [block1 value: rightLink]</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>private</category><body package="Chronos-TimeZones-Policies-Annual" selector="transitionOccursOnOrAfterYear:dayOfYear:relativity:secondsSinceStartOfDayFunction:">transitionOccursOnOrAfterYear: year dayOfYear: dayOfYearOrdinal relativity: parameterRelativity secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction	^self subclassResponsibility</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>private-comparing</category><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilEndOfYearAnnualTZPolicy:">compareToUntilEndOfYearAnnualTZPolicy: anUntilEndOfYearAnnualTZPolicy	^1</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransition</class-id> <category>printing</category><body package="Chronos-TimeZones-Policies-Annual" selector="printSuccessorOn:">printSuccessorOn: stream	rightLink == nil 		ifFalse: 			[stream				cr; tab; tab; tab; tab;				nextPutAll: 'then '; print: rightLink].</body><body package="Chronos-TimeZones-Policies-Annual" selector="printTransitionTimeOfDayOn:">printTransitionTimeOfDayOn: stream	stream nextPutAll: ' @ '.	self transitionTimeOfDay printOn: stream.	stream		nextPutAll: ' (';		nextPutAll: relativity;		nextPut: $)</body></methods><methods><class-id>Chronos.ChronosObject</class-id> <category>parameter validation</category><body package="Chronos-Foundation" selector="signalInvalidArgument:value:">signalInvalidArgument: key value: value	"Signal an Error to the effect that &lt;value&gt; is not a valid argument value for the parameter &lt;key&gt;."	self signalError: 'The value ', value printString, ' for the ', key printString, ' parameter is not valid.'</body></methods><methods><class-id>Chronos.ChronosObject</class-id> <category>printing</category><body package="Chronos-Foundation" selector="basicPrintOn:">basicPrintOn: stream	"Print the receiver on &lt;stream&gt; using the implementation of #printOn: inherited from the superclass of ChronosObject ."	super printOn: stream</body><body package="Chronos-Foundation" selector="storeOn:">storeOn: stream 	"{Compiler evaluate: Timepoint now storeString}"	"{Compiler evaluate: (CalendarDuration years: 4 months: 3 days: 15) storeString}"	"{Compiler evaluate: Timeperiod today storeString}"	"{Compiler evaluate: ChronosPrintPolicy universal storeString}"	"{Compiler evaluate: ChronosLocale unitedStates storeString}"	"{Compiler evaluate: TimeZoneLocalizationPolicy unitedStates storeString}"	"{Compiler evaluate: SemanticDatePolicy default storeString}"	"{Compiler evaluate: 		(VariableOffsetTimezone			key: #nonGlobalKey name: #SouthernHemisphereNormalOrder			initialOffset: (Duration hours: 10) withAbbreviation: #WADT 				until: (WeekOfMonthDayOfWeek month: 4 week: 0 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #nominal			thenOffset: (Duration hours: 9)  withAbbreviation: #WAST  				until: (WeekOfMonthDayOfWeek month: 9 week: 1 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #nominal)					nowToTheSecond storeString}"	stream 		store: self literalArrayEncoding;		nextPutAll: ' decodeAsLiteralArray.'</body></methods><methods><class-id>Chronos.ChronosObject</class-id> <category>converting</category><body package="Chronos-Foundation" selector="asChronosValue">asChronosValue	"Answer the translation of the receiver into an object that is an instance of whichever class in the Chronos Date/Time Library would be most appropriate for the instantiation of an object equal and/or analogous to the receiver ."	^self</body></methods><methods><class-id>Chronos.ChronosObject</class-id> <category>testing</category><body package="Chronos-Foundation" selector="isCalendricalCoordinate">isCalendricalCoordinate	^false</body><body package="Chronos-Foundation" selector="isDurational">isDurational	^false</body><body package="Chronos-Foundation" selector="isTemporalCoordinate">isTemporalCoordinate	^false</body><body package="Chronos-Foundation" selector="isTimezone">isTimezone	^false</body></methods><methods><class-id>Chronos.ChronosObject</class-id> <category>private-comparing</category><body package="Chronos-Foundation" selector="isEqualToCalendarDuration:">isEqualToCalendarDuration: aCalendarDuration	^false</body><body package="Chronos-Foundation" selector="isEqualToCivilDuration:">isEqualToCivilDuration: aCivilDuration 	^false</body><body package="Chronos-Foundation" selector="isEqualToInfiniteDuration:">isEqualToInfiniteDuration: anInfiniteDuration	^false</body><body package="Chronos-Foundation" selector="isEqualToTimezone:">isEqualToTimezone: aTimezone 	^false</body></methods><methods><class-id>Chronos.ChronosObject class</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="appOrLibraryName">appOrLibraryName	^'Chronos'</body><body package="Chronos-Foundation" selector="calendarDurationFactory">calendarDurationFactory	^CalendarDurationFactory</body><body package="Chronos-Foundation" selector="civilDurationFactory">civilDurationFactory	^CivilDurationFactory</body><body package="Chronos-Foundation" selector="dateAndTimeFactory">dateAndTimeFactory	^DateAndTimeFactory</body><body package="Chronos-Foundation" selector="dateFactory">dateFactory	^DateFactory</body><body package="Chronos-Foundation" selector="durationFactory">durationFactory	^DurationFactory</body><body package="Chronos-Foundation" selector="timeOfDayFactory">timeOfDayFactory	^TimeOfDayFactory</body><body package="Chronos-Foundation" selector="timeperiodFactory">timeperiodFactory	^TimeperiodFactory</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="aliasingKeys">aliasingKeys	^Set new</body><body package="Chronos-TimeZones" selector="canonicalKey">canonicalKey	^self key</body><body package="Chronos-TimeZones" selector="comparisonClassIdentifier">comparisonClassIdentifier		"Answer a value that identifies the group of comparable values to which the receiver belongs.  The value might be a Smalltalk class, or might be a Symbol, or might be something else."	^#timezone</body><body package="Chronos-TimeZones" selector="defaultAnnualPolicy">defaultAnnualPolicy	"Answer the AnnuallyRecurringTZPolicy that specifies the time zone rules that are in effect during the current year."	^self subclassResponsibility</body><body package="Chronos-TimeZones" selector="key">key	"Answer the key that identifies the receiver."	^self subclassResponsibility</body><body package="Chronos-TimeZones" selector="name">name	"Answer the name of the receiver."	^self nameIfNone: [self zuluNotation]</body><body package="Chronos-TimeZones" selector="nameIfNone:">nameIfNone: noneBlock	"Answer the name of the receiver."	^self defaultNameIfNone: noneBlock</body><body package="Chronos-TimeZones" selector="namespaceIfNone:">namespaceIfNone: block0	^self keyIsGlobal ifTrue: [self class] ifFalse: [block0 value]</body><body package="Chronos-TimeZones" selector="namespaceKey">namespaceKey	^self subclassResponsibility</body><body package="Chronos-TimeZones" selector="root">root	^self</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>date/time-current time</category><body package="Chronos-TimeZones" selector="dateToday">dateToday	"Answer the YearMonthDay (bound to the Gregorian Calendar) that designates today's date in the local time defined by the receiver."	"Timezone default dateToday"	^(AnsiStandardCalendarClock mutableDateTodayIn: self) beImmutable</body><body package="Chronos-TimeZones" selector="dateTodayAs:">dateTodayAs: calendarOrCalendarReference	"Answer the YearMonthDay (bound to the specified &lt;calendarOrCalendarReference&gt;) that designates today's date in the local time defined by the receiver."	"Timezone default dateTodayAs: #Persian"	^((Calendar referencedBy: calendarOrCalendarReference) clock mutableDateTodayIn: self) beImmutable</body><body package="Chronos-TimeZones" selector="now">now	"Answer the Timepoint (bound to the Gregorian Calendar) that designates the current date and time in the local time defined by the receiver."	"Timezone default now"	^AnsiStandardCalendarClock nowIn: self</body><body package="Chronos-TimeZones" selector="nowAs:">nowAs: calendarOrCalendarReference	"Answer the Timepoint (bound to the specified &lt;calendarOrCalendarReference&gt;) that designates the current date and time in the local time defined by the receiver."	"Timezone default nowAs: #Persian"	^(Calendar referencedBy: calendarOrCalendarReference) clock nowIn: self</body><body package="Chronos-TimeZones" selector="nowToTheSecond">nowToTheSecond	"Answer the Timepoint (bound to the Gregorian Calendar) that designates the current date and time at the start of the current second in the local time defined by the receiver."	"Timezone default nowToTheSecond"	^AnsiStandardCalendarClock nowToTheSecondIn: self</body><body package="Chronos-TimeZones" selector="nowToTheSecondAs:">nowToTheSecondAs: calendarOrCalendarReference 	"Answer the Timepoint (bound to the specified &lt;calendarOrCalendarReference&gt;) that designates the current date and time at the start of the current second in the local time defined by the receiver."	"Timezone default nowToTheSecondAs: #Hebrew"	^(Calendar referencedBy: calendarOrCalendarReference) clock 		nowToTheSecondIn: self</body><body package="Chronos-TimeZones" selector="timeOfDayNow">timeOfDayNow	"Answer the TimeOfDay that designates the current time-of-day according to the Gregorian Calendar in the local time defined by the receiver."	"Timezone default timeOfDayNow"	^AnsiStandardCalendarClock timeOfDayNowIn: self</body><body package="Chronos-TimeZones" selector="timeOfDayNowAs:">timeOfDayNowAs: calendarOrCalendarReference	"Answer the TimeOfDay that designates the current time-of-day according to the specified &lt;calendarOrCalendarReference&gt; in the local time defined by the receiver."	"Timezone default timeOfDayNowAs: #Ethiopic" "(The time-of-day clock of the Ethiopic Calendar starts at sunrise--6am.)"	^(Calendar referencedBy: calendarOrCalendarReference) clock timeOfDayNowIn: self</body><body package="Chronos-TimeZones" selector="timeOfDayNowToTheSecond">timeOfDayNowToTheSecond	"Answer the TimeOfDay that designates the current time-of-day at the start of the current second according to the Gregorian Calendar in the local time defined by the receiver."	"Timezone default timeOfDayNowToTheSecond"	^AnsiStandardCalendarClock timeOfDayNowToTheSecondIn: self</body><body package="Chronos-TimeZones" selector="timeOfDayNowToTheSecondAs:">timeOfDayNowToTheSecondAs: aCalendarOrCalendarReference	"Answer the TimeOfDay that designates the current time-of-day at the start of the current second according to the specified &lt;calendarOrCalendarReference&gt; in the local time defined by the receiver."	"Timezone default timeOfDayNowToTheSecondAs: #Ethiopic" "(The time-of-day clock of the Ethiopic Calendar starts at sunrise--6am.)"	^(Calendar referencedBy: aCalendarOrCalendarReference) clock timeOfDayNowToTheSecondIn: self</body><body package="Chronos-TimeZones" selector="today">today	"Answer the Timepoint (bound to the Gregorian Calendar) that designates the first moment of today's date in the local time defined by the receiver."	"Timezone default today"	^AnsiStandardCalendarClock basicTodayIn: self</body><body package="Chronos-TimeZones" selector="todayAs:">todayAs: calendarOrCalendarReference	"Answer the Timepoint (bound to the specified &lt;calendarOrCalendarReference&gt;) that designates the first moment of today's date (as defined by the specified &lt;calendarOrCalendarReference&gt;) in the local time defined by the receiver."	"Timezone default todayAs: Julian"	^(Calendar referencedBy: calendarOrCalendarReference) clock basicTodayIn: self</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="hasSubsecondOffset">hasSubsecondOffset	"Answer whether the receiver has fractional seconds of offset."	^false</body><body package="Chronos-TimeZones" selector="isAlwaysDefault">isAlwaysDefault	"Answer whether the receiver is the `always default` time zone."	^false</body><body package="Chronos-TimeZones" selector="isAlwaysSystem">isAlwaysSystem	"Answer whether the receiver is the `always system` time zone."	^false</body><body package="Chronos-TimeZones" selector="isBound">isBound	"Answer whether the receiver is a bound time zone. A bound time zone is one that defines a single offset/abbreviation tuple, and that conforms to the `BOUND TIMEZONE API` (as defined in the class comment.)"	^self subclassResponsibility</body><body package="Chronos-TimeZones" selector="isDefault">isDefault	"Answer whether the receiver is the default time zone."	^self == self class default</body><body package="Chronos-TimeZones" selector="isDynamic">isDynamic	"Answer whether or not the timezone policy (key, offset, name and abbreviation) of the timezone represented by the receiver is subject to retroactive revision."	^self isStatic not</body><body package="Chronos-TimeZones" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to nominal time."	^false</body><body package="Chronos-TimeZones" selector="isInvariantToUT">isInvariantToUT	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to Universal Time."	^true</body><body package="Chronos-TimeZones" selector="isProxy">isProxy	"Answer whether the receiver operates as an indirect reference to some other time zone."	^false</body><body package="Chronos-TimeZones" selector="isProxyAndInvariantToUT">isProxyAndInvariantToUT	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to Universal Time, and whether the receiver operates as an indirect reference to some other time zone (if both are true, answer true, otherwise answer false.)"	^false</body><body package="Chronos-TimeZones" selector="isProxyOrStatic">isProxyOrStatic	"Answer whether the receiver is either a proxy time zone or a static time zone."	^false</body><body package="Chronos-TimeZones" selector="isStatic">isStatic	"Answer whether or not the timezone policy (key, offset, name and abbreviation) of the timezone represented by the receiver is invariant, constant and never subject to change or revision.  If the receiver's timezone policy is dynamically redefinable, answer false."	^false</body><body package="Chronos-TimeZones" selector="isSystem">isSystem	"Answer whether the receiver is the system time zone."	^self == self class system</body><body package="Chronos-TimeZones" selector="isTimezone">isTimezone	^true</body><body package="Chronos-TimeZones" selector="isUniversalTime">isUniversalTime	"Anwser whether the receiver has all the properties and behaviors of the international reference zero-offset time zone."	^false</body><body package="Chronos-TimeZones" selector="keyIsGlobal">keyIsGlobal	"Answer whether the receiver's identifying key is a globally well-known value."	^true</body><body package="Chronos-TimeZones" selector="specifiesAbbreviation">specifiesAbbreviation	^self specifiesCommonAbbreviation</body><body package="Chronos-TimeZones" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^false</body><body package="Chronos-TimeZones" selector="specifiesGeographicCoordinates">specifiesGeographicCoordinates	^false</body><body package="Chronos-TimeZones" selector="specifiesName">specifiesName	^false</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="asNative">asNative	"Answer the conversion of the receiver into whatever object/value would canonically be used by the host Smalltalk implementation to name/identify a time zone as equivalent to the receiver as is possible. If there is no such value, or if Chronos is the native date/time library of the host environment, answer the receiver."	^ChronosSystemFacade current nativeTimeZoneFromChronosTimeZone: self</body><body package="Chronos-TimeZones" selector="asNonProxy">asNonProxy	"Answer the time zone to which the receiver indirectly refers by proxy.  If the receiver is not a proxy for a time zone other than itself, answer the receiver."	^self</body><body package="Chronos-TimeZones" selector="asTimezone">asTimezone	"Answer the conversion of the receiver into a time zone it either references or describes. If the receiver is itself a time zone, answer the receiver."	^self</body><body package="Chronos-TimeZones" selector="asUnbound">asUnbound	"Answer the unbound time zone that specifies the full diachronic ruleset of the time zone represented by the receiver."	^self</body><body package="Chronos-TimeZones" selector="canonical">canonical	"Answer the canonical instance of the receiver's class whose value is equivalent to that of the receiver's."	^self</body><body package="Chronos-TimeZones" selector="renamedTo:">renamedTo: newName	"Answer an immutable copy of the receiver whose name will be &lt;newName&gt;."	^self copy		setName: newName;		beImmutable</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="beDefault">beDefault	"Set the receiver as the default time zone. If the receiver is the system time zone, cause the default time zone to virtually shadow the system time zone, so that whenever the system time zone is set to a different value, the default time zone is also set to the same new value."	self == System ifTrue: [Default := nil] ifFalse: [Default := self canonical]</body><body package="Chronos-TimeZones" selector="beSystem">beSystem	"Set the receiver as the system time zone. This operation may or may not affect the host Smalltalk environment and/or the host operating system. See the class of the current ChronosSystemFacade singleton to determine the behavior in the current environment and platform."	ChronosSystemFacade current 		systemTimeZone: self</body><body package="Chronos-TimeZones" selector="invalidatePolicy">invalidatePolicy 	"By default, do nothing"</body><body package="Chronos-TimeZones" selector="register">register	"By default, do nothing"</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>private</category><body package="Chronos-TimeZones" selector="defaultName">defaultName	^self defaultNameIfNone: [self zuluNotation]</body><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneBlock	^self subclassResponsibility</body><body package="Chronos-TimeZones" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut: self literalArrayEncodingOfKey</body><body package="Chronos-TimeZones" selector="keyIsAlias">keyIsAlias	^false</body><body package="Chronos-TimeZones" selector="literalArrayEncodingOfKey">literalArrayEncodingOfKey	^self key</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>queries</category><body package="Chronos-TimeZones" selector="annualPolicyForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^self defaultAnnualPolicy</body><body package="Chronos-TimeZones" selector="annualPolicyForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^self defaultAnnualPolicy</body><body package="Chronos-TimeZones" selector="binding">binding	"Answer the bound timezone referenced by the receiver.  If there is none, answer nil."	^nil</body><body package="Chronos-TimeZones" selector="bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in the local time defined by the receiver.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in local (`wall clock`) time as defined by the receiver."	^self</body><body package="Chronos-TimeZones" selector="bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in Universal Time.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in Universal Time."	^self</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>comparing</category><body package="Chronos-TimeZones" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	self == aMagnitude ifTrue: [^true].	^[aMagnitude isEqualToTimezone: self]		on: MessageNotUnderstood		do: [:ex | 			(ex receiver == aMagnitude and: [ex message selector == #isEqualToTimezone:])				ifTrue: [ex return: false]				ifFalse: [ex pass]]</body><body package="Chronos-TimeZones" selector="hash">hash	"Answer a SmallInteger that is equal to the hash value of 	any object that is equal to (=) the receiver. 	When two objects are not =, their hash values may or may not be the same.	The hash value may change based on the receiver's contents."	^self key hash</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>private-comparing</category><body package="Chronos-TimeZones" selector="isEqualToTimezone:">isEqualToTimezone: aTimezone 	^self key = aTimezone key</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>printing</category><body package="Chronos-TimeZones" selector="identityString">identityString	"Timezone default identityString"	| stream |	stream := WriteStream on: (String new: 16).	self isStatic 		ifTrue: [self printZuluNotationOn: stream]		ifFalse: [self printKeyOn: stream].	self specifiesName 		ifTrue: 			[stream				nextPutAll: ' | ';				nextPutAll: self name].	^stream contents</body><body package="Chronos-TimeZones" selector="printIdentificationOn:">printIdentificationOn: stream	stream		crtab;		nextPutAll: 'key='.	self printKeyOn: stream.		self specifiesName 		ifTrue: 			[stream				crtab;				nextPutAll: 'name=';				nextPutAll: self name]</body><body package="Chronos-TimeZones" selector="printKeyOn:">printKeyOn: stream	stream nextPutAll: self key</body><body package="Chronos-TimeZones" selector="printOn:">printOn: stream	stream nextPut: ${.	self printTypeOn: stream.	self printIdentificationOn: stream.	self printPolicyOn: stream.	stream nextPut: $}</body><body package="Chronos-TimeZones" selector="printPolicyOn:">printPolicyOn: stream 	self specifiesAbbreviation 		ifTrue: 			[stream				crtab;				nextPutAll: 'abbreviation=';				nextPutAll: self abbreviation].	stream		crtab;		nextPutAll: 'offsetFromUT='.	self printOffsetOn: stream.</body><body package="Chronos-TimeZones" selector="printTypeOn:">printTypeOn: stream	stream nextPutAll: self class name</body></methods><methods><class-id>Chronos.ChronosTimezone</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="convertGMT:do:">convertGMT: utSecondsSinceST80Epoch do: block2 	^self subclassResponsibility</body><body package="Chronos-ST80 (and VW) Compatibility" selector="convertToGMT:do:">convertToGMT: localSecondsSinceST80Epoch do: block2	^self subclassResponsibility</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>class initialization</category><body package="Chronos-TimeZones" selector="initialize">initialize	"ChronosTimezone initialize" 	Universal := nil.	Nominal := nil.	AlwaysSystem := nil.	AlwaysDefault := nil.	self invalidateSystemTimezone.	self invalidateDefaultTimezone.</body><body package="Chronos-TimeZones" selector="invalidate">invalidate	"ChronosTimezone invalidate" 	self initialize.	VariableOffsetTimezone invalidate.</body><body package="Chronos-TimeZones" selector="invalidateBoundDynamicFlyweights">invalidateBoundDynamicFlyweights	"Discard any cached `bound, dynamic` time zone instances from the registry (does not affect operational correctness.)"	BindingRegistry := nil</body><body package="Chronos-TimeZones" selector="invalidateDefaultTimezone">invalidateDefaultTimezone	"Reset the receiver's reference to the default time zone (idempotent.)"	"Timezone invalidateDefaultTimezone"	Default == nil 		ifFalse: 			[Default				invalidatePolicy;				register]</body><body package="Chronos-TimeZones" selector="invalidateOffsetFlyweights">invalidateOffsetFlyweights	"Discard any cached offsets from the registry (does not affect operational correctness.)"	OffsetRegistry := nil</body><body package="Chronos-TimeZones" selector="invalidateSystemTimezone">invalidateSystemTimezone	"Reset the receiver's reference to the system time zone (idempotent.)"	"Timezone invalidateSystemTimezone"	System := nil</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>private</category><body package="Chronos-TimeZones" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body><body package="Chronos-TimeZones" selector="newAlwaysDefault">newAlwaysDefault	^AlwaysDefaultTZ		new beImmutable</body><body package="Chronos-TimeZones" selector="newAlwaysSystem">newAlwaysSystem	^AlwaysSystemTZ		new beImmutable</body><body package="Chronos-TimeZones" selector="newNominalTimeInvariantTZ">newNominalTimeInvariantTZ	^NominalTime new</body><body package="Chronos-TimeZones" selector="newUniversalTime">newUniversalTime	^UniversalTime 		new beImmutable</body><body package="Chronos-TimeZones" selector="offsetFromSeconds:">offsetFromSeconds: seconds	| offset |	offset := self offsetRegistry at: seconds ifAbsent: [0].	(offset == nil or: [offset = 0])		ifTrue: [self offsetRegistry at: seconds put: (offset := (seconds = 0 ifTrue: [ZeroDuration] ifFalse: [DurationFactory seconds: seconds]))].	^offset		"^seconds = 0 ifTrue: [ZeroDuration] ifFalse: [DurationFactory seconds: seconds]"</body><body package="Chronos-TimeZones" selector="offsetRegistry">offsetRegistry	OffsetRegistry == nil ifTrue: [OffsetRegistry := EnvironmentFacade current newWeakDictionary].	^OffsetRegistry</body><body package="Chronos-TimeZones" selector="resolveSystem">resolveSystem	^ChronosSystemFacade current systemTimeZone</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="alwaysDefault">alwaysDefault	"Answer the `always default` time zone."	"Timezone alwaysDefault"	AlwaysDefault == nil ifTrue: [AlwaysDefault := self newAlwaysDefault].	^AlwaysDefault</body><body package="Chronos-TimeZones" selector="alwaysSystem">alwaysSystem	"Answer the `always system` time zone."	"Timezone alwaysSystem"	AlwaysSystem == nil ifTrue: [AlwaysSystem := self newAlwaysSystem].	^AlwaysSystem</body><body package="Chronos-TimeZones" selector="at:">at: aChronosTimeZoneKey 	"Answer the time zone whose key is &lt;aChronosTimeZoneKey&gt;.  If there is no time zone with the specified key, signal an exception."	"Timezone at: 3600"	"Timezone at: 'Asia/Rangoon'"	"Timezone at: 'America/Los_Angeles'"	"Timezone at: 'Europe/Berlin'"	"Timezone allRegisteredKeys"	^aChronosTimeZoneKey respondsToArithmetic 		ifTrue: [(DurationFactory seconds: aChronosTimeZoneKey) asTimezone]		ifFalse: [VariableOffsetTimezone at: aChronosTimeZoneKey]</body><body package="Chronos-TimeZones" selector="at:ifAbsent:">at: aTimeZoneKey ifAbsent: absentAction	"Answer the time zone whose key is &lt;aChronosTimeZoneKey&gt;.  If there is no time zone with the specified key, answer the result of evaluating &lt;absentAction&gt;."	"Timezone at: 'Asia/Shanghai' ifAbsent: []"	"Timezone at: 'America/New_York' ifAbsent: []"	"Timezone at: 'Europe/Prague' ifAbsent: []"	"Timezone at: 'Luna/Tycho' ifAbsent: []"	"Timezone allRegisteredKeys"	^aTimeZoneKey respondsToArithmetic 		ifTrue: [(DurationFactory seconds: aTimeZoneKey) asTimezone]		ifFalse: [VariableOffsetTimezone at: aTimeZoneKey ifAbsent: absentAction]</body><body package="Chronos-TimeZones" selector="atAbbreviation:dstPreferred:ifAbsent:">atAbbreviation: commonTzAbbreviation dstPreferred: dstPreferred ifAbsent: absentAction 	"Answer the Olson time zone mapped to the time zone abbreviation &lt;commonTzAbbreviation&gt; by the current default TimeZoneLocalizationPolicy, with a preference for a time zone that observes DST if &lt;dstPreferred&gt; is true, but otherwise with a preference for a time zone that does not observe DST. A time zone whose DST behavior matches the specified preference may or may not be availlable; if it is not, then one will be answered with whatever DST behavior is available for &lt;commonTzAbbreviation&gt;.  If the default TimeZoneLocalizationPolicy defines no  mapping for &lt;commonTzAbbreviation&gt; (or if the mapping specifies a non-existent Olson time zone,) answer the result of evaluating &lt;absentAction&gt;."	"Timezone atAbbreviation: #HOVT dstPreferred: true ifAbsent: []"	"Timezone atAbbreviation: #MST dstPreferred: false ifAbsent: []"	"Timezone atAbbreviation: #MST dstPreferred: true ifAbsent: []"	^self 		atAbbreviation: commonTzAbbreviation		usingLocalizationPolicy: TimeZoneLocalizationPolicy default		dstPreferred: dstPreferred		ifAbsent: absentAction</body><body package="Chronos-TimeZones" selector="atAbbreviation:inLocale:dstPreferred:ifAbsent:">atAbbreviation: commonTzAbbreviation inLocale: aChronosLocale dstPreferred: dstPreferred ifAbsent: absentAction 	"Answer the Olson time zone mapped to the time zone abbreviation &lt;commonTzAbbreviation&gt; by &lt;aChronosLocale&gt;'s TimeZoneLocalizationPolicy, with a preference for a time zone that observes DST if &lt;dstPreferred&gt; is true, but otherwise with a preference for a time zone that does not observe DST. A time zone whose DST behavior matches the specified preference may or may not be availlable; if it is not, then one will be answered with whatever DST behavior is available for &lt;commonTzAbbreviation&gt;.  If &lt;aChronosLocale&gt;'s TimeZoneLocalizationPolicy defines no  mapping for &lt;commonTzAbbreviation&gt; (or if the mapping specifies a non-existent Olson time zone,) answer the result of evaluating &lt;absentAction&gt;."	"Timezone atAbbreviation: #EST inLocale: #en_AU dstPreferred: true ifAbsent: []"	"Timezone atAbbreviation: #EST inLocale: #en_US dstPreferred: false ifAbsent: []"	"Timezone atAbbreviation: #EST inLocale: #en_US dstPreferred: true ifAbsent: []"	"Timezone atAbbreviation: #PST inLocale: #en_CA dstPreferred: true ifAbsent: []"	^self 		atAbbreviation: commonTzAbbreviation		usingLocalizationPolicy: (ChronosLocale referencedBy: aChronosLocale) timeZoneLocalizationPolicy		dstPreferred: dstPreferred		ifAbsent: absentAction</body><body package="Chronos-TimeZones" selector="atAbbreviation:usingLocalizationPolicy:dstPreferred:ifAbsent:">atAbbreviation: commonTzAbbreviation usingLocalizationPolicy: aTimeZoneLocalizationPolicy dstPreferred: dstPreferred ifAbsent: absentAction 	"Answer the Olson time zone mapped to the time zone abbreviation &lt;commonTzAbbreviation&gt; by &lt;aTimeZoneLocalizationPolicy&gt;, with a preference for a time zone that observes DST if &lt;dstPreferred&gt; is true, but otherwise with a preference for a time zone that does not observe DST. A time zone whose DST behavior matches the specified preference may or may not be availlable; if it is not, then one will be answered with whatever DST behavior is available for &lt;commonTzAbbreviation&gt;.  If &lt;aTimeZoneLocalizationPolicy&gt; defines no  mapping for &lt;commonTzAbbreviation&gt; (or if the mapping specifies a non-existent Olson time zone,) answer the result of evaluating &lt;absentAction&gt;."	"Timezone atAbbreviation: #CET 		usingLocalizationPolicy: TimeZoneLocalizationPolicy root 			dstPreferred: true 	ifAbsent: []"	"Timezone atAbbreviation: #EET 		usingLocalizationPolicy: TimeZoneLocalizationPolicy root 			dstPreferred: true 	ifAbsent: []"	"Timezone atAbbreviation: #HAST 	usingLocalizationPolicy: TimeZoneLocalizationPolicy unitedStates dstPreferred: true 	ifAbsent: []"	"Timezone atAbbreviation: #HAST 	usingLocalizationPolicy: TimeZoneLocalizationPolicy unitedStates dstPreferred: false 	ifAbsent: []"	"Timezone atAbbreviation: #CST 		usingLocalizationPolicy: TimeZoneLocalizationPolicy root			dstPreferred: true 	ifAbsent: []"	"Timezone atAbbreviation: #CST 		usingLocalizationPolicy: TimeZoneLocalizationPolicy unitedStates dstPreferred: true 	ifAbsent: []"	^self 		at: ((TimeZoneLocalizationPolicy referencedBy: aTimeZoneLocalizationPolicy) 				defaultTimeZoneKeyWithCommonAbbreviation: commonTzAbbreviation asSymbol				dstPreferred: dstPreferred				ifAbsent: [^absentAction value])		ifAbsent: absentAction</body><body package="Chronos-TimeZones" selector="default">default	"Answer the Chronos `default time zone` that implements the `implementation-defined local time` as specified and required by the ANSI-Smalltalk Standard.  The Chronos default time zone will be identical to the Chronos system time zone, unless the default time zone is explicitly (programmatically) set to a different value."	"Timezone default"	Default == nil ifTrue: [^self system].	^Default</body><body package="Chronos-TimeZones" selector="gmt">gmt	"Answer the time zone that defines Universal Time--the international reference zero-offset time zone."	"Timezone gmt"	^self universal</body><body package="Chronos-TimeZones" selector="nominal">nominal	"Answer the time zone that defines/specifies nominal time invariance."	"Timezone nominal"	Nominal == nil ifTrue: [Nominal := self newNominalTimeInvariantTZ].	^Nominal</body><body package="Chronos-TimeZones" selector="referencedBy:">referencedBy: aTimeZoneOrTimeZoneKey 	"Anser the value referenced by &lt;aChronosObjectOrChronosObjectLiteralString&gt;. If the value is a key, answer the value bound to the key. If the value is a literal representation of a value encoded as a String, answer the result of decoding the value encoded by the String.  Otherwise, answer aChronosObjectOrChronosObjectLiteralString itself."	^aTimeZoneOrTimeZoneKey == nil 		ifTrue: [self default]		ifFalse: 			[(aTimeZoneOrTimeZoneKey isString or: [aTimeZoneOrTimeZoneKey respondsToArithmetic])				ifTrue: [self at: aTimeZoneOrTimeZoneKey]				ifFalse: [aTimeZoneOrTimeZoneKey asTimezone root]]</body><body package="Chronos-TimeZones" selector="system">system	"Answer the Chronos `system time zone` that is intended to match the behavior of the host system's local time zone as cloesely as possible.  The Chronos system time zone will be identical to the Chronos default time zone, unless the Chronos default time zone is explicitly (programmatically) set to a different value.	The Chronos system time zone may be explicitly (programatically) set to any Chronos time zone, regardless of the time zone used by the host system to define local time.  Doing so may or may not also change the host system's local time zone, depending on the specific implementation of the current ChronosSystemFacade singleton.  Also, when an image is restarted, the current ChronosSystemFacade singleton may reset the Chronos system time zone to match the host system's local time zone (as best it can,) but how and whether that happens depends upon both its current system-time-zone-binding strategy (which is programatically settable) and its specific implementation (which varies from one environment/platform to another.)"	"Timezone system"	System == nil 		ifTrue: 			[System := self resolveSystem.			System register].	^System</body><body package="Chronos-TimeZones" selector="universal">universal	"Answer the time zone that defines Universal Time--the international reference zero-offset time zone."	"Timezone universal"	Universal == nil ifTrue: [Universal := self newUniversalTime].	^Universal</body><body package="Chronos-TimeZones" selector="ut">ut	"Answer the time zone that defines Universal Time--the international reference zero-offset time zone."	"Timezone ut"	^self universal</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>private-bound, dynamic time zones</category><body package="Chronos-TimeZones" selector="bindingForKey:offsetSecondsFromUT:stdTimeOffsetSecondsFromUT:commonAbbreviation:">bindingForKey: timeZoneKey offsetSecondsFromUT: offsetSeconds stdTimeOffsetSecondsFromUT: stdTimeOffsetSeconds commonAbbreviation: abbreviation 	"Answer a `bound, dynamic` ChronosTimezone whose time zone key is &lt;timeZoneKey&gt;, whose offset (in seconds) from UT is &lt;offsetSeconds&gt;, whose offset (in seconds) from UT when `standard time` is in effect is &lt;stdTimeOffsetSeconds&gt; and whose common abbreviation is &lt;abbreviation&gt;. The `root time zone` of &lt;anAnnuallyRecurringTZPolicy&gt; ('anAnnuallyRecurringTZPolicy root') is the ChronosTimezone that a) defines the instance's key (identity,) and b) defines the full diachronic ruleset of the time zone for which the instance defines but a single atomic component."	| registrationKey subRegistry offsetDeltaSeconds binding bindingKey |	registrationKey := self bindingRegistryKeyForTimeZoneKey: timeZoneKey				commonAbbreviation: abbreviation.	subRegistry := self bindingRegistry at: registrationKey				ifAbsentPut: [EnvironmentFacade current newWeakDictionary].	offsetDeltaSeconds := offsetSeconds - stdTimeOffsetSeconds.	binding := subRegistry at: (bindingKey := offsetDeltaSeconds * SecondsPerDay + offsetSeconds) ifAbsent: [0].	(binding == nil or: [binding = 0])		ifTrue:			[subRegistry 				at: bindingKey				put: (binding := 							self 								newBindingForKey: timeZoneKey								offsetSecondsFromUT: offsetSeconds								stdTimeOffsetSecondsFromUT: stdTimeOffsetSeconds								commonAbbreviation: abbreviation)].	^binding</body><body package="Chronos-TimeZones" selector="bindingRegistry">bindingRegistry	BindingRegistry == nil ifTrue: [BindingRegistry := IdentityDictionary new].	^BindingRegistry</body><body package="Chronos-TimeZones" selector="bindingRegistryKeyForTimeZoneKey:commonAbbreviation:">bindingRegistryKeyForTimeZoneKey: aTimeZoneKey commonAbbreviation: abbreviation	| stream |	stream := (String new: 37) writeStream.	stream		nextPutAll: (aTimeZoneKey isString ifTrue: [aTimeZoneKey] ifFalse: [aTimeZoneKey printString]);		nextPut: $:;		nextPutAll: abbreviation.	^stream contents asSymbol</body><body package="Chronos-TimeZones" selector="newBindingForKey:offsetSecondsFromUT:stdTimeOffsetSecondsFromUT:commonAbbreviation:">newBindingForKey: aTimeZoneKey offsetSecondsFromUT: offsetSeconds stdTimeOffsetSecondsFromUT: stdTimOffsetSeconds commonAbbreviation: abbreviation 	"Answer a new `bound, dynamic` ChronosTimezone whose time zone key is &lt;aTimeZoneKey&gt;, whose offset (in seconds) from UT is &lt;offsetSeconds&gt;, whose offset (in seconds) from UT when `standard time` is in effect is &lt;stdTimeOffsetSeconds&gt; and whose common abbreviation is &lt;abbreviation&gt;. The `root time zone` of &lt;anAnnuallyRecurringTZPolicy&gt; ('anAnnuallyRecurringTZPolicy root') is the ChronosTimezone that a) defines the instance's key (identity,) and b) defines the full diachronic ruleset of the time zone for which the instance defines but a single atomic component."	^offsetSeconds = stdTimOffsetSeconds 		ifTrue: 			[StandardTime new				setKey: aTimeZoneKey					offsetSeconds: offsetSeconds					commonAbbreviation: abbreviation;				beImmutable]		ifFalse: 			[NonStandardTime new				setKey: aTimeZoneKey					offsetSeconds: offsetSeconds					stdTimeOffsetSeconds: stdTimOffsetSeconds					commonAbbreviation: abbreviation;				beImmutable]</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>instance creation</category><body package="Chronos-TimeZones" selector="key:name:initialOffset:withAbbreviation:until:at:relativity:thenOffset:withAbbreviation:until:at:relativity:">key: aKey name: aStringOrSymbol initialOffset: offset1FromUT withAbbreviation: abbreviation1 until: annualTransitionDate1 at: timeOfDay1 relativity: relativity1 thenOffset: offset2FromUT withAbbreviation: abbreviation2 until: annualTransitionDate2 at: timeOfDay2 relativity: relativity2 	"Answer a new `unbound, dynamic` ChronosTimezone with one inter-year ruleset consisting of two intra-year offset/abbreviation transitions that repeat annually. The answered instance's single inter-year ruleset with two intra-year annual transitions will apply every year, from the infinite past to the infinite future. The answered instance will have the specfied &lt;key&gt; and &lt;name&gt; (Symbols or Strings; the keys #alwaysSystem, #alwaysDefault and #nominal are not allowed.) The name may nil, in which case the answered instance's name will be its key.	From the beginning of the year until the first offset/abbreviation transition, the answered instance's offset from UT will be &lt;offset1FromUT&gt; (a Duration) and its abbreviation will be &lt;abbreviation1&gt; (a Symbol.)  The first transtion will occur on &lt;annualTransitionDate1&gt; (an AnnualDate) at &lt;timeOfDay1&gt; (a TimeOfDay).  If &lt;relativity1&gt; == #nominal, then the specified date and time of the first transition reflect local `wall clock` time as defined by the answered instance.   If &lt;relativity1&gt; == #standard, then the specified date and time of the first transition reflect local `standard time` as defined by the answered instance (i.e., without DST.)  If &lt;relativity1&gt; == #universal, then the specified date and time reflect the Universal Time when the first transition occurs.	From the first offset/abbreviation transition until the second offset/abbreviation transition,  the answered instance's offset from UT will be &lt;offset2FromUT&gt; (a Duration) and its abbreviation will be &lt;abbreviation2&gt; (a Symbol.)  The second transtion will occur on &lt;annualTransitionDate2&gt; (an AnnualDate) at &lt;timeOfDay2&gt; (a TimeOfDay).  If &lt;relativity2&gt; == #nominal, then the specified date and time of the second transition reflect local `wall clock` time as defined by the answered instance.   If &lt;relativity2&gt; == #standard, then the specified date and time of the second transition reflect local `standard time`  as defined by the answered instance (i.e., without DST.)  If &lt;relativity2&gt; == #universal, then the specified date and time reflect the Universal Time when the second transition occurs.	After the second offset/abbreviation transition and until the end of the year,  the answered instance's offset from UT will again be &lt;offset1FromUT&gt; (a Duration) and its abbreviation will again be &lt;abbreviation2&gt; (a Symbol.) 	HOWEVER, the parameters may be supplied in inverted order: If &lt;annualTransitionDate1&gt; occurs later in the year than &lt;annualTransitionDate2&gt;, then the role of &lt;offset1FromUT&gt; is swapped with that of &lt;offset2FromUT&gt;, the role of &lt;abbreviation1&gt; is swapped with that of &lt;abbreviation2&gt;, the role of &lt;annualTransitionDate1&gt; is swapped with that of &lt;annualTransitionDate2&gt;, the role of &lt;timeOfDay1&gt; is swapped with that of &lt;timeOfDay2&gt; and the role of &lt;relativity1&gt; is swapped with that of &lt;relativity2&gt;"	"{(Timezone		key: #myOwnPrivateTimeZone name: #NorthernHemispereInvertedOrder		initialOffset: (Duration hours: -7) withAbbreviation: #WDT 			until: (WeekOfMonthDayOfWeek month: 11 week: 0 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #nominal		thenOffset: (Duration hours: -8)  withAbbreviation: #WST  			until: (WeekOfMonthDayOfWeek month: 3 week: 1 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #standard) 				nowToTheSecond printStringUsing: #verbose}"	"{(Timezone		key: #someonElsesPrivateTimeZone name: #SouthernHemisphereNormalOrder		initialOffset: (Duration hours: 10) withAbbreviation: #WADT 			until: (WeekOfMonthDayOfWeek month: 4 week: 0 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #universal		thenOffset: (Duration hours: 9)  withAbbreviation: #WAST  			until: (WeekOfMonthDayOfWeek month: 9 week: 1 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #universal)				nowToTheSecond literalArrayEncoding decodeAsLiteralArray printStringUsing: #verbose}"	^VariableOffsetTimezone 		key: aKey		name: aStringOrSymbol		initialOffset: offset1FromUT		withAbbreviation: abbreviation1		until: annualTransitionDate1		at: timeOfDay1		relativity: relativity1		thenOffset: offset2FromUT		withAbbreviation: abbreviation2		until: annualTransitionDate2		at: timeOfDay2		relativity: relativity2</body><body package="Chronos-TimeZones" selector="offset:">offset: aDuration	"Answer a `bound, static` ChronosTimezone whose offset from UT is &lt;aDuration&gt;."	"{Timezone ofset: (Duration hours: -7)}"	^BasicTimezone offset: aDuration</body><body package="Chronos-TimeZones" selector="offset:commonAbbreviation:">offset: aDuration commonAbbreviation: aSymbol	"Answer a `bound, static` ChronosTimezone whose offset from UT is &lt;aDuration&gt; and whose common abbreviation is &lt;aSymbol&gt;."	"{Timezone		offset: (Duration hours: -7)		commonAbbreviation: #MST}"	^BasicTimezone		offset: aDuration 		commonAbbreviation: aSymbol</body><body package="Chronos-TimeZones" selector="offset:name:commonAbbreviation:">offset: aDuration name: aStringOrSymbol commonAbbreviation: aSymbol 	"Answer a `bound, static` ChronosTimezone whose offset from UT is &lt;aDuration&gt;, whose name is &lt;aStringOrSymbol&gt; and whose common abbreviation is &lt;aSymbol&gt;."	"{Timezone		offset: (Duration hours: -7)		name: 'US Mountain Time (Arizona)'		commonAbbreviation: #MST}"	^BasicTimezone 		offset: aDuration		name: aStringOrSymbol		commonAbbreviation: aSymbol</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>validation</category><body package="Chronos-TimeZones" selector="assertValidityOfTimezoneKey:">assertValidityOfTimezoneKey: aTimeZoneKey	"Assert that &lt;aTimeZoneKey&gt; is a valid Chronos time zone key (in the context of the current execution environment.) If it is, do nothing. If it is not, raise an Exception."	aTimeZoneKey respondsToArithmetic		ifFalse: 			[VariableOffsetTimezone assertValidityOfTimezoneKey: aTimeZoneKey]</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>queries</category><body package="Chronos-TimeZones" selector="allAliasedKeys">allAliasedKeys	"Answer a Set of the canonical keys that have aliases (alternative keys) for all the time zones persistently stored in the Chronos time-zones repository (to which this execution environment is attached.)"	^TimeZonePolicyFactory allAliasedKeys</body><body package="Chronos-TimeZones" selector="allAliasingKeys">allAliasingKeys	"Answer a Set of the aliasing (non-canonical) keys of all the time zones persistently stored in the Chronos time-zones repository (to which this execution environment is attached.)"	^TimeZonePolicyFactory allAliasingKeys</body><body package="Chronos-TimeZones" selector="allCanonicalKeys">allCanonicalKeys	"Answer a Set of the canonical (non-aliasing) keys of all the time zones persistently stored in the Chronos time-zones repository (to which this execution environment is attached.)"	^TimeZonePolicyFactory allCanonicalKeys</body><body package="Chronos-TimeZones" selector="allRegisteredKeys">allRegisteredKeys	"Answer a Set of the keys of all the time zones persistently stored in the Chronos time-zones repository (to which this execution environment is attached.)"	^TimeZonePolicyFactory allRegisteredKeys</body><body package="Chronos-TimeZones" selector="canonicalKeyAt:ifNone:">canonicalKeyAt: aKey ifNone: ifNone	^TimeZonePolicyFactory canonicalKeyAt: aKey ifNone: ifNone</body></methods><methods><class-id>Chronos.ChronosTimezone class</class-id> <category>examples</category><body package="Chronos-TimeZones" selector="commonWorldTimezones">commonWorldTimezones	"ChronosTimezone commonWorldTimezones"	^#('Pacific/Auckland' 'Australia/Sydney' 'Asia/Tokyo' 'Australia/Perth' 'Asia/Hong_Kong' 'Asia/Calcutta' 'Europe/Moscow' 	'Asia/Jerusalem' 'Europe/Amsterdam' 'Europe/London' UT 'America/Sao_Paulo' 'America/Argentina/Buenos_Aires'	'America/New_York' 'America/Chicago' 'America/Denver' 'America/Los_Angeles' 'Pacific/Honolulu') 		collect: [:tzKey | self at: tzKey]</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="abbreviation">abbreviation	"Answer the abbreviation for the timezone represented by the receiver--according to the default locale if possible."	^self asNonProxy abbreviation</body><body package="Chronos-TimeZones" selector="commonAbbreviation">commonAbbreviation	"Answer the common abbreviation for the timezone represented by the receiver."	^self asNonProxy commonAbbreviation</body><body package="Chronos-TimeZones" selector="defaultAnnualPolicy">defaultAnnualPolicy	"Answer the AnnuallyRecurringTZPolicy that specifies the time zone rules that are in effect during the current year."	^self asNonProxy defaultAnnualPolicy</body><body package="Chronos-TimeZones" selector="key">key	"Answer the key that identifies the receiver."	^self class registrationKey</body><body package="Chronos-TimeZones" selector="name">name	^self nameIfNone: [self key]</body><body package="Chronos-TimeZones" selector="nameIfNone:">nameIfNone: noneBlock	^ChronosLocale default properNameAtSemanticKey: self key ifAbsent: [self defaultNameIfNone: noneBlock]</body><body package="Chronos-TimeZones" selector="namespaceKey">namespaceKey	^#proxy</body><body package="Chronos-TimeZones" selector="offsetFromUT">offsetFromUT	^self asNonProxy offsetFromUT</body><body package="Chronos-TimeZones" selector="offsetSecondsFromUT">offsetSecondsFromUT	^self asNonProxy offsetSecondsFromUT</body><body package="Chronos-TimeZones" selector="stdTimeOffsetFromUT">stdTimeOffsetFromUT	^self asNonProxy stdTimeOffsetFromUT</body><body package="Chronos-TimeZones" selector="stdTimeOffsetSecondsFromUT">stdTimeOffsetSecondsFromUT	^self asNonProxy stdTimeOffsetSecondsFromUT</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processProxyTimezone: self</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>queries</category><body package="Chronos-TimeZones" selector="annualPolicyForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^self asNonProxy 		annualPolicyForLocalYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones" selector="annualPolicyForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^self asNonProxy 		annualPolicyForUTYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones" selector="binding">binding	"Answer the bound timezone referenced by the receiver.  If there is none, answer nil."	| delegate |	delegate := self asNonProxy.	^delegate isBound ifTrue: [delegate binding]</body><body package="Chronos-TimeZones" selector="bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in the local time defined by the receiver.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in local (`wall clock`) time as defined by the receiver."	^self asNonProxy bindingForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones" selector="bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in Universal Time.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in Universal Time."	^self asNonProxy bindingForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="asNonProxy">asNonProxy	"Answer the time zone to which the receiver indirectly refers by proxy.  If the receiver is not a proxy for a time zone other than itself, answer the receiver."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isBound">isBound	"Answer whether the receiver is a bound time zone. A bound time zone is one that defines a single offset/abbreviation tuple, and that conforms to the `BOUND TIMEZONE API` (as defined in the class comment of ChronosTimezone.)"	^false</body><body package="Chronos-TimeZones" selector="isProxy">isProxy	"Answer whether the receiver operates as an indirect reference to some other time zone."	^true</body><body package="Chronos-TimeZones" selector="isProxyAndInvariantToUT">isProxyAndInvariantToUT	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to Universal Time, and whether the receiver operates as an indirect reference to some other time zone (if both are true, answer true, otherwise answer false.)"	^true</body><body package="Chronos-TimeZones" selector="isProxyOrStatic">isProxyOrStatic	"Answer whether the receiver is either a proxy time zone or a static time zone."	^true</body><body package="Chronos-TimeZones" selector="specifiesName">specifiesName	^true</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="beDefault">beDefault	"Set the time zone indirectly referenced by the receiver as the default time zone. If the time zone indirectly referenced by the receiver is the system time zone, cause the default time zone to virtually shadow the system time zone, so that whenever the system time zone is set to a different value, the default time zone is also set to the same new value."	self asNonProxy beDefault</body><body package="Chronos-TimeZones" selector="beSystem">beSystem	"Set the time zone indirectly referenced by the receiver as the system time zone. This operation may or may not affect the host Smalltalk environment and/or the host operating system. See the class of the current ChronosSystemFacade singleton to determine the behavior in the current environment and platform."	self asNonProxy beSystem</body><body package="Chronos-TimeZones" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	self beImmutable</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>printing</category><body package="Chronos-TimeZones" selector="printOn:">printOn: stream	stream nextPutAll: self name.</body><body package="Chronos-TimeZones" selector="printPolicyOn:">printPolicyOn: stream 	self asNonProxy printPolicyOn: stream</body></methods><methods><class-id>Chronos.ProxyTZ</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="convertGMT:do:">convertGMT: utSecondsSinceST80Epoch do: block2  	^self asNonProxy convertGMT: utSecondsSinceST80Epoch do: block2</body><body package="Chronos-ST80 (and VW) Compatibility" selector="convertToGMT:do:">convertToGMT: localSecondsSinceST80Epoch do: block2 	^self asNonProxy convertToGMT: localSecondsSinceST80Epoch do: block2</body></methods><methods><class-id>Chronos.ProxyTZ class</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="registrationKey">registrationKey	"Anser the canonical key that uniquely identifies the receiver's canonical instance."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.NominalTime</class-id> <category>private-comparing</category><body package="Chronos-TimeZones" selector="isEqualToTimezone:">isEqualToTimezone: aTimezone 	^true</body></methods><methods><class-id>Chronos.NominalTime</class-id> <category>comparing</category><body package="Chronos-TimeZones" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	self == aMagnitude ifTrue: [^true].	^[aMagnitude isTimezone]		on: MessageNotUnderstood		do: [:ex | 			(ex receiver == aMagnitude and: [ex message selector == #isTimezone])				ifTrue: [ex return: false]				ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.NominalTime</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to nominal time."	^true</body><body package="Chronos-TimeZones" selector="isInvariantToUT">isInvariantToUT	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to Universal Time."	^false</body><body package="Chronos-TimeZones" selector="isProxyAndInvariantToUT">isProxyAndInvariantToUT	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to Universal Time, and whether the receiver operates as an indirect reference to some other time zone (if both are true, answer true, otherwise answer false.)"	^false</body></methods><methods><class-id>Chronos.NominalTime</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processNominalTime: self</body></methods><methods><class-id>Chronos.NominalTime</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="asNonProxy">asNonProxy	"Answer the time zone to which the receiver indirectly refers by proxy.  If the receiver is not a proxy for a time zone other than itself, answer the receiver."	^ChronosTimezone default</body><body package="Chronos-TimeZones" selector="canonical">canonical	"Answer the canonical instance of the receiver's class whose value is equivalent to that of the receiver's."	^ChronosTimezone nominal</body></methods><methods><class-id>Chronos.NominalTime</class-id> <category>private</category><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneblock	^'Nominal Time'</body></methods><methods><class-id>Chronos.NominalTime class</class-id> <category>private</category><body package="Chronos-TimeZones" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self nominal</body></methods><methods><class-id>Chronos.NominalTime class</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="registrationKey">registrationKey	"Anser the canonical key that uniquely identifies the receiver's canonical instance."	^#nominal</body></methods><methods><class-id>Chronos.RangeConstraint</class-id> <category>initialize-release</category><body package="Chronos-Foundation" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	rangeViolationHandler == nil		ifTrue: [self setRangeViolationHandler: self defaultRangeViolationHandler].</body><body package="Chronos-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	minValidValue := 0.	maxValidValue := 0.	self setRangeViolationHandler: self defaultRangeViolationHandler.</body><body package="Chronos-Foundation" selector="setMaxValidValue:">setMaxValidValue: aMagnitude	self assertMutability.	maxValidValue := aMagnitude</body><body package="Chronos-Foundation" selector="setMinValidValue:">setMinValidValue: aMagnitude	self assertMutability.	minValidValue := aMagnitude</body><body package="Chronos-Foundation" selector="setRangeViolationHandler:">setRangeViolationHandler: block3	self assertMutability.	rangeViolationHandler := block3</body><body package="Chronos-Foundation" selector="setSemanticKey:">setSemanticKey: aKey	self assertMutability.	semanticKey := aKey</body></methods><methods><class-id>Chronos.RangeConstraint</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="maxValidValue">maxValidValue	^maxValidValue</body><body package="Chronos-Foundation" selector="minValidValue">minValidValue	^minValidValue</body><body package="Chronos-Foundation" selector="rangeViolationHandler">rangeViolationHandler	^rangeViolationHandler</body><body package="Chronos-Foundation" selector="semanticKey">semanticKey	^semanticKey</body></methods><methods><class-id>Chronos.RangeConstraint</class-id> <category>private</category><body package="Chronos-Foundation" selector="defaultRangeViolationHandler">defaultRangeViolationHandler	^[:value :min :max | 		value == nil ifTrue: [^self signalError: 'The value ', value printString, ' for the ', semanticKey printString, ' attribute is not valid.'].		min == nil			ifTrue: [self signalError: (self stringForValue: value), ' exceeds the maximum valid value of the ', semanticKey printString, ' attribute (max=', (self stringForValue: max), ')']			ifFalse:				[max == nil					ifTrue: [self signalError: (self stringForValue: value), ' is less than the minimum valid value of the ', semanticKey printString, ' attribute (min=', (self stringForValue: min), ')']					ifFalse: 						[value &lt; min							ifTrue:[self signalError: (self stringForValue: value), ' is less than the minimum valid value of the ', semanticKey printString, ' attribute (min=', (self stringForValue: min), ')']							ifFalse: [self signalError: (self stringForValue: value), ' exceeds the maximum valid value of the ', semanticKey printString, ' attribute (max=', (self stringForValue: max), ')']]]]</body><body package="Chronos-Foundation" selector="handleRangeViolation:">handleRangeViolation: value	^self rangeViolationHandler value: value value: self minValidValue value: self maxValidValue</body><body package="Chronos-Foundation" selector="signalZeroInvalid">signalZeroInvalid	^self signal: self zeroInvalidException message: self zeroInvalidMessage</body><body package="Chronos-Foundation" selector="stringForValue:">stringForValue: aValue	^aValue == nil		ifTrue:['undefined value']		ifFalse: [aValue printString]</body></methods><methods><class-id>Chronos.RangeConstraint</class-id> <category>API-validation</category><body package="Chronos-Foundation" selector="assertValid:">assertValid: aValue 	(aValue == nil or: [aValue &lt; minValidValue or: [aValue &gt; maxValidValue]])		ifTrue: [self handleRangeViolation: aValue]</body><body package="Chronos-Foundation" selector="isValid:">isValid: aValue	^aValue ~~ nil and: [aValue &gt;= minValidValue and: [aValue &lt;= maxValidValue]]</body></methods><methods><class-id>Chronos.RangeConstraint</class-id> <category>testing</category><body package="Chronos-Foundation" selector="isNegativeValid">isNegativeValid	^minValidValue &lt; 0</body><body package="Chronos-Foundation" selector="isPositveValid">isPositveValid	^maxValidValue &gt; 0</body><body package="Chronos-Foundation" selector="isZeroValid">isZeroValid	^minValidValue &lt;= 0 and: [maxValidValue &gt;= 0]</body></methods><methods><class-id>Chronos.RangeConstraint class</class-id> <category>instance creation</category><body package="Chronos-Foundation" selector="semanticKey:maxValidValue:">semanticKey: semanticKey maxValidValue: max	^self new		setSemanticKey: semanticKey;		setMaxValidValue: max;		beImmutable</body><body package="Chronos-Foundation" selector="semanticKey:minValidValue:">semanticKey: semanticKey minValidValue: min	^self new		setSemanticKey: semanticKey;		setMinValidValue: min;		beImmutable</body><body package="Chronos-Foundation" selector="semanticKey:minValidValue:maxValidValue:">semanticKey: semanticKey minValidValue: min maxValidValue: max	^self new		setSemanticKey: semanticKey;		setMinValidValue: min;		setMaxValidValue: max;		beImmutable</body><body package="Chronos-Foundation" selector="semanticKey:minValidValue:maxValidValue:rangeViolationHandler:">semanticKey: semanticKey minValidValue: min maxValidValue: max rangeViolationHandler: block3	^self new		setSemanticKey: semanticKey;		setMinValidValue: min;		setMaxValidValue: max;		setRangeViolationHandler: block3;		beImmutable</body><body package="Chronos-Foundation" selector="semanticKey:minValidValue:maxValidValue:rangeViolationHandler:zeroInvalidException:zeroInvalidMessage:">semanticKey: semanticKey minValidValue: min maxValidValue: max rangeViolationHandler: block3 zeroInvalidException:  anExceptionFactory zeroInvalidMessage: aString	^self new		setSemanticKey: semanticKey;		setMinValidValue: min;		setMaxValidValue: max;		setRangeViolationHandler: block3;		setZeroInvalidException:  anExceptionFactory;		setZeroInvalidMessage: aString;		beImmutable</body><body package="Chronos-Foundation" selector="semanticKey:zeroInvalidException:">semanticKey: semanticKey zeroInvalidException:  aString	^self new		setSemanticKey: semanticKey;		setZeroInvalidException:  aString;		beImmutable</body><body package="Chronos-Foundation" selector="semanticKey:zeroInvalidException:zeroInvalidMessage:">semanticKey: semanticKey zeroInvalidException:  anExceptionFactory zeroInvalidMessage: aString	^self new		setSemanticKey: semanticKey;		setZeroInvalidException:  anExceptionFactory;		setZeroInvalidMessage: aString;		beImmutable</body><body package="Chronos-Foundation" selector="semanticKey:zeroInvalidMessage:">semanticKey: semanticKey zeroInvalidMessage: aString	^self new		setSemanticKey: semanticKey;		setZeroInvalidMessage: aString;		beImmutable</body></methods><methods><class-id>Chronos.RangeConstraint class</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="appOrLibraryName">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.ZeroSensitiveRangeConstraint</class-id> <category>API-validation</category><body package="Chronos-Foundation" selector="assertValid:">assertValid: aValue	(self satisfiesZeroConstraint: aValue)		ifFalse: [self signalZeroInvalid]. 	super assertValid: aValue</body><body package="Chronos-Foundation" selector="isValid:">isValid: aValue	^(self satisfiesZeroConstraint: aValue) and: [super isValid: aValue]</body><body package="Chronos-Foundation" selector="satisfiesZeroConstraint:">satisfiesZeroConstraint: aValue	^true</body></methods><methods><class-id>Chronos.ZeroSensitiveRangeConstraint</class-id> <category>initialize-release</category><body package="Chronos-Foundation" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	super canonicalize.	zeroInvalidException == nil		ifTrue: [self setZeroInvalidException: Error].	zeroInvalidMessage == nil		ifTrue: [self setZeroInvalidMessage: 'The value zero is not valid in a zeroless ordinal numbering system.'].</body><body package="Chronos-Foundation" selector="initialize">initialize	super initialize.	self setZeroInvalidException: Error.	self setZeroInvalidMessage: 'The value zero is not valid in a zeroless ordinal numbering system.'</body><body package="Chronos-Foundation" selector="setZeroInvalidException:">setZeroInvalidException: anExceptionFactory	self assertMutability.	zeroInvalidException := anExceptionFactory</body><body package="Chronos-Foundation" selector="setZeroInvalidMessage:">setZeroInvalidMessage: aString	self assertMutability.	zeroInvalidMessage := aString</body></methods><methods><class-id>Chronos.ZeroSensitiveRangeConstraint</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="zeroInvalidException">zeroInvalidException	^zeroInvalidException</body><body package="Chronos-Foundation" selector="zeroInvalidMessage">zeroInvalidMessage	^zeroInvalidMessage</body></methods><methods><class-id>Chronos.NumberingPolicy</class-id> <category>API-conversion</category><body package="Chronos-Foundation" selector="canonicalFromCardinal:">canonicalFromCardinal: cardinal	^self subclassResponsibility</body><body package="Chronos-Foundation" selector="canonicalFromOrdinal:">canonicalFromOrdinal: ordinal	^self subclassResponsibility</body><body package="Chronos-Foundation" selector="canonicalFromZerolessOrdinal:">canonicalFromZerolessOrdinal: zerolessOrdinal	^self subclassResponsibility</body><body package="Chronos-Foundation" selector="cardinalFromCanonical:">cardinalFromCanonical: canonical	^self subclassResponsibility</body><body package="Chronos-Foundation" selector="ordinalFromCanonical:">ordinalFromCanonical: canonical	^self subclassResponsibility</body><body package="Chronos-Foundation" selector="zerolessOrdinalFromCanonical:">zerolessOrdinalFromCanonical: canonical	^self subclassResponsibility</body></methods><methods><class-id>Chronos.CardinalNumberingPolicy</class-id> <category>API-conversion</category><body package="Chronos-Foundation" selector="canonicalFromCardinal:">canonicalFromCardinal: cardinal	^cardinal</body><body package="Chronos-Foundation" selector="canonicalFromOrdinal:">canonicalFromOrdinal: ordinal	^ordinal - 1</body><body package="Chronos-Foundation" selector="canonicalFromZerolessOrdinal:">canonicalFromZerolessOrdinal: zerolessOrdinal	^zerolessOrdinal &gt; 0 		ifTrue: [zerolessOrdinal - 1]		ifFalse: [zerolessOrdinal &lt; 0 ifTrue: [zerolessOrdinal] ifFalse: [self signalZeroInvalid]]</body><body package="Chronos-Foundation" selector="cardinalFromCanonical:">cardinalFromCanonical: canonical	^canonical</body><body package="Chronos-Foundation" selector="ordinalFromCanonical:">ordinalFromCanonical: canonical	^canonical + 1</body><body package="Chronos-Foundation" selector="zerolessOrdinalFromCanonical:">zerolessOrdinalFromCanonical: canonical	^canonical &gt; 0		ifTrue: [canonical + 1]		ifFalse: [canonical]</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-validation</category><body package="Chronos-Calendars-Foundation" selector="assertIsGregorian">assertIsGregorian	"If the calendrical system implemented by the receiver is not the Gregorian calendar, signal an Exception."	self signalError:  'It is required that I must be a Gregorian Calendar.'</body><body package="Chronos-Calendars-Foundation" selector="assertIsJulian">assertIsJulian	"If the calendrical system implemented by the receiver is not the Julian calendar, signal an Exception."	self signalError:  'It is required that I must be a Julian Calendar.'</body><body package="Chronos-Calendars-Foundation" selector="assertValidDayOfYear:">assertValidDayOfYear: dayOfYear	"If the &lt;dayOfYear&gt; parameter could not possibly be a valid value in the calendrical system implemented by the receiver, regardless of year, signal an Exception."	dayOfYear &lt; 1 ifTrue: [self signalInvalidArgument: #dayOfYear value: dayOfYear].	dayOfYear &gt; maxDaysPerYear ifTrue: [self signalInvalidArgument: #dayOfYear value: dayOfYear].</body><body package="Chronos-Calendars-Foundation" selector="assertValidDaysSinceStartOfYear:">assertValidDaysSinceStartOfYear: daySinceStartOfYear	"If the &lt;daySinceStartOfYear&gt; parameter could not possibly be a valid value in the calendrical system implemented by the receiver, regardless of year, signal an Exception."	daySinceStartOfYear &lt; 0 ifTrue: [self signalInvalidArgument: #daySinceStartOfYear value: daySinceStartOfYear].	daySinceStartOfYear &gt;= maxDaysPerYear ifTrue: [self signalInvalidArgument: #daySinceStartOfYear value: daySinceStartOfYear].</body><body package="Chronos-Calendars-Foundation" selector="assertValidMonth:day:">assertValidMonth: monthOrdinal day: dayOfMonth	"If either or both the &lt;monthOrdinal&gt; and &lt;dayOfMonth&gt; parameters could not possibly be valid values in the calendrical system implemented by the receiver, regardless of year, signal an Exception."	monthOrdinal &lt; 1 ifTrue: [self signalInvalidArgument: #month value: monthOrdinal].	monthOrdinal &gt; maxMonthsPerYear ifTrue: [self signalInvalidArgument: #month value: monthOrdinal].	dayOfMonth &lt; 1 ifTrue: [self signalInvalidArgument: #dayOfMonth value: dayOfMonth].	dayOfMonth &gt; (self maximumDaysInMonth: monthOrdinal) ifTrue: [self signalInvalidArgument: #dayOfMonth value: dayOfMonth].</body><body package="Chronos-Calendars-Foundation" selector="validateYear:dayOfYear:ifInvalid:">validateYear: y dayOfYear: d ifInvalid: block1	"If, in the year &lt;y&gt;, either the day-of-year &lt;d&gt; is not valid (or the year &lt;y&gt; is not valid) in the calendrical system implemented by the receiver, answer the result of evaluating &lt;block1&gt; with a parameter that is a Symbol identifying the reason that &lt;d&gt; is not a valid day-of-year in the year &lt;y&gt; (or the reason that &lt;y&gt; is not a valid year)--the possible values of the Symbol are #yearZeroInvalid, #underflow and #overflow. If both &lt;y&gt; and &lt;d&gt; are valid, answer nil"	"{Calendar gregorian validateYear: 2000 dayOfYear: 366 ifInvalid: [:evaluation | evaluation]}"	"{Calendar gregorian validateYear: 1900 dayOfYear: 366 ifInvalid: [:evaluation | evaluation]}"	"{Calendar gregorian validateYear: 0 dayOfYear: 0 ifInvalid: [:evaluation | evaluation]}"	"{Calendar julian validateYear: 0 dayOfYear: 1 ifInvalid: [:evaluation | evaluation]}"	| yearlyCalendar |	d &lt; 1 ifTrue: [^block1 value: #underflow].	(yearNumberingPolicy satisfiesZeroConstraint: y) ifFalse: [^block1 value: #yearZeroInvalid].	yearlyCalendar := self yearlyCalendarForYearTypeCode: (self typeCodeOfYear: y).	d &gt; yearlyCalendar daysPerYear 		ifTrue: [^block1 value:  #overflow].	^nil</body><body package="Chronos-Calendars-Foundation" selector="validateYear:month:day:ifInvalid:">validateYear: y month: m day: d ifInvalid: block1 	"If the date designation whose year is &lt;y&gt;, whose month ordinal is &lt;m&gt; and whose day-of-month ordinal is &lt;d&gt; is not valid in the calendrical system implemented by the receiver, answer the result of evaluating &lt;block1&gt; with a Dictionary as the argument, where the keys and values of the Dictionary identify the reasons that the date designation is not valid. The keys of the Dictionary identify the date-field whose value is not valid (#year, #month, #dayOfMonth,) and the value at the key identifies the nature of the problem with that date field (#yearZeroInvalid, #underflow, #overflow.) If the date designation is valid in all respects, answer nil"	"{Calendar gregorian validateYear: 2000 month: 2 day: 29 ifInvalid: [:evaluation | evaluation]}"	"{Calendar gregorian validateYear: 1900 month: 2 day: 29 ifInvalid: [:evaluation | evaluation]}"	"{Calendar gregorian validateYear: 2100 month: 0 day: -3 ifInvalid: [:evaluation | evaluation]}"	"{Calendar gregorian validateYear: 2100 month: 13 day: -12 ifInvalid: [:evaluation | evaluation]}"	"{Calendar julian validateYear: 0 month: 1 day: -12 ifInvalid: [:evaluation | evaluation]}"	| evaluation evaluationRef yearlyCalendar monthlyCalendar |	evaluation := nil.	evaluationRef := 			[evaluation == nil ifTrue: [evaluation := IdentityDictionary new].			evaluation].	d &lt; 1 ifTrue: [evaluationRef value at: #dayOfMonth put: #underflow].	m &lt; 1 		ifTrue: 			[evaluationRef value at: #month put: #underflow.			^block1 value: evaluation].	(yearNumberingPolicy satisfiesZeroConstraint: y) 		ifFalse: 			[evaluationRef value at: #year put: #yearZeroInvalid.			^block1 value: evaluation].	yearlyCalendar := self yearlyCalendarForYearTypeCode: (self typeCodeOfYear: y).	m &gt; yearlyCalendar monthsPerYear 		ifTrue: 			[evaluationRef value at: #month put: #overflow.			^block1 value: evaluation].	monthlyCalendar := yearlyCalendar monthAt: m.	d &gt; monthlyCalendar daysPerMonth 		ifTrue: [evaluationRef value at: #dayOfMonth put: #overflow].	^evaluation == nil ifFalse: [block1 value: evaluation]</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicNewCalendarClock">basicNewCalendarClock	"Answer a new CalendarClock for use by the receiver as its canonical CalendarClock."	^ChronosSystemClock current newCalendarClock</body><body package="Chronos-Calendars-Foundation" selector="bindToClock">bindToClock	"Perforn any necessary configuration or set up so that the receiver's &lt;clock&gt; can properly operate as the receiver's canonocal CalendarClock."	"By default, do nothing"</body><body package="Chronos-Calendars-Foundation" selector="bindToSystem">bindToSystem	"Make the receiver and other sytem objects collaborate with each other, as required by the overall system architecture."	self initializeReferenceTimes.	self invalidateClock</body><body package="Chronos-Calendars-Foundation" selector="computeDaysSinceStartOfWeekForEpochDay">computeDaysSinceStartOfWeekForEpochDay	"Answer the zero-based cardinal of the day of the week of the receiver's epoch day--without using the value of the &lt;daysSinceStartOfWeekForEpochDay&gt; instance variable"	^daysSinceStartOfANSIWeekForEpochDay</body><body package="Chronos-Calendars-Foundation" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	"Example 'de novo' calculation for the Gregorian Calendar:		 {| uDays uSeconds |		uDays := Gregorian 					daysSinceEpochUpToMonth: 11					day: 24					inYear: -4713.		uSeconds := uDays * 86400.		uSeconds negated - Gregorian secondsSinceStartOfDayAtStartOfJulianDay}"	"Example 'de novo' calculation for the Hebrew Calendar:		 {| uDays uSeconds |		uDays := HebrewCalendar canonical					daysSinceEpochUpToMonth: 4					day: 20					inYear: -952.		uSeconds := uDays * 86400.		uSeconds negated - HebrewCalendar canonical secondsSinceStartOfDayAtStartOfJulianDay}"	self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self registrationKey</body><body package="Chronos-Calendars-Foundation" selector="initializeIntraYearValues">initializeIntraYearValues	"Initialize the instance variables of the receiver that specify or describe the properties and organizational structure of days-of-the-year, months and days-of-the-month in the calendrical system of the receiver."	self assertMutability.	minDaysPerYear  := 0.	maxDaysPerYear  := 0.	minMonthsPerYear  := 0.	maxMonthsPerYear := 0.	maxDaysPerMonth := 0.	minDaysPerMonth := 0.	monthOrdinalsAlwaysCorrespondToTheSameMonthKey := self isMonthsPerYearInvariant. "Subclasses may need to override."	doMonthKeysAlwaysCorrespondToTheSameMonthNameKey := self isMonthsPerYearInvariant.  "Subclasses may need to override."	self initializeMonthSemantics.</body><body package="Chronos-Calendars-Foundation" selector="initializeMonthSemantics">initializeMonthSemantics	"Initialize the instance variables of the receiver that specify the mappings/associations between month ordinals, month keys and month name keys."	monthOrdinalsByMonthKey := Dictionary new.	monthKeysByMonthOrdinal := Dictionary new.	monthNameKeysByMonthKey := Dictionary new.	monthKeyByMonthNameKey := Dictionary new.</body><body package="Chronos-Calendars-Foundation" selector="initializeRangeConstraints">initializeRangeConstraints	"Initialize the instance variables of the receiver that constrain the numerical range of days-of-the-year, months and days-of-the-month in the calendrical system of the receiver."	self assertMutability.	monthOrdinalRangeConstraint := 		RangeConstraint 			semanticKey: #month			minValidValue: 1			maxValidValue: self maxMonthsPerYear.	dayOfMonthOrdinalRangeConstraint  := 		RangeConstraint 			semanticKey: #dayOfMonth			minValidValue: 1			maxValidValue: self maxDaysPerMonth.	dayOfYearOrdinalRangeConstraint  := 		RangeConstraint 			semanticKey: #dayOfYear			minValidValue: 1			maxValidValue: self maxDaysPerYear.	daysSinceStartOfYearRangeConstraint := 		RangeConstraint 			semanticKey: #daysSinceStartOfYear			minValidValue: 0			maxValidValue: self maxDaysPerYear - 1.</body><body package="Chronos-Calendars-Foundation" selector="initializeReferenceTimes">initializeReferenceTimes	"Initialize the instance variables of the receiver that store values used to convert between calendrical systems, or that otherwise serve to provide temporal reference points for interpreting dates in the receiver's calendrical system in a calendar-neutral manner." 	self setSecondsSinceJulianDayEpochUpToEpoch.	self setSecondsSinceUnificationEpochUpToEpoch.	self setDaysSinceStartOfWeekForEpochDay</body><body package="Chronos-Calendars-Foundation" selector="newCalendarClock">newCalendarClock	"Answer a new CalendarClock usable by the receiver as its canonical CalendarClock."	| newClock |	newClock := self basicNewCalendarClock.	^newClock		setCalendar: self;		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="newDefaultYearNumberingPolicy">newDefaultYearNumberingPolicy	"Answer a new NumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. NOTE: The ANSI Smalltalk standard REQUIRES the use of 'Astronomical Year Numbering' (i.e., an OrdinalNumberingPolicy) for dates in the Gregorian calendar. The ISO 8601 standard imposes the same requirement."	^self class newDefaultYearNumberingPolicy</body><body package="Chronos-Calendars-Foundation" selector="setDaysSinceStartOfWeekForEpochDay">setDaysSinceStartOfWeekForEpochDay	"Set the zero-based day-of-week index of the first day of the receiver's epoch.  Set this value for a) the receiver's canonical week, b) the ANSI Smalltalk week and c) the ISO 8601 standard week.  In ANSI Smalltalk, Sunday is the first day of the week.  ISO 8601 defines Monday as the first day of the week."	self assertMutability.	daysSinceStartOfISOWeekForEpochDay := self julianDayOfEpoch \\ DaysPerWeek.	daysSinceStartOfANSIWeekForEpochDay := daysSinceStartOfISOWeekForEpochDay + 1 \\ DaysPerWeek.	daysSinceStartOfWeekForEpochDay := self computeDaysSinceStartOfWeekForEpochDay</body><body package="Chronos-Calendars-Foundation" selector="setSecondsSinceJulianDayEpochUpToEpoch">setSecondsSinceJulianDayEpochUpToEpoch	"Set the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	"Example 'de novo' calculation for the Gregorian Calendar:		 {| uDays uSeconds |		uDays := Gregorian 					daysSinceEpochUpToMonth: 11					day: 24					inYear: -4713.		uSeconds := uDays * SecondsPerDay + Gregorian secondsFromMidnightToJulianDayStartOfDay.		(Gregorian secondsSinceEpochFromSecondsSinceUnificationEpoch: uSeconds) negated}"	self assertMutability.	secondsSinceJulianDayEpochUpToEpoch := self computeSecondsSinceJulianDayEpochUpToEpoch</body><body package="Chronos-Calendars-Foundation" selector="setSecondsSinceUnificationEpochUpToEpoch">setSecondsSinceUnificationEpochUpToEpoch	"Set the number of seconds since the initial moment of the epoch day of the unification calendar up to the initial moment of the epoch day of the receiver's calendrical system."	self assertMutability.	secondsSinceUnificationEpochUpToEpoch := self secondsSinceJulianDayEpochUpToEpoch - Calendar unification secondsSinceJulianDayEpochUpToEpoch</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Foundation" selector="doMonthKeysAlwaysCorrespondToTheSameMonthNameKey">doMonthKeysAlwaysCorrespondToTheSameMonthNameKey	"If the mapping between month keys and month name keys is invariant for all years, answer true.  Otherwise, answer false."	^doMonthKeysAlwaysCorrespondToTheSameMonthNameKey</body><body package="Chronos-Calendars-Foundation" selector="doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey">doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey	"If the mapping between month ordinals and month keys is invariant for all years, answer true.  Otherwise, answer false."	^monthOrdinalsAlwaysCorrespondToTheSameMonthKey</body><body package="Chronos-Calendars-Foundation" selector="isAnsiStandard">isAnsiStandard	"If the calendrical system implemented by the receiver conforms in all respects to the requirements of the ANSI Smalltalk standard with respect to the behavior of DateAndTime instances, answer true.  Otherwise, answer false.  Specifically: Answer true if and only if the receiver implements the proleptic Gregorian Calendar using astronomical (pure ordinal) year numbering."	^false</body><body package="Chronos-Calendars-Foundation" selector="isDaysPerMonthInvariant">isDaysPerMonthInvariant	"If there are always the exact same number of days in all months of all years, answer true. Otherwise, answer false."	^false</body><body package="Chronos-Calendars-Foundation" selector="isDaysPerYearInvariant">isDaysPerYearInvariant	"If there are always the exact same number of days in all years, answer true. Otherwise, answer false."	^false</body><body package="Chronos-Calendars-Foundation" selector="isGregorian">isGregorian	"If the receiver implements the Gregorian Calendar, answer true. Otherwise, answer false."	^false</body><body package="Chronos-Calendars-Foundation" selector="isJulian">isJulian	"If the receiver implements the Julian Calendar, answer true. Otherwise, answer false."	^false</body><body package="Chronos-Calendars-Foundation" selector="isMonthsPerYearInvariant">isMonthsPerYearInvariant	"If there are always the exact same number of months in all years, answer true. Otherwise, answer false."	^false</body><body package="Chronos-Calendars-Foundation" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the calendrical system represented by the receiver starts each day at local midnight."	^(self secondsSinceMidnightFromSecondsSinceStartOfDay: 0) isZero</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayClockStartsAtMidnight">timeOfDayClockStartsAtMidnight	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the calendrical system implemented by the receiver coincides with midnight.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^self midnightIsStartOfDay or: [self timeOfDayClockStartsAtStartOfDay not]</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the calendrical system implemented by the receiver coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^true</body><body package="Chronos-Calendars-Foundation" selector="yearArithmeticPreferablyPreservesMonthOrdinal">yearArithmeticPreferablyPreservesMonthOrdinal	"Answer true if adding or subtracting an integer number of civil years to a date always results in a new date with the same month ordinal.  If the date's dayOfMonthOrdinal is greater than the number of days in the month identified by that ordinal in the new year, then the next month will be used. If there is no month with the same month ordinal in the new year, then the next month will be used when adding years, and the previous month when subtracting years.	Answer false if adding or subtracting an integer number of civil years results in a new date with the same month key. If the date's dayOfMonthOrdinal is greater than the number of days in the month identified by that month key in the new year, then the next month will be used. If there is no month with the same month key in the new year, then the next month will be used when adding years, and the previous month when subtracting years."	^true</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-queries-months</category><body package="Chronos-Calendars-Foundation" selector="daysInMonth:forYearTypeCode:">daysInMonth: monthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days in the month whose ordinal is &lt;monthOrdinal&gt;, in a year whose typeCode is &lt;yearTypeCode&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysInMonth:inYear:">daysInMonth: monthOrdinal inYear: year	"Answer the number of days in the month whose ordinal is &lt;monthOrdinal&gt;, in the given &lt;year&gt;."	^self daysInMonth: monthOrdinal forYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="maxDaysPerMonth">maxDaysPerMonth		"Answer the most number of days that occur in any month of any year."	^maxDaysPerMonth</body><body package="Chronos-Calendars-Foundation" selector="maxMonthsPerYear">maxMonthsPerYear	"Answer the most number of months that occur in any year."	^maxMonthsPerYear</body><body package="Chronos-Calendars-Foundation" selector="maximumDayOfYearOrdinalForMonth:day:">maximumDayOfYearOrdinalForMonth: monthOrdinal day: dayOfMonthOrdinal	"Answer the largest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthOrdinal&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="maximumDayOfYearOrdinalForMonthWithKey:day:">maximumDayOfYearOrdinalForMonthWithKey: monthKey day: dayOfMonthOrdinal	"Answer the largest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthKey&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="maximumDaysInMonth:">maximumDaysInMonth: monthOrdinal	"Answer the most number of days that may occur, for any year, in the month whose ordinal is &lt;monthOrdinal&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="maximumDaysInMonthWithKey:">maximumDaysInMonthWithKey: monthKey	"Answer the most number of days that may occur, for any year, in the month whose key is &lt;monthKey&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="minDaysPerMonth">minDaysPerMonth		"Answer the least number of days that occur in any month of any year."	^minDaysPerMonth</body><body package="Chronos-Calendars-Foundation" selector="minMonthsPerYear">minMonthsPerYear	"Answer the least number of months that occur in any year."	^minMonthsPerYear</body><body package="Chronos-Calendars-Foundation" selector="minimumDayOfYearOrdinalForMonth:day:">minimumDayOfYearOrdinalForMonth: monthOrdinal day: dayOfMonthOrdinal	"Answer the smallest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthOrdinal&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="minimumDayOfYearOrdinalForMonthWithKey:day:">minimumDayOfYearOrdinalForMonthWithKey: monthKey day: dayOfMonthOrdinal	"Answer the smallest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthKey&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="minimumDaysInMonth:">minimumDaysInMonth: monthOrdinal	"Answer the least number of days that may occur, for any year, in the month whose ordinal is &lt;monthOrdinal&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="minimumDaysInMonthWithKey:">minimumDaysInMonthWithKey: monthKey	"Answer the least number of days that may occur, for any year, in the month whose key is &lt;monthKey&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="monthKeyAtMonthNameKey:">monthKeyAtMonthNameKey: monthNameKey	monthKeyByMonthNameKey == nil ifTrue: [self bindToYearlyCalendars].	^monthKeyByMonthNameKey at: monthNameKey</body><body package="Chronos-Calendars-Foundation" selector="monthKeyForMonthAt:forYearTypeCode:">monthKeyForMonthAt: monthOrdinal forYearTypeCode: yearTypeCode	"Answer the monthKey for the month whose ordinal is &lt;monthOrdinal&gt;, in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="monthKeyForMonthAt:inYear:">monthKeyForMonthAt: monthOrdinal inYear: year	"Answer the monthKey for the month whose ordinal is &lt;monthOrdinal&gt;, in the given &lt;year&gt;."	^self monthKeyForMonthAt: monthOrdinal forYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinalForMonthWithKey:forYearTypeCode:">monthOrdinalForMonthWithKey: monthKey forYearTypeCode: yearTypeCode	"Answer the month ordinal for the month whose monthKey is &lt;monthKey&gt;, in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinalForMonthWithKey:inYear:">monthOrdinalForMonthWithKey: monthKey inYear: year	"Answer the month ordinal for the month whose monthKey is &lt;monthKey&gt;, in the given &lt;year&gt;."	^self monthOrdinalForMonthWithKey: monthKey forYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinalFromNumericMonthDesignator:forYearTypeCode:">monthOrdinalFromNumericMonthDesignator: numericalMonthDesignator forYearTypeCode: yearTypeCode	"Answer the month ordinal for the month identified by the culturally-correct numeric designator &lt;numericalMonthDesignator&gt;, for a year whose type is identified by the code &lt;yearTypeCode&gt;."	^numericalMonthDesignator</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinalFromNumericMonthDesignator:inYear:">monthOrdinalFromNumericMonthDesignator: numericalMonthDesignator inYear: year	"Answer the month ordinal for the month whose culturally-correct numeric designator is &lt;numericalMonthDesignator&gt;, in the given &lt;year&gt;."	^self monthOrdinalFromNumericMonthDesignator: numericalMonthDesignator forYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="monthsInYear:">monthsInYear: year	"Answer the number of months there are in the given &lt;year&gt;."	^self monthsInYearForYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="monthsInYearForYearTypeCode:">monthsInYearForYearTypeCode: yearTypeCode 	"Answer the number of months there are per year, in a year whose typeCode is &lt;yearTypeCode&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="numericMonthDesignatorFromMonthOrdinal:forYearTypeCode:">numericMonthDesignatorFromMonthOrdinal: monthOrdinal forYearTypeCode: yearTypeCode	"Answer the culturally-correct numeric designator that identifies the month whose ordinal is &lt;monthOrdinal&gt;, for a year whose type is identified by the code &lt;yearTypeCode&gt;."	^monthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="numericMonthDesignatorFromMonthOrdinal:inYear:">numericMonthDesignatorFromMonthOrdinal: monthOrdinal inYear: year	"Answer the culturally-correct numeric designator that identifies the month whose ordinal is &lt;monthOrdinal&gt; in the given &lt;year&gt;."	^self numericMonthDesignatorFromMonthOrdinal: monthOrdinal forYearTypeCode: (self typeCodeOfYear: year)</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochUpToMonth:day:inYear:">daysSinceEpochUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear 	"Answer the number of days since the receiver's epoch up to (but not including) the &lt;dayOfMonthOrdinal&gt;th day of the &lt;monthOrdinal&gt;th month of the given &lt;calendarYear&gt;.  By definition, the answer when &lt;calendarYear&gt; = 1 (assuming positve years are ordinal numbers,) &lt;monthOrdinal&gt; = 1 and &lt;dayOfMonthOrdinal&gt; = 1 must be zero."	^(self daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear)		+ (self daysSinceEpochUpToYear: calendarYear)</body><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: ordinalYearNumber 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonth:day:forYearTypeCode:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonth:day:inYear:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^self daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: (self typeCodeOfYear: calendarYear)</body><body package="Chronos-Calendars-Foundation" selector="monthsSinceEpochUpToYear:">monthsSinceEpochUpToYear: calendarYear 	"Answer the count of months since the Epoch day (start of day) up to (but NOT including) the first month of the specified year."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceEpochUpToYear:">secondsSinceEpochUpToYear: calendarYear 	"Answer the count of seconds since the initial moment of the epoch day of the receiver's calendar up to the initial moment of the first day of the specified year. DO NOT include leap seconds, or any timezone-dependent adjustments."	^(self daysSinceEpochUpToYear: calendarYear) * SecondsPerDay</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-CalendarPeriods</category><body package="Chronos-Calendars-Foundation" selector="calendarDayFromDayOfYearOrdinal:forYearTypeCode:">calendarDayFromDayOfYearOrdinal: dayOfYearOrdinal forYearTypeCode: yearTypeCode 	"Answer the CalendarDay (which see) that represents the day of the year whose ordinal number is &lt;dayOfYearOrdinal&gt;, for any year whose year type code is &lt;yearTypeCode&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="calendarDayFromDayOfYearOrdinal:inYear:">calendarDayFromDayOfYearOrdinal: dayOfYearOrdinal inYear: year	"Answer the CalendarDay (which see) that represents the day of the year whose ordinal number is &lt;dayOfYearOrdinal&gt; in the year &lt;year&gt;."	^self calendarDayFromDayOfYearOrdinal: dayOfYearOrdinal forYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="calendarDayFromMonth:day:forYearTypeCode:">calendarDayFromMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode	"Answer the CalendarDay (which see) that represents the month of the year whose ordinal is &lt;monthOrdinal&gt;, and the day of the month whose ordinal number is &lt;dayOfMonthOrdinal&gt;, for any year whose year type code is &lt;yearTypeCode&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="calendarDayFromMonth:day:inYear:">calendarDayFromMonth: monthOrdinal day: dayOfMonthOrdinal inYear: year	"Answer the CalendarDay (which see) that represents the month of the year whose ordinal is &lt;monthOrdinal&gt;, and the day of the month whose ordinal number is &lt;dayOfMonthOrdinal&gt; in the year &lt;year&gt;."	^self calendarDayFromMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="yearlyCalendarFor:">yearlyCalendarFor: year	"Answer the YearlyCalendar (which see) that specifies the characteristics of the given &lt;year&gt;, including the year's organization into months and days of the month."	^self yearlyCalendarForYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="yearlyCalendarForYearTypeCode:">yearlyCalendarForYearTypeCode: yearType	"Answer the YearlyCalendar (which see) that specifies the characteristics of any year whose year type is identifiefied by the code &lt;yearType&gt;, including the year's organization into months and days of the month."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="clock">clock	"Answer the CalendarClock associated with the receiver."	^clock</body><body package="Chronos-Calendars-Foundation" selector="dayOfMonthOrdinalRangeConstraint">dayOfMonthOrdinalRangeConstraint	"Answer the RangeConstraint that implements the range constraint for the valid values of dayOfMonth ordinals in the calendrical system represented by the receiver (taking all months and year-types into account.)"	^dayOfMonthOrdinalRangeConstraint</body><body package="Chronos-Calendars-Foundation" selector="dayOfYearOrdinalRangeConstraint">dayOfYearOrdinalRangeConstraint	"Answer the RangeConstraint that implements the range constraint for the valid values of dayOfYear ordinals in the calendrical system represented by the receiver (taking all year-types into account.)"	^dayOfYearOrdinalRangeConstraint</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfYearRangeConstraint">daysSinceStartOfYearRangeConstraint	"Answer the RangeConstraint that implements the range constraint for the valid values of daysSinceStartOfYear (dayOfYear cardinal numbers) in the calendrical system represented by the receiver (taking all year-types into account.)"	^daysSinceStartOfYearRangeConstraint</body><body package="Chronos-Calendars-Foundation" selector="defaultLocale">defaultLocale	"Answer the ChronosLocale to be used by default for printing (or parsing) dates in the calendrical system repersented by the receiver."	^ChronosLocale default</body><body package="Chronos-Calendars-Foundation" selector="defaultTimeZone">defaultTimeZone	^ChronosTimezone default</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinalRangeConstraint">monthOrdinalRangeConstraint	"Answer the RangeConstraint that implements the range constraint for the valid values of month ordinals in the calendrical system represented by the receiver (taking all year-types into account.)"	^monthOrdinalRangeConstraint</body><body package="Chronos-Calendars-Foundation" selector="name">name	"Answer the name, for presentation purposes, of the calendrical system represented by the receiver."	^self defaultLocale properNameAtSemanticKey: self registrationKey</body><body package="Chronos-Calendars-Foundation" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^self class registrationKey</body><body package="Chronos-Calendars-Foundation" selector="yearNumberingPolicy">yearNumberingPolicy	"Answer the instance of the concrete subclass of NumberingPolicy that implements the year-numbering policy of the calendrical system represented by the receiver."	^yearNumberingPolicy</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-InterCalendar</category><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochFromForeignDaysSinceEpoch:convertingFrom:">daysSinceEpochFromForeignDaysSinceEpoch: foreignDaysSinceEpoch convertingFrom: aForeignCalendar 	"Answer the number of days since the epoch of the receiver's calendar, converted from &lt;foreignDaysSinceEpoch&gt; days since the epoch of the Calendar &lt;aForeignCalendar&gt;."	^(self 		secondsSinceEpochFromForeignSecondsSinceEpoch: 			(foreignDaysSinceEpoch * SecondsPerDay + (aForeignCalendar secondsSinceStartOfDayAtStartOfJulianDay))		convertingFrom: aForeignCalendar) - (self secondsSinceStartOfDayAtStartOfJulianDay)  // SecondsPerDay</body><body package="Chronos-Calendars-Foundation" selector="forSecondsSinceEpoch:canonicalCalendarAndSecondsSinceEpochDo:ifSameCalendar:">forSecondsSinceEpoch: secondsSinceEpoch canonicalCalendarAndSecondsSinceEpochDo: block2 ifSameCalendar: block0	"For a timepoint that is &lt;secondsSinceEpoch&gt; seconds since the initial moment of the epoch day of the receiver's calendar, determine whether the receiver is the canonical calendar used by the culture that would be, or would have been, the principal users of the receiver's calendar. If so, answer the result of evaluating ther zero-argument block &lt;block0&gt;.  Otherwise, answer the result of evaluating the two-argument block &lt;block2&gt;, where the first block argument is the Calendar instance that is canonical for that culture at that moment in time, and where the second block argument is the number of seconds since the initial moment of the epoch day of the calendrical system represented by the first block argument."	^block0 value</body><body package="Chronos-Calendars-Foundation" selector="gregorianDateSpecFromDaysSinceEpoch:">gregorianDateSpecFromDaysSinceEpoch: daysSinceEpoch 	"Answer an instance of DateSpec that specifies a Gregorian year/month/day that is daysSinceEpoch days since my Epoch."	^Gregorian 		dateSpecFromDaysSinceEpoch: 			(Gregorian 				daysSinceEpochFromForeignDaysSinceEpoch: daysSinceEpoch convertingFrom: self)</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceEpochFromForeignSecondsSinceEpoch:convertingFrom:">secondsSinceEpochFromForeignSecondsSinceEpoch: foreignSecondsSinceEpoch convertingFrom: aForeignCalendar	"Answer the number of seconds since the initial moment of the epoch day of the receiver's calendar, converted from &lt;foreignSecondsSinceEpoch&gt; days since the initial moment of the epoch day of the Calendar &lt;aForeignCalendar&gt;. Do not include any adjustments for leap seconds, or any time-zone dependent adjustments."	^self 		secondsSinceEpochFromSecondsSinceUnificationEpoch: 			(aForeignCalendar 				secondsSinceUnificationEpochFromSecondsSinceEpoch: foreignSecondsSinceEpoch)</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceUnificationEpochUpToEpoch">secondsSinceUnificationEpochUpToEpoch	"Answer the number of seconds since the initial moment of the epoch day of the unification calendar up to the initial moment of the epoch day of the receiver's calendar."	^secondsSinceUnificationEpochUpToEpoch</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-Julian Days</category><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochFromJulianDay:">daysSinceEpochFromJulianDay: julianDay	"Answer the number of days since the epoch of the receiver's calendar that corresponds to the day whose Julian Astronomical Day Number is &lt;julianDay&gt;. Correspondence rule: The day in the receiver's count of days since the epoch that contains the starting moment of Julian Day J is the one that corresponds to Julian Day J.  Julian Days start at Noon--because astronomers work at night."	^(self secondsSinceEpochFromJulianDay: julianDay) // SecondsPerDay</body><body package="Chronos-Calendars-Foundation" selector="julianDayFromDaysSinceEpoch:">julianDayFromDaysSinceEpoch: daysSinceEpoch	"Answer the Julian Astronomical Day Number that corresponds to the day that is &lt;daysSinceEpoch&gt; days since the epoch of the receiver's calendar. Correspondence rule: The day in the receiver's count of days since the epoch that contains the starting moment of Julian Day J is the one that corresponds to Julian Day J.  Julian Days start at Noon--because astronomers work at night."	^self julianDayFromSecondsSinceEpoch: daysSinceEpoch * SecondsPerDay + self secondsSinceStartOfDayAtStartOfJulianDay</body><body package="Chronos-Calendars-Foundation" selector="julianDayFromSecondsSinceEpoch:">julianDayFromSecondsSinceEpoch: secondsSinceEpoch	"Answer the Julian Astronomical Day Number that corresponds to the timepoint that is &lt;secondsSinceEpoch&gt; seconds since the initial moment of the epoch day of the receiver's calendar.  Julian Days start at Noon--because astronomers work at night.."	^(self secondsSinceJulianDayEpochUpToEpoch + secondsSinceEpoch) // SecondsPerDay</body><body package="Chronos-Calendars-Foundation" selector="julianDayOfEpoch">julianDayOfEpoch	"Answer the Julian Astronomical Day Number that begins at Noon on the epoch day of the receiver's calendar."	^self julianDayFromDaysSinceEpoch: 0</body><body package="Chronos-Calendars-Foundation" selector="secondsFromMidnightToJulianDayStartOfDay">secondsFromMidnightToJulianDayStartOfDay	"Answer the number of seconds to be added to seconds-since-start-of-day, expressed relative to the canonical Julian Day start-of-day, to convert them into seconds-since-midnight (without respect to timezone translation.).	Julian Day 0 starts at Noon 4713 BC-Jan-1 in the Julian Calendar."	^"SecondsPerDay // 2" 43200</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceEpochFromJulianDay:">secondsSinceEpochFromJulianDay: julianDay	"Answer the number of seconds since the initial moment of the epoch day of the receiver's calendar that corresponds to the initial moment of the day whose Julian Astronomical Day Number is &lt;julianDay&gt;. Julian Days start at Noon--because astronomers work at night."	^(julianDay * SecondsPerDay) - self secondsSinceJulianDayEpochUpToEpoch</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceJulianDayEpochUpToEpoch">secondsSinceJulianDayEpochUpToEpoch	"Answer the number of seconds since the initial moment (Noon) of Julian Day 0 (Monday, January 1, 4713 BC in the proleptic Julian calendar; or November 24, -4713 in the proleptic Gregorian calendar) up to the initial moment of the epoch day of the receiver's calendar."	secondsSinceJulianDayEpochUpToEpoch == nil 		ifTrue: 			[EnvironmentFacade current makeMutable: self.			secondsSinceJulianDayEpochUpToEpoch := self computeSecondsSinceJulianDayEpochUpToEpoch].	^secondsSinceJulianDayEpochUpToEpoch</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceStartOfDayAtStartOfJulianDay">secondsSinceStartOfDayAtStartOfJulianDay	"Answer the number of seconds to be added to the start-of-day of the receiver in order to derive the seconds-since-start-of-day of the next Julian Day.	Julian Day 0 starts at Noon 4713 BC-Jan-1 in the Julian Calendar."	| seconds |	seconds := self secondsSinceStartOfDayFromSecondsSinceMidnight: self secondsFromMidnightToJulianDayStartOfDay.	^seconds &gt; SecondsPerDay		ifTrue: [seconds - SecondsPerDay]		ifFalse: [seconds]</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceStartOfJulianDayAtStartOfDay">secondsSinceStartOfJulianDayAtStartOfDay	"Answer the number of seconds to be added to the start-of-day of a Julian Day in order to advance to the start-of-day of the receiver.	Julian Day 0 starts at Noon 4713 BC-Jan-1 in the Julian Calendar."	| seconds |	seconds := self secondsSinceMidnightFromSecondsSinceStartOfDay: self secondsFromMidnightToJulianDayStartOfDay.	^seconds &gt; SecondsPerDay		ifTrue: [seconds - SecondsPerDay]		ifFalse: [seconds]</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Foundation" selector="daysInYear:">daysInYear: year	"Answer the number of days in the given &lt;year&gt;."	^self daysInYearForYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Foundation" selector="daysInYearForYearTypeCode:">daysInYearForYearTypeCode: yearTypeCode	"Answer the number of days per year there are in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="eraNameForYear:">eraNameForYear: calendarYear	"Answer the abbreviation of the name of the era to which &lt;calendarYear&gt; belongs.  The name of an era identifies the epoch date of a calendrical system and/or the calendrical system itself (although it may do so ambiguously.) The era name may also identify whether or not the &lt;calendarYear&gt; occurs before or after the epoch date."	^(yearNumberingPolicy cardinalFromCanonical: calendarYear) &gt;= 0		ifTrue: [self defaultLocale properNameAtSemanticKey: (self registrationKey, #'-era-postEpoch') asSymbol] 		ifFalse: [self defaultLocale properNameAtSemanticKey: (self registrationKey, #'-era-preEpoch') asSymbol]</body><body package="Chronos-Calendars-Foundation" selector="fullYearFromTwoDigitYear:">fullYearFromTwoDigitYear: twoDigitYear	"Answer the best guess regarding the full year, in the context of a) the calendar represented by the receiver, b) the current year in the calendar represented by the receiver. See #fullYearFromTwoDigitYear:backwardBias: for more information.	Examples:		Two-digitYear		CurrentYear		FullYear		00					2000			2000		50					2000			1950		37					2004			1937		37					2005                 2037	VERIFICATION:						Normal cases												Abnormal cases		Print it: {Calendar gregorian fullYearFromTwoDigitYear: 0} 		Print it: {Calendar gregorian fullYearFromTwoDigitYear: 100} 		Print it: {Calendar gregorian fullYearFromTwoDigitYear: 25}	Print it: {Calendar gregorian fullYearFromTwoDigitYear: -1250}		Print it: {Calendar gregorian fullYearFromTwoDigitYear: 50}	Print it: {Calendar gregorian fullYearFromTwoDigitYear: -150}		Print it: {Calendar gregorian fullYearFromTwoDigitYear: 75}	Print it: {Calendar gregorian fullYearFromTwoDigitYear: 2525}		Print it: {Calendar gregorian fullYearFromTwoDigitYear: 1999}	Print it: {Calendar gregorian fullYearFromTwoDigitYear: 972}						All two-digit years:		Inspect it: {(0 to: 99) collect: [:twoDigitYear | twoDigitYear -&gt; (Calendar gregorian fullYearFromTwoDigitYear: twoDigitYear)]}"	^self fullYearFromTwoDigitYear: twoDigitYear backwardBias: 67</body><body package="Chronos-Calendars-Foundation" selector="fullYearFromTwoDigitYear:backwardBias:">fullYearFromTwoDigitYear: twoDigitYear backwardBias: backwardBias 	"Answer the best guess regarding the full year, in the context of a) the calendar represented by the receiver, b) the current year in the calendar represented by the receiver, and c) the given &lt;backwardBias&gt;.  The &lt;backwardBias&gt; is the number of years back from the receiver's current year for which the receiver will assume that the 2 least significant digits of such years correspond to those of the given &lt;twoDigitYear&gt;. If &lt;twoDigitYear&gt; has more than two (base 10) digits, then the value answered will be &lt;twoDigitYear&gt;.	NOTE: The algorithm works for negative years, and for years within 100 years of the calendar's Epoch.	A &lt;backwardBias&gt; of zero results in all two-digit years being mapped to either the current year, or to one of the following 99 years. A &lt;backwardBias&gt; of 99 results in all two-digit years being mapped to either the current year, or to one of the preceding 99 years. A &lt;backwardBias&gt; of 'self clock thisYear - 1901' maps all two-digit years to the 20th century (of the receiver's calendar, of course--and assuming that the year 2000 is considered the final year of the 20th century, as is canoncial in the Gregorian and Julian calendars.) 	The industry-recommended standard backward bias is 67 (regardless of calendar.)	Examples:		Two-digitYear		BackwardBias	CurrentYear		FullYear		00								     0			2000			2000		50								   49			2000			2050		50								   50			2000			1950		37								   67			2004			1937		37								   67			2005			2037		00								 100			2000			1900		50								 100			2000			1950		00								-100			2000			2100		50								-100			2000			2150		00								 200			2000			1800		50								 200			2000			1850		00								-200			2000			2200		50								-200			2000			2250	VERIFICATION:		Inspect it: {(0 to: 99) collect: [:twoDigitYear | twoDigitYear -&gt; (Calendar gregorian fullYearFromTwoDigitYear: twoDigitYear  backwardBias: 67)]}		Inspect it: {(0 to: 99) collect: [:twoDigitYear | twoDigitYear -&gt; (Calendar gregorian fullYearFromTwoDigitYear: twoDigitYear  backwardBias: -33)]}		Inspect it: {(0 to: 99) collect: [:twoDigitYear | twoDigitYear -&gt; (Calendar gregorian fullYearFromTwoDigitYear: twoDigitYear  backwardBias: 167)]}		Inspect it: {(0 to: 99) collect: [:twoDigitYear | twoDigitYear -&gt; (Calendar gregorian fullYearFromTwoDigitYear: twoDigitYear  backwardBias: Calendar gregorian clock thisYear - 1901)]}"	"{(-199 to: 199) collect: [:twoDigitYear | twoDigitYear -&gt; (Calendar gregorian fullYearFromTwoDigitYear: twoDigitYear  backwardBias: 2067)]}"	"{(-199 to: 199) collect: [:twoDigitYear | twoDigitYear -&gt; (Calendar gregorian fullYearFromTwoDigitYear: twoDigitYear  backwardBias: 2167)]}"	| thisYear pivotYear pivotYearMod100 yearDelta tdy |	twoDigitYear abs &gt;= 100 		ifTrue: 			["&lt;twoDigitYear&gt; is the full year."			^twoDigitYear].	thisYear := self clock thisYear.	yearDelta := twoDigitYear - thisYear.	yearDelta abs &lt; 100 "Perhaps the calendar epoch is within 100 years of the current year."		ifTrue: 			["&lt;twoDigitYear&gt; is the full year."			^twoDigitYear].	pivotYear := yearNumberingPolicy ordinalFromCanonical: thisYear - backwardBias.	yearDelta := twoDigitYear - pivotYear.	(yearDelta abs &lt; 100 or: [twoDigitYear ~= 0 and: [pivotYear sign ~= twoDigitYear sign]]) "Perhaps the pivot year is within 100 years of the specified year."		ifTrue: 			["&lt;twoDigitYear&gt; is the full year in the context of the &lt;backwardBias&gt;."			^yearNumberingPolicy canonicalFromOrdinal: pivotYear + yearDelta].	"&lt;twoDigitYear&gt; is intended to be some year within 100 years of the current year."		pivotYearMod100 := pivotYear \\ 100. "Handle negative years"	tdy := twoDigitYear \\ 100. "Handle negative years"	yearDelta := tdy - pivotYearMod100.	^yearNumberingPolicy 		canonicalFromOrdinal: 			(tdy &gt;= pivotYearMod100 				ifTrue: [pivotYear + yearDelta]				ifFalse: [pivotYear + yearDelta + 100])</body><body package="Chronos-Calendars-Foundation" selector="maxDaysPerYear">maxDaysPerYear	"Answer the most number of days that may occur in a year."	^maxDaysPerYear</body><body package="Chronos-Calendars-Foundation" selector="minDaysPerYear">minDaysPerYear	"Answer the least number of days that may occur in a year."	^minDaysPerYear</body><body package="Chronos-Calendars-Foundation" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-Day of week</category><body package="Chronos-Calendars-Foundation" selector="ansiDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal:">ansiDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: canonicalDayOfWeekOrdinal	"Answer the ANSI day-of-week ordinal that corresponds to the canonical day-of-week ordinal &lt;canonicalDayOfWeekOrdinal&gt;."	"{Calendar gregorian ansiDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: 1}"	"{Calendar gregorian ansiDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: 7}"	^canonicalDayOfWeekOrdinal</body><body package="Chronos-Calendars-Foundation" selector="ansiDayOfWeekOrdinalFromDaysSinceEpoch:">ansiDayOfWeekOrdinalFromDaysSinceEpoch: daysSinceEpoch	"Answer the ordinal number of the day of the week of the day that is &lt;daysSinceEpoch&gt; days from the receiver's epoch. Use the ANSI Smalltalk numbering convention, where Sunday=1 and Saturday=7."	^(self daysSinceStartOfANSIWeekFromDaysSinceEpoch: daysSinceEpoch) + 1</body><body package="Chronos-Calendars-Foundation" selector="ansiDayOfWeekOrdinalFromISODayOfWeekOrdinal:">ansiDayOfWeekOrdinalFromISODayOfWeekOrdinal: isoDayOfWeekOrdinal	"Answer the ANSI day-of-week ordinal that corresponds to the ISO 8601 day-of-week ordinal &lt;isoDayOfWeekOrdinal&gt;."	"{Calendar gregorian ansiDayOfWeekOrdinalFromISODayOfWeekOrdinal: 1}"	"{Calendar gregorian ansiDayOfWeekOrdinalFromISODayOfWeekOrdinal: 7}"	^(isoDayOfWeekOrdinal \\ DaysPerWeek) + 1</body><body package="Chronos-Calendars-Foundation" selector="canonicalDayOfWeekOrdinalFromANSIDayOfWeekOrdinal:">canonicalDayOfWeekOrdinalFromANSIDayOfWeekOrdinal: ansiDayOfWeekOrdinal	"Answer the canonical day-of-week ordinal that corresponds to the ANSI day-of-week ordinal &lt;ansiDayOfWeekOrdinal&gt;."	"{Calendar gregorian canonicalDayOfWeekOrdinalFromANSIDayOfWeekOrdinal: 1}"	"{Calendar gregorian canonicalDayOfWeekOrdinalFromANSIDayOfWeekOrdinal: 7}"	^ansiDayOfWeekOrdinal</body><body package="Chronos-Calendars-Foundation" selector="canonicalDayOfWeekOrdinalFromISODayOfWeekOrdinal:">canonicalDayOfWeekOrdinalFromISODayOfWeekOrdinal: isoDayOfWeekOrdinal	"Answer the canonical day-of-week ordinal that corresponds to the ISO 8601 day-of-week ordinal &lt;isoDayOfWeekOrdinal&gt;."	"{Calendar gregorian canonicalDayOfWeekOrdinalFromISODayOfWeekOrdinal: 1}"	"{Calendar gregorian canonicalDayOfWeekOrdinalFromISODayOfWeekOrdinal: 7}"	^(isoDayOfWeekOrdinal \\ DaysPerWeek) + 1</body><body package="Chronos-Calendars-Foundation" selector="dayOfWeekOrdinalFromDaysSinceEpoch:">dayOfWeekOrdinalFromDaysSinceEpoch: daysSinceEpoch	"Answer the ordinal number of the day of the week of the day that is &lt;daysSinceEpoch&gt; days from the receiver's epoch. Use whatever numbering convention for days of the week that would be canonically used by the culture that is the principal user of the calendrical system implemented by the receiver.."	^(self daysSinceStartOfWeekFromDaysSinceEpoch: daysSinceEpoch) + 1</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfANSIWeekForEpochDay">daysSinceStartOfANSIWeekForEpochDay	"Answer the zero-based day-of-week index of the first day of the epoch (ANSI Smalltalk standard cardinal, where Sunday=0 and Saturday=6)."	^daysSinceStartOfANSIWeekForEpochDay</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfANSIWeekFromDaysSinceEpoch:">daysSinceStartOfANSIWeekFromDaysSinceEpoch: daysSinceEpoch	"Answer the cardinal number of the day of the week of the day that is &lt;daysSinceEpoch&gt; days from the receiver's epoch. Use the ANSI Smalltalk numbering convention, where Sunday=0 and Saturday=6."	^daysSinceEpoch + daysSinceStartOfANSIWeekForEpochDay \\ DaysPerWeek</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfISOWeekForEpochDay">daysSinceStartOfISOWeekForEpochDay	"Answer the zero-based day-of-week index of the first day of the epoch (ISO 8601 standard cardinal, where Monday=0 and Sunday=6)."	^daysSinceStartOfISOWeekForEpochDay</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfISOWeekFromDaysSinceEpoch:">daysSinceStartOfISOWeekFromDaysSinceEpoch: daysSinceEpoch	"Answer the cardinal number of the day of the week of the day that is &lt;daysSinceEpoch&gt; days from the receiver's epoch. Use the ISO 8601 numbering convention, where Monday=0 and Sunday=6."	^daysSinceEpoch + daysSinceStartOfISOWeekForEpochDay \\ DaysPerWeek</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfWeekForEpochDay">daysSinceStartOfWeekForEpochDay	"Answer the zero-based day-of-week index of the receiver's epoch day."	^daysSinceStartOfWeekForEpochDay</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfWeekFromDaysSinceEpoch:">daysSinceStartOfWeekFromDaysSinceEpoch: daysSinceEpoch	"Answer the cardinal number of the day of the week of the day that is &lt;daysSinceEpoch&gt; days from the receiver's epoch"	^daysSinceEpoch + daysSinceStartOfWeekForEpochDay \\ DaysPerWeek</body><body package="Chronos-Calendars-Foundation" selector="isoDayOfWeekOrdinalFromANSIDayOfWeekOrdinal:">isoDayOfWeekOrdinalFromANSIDayOfWeekOrdinal: ansiDayOfWeekOrdinal	"Answer the ISO 8601 day-of-week ordinal that corresponds to the ANSI day-of-week ordinal &lt;ansiDayOfWeekOrdinal&gt;."	"{Calendar gregorian isoDayOfWeekOrdinalFromANSIDayOfWeekOrdinal: 1}"	"{Calendar gregorian isoDayOfWeekOrdinalFromANSIDayOfWeekOrdinal: 7}"	^(ansiDayOfWeekOrdinal - 2 \\ DaysPerWeek) + 1.</body><body package="Chronos-Calendars-Foundation" selector="isoDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal:">isoDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: canonicalDayOfWeekOrdinal	"Answer the ISO 8601 day-of-week ordinal that corresponds to the canonical day-of-week ordinal &lt;canonicalDayOfWeekOrdinal&gt;."	"{Calendar gregorian isoDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: 1}"	"{Calendar gregorian isoDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: 7}"	^(canonicalDayOfWeekOrdinal - 2 \\ DaysPerWeek) + 1.</body><body package="Chronos-Calendars-Foundation" selector="isoDayOfWeekOrdinalFromDaysSinceEpoch:">isoDayOfWeekOrdinalFromDaysSinceEpoch: daysSinceEpoch	"Answer the ordinal number of the day of the week of the day that is &lt;daysSinceEpoch&gt; days from the receiver's epoch. Use the ISO 8601 numbering convention, where Monday=1 and Sunday=7."	^(self daysSinceStartOfISOWeekFromDaysSinceEpoch: daysSinceEpoch) + 1</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-unification</category><body package="Chronos-Calendars-Foundation" selector="secondsSinceEpochFromSecondsSinceUnificationEpoch:">secondsSinceEpochFromSecondsSinceUnificationEpoch: secondsSinceUnificationEpoch	"Answer the number of seconds since the initial moment of the epoch day of the receiver's calendar, converted from &lt;secondsSinceUnificationEpoch&gt; seconds from the initial moment of the epoch day of the unification calendar."	^secondsSinceUnificationEpoch - secondsSinceUnificationEpochUpToEpoch</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceMidnightFromSecondsSinceStartOfDay:">secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay	"Answer the number of seconds-since-start-of-day relative to midnight represented by the argument, &lt;secondsSinceStartOfDay&gt;, where the argument is specified relative to the receiver's canonical start-of-day (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since midnight clock time that corresponds to the number of seconds since the receiver's canonical start-of-day clock time, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for calendar systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Hebrew calendar, the canonical start-of-day is 6pm."	^secondsSinceStartOfDay</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceStartOfDayFromSecondsSinceMidnight:">secondsSinceStartOfDayFromSecondsSinceMidnight: secondsSinceMidnight	"Answer the number of seconds-since-start-of-day relative to the receiver's canonical start-of-day represented by the argument, &lt;secondsSinceMidnight&gt;, where the argument is specified relative to midnight (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since the receiver's canonical start-of-day clock time that corresponds to the number of seconds since midnight, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for calendar systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Hebrew calendar, the canonical start-of-day is 6pm."	^secondsSinceMidnight</body><body package="Chronos-Calendars-Foundation" selector="secondsSinceUnificationEpochFromSecondsSinceEpoch:">secondsSinceUnificationEpochFromSecondsSinceEpoch: secondsSinceEpoch	"Answer the number of seconds from the initial moment of the epoch day of the unification calendar, converted from &lt;secondsSinceEpoch&gt; seconds since the initial moment of the epoch day of the receiver's calendar."	^secondsSinceEpoch + secondsSinceUnificationEpochUpToEpoch</body><body package="Chronos-Calendars-Foundation" selector="unificationDayNumberOfEpoch">unificationDayNumberOfEpoch	"Answer the number of days since the epoch of the unification calendar that corresponds to the initial moment of the epoch day of the receiver's calendar."	^(self secondsSinceUnificationEpochFromSecondsSinceEpoch: 0) // SecondsPerDay</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Foundation" selector="dateSpecFromDaysSinceEpoch:">dateSpecFromDaysSinceEpoch: daysSinceEpoch 	"Answer an instance of DateSpec that specifies a year/month/day that is daysSinceEpoch days since my Epoch."	^self 		forDaysSinceEpoch: daysSinceEpoch 		setYearAndCalendarDayInto: DateSpec basicNew</body><body package="Chronos-Calendars-Foundation" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearMonthDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	^self 		startingWithYear: (yearNumberingPolicy canonicalFromCardinal: 0)		addingDays: daysSinceEpoch		setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2</body><body package="Chronos-Calendars-Foundation" selector="forMonthsSinceEpoch:setYearAndMonthsSinceStartOfYearInto:">forMonthsSinceEpoch: monthsSinceEpoch setYearAndMonthsSinceStartOfYearInto: block2 	"For a year and months-since-start-of-year that is monthsSinceEpoch months since my Epoch, send #value:value: to &lt;block2&gt;, with the year as the first argument and the months-since-start-of-year as the second argument."	^self 		startingWithYear: (yearNumberingPolicy canonicalFromCardinal: 0)		addingMonths: monthsSinceEpoch		setYearAndMonthsSinceStartOfYearInto: block2</body><body package="Chronos-Calendars-Foundation" selector="startingWithYear:addingDays:setYearAndCalendarDayInto:">startingWithYear: startYear addingDays: dayDelta setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2 	"For a year and CalendarDay that is dayDelta days since the first day of the year &lt;startYear&gt;, send #value:value: to &lt;yearMonthDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	| ordinalYear |	^self isDaysPerYearInvariant		ifTrue: 			[| endingYear |			ordinalYear := yearNumberingPolicy cardinalFromCanonical: startYear.			endingYear := yearNumberingPolicy canonicalFromCardinal: (ordinalYear + (dayDelta // self maxDaysPerYear)).			yearMonthDaySpecOrBlock2 				value: endingYear				value: (self calendarDayFromDayOfYearOrdinal: dayDelta \\ self maxDaysPerYear + 1 inYear: endingYear)]		ifFalse: 			["Default algorithm that will work, but is probably much slower than some alternative--except for a small number of days."			| days daysInYear yearTypeCode canonicalYear |			days := dayDelta.			canonicalYear := startYear.			ordinalYear := yearNumberingPolicy ordinalFromCanonical: canonicalYear.			yearTypeCode := self typeCodeOfYear: canonicalYear.						[days &gt;= (daysInYear := self daysInYearForYearTypeCode: yearTypeCode)] 					whileTrue: 						[ordinalYear := ordinalYear + 1.						canonicalYear := yearNumberingPolicy canonicalFromOrdinal: ordinalYear.						yearTypeCode := self typeCodeOfYear: canonicalYear.						days := days - daysInYear].			[days &lt; 0] whileTrue: 					[ordinalYear := ordinalYear - 1.					canonicalYear := yearNumberingPolicy canonicalFromOrdinal: ordinalYear.					yearTypeCode := self typeCodeOfYear: canonicalYear.					days := days + (daysInYear := self daysInYearForYearTypeCode: yearTypeCode)].			yearMonthDaySpecOrBlock2 				value: canonicalYear				value: (self calendarDayFromDayOfYearOrdinal: days + 1 forYearTypeCode: yearTypeCode)]</body><body package="Chronos-Calendars-Foundation" selector="startingWithYear:addingMonths:setYearAndMonthsSinceStartOfYearInto:">startingWithYear: startYear addingMonths: monthDelta setYearAndMonthsSinceStartOfYearInto: block2 	"For a year and months-since-start-of-year that is monthDelta months since the first month of the year &lt;startYear&gt;, send #value:value: to &lt;block2&gt;, with the year as the first argument and the months-since-start-of-year as the second argument."	| ordinalYear |	^self isMonthsPerYearInvariant		ifTrue: 			[ordinalYear := yearNumberingPolicy cardinalFromCanonical: startYear.			block2 				value: (yearNumberingPolicy canonicalFromCardinal: (ordinalYear + (monthDelta // self maxMonthsPerYear)))				value: monthDelta \\ self maxMonthsPerYear]		ifFalse: 			["Default algorithm that will work, but is probably much slower than some alternative--except for a small number of months."			| months monthsInYear canonicalYear |			months := monthDelta.			canonicalYear := startYear.			ordinalYear := yearNumberingPolicy ordinalFromCanonical: canonicalYear.						[months &gt;= (monthsInYear := self monthsInYear: canonicalYear)] 					whileTrue: 						[ordinalYear := ordinalYear + 1.						canonicalYear := yearNumberingPolicy canonicalFromOrdinal: ordinalYear.						months := months - monthsInYear].			[months &lt; 0] whileTrue: 					[ordinalYear := ordinalYear - 1.					canonicalYear := yearNumberingPolicy canonicalFromOrdinal: ordinalYear.					months := months + (monthsInYear := self self monthsInYear: canonicalYear)].			block2 				value: canonicalYear 				value: months]</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	"Initialize the receiver so that it becomes fully functional as a Calendar object that implements a particular calenrdical system. Fail if the receiver is not mutable."	self assertMutability.	yearNumberingPolicy := self newDefaultYearNumberingPolicy.	self initializeIntraYearValues.	self initializeRangeConstraints.	self bindToSystem.	self beImmutable.</body><body package="Chronos-Calendars-Foundation" selector="invalidate">invalidate	| originalLock |	originalLock := lock.	lock := nil.	[self initialize] ensure: [lock := originalLock]</body><body package="Chronos-Calendars-Foundation" selector="invalidateClock">invalidateClock	"Ensure that the receiver's CalendarClock is the correct implmentation for the current system environment."	clock := self newCalendarClock.	self bindToClock.</body><body package="Chronos-Calendars-Foundation" selector="register">register	"Register the receiver as the canonical instance of its class."	| key old |	key := self registrationKey.	key == nil ifTrue: [^nil].	old := self class instanceRegistry at: key ifAbsentPut: [self].	old == self 		ifFalse: 			["The only obvious reason it should ever be necessary to register one Calendar instance in place of another is because their classes are different (and so have different behavior.)  However, the invariant that there is only one Calendar instance with a given key (where 'Calendar' is understood as a role/type, not a class) must be be maintained."			self class instanceRegistry at: key put: self.			ChronosEnvironment canonical invalidateCalendarBindings]</body><body package="Chronos-Calendars-Foundation" selector="release">release	"Remove references to objects that may refer to the receiver. Answers self. 	This message should be overidden by subclasses with any cycles, in which	case the subclass should also include the expression super release."	super release.	InstanceRegistry == nil ifFalse: [InstanceRegistry removeKey: self registrationKey ifAbsent: []]</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>converting</category><body package="Chronos-Calendars-Foundation" selector="asCalendar">asCalendar	"Answer the Calendar represented by the receiver.  If the receiver is a Calendar instance, answer the receiver.  If the receiver is a Calendar class, answer its canonical instance.  If the receiver is an indirect reference to a calendrical system, answer the canonical Calendar instance that implements that calendrical system."	^self</body><body package="Chronos-Calendars-Foundation" selector="canonical">canonical	"Answer the instance of the receiver's class that is the canonical instance."	| value |	value := self class canonical.	^value == nil ifTrue: [self] ifFalse: [value]</body></methods><methods><class-id>Chronos.Calendar</class-id> <category>enumerating</category><body package="Chronos-Calendars-Foundation" selector="monthKeysAndMonthNameKeysDo:">monthKeysAndMonthNameKeysDo: block1 	monthNameKeysByMonthKey == nil ifTrue: [self bindToYearlyCalendars].	doMonthKeysAlwaysCorrespondToTheSameMonthNameKey 		ifTrue: [monthNameKeysByMonthKey keysAndValuesDo: block1]		ifFalse: 			[monthNameKeysByMonthKey keysAndValuesDo: 					[:monthKey :monthNameKeySet | 					monthNameKeySet 						do: [:monthNameKey | block1 value: monthKey value: monthNameKey]]]</body><body package="Chronos-Calendars-Foundation" selector="monthKeysAndMonthOrdinalsDo:">monthKeysAndMonthOrdinalsDo: block1 	monthOrdinalsByMonthKey == nil ifTrue: [self bindToYearlyCalendars].	monthOrdinalsAlwaysCorrespondToTheSameMonthKey 		ifTrue: [monthOrdinalsByMonthKey keysAndValuesDo: block1]		ifFalse: 			[monthOrdinalsByMonthKey keysAndValuesDo: 					[:monthKey :monthOrdinalSet | 					monthOrdinalSet 						do: [:monthOrdinal | block1 value: monthKey value: monthOrdinal]]]</body><body package="Chronos-Calendars-Foundation" selector="monthKeysDo:">monthKeysDo: block1	monthOrdinalsByMonthKey == nil ifTrue: [self bindToYearlyCalendars].	monthOrdinalsByMonthKey keysDo: block1</body><body package="Chronos-Calendars-Foundation" selector="monthNameKeysAndMonthKeysDo:">monthNameKeysAndMonthKeysDo: block1 	monthKeyByMonthNameKey == nil ifTrue: [self bindToYearlyCalendars].	monthKeyByMonthNameKey keysAndValuesDo: block1</body><body package="Chronos-Calendars-Foundation" selector="monthNameKeysDo:">monthNameKeysDo: block1	monthKeyByMonthNameKey == nil ifTrue: [self bindToYearlyCalendars].	monthKeyByMonthNameKey keysDo: block1</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinalsAndMonthKeysDo:">monthOrdinalsAndMonthKeysDo: block1 	monthKeysByMonthOrdinal == nil ifTrue: [self bindToYearlyCalendars].	monthOrdinalsAlwaysCorrespondToTheSameMonthKey 		ifTrue: [monthKeysByMonthOrdinal keysAndValuesDo: block1]		ifFalse: 			[monthKeysByMonthOrdinal keysAndValuesDo: 					[:monthOrdinal :monthKeySet | 					monthKeySet 						do: [:monthKey | block1 value: monthOrdinal value: monthKey]]]</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="ansiStandard">ansiStandard	"Answer the Calendar that implements the calendrical system required for the implementation of DateAndTime objects, as specified by the ANSI Smalltalk standard. Specifically, answer the Calendar that implements the Gregorian Calendar using Astronomical Year Numbering (i.e., that uses an OrdinalNumberingPolicy as its yearNumberingPolicy.)"	^self gregorian</body><body package="Chronos-Calendars-Foundation" selector="at:">at: registrationKey	"Answer the canonical Calendar instance whose registration key (semantic key) is &lt;registrationKey&gt;. If none, raise an Exception."	^self at: registrationKey asSymbol ifAbsent: [self signalError: 'No Calendar found with key=', registrationKey printString]</body><body package="Chronos-Calendars-Foundation" selector="at:ifAbsent:">at: registrationKey ifAbsent: missing	"Answer the canonical Calendar instance whose registration key (semantic key) is &lt;registrationKey&gt;. If none, answer the result of evaluating the zero-argument block &lt;missing&gt;."	| calendar |	calendar := self instanceRegistry at: registrationKey ifAbsent: [0].	(calendar == nil or: [calendar = 0]) ifFalse: [^calendar].	^(self classRegistry at: registrationKey ifAbsent: [^missing value]) new register</body><body package="Chronos-Calendars-Foundation" selector="canonical">canonical	"Answer the canonical instance of the receiver."	^self at: self registrationKey		ifAbsent: 			[(self registrationKey == nil or: [self isObsolete]) 				ifFalse: 					[self register.					self canonical]]</body><body package="Chronos-Calendars-Foundation" selector="clock">clock	"Answer the CalendarClock associated with the canonical instance of the receiver."	^self canonical clock</body><body package="Chronos-Calendars-Foundation" selector="gregorian">gregorian	"Answer the Calendar object that implements the Gregorian Calendar using Astronomical Year Numbering (i.e., that uses an OrdinalNumberingPolicy as its yearNumberingPolicy.)"	Gregorian == nil		ifTrue: 			[^GregorianCalendar rebindCanonicalInstance].	^Gregorian</body><body package="Chronos-Calendars-Foundation" selector="julian">julian	"Answer the Calendar object that implements the Julian Calendar as first defined and used by Dionysius Exiguus."	Julian == nil		ifTrue: 			[^JulianCalendar rebindCanonicalInstance].	^Julian</body><body package="Chronos-Calendars-Foundation" selector="referencedBy:">referencedBy: aCalendarOrCalendarRegistrationKey 	"Anser the value referenced by &lt;aCalendarOrCalendarRegistrationKey&gt;. If the value is a key, answer the value bound to the key. Otherwise, answer aCalendarOrCalendarRegistrationKey itself."	^aCalendarOrCalendarRegistrationKey == nil 		ifTrue: [AnsiStandardCalendar]		ifFalse: 			[aCalendarOrCalendarRegistrationKey isString 				ifTrue: [self at: aCalendarOrCalendarRegistrationKey]				ifFalse: [aCalendarOrCalendarRegistrationKey asCalendar]]</body><body package="Chronos-Calendars-Foundation" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by instances of the receiver."	^nil</body><body package="Chronos-Calendars-Foundation" selector="unification">unification	"Answer the 'unification calendar'--the Calendar used to unify the all the calendars implemented by concrete subclasses of Calendar, so that it is possible to interconvert dates between calendrical systems."	^self gregorian</body><body package="Chronos-Calendars-Foundation" selector="yearNumberingPolicy">yearNumberingPolicy	"Answer the instance of the concrete subclass of NumberingPolicy that implements the year-numbering policy of the calendrical system represented by instances of the receiver."	yearNumberingPolicy == nil ifTrue: [yearNumberingPolicy := self newDefaultYearNumberingPolicy].	^yearNumberingPolicy</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>functional verification</category><body package="Chronos-Calendars-Foundation" selector="basicDaysSinceEpochUpToYearVerifier">basicDaysSinceEpochUpToYearVerifier	^[:calendar :year | 	| passes |	passes := false.	calendar 		forDaysSinceEpoch: (calendar daysSinceEpochUpToYear: year)		setYearAndCalendarDayInto: 			[:computedYear :calendarDay | 			passes := year = computedYear and: [calendarDay daysSinceStartOfYear = 0]].	passes]</body><body package="Chronos-Calendars-Foundation" selector="basicForDaysSinceEpochSetYearAndCalendarDayIntoVerifier">basicForDaysSinceEpochSetYearAndCalendarDayIntoVerifier	^[:calendar :daysSinceEpoch | 	| passes |	passes := false.	calendar 		forDaysSinceEpoch: daysSinceEpoch		setYearAndCalendarDayInto: 			[:year :calendarDay | 			passes := 				(calendar 					daysSinceEpochUpToMonth: calendarDay month					day: calendarDay dayOfMonth					inYear: year) = daysSinceEpoch.			passes ifFalse: [nil halt]].	passes]</body><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochUpToMonthDayInYearPassesVerification">daysSinceEpochUpToMonthDayInYearPassesVerification	^self daysSinceEpochUpToMonthDayInYearVerifier value: self canonical</body><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochUpToMonthDayInYearVerifier">daysSinceEpochUpToMonthDayInYearVerifier	^[:calendar |		(self daysSinceEpochUpToYearVerifier value: calendar)			and: [self daysUpToMonthDayInYearVerifier value: calendar]]</body><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochUpToYearPassesVerification">daysSinceEpochUpToYearPassesVerification	^self daysSinceEpochUpToYearVerifier value: self canonical</body><body package="Chronos-Calendars-Foundation" selector="daysSinceEpochUpToYearVerifier">daysSinceEpochUpToYearVerifier	"{Calendar daysSinceEpochUpToYearVerifier value: Calendar gregorian}"	^[:calendar | 	| passes |	passes := true.	self minVerificationYearCardinal to: self maxVerificationYearCardinal		do: 			[:cardinalYear | 			| yearPasses |			yearPasses := self basicDaysSinceEpochUpToYearVerifier value: calendar value: (self yearNumberingPolicy canonicalFromCardinal: cardinalYear).			passes := passes and: [yearPasses]].	passes].</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonthDayInYearPassesVerification">daysUpToMonthDayInYearPassesVerification	^self daysUpToMonthDayInYearVerifier value: self canonical</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonthDayInYearVerifier">daysUpToMonthDayInYearVerifier	"VERIFICATION:		{Calendar daysUpToMonthDayInYearVerifier value: Calendar gregorian}"	^[:calendar | 	| exceptions |	exceptions := OrderedCollection new.	self minVerificationYearCardinal to: self maxVerificationYearCardinal		do: 			[:cardinalYear | 			| canonicalYear daysUpToEndOfPrevMonth |			canonicalYear := calendar yearNumberingPolicy canonicalFromCardinal: cardinalYear.			daysUpToEndOfPrevMonth := 0.			1 to: (calendar monthsInYear: canonicalYear)				do: 					[:monthOrdinal | 					| daysInMonth |					(calendar daysUpToMonth: monthOrdinal day: 1 inYear: canonicalYear) = daysUpToEndOfPrevMonth 						ifFalse: [exceptions add: monthOrdinal -&gt; #firstDayOfMonth].					daysInMonth := calendar daysInMonth: monthOrdinal inYear: canonicalYear.					(calendar daysUpToMonth: monthOrdinal day: daysInMonth inYear: canonicalYear) = (daysUpToEndOfPrevMonth + daysInMonth - 1) 						ifFalse: [exceptions add: monthOrdinal -&gt; #lastDayOfMonth].					daysUpToEndOfPrevMonth := daysUpToEndOfPrevMonth + daysInMonth]].	exceptions isEmpty]</body><body package="Chronos-Calendars-Foundation" selector="forDaysSinceEpochSetYearAndCalendarDayIntoPassesVerification">forDaysSinceEpochSetYearAndCalendarDayIntoPassesVerification	^self forDaysSinceEpochSetYearAndCalendarDayIntoVerifier value: self canonical</body><body package="Chronos-Calendars-Foundation" selector="forDaysSinceEpochSetYearAndCalendarDayIntoVerifier">forDaysSinceEpochSetYearAndCalendarDayIntoVerifier	^[:calendar | 	| passes daysSinceEpoch daysInPrevYear |	passes := true.	daysSinceEpoch := nil.	daysInPrevYear := 0.	self minVerificationYearCardinal to: self maxVerificationYearCardinal		do: 			[:cardinalYear | 			| canonicalYear |			canonicalYear := self yearNumberingPolicy canonicalFromCardinal: cardinalYear.			daysSinceEpoch := daysSinceEpoch == nil				ifTrue: [calendar daysSinceEpochUpToYear: canonicalYear]				ifFalse: [daysSinceEpoch + daysInPrevYear].			daysInPrevYear := 0.			1 to: (calendar monthsInYear: canonicalYear)				do: 					[:monthOrdinal | 					| daysInMonth firstDayOfMonthPasses lastDayOfMonthPasses |										firstDayOfMonthPasses := 						self basicForDaysSinceEpochSetYearAndCalendarDayIntoVerifier 							value: calendar value: daysSinceEpoch. "First day of month"					daysInMonth := calendar daysInMonth: monthOrdinal inYear: canonicalYear.					daysInPrevYear := daysInPrevYear + daysInMonth.					daysSinceEpoch := daysSinceEpoch + daysInMonth.					lastDayOfMonthPasses := 						self basicForDaysSinceEpochSetYearAndCalendarDayIntoVerifier 							value: calendar value: daysSinceEpoch - 1. "Last day of month"					passes := passes and: [firstDayOfMonthPasses and: [lastDayOfMonthPasses]]]].	passes].</body><body package="Chronos-Calendars-Foundation" selector="fundamentalAlgorithmsPassVerification">fundamentalAlgorithmsPassVerification	"{GregorianCalendar fundamentalAlgorithmsPassVerification}	{JulianCalendar fundamentalAlgorithmsPassVerification}	{ImperialJulianCalendar fundamentalAlgorithmsPassVerification}	{DurationFactory toRun: [10 timesRepeat: [GregorianCalendar fundamentalAlgorithmsPassVerification]]}"	^self daysSinceEpochUpToMonthDayInYearPassesVerification		and: [self forDaysSinceEpochSetYearAndCalendarDayIntoPassesVerification]</body><body package="Chronos-Calendars-Foundation" selector="maxVerificationYearCardinal">maxVerificationYearCardinal	^2500</body><body package="Chronos-Calendars-Foundation" selector="minVerificationYearCardinal">minVerificationYearCardinal	^-2500</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>converting</category><body package="Chronos-Calendars-Foundation" selector="asCalendar">asCalendar	"Answer the Calendar represented by the receiver.  If the receiver is a Calendar instance, answer the receiver.  If the receiver is a Calendar class, answer its canonical instance.  If the receiver is an indirect reference to a calendrical system, answer the canonical Calendar instance that implements that calendrical system."	^self canonical</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self canonical</body><body package="Chronos-Calendars-Foundation" selector="classRegistry">classRegistry	"Answer the registry used to associate the semantic key that identifies a particular calendrical system with the concrete subclass of Calendar that implements that calendrical system."	ClassRegistry == nil ifTrue: [ClassRegistry := self newClassRegistry].	^ClassRegistry</body><body package="Chronos-Calendars-Foundation" selector="instanceRegistry">instanceRegistry	"Answer the registry used to associate the semantic key that identifies a particular calendrical system with the canonical instance of the subclass of Calendar that implements that calendrical system."	InstanceRegistry == nil 		ifTrue: [InstanceRegistry := self newInstanceRegistry].	^InstanceRegistry</body><body package="Chronos-Calendars-Foundation" selector="newCardinalYearNumberingPolicy">newCardinalYearNumberingPolicy	"Answer a new CardinalNumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. Using a CardinalNumberingPolicy as the year numbering policy of a calendar is precisely equivalent to what is sometimes called 'Elapsed Year Numbering' or 'Expired Year Numbering'--commonly used by the various Hindu Calendars."	^CardinalNumberingPolicy 		semanticKey: #year		zeroInvalidMessage: 'This error should not have occurred.'</body><body package="Chronos-Calendars-Foundation" selector="newClassRegistry">newClassRegistry	"Answer a new Dictionary-like object to be used as the registry by which a semantic key that identifies a particular calendrical system is associated with the concrete subclass of Calendar that implements that calendrical system."	^EnvironmentFacade current newWeakDictionary</body><body package="Chronos-Calendars-Foundation" selector="newDefaultYearNumberingPolicy">newDefaultYearNumberingPolicy	"Answer a new NumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. NOTE: The ANSI Smalltalk standard REQUIRES the use of 'Astronomical Year Numbering' (i.e., an OrdinalNumberingPolicy) for dates in the Gregorian calendar. The ISO 8601 standard imposes the same requirement."	^self newOrdinalYearNumberingPolicy</body><body package="Chronos-Calendars-Foundation" selector="newInstanceRegistry">newInstanceRegistry	"Answer a new Dictionary-like object to be used as the registry by which a semantic key that identifies a particular calendrical system is associated with the canonical instance of the concrete subclass of Calendar that implements that calendrical system."	^EnvironmentFacade current newWeakDictionary</body><body package="Chronos-Calendars-Foundation" selector="newOrdinalYearNumberingPolicy">newOrdinalYearNumberingPolicy	"Answer a new OrdinalNumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. Using an OrdinalNumberingPolicy as the year numbering policy of a calendar implements the year-numbering convention sometimes called 'Astronomical Year Numbering.' The ANSI Smalltalk standard REQUIRES the use of 'Astronomical Year Numbering' (i.e., an OrdinalNumberingPolicy) for dates in the Gregorian calendar. The ISO 8601 standard imposes the same requirement."	^OrdinalNumberingPolicy 		semanticKey: #year		zeroInvalidMessage: 'This error should not have occurred'.</body><body package="Chronos-Calendars-Foundation" selector="newZerolessOrdinalYearNumberingPolicy">newZerolessOrdinalYearNumberingPolicy	"Answer a new ZerolessOrdinalNumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. Using a ZerolessOrdinalNumberingPolicy as the year numbering policy of a calendar implements the convention traditionally used to number years in most calendrical systems, such as the Julian Calendar."	^ZerolessOrdinalNumberingPolicy 		semanticKey: #year		zeroInvalidMessage: 'The year zero does not exist in the ', self name, ' calendar, which uses a zero-less (traditional, non-astronimical) year numbering system.'</body><body package="Chronos-Calendars-Foundation" selector="rebindCanonicalInstance">rebindCanonicalInstance	self register.	InstanceRegistry == nil 		ifFalse: [InstanceRegistry removeKey: self registrationKey ifAbsent: []].	^self at: self registrationKey</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>queries</category><body package="Chronos-Calendars-Foundation" selector="allRegisteredKeys">allRegisteredKeys	"Answer the registrationKeys (semantic keys) for all implemented, resident Calendars."	^self classRegistry keys</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Foundation" selector="basicInvalidate">basicInvalidate	self register.	self allInstancesDo: [:instance | [instance invalidate] on: Error do: [:ex | self reportToConsole: ex description]].</body><body package="Chronos-Calendars-Foundation" selector="basicInvalidateClock">basicInvalidateClock	"Ensure that the CalendarClock of all Calendar instances is the correct implmentation for the current system environment."	self allInstancesDo: [:instance | instance invalidateClock].</body><body package="Chronos-Calendars-Foundation" selector="initializeCalendarConstants">initializeCalendarConstants	"Calendar initializeCalendarConstants"	InstanceRegistry := nil.	Gregorian == nil ifFalse: [Gregorian release].	Julian == nil ifFalse: [Julian release].	ClassRegistry := nil.	self registerAll.	GregorianCalendar rebindCanonicalInstance.	JulianCalendar rebindCanonicalInstance.</body><body package="Chronos-Calendars-Foundation" selector="invalidate">invalidate	self basicInvalidate.	self subclasses do: [:each | each invalidate]</body><body package="Chronos-Calendars-Foundation" selector="invalidateClock">invalidateClock	"Ensure that the CalendarClock of all Calendar instances is the correct implmentation for the current system environment."	self basicInvalidateClock.	self subclasses do: [:each | each invalidateClock]</body><body package="Chronos-Calendars-Foundation" selector="register">register	| key |	key := self registrationKey.	(key == nil or: [self isAbstract]) 		ifFalse: [self classRegistry at: key put: self].</body><body package="Chronos-Calendars-Foundation" selector="registerAll">registerAll	self register.	self subclasses do: [:each | each registerAll]</body><body package="Chronos-Calendars-Foundation" selector="release">release	self allInstancesDo: [:each | each release].	ClassRegistry == nil 		ifFalse: [ClassRegistry removeKey: self registrationKey ifAbsent: []]</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Foundation" selector="monthsInYear:">monthsInYear: year 	"Answer the number of months there are in the given &lt;year&gt;."	^self canonical monthsInYear: year</body><body package="Chronos-Calendars-Foundation" selector="monthsInYearForYearTypeCode:">monthsInYearForYearTypeCode: yearTypeCode 	"Answer the number of months there are per year, in a year whose typeCode is &lt;yearTypeCode&gt;."	^self canonical monthsInYearForYearTypeCode: yearTypeCode</body><body package="Chronos-Calendars-Foundation" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^self canonical typeCodeOfYear: calendarYear</body></methods><methods><class-id>Chronos.Calendar class</class-id> <category>testing</category><body package="Chronos-Calendars-Foundation" selector="isAbstract">isAbstract	^self registrationKey == nil</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="bindToYearlyCalendars">bindToYearlyCalendars	self initializeMonthSemantics.	maxDaysPerYear := 0.	maxMonthsPerYear := 0.	maxDaysPerMonth := 0.	yearlyCalendars do: [:yearlyCalendar |		maxDaysPerYear := maxDaysPerYear max: yearlyCalendar daysPerYear.		maxMonthsPerYear := maxMonthsPerYear max: yearlyCalendar monthsPerYear.		yearlyCalendar 			monthsDo: [:monthlyCalendar | 				maxDaysPerMonth := maxDaysPerMonth max: monthlyCalendar daysPerMonth.				(monthOrdinalsByMonthKey at: monthlyCalendar monthKey ifAbsentPut: [Set new]) add: monthlyCalendar monthOrdinal.				(monthKeysByMonthOrdinal at: monthlyCalendar monthOrdinal ifAbsentPut: [Set new]) add: monthlyCalendar monthKey.				(monthNameKeysByMonthKey at: monthlyCalendar monthKey ifAbsentPut: [Set new]) add: monthlyCalendar nameKey.				monthKeyByMonthNameKey at: monthlyCalendar nameKey put: monthlyCalendar monthKey]].	monthOrdinalsAlwaysCorrespondToTheSameMonthKey := ChronosFunction allElementsOf: monthOrdinalsByMonthKey satisfy: [:monthOrdinalsSet | monthOrdinalsSet size = 1].	monthOrdinalsAlwaysCorrespondToTheSameMonthKey		ifTrue: 			[| map |			map := Dictionary new.			monthOrdinalsByMonthKey keysAndValuesDo: [:monthKey :monthOrdinalSet | monthOrdinalSet do: [:monthOrdinal | map at: monthKey put: monthOrdinal]].			monthOrdinalsByMonthKey := map.			map := Dictionary new.			monthKeysByMonthOrdinal keysAndValuesDo: [:monthOrdinal :monthKeySet | monthKeySet do: [:monthKey | map at: monthOrdinal put: monthKey]].			monthKeysByMonthOrdinal := map].	doMonthKeysAlwaysCorrespondToTheSameMonthNameKey := ChronosFunction allElementsOf: monthNameKeysByMonthKey satisfy: [:monthNameKeySet | monthNameKeySet size = 1].	doMonthKeysAlwaysCorrespondToTheSameMonthNameKey		ifTrue: 			[| map |			map := Dictionary new.			monthNameKeysByMonthKey keysAndValuesDo: [:monthKey :monthNameKeySet | monthNameKeySet do: [:monthNameKey | map at: monthKey put: monthNameKey]].			monthNameKeysByMonthKey := map].	minDaysPerYear := maxDaysPerYear.	minDaysPerMonth := maxDaysPerMonth.	minMonthsPerYear := maxMonthsPerYear.	yearlyCalendars do: [:yearlyCalendar |		minDaysPerYear := minDaysPerYear min: yearlyCalendar daysPerYear.		minMonthsPerYear := minMonthsPerYear min: yearlyCalendar monthsPerYear.		yearlyCalendar monthsDo: [:monthlyCalendar | minDaysPerMonth := minDaysPerMonth min: monthlyCalendar daysPerMonth]].</body><body package="Chronos-Calendars-Regular" selector="computeArrayOfYearlyCalendars">computeArrayOfYearlyCalendars	| list |	list := SortedCollection sortBlock: [:a :b | a yearTypeCode &lt; b yearTypeCode].	self yearTypeCodesDo: [:yearTypeCode | list add: (self computeCalendarForYearTypeCode: yearTypeCode)].	^list asArray</body><body package="Chronos-Calendars-Regular" selector="computeCalendarForYearTypeCode:">computeCalendarForYearTypeCode: yearTypeCode	^StaticYearlyCalendar 		calendar: self		typeCode: yearTypeCode 		specificationOfMonths: (self class specificationOfMonthsForYearTypeCode: yearTypeCode)</body><body package="Chronos-Calendars-Regular" selector="initializeIntraYearValues">initializeIntraYearValues	"Initialize the instance variables of the receiver that specify or describe the properties and organizational structure of days-of-the-year, months and days-of-the-month in the calendrical system of the receiver."	super initializeIntraYearValues.	self setYearlyCalendars: self computeArrayOfYearlyCalendars.</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>API-queries-months</category><body package="Chronos-Calendars-Regular" selector="daysInMonth:forYearTypeCode:">daysInMonth: monthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days in the month whose ordinal is &lt;monthOrdinal&gt;, in a year whose typeCode is &lt;yearTypeCode&gt;."	^((yearlyCalendars at: yearTypeCode) monthAt: monthOrdinal) daysPerMonth</body><body package="Chronos-Calendars-Regular" selector="maximumDayOfYearOrdinalForMonth:day:">maximumDayOfYearOrdinalForMonth: monthOrdinal day: dayOfMonthOrdinal 	"Answer the largest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthOrdinal&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^yearlyCalendars inject: 1		into: 			[:max :yearlyCalendar | 			| dayOfYearOrdinal |			dayOfYearOrdinal := dayOfMonthOrdinal = 1 						ifTrue: [(yearlyCalendar daysUpToMonth: monthOrdinal) + 1]						ifFalse: 							[yearlyCalendar dayOfYearOrdinalForMonth: monthOrdinal								day: dayOfMonthOrdinal].			dayOfYearOrdinal == nil ifTrue: [max] ifFalse: [dayOfYearOrdinal max: max]]</body><body package="Chronos-Calendars-Regular" selector="maximumDayOfYearOrdinalForMonthWithKey:day:">maximumDayOfYearOrdinalForMonthWithKey: monthKey day: dayOfMonthOrdinal	"Answer the largest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthKey&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^yearlyCalendars 		inject: 1 		into: [:max :yearlyCalendar | 			| dayOfYearOrdinal |			dayOfYearOrdinal := dayOfMonthOrdinal = 1					ifTrue: [(yearlyCalendar daysUpToMonthWithKey: monthKey ifAbsent: [max - 1]) + 1]					ifFalse: [(yearlyCalendar daysUpToMonthWithKey: monthKey day: dayOfMonthOrdinal ifAbsent: [max - 1]) + 1].			dayOfYearOrdinal == nil				ifTrue: [max]				ifFalse: 					[dayOfYearOrdinal max: max]]</body><body package="Chronos-Calendars-Regular" selector="maximumDaysInMonth:">maximumDaysInMonth: monthOrdinal 	"Answer the most number of days that may occur, for any year, in the month whose ordinal is &lt;monthOrdinal&gt;."	^yearlyCalendars inject: self minDaysPerMonth		into: [:max :yearlyCalendar | (yearlyCalendar daysInMonthAt: monthOrdinal) max: max]</body><body package="Chronos-Calendars-Regular" selector="maximumDaysInMonthWithKey:">maximumDaysInMonthWithKey: monthKey	"Answer the most number of days that may occur, for any year, in the month whose key is &lt;monthKey&gt;."	^yearlyCalendars inject: self minDaysPerMonth		into: [:max :yearlyCalendar | (yearlyCalendar daysInMonthWithKey: monthKey ifAbsent: [max]) max: max ]</body><body package="Chronos-Calendars-Regular" selector="minimumDayOfYearOrdinalForMonth:day:">minimumDayOfYearOrdinalForMonth: monthOrdinal day: dayOfMonthOrdinal 	"Answer the smallest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthOrdinal&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^yearlyCalendars inject: self maxDaysPerYear		into: 			[:min :yearlyCalendar | 			| dayOfYearOrdinal |			dayOfYearOrdinal := 					dayOfMonthOrdinal = 1 						ifTrue: [(yearlyCalendar daysUpToMonth: monthOrdinal) + 1]						ifFalse: 							[yearlyCalendar dayOfYearOrdinalForMonth: monthOrdinal								day: dayOfMonthOrdinal].			dayOfYearOrdinal == nil ifTrue: [min] ifFalse: [dayOfYearOrdinal min: min]]</body><body package="Chronos-Calendars-Regular" selector="minimumDayOfYearOrdinalForMonthWithKey:day:">minimumDayOfYearOrdinalForMonthWithKey: monthKey day: dayOfMonthOrdinal	"Answer the smallest day-of-year ordinal corresponding to the intra-year date desgnation &lt;monthKey&gt;/&lt;dayOfMonthOrdinal&gt;, for a year of any type."	^yearlyCalendars 		inject: self maxDaysPerYear 		into: [:min :yearlyCalendar | 			| dayOfYearOrdinal |			dayOfYearOrdinal := dayOfMonthOrdinal = 1					ifTrue: [(yearlyCalendar daysUpToMonthWithKey: monthKey ifAbsent: [min - 1]) + 1]					ifFalse: [(yearlyCalendar daysUpToMonthWithKey: monthKey day: dayOfMonthOrdinal ifAbsent: [min - 1]) + 1].			dayOfYearOrdinal == nil				ifTrue: [min]				ifFalse: 					[dayOfYearOrdinal min: min]]</body><body package="Chronos-Calendars-Regular" selector="minimumDaysInMonth:">minimumDaysInMonth: monthOrdinal	"Answer the least number of days that may occur, for any year, in the month whose ordinal is &lt;monthOrdinal&gt;."	^yearlyCalendars inject: self maxDaysPerMonth		into: [:min :yearlyCalendar | (yearlyCalendar daysInMonthAt: monthOrdinal) min: min ]</body><body package="Chronos-Calendars-Regular" selector="minimumDaysInMonthWithKey:">minimumDaysInMonthWithKey: monthKey	"Answer the least number of days that may occur, for any year, in the month whose key is &lt;monthKey&gt;."	^yearlyCalendars inject: self minDaysPerMonth		into: [:min :yearlyCalendar | (yearlyCalendar daysInMonthWithKey: monthKey ifAbsent: [min]) min: min ]</body><body package="Chronos-Calendars-Regular" selector="monthKeyForMonthAt:forYearTypeCode:">monthKeyForMonthAt: monthOrdinal forYearTypeCode: yearTypeCode	"Answer the monthKey for the month whose ordinal is &lt;monthOrdinal&gt;, in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^((yearlyCalendars at: yearTypeCode) monthAt: monthOrdinal) monthKey</body><body package="Chronos-Calendars-Regular" selector="monthOrdinalForMonthWithKey:forYearTypeCode:">monthOrdinalForMonthWithKey: monthKey forYearTypeCode: yearTypeCode 	"Answer the month ordinal for the month whose monthKey is &lt;monthKey&gt;, in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^(yearlyCalendars at: yearTypeCode) 		monthOrdinalForMonthWithKey: monthKey		ifAbsent: 			[^self 				signalError: 'The ' , self name 						, ' calendar has no month whose monthKey is ' , monthKey printString]</body><body package="Chronos-Calendars-Regular" selector="monthsInYearForYearTypeCode:">monthsInYearForYearTypeCode: yearTypeCode	"Answer the number of months there are per year, in a year whose typeCode is &lt;yearTypeCode&gt;."	^(yearlyCalendars at: yearTypeCode) monthsPerYear</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="daysInYearForYearTypeCode:">daysInYearForYearTypeCode: yearTypeCode	"Answer the number of days per year there are in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^(yearlyCalendars at: yearTypeCode) daysPerYear</body><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^StandardYearTypeCode</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Regular" selector="setYearlyCalendars:">setYearlyCalendars: anArrayOfYearlyCalendars	self assertMutability.	yearlyCalendars := anArrayOfYearlyCalendars.	self bindToYearlyCalendars</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="isDaysPerMonthInvariant">isDaysPerMonthInvariant	"If there are always the exact same number of days in all months of all years, answer true. Otherwise, answer false."	^minDaysPerMonth = maxDaysPerMonth</body><body package="Chronos-Calendars-Regular" selector="isDaysPerYearInvariant">isDaysPerYearInvariant	"If there are always the exact same number of days in all years, answer true. Otherwise, answer false."	^minDaysPerYear = maxDaysPerYear</body><body package="Chronos-Calendars-Regular" selector="isMonthsPerYearInvariant">isMonthsPerYearInvariant	"If there are always the exact same number of months in all years, answer true. Otherwise, answer false."	^minMonthsPerYear = maxMonthsPerYear</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>API-CalendarPeriods</category><body package="Chronos-Calendars-Regular" selector="calendarDayFromDayOfYearOrdinal:forYearTypeCode:">calendarDayFromDayOfYearOrdinal: dayOfYearOrdinal forYearTypeCode: yearTypeCode 	"Answer the CalendarDay (which see) that represents the day of the year whose ordinal number is &lt;dayOfYearOrdinal&gt;, for any year whose year type code is &lt;yearTypeCode&gt;."	^(yearlyCalendars at: yearTypeCode) basicDayAt: dayOfYearOrdinal</body><body package="Chronos-Calendars-Regular" selector="calendarDayFromMonth:day:forYearTypeCode:">calendarDayFromMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode	"Answer the CalendarDay (which see) that represents the month of the year whose ordinal is &lt;monthOrdinal&gt;, and the day of the month whose ordinal number is &lt;dayOfMonthOrdinal&gt;, for any year whose year type code is &lt;yearTypeCode&gt;."	^(yearlyCalendars at: yearTypeCode) monthAt: monthOrdinal dayAt: dayOfMonthOrdinal</body><body package="Chronos-Calendars-Regular" selector="yearlyCalendarForYearTypeCode:">yearlyCalendarForYearTypeCode: yearTypeCode	"Answer the YearlyCalendar (which see) that specifies the characteristics of any year whose year type is identifiefied by the code &lt;yearType&gt;, including the year's organization into months and days of the month."	^yearlyCalendars at: yearTypeCode</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:day:forYearTypeCode:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^(yearlyCalendars at: yearTypeCode) daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2 	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearMonthDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	^self subclassResponsibility</body><body package="Chronos-Calendars-Regular" selector="startingWithYear:addingDays:setYearAndCalendarDayInto:">startingWithYear: startYear addingDays: dayDelta setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2 	"For a year and CalendarDay that is dayDelta days since the first day of the year &lt;startYear&gt;, send #value:value: to &lt;yearMonthDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	^dayDelta &lt; 2922		ifTrue: 			[super 				startingWithYear: startYear				addingDays: dayDelta				setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2]		ifFalse: 			[self 				forDaysSinceEpoch: (self daysSinceEpochUpToYear: startYear) + dayDelta				setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2]</body></methods><methods><class-id>Chronos.RegularCalendar</class-id> <category>enumerating</category><body package="Chronos-Calendars-Regular" selector="yearTypeCodesDo:">yearTypeCodesDo: block1	^self class yearTypeCodesDo: block1</body></methods><methods><class-id>Chronos.RegularCalendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Regular" selector="yearTypeCodesDo:">yearTypeCodesDo: block1	block1 value: StandardYearTypeCode.	block1 value: 2.</body></methods><methods><class-id>Chronos.RegularCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="standardYearTypeCode">standardYearTypeCode	^StandardYearTypeCode</body></methods><methods><class-id>Chronos.RegularCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="monthlyCalendarSpecs">monthlyCalendarSpecs	monthlyCalendarSpecs == nil ifTrue: [self setMonthlyCalendarSpecs].	^monthlyCalendarSpecs</body><body package="Chronos-Calendars-Regular" selector="setMonthlyCalendarSpecs">setMonthlyCalendarSpecs	"Initialize the class instance variable monthlyCalendarSpecs, so that it contains an Array of Array of MonthlyCalendarSpecs.  There must be one Array of MonthlyCalendarSpecs in the outer Array (the one referenced by monthlyCalendarSpecs) for each 'year type' of the calendrical system implemented by instances of the receiver.  There must be a MonthlyCalendarSpec in the inner Array for each month for each year type.  See the class comments of ArithmeticalCalendar, Calendar and MonthlyCalendarSpec for more information."	^self subclassResponsibility</body><body package="Chronos-Calendars-Regular" selector="specificationOfMonthsForYearTypeCode:">specificationOfMonthsForYearTypeCode: yearTypeCode	^self monthlyCalendarSpecs at: yearTypeCode</body></methods><methods><class-id>Chronos.RegularCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="basicInitialize">basicInitialize	monthlyCalendarSpecs := nil</body><body package="Chronos-Calendars-Regular" selector="initialize">initialize	StandardYearTypeCode := 1.	self basicInitialize</body></methods><methods><class-id>Chronos.MonthsPerYearInvariantCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="isMonthsPerYearInvariant">isMonthsPerYearInvariant	"If there are always the exact same number of months in all years, answer true. Otherwise, answer false."	^true</body></methods><methods><class-id>Chronos.MonthsPerYearInvariantCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="monthsSinceEpochUpToYear:">monthsSinceEpochUpToYear: calendarYear 	"Answer the count of months since the Epoch day (start of day) up to (but NOT including) the first month of the specified year."	^(yearNumberingPolicy cardinalFromCanonical: calendarYear) 		* self monthsPerYear</body></methods><methods><class-id>Chronos.MonthsPerYearInvariantCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forMonthsSinceEpoch:setYearAndMonthsSinceStartOfYearInto:">forMonthsSinceEpoch: monthsSinceEpoch setYearAndMonthsSinceStartOfYearInto: block2 	"For a year and months-since-start-of-year that is monthsSinceEpoch months since my Epoch, send #value:value: to &lt;block2&gt;, with the year as the first argument and the months-since-start-of-year as the second argument."	^block2 		value: (yearNumberingPolicy canonicalFromCardinal: monthsSinceEpoch // self monthsPerYear)		value: monthsSinceEpoch \\ self monthsPerYear</body><body package="Chronos-Calendars-Regular" selector="startingWithYear:addingMonths:setYearAndMonthsSinceStartOfYearInto:">startingWithYear: startYear addingMonths: monthDelta setYearAndMonthsSinceStartOfYearInto: block2 	"For a year and months-since-start-of-year that is monthDelta months since the first month of the year &lt;startYear&gt;, send #value:value: to &lt;block2&gt;, with the year as the first argument and the months-since-start-of-year as the second argument."	^block2 		value: (yearNumberingPolicy 				canonicalFromCardinal: (yearNumberingPolicy 						cardinalFromCanonical: startYear) + (monthDelta // self monthsPerYear))		value: monthDelta \\ self monthsPerYear</body></methods><methods><class-id>Chronos.MonthsPerYearInvariantCalendar</class-id> <category>API-queries-months</category><body package="Chronos-Calendars-Regular" selector="monthsInYear:">monthsInYear: year	"Answer the number of months there are in the given &lt;year&gt;."	^minMonthsPerYear</body><body package="Chronos-Calendars-Regular" selector="monthsInYearForYearTypeCode:">monthsInYearForYearTypeCode: yearTypeCode 	"Answer the number of months there are per year, in a year whose typeCode is &lt;yearTypeCode&gt;."	^minMonthsPerYear</body><body package="Chronos-Calendars-Regular" selector="monthsPerYear">monthsPerYear	^minMonthsPerYear</body></methods><methods><class-id>Chronos.MonthsPerYearInvariantCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	^self subclassResponsibility</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	^self subclassResponsibility</body><body package="Chronos-Calendars-Regular" selector="setMonthlyCalendarSpecs">setMonthlyCalendarSpecs	"Initialize the class instance variable monthlyCalendarSpecs, so that it contains an Array of Array of MonthlyCalendarSpecs.  There must be one Array of MonthlyCalendarSpecs in the outer Array (the one referenced by monthlyCalendarSpecs) for each 'year type' of the calendrical system implemented by instances of the receiver.  There must be a MonthlyCalendarSpec in the inner Array for each month for each year type.  See the class comments of ArithmeticalCalendar, Calendar and MonthlyCalendarSpec for more information."	monthlyCalendarSpecs := Array new: 2.	monthlyCalendarSpecs 		at: 1 put: self newMonthlyCalendarSpecsForStandardYear;		at: 2 put: self newMonthlyCalendarSpecsForLeapYear</body></methods><methods><class-id>Chronos.CopticCalendar</class-id> <category>API-unification</category><body package="Chronos-Calendars-Regular" selector="secondsSinceMidnightFromSecondsSinceStartOfDay:">secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay	"Answer the number of seconds-since-start-of-day relative to midnight represented by the argument, &lt;secondsSinceStartOfDay&gt;, where the argument is specified relative to the receiver's canonical start-of-day (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since midnight clock time that corresponds to the number of seconds since the receiver's canonical start-of-day clock time, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for time systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Julian Day time system, the canonical start-of-day is Noon."	^secondsSinceStartOfDay + 64800</body><body package="Chronos-Calendars-Regular" selector="secondsSinceStartOfDayFromSecondsSinceMidnight:">secondsSinceStartOfDayFromSecondsSinceMidnight: secondsSinceMidnight	"Answer the number of seconds-since-start-of-day relative to the receiver's canonical start-of-day represented by the argument, &lt;secondsSinceMidnight&gt;, where the argument is specified relative to midnight (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since the receiver's canonical start-of-day clock time that corresponds to the number of seconds since midnight, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for calendar systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Hebrew calendar, the canonical start-of-day is 6pm."	^secondsSinceMidnight + 21600</body></methods><methods><class-id>Chronos.CopticCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the calendrical system represented by the receiver starts each day at local midnight."	^false</body><body package="Chronos-Calendars-Regular" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the calendrical system implemented by the receiver coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^false</body></methods><methods><class-id>Chronos.CopticCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2 	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"CopticCalendar canonical forDaysSinceEpoch: (7*365) negated setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	| quadYear year days yearTypeCode |	quadYear := daysSinceEpoch // 1461.	days := daysSinceEpoch \\ 1461.	year := days // 365.	days := days \\ 365.	year &gt;= 3 	"&lt;year&gt; and &lt;days&gt; are both CARDINAL numbers here"		ifTrue: 			[days = 0 				ifTrue: 					[year := year - 1.					year = 2 						ifTrue: 							[days := 365.							yearTypeCode := 2]						ifFalse: 							[days := 364.							yearTypeCode := 1]]				ifFalse: 					[days := days - 1.					yearTypeCode := 1]]		ifFalse: [yearTypeCode := year = 2 ifTrue: [2] ifFalse: [1]].	^yearMonthDaySpecOrBlock2 		value: (yearNumberingPolicy canonicalFromCardinal: year + (quadYear * 4))		value: ((yearlyCalendars at: yearTypeCode) basicDayAt: days + 1)</body></methods><methods><class-id>Chronos.CopticCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^calendarYear \\ 4 == 3		ifTrue: [2]		ifFalse: [1]</body></methods><methods><class-id>Chronos.CopticCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	| cardinalYear ordinalYear |	cardinalYear := yearNumberingPolicy cardinalFromCanonical: calendarYear.	ordinalYear := yearNumberingPolicy ordinalFromCanonical: calendarYear.	^cardinalYear * 365 + (ordinalYear // 4) "NOT exactly the same as Julian rule, since Year 0003 is a Coptic leap year, but not a Julian leap year."</body></methods><methods><class-id>Chronos.CopticCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1825029 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.CopticCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newDefaultYearNumberingPolicy">newDefaultYearNumberingPolicy	"Answer a new NumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. NOTE: The ANSI Smalltalk standard REQUIRES the use of 'Astronomical Year Numbering' (i.e., an OrdinalNumberingPolicy) for dates in the Gregorian calendar. The ISO 8601 standard imposes the same requirement."	^self newZerolessOrdinalYearNumberingPolicy</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Thoout					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Paope 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Athor 						daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Koiak 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tobe	 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Meshir 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Paremotep 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Parmoute		 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Pashons 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Paone 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Epep 						daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Mesore 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey:  #Epagomene 	daysPerMonth: 6 occursEveryYear: true leapDayOrdinals: #(6)).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Thoout					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Paope 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Athor 						daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Koiak 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tobe	 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Meshir 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Paremotep 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Parmoute		 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Pashons 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Paone 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Epep 						daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Mesore 					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey:  #Epagomene 	daysPerMonth: 5 occursEveryYear: true leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.CopticCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Coptic</body></methods><methods><class-id>Chronos.CopticCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"CopticCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Chronos.IndianCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1749994 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.IndianCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"IndianCalendar canonical daysSinceEpochUpToYear: 3"	"IndianCalendar canonical daysSinceEpochUpToYear: 778"	| cardinalYear |	cardinalYear := calendarYear + 77.	^ cardinalYear * 365 		+ (cardinalYear // 4) 		- (cardinalYear // 100) 		+ (cardinalYear // 400)		- 28489	"(Gregorian daysSinceEpochUpToYear: ordinalYearNumber + 78) - (Gregorian daysSinceEpochUpToYear: 79)"</body></methods><methods><class-id>Chronos.IndianCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"days-in-four-year-cycle=1461; days-in-century=36524; days-in-four-centuries=146097; days-in-20 centuries=730485 " 	"IndianCalendar canonical forDaysSinceEpoch: 283793  setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"IndianCalendar canonical forDaysSinceEpoch: 284158  setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	| quadCentury century quadYear year days yearTypeCode |	days := daysSinceEpoch + 28489. "Adjusts for 79-year phase shift"	quadCentury := days // 146097.	days := days \\ 146097.	century := days // 36524.	days := days \\ 36524.	(days == 0 and: [century == 4]) 		ifTrue: 			["Handle the 36524th cardinal day--a leap day"			century := century - 1.			days := 36524].	quadYear := days // 1461.	days := days \\ 1461.	year := days // 365.	days := days \\ 365.	(days == 0 and: [year == 4]) 		ifTrue: 			["Handle the 365th cardinal day--a leap day"			year := year - 1.			days := 365].	yearTypeCode := 		year == 3 "Last year in 4-year cycle"			ifTrue: 				[quadYear = 24 "last 4-year cycle in century"					ifTrue: 						[century = 3 "last century in 4-century cycle" 							ifTrue: [2] ifFalse: [1]]					ifFalse: [2]]			ifFalse: [1].	^yearMonthDaySpecOrBlock2		value: (year + (quadCentury * 400) + (century * 100) + (quadYear * 4))  - 77		value: ((yearlyCalendars at: yearTypeCode) basicDayAt: days + 1)</body></methods><methods><class-id>Chronos.IndianCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	"IndianCalendar canonical typeCodeOfYear: 2"	"IndianCalendar canonical typeCodeOfYear: 778"	| year |	year := calendarYear + 78.	^year \\ 4 == 0 		ifTrue: [year \\ 100 == 0 					ifTrue: [year \\ 400 == 0 								ifTrue: [2] 								ifFalse: [1]] 					ifFalse: [2]]		ifFalse: [1]</body></methods><methods><class-id>Chronos.IndianCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Indian</body></methods><methods><class-id>Chronos.IndianCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Chaitra 			daysPerMonth: 31 leapDayOrdinals: #(31));		nextPut: (MonthlyCalendarSpec newWithKey: #Vaisakha 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Jyaista 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ashadha 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sravana 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Bhadrapada 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Asvina 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Kartika 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Margasira 		daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Pausha 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Magha			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Phalguna 		daysPerMonth: 30 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Chaitra 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Vaisakha 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Jyaista 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ashadha 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sravana 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Bhadrapada 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Asvina 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Kartika 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Margasira 		daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Pausha 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Magha			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Phalguna 		daysPerMonth: 30 leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.IndianCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"IndianCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Chronos.ChronosSystemClock</class-id> <category>testing</category><body package="Chronos-System" selector="isRelativeToLocalTime">isRelativeToLocalTime	"If the receiver reports ticks relative to UT, answer false.	If the receiver reports ticks relative to local time, answer true."	^self isRelativeToUT not</body><body package="Chronos-System" selector="isRelativeToUT">isRelativeToUT	"If the receiver reports ticks relative to UT, answer true.	If the receiver reports ticks relative to local time, answer false."	^true</body><body package="Chronos-System" selector="isRelativityDynamic">isRelativityDynamic	"Answer true if the relativity of the receiver (whether it keeps/reports time relative to UT or to local time) may be different in different operating environments (e.g., pre VW7x, the VW system clock is relative to local time on Windows and MacOS Classic, but relative to UT on all other platforms.)"	^false</body></methods><methods><class-id>Chronos.ChronosSystemClock</class-id> <category>accessing</category><body package="Chronos-System" selector="epoch">epoch	^self isRelativeToUT 		ifTrue: 			[DateAndTimeFactory 				utSecondsSinceEpoch: self secondsFromGregorianEpochUpToSystemClockEpoch				timeZone: ChronosTimezone universal]		ifFalse: 			[DateAndTimeFactory 				secondsSinceEpoch: self secondsFromGregorianEpochUpToSystemClockEpoch]</body><body package="Chronos-System" selector="precision">precision	"Answer a Duration whose value indicates the precision of the receiver.  The precision of a clock is the average time interval between updates to the clock's tick count.  The 'tick size' of a clock is the minimum time interval that notationally can be represented by the clock's time counter (the clock's 'tick size' is also called the 'clock resolution.')"	^DurationFactory nanoseconds: (self nanosecondsFromTicks: self tickPrecision)</body><body package="Chronos-System" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the resolution of the receiver.  The resolution of a clock is the minimum temporal extent that notationally can be represented by the clock's logical time counter (which is determined by the API for reading the value of the counter.)"	^DurationFactory nanoseconds: (self nanosecondsFromTicks: 1)</body><body package="Chronos-System" selector="tickPrecision">tickPrecision         "Answer the mean of the number of clock ticks between subsequent updates of the clock's tick counter."         "{ChronosSystemClock current tickPrecision}"         | ticks tickDelta sum count |         sum := 0.         count := 0.         ticks := self ticksNowSinceSystemClockEpoch.         [count &lt; 10] whileTrue:                         [tickDelta := self ticksNowSinceSystemClockEpoch - ticks.                         tickDelta &gt; 0                                 ifTrue:                                         [count := count + 1.                                         sum := sum + tickDelta.                                         ticks := self ticksNowSinceSystemClockEpoch]].         ^(sum / 10) rounded</body><body package="Chronos-System" selector="tickResolutionName">tickResolutionName	"Answer a Symbol that identifies a time unit whose duration is that of the receiver's tick resolution."	^#second</body><body package="Chronos-System" selector="ticksPerSecond">ticksPerSecond	^ticksPerSecond</body></methods><methods><class-id>Chronos.ChronosSystemClock</class-id> <category>API-conversion</category><body package="Chronos-System" selector="microsecondsFromTicks:">microsecondsFromTicks: ticks	^ChronosFunction times1000000: ticks</body><body package="Chronos-System" selector="millisecondsFromTicks:">millisecondsFromTicks: ticks	^ticks * MillisecondsPerSecond</body><body package="Chronos-System" selector="nanosecondsFromTicks:">nanosecondsFromTicks: ticks	^ticks * NanosecondsPerSecond</body><body package="Chronos-System" selector="nanosecondsSinceSecondFromTicks:">nanosecondsSinceSecondFromTicks: ticks	^0</body><body package="Chronos-System" selector="secondsFromTicks:">secondsFromTicks: ticks	^ticks</body><body package="Chronos-System" selector="ticksFromMicroseconds:">ticksFromMicroseconds: microseconds 	^microseconds // MicrosecondsPerSecond</body><body package="Chronos-System" selector="ticksFromMilliseconds:">ticksFromMilliseconds: milliseconds	^milliseconds // MillisecondsPerSecond</body><body package="Chronos-System" selector="ticksFromNanososeconds:">ticksFromNanososeconds: nanoseconds 	^nanoseconds // NanosecondsPerSecond</body><body package="Chronos-System" selector="ticksFromSeconds:">ticksFromSeconds: seconds	^seconds</body></methods><methods><class-id>Chronos.ChronosSystemClock</class-id> <category>API-timing</category><body package="Chronos-System" selector="microsecondsToRun:">microsecondsToRun: timedBlock	^self microsecondsFromTicks: (self ticksToRun: timedBlock)</body><body package="Chronos-System" selector="millisecondsToRun:">millisecondsToRun: timedBlock	^self millisecondsFromTicks: (self ticksToRun: timedBlock)</body><body package="Chronos-System" selector="nanosecondsToRun:">nanosecondsToRun: timedBlock	^self nanosecondsFromTicks: (self ticksToRun: timedBlock)</body><body package="Chronos-System" selector="secondsNowSinceSystemClockEpoch">secondsNowSinceSystemClockEpoch	"Answer the number of seconds since the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where seconds = 0)) up to the current moment. Do not adjust for timezone offset, just answer the raw value provided by the platform system clock (for many Smalltallk implementations, the platform system clock is a software device provided by the virtual machine, and can be accessed via primtive message send.)"	"The default implementation uses the network time service as defined by RFC-868, which provides the number of seconds since 1900-01-01T00:00:00 UTC"	"{| clock |	clock := ChronosSystemClock new.	DateAndTimeFactory		utSecondsSinceEpoch: (clock secondsFromGregorianEpochUpToSystemClockEpoch + clock secondsNowSinceSystemClockEpoch)		timeZone: Timezone default}"	^self secondsFromTicks: self ticksNowSinceSystemClockEpoch</body><body package="Chronos-System" selector="ticksNowSinceSystemClockEpoch">ticksNowSinceSystemClockEpoch	"Answer the number of clock ticks since the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0)) up to the current moment. Do not adjust for timezone offset, just answer the raw value provided by the platform system clock (for many Smalltallk implementations, the platform system clock is a software device provided by the virtual machine, and can be accessed via primtive message send.)"	"The default implementation uses the network time service as defined by RFC-868, which provides the number of seconds since 1900-01-01T00:00:00 UTC"	"{| clock |	clock := ChronosSystemClock new.	DateAndTimeFactory		utSecondsSinceEpoch: (clock secondsFromGregorianEpochUpToSystemClockEpoch + (clock secondsFromTicks: clock ticksNowSinceSystemClockEpoch))		timeZone: Timezone default}"	^ChronosSystemFacade current rfc868SecondsSince1900</body><body package="Chronos-System" selector="ticksToRun:">ticksToRun: timedBlock	| initialTicks |	initialTicks := self ticksNowSinceSystemClockEpoch.	timedBlock value.	^self ticksNowSinceSystemClockEpoch - initialTicks</body></methods><methods><class-id>Chronos.ChronosSystemClock</class-id> <category>initialize-release</category><body package="Chronos-System" selector="initialize">initialize	ticksPerSecond := self ticksFromSeconds: 1</body><body package="Chronos-System" selector="invalidateRelativity">invalidateRelativity	"Reset the receiver's UT/local relativity based on the current operating environment. If the new relativity differs from the old, inform dependents of the change using the aspect #relativity"	"By default, do nothing"</body></methods><methods><class-id>Chronos.ChronosSystemClock</class-id> <category>printing</category><body package="Chronos-System" selector="printOn:">printOn: stream	super printOn: stream.	stream		nextPut: $(;		nextPutAll: 'tick resolution = ';		nextPutAll: self tickResolutionName;		nextPutAll: ' | ';		nextPutAll: 'Clock Epoch = ';		nextPutAll: (self epoch printStringUsing: ChronosPrintPolicy verbose).	stream nextPut: $)</body></methods><methods><class-id>Chronos.ChronosSystemClock</class-id> <category>calendar clock binding</category><body package="Chronos-System" selector="newCalendarClock">newCalendarClock	"Answer a new CalendarClock instance appropriate for use with the receiver.  The appropriate CalendarClock depends on the relativity of the time the receiver reports (e.g., relative to Universal Time, relative to local time, etc.)"	^CalendarClock systemClock: self</body><body package="Chronos-System" selector="newGregorianCalendarClock">newGregorianCalendarClock	"Answer a new CalendarClock instance appropriate for use with the receiver and the Gregorian Calendar.  The appropriate CalendarClock instance depends on 1) whether the host Smalltalk environment's system clock reports time as a) time units (seconds, milliseconds, etc.) since an epoch or b) a Gregorian year-month-day-hour-minute-second designation; and 2) whether the host Smalltalk environment's system clock reports time c) relative to Universal Time or d) relative to local time."	^self newCalendarClock</body><body package="Chronos-System" selector="secondsFromGregorianEpochUpToSystemClockEpoch">secondsFromGregorianEpochUpToSystemClockEpoch	"Answer the number of seconds from the Epoch date/time of the Proleptic Gregorian Calendar (i.e., January 1, 1 AD  00:00:00 Proleptic Gregorian) up to the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0).  For most Smalltallk implementations, the platform system clock is a software device provided by the virtual machine.  On most operating systems, the system clock's zero point will be 00:00:00 UT of the first day of some Gregorian year.  However, some platforms (e.g., Classic MacOS) use a zero point that is 00:00:00 (midnight) LOCAL TIME.  Do not adjust the encapsulated clock's tick count from UT to local time, nor from local time to UT.  If the encapsulated clock reports ticks relative to UT, then #secondsFromGregorianEpochUpToSystemClockEpoch should answer the number of seconds since midnight UT of the clock's epoch date, and the instance method #isRelativeToUT should answer true. However, if the encapsulated clock reports ticks relative to local time, then #secondsFromGregorianEpochUpToSystemClockEpoch should answer the number of seconds since midnight local time of the clock's epoch date, and the instance method #isRelativeToUT should answer false."	"EXAMPLE 'How-To':	Option 1: 'Let the Gregorian Calendar do it-slower but very clear, and since this value will usually only be needed once, speed should not be an issue'		^(Calendar gregorian secondsSinceEpochUpToYear: 1901) {= 59958144000} 	Option 2: 'Use the difference between Julian Days-fast but opaque'		^(2415386 - 1721426) * SecondsPerDay {=59958144000}	Option 3: 'Precompute the value somehow and just answer it--very fast but very opaque'		^59958144000"	"Many Smalltalk systems use 1901-01-01T00:00:00 UT (1 January 1901 AD, UT start-of-day) as the 'Epoch Date/Time' for the system clock (or perhaps 1901-01-01T00:00:00 local time, even though that's a rather bad practice.) The corresponding Julian Day is 2415386. (Julian Days start at noon; the convention is that the Julian Day Number of a date corresponds to that of the Julian Day that starts at Noon on that date.)	The Julian Day numbers for a list of common system clock/calendar epoch dates are listed below:		Gregorian Date		 +0.5d =	Julian Day	-0.5d =	Julian Calendar Date		Verification							Comment		-4713-11-24T00:00:00 UT =&gt;  		    0		&lt;=	-4713-01-01T00:00:00 UT		{DateSpec julianDay: 0} 			Julian Day Zero		0000-12-30T00:00:00 UT =&gt;  	1721424		&lt;=	0001-01-01T00:00:00 UT		{DateSpec julianDay: 1721424} 	Epoch of Julian Calendar		0000-12-31T00:00:00 UT =&gt;  	1721425		&lt;=	0001-01-02T00:00:00 UT		{DateSpec julianDay: 1721425} 	Rata Die epoch (Reingold/Dershowitz)		0001-01-01T00:00:00 UT =&gt;  	1721426		&lt;=	0001-01-03T00:00:00 UT		{DateSpec julianDay: 1721426} 	Epoch of Gregorian Calendar		1582-10-15T00:00:00 UT =&gt;  	2299161		&lt;=	1582-10-05T00:00:00 UT		{DateSpec julianDay: 2299161}	Inception of Gregorian Calendar,																										by Proclamation of Pope Gregory																										(which was ignored by many 																										non-Catholic countries, who all																										switched at various later times)		1601-01-01T00:00:00 UT =&gt;  	2305814		&lt;=	1600-12-22T00:00:00 UT		{DateSpec julianDay: 2305814}  System clock Epoch for both																											Windows-32 &amp; ANSI COBOL		1858-11-17T00:00:00 UT =&gt;  	2400001		&lt;=	1858-11-05T00:00:00 UT		{DateSpec julianDay: 2400001}  Epoch of Modified Julian Day 																																					(Midnight, not Noon)																																					&amp; System clock epoch of VMS		1900-01-01T00:00:00 UT =&gt;  	2415021		&lt;=	1899-12-20T00:00:00 UT		{DateSpec julianDay: 2415021}  IBM Mainframe system clock Epoch		1901-01-01T00:00:00 UT =&gt;  	2415386		&lt;=	1900-12-19T00:00:00 UT		{DateSpec julianDay: 2415386}  ST-80 VM clock Epoch		1904-01-01T00:00:00 UT =&gt;  	2416481		&lt;=	1903-12-19T00:00:00 UT		{DateSpec julianDay: 2416481}  MacOS Classic clock epoch		1970-01-01T00:00:00 UT =&gt;  	2440588		&lt;=	1969-12-19T00:00:00 UT		{DateSpec julianDay: 2440588}  UNIX/POSIX system clock Epoch		1980-01-01T00:00:00 xxx =&gt;  	2444240		&lt;=	1979-12-19T00:00:00 xxx		{DateSpec julianDay: 2444240}	MS-DOS system clock Epoch 																																					&amp; Windows-16 (both in local time!!!)		1990-01-01T00:00:00 UT =&gt;  	2447893		&lt;=	1989-12-19T00:00:00 UT		{DateSpec julianDay: 2447893}		2000-01-01T00:00:00 UT =&gt;  	2451545		&lt;=	1999-12-19T00:00:00 UT		{DateSpec julianDay: 2451545}		2001-01-01T00:00:00 UT =&gt;  	2451911		&lt;=	2000-12-19T00:00:00 UT		{DateSpec julianDay: 2451911}		Note that the actual Julian Date of the Modified Julian Day system is 2400000.5, since MJD 0.0 is midnight (start-of-day) 1858-11-17T00:00:00 UT."	"The default implementation uses the network time service as defined by RFC-868, which provides the number of seconds since 1900-01-01T00:00:00 UT"	"^Calendar gregorian secondsSinceEpochUpToYear: 1900" ^59926608000</body></methods><methods><class-id>Chronos.ChronosSystemClock class</class-id> <category>instance creation</category><body package="Chronos-System" selector="new">new	^self basicNew initialize</body></methods><methods><class-id>Chronos.ChronosSystemClock class</class-id> <category>class initialization</category><body package="Chronos-System" selector="initialize">initialize	"ChronosSystemClock initialize" 	Current := nil.</body><body package="Chronos-System" selector="invalidateCurrent">invalidateCurrent	"Ensure that the current ChronosSystemClock is the correct implementation for the current system environment.  Also ensure that the CalendarClock for all Calendars is the correct implementation for the current ChronosSystemClock."	"ChronosSystemClock invalidateCurrent"	Current := ChronosSystemFacade current newSystemClock.	Calendar invalidateClock.	ChronosEnvironment canonical defineSystemClockInGlobalNamespace</body></methods><methods><class-id>Chronos.ChronosSystemClock class</class-id> <category>accessing</category><body package="Chronos-System" selector="current">current	Current == nil ifTrue: [self invalidateCurrent].	^Current</body></methods><methods><class-id>Chronos.ChronosSystemClock class</class-id> <category>queries</category><body package="Chronos-System" selector="javaEpoch">javaEpoch	"ChronosSystemClock javaEpoch"	^self unixEpoch</body><body package="Chronos-System" selector="msWindowsNTEpoch">msWindowsNTEpoch	"ChronosSystemClock msWindowsNTEpoch"	^DateAndTimeFactory year: 1601 day: 1 timeZone: #UT</body><body package="Chronos-System" selector="st80Epoch">st80Epoch	"ChronosSystemClock st80Epoch"	^DateAndTimeFactory year: 1901 day: 1 timeZone: #UT</body><body package="Chronos-System" selector="unixEpoch">unixEpoch	^DateAndTimeFactory year: 1970 day: 1 timeZone: #UT</body></methods><methods><class-id>Chronos.MicrosecondSystemClock</class-id> <category>API-conversion</category><body package="Chronos-System" selector="microsecondsFromTicks:">microsecondsFromTicks: ticks	^ticks</body><body package="Chronos-System" selector="millisecondsFromTicks:">millisecondsFromTicks: ticks	^ChronosFunction times1000: ticks</body><body package="Chronos-System" selector="nanosecondsFromTicks:">nanosecondsFromTicks: ticks	^ticks * NanosecondsPerMicrosecond</body><body package="Chronos-System" selector="nanosecondsSinceSecondFromTicks:">nanosecondsSinceSecondFromTicks: ticks	"MicrosecondSystemClock new nanosecondsSinceSecondFromTicks: 1200000"	"{[1000000 timesRepeat: [33554431 \\ 1000000 * 125 bitShift: 3]] durationToRun 00:00:00:00.150378} Fastest"	"{[1000000 timesRepeat: [((33554431 bitAnd: 63) + (((33554431 bitShift: -6) \\ 15625)  bitShift: 6) * 125) bitShift: 3]] durationToRun 00:00:00:00.156723} Next to fastest"	"{[1000000 timesRepeat: [(33554431 bitAnd: 63) * 1000 + ((((33554431 bitShift: -6) \\ 15625)  * 125) bitShift: 9)]] durationToRun 00:00:00:00.361593} Next to slowest"	"{[1000000 timesRepeat: [33554431 \\ 1000000 * 1000]] durationToRun 00:00:00:01.089217} Slowest"	^ticks \\ ticksPerSecond * 125 bitShift: 3</body><body package="Chronos-System" selector="secondsFromTicks:">secondsFromTicks: ticks	^ticks // MicrosecondsPerSecond</body><body package="Chronos-System" selector="ticksFromMicroseconds:">ticksFromMicroseconds: microseconds 	^microseconds</body><body package="Chronos-System" selector="ticksFromMilliseconds:">ticksFromMilliseconds: milliseconds	^milliseconds * MicrosecondsPerMillisecond</body><body package="Chronos-System" selector="ticksFromNanososeconds:">ticksFromNanososeconds: nanoseconds 	^nanoseconds * NanosecondsPerMicrosecond</body><body package="Chronos-System" selector="ticksFromSeconds:">ticksFromSeconds: seconds	^ChronosFunction times1000000: seconds</body></methods><methods><class-id>Chronos.MicrosecondSystemClock</class-id> <category>API-timing</category><body package="Chronos-System" selector="ticksNowSinceSystemClockEpoch">ticksNowSinceSystemClockEpoch	"Answer the number of clock ticks since the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0)) up to the current moment. Do not adjust for timezone offset, just answer the raw value provided by the platform system clock (for many Smalltallk implementations, the platform system clock is a software device provided by the virtual machine, and can be accessed via primtive message send.)"	"The default implementation uses the network time service as defined by RFC-868, which provides the number of seconds since 1900-01-01T00:00:00 UT"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.MicrosecondSystemClock</class-id> <category>accessing</category><body package="Chronos-System" selector="tickResolutionName">tickResolutionName	"Answer a Symbol that identifies a time unit whose duration is that of the receiver's tick resolution."	^#microsecond</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>exception operations</category><body package="Passport-Kernel" selector="reportException:message:">reportException: exception message: message	self		reportToConsole: message;		reportToConsole: exception description newLineCount: 1 tabCount: 1</body><body package="Passport-Kernel" selector="signal:message:">signal: anExceptionFactory message: message	"Using &lt;anExceptionFactory&gt;, raise an exception with the given &lt;message&gt;"	^self signal: anExceptionFactory message: message contextName: self name</body><body package="Passport-Kernel" selector="signal:message:contextName:">signal: anExceptionFactory message: message contextName: contextName	"Using &lt;anExceptionFactory&gt;, raise an exception with the given &lt;message&gt;"	^self current basicSignal: anExceptionFactory message: message contextName: contextName</body><body package="Passport-Kernel" selector="signalError:">signalError: message	"Using the general 'Error' exception factory, raise an exception with the given &lt;message&gt;"	^self signal: Error message: message</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>system operations</category><body package="Passport-Kernel" selector="performGarbageCollection">performGarbageCollection	^Smalltalk garbageCollect</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>namespace operations</category><body package="Passport-Kernel" selector="addImport:in:private:">addImport: importedNamespacePath in: importingNamespace private: isPrivate	"Cause the &lt;importingNamespace&gt; to 'import' from the namespace whose hierarchical name key is represented (in a syntactically-portable manner) by the pathname-array &lt;importedNamespacePath&gt;. Ideally, this should be done by means of dynamic delegation from &lt;importingNamespace&gt; to the namespace specified by &lt;importedNamespacePath&gt;.  However, if necessary, it may also be achieved by copying the bindings (key-&gt;value associations) from the namespace specified by &lt;importedNamespacePath&gt; into the &lt;importingNamespace&gt;, or even by duplicating the key-&gt;value entries.	The &lt;importedNamespacePath&gt; parameter (representing the hierarchical name key of a namespace) will be an Array of Symbols. The first Symbol will be the name of a namespace accessible from the global namespace (and may even be the name of the global namespace itself.)  Each subsequent Symbol will be the name of a namespace accessible from the previous namespace.  So, if there is a namespace defined in the global namespace named #Chronos, which contains a namespace named #ChronosTemporalRatioConstants, then the hierarchical name key identifing the #ChronosTemporalRatioConstants namespace would be the Array #(Chronos ChronosTemporalRatioConstants). In this way, it is possible to portably specify hierarchical namespace pathnames without knowing or caring about the synatax used for such hierarchical names by the host Smalltalk system."	| importedNamespace |	importedNamespace := importedNamespacePath inject: self globalNamespace into: [:ns :key | ns at: key].	importedNamespace associationsDo: [:association | importingNamespace removeKey: association key ifAbsent: []; add: association]</body><body package="Passport-Kernel" selector="defineVariable:in:withValue:constant:category:rebindIfPresent:onCollision:">defineVariable: key in: aNamespace withValue: value constant: constant category: category rebindIfPresent: rebindIfPresent onCollision: collisionAction 	"Define a binding (key-&gt;value association) in the namespace &lt;aNamespace&gt; (which may just be a Dictionary,) whose key is &lt;key&gt;, and whose value is &lt;value&gt;.  If &lt;constant&gt; is true (and if constant/immutable bindings are supported by the functionality of &lt;aNamespace&gt;,) make the binding constant (immutable.) If supported by the functionality of &lt;aNamespace&gt;, place the binding in the semantic category &lt;category&gt;.  	If there already exists a binding in &lt;aNamespace&gt; with the given &lt;key&gt;, then:		1) If the value associated with &lt;key&gt; is the same object as &lt;value&gt;, then just answer &lt;value&gt;.  		2) If the value associated with &lt;key&gt; is nil, then:			If there is also a binding in the Undeclared namespace whose key is &lt;key&gt;, set &lt;value&gt; as the value of the binding in the Undeclared namespace, and then move the binding (which might be an Association instance, or else an object that supports Association-like behavior and/or protocol) from the Undeclared namespace to &lt;namespace&gt;. Otherwise, set &lt;value&gt; as the value of the binding already present in &lt;aNamespace&gt;.		3) If the value associated with &lt;key&gt; is neither nil nor the same object as &lt;value&gt;, but if &lt;rebindIfPresent&gt; is true, then remove any binding whose key is &lt;key&gt; from the Undeclared namespace, and reset the value of the binding in &lt;aNamespace&gt; whose key is &lt;key&gt; to the value &lt;value&gt;.		4) If the value associated with &lt;key&gt; is neither nil nor the same object as &lt;value&gt;, and if &lt;rebindIfPresent&gt; is also false, then do not change the value of the existing binding, but instead invoke the zero-argument block &lt;collisionAction&gt; (and answer the result.)"	| presentValue |	presentValue := aNamespace at: key ifAbsent: [self notAValue].	^presentValue == value 		ifTrue: [value]		ifFalse: 			[(rebindIfPresent or: [presentValue == self notAValue or: [presentValue == nil]]) 				ifTrue: 					[presentValue == self notAValue 						ifTrue: 							[(Undeclared includesKey: key) 								ifTrue: [aNamespace declare: key from: Undeclared]]						ifFalse: [Undeclared removeKey: key ifAbsent: []].					aNamespace at: key put: value]				ifFalse: [collisionAction value]]</body><body package="Passport-Kernel" selector="fullyQualifiedNameOfClass:">fullyQualifiedNameOfClass: aClass	"Answer the fully-qualified (usable anywhere) name of &lt;aClass&gt;."	"ChronosEnvironment canonical fullyQualifiedNameOfClass: Timepoint"	^aClass name</body><body package="Passport-Kernel" selector="namespaceOfClass:">namespaceOfClass: aClass	^aClass environment</body><body package="Passport-Kernel" selector="purgeUnusedBindingsFromUndeclaredNamespace">purgeUnusedBindingsFromUndeclaredNamespace	"Remove any bindings (associations) from the Undeclared namespace (Dictionary) for which there are no active references in the system codebase."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="resolveClassFromFullyQualifiedName:ifAbsent:">resolveClassFromFullyQualifiedName: className ifAbsent: ifAbsentBlock	"Answwer the class whose fully-qualfied (usable anywhere) name is &lt;name&gt;."	^self globalNamespace at: className ifAbsent: ifAbsentBlock</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>console operations</category><body package="Passport-Kernel" selector="newLineToConsole">newLineToConsole	self current basicNewLineToConsole</body><body package="Passport-Kernel" selector="reportToConsole:">reportToConsole: message	"EnvironmentFacade reportToConsole: 'Hello, world'"	self reportToConsole: message newLineCount: 1</body><body package="Passport-Kernel" selector="reportToConsole:message:">reportToConsole: contextName message: message	"EnvironmentFacade reportToConsole: 'Hello, world'"	self reportToConsole: contextName message: message newLineCount: 1</body><body package="Passport-Kernel" selector="reportToConsole:message:newLineCount:">reportToConsole: contextName message: message newLineCount: newLineCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 2"	self reportToConsole: contextName message: message newLineCount: newLineCount tabCount: 0</body><body package="Passport-Kernel" selector="reportToConsole:message:newLineCount:tabCount:">reportToConsole: contextName message: message newLineCount: newLineCount tabCount: tabCount	"EnvironmentFacade reportToConsole: 'Test' message: 'Hello, world' newLineCount: 1 tabCount: 0"	"EnvironmentFacade reportToConsole: 'Test' message: 'Hello, world' newLineCount: 0 tabCount: 2"	self current basicReportToConsole: contextName message: message newLineCount: newLineCount tabCount: tabCount</body><body package="Passport-Kernel" selector="reportToConsole:newLineCount:">reportToConsole: message newLineCount: newLineCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 2"	self reportToConsole: message newLineCount: newLineCount tabCount: 0</body><body package="Passport-Kernel" selector="reportToConsole:newLineCount:tabCount:">reportToConsole: message newLineCount: newLineCount tabCount: tabCount	"EnvironmentFacade reportToConsole: 'Hello, world' newLineCount: 0 tabCount: 2"	self reportToConsole: 'Passport' message: message newLineCount: newLineCount tabCount: tabCount</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>private</category><body package="Passport-Kernel" selector="basicCancelImageRestartNotificationSubscriptionFor:">basicCancelImageRestartNotificationSubscriptionFor: subscriber	RestartNotificationSubscribers == nil ifTrue: [^self].	RestartNotificationSubscribers removeKey: subscriber ifAbsent: []</body><body package="Passport-Kernel" selector="basicNewLineToConsole">basicNewLineToConsole	Transcript cr</body><body package="Passport-Kernel" selector="basicRegisterForStartupNotification">basicRegisterForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver will be sent the message #handleRestart.	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="basicRelease">basicRelease	"Ensure that the receiver disconnets from its environment."	"EnvironmentFacade basicRelease"	self unregisterForStartupNotification</body><body package="Passport-Kernel" selector="basicReportToConsole:message:newLineCount:tabCount:">basicReportToConsole: contextName message: message newLineCount: newLineCount tabCount: tabCount	"EnvironmentFacade current reportToConsole: 'Test' message: 'Hello, world' newLineCount: 1 tabCount: 0"	"EnvironmentFacade current reportToConsole: 'Test' message: 'Hello, world' newLineCount: 0 tabCount: 2"	newLineCount timesRepeat: [Transcript cr].	tabCount timesRepeat: [Transcript tab].	tabCount &lt; 1 ifTrue: [Transcript show: '## '; show: contextName; show: ': '].	Transcript show: message</body><body package="Passport-Kernel" selector="basicSendImageRestartNotificationsToSubscribers">basicSendImageRestartNotificationsToSubscribers	| notificationMessage |	RestartNotificationSubscribers == nil ifTrue: [^self].	RestartNotificationSubscribers keys do: 			[:subscriber | 			(subscriber == nil or: 					[subscriber = 0 or: 							[(subscriber isBehavior ifTrue: [subscriber] ifFalse: [subscriber class]) 								isObsolete]]) 				ifTrue: [RestartNotificationSubscribers removeKey: subscriber ifAbsent: []]				ifFalse: 					[notificationMessage := RestartNotificationSubscribers at: subscriber.					[subscriber perform: notificationMessage] on: Error						do: 							[:ex | 							self 								reportException: ex								message: 'Image restart notification failure when sending ' 										, notificationMessage , ' to ' 										, subscriber printString]]]</body><body package="Passport-Kernel" selector="basicSignal:message:contextName:">basicSignal: anExceptionFactory message: message contextName: contextName	"Using &lt;anExceptionFactory&gt;, raise an exception with the given &lt;message&gt;"	| stream |	stream := (String new: 12) writeStream.	stream		nextPut: ${;		nextPutAll: contextName;		nextPutAll: '} ';		nextPutAll: message.	^anExceptionFactory signal: stream contents</body><body package="Passport-Kernel" selector="basicSubscribe:forImageRestartNotificationSending:">basicSubscribe: subscriber forImageRestartNotificationSending: restartNotificationMessage 	RestartNotificationSubscribers == nil ifTrue: [self setRestartNotificationSubscribers].	RestartNotificationSubscribers at: subscriber put: restartNotificationMessage</body><body package="Passport-Kernel" selector="basicUnregisterForStartupNotification">basicUnregisterForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver will NOT be sent the message #install (nor otherwise notified.)	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="initializeResourcePathFacadeFactoryReferences">initializeResourcePathFacadeFactoryReferences	"{EnvironmentFacade current initializeResourcePathFacadeFactoryReferences}"	ResourcePathFacadeFactoryReferences := IdentityDictionary new.</body><body package="Passport-Kernel" selector="notAValue">notAValue	NotAValue == nil ifTrue: [NotAValue := Object new].	^NotAValue</body><body package="Passport-Kernel" selector="setPlatformClass">setPlatformClass	"Set the concrete subclass of the reciever whose implmentation is specific to the current Smalltalk platform and usage context."	"This version of the method assumes that any subclass of the receiver is competent to perform the function requested. If you're porting Passport from one Smalltalk platform to another, this method must be subimplemented by all direct subclasses so that all (direct) subimplementations will correctly set the  PlatformClass to be the subclass of EnvironmentFacade appropriate for the particular version of the Smalltalk environment/platform into which Passport finds itself being loaded when #setPlatformClass is sent to the receiver (or any direct subclass.)  The code to figure out which version of Squeak, or of Dolphin, or or VAST, or of ST/X (etc) on which the code is running is of course specific to each Smalltalk flavor.  Also, how many different subclasses of EnvironmentFacade may be needed in order to handle all the versions of a particular Smalltalk environment, and which specific subclass of EnvironmentFacade is optimal for each version, depends on the platform.  	As the person doing the port, how far into the past you wish to provide support is up to you.  Support for previous (or future) versions can always be added later."	self subclasses do: [:any | ^any setPlatformClass]</body><body package="Passport-Kernel" selector="setRestartNotificationSubscribers">setRestartNotificationSubscribers	RestartNotificationSubscribers := IdentityDictionary new</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="current">current	"EnvironmentFacade current"	PlatformClass == nil ifTrue: [self setPlatformClass].	^PlatformClass == nil ifTrue: [self] ifFalse: [PlatformClass]</body><body package="Passport-Kernel" selector="globalNamespace">globalNamespace	"Answer the namespace canonically (or most generally) used for the purpose of defining and accessing classes by the host Smalltalk implementation."	^Smalltalk</body><body package="Passport-Kernel" selector="globalNamespaceName">globalNamespaceName	"Answer the name of the namespace canonically (or most generally) used for the purpose of defining and accessing classes by the host Smalltalk implementation."	^#Smalltalk</body><body package="Passport-Kernel" selector="key">key	"EnvironmentFacade current key"	^#unknown</body><body package="Passport-Kernel" selector="passportNamespace">passportNamespace	"Answer the namespace used for Passport."	^(Pathname components: (Array with: self passportNamespaceName)) value</body><body package="Passport-Kernel" selector="passportNamespaceName">passportNamespaceName	"Answer the name of the namespace used for Passport."	^#Passport</body><body package="Passport-Kernel" selector="versionNumber">versionNumber	"EnvironmentFacade current versionNumber"	^self subclassResponsibility</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>code complation/execution</category><body package="Passport-Kernel" selector="evaluateExpression:">evaluateExpression: smalltalkExpression	^Compiler evaluate: smalltalkExpression</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>mutability</category><body package="Passport-Kernel" selector="makeImmutable:">makeImmutable: anObject	"Make the argument immutable.  Answer the argumnt--NOT A COPY!. If the host Smalltalk environment doesn't support immutable objects, then just answer the argument as-is."	^anObject</body><body package="Passport-Kernel" selector="makeMutable:">makeMutable: anObject	"Make the argument mutable.  Answer the argumnt--NOT A COPY!. If the host Smalltalk environment doesn't support immutable objects, then just answer the argument as-is."	^anObject</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>class binding</category><body package="Passport-Kernel" selector="nativeScaledDecimalClass">nativeScaledDecimalClass	"Answer the class that implements the ANSI-Smallltalk &lt;ScaledDecimal&gt; protocol in the native Smalltalk environment.  Answer nil if none."	^(Pathname components: #(#ScaledDecimal)) value</body><body package="Passport-Kernel" selector="resourcePathFacadeFactoryReferenceAt:ifAbsent:">resourcePathFacadeFactoryReferenceAt: protocolSymbol ifAbsent: ifAbsent	ResourcePathFacadeFactoryReferences == nil ifTrue: [self initializeResourcePathFacadeFactoryReferences].	^ResourcePathFacadeFactoryReferences at: protocolSymbol ifAbsent: ifAbsent</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>resource paths</category><body package="Passport-Kernel" selector="invalidateResourcePathFacades">invalidateResourcePathFacades	"{EnvironmentFacade invalidateResourcePathFacades}"	self current initializeResourcePathFacadeFactoryReferences.	ResourcePathContext invalidateFacades.</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>image restart</category><body package="Passport-Kernel" selector="cancelImageRestartNotificationSubscriptionFor:">cancelImageRestartNotificationSubscriptionFor: subscriber	self current basicCancelImageRestartNotificationSubscriptionFor: subscriber</body><body package="Passport-Kernel" selector="handleRestart">handleRestart	self invalidateResourcePathFacades.	self sendImageRestartNotificationsToSubscribers</body><body package="Passport-Kernel" selector="sendImageRestartNotificationsToSubscribers">sendImageRestartNotificationsToSubscribers	self current basicSendImageRestartNotificationsToSubscribers</body><body package="Passport-Kernel" selector="subscribe:forImageRestartNotificationSending:">subscribe: subscriber forImageRestartNotificationSending: restartNotificationMessage 	self cancelImageRestartNotificationSubscriptionFor: subscriber.	self current basicSubscribe: subscriber forImageRestartNotificationSending: restartNotificationMessage</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="beCurrent">beCurrent	PlatformClass := self.	self defineScaledDecimalInGlobalNamespace</body><body package="Passport-Kernel" selector="initialize">initialize	"EnvironmentFacade initialize."	NotAValue := Object new.	self release.</body><body package="Passport-Kernel" selector="registerForStartupNotification">registerForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver's 'PlatformClass' will be sent the message #handleRestart.	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	"EnvironmentFacade registerForStartupNotification"	^self current basicRegisterForStartupNotification</body><body package="Passport-Kernel" selector="release">release	"The message #release must be sent to EnvironmentFacade whenever Passport is about to be removed from the system (image.)  It is the responsibility of subimplementors to ensure that this message is sent at the appropriate time."	"EnvironmentFacade release"	PlatformClass == nil ifFalse: [PlatformClass basicRelease].	PlatformClass := nil.	self allSubclassesDo: [:subclass | subclass basicRelease]</body><body package="Passport-Kernel" selector="unregisterForStartupNotification">unregisterForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver's 'PlatformClass' will NOT be sent the message #install (nor otherwise notified.)	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	^self current basicUnregisterForStartupNotification</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>queries</category><body package="Passport-Kernel" selector="valueOfEnvironmentVariableAt:">valueOfEnvironmentVariableAt: envVarKey	"Answer the value of the environment variable whose key (name) is &lt;envVarKey&gt;. If the host system does not support environment variables, then answer nil."	^''</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>character constants</category><body package="Passport-Kernel" selector="euroCurrencyCharIfNone:">euroCurrencyCharIfNone: ifNone	"Answer the Character value that represents the symbol for the Euro currency.  If the Smalltalk execution environment does not support such a character value, then answer the result of evaluating the &lt;ifNone&gt; block."		^ifNone value</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>global variable bindings</category><body package="Passport-Kernel" selector="defineScaledDecimalInGlobalNamespace">defineScaledDecimalInGlobalNamespace	"EnvironmentFacade current defineScaledDecimalInGlobalNamespace"	| nativeScaledDecimalClass |	nativeScaledDecimalClass := self nativeScaledDecimalClass.	nativeScaledDecimalClass == nil ifTrue: [^self].	self		defineVariable: #ScaledDecimal		in: self globalNamespace		withValue: nativeScaledDecimalClass		constant: true		category: #'Chronos-Aliases'		rebindIfPresent: false		onCollision: [].</body></methods><methods><class-id>Passport.EnvironmentFacade class</class-id> <category>object creation</category><body package="Passport-Kernel" selector="newWeakDictionary">newWeakDictionary		^(Pathname components: #(#WeakDictionary)) value new</body></methods><methods><class-id>Chronos.ChronosPrintable</class-id> <category>converting</category><body package="Chronos-Foundation" selector="asString">asString	^self printString</body><body package="Chronos-Printing" selector="withDefaultPrintPolicy:">withDefaultPrintPolicy: defaultChronosPrintPolicyOrSpec 	^ChronosPrintableDecorator on: self		defaultPrintPolicy: defaultChronosPrintPolicyOrSpec</body></methods><methods><class-id>Chronos.ChronosPrintable</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="defaultLocale">defaultLocale	"Answer the default ChronosLocale for the receiver."	^ChronosLocale default</body><body package="Chronos-Printing" selector="defaultPrintPolicy">defaultPrintPolicy	"Answer the default ChronosPrintPolicy for the receiver."	^ChronosPrintPolicy ansiStandard</body></methods><methods><class-id>Chronos.ChronosPrintable</class-id> <category>printing</category><body package="Chronos-Printing" selector="%">% aChronosPrintPolicyOrSpec	^self printStringUsing: aChronosPrintPolicyOrSpec</body><body package="Chronos-Printing" selector="localePrintString">localePrintString	"Answer the printString of the receiver as generated by the temporal print policy of the default ChronosLocale."	"Timepoint now localePrintString"	^self printStringUsing: self defaultLocale temporalPrintPolicy</body><body package="Chronos-Printing" selector="longPrintString">longPrintString	^self printStringUsing: (self defaultLocale temporalPrintPolicy 				apply: #(#showDayOfWeekName 						#useMonthName 						#showTimeOfDay 						#showTimeZoneOffset 						#timeZoneSeparator: $  						#timeZoneElementSeparator: nil 						#showNamesOfDurationElements 						#showNamesOfCalendarDurationElements))</body><body package="Chronos-Printing" selector="printOn:">printOn: stream	self printOn: stream using: self defaultPrintPolicy</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	^self subclassResponsibility</body><body package="Chronos-Printing" selector="printStringForLocale:">printStringForLocale: aLocale	"Answer the printString of the receiver as generated by the temporal print policy of the ChronosLocale specified by &lt;aLocale&gt;."	"Timepoint now printStringForLocale: #'de_DE'"	"Timepoint now printStringForLocale: #'fr_FR'"	"Timepoint now printStringForLocale: #'en_UK'"	"Timepoint now printStringForLocale: #'en_US'"	"Timepoint now printStringForLocale: #'es_ES'"	^self printStringUsing: (ChronosLocale referencedBy: aLocale) temporalPrintPolicy</body><body package="Chronos-Printing" selector="printStringUsing:">printStringUsing: aChronosPrintPolicy	"Answer the printString of the receiver as generated by &lt;aChronosPrintPolicy&gt;."	| stream |	stream := (String new: 30) writeStream.	self printOn: stream using: aChronosPrintPolicy.	^stream contents</body><body package="Chronos-Printing" selector="shortPrintString">shortPrintString	"Timepoint now shortPrintString"	^self printStringUsing: (self defaultLocale temporalPrintPolicy 				apply: #(#hideDayOfWeek 						#useMonthAbbreviation 						#showTimeOfDay 						#hideSubsecondFraction 						#showTimeZoneOffset 						#timeZoneSeparator: $  						#timeZoneElementSeparator: nil 						#hideNamesOfDurationElements 						#durationDayHourSeparator: ' T ' 						#durationElementSeparator: $: 						#durationPadChar: $0 						#hideNamesOfCalendarDurationElements 						#showZeroValuedDurationElements 						#hideZeroValuedCalendarDurationElements))</body></methods><methods><class-id>Chronos.ChronosPrintable class</class-id> <category>instance creation</category><body package="Chronos-Parsing" selector="readFrom:">readFrom: stream	"Create an object based on the contents of &lt;stream&gt;, as interpreted by the receiver's default parser."	"YearMonthDay readFrom: '1776-07-04' readStream"	"TimeOfDay readFrom: 'T17:30:00.5' readStream"	"Timepoint readFrom: '1776-07-04' readStream"	^self readFrom: stream using: self defaultParser</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^self subclassResponsibility</body><body package="Chronos-Parsing" selector="readFromString:">readFromString: aString	"Create an object based on the contents of aString, as interpreted by the receiver's default parser."	"YearMonthDay readFromString: '1776-07-04'"	"TimeOfDay readFromString: 'T17:30:00.5'"	"Timepoint readFromString: '1776-07-04'"	^self readFromString: aString using: self defaultParser</body><body package="Chronos-Parsing" selector="readFromString:using:">readFromString: aString using: aChronosParser	"Create an object based on the contents of aString, as interpreted by &lt;aChronosParser&gt;."	^self readFrom: aString readStream using: aChronosParser</body></methods><methods><class-id>Chronos.ChronosPrintable class</class-id> <category>accessing</category><body package="Chronos-Parsing" selector="defaultParser">defaultParser	^ChronosParser iso8601</body></methods><methods><class-id>Chronos.CalendarPeriod</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="calendar">calendar	"Answer the instance of Calendar that implements the calendrical system of the calendar period whose properties are specified by the receiver."	^self yearlyCalendar calendar</body><body package="Chronos-Calendars-Foundation" selector="calendarRegistrationKey">calendarRegistrationKey	^self calendar registrationKey</body><body package="Chronos-Calendars-Foundation" selector="daysPerYear">daysPerYear	"Answer the number of days per in a year whose type is the same as the year type of the calendar period whose properties are specified by the receiver."	^self yearlyCalendar daysPerYear</body><body package="Chronos-Calendars-Foundation" selector="firstMonth">firstMonth	"Answer the MonthlyCalendar instance that specifies the properties of the first month of the receiver's year."	^self yearlyCalendar firstMonth</body><body package="Chronos-Calendars-Foundation" selector="lastMonth">lastMonth	"Answer the MonthlyCalendar instance that specifies the properties of the last month of the receiver's year."	^self yearlyCalendar lastMonth</body><body package="Chronos-Calendars-Foundation" selector="yearTypeCode">yearTypeCode	"Answer the year type code of the receiver's year type."	^self yearlyCalendar yearTypeCode</body><body package="Chronos-Calendars-Foundation" selector="yearlyCalendar">yearlyCalendar	"Answer the YearlyCalendar instance that specifies the properties of the receiver's year type (if the receiver is itself a YearlyCalendar, answer the receiver.)"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.CalendarPeriod</class-id> <category>printing</category><body package="Chronos-Calendars-Foundation" selector="printOn:">printOn: stream	self basicPrintOn: stream</body></methods><methods><class-id>Chronos.CalendarPeriod</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self calendarRegistrationKey;		nextPut: self yearTypeCode literalArrayEncoding</body></methods><methods><class-id>Chronos.CalendarPeriod</class-id> <category>converting</category><body package="Chronos-Calendars-Foundation" selector="canonical">canonical	^self subclassResponsibility</body></methods><methods><class-id>Chronos.CalendarPeriod class</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>queries</category><body package="Chronos-Calendars-Foundation" selector="dayAt:monthDayDo:">dayAt: dayOfYearOrdinal monthDayDo: block2	"For the day of the receiver's year type with the given &lt;dayOfYearOrdinal&gt;, evaluate &lt;block2&gt; with the day's month ordinal and day-of-month ordinal as the first and second arguments (respectively.)"	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="dayOfYearOrdinalForMonth:day:">dayOfYearOrdinalForMonth: month day: day	"Answer the day-of-year ordinal for the day in the receiver's year type with the given &lt;month&gt; ordinal and &lt;day&gt;-of-month ordinal."	^(self daysUpToMonth: month day: day) + 1</body><body package="Chronos-Calendars-Foundation" selector="dayOfYearOrdinalForMonthWithKey:day:">dayOfYearOrdinalForMonthWithKey: monthKey day: day	"Answer the day-of-year ordinal for the day in the receiver's year type with the given &lt;monthKey&gt; (semantic identifier) and &lt;day&gt;-of-month ordinal."	^(self daysUpToMonthWithKey: monthKey day: day) + 1</body><body package="Chronos-Calendars-Foundation" selector="daysInMonthAt:">daysInMonthAt: monthOrdinal	"Answer the number of days in the month of the receiver's year type with the given &lt;monthOrdinal&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysInMonthWithKey:ifAbsent:">daysInMonthWithKey: monthKey ifAbsent: block0	"Answer the number of days in the month of the receiver's year type with the given &lt;monthKey&gt; (semantic identifier.) If there is no month with the given &lt;monthKey&gt; in the receiver's year, answer the result of evaluating &lt;block0&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonth:">daysUpToMonth: month	"Anwer the number of days from the first day of the year up to (but not including) the first day of the month (in the receiver's year type) with the given &lt;month&gt; ordinal. The answer should be the CARDINAL day-of-year number of the first day of the month."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonth:day:">daysUpToMonth: month day: day	"Anwer the number of days from the first day of the year up to (but not including) the day (in the receiver's year type) with the given &lt;month&gt; ordinal and &lt;day&gt;-of-month ordinal. The answer should be the CARDINAL day-of-year number of the day with the given month/day designation."	^(self daysUpToMonth: month) + day - 1</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonthWithKey:day:ifAbsent:">daysUpToMonthWithKey: monthKey day: dayOfMonth ifAbsent: block0	"Anwer the number of days from the first day of the year up to (but not including) the day (in the receiver's year type) with given &lt;monthKey&gt; (semantic identifier) and &lt;day&gt;-of-month ordinal. The answer should be the CARDINAL day-of-year number of the day with the given month/day designation."	^(self daysUpToMonthWithKey: monthKey ifAbsent: [^block0 value]) + dayOfMonth - 1</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonthWithKey:ifAbsent:">daysUpToMonthWithKey: monthKey ifAbsent: block0	"Anwer the number of days from the first day of the year up to (but not including) the first day of the month (in the receiver's year type) with the given &lt;monthKey&gt; (semantic identifier.) The answer should be the CARDINAL day-of-year number of the first day of the month. If the receiver's year type has no month with the given &lt;monthKey&gt;, answer the result of evaluating &lt;block0&gt;."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinalForMonthWithKey:ifAbsent:">monthOrdinalForMonthWithKey: monthKey ifAbsent: block0	"Answer the month ordinal of the month with the given &lt;monthKey&gt; (semantic identifier) in the receiver's year type. If the receiver's year type has no month with the given &lt;monthKey&gt;, answer the result of evaluating &lt;block0&gt;." 	^self subclassResponsibility</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="basicDayAt:">basicDayAt: dayOfYearOrdinal 	"Answer the CalendarDay with the given &lt;dayOfYearOrdinal&gt;.  Fail if the &lt;dayOfYearOrdinal&gt; is invalid."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="basicMonthAt:dayAt:">basicMonthAt: monthOrdinal dayAt: day	"Answer the CalendarDay with the given &lt;monthOrdinal&gt; and &lt;day&gt;-of-month ordinal.  Fail if either the &lt;monthOrdinal&gt; or the the &lt;day&gt;-of-month ordinal are invalid."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="calendar">calendar	"Answer the instance of Calendar that implements the calendrical system of the calendar period whose properties are specified by the receiver."	^calendar</body><body package="Chronos-Calendars-Foundation" selector="dayAt:">dayAt: dayOfYearOrdinal	"Answer the CalendarDay with the given &lt;dayOfYearOrdinal&gt;.  Answer nil if the &lt;dayOfYearOrdinal&gt; is invalid."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysPerStandardYear">daysPerStandardYear	^daysPerStandardYear</body><body package="Chronos-Calendars-Foundation" selector="daysPerYear">daysPerYear	"Answer the number of days per in a year whose type is the same as the year type of the calendar period whose properties are specified by the receiver."	^daysPerYear</body><body package="Chronos-Calendars-Foundation" selector="intercalaryMonthCount">intercalaryMonthCount	^intercalaryMonthCount</body><body package="Chronos-Calendars-Foundation" selector="leapDayCount">leapDayCount	"Answer the number of leap days in the type of year whose properties are specified by the receiver."	^leapDayOrdinals size</body><body package="Chronos-Calendars-Foundation" selector="leapDayOrdinals">leapDayOrdinals	^leapDayOrdinals</body><body package="Chronos-Calendars-Foundation" selector="leapMonthCount">leapMonthCount	"Answer the number of leap months in the type of year whose properties are specified by the receiver."	^leapMonthOrdinals size</body><body package="Chronos-Calendars-Foundation" selector="leapMonthOrdinals">leapMonthOrdinals	^leapMonthOrdinals</body><body package="Chronos-Calendars-Foundation" selector="monthAt:">monthAt: monthOrdinal	"Answer the MonthlyCalendar for the month with the given &lt;monthOrdinal&gt;. Answer nil if the &lt;monthOrdinal&gt; is invalid."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="monthAt:dayAt:">monthAt: monthOrdinal dayAt: day	"Answer the CalendarDay with the given &lt;monthOrdinal&gt; and &lt;day&gt;-of-month ordinal.  Answer nil if either the &lt;monthOrdinal&gt; or the the &lt;day&gt;-of-month ordinal are invalid."	| month |	month := self monthAt: monthOrdinal.	^month == nil		ifFalse: [month dayAt: day]</body><body package="Chronos-Calendars-Foundation" selector="monthsPerYear">monthsPerYear	"Answer the number of months in the type of year whose properties are specified by the receiver."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^YearDuration</body><body package="Chronos-Calendars-Foundation" selector="yearTypeCode">yearTypeCode	"Answer the year type code of the receiver's year type."	^typeCode</body><body package="Chronos-Calendars-Foundation" selector="yearlyCalendar">yearlyCalendar	"Answer the YearlyCalendar instance that specifies the properties of the receiver's year type (if the receiver is itself a YearlyCalendar, answer the receiver.)"	^self</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>testing</category><body package="Chronos-Calendars-Foundation" selector="hasIntercalaryMonths">hasIntercalaryMonths	^intercalaryMonthCount &gt; 0</body><body package="Chronos-Calendars-Foundation" selector="hasLeapDayAt:">hasLeapDayAt: dayOfYearOrdinal	^leapDayOrdinals includes: dayOfYearOrdinal</body><body package="Chronos-Calendars-Foundation" selector="hasLeapDays">hasLeapDays	^hasNoLeapDays not</body><body package="Chronos-Calendars-Foundation" selector="hasLeapMonths">hasLeapMonths	^leapMonthOrdinals size &gt; 0</body><body package="Chronos-Calendars-Foundation" selector="isStandardYear">isStandardYear	^hasNoLeapDays</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>enumerating</category><body package="Chronos-Calendars-Foundation" selector="daysDo:">daysDo: block1	"For each CalendarDay of the receiver's year type, evaluate &lt;block1&gt; with that CalendarDay as the argument."	self monthsDo:[:month | month daysDo: block1]</body><body package="Chronos-Calendars-Foundation" selector="leapDayOrdinalsDo:">leapDayOrdinalsDo: block1	"For each day-of-year ordinal of a leap day in the receiver's year type, evaluate &lt;block1&gt; with said day-of-year ordinal as the argument."	leapDayOrdinals do: block1</body><body package="Chronos-Calendars-Foundation" selector="leapMonthOrdinalsDo:">leapMonthOrdinalsDo: block1	"For each month ordinal of a leap day in the receiver's year type, evaluate &lt;block1&gt; with said month ordinal as the argument."	leapMonthOrdinals do: block1</body><body package="Chronos-Calendars-Foundation" selector="leapMonthsDo:">leapMonthsDo: block1	"For each leap month in the receiver's year type, evaluate &lt;block1&gt; with the MonthlyCalendar of said month as the argument."	self leapMonthOrdinalsDo: [:index | block1 value: (self monthAt:index)]</body><body package="Chronos-Calendars-Foundation" selector="monthsDo:">monthsDo: block1	"For each month in the receiver's year type, evaluate &lt;block1&gt; with the MonthlyCalendar of said month as the argument."	1 to: self monthsPerYear do: [:monthOrdinal | block1 value: (self monthAt: monthOrdinal)]</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="monthlyCalendarClass">monthlyCalendarClass	"Answer the concrete subclass of MonthlyCalendar that should be used to instantiate MonthlyCalendars to represent the months of the receiver's year."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="setMonthsInYear:">setMonthsInYear: specificationOfMonths	"Initialize the receiver so that its month structure is as specified by &lt;specificationOfMonths&gt;--which is an Array of MonthlyCalendarSpecs, such that the entry in the Array whose index is M specifies the properties of the month whose month ordinal is also M. Fail if the receiver is immutable."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	self assertMutability.	typeCode := 0.	daysPerYear := 0.	daysPerStandardYear := 0.	hasNoLeapDays := true.	intercalaryMonthCount := 0.	leapMonthOrdinals := #().	leapDayOrdinals := #().</body><body package="Chronos-Calendars-Foundation" selector="invalidateCalendar">invalidateCalendar	calendar := calendar == nil ifFalse: [Calendar at: calendar registrationKey ifAbsent: [calendar]]</body><body package="Chronos-Calendars-Foundation" selector="setCalendar:">setCalendar: aCalendar	"Initialize the receiver so that it's Calendar is &lt;aCalendar&gt;. Fail if the receiver is not mutable"	self assertMutability.	calendar := aCalendar</body><body package="Chronos-Calendars-Foundation" selector="setTypeCode:specificationOfMonths:">setTypeCode: aYearTypeCode specificationOfMonths: specificationOfMonths	"Initialize the receiver so that its year type code is &lt;yearType&gt;, and so that its month structure is as specified by &lt;specificationOfMonths&gt;--which is an Array of MonthlyCalendarSpecs, such that the entry in the Array whose index is M specifies the properties of the month whose month ordinal is also M. Fail if the receiver is immutable."	self assertMutability.	typeCode := aYearTypeCode.	self setMonthsInYear: specificationOfMonths.	daysPerStandardYear := daysPerYear - self leapDayCount.	hasNoLeapDays := daysPerYear = daysPerStandardYear.</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>printing</category><body package="Chronos-Calendars-Foundation" selector="basicPrintOn:">basicPrintOn: stream	self basicPrintOn: stream showMonths: true</body><body package="Chronos-Calendars-Foundation" selector="basicPrintOn:showMonths:">basicPrintOn: stream showMonths: shouldShowMonths	stream nextPut: ${.	stream 		nextPutAll: self class name;		nextPutAll: ' typeCode=';		print: self yearTypeCode;		tab;		nextPutAll: ' monthsPerYear=';		print: self monthsPerYear;		tab;		nextPutAll: ' daysPerYear=';		print: self daysPerYear;		tab;		nextPutAll: ' leapMonthOrdinals=';		print: self leapMonthOrdinals;		tab;		nextPutAll: ' leapDayOrdinals=';		print: self leapDayOrdinals.		shouldShowMonths ifTrue: [self printMonthsOn: stream indent: 1].	stream nextPut: $}</body><body package="Chronos-Calendars-Foundation" selector="printMonthsOn:indent:">printMonthsOn: stream indent: depth	self monthsDo: [:month |		stream cr.		month printOn: stream indent: depth]</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printYearlyCalendar: self on: stream</body></methods><methods><class-id>Chronos.YearlyCalendar</class-id> <category>converting</category><body package="Chronos-Calendars-Foundation" selector="canonical">canonical	self invalidateCalendar.	^calendar yearlyCalendarForYearTypeCode: self yearTypeCode</body></methods><methods><class-id>Chronos.YearlyCalendar class</class-id> <category>instance creation</category><body package="Chronos-Calendars-Foundation" selector="calendar:typeCode:specificationOfMonths:">calendar: aCalendar typeCode: yearType specificationOfMonths: specificationOfMonths	"Create, initialize and answer an immutable instance of the receiver whose Calendar is &lt;aCalendar&gt;, whose year type code is &lt;yearType&gt;, and whose month structure is specified by &lt;specificationOfMonths&gt;--which is an Array of MonthlyCalendarSpecs, such that the entry in the Array whose index is M specifies the properties of the month whose month ordinal is also M."	^self new 		setCalendar: aCalendar;		setTypeCode: yearType specificationOfMonths: specificationOfMonths;		beImmutable</body></methods><methods><class-id>Chronos.YearlyCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^(Calendar referencedBy: (literalArray at: 2)) canonical		yearlyCalendarForYearTypeCode: (literalArray at: 3) decodeAsLiteralArray</body></methods><methods><class-id>Chronos.YearlyCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Foundation" selector="invalidateCalendarBindings">invalidateCalendarBindings	"YearlyCalendar invalidateCalendarBindings"	self allInstancesDo: [:calendrical | calendrical invalidateCalendar].	self subclasses do: [:class | class invalidateCalendarBindings]</body></methods><methods><class-id>Chronos.StaticYearlyCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="monthWithKey:ifAbsent:">monthWithKey: monthKey ifAbsent: block0	^months detect: [:each | each monthKey == monthKey] ifNone: block0</body><body package="Chronos-Calendars-Regular" selector="monthlyCalendarClass">monthlyCalendarClass	"Answer the concrete subclass of MonthlyCalendar that should be used to instantiate MonthlyCalendars to represent the months of the receiver's year."	^StaticMonthlyCalendar</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendar:">newMonthlyCalendar: aMonthlyCalendarSpecification	^self 		monthlyCalendarClass firstMonthInYear: self 		specification: aMonthlyCalendarSpecification</body><body package="Chronos-Calendars-Regular" selector="setMonthsInYear:">setMonthsInYear: specificationOfMonths	"Initialize the receiver so that its month structure is as specified by &lt;specificationOfMonths&gt;--which is an Array of MonthlyCalendarSpecs, such that the entry in the Array whose index is M specifies the properties of the month whose month ordinal is also M. Fail if the receiver is immutable."	| monthSpec calendarMonth leapMonthStream daysStream leapDaySet |	self assertMutability.	months := Array new: specificationOfMonths size.	monthSpec := specificationOfMonths at: 1.	calendarMonth := self newMonthlyCalendar: monthSpec.	months at: 1 put: calendarMonth.	daysPerYear := calendarMonth daysPerMonth.	2 to: months size do: [:i | 		monthSpec := specificationOfMonths at: i.		months at: i put: (calendarMonth := calendarMonth newForNextMonth: monthSpec).		daysPerYear := daysPerYear + calendarMonth daysPerMonth].	calendarMonth lastDay beImmutable.	calendarMonth beImmutable.	leapMonthOrdinals := Array new.	leapMonthStream := leapMonthOrdinals writeStream.	daysStream := (Array new: daysPerYear) writeStream.	leapDaySet := Set new.	intercalaryMonthCount := 0.	self monthsDo: [:month | 		month isIntercalaryMonth 			ifTrue: 				[intercalaryMonthCount := intercalaryMonthCount + 1.				month isLeapMonth 					ifTrue: [leapMonthStream nextPut: month monthOrdinal]].		month daysDo: [:day | 			daysStream nextPut: day.			day isLeapDay ifTrue: [leapDaySet add: day dayOfYearOrdinal]]].	days := daysStream contents.	leapMonthOrdinals := leapMonthStream contents.	leapDayOrdinals := leapDaySet asSortedCollection asArray.</body></methods><methods><class-id>Chronos.StaticYearlyCalendar</class-id> <category>queries</category><body package="Chronos-Calendars-Regular" selector="dayAt:monthDayDo:">dayAt: dayOfYearOrdinal monthDayDo: block2	"For the day of the receiver's year type with the given &lt;dayOfYearOrdinal&gt;, evaluate &lt;block2&gt; with the day's month ordinal and day-of-month ordinal as the first and second arguments (respectively.)"	^(days at: dayOfYearOrdinal) monthDayDo: block2</body><body package="Chronos-Calendars-Regular" selector="daysInMonthAt:">daysInMonthAt: monthOrdinal	"Answer the number of days in the month of the receiver's year type with the given &lt;monthOrdinal&gt;."	^(self monthAt: monthOrdinal) daysPerMonth</body><body package="Chronos-Calendars-Regular" selector="daysInMonthWithKey:ifAbsent:">daysInMonthWithKey: monthKey ifAbsent: block0	"Answer the number of days in the month of the receiver's year type with the given &lt;monthKey&gt; (semantic identifier.) If there is no month with the given &lt;monthKey&gt; in the receiver's year, answer the result of evaluating &lt;block0&gt;."	^(self monthWithKey: monthKey ifAbsent: [^block0 value]) daysPerMonth</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:">daysUpToMonth: month	"Anwer the number of days from the first day of the year up to (but not including) the first day of the month (in the receiver's year type) with the given &lt;month&gt; ordinal. The answer should be the CARDINAL day-of-year number of the first day of the month."	^(months at: month) daysUpToMonthSinceStartOfYear</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonthWithKey:ifAbsent:">daysUpToMonthWithKey: monthKey ifAbsent: block0	"Anwer the number of days from the first day of the year up to (but not including) the first day of the month (in the receiver's year type) with the given &lt;monthKey&gt; (semantic identifier.) The answer should be the CARDINAL day-of-year number of the first day of the month. If the receiver's year type has no month with the given &lt;monthKey&gt;, answer the result of evaluating &lt;block0&gt;."	^(self monthWithKey: monthKey ifAbsent: [^block0 value]) daysUpToMonthSinceStartOfYear</body><body package="Chronos-Calendars-Regular" selector="monthOrdinalForMonthWithKey:ifAbsent:">monthOrdinalForMonthWithKey: monthKey ifAbsent: block0	"Answer the month ordinal of the month with the given &lt;monthKey&gt; (semantic identifier) in the receiver's year type. If the receiver's year type has no month with the given &lt;monthKey&gt;, answer the result of evaluating &lt;block0&gt;." 	^(self monthWithKey: monthKey ifAbsent: [^block0 value]) monthOrdinal</body></methods><methods><class-id>Chronos.StaticYearlyCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	months := #().	days := #().</body></methods><methods><class-id>Chronos.StaticYearlyCalendar</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="basicDayAt:">basicDayAt: dayOfYearOrdinal 	"Answer the CalendarDay with the given &lt;dayOfYearOrdinal&gt;.  Fail if the &lt;dayOfYearOrdinal&gt; is invalid."	^days at: dayOfYearOrdinal</body><body package="Chronos-Calendars-Regular" selector="basicMonthAt:dayAt:">basicMonthAt: monthOrdinal dayAt: day	"Answer the CalendarDay with the given &lt;monthOrdinal&gt; and &lt;day&gt;-of-month ordinal.  Fail if either the &lt;monthOrdinal&gt; or the the &lt;day&gt;-of-month ordinal are invalid."	^(months at: monthOrdinal) basicDayAt: day</body><body package="Chronos-Calendars-Regular" selector="dayAt:">dayAt: dayOfYearOrdinal 	"Answer the CalendarDay with the given &lt;dayOfYearOrdinal&gt;.  Answer nil if the &lt;dayOfYearOrdinal&gt; is invalid."	^dayOfYearOrdinal &gt; 0 		ifTrue: 			[dayOfYearOrdinal &gt; daysPerYear				ifFalse: [days at: dayOfYearOrdinal]]</body><body package="Chronos-Calendars-Regular" selector="firstMonth">firstMonth	"Answer the MonthlyCalendar instance that specifies the properties of the first month of the receiver's year."	^months first</body><body package="Chronos-Calendars-Regular" selector="lastMonth">lastMonth	"Answer the MonthlyCalendar instance that specifies the properties of the last month of the receiver's year."	^months last</body><body package="Chronos-Calendars-Regular" selector="monthAt:">monthAt: monthOrdinal	"Answer the MonthlyCalendar for the month with the given &lt;monthOrdinal&gt;. Answer nil if the &lt;monthOrdinal&gt; is invalid."	^monthOrdinal &gt; 0		ifTrue: [monthOrdinal &gt; months size			 		ifFalse: [months at: monthOrdinal]]</body><body package="Chronos-Calendars-Regular" selector="monthsPerYear">monthsPerYear	"Answer the number of months in the type of year whose properties are specified by the receiver."	^months size</body></methods><methods><class-id>Chronos.StaticYearlyCalendar</class-id> <category>enumerating</category><body package="Chronos-Calendars-Regular" selector="daysDo:">daysDo: block1	"For each CalendarDay of the receiver's year type, evaluate &lt;block1&gt; with that CalendarDay as the argument."	^days do: block1</body><body package="Chronos-Calendars-Regular" selector="monthsDo:">monthsDo: block1	"For each month in the receiver's year type, evaluate &lt;block1&gt; with the MonthlyCalendar of said month as the argument."	^months do: block1</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>accessing</category><body package="Chronos-TimeZones-Policies-Annual" selector="annualDate">annualDate	^annualDate</body><body package="Chronos-TimeZones-Policies-Annual" selector="annualDateKey">annualDateKey	^self annualDate selfDescribingKey</body><body package="Chronos-TimeZones-Policies-Annual" selector="maxDaysFromStartOfYearUntilTransitionForYearOfType:">maxDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^(annualDate maxDayOfYearOrdinalForYearOfType: yearTypeCode) - 1</body><body package="Chronos-TimeZones-Policies-Annual" selector="maxTransitionDayOfYear">maxTransitionDayOfYear	^annualDate maxDayOfYearOrdinal</body><body package="Chronos-TimeZones-Policies-Annual" selector="minDaysFromStartOfYearUntilTransitionForYearOfType:">minDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^(annualDate minDayOfYearOrdinalForYearOfType: yearTypeCode) - 1</body><body package="Chronos-TimeZones-Policies-Annual" selector="minTransitionDayOfYear">minTransitionDayOfYear	^annualDate minDayOfYearOrdinal</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>queries</category><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year 	^self isSpecifiedAsLocalTime 		ifTrue: 			[self annualDate asDateAndTimeInYear: year timeZone: self offsetFromUT]		ifFalse: 			[self isSpecifiedAsStandardTime 				ifTrue: 					[self annualDate asDateAndTimeInYear: year						timeZone: self stdTimeOffsetFromUT asTimezone]				ifFalse: 					[self annualDate asDateAndTimeInUTYear: year timeZone: self offsetFromUT]]</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDayOfWeekInYear:">transitionDayOfWeekInYear: year	^annualDate ansiDayOfWeekOrdinalInYear: year</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>private</category><body package="Chronos-TimeZones-Policies-Annual" selector="transitionOccursOnOrAfterYear:dayOfYear:relativity:secondsSinceStartOfDayFunction:">transitionOccursOnOrAfterYear: year dayOfYear: dayOfYearOrdinal relativity: parameterRelativity secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	| offsetSecondsFromUT transitionDay transitionSeconds dayDelta deltaSeconds secondsSinceStartOfDay |	relativity == parameterRelativity 		ifTrue: 			[dayOfYearOrdinal &lt; annualDate minDayOfYearOrdinal ifTrue: [^false].			dayOfYearOrdinal &gt; annualDate maxDayOfYearOrdinal ifTrue: [^true].			transitionDay := annualDate dayOfYearOrdinalInYear: year.			dayOfYearOrdinal &lt; transitionDay ifTrue: [^false].			dayOfYearOrdinal &gt; transitionDay ifTrue: [^true].			offsetSecondsFromUT := boundTZ offsetSecondsFromUT.			transitionSeconds := transitionSecondsSinceStartOfDay.			secondsSinceStartOfDay := secondsSinceStartOfDayFunction value: offsetSecondsFromUT.			secondsSinceStartOfDay &lt; 0				ifTrue: [secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]				ifFalse: 					[secondsSinceStartOfDay &gt; SecondsPerDay 						ifTrue: [secondsSinceStartOfDay := SecondsPerDay - secondsSinceStartOfDay]]]		ifFalse: 			[dayDelta := dayOfYearOrdinal - annualDate minDayOfYearOrdinal.			dayDelta &lt; -1 ifTrue: [^false].			dayDelta := dayOfYearOrdinal - annualDate maxDayOfYearOrdinal.			dayDelta &gt; 1 ifTrue: [^true].			offsetSecondsFromUT := boundTZ offsetSecondsFromUT.			relativity == #nominal				ifTrue: 					["parameterRelativity == #universal"					deltaSeconds := offsetSecondsFromUT negated]				ifFalse: 					[relativity == #standard						ifTrue: 							[parameterRelativity == #nominal								ifTrue: 									["parameterRelativity == #nominal"									deltaSeconds := boundTZ offsetDeltaSeconds]								ifFalse:									["parameterRelativity == #universal"									deltaSeconds := boundTZ stdTimeOffsetSecondsFromUT negated]]						ifFalse: 							["parameterRelativity == #nominal"							deltaSeconds := offsetSecondsFromUT]].			transitionSeconds := transitionSecondsSinceStartOfDay + deltaSeconds.			transitionDay := annualDate dayOfYearOrdinalInYear: year.			"Assumption: No REGISTERED Timezone (with a well-known key in the Olson TZ database) will have an offsetSecondsFromUT greater than SecondsPerDay."			transitionSeconds &lt; 0 				ifTrue: 					[transitionDay := transitionDay - 1.					transitionSeconds := transitionSeconds + SecondsPerDay]				ifFalse: 					[transitionSeconds &gt;= SecondsPerDay 						ifTrue: 							[transitionDay := transitionDay + 1.							transitionSeconds := transitionSeconds - SecondsPerDay]].			dayOfYearOrdinal &lt; transitionDay ifTrue: [^false].			dayOfYearOrdinal &gt; transitionDay ifTrue: [^true].			secondsSinceStartOfDay := secondsSinceStartOfDayFunction value: offsetSecondsFromUT].	^secondsSinceStartOfDay &gt;= transitionSeconds</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>converting</category><body package="Chronos-TimeZones-Policies-Annual" selector="asAnnuallyRecurringTZPolicyFactory">asAnnuallyRecurringTZPolicyFactory	"Answer the AnnuallyRecurringTZPolicyFactory that would serve as a factory to recreate an instance of the receiver's class with the same value as the receiver."	^UntilAnnualDateTimeZoneTransitionFactory 		offsetSeconds: self offsetSecondsFromUT		stdTimeOffsetSeconds: self stdTimeOffsetSecondsFromUT		commonAbbreviation: self commonAbbreviation		annualDate: self annualDate		transitionSecondsSinceStartOfDay: self transitionSecondsSinceStartOfDay		relativity: self relativity</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>comparing</category><body package="Chronos-TimeZones-Policies-Annual" selector="compareTo:">compareTo: anUntilAnnualDateTZPolicy	"Answer a strictly positive integer if the receiver's transition time is greater than that of the argument; answer 0 if equal; and answer a negative integer if less."	self == anUntilAnnualDateTZPolicy ifTrue: [^0].	^[anUntilAnnualDateTZPolicy compareToUntilAnnualDateTZPolicy: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == anUntilAnnualDateTZPolicy and: [ex message selector == #compareToUntilAnnualDateTZPolicy:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>private-comparing</category><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilAnnualDateTZPolicy:">compareToUntilAnnualDateTZPolicy: anUntilAnnualDateTZPolicy	| diff |	diff := anUntilAnnualDateTZPolicy annualDate compareTo: annualDate.	diff == nil ifTrue: [^nil].	diff = 0 ifFalse: [^diff].	^anUntilAnnualDateTZPolicy transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilAnnualDayOfYearTZPolicy:">compareToUntilAnnualDayOfYearTZPolicy: anUntilAnnualDayOfYearTZPolicy	| diff |	diff := anUntilAnnualDayOfYearTZPolicy transitionDayOfYear - annualDate minDayOfYearOrdinal.	diff = 0 ifFalse: [^diff].	^anUntilAnnualDayOfYearTZPolicy transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-Policies-Annual" selector="setAnnualDate:">setAnnualDate: anAnnualDate	self assertMutability.	annualDate := anAnnualDate</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition</class-id> <category>printing</category><body package="Chronos-TimeZones-Policies-Annual" selector="printTranstionRuleOn:">printTranstionRuleOn: stream	stream 		print: annualDate.	self printTransitionTimeOfDayOn: stream</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransition class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-Policies-Annual" selector="for:offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:annualDate:transitionSecondsSinceStartOfDay:relativity:">for: anInterYearTimeZonePolicy offsetSeconds: offsetSeconds stdTimeOffsetSeconds: stdTimeOffsetSeconds commonAbbreviation: abbreviation annualDate: annualDate transitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol	^(self new)		setInterYearPolicy: anInterYearTimeZonePolicy offsetSeconds: offsetSeconds stdTimeOffsetSeconds: stdTimeOffsetSeconds commonAbbreviation: abbreviation;		setTransitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol;		setAnnualDate: annualDate</body></methods><methods><class-id>Chronos.CalendarYearPart</class-id> <category>queries</category><body package="Chronos-Calendars-Foundation" selector="forLocale:monthAbbreviationIfResolvable:ifNot:">forLocale: aChronosLocale monthAbbreviationIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the abbreviation of the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self monthlyCalendar 		forLocale: aChronosLocale		monthAbbreviationIfResolvable: resolvable		ifNot: notResolvable</body><body package="Chronos-Calendars-Foundation" selector="forLocale:monthNameIfResolvable:ifNot:">forLocale: aChronosLocale monthNameIfResolvable: resolvable ifNot: notResolvable 	"Evaluate &lt;resolvable&gt; with the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKkey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self monthlyCalendar 		forLocale: aChronosLocale		monthNameIfResolvable: resolvable		ifNot: notResolvable</body><body package="Chronos-Calendars-Foundation" selector="monthKeyIfResolvable:ifNot:">monthKeyIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the key that semantically identifies the receiver's month as the sole argument. However, if the month's semantic key is not unambiguously resolvable, answer the result of evaluationg &lt;notResolvable&gt;. Answer the result of the evaluated block."	^resolvable value: self monthKey</body></methods><methods><class-id>Chronos.CalendarYearPart</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="daysUpToMonthSinceStartOfYear">daysUpToMonthSinceStartOfYear	"For the type of year of the receiver, answer the number of days from the first day of the year up to (but not including) the first day of the receiver's month."	^self monthlyCalendar daysUpToMonthSinceStartOfYear</body><body package="Chronos-Calendars-Foundation" selector="leapDayCountInYear">leapDayCountInYear	"For the type of year of the receiver, answer the number of leap days in the year."	^self yearlyCalendar leapDayCount</body><body package="Chronos-Calendars-Foundation" selector="month">month	"Answer the ordinal of the receiver's month."	^monthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="monthAbbreviation">monthAbbreviation	"Answer the abbreviation of the receiver's month name according to the current default ChronosLocale."	^self monthlyCalendar abbreviation</body><body package="Chronos-Calendars-Foundation" selector="monthKey">monthKey	"Answer the semantic key that identifies the receiver's month."	^self monthlyCalendar monthKey</body><body package="Chronos-Calendars-Foundation" selector="monthName">monthName	"Answer the name of the receiver's month according to the current default ChronosLocale."	^self monthlyCalendar name</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinal">monthOrdinal	"Answer the ordinal of the receiver's month."	^monthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="monthlyCalendar">monthlyCalendar	"Answer the MonthlyCalendar instance that specifies the properties the receiver's month (if the receiver is itself a MonthlyCalendar, answer the receiver.)"	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="monthsPerYear">monthsPerYear	"For the type of year of the receiver, answer the number of months in the year."	^self yearlyCalendar monthsPerYear</body><body package="Chronos-Calendars-Foundation" selector="monthsSinceStartOfYear">monthsSinceStartOfYear	"For the type of year of the receiver, answer the number of months from the first month of the year up to (but not including) the receiver's month (the answer must be the cardinal number of the receiver's month.)"	^self monthlyCalendar monthsSinceStartOfYear</body><body package="Chronos-Calendars-Foundation" selector="yearlyCalendar">yearlyCalendar	"Answer the YearlyCalendar instance that specifies the properties of the receiver's year type (if the receiver is itself a YearlyCalendar, answer the receiver.)"	^containingPeriod yearlyCalendar</body></methods><methods><class-id>Chronos.CalendarYearPart</class-id> <category>printing</category><body package="Chronos-Calendars-Foundation" selector="basicPrintOn:">basicPrintOn: stream	self printOn: stream indent: 0</body></methods><methods><class-id>Chronos.CalendarYearPart</class-id> <category>testing</category><body package="Chronos-Calendars-Foundation" selector="occursEveryYear">occursEveryYear	"Answer whether the calendar period represented by the receiver occurs in each and every type of year of the receiver's calendrical system."	^isLeap not</body><body package="Chronos-Calendars-Foundation" selector="yearHasLeapDays">yearHasLeapDays	"Answer whether the receiver's year has any leap days."	^self yearlyCalendar hasLeapDays</body></methods><methods><class-id>Chronos.CalendarYearPart</class-id> <category>accessing-multivalued</category><body package="Chronos-Calendars-Foundation" selector="eitherMonthOrdinalDo:orMonthkeyDo:">eitherMonthOrdinalDo: block1a orMonthkeyDo: block1b	"If the receiver's month ordinal is unambigously specified, evaluate &lt;block1a&gt; with the receiver's month ordinal. Otherwise, evaluate &lt;block1b&gt; with the semantic key that identifies the receiver's month."	^block1a value: self monthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="eitherYearMonthDayDo:orYearMonthkeyDayDo:">eitherYearMonthDayDo: block3a orYearMonthkeyDayDo: block3b	"If the receiver's month ordinal is unambigously specified, evaluate &lt;block3a&gt; with the receiver's year, its month ordinal and its day-of-month ordinal as the arguments. Otherwise, evaluate &lt;block3b&gt; with the receiver's year,  the semantic key that identifies the receiver's month and its day-of-month ordinal as the arguments."	^self yearMonthDayDo: block3a</body></methods><methods><class-id>Chronos.CalendarYearPart</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	self assertMutability.	monthOrdinal := 1.	isLeap := false</body><body package="Chronos-Calendars-Foundation" selector="invalidateCalendar">invalidateCalendar	containingPeriod := containingPeriod == nil ifFalse: [containingPeriod canonical]</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="dayOfMonth">dayOfMonth	^dayOfMonthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="dayOfMonthOrdinal">dayOfMonthOrdinal	^dayOfMonthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="dayOfYear">dayOfYear	^dayOfYearOrdinal</body><body package="Chronos-Calendars-Foundation" selector="dayOfYearOrdinal">dayOfYearOrdinal	^dayOfYearOrdinal</body><body package="Chronos-Calendars-Foundation" selector="daysPerMonth">daysPerMonth	"Answer the number of days in the receiver's month."	^containingPeriod daysPerMonth</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfMonth">daysSinceStartOfMonth	"Answer the number of days since the first day of the receiver's month up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the month represented by the receiver."	^dayOfMonthOrdinal - 1</body><body package="Chronos-Calendars-Foundation" selector="daysSinceStartOfYear">daysSinceStartOfYear	"Answer the number of days since the first day of the receiver's year up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the year represented by the receiver."	^dayOfYearOrdinal - 1</body><body package="Chronos-Calendars-Foundation" selector="monthlyCalendar">monthlyCalendar	"Answer the MonthlyCalendar instance that specifies the properties the receiver's month (if the receiver is itself a MonthlyCalendar, answer the receiver.)"	^containingPeriod</body><body package="Chronos-Calendars-Foundation" selector="numericMonthDesignator">numericMonthDesignator	"Answer the culturally-correct numerical label for the receiver's month (usually, this is the ordinal number of the month in the sequence of months since the month that begins a year, but such is not the case in all cultures.)"	^self calendar 		numericMonthDesignatorFromMonthOrdinal: self monthOrdinal		forYearTypeCode: self yearTypeCode</body><body package="Chronos-Calendars-Foundation" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^CalendarDayDuration</body><body package="Chronos-Calendars-Foundation" selector="weekOfMonthOrdinal">weekOfMonthOrdinal	"Answer the ordinal number of the week of the month in which the day represented by the receiver occurs.  The first seven days of the month are the first week of the month."	^self weeksSinceStartOfMonth + 1</body><body package="Chronos-Calendars-Foundation" selector="weeksSinceStartOfMonth">weeksSinceStartOfMonth	"Answer the CARDINAL number of the week of the month in which the day represented by the receiver occurs.  The first seven days of the month are in the week whose CARDINAL number is zero."	^self daysSinceStartOfMonth // DaysPerWeek</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>arithmetic</category><body package="Chronos-Calendars-Foundation" selector="addingDays:">addingDays: count	"Answer the CalendarDay in the receiver's year type whose day-of-year ordinal is computed by adding &lt;count&gt; to the receiver's day-of-year ordinal. If the resulting day-of-year ordinal is not valid, answer nil."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="startingWithYear:addingDays:setYearAndCalendarDayInto:">startingWithYear: year addingDays: dayDelta setYearAndCalendarDayInto: block2OrYearMonthDaySpec 	"PRECONDITION: The year type of &lt;year&gt; must be the same as that of the receiver's year."	"For the day that is &lt;dayDelta&gt; days after the day represented by the receiver, send #value:value: to &lt;block2OrYearMonthDaySpec&gt; with the year of said day as the first argument, and the CalendarDay that represents said day as the second argument."	| calendarDay |	calendarDay := self addingDays: dayDelta.	^calendarDay == nil 		ifTrue: 			[self calendar 				startingWithYear: year				addingDays: dayOfYearOrdinal - 1 + dayDelta				setYearAndCalendarDayInto: block2OrYearMonthDaySpec]		ifFalse: [block2OrYearMonthDaySpec value: year value: calendarDay]</body><body package="Chronos-Calendars-Foundation" selector="subtractingDays:">subtractingDays: count	"Answer the CalendarDay in the receiver's year type whose day-of-year ordinal is computed by subtracting &lt;count&gt; from the receiver's day-of-year ordinal. If the resulting day-of-year ordinal is not valid, answer nil."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>accessing-multivalued</category><body package="Chronos-Calendars-Foundation" selector="monthDayDo:">monthDayDo: block2	"Evaluate &lt;block2&gt; with the month ordinal and day-of-month ordinal of the day represented by the receiver as the first and second arguments (respectively.)"	^block2 value: monthOrdinal value: dayOfMonthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="yearMonthDayDo:">yearMonthDayDo: block3	"Evaluate &lt;block3&gt; with the calendar year number, month ordinal and day-of-month ordinal of the day represented by the receiver as the first, second and third arguments (respectively.) If the receiver is not bound to a particular year, use nil as the value of the year."	^block3 		value: nil		value: monthOrdinal		value: dayOfMonthOrdinal</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>testing</category><body package="Chronos-Calendars-Foundation" selector="isFirstDayOfMonth">isFirstDayOfMonth	^dayOfMonthOrdinal = 1</body><body package="Chronos-Calendars-Foundation" selector="isFirstDayOfYear">isFirstDayOfYear	^dayOfYearOrdinal = 1</body><body package="Chronos-Calendars-Foundation" selector="isInIntercalaryMonth">isInIntercalaryMonth	"Answer whether the receiver's month is an intercalary month. An intercalary month is one that either a) does not occur every year, and/or b) does not have nearly the same number of days as the majority of months in the year."	^containingPeriod isIntercalaryMonth</body><body package="Chronos-Calendars-Foundation" selector="isInLeapMonth">isInLeapMonth	"Answer whether the receiver's month is a leap month."	^containingPeriod isLeapMonth</body><body package="Chronos-Calendars-Foundation" selector="isLastDayOfMonth">isLastDayOfMonth	^dayOfMonthOrdinal = self daysPerMonth</body><body package="Chronos-Calendars-Foundation" selector="isLastDayOfYear">isLastDayOfYear	^dayOfYearOrdinal = self daysPerYear</body><body package="Chronos-Calendars-Foundation" selector="isLeapDay">isLeapDay	"Answer whether the day represented by the receiver is a leap day of its year. This will be true for all days in a leap month."	^isLeap</body><body package="Chronos-Calendars-Foundation" selector="isLeapDayInMonth">isLeapDayInMonth	"Answer whether the day represented by the receiver is a leap day of its month. This may or may not be true for days in a leap month."	^isLeapDayInMonth</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>printing</category><body package="Chronos-Calendars-Foundation" selector="printOn:indent:">printOn: stream indent: depth	stream		tab: depth;		nextPut: ${;		nextPutAll: self monthName;		space;		print: self dayOfMonthOrdinal.	self isLeapDay		ifTrue: [stream nextPutAll: ' (leap day)'].	stream nextPut: $}</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printCalendarDay: self on: stream</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	dayOfMonthOrdinal := 1.	dayOfYearOrdinal := 1.	isLeapDayInMonth := false.</body><body package="Chronos-Calendars-Foundation" selector="setMonthlyCalendar:">setMonthlyCalendar: aMonthlyCalendar	self assertMutability.	containingPeriod := aMonthlyCalendar.	monthOrdinal := containingPeriod monthOrdinal.	isLeapDayInMonth := containingPeriod hasLeapDayAt: dayOfMonthOrdinal.	isLeap := isLeapDayInMonth or: [self isInLeapMonth].</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self dayOfYearOrdinal</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>comparing</category><body package="Chronos-Calendars-Foundation" selector="=">= aCalendarDay	^(self compareTo: aCalendarDay) = 0</body><body package="Chronos-Calendars-Foundation" selector="compareTo:">compareTo: otherCalendarDay	"Compare the value of the receiver to that of &lt;otherCalendarDay&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;otherCalendarDay&gt; are the same.)"	self == otherCalendarDay ifTrue: [^0].	^[otherCalendarDay compareToCalendarDay: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == otherCalendarDay and: [ex message selector == #compareToCalendarDay:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-Calendars-Foundation" selector="hash">hash	^(monthOrdinal + dayOfMonthOrdinal) hash</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>private-comparing</category><body package="Chronos-Calendars-Foundation" selector="compareToCalendarDay:">compareToCalendarDay: otherCalendarDay		| diff |	diff := otherCalendarDay monthOrdinal - monthOrdinal.	diff = 0 ifFalse: [^diff].	^otherCalendarDay dayOfMonthOrdinal - dayOfMonthOrdinal</body></methods><methods><class-id>Chronos.CalendarDay</class-id> <category>converting</category><body package="Chronos-Calendars-Foundation" selector="canonical">canonical	^self yearlyCalendar canonical dayAt: self dayOfYearOrdinal</body></methods><methods><class-id>Chronos.CalendarDay class</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^((Calendar referencedBy: (literalArray at: 2)) canonical		yearlyCalendarForYearTypeCode: (literalArray at: 3) decodeAsLiteralArray)			dayAt: (literalArray at: 4)</body></methods><methods><class-id>Chronos.StaticCalendarDay</class-id> <category>arithmetic</category><body package="Chronos-Calendars-Regular" selector="addingDays:">addingDays: count	"Answer the CalendarDay in the receiver's year type whose day-of-year ordinal is computed by adding &lt;count&gt; to the receiver's day-of-year ordinal. If the resulting day-of-year ordinal is not valid, answer nil."	^count = 0		ifTrue: [self]		ifFalse: [self yearlyCalendar dayAt: dayOfYearOrdinal + count]</body><body package="Chronos-Calendars-Regular" selector="subtractingDays:">subtractingDays: count	"Answer the CalendarDay in the receiver's year type whose day-of-year ordinal is computed by subtracting &lt;count&gt; from the receiver's day-of-year ordinal. If the resulting day-of-year ordinal is not valid, answer nil."	^count = 0		ifTrue: [self]		ifFalse: [self yearlyCalendar dayAt: dayOfYearOrdinal - count]</body></methods><methods><class-id>Chronos.StaticCalendarDay</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="advanceToNextDayOfMonth">advanceToNextDayOfMonth	self assertMutability.	dayOfMonthOrdinal := dayOfMonthOrdinal + 1.	dayOfYearOrdinal := dayOfYearOrdinal + 1.	isLeapDayInMonth := containingPeriod hasLeapDayAt: dayOfMonthOrdinal.	isLeap := isLeapDayInMonth or: [self isInLeapMonth].</body><body package="Chronos-Calendars-Regular" selector="advanceToNextDayOfNextMonth">advanceToNextDayOfNextMonth	self assertMutability.	containingPeriod := containingPeriod nextInYear.	monthOrdinal := containingPeriod monthOrdinal.	dayOfMonthOrdinal := 1.	dayOfYearOrdinal := dayOfYearOrdinal + 1.	isLeapDayInMonth := containingPeriod hasLeapDayAt: dayOfMonthOrdinal.	isLeap := isLeapDayInMonth or: [self isInLeapMonth].</body><body package="Chronos-Calendars-Regular" selector="newForNextDayOfMonth">newForNextDayOfMonth	| nextInYear |	self assertMutability.	nextInYear := self copy.	nextInYear advanceToNextDayOfMonth.	self beImmutable.	^nextInYear</body><body package="Chronos-Calendars-Regular" selector="newForNextDayOfNextMonth">newForNextDayOfNextMonth	| nextInYear |	self assertMutability.	nextInYear := self copy.	nextInYear 	advanceToNextDayOfNextMonth.	self beImmutable.	^nextInYear</body></methods><methods><class-id>Chronos.StaticCalendarDay class</class-id> <category>instance creation</category><body package="Chronos-Calendars-Regular" selector="firstDayOfMonth:">firstDayOfMonth: aMonthlyCalendar	"Answer an instance of the receiver initialized as the first day of the month represented by &lt;aMonthlyCalendar&gt; (an instance of MonthlyCalendar.)"	^self new		setMonthlyCalendar: aMonthlyCalendar</body></methods><methods><class-id>Chronos.RomanicCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the calendrical system represented by the receiver starts each day at local midnight."	^true</body></methods><methods><class-id>Chronos.RomanicCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsFromEpochUpToGregorianStart">computeSecondsFromEpochUpToGregorianStart	"Compute and answer the number of seconds from the receiver's epoch up to the canonical moment of official/legal transition to the Gregorian Calendar."	^self subclassResponsibility</body><body package="Chronos-Calendars-Regular" selector="initializeReferenceTimes">initializeReferenceTimes	"Initialize the instance variables of the receiver that store values used to convert between calendrical systems, or that otherwise serve to provide temporal reference points for interpreting dates in the receiver's calendrical system in a calendar-neutral manner."	super initializeReferenceTimes.	secondsFromEpochUpToGregorianStart := self computeSecondsFromEpochUpToGregorianStart</body></methods><methods><class-id>Chronos.RomanicCalendar</class-id> <category>API-InterCalendar</category><body package="Chronos-Calendars-Regular" selector="forSecondsSinceEpoch:canonicalCalendarAndSecondsSinceEpochDo:ifSameCalendar:">forSecondsSinceEpoch: secondsSinceEpoch canonicalCalendarAndSecondsSinceEpochDo: block2 ifSameCalendar: block0 	"For a timepoint that is &lt;secondsSinceEpoch&gt; seconds since the initial moment of the epoch day of the receiver's calendar, determine whether the receiver is the canonical calendar used by the culture that would be, or would have been, the principal users of the receiver's calendar. If so, answer the result of evaluating ther zero-argument block &lt;block0&gt;.  Otherwise, answer the result of evaluating the two-argument block &lt;block2&gt;, where the first block argument is the Calendar instance that is canonical for that culture at that moment in time, and where the second block argument is the number of seconds since the initial moment of the epoch day of the calendrical system represented by the first block argument."	^secondsSinceEpoch &gt;= secondsFromEpochUpToGregorianStart 		ifTrue: 			[self isGregorian 				ifTrue: [block0 value]				ifFalse: 					[block2 						value: Gregorian						value: (Gregorian								secondsSinceEpochFromForeignSecondsSinceEpoch: secondsSinceEpoch								convertingFrom: self)]]		ifFalse: 			[self isJulian 				ifTrue: [block0 value]				ifFalse: 					[block2 						value: Julian						value: (Julian								secondsSinceEpochFromForeignSecondsSinceEpoch: secondsSinceEpoch								convertingFrom: self)]]</body><body package="Chronos-Calendars-Regular" selector="secondsFromEpochUpToGregorianStart">secondsFromEpochUpToGregorianStart	^secondsFromEpochUpToGregorianStart</body></methods><methods><class-id>Chronos.RomanicCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="daysInYearForYearTypeCode:">daysInYearForYearTypeCode: yearTypeCode	"Answer the number of days per year there are in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^yearTypeCode + 364</body><body package="Chronos-Calendars-Regular" selector="eraNameForYear:">eraNameForYear: calendarYear	"Answer the abbreviation of the name of the era to which &lt;calendarYear&gt; belongs.  The name of an era identifies the epoch date of a calendrical system and/or the calendrical system itself (although it may do so ambiguously.) The era name may also identify whether or not the &lt;calendarYear&gt; occurs before or after the epoch date."	^(yearNumberingPolicy cardinalFromCanonical: calendarYear) &gt;= 0		ifTrue: [self defaultLocale properNameAtSemanticKey: #'Christian-era-postEpoch'] 		ifFalse: [self defaultLocale properNameAtSemanticKey: #'Christian-era-preEpoch']</body></methods><methods><class-id>Chronos.RomanicCalendar</class-id> <category>API-queries-months</category><body package="Chronos-Calendars-Regular" selector="daysInMonth:forYearTypeCode:">daysInMonth: monthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days in the month whose ordinal is &lt;monthOrdinal&gt;, in a year whose typeCode is &lt;yearTypeCode&gt;."	^self class daysInMonth: monthOrdinal forYearTypeCode: yearTypeCode</body><body package="Chronos-Calendars-Regular" selector="daysInMonth:inYear:">daysInMonth: month inYear: year       ^self class daysInMonth: month inYear: year</body></methods><methods><class-id>Chronos.RomanicCalendar class</class-id> <category>functional verification</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToMonthDayInYearPassesVerification">daysSinceEpochUpToMonthDayInYearPassesVerification	^self daysSinceEpochUpToMonthDayInYearVerifier value: self</body><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYearPassesVerification">daysSinceEpochUpToYearPassesVerification	^self daysSinceEpochUpToYearVerifier value: self</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonthDayInYearPassesVerification">daysUpToMonthDayInYearPassesVerification	^self daysUpToMonthDayInYearVerifier value: self</body></methods><methods><class-id>Chronos.RomanicCalendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Regular" selector="daysInMonth:forYearTypeCode:">daysInMonth: month forYearTypeCode: yearTypeCode  	"Answer the number of days in the month whose ordinal is &lt;monthOrdinal&gt;, in a year whose typeCode is &lt;yearTypeCode&gt;."        ^(#((31 28 31 30 31 30 31 31 30 31 30 31)            (31 29 31 30 31 30 31 31 30 31 30 31)) at: yearTypeCode) at: month</body><body package="Chronos-Calendars-Regular" selector="daysInMonth:inYear:">daysInMonth: month inYear: year       ^self daysInMonth: month forYearTypeCode: (self typeCodeOfYear: year)</body><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToMonth:day:inYear:">daysSinceEpochUpToMonth: monthOrdinal day: dayOfMonthOrdinal  inYear: calendarYear	"Answer the number of days since the receiver's epoch up to (but not including) the &lt;dayOfMonthOrdinal&gt;th day of the &lt;monthOrdinal&gt;th month of the given &lt;calendarYear&gt;.  By definition, the answer when &lt;calendarYear&gt; = 1 (assuming positve years are ordinal numbers,) &lt;monthOrdinal&gt; = 1 and &lt;dayOfMonthOrdinal&gt; = 1 must be zero."	"VERIFICATION (should evaluate to true):		Gregorian: 		{GregorianCalendar daysSinceEpochUpToMonthDayInYearVerifier value: GregorianCalendar}		Julian: 			{JulianCalendar daysSinceEpochUpToMonthDayInYearVerifier value: JulianCalendar}		Equivalence:	{(((JulianCalendar daysSinceEpochUpToMonth: 10 day: 5 inYear: 1582) 							- (GregorianCalendar daysSinceEpochUpToMonth: 10 day: 15 inYear: 1582))								= (JulianCalendar daysSinceEpochUpToMonth: 1 day: 3 inYear: 1))						and: [((GregorianCalendar daysSinceEpochUpToMonth: 10 day: 15 inYear: 1582) 							- (JulianCalendar daysSinceEpochUpToMonth: 10 day: 5 inYear: 1582))								= (GregorianCalendar daysSinceEpochUpToMonth: 12 day: 30 inYear: 0)]}"	^(self 		daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear)		+ (self daysSinceEpochUpToYear: calendarYear)</body><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: ordinalYearNumber 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	^self subclassResponsibility</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:day:forYearTypeCode:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^dayOfMonthOrdinal - 1 		+ (30 * (monthOrdinal - 1)) 		+ ((monthOrdinal // 8 + monthOrdinal) // 2) 		- (monthOrdinal &gt; 2 ifTrue: [yearTypeCode - 1] ifFalse: [0])</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:day:inYear:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear 	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	"VERIFICATION-Gregorian (should evaluate to true):		{GregorianCalendar daysUpToMonthDayInYearVerifier value: GregorianCalendar}"	"VERIFICATION-Julian (should evaluate to true):		{JulianCalendar daysUpToMonthDayInYearVerifier value: JulianCalendar}"	^dayOfMonthOrdinal - 1 		+ (30 * (monthOrdinal - 1)) 		+ ((monthOrdinal // 8 + monthOrdinal) // 2) 		- (self leapDayCorrectionForYear: calendarYear month: monthOrdinal)</body></methods><methods><class-id>Chronos.RomanicCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="leapDayCorrectionForYear:month:">leapDayCorrectionForYear: year month: month                 ^month &gt; 2                 ifTrue: [(self typeCodeOfYear: year) - 1]                 ifFalse: [0]</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #January 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #February 		daysPerMonth: 29 leapDayOrdinals: #(29));		nextPut: (MonthlyCalendarSpec newWithKey: #March 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #April 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #May 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #June 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #July 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #August 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #September 	daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #October 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #November 	daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #December 	daysPerMonth: 31 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #January 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #February 		daysPerMonth: 28 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #March 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #April 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #May 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #June 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #July 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #August 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #September 	daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #October 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #November 	daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #December 	daysPerMonth: 31 leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.RomanicCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"RomanicCalendar initialize"	LeapYearTypeCode := 2.	self basicInitialize.</body></methods><methods><class-id>Chronos.AbstractJulianCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	| quadYear year days yearTypeCode |	quadYear := daysSinceEpoch // 1461.	days := daysSinceEpoch \\ 1461.	year := days // 365.	days := days \\ 365.	(year == 4 and: [days == 0])		ifTrue: 			[year := year - 1.			days := 365].	"&lt;year&gt; is a CARDINAL number here"	yearTypeCode := 		year == 3 "Last year in 4-year cycle"			ifTrue: [2] 			ifFalse: [1].	^yearMonthDaySpecOrBlock2		value: (yearNumberingPolicy  canonicalFromCardinal: year  + (quadYear * 4))  		value: ((yearlyCalendars at: yearTypeCode) basicDayAt: days + 1)</body></methods><methods><class-id>Chronos.AbstractJulianCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^((yearNumberingPolicy ordinalFromCanonical: calendarYear) \\ 4 == 0)		ifTrue: [2]		ifFalse: [1]</body></methods><methods><class-id>Chronos.AbstractJulianCalendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^((self yearNumberingPolicy ordinalFromCanonical: calendarYear) \\ 4 == 0)		ifTrue: [2]		ifFalse: [1]</body></methods><methods><class-id>Chronos.JulianCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Regular" selector="register">register	super register.	ChronosEnvironment canonical setJulian: self</body><body package="Chronos-Calendars-Regular" selector="release">release	super release.	self == Julian ifTrue: [ChronosEnvironment canonical setJulian: nil]</body></methods><methods><class-id>Chronos.JulianCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="bindToSystem">bindToSystem	"Make the receiver and other sytem objects collaborate with each other, as required by the overall system architecture."	Julian == nil ifTrue: [self register].	super bindToSystem</body><body package="Chronos-Calendars-Regular" selector="computeSecondsFromEpochUpToGregorianStart">computeSecondsFromEpochUpToGregorianStart	^(self 		daysSinceEpochUpToMonth: 10		day: 5		inYear: 1582) * SecondsPerDay</body><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1721423 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.JulianCalendar</class-id> <category>testing</category><body package="Chronos-Calendars-Regular" selector="isJulian">isJulian	"If the receiver implements the Julian Calendar, answer true. Otherwise, answer false."	^true</body></methods><methods><class-id>Chronos.JulianCalendar</class-id> <category>API-validation</category><body package="Chronos-Calendars-Regular" selector="assertIsJulian">assertIsJulian	"If the calendrical system implemented by the receiver is not the Julian calendar, signal an Exception."	"Yup, that's me--so do nothing."</body></methods><methods><class-id>Chronos.JulianCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToMonth:day:inYear:">daysSinceEpochUpToMonth: monthOrdinal day: dayOfMonthOrdinal  inYear: calendarYear	"Answer the number of days since the receiver's epoch up to (but not including) the &lt;dayOfMonthOrdinal&gt;th day of the &lt;monthOrdinal&gt;th month of the given &lt;calendarYear&gt;.  By definition, the answer when &lt;calendarYear&gt; = 1 (assuming positve years are ordinal numbers,) &lt;monthOrdinal&gt; = 1 and &lt;dayOfMonthOrdinal&gt; = 1 must be zero."	^self class daysSinceEpochUpToMonth: monthOrdinal day: dayOfMonthOrdinal  inYear: calendarYear</body><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	^self class daysSinceEpochUpToYear: calendarYear</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:day:forYearTypeCode:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^self class daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:day:inYear:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear 	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^self class daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear</body></methods><methods><class-id>Chronos.JulianCalendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"VERIFICATION (should evaluate to true): {JulianCalendar daysSinceEpochUpToYearVerifier value: self}"	| cardinalYear |	cardinalYear := self yearNumberingPolicy cardinalFromCanonical: calendarYear.	^cardinalYear * 365 + (cardinalYear // 4)</body></methods><methods><class-id>Chronos.JulianCalendar class</class-id> <category>functional verification</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYearVerifier">daysSinceEpochUpToYearVerifier	"JulianCalendar daysSinceEpochUpToYearVerifier value: Calendar julian"	^[:calendar | 	((((calendar daysSinceEpochUpToYear: 1) = 0)			and: [((calendar daysSinceEpochUpToYear: -1) = -366)				and: [((calendar daysSinceEpochUpToYear: 4) = 1095)					and: [((calendar daysSinceEpochUpToYear: -4) = -1461)						and: [(calendar daysSinceEpochUpToYear: 5) = 1461]]]])		and: [((calendar daysSinceEpochUpToYear: 101) = 36525)				and: [((calendar daysSinceEpochUpToYear: 100) = 36159)					and: [((calendar daysSinceEpochUpToYear: 104) = 37620)						and: [((calendar daysSinceEpochUpToYear: 97) = 35064)							and: [(calendar daysSinceEpochUpToYear: 105 ) = 37986]]]]])		and: [((calendar daysSinceEpochUpToYear: -100) = -36525)				and: [((calendar daysSinceEpochUpToYear: -101) = -36891)					and: [((calendar daysSinceEpochUpToYear: -97) = -35430)						and: [((calendar daysSinceEpochUpToYear: -104) = -37986)							and: [(calendar daysSinceEpochUpToYear: -96 ) = -35064]]]]]]</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonthDayInYearVerifier">daysUpToMonthDayInYearVerifier	"JulianCalendar daysUpToMonthDayInYearVerifier value: Calendar julian"	^[:calendar |		((((((calendar daysUpToMonth: 2 day: 29 inYear: 2000) = 59)		and: [(calendar daysUpToMonth: 3 day: 1 inYear: 2000) = 60])		and: [(calendar daysUpToMonth: 3 day: 1 inYear: 1900) = 60])		and: [(calendar daysUpToMonth: 12 day: 31 inYear: 1900) = 365])		and: [(calendar daysUpToMonth: 12 day: 31 inYear: 2000) = 365])		and: [super daysUpToMonthDayInYearVerifier value: calendar canonical]]</body><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpochSetYearAndCalendarDayIntoVerifier">forDaysSinceEpochSetYearAndCalendarDayIntoVerifier	"JulianCalendar forDaysSinceEpochSetYearAndCalendarDayIntoVerifier value: Calendar julian"	^[:calendar | 	| passes |	passes := true.	(calendar forDaysSinceEpoch: 577737		setYearAndCalendarDayInto: 			[:year :calendarDay | 			passes := passes 						and: [year = 1582 and: [calendarDay month = 10 and: [calendarDay dayOfMonth = 5]]]]) 			and: 				[calendar forDaysSinceEpoch: -1721424					setYearAndCalendarDayInto: 						[:year :calendarDay | 						passes := passes 									and: [year = -4713 and: [calendarDay month = 1 and: [calendarDay dayOfMonth = 1]]]]].		passes and: [super forDaysSinceEpochSetYearAndCalendarDayIntoVerifier value: calendar]]</body></methods><methods><class-id>Chronos.JulianCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="leapDayCorrectionForYear:month:">leapDayCorrectionForYear: year month: month                 ^month &gt; 2                 ifTrue: [((self yearNumberingPolicy ordinalFromCanonical: year) \\ 4 = 0) ifTrue: [1] ifFalse: [2]]                 ifFalse: [0]</body><body package="Chronos-Calendars-Regular" selector="newDefaultYearNumberingPolicy">newDefaultYearNumberingPolicy	"Answer a new NumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. NOTE: The ANSI Smalltalk standard REQUIRES the use of 'Astronomical Year Numbering' (i.e., an OrdinalNumberingPolicy) for dates in the Gregorian calendar. The ISO 8601 standard imposes the same requirement."	^self newZerolessOrdinalYearNumberingPolicy</body><body package="Chronos-Calendars-Regular" selector="shouldIgnorePostLoad">shouldIgnorePostLoad	^true</body></methods><methods><class-id>Chronos.JulianCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Julian</body></methods><methods><class-id>Chronos.JulianCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"JulianCalendar initialize"	self basicInitialize.</body></methods><methods><class-id>Chronos.HebrewCalendar</class-id> <category>API-queries-months</category><body package="Chronos-Calendars-Regular" selector="monthOrdinalFromNumericMonthDesignator:forYearTypeCode:">monthOrdinalFromNumericMonthDesignator: numericalMonthDesignator forYearTypeCode: yearTypeCode	"Answer the month ordinal for the month identified by the culturally-correct numeric designator &lt;numericalMonthDesignator&gt;, for a year whose type is identified by the code &lt;yearTypeCode&gt;."	| monthOrdinal |	monthOrdinal := numericalMonthDesignator - 6.	^monthOrdinal &lt; 1		ifTrue: [monthOrdinal + (self monthsInYearForYearTypeCode: yearTypeCode)]		ifFalse: [monthOrdinal]</body><body package="Chronos-Calendars-Regular" selector="monthsInYear:">monthsInYear: year	"Answer the number of months there are in the given &lt;year&gt;."	^((year * 7) + 1) \\ 19 &lt; 7		ifTrue: [13] ifFalse: [12]</body><body package="Chronos-Calendars-Regular" selector="monthsInYearForYearTypeCode:">monthsInYearForYearTypeCode: yearTypeCode 	"Answer the number of months there are per year, in a year whose typeCode is &lt;yearTypeCode&gt;."	^yearTypeCode &lt; 4		ifTrue: [12]		ifFalse: [13]</body><body package="Chronos-Calendars-Regular" selector="numericMonthDesignatorFromMonthOrdinal:forYearTypeCode:">numericMonthDesignatorFromMonthOrdinal: monthOrdinal forYearTypeCode: yearTypeCode	"Answer the culturally-correct numeric designator that identifies the month whose ordinal is &lt;monthOrdinal&gt;, for a year whose type is identified by the code &lt;yearTypeCode&gt;."	| designator monthsInYear |	designator := monthOrdinal + 6.	monthsInYear := self monthsInYearForYearTypeCode: yearTypeCode.	^designator &gt; monthsInYear 		ifTrue: [designator - monthsInYear]		ifFalse: [designator]</body></methods><methods><class-id>Chronos.HebrewCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="daysInYear:">daysInYear: year	"Answer the number of days in the given &lt;year&gt;."	"{(-10000 to: 10000) do: [:year | 		| daysInYearA daysInYearB |		daysInYearA := HebrewCalendar daysInYear: year.		daysInYearB := (HebrewCalendar daysSinceEpochUpToYear: year + 1) - (HebrewCalendar daysSinceEpochUpToYear: year).		daysInYearA = daysInYearB ifFalse: [year halt].		year -&gt; daysInYearA]}"	"{HebrewCalendar daysInYear: 5765}"	"^(self daysSinceEpochUpToYear: year + 1) - (self daysSinceEpochUpToYear: year)"	| daysUpToYear0 daysUpToYear1 daysUpToYear2 daysUpToYear3 |	daysUpToYear1 := self basicDaysSinceEpochUpToYear: year.	daysUpToYear2 := self basicDaysSinceEpochUpToYear: year + 1.	daysUpToYear3 := self basicDaysSinceEpochUpToYear: year + 2.	(daysUpToYear3 - daysUpToYear2) = 356 		ifTrue: [daysUpToYear2 := daysUpToYear2 + 2]		ifFalse:			[(daysUpToYear2 - daysUpToYear1) = 382 				ifTrue: [daysUpToYear2 := daysUpToYear2 + 1]].	(daysUpToYear2 - daysUpToYear1) = 356 		ifTrue: [daysUpToYear1 := daysUpToYear1 + 2]		ifFalse:			[daysUpToYear0 := self basicDaysSinceEpochUpToYear:  year - 1.			(daysUpToYear1 - daysUpToYear0) = 382 				ifTrue: [daysUpToYear1 := daysUpToYear1 + 1]].	^daysUpToYear2 - daysUpToYear1</body><body package="Chronos-Calendars-Regular" selector="daysInYearForYearTypeCode:">daysInYearForYearTypeCode: yearTypeCode	"Answer the number of days per year there are in a year whose type is identified by the code &lt;yearTypeCode&gt;."	^yearTypeCode &lt; 4		ifTrue: [352 + yearTypeCode]		ifFalse: [379 + yearTypeCode]</body><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	"{(-10000 to: 10000) do: [:year | 		| typeCode isLeapYear |		typeCode := HebrewCalendar canonical typeCodeOfYear: year.		isLeapYear := HebrewCalendar isLeapYear: year.		(isLeapYear and: [typeCode &lt; 4]) ifTrue: [year halt].		(typeCode &lt; 1 or: [typeCode &gt; 6]) ifTrue: [year halt]]}"	"{HebrewCalendar typeCodeOfYear: 5765}"	| daysInYear |	daysInYear := self daysInYear: calendarYear.	^daysInYear &lt; 356 		ifTrue: [daysInYear - 352]		ifFalse: [daysInYear - 379]</body></methods><methods><class-id>Chronos.HebrewCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"{(-10000 to: 10000) do: [:year | 		HebrewCalendar canonical			forDaysSinceEpoch: (HebrewCalendar canonical daysSinceEpochUpToYear: year) 			setYearAndCalendarDayInto: [:y :calendarDay | (y = year and: [calendarDay dayOfYear = 1]) ifFalse: [year halt]. y-&gt;calendarDay]]}"	"{HebrewCalendar canonical			forDaysSinceEpoch: (HebrewCalendar canonical daysSinceEpochUpToYear: 5766)			setYearAndCalendarDayInto: [:y :calendarDay | y-&gt;calendarDay]}"	| year daysSinceStartOfYear daysSinceEpochAtStartOfYear daysSinceEpochAtStartOfYear1 daysUpToYear daysUpToNextYear daysUpToPrevYear |	year := daysSinceEpoch * 98496 // 35975351 + 1. "Approximation based on average length of a calendar year--error range is from -1 to +1 years."	"daysSinceEpochAtStartOfYear := self daysSinceEpochUpToYear: year."	daysUpToYear := self basicDaysSinceEpochUpToYear: year.	daysUpToNextYear := self basicDaysSinceEpochUpToYear: year + 1.	(daysUpToNextYear - daysUpToYear) = 356 "'Dehiyyah GaTaRaD' requires that Tishri 1 be postponed to Thursday whenever the Molad of Tishri for a 12-month year is on Tuesday at 9 hours and 204 parts or later. The effect is to disallow a year from having 356 days--a fact that this implementation uses to simply and easily enforce the rule."		ifTrue: [daysSinceEpochAtStartOfYear := daysUpToYear + 2]		ifFalse: 			[daysUpToPrevYear := self basicDaysSinceEpochUpToYear: year -1.			(daysUpToYear - daysUpToPrevYear) = 382 "'Dehiyyah BeTU'TeKaPoT' requires that Tishri 1 be postponed to Tuesday whenever the Molad of Tishri following a 13-month year is on Monday at 15 hours and 589 parts or later. The effect is to disallow a year from having 382 days--a fact that this implementation uses to simply and easily enforce the rule."				ifTrue: [daysSinceEpochAtStartOfYear := daysUpToYear + 1]				ifFalse: [daysSinceEpochAtStartOfYear := daysUpToYear]].	daysSinceStartOfYear := daysSinceEpoch - daysSinceEpochAtStartOfYear.	daysSinceStartOfYear &lt; 0 		ifTrue: 			["Approximation error: -1 years."			year := year - 1.			daysUpToNextYear := daysUpToYear.			daysUpToYear := daysUpToPrevYear == nil ifTrue: [self basicDaysSinceEpochUpToYear: year] ifFalse: [daysUpToPrevYear].			(daysUpToNextYear - daysUpToYear) = 356 "'Dehiyyah GaTaRaD' requires that Tishri 1 be postponed to Thursday whenever the Molad of Tishri for a 12-month year is on Tuesday at 9 hours and 204 parts or later. The effect is to disallow a year from having 356 days--a fact that this implementation uses to simply and easily enforce the rule."				ifTrue: [daysSinceEpochAtStartOfYear := daysUpToYear + 2]				ifFalse: 					[daysUpToPrevYear := self basicDaysSinceEpochUpToYear: year -1.					(daysUpToYear - daysUpToPrevYear) = 382 "'Dehiyyah BeTU'TeKaPoT' requires that Tishri 1 be postponed to Tuesday whenever the Molad of Tishri following a 13-month year is on Monday at 15 hours and 589 parts or later. The effect is to disallow a year from having 382 days--a fact that this implementation uses to simply and easily enforce the rule."						ifTrue: [daysSinceEpochAtStartOfYear := daysUpToYear + 1]						ifFalse: [daysSinceEpochAtStartOfYear := daysUpToYear]].			daysSinceStartOfYear := daysSinceEpoch - daysSinceEpochAtStartOfYear "(self basicDaysSinceEpochUpToYear: year)"]		ifFalse: 			[daysSinceStartOfYear &gt;= 353 "Minimum number of days in a year."				ifTrue: 					["daysSinceEpochAtStartOfYear1 := self daysSinceEpochUpToYear: year + 1."					daysUpToPrevYear := daysUpToYear.					daysUpToYear := daysUpToNextYear.					daysUpToNextYear := self basicDaysSinceEpochUpToYear: year + 2.					(daysUpToNextYear - daysUpToYear) = 356 "'Dehiyyah GaTaRaD' requires that Tishri 1 be postponed to Thursday whenever the Molad of Tishri for a 12-month year is on Tuesday at 9 hours and 204 parts or later. The effect is to disallow a year from having 356 days--a fact that this implementation uses to simply and easily enforce the rule."						ifTrue: [daysSinceEpochAtStartOfYear1 := daysUpToYear + 2]						ifFalse: 							[(daysUpToYear - daysUpToPrevYear) = 382 "'Dehiyyah BeTU'TeKaPoT' requires that Tishri 1 be postponed to Tuesday whenever the Molad of Tishri following a 13-month year is on Monday at 15 hours and 589 parts or later. The effect is to disallow a year from having 382 days--a fact that this implementation uses to simply and easily enforce the rule."								ifTrue: [daysSinceEpochAtStartOfYear1 := daysUpToYear + 1]								ifFalse: [daysSinceEpochAtStartOfYear1 := daysUpToYear]].					daysSinceEpochAtStartOfYear1 &lt;= daysSinceEpoch 						ifTrue: 							["Approximation error: +1 years."							year := year + 1.							daysSinceStartOfYear := daysSinceEpoch - daysSinceEpochAtStartOfYear1]]].	^yearMonthDaySpecOrBlock2 		value: year 		value: ((yearlyCalendars at: (self typeCodeOfYear: year)) basicDayAt: daysSinceStartOfYear + 1)</body><body package="Chronos-Calendars-Regular" selector="startingWithYear:addingDays:setYearAndCalendarDayInto:">startingWithYear: startYear addingDays: dayDelta setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2 	"For a year and CalendarDay that is dayDelta days since the first day of the year &lt;startYear&gt;, send #value:value: to &lt;yearMonthDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	^self 		forDaysSinceEpoch: (self daysSinceEpochUpToYear: startYear) + dayDelta		setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2</body><body package="Chronos-Calendars-Regular" selector="startingWithYear:addingMonths:setYearAndMonthsSinceStartOfYearInto:">startingWithYear: startYear addingMonths: monthDelta setYearAndMonthsSinceStartOfYearInto: block2 	"For a year and months-since-start-of-year that is monthDelta months since the first month of the year &lt;startYear&gt;, send #value:value: to &lt;block2&gt;, with the year as the first argument and the months-since-start-of-year as the second argument."	"{HebrewCalendar canonical		forMonthsSinceEpoch: (YearMonthDay year: 5000 month: 1 day: 1 calendar: #Hebrew) monthsSinceEpoch 		setYearAndMonthsSinceStartOfYearInto: [:y :m | YearMonthDay year: y month: m + 1 day: 1 calendar: #Hebrew]}"	| months monthsInYear year |	months := monthDelta rem: 235.	year := startYear + ((monthDelta quo: 235) * 19).	[months &gt;= (monthsInYear := self monthsInYear: year)] 		whileTrue: 			[year := year + 1.			months := months - monthsInYear].	[months &lt; 0] whileTrue: 			[year := year - 1.			months := months + (monthsInYear := self monthsInYear: year)].	^block2 value: year value: months</body></methods><methods><class-id>Chronos.HebrewCalendar</class-id> <category>API-unification</category><body package="Chronos-Calendars-Regular" selector="secondsSinceMidnightFromSecondsSinceStartOfDay:">secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay	"Answer the number of seconds-since-start-of-day relative to midnight represented by the argument, &lt;secondsSinceStartOfDay&gt;, where the argument is specified relative to the receiver's canonical start-of-day (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since midnight clock time that corresponds to the number of seconds since the receiver's canonical start-of-day clock time, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for time systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Julian Day time system, the canonical start-of-day is Noon."	^secondsSinceStartOfDay + 64800</body><body package="Chronos-Calendars-Regular" selector="secondsSinceStartOfDayFromSecondsSinceMidnight:">secondsSinceStartOfDayFromSecondsSinceMidnight: secondsSinceMidnight	"Answer the number of seconds-since-start-of-day relative to the receiver's canonical start-of-day represented by the argument, &lt;secondsSinceMidnight&gt;, where the argument is specified relative to midnight (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since the receiver's canonical start-of-day clock time that corresponds to the number of seconds since midnight, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for calendar systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Hebrew calendar, the canonical start-of-day is 6pm."	^secondsSinceMidnight + 21600</body></methods><methods><class-id>Chronos.HebrewCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToMonth:day:inYear:">daysSinceEpochUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: year 	"Answer the number of days since the receiver's epoch up to (but not including) the &lt;dayOfMonthOrdinal&gt;th day of the &lt;monthOrdinal&gt;th month of the given &lt;calendarYear&gt;.  By definition, the answer when &lt;calendarYear&gt; = 1 (assuming positve years are ordinal numbers,) &lt;monthOrdinal&gt; = 1 and &lt;dayOfMonthOrdinal&gt; = 1 must be zero."	| daysUpToYear0 daysUpToYear1 daysUpToYear2 daysUpToYear3 daysInYear yearTypeCode |	daysUpToYear1 := self basicDaysSinceEpochUpToYear: year.	daysUpToYear2 := self basicDaysSinceEpochUpToYear: year + 1.	daysUpToYear3 := self basicDaysSinceEpochUpToYear: year + 2.	(daysUpToYear3 - daysUpToYear2) = 356 		ifTrue: [daysUpToYear2 := daysUpToYear2 + 2]		ifFalse:			[(daysUpToYear2 - daysUpToYear1) = 382 				ifTrue: [daysUpToYear2 := daysUpToYear2 + 1]].	(daysUpToYear2 - daysUpToYear1) = 356 		ifTrue: [daysUpToYear1 := daysUpToYear1 + 2]		ifFalse:			[daysUpToYear0 := self basicDaysSinceEpochUpToYear:  year - 1.			(daysUpToYear1 - daysUpToYear0) = 382 				ifTrue: [daysUpToYear1 := daysUpToYear1 + 1]].	daysInYear := daysUpToYear2 - daysUpToYear1.	yearTypeCode := daysInYear &lt; 356 ifTrue: [daysInYear - 352] ifFalse: [daysInYear - 379]. 	^daysUpToYear1+ ((yearlyCalendars at: yearTypeCode) daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal)</body><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"HebrewCalendar daysSinceEpochUpToYear: 5766"	| daysUpToYear daysUpToNextYear daysUpToPrevYear |	daysUpToYear := self basicDaysSinceEpochUpToYear: calendarYear.	daysUpToNextYear := self basicDaysSinceEpochUpToYear: calendarYear + 1.	(daysUpToNextYear - daysUpToYear) = 356 "'Dehiyyah GaTaRaD' requires that Tishri 1 be postponed to Thursday whenever the Molad of Tishri for a 12-month year is on Tuesday at 9 hours and 204 parts or later. The effect is to disallow a year from having 356 days--a fact that this implementation uses to simply and easily enforce the rule."		ifTrue: [^daysUpToYear + 2].	daysUpToPrevYear := self basicDaysSinceEpochUpToYear: calendarYear -1.	^(daysUpToYear - daysUpToPrevYear) = 382 "'Dehiyyah BeTU'TeKaPoT' requires that Tishri 1 be postponed to Tuesday whenever the Molad of Tishri following a 13-month year is on Monday at 15 hours and 589 parts or later. The effect is to disallow a year from having 382 days--a fact that this implementation uses to simply and easily enforce the rule."		ifTrue: [daysUpToYear + 1]		ifFalse: [daysUpToYear]</body><body package="Chronos-Calendars-Regular" selector="monthsSinceEpochUpToYear:">monthsSinceEpochUpToYear: year 	"Answer the count of months since the Epoch day (start of day) up to (but NOT including) the first month of the specified year."	^((235 * year) - 234) // 19</body></methods><methods><class-id>Chronos.HebrewCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="basicDaysSinceEpochUpToYear:">basicDaysSinceEpochUpToYear: year		| molads basicDaysSinceEpoch ordinalDayNumber |	molads := self monthsSinceEpochUpToYear: year.	"'Dehiyyah Molad Zaqen' requires that the first day of Tishri (aka Rosh ha Shannah; New Year's Day) be delayed by one day whenever the Molad of Tishri (the computed occurrence of the new moon on or after which the month of Tishri should start) occurs on or after the 18th hour of the Hebrew day (that's on or after 12 noon modern clock time.) This rule is enforced by adding 6 hours (6480 parts) to the time for Molad Beharad (the new moon that marks the Epoch Day of the Hebrew Calendar, which is set by definition at 5604 parts since-start-of-day on Epoch Day, which corresponds to precisely -3760-09-06T23:11:20 Gregorian (using astronomical year numbering, as required by both ANSI and ISO standards))  The occurence of the value 12804 (6480 + 5604 = 12804) as an additive term in the expression in the statement that follows this comment implements the algorithmic enforcement of this rule."	basicDaysSinceEpoch := 29 * molads + (((13753 * molads) + 12804) / 25920) floor.	"'Dehiyyah Lo ADU Rosh' requires that the first day of Tishri be postponed to the following day whenever the Molad of Tishri occurs on a Sunday, Wednesday or Friday. This is implemented using the following logic:"	ordinalDayNumber := basicDaysSinceEpoch + 1.	^3 * ordinalDayNumber \\ 7 &lt; 3		ifTrue: 			["The Molad occurs on Sunday, Wednesday or Friday, so the start-of-year is delayed by one day."			ordinalDayNumber]		ifFalse: 			["The Molad occurs on Monday, Tuesday, Thursday or Saturday, so the start-of-year is not delayed by 'Dehiyyah Lo ADU Rosh'."			basicDaysSinceEpoch]</body><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^347997 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.HebrewCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the calendrical system represented by the receiver starts each day at local midnight."	^false</body><body package="Chronos-Calendars-Regular" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the calendrical system implemented by the receiver coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^false</body></methods><methods><class-id>Chronos.HebrewCalendar class</class-id> <category>fundamental algorithms-conversions</category><body package="Chronos-Calendars-Regular" selector="daysFromMolads:">daysFromMolads: molads	^molads * 765433 / 25920</body><body package="Chronos-Calendars-Regular" selector="moladsFromDays:">moladsFromDays: days	^days * 25920 / 765433</body><body package="Chronos-Calendars-Regular" selector="moladsFromSeconds:">moladsFromSeconds: seconds	^seconds * 3 / 7654330</body><body package="Chronos-Calendars-Regular" selector="partsFromSeconds:">partsFromSeconds: seconds	^seconds * 3 / 10</body><body package="Chronos-Calendars-Regular" selector="partsPerMolad">partsPerMolad	^765433</body><body package="Chronos-Calendars-Regular" selector="secondsFromMolads:">secondsFromMolads: molads	^molads * 7654330 / 3</body><body package="Chronos-Calendars-Regular" selector="secondsFromParts:">secondsFromParts: parts	^parts * 10 / 3</body><body package="Chronos-Calendars-Regular" selector="secondsPerMolad">secondsPerMolad	^7654330/3</body></methods><methods><class-id>Chronos.HebrewCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsFor353DayYear">newMonthlyCalendarSpecsFor353DayYear	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Tishri daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Marheshvan daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Kislev daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Teveth daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shevat daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Adar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nisan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Iyyar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sivan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tammuz daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Av daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Elul daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsFor354DayYear">newMonthlyCalendarSpecsFor354DayYear	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Tishri daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Marheshvan daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Kislev daysPerMonth: 30 leapDayOrdinals: #(30));		nextPut: (MonthlyCalendarSpec newWithKey: #Teveth daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shevat daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Adar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nisan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Iyyar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sivan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tammuz daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Av daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Elul daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsFor355DayYear">newMonthlyCalendarSpecsFor355DayYear	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Tishri daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Marheshvan daysPerMonth: 30 leapDayOrdinals: #(30));		nextPut: (MonthlyCalendarSpec newWithKey: #Kislev daysPerMonth: 30 leapDayOrdinals: #(30));		nextPut: (MonthlyCalendarSpec newWithKey: #Teveth daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shevat daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Adar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nisan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Iyyar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sivan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tammuz daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Av daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Elul daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsFor383DayYear">newMonthlyCalendarSpecsFor383DayYear	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Tishri daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Marheshvan daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Kislev daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Teveth daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shevat daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey: #'Adar Rishon' nameKey: #'Adar Rishon' daysPerMonth: 30 occursEveryYear: false leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Adar nameKey: #'Adar Sheni' daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nisan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Iyyar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sivan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tammuz daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Av daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Elul daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsFor384DayYear">newMonthlyCalendarSpecsFor384DayYear	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Tishri daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Marheshvan daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Kislev daysPerMonth: 30 leapDayOrdinals: #(30));		nextPut: (MonthlyCalendarSpec newWithKey: #Teveth daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shevat daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey: #'Adar Rishon' daysPerMonth: 30 occursEveryYear: false leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Adar nameKey: #'Adar Sheni' daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nisan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Iyyar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sivan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tammuz daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Av daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Elul daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsFor385DayYear">newMonthlyCalendarSpecsFor385DayYear	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Tishri daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Marheshvan daysPerMonth: 30 leapDayOrdinals: #(30));		nextPut: (MonthlyCalendarSpec newWithKey: #Kislev daysPerMonth: 30 leapDayOrdinals: #(30));		nextPut: (MonthlyCalendarSpec newWithKey: #Teveth daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shevat daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey: #'Adar Rishon' daysPerMonth: 30 occursEveryYear: false leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Adar nameKey: #'Adar Sheni' daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nisan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Iyyar daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sivan daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tammuz daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Av daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Elul daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="setMonthlyCalendarSpecs">setMonthlyCalendarSpecs	"Initialize the class instance variable monthlyCalendarSpecs, so that it contains an Array of Array of MonthlyCalendarSpecs.  There must be one Array of MonthlyCalendarSpecs in the outer Array (the one referenced by monthlyCalendarSpecs) for each 'year type' of the calendrical system implemented by instances of the receiver.  There must be a MonthlyCalendarSpec in the inner Array for each month for each year type.  See the class comments of ArithmeticalCalendar, Calendar and MonthlyCalendarSpec for more information."	monthlyCalendarSpecs := Array new: 6.	monthlyCalendarSpecs 		at: 1 put: self newMonthlyCalendarSpecsFor353DayYear;			at: 2 put: self newMonthlyCalendarSpecsFor354DayYear;			at: 3 put: self newMonthlyCalendarSpecsFor355DayYear;			at: 4 put: self newMonthlyCalendarSpecsFor383DayYear;		at: 5 put: self newMonthlyCalendarSpecsFor384DayYear;			at: 6 put: self newMonthlyCalendarSpecsFor385DayYear</body></methods><methods><class-id>Chronos.HebrewCalendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToTishriMoladForYear:">daysSinceEpochUpToTishriMoladForYear: year	"(HebrewCalendar daysSinceEpochUpToTishriMoladForYear: 2) floor"	^((467 / 2160) + (self daysFromMolads: (((235 * year) - 234) // 19)))</body><body package="Chronos-Calendars-Regular" selector="isLeapYear:">isLeapYear: year	^((year * 7) + 1) \\ 19 &lt; 7</body><body package="Chronos-Calendars-Regular" selector="partsSinceStartOfDayAtMoladBeharad">partsSinceStartOfDayAtMoladBeharad	^5604</body><body package="Chronos-Calendars-Regular" selector="secondsSinceStartOfDayAtMoladBeharad">secondsSinceStartOfDayAtMoladBeharad	^18680</body><body package="Chronos-Calendars-Regular" selector="yearTypeCodesDo:">yearTypeCodesDo: block1	1 to: 6 do: [:ytc | block1 value: ytc]</body></methods><methods><class-id>Chronos.HebrewCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Hebrew</body></methods><methods><class-id>Chronos.HebrewCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"HebrewCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	secondsFromCalendarEpochUpToSystemClockEpoch := 0.	secondsFromGregorianEpochUpToSystemClockEpoch := 0</body><body package="Chronos-Calendars-Foundation" selector="invalidateCalendar">invalidateCalendar	calendar := calendar == nil ifFalse: [Calendar at: calendar registrationKey ifAbsent: [calendar]]</body><body package="Chronos-Calendars-Foundation" selector="setCalendar:">setCalendar: aCalendar	self assertMutability.	calendar := aCalendar.	self bindToCalendar.</body><body package="Chronos-Calendars-Foundation" selector="setSystemClock:">setSystemClock: aSystemClock	self assertMutability.	systemClock := aSystemClock.</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="calendar">calendar	^calendar</body><body package="Chronos-Calendars-Foundation" selector="daysFromCalendarEpochUpToSystemClockEpoch">daysFromCalendarEpochUpToSystemClockEpoch	"Answer the number of days (mean solar) from the epoch of the receiver's calendar up to (but not including) the epoch of the receiver's systemClock."	^(secondsFromCalendarEpochUpToSystemClockEpoch bitShift: -7) // 675</body><body package="Chronos-Calendars-Foundation" selector="epoch">epoch	"Answer a DateAndTime that represents the epoch of the receiver's systemClock, and that designates the date and time of the sytemClock's epoch using the calendrical system implemented by the receiver's calendar."	^systemClock isRelativeToUT 		ifTrue: 			[DateAndTimeFactory 				utSecondsSinceEpoch: self secondsFromCalendarEpochUpToSystemClockEpoch				timeZone: ChronosTimezone universal				calendar: calendar]		ifFalse: 			[DateAndTimeFactory 				secondsSinceEpoch: self secondsFromCalendarEpochUpToSystemClockEpoch				calendar: calendar]</body><body package="Chronos-Calendars-Foundation" selector="gregorianEpoch">gregorianEpoch	"Answer a DateAndTime that represents the epoch of the receiver's systemClock, and that designates the date and time of the sytemClock's epoch using the Gregorian Calendar."	^systemClock epoch</body><body package="Chronos-Calendars-Foundation" selector="precision">precision	"Answer a Duration whose value indicates the precision of the receiver's systemClock.  The precision of a clock is the average time interval between updates to the clock's tick count.  The 'tick size' of a clock is the minimum time interval that notationally can be represented by the clock's time counter (the clock's 'tick size' is also called the 'clock resolution.')"	^systemClock precision</body><body package="Chronos-Calendars-Foundation" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the resolution of the receiver's systemClock.  The resolution of a clock is the minimum temporal extent that notationally can be represented by the clock's time counter."	^systemClock resolutionQuantum</body><body package="Chronos-Calendars-Foundation" selector="secondsFromCalendarEpochUpToSystemClockEpoch">secondsFromCalendarEpochUpToSystemClockEpoch	"Answer the number of seconds (UT1) from the epoch of the receiver's calendar up to (but not including) the epoch of the receiver's systemClock."	^secondsFromCalendarEpochUpToSystemClockEpoch</body><body package="Chronos-Calendars-Foundation" selector="systemClock">systemClock	^systemClock</body><body package="Chronos-Calendars-Foundation" selector="timescale">timescale	"Answer the Timescale used by the receiver."	^self notYetImplemented</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>API-Current Dates &amp; Times</category><body package="Chronos-Calendars-Foundation" selector="dateToday">dateToday	"Answer a date value representing today's date, in the receiver's calendar, and relative to the current default timezone."	"{Calendar gregorian clock dateToday}"	"{Calendar julian clock dateToday}"	^(self mutableDateTodayIn: ChronosTimezone default) beImmutable</body><body package="Chronos-Calendars-Foundation" selector="dateTodayIn:">dateTodayIn: aTimezoneOrTimezoneReference 	"Answer a date value representing today's date, in the receiver's calendar, and relative to the timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;."	"{Calendar gregorian clock dateTodayIn: (Duration hours: 10) asTimezone}"	"{Calendar julian clock dateTodayIn: (Duration hours: 10) asTimezone}"	^(self mutableDateTodayIn: (ChronosTimezone referencedBy: aTimezoneOrTimezoneReference)) 		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="nominalNow">nominalNow	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the current default timezone, and with invariant-to-nominal-time semantics."	"{Calendar gregorian clock nominalNow}"	"{Calendar julian clock nominalNow}"	^self nominalNow: true</body><body package="Chronos-Calendars-Foundation" selector="nominalNowToTheSecond">nominalNowToTheSecond	"Answer a DateAndTime (a point-in-time value) representing the current date and time to the second, in the receiver's calendar, relative to the current default timezone, and with invariant-to-nominal-time semantics."	"{Calendar gregorian clock nominalNowToTheSecond}"	"{Calendar julian clock nominalNowToTheSecond}"	^self nominalNow: false</body><body package="Chronos-Calendars-Foundation" selector="nominalToday">nominalToday	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the current default timezone, and with invariant-to-nominal-time semantics."	^self basicTodayIn: ChronosTimezone nominal</body><body package="Chronos-Calendars-Foundation" selector="now">now	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the current default timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock now}"	"{Calendar julian clock now}"	^self nowIn: ChronosTimezone default includeNanoseconds: true</body><body package="Chronos-Calendars-Foundation" selector="nowIn:">nowIn: aTimezoneOrTimezoneReference 	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the  timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;, and with invariant-to-UT semantics."	"{Calendar gregorian clock nowIn: #'Pacific/Honolulu'}"	"{Calendar julian clock nowIn: #'Pacific/Honolulu'}"	^self nowIn: (ChronosTimezone referencedBy: aTimezoneOrTimezoneReference) includeNanoseconds: true</body><body package="Chronos-Calendars-Foundation" selector="nowToTheSecond">nowToTheSecond	"Answer a DateAndTime (a point-in-time value) representing the current date and time to the second, in the receiver's calendar, relative to the current default timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock nowToTheSecond}"	"{Calendar julian clock nowToTheSecond}"	^self nowIn: ChronosTimezone default includeNanoseconds: false</body><body package="Chronos-Calendars-Foundation" selector="nowToTheSecondIn:">nowToTheSecondIn: aTimezoneOrTimezoneReference	"Answer a DateAndTime (a point-in-time value) representing the current date and time to the second, in the receiver's calendar, relative to the  timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;, and with invariant-to-UT semantics."	"{Calendar gregorian cock nowToTheSecondIn: #'Pacific/Honolulu'}"	"{Calendar julian clock nowToTheSecondIn: #'Pacific/Honolulu'}"	^self nowIn: (ChronosTimezone referencedBy: aTimezoneOrTimezoneReference) includeNanoseconds: false</body><body package="Chronos-Calendars-Foundation" selector="thisDayOfMonth">thisDayOfMonth	"Answer the day of the month of today's date, in the receiver's calendar, and relative to the current default timezone."	^self dateToday dayOfMonth</body><body package="Chronos-Calendars-Foundation" selector="thisDayOfYear">thisDayOfYear	"Answer the day of the year ordinal of today's date, in the receiver's calendar, and relative to the current default timezone."	^self dateToday dayOfYear</body><body package="Chronos-Calendars-Foundation" selector="thisMonth">thisMonth	"Answer the ordinal of today's month, in the receiver's calendar, and relative to the current default timezone."	^self dateToday month</body><body package="Chronos-Calendars-Foundation" selector="thisYear">thisYear	"Answer the current year, in the receiver's calendar, and relative to the current default timezone."	^self dateToday year</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayNow">timeOfDayNow	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the current default timezone."	"{Calendar gregorian clock timeOfDayNow}"	"{Calendar julian clock timeOfDayNow}"	^self timeOfDayNowIn: ChronosTimezone default includeNanoseconds: true</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayNowIn:">timeOfDayNowIn: aTimezoneOrTimezoneReference 	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;."	"{Calendar gregorian clock timeOfDayNowIn: #'Pacific/Honolulu'}"	"{Calendar julian clock timeOfDayNowIn: #'Pacific/Honolulu'}"	^self timeOfDayNowIn: (ChronosTimezone referencedBy: aTimezoneOrTimezoneReference) includeNanoseconds: true</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayNowToTheSecond">timeOfDayNowToTheSecond	"Answer a time-of-day value representing the current time-of-day to the second, in the receiver's calendar, and relative to the current default timezone."	"{Calendar gregorian clock timeOfDayNowToTheSecond}"	"{Calendar julian clock timeOfDayNowToTheSecond}"	^self timeOfDayNowIn: ChronosTimezone default includeNanoseconds: false</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayNowToTheSecondIn:">timeOfDayNowToTheSecondIn: aTimezoneOrTimezoneReference	"Answer a time-of-day value representing the current time-of-day to the second, in the receiver's calendar, and relative to the timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;."	"{Calendar gregorian clock timeOfDayNowToTheSecondIn: #'Pacific/Honolulu'}"	"{Calendar julian clock timeOfDayNowToTheSecondIn: #'Pacific/Honolulu'}"	^self timeOfDayNowIn: (ChronosTimezone referencedBy: aTimezoneOrTimezoneReference) includeNanoseconds: false</body><body package="Chronos-Calendars-Foundation" selector="today">today	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the current default timezone, and with invariant-to-UT semantics."	"{Gregorian clock today}"	^self basicTodayIn: ChronosTimezone default</body><body package="Chronos-Calendars-Foundation" selector="todayIn:">todayIn: aTimezoneOrTimezoneReference	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the  timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;, and with invariant-to-UT semantics." 	"{Calendar gregorian clock todayIn: #'Pacific/Honolulu'}"	"{Calendar julian clock todayIn: #'Pacific/Honolulu'}"	^self basicTodayIn: (ChronosTimezone referencedBy: aTimezoneOrTimezoneReference)</body><body package="Chronos-Calendars-Foundation" selector="utNow">utNow	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the UT timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock utNow}"	"{Calendar julian clock utNow}"	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="utTimeOfDayNow">utTimeOfDayNow	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the UT timezone."	"{Calendar gregorian clock utTimeOfDayNow}"	"{Calendar julian clock utTimeOfDayNow}"	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="utToday">utToday	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the UT timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock utToday}"	"{Calendar julian clock utToday}"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicTodayIn:">basicTodayIn: aTimezone	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the timezone implemented by &lt;aTimezone&gt; (which must be an instance of a concrete subclass of ChronosTimezone,) and with invariant-to-UT semantics." 	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self calendar registrationKey</body><body package="Chronos-Calendars-Foundation" selector="mutableDateTodayIn:">mutableDateTodayIn: aTimezone	"Answer a date value representing today's date, in the receiver's calendar, and relative to the timezone implemented by &lt;aTimezone&gt; (which must be an instance of a concrete subclass of ChronosTimezone.)"	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="nominalNow:">nominalNow: includeNanoseconds 	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the current default timezone, and with invariant-to-nominal-time semantics. If &lt;includeNanoseconds&gt; is true, include the number of nanoseconds-since-the-second in the answered DateAndTime; otherwise, have the answered DateAndTime specify zero nanoseconds-since-the-second (so that the current date and time is reported only to the latest second.)"	"{Calendar gregorian clock nominalNow: true}"	"{Calendar julian clock nominalNow: false}"	^self nowIn: DateAndTimeFactory nominalTZ includeNanoseconds: includeNanoseconds</body><body package="Chronos-Calendars-Foundation" selector="nowIn:includeNanoseconds:">nowIn: aTimezoneOrTimezoneReference includeNanoseconds: includeNanoseconds 	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the  timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;, and with invariant-to-UT semantics. If &lt;includeNanoseconds&gt; is true, include the number of nanoseconds-since-the-second in the answered DateAndTime; otherwise, have the answered DateAndTime specify zero nanoseconds-since-the-second (so that the current date and time is reported only to the latest second.)"	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayNowIn:includeNanoseconds:">timeOfDayNowIn: aTimezoneOrTimezoneReference includeNanoseconds: includeNanoseconds 	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;. If &lt;includeNanoseconds&gt; is true, include the number of nanoseconds-since-the-second in the answered time-of-day value; otherwise, have the answered time-of-day value specify zero nanoseconds-since-the-second (so that the current date and time is reported only to the latest second.)"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>API-converting</category><body package="Chronos-Calendars-Foundation" selector="chronosDateAndTimeFromNativeCalendricalCoordinate:">chronosDateAndTimeFromNativeCalendricalCoordinate: aNativeTimestampOrDate	"Answer a Chronos DateAndTime that semantically corresponds as closely as possible to &lt;aNativeTimestampOrDate&gt;.	PRECONDITION: The receiver must already have been bound to its calendar; 		specificially, the instance variable &lt;secondsFromCalendarEpochUpToSystemClockEpoch&gt; must contain a valid value."	^ChronosSystemFacade current chronosDateAndTimeFromNativeCalendricalCoordinate: aNativeTimestampOrDate calendarClock: self</body><body package="Chronos-Calendars-Foundation" selector="chronosDateFromNativeCalendricalCoordinate:">chronosDateFromNativeCalendricalCoordinate: aNativeTimestampOrDate	"Answer a Chronos YearMonthDay that semantically corresponds as closely as possible to &lt;aNativeTimestampOrDate&gt;.	PRECONDITION: The receiver must already have been bound to its calendar; 		specificially, the instance variable &lt;secondsFromCalendarEpochUpToSystemClockEpoch&gt; must contain a valid value."	^ChronosSystemFacade current chronosDateFromNativeCalendricalCoordinate: aNativeTimestampOrDate calendarClock: self</body><body package="Chronos-Calendars-Foundation" selector="nativeCalendricalCoordinateFromChronosDate:">nativeCalendricalCoordinateFromChronosDate: aChronosDate	"Answer the native 'Date' analog (or 'Timestamp' analog, if no Date analog is available) that semantically corresponds as closely as possible to &lt;aChronosDate&gt;.	PRECONDITION: The receiver must already have been bound to its calendar; 		specificially, the instance variable &lt;secondsFromCalendarEpochUpToSystemClockEpoch&gt; must contain a valid value."	^ChronosSystemFacade current nativeCalendricalCoordinateFromChronosDate: aChronosDate</body><body package="Chronos-Calendars-Foundation" selector="nativeCalendricalCoordinateFromChronosDateAndTime:">nativeCalendricalCoordinateFromChronosDateAndTime: aChronosDateAndTime	"Answer the native 'Timestamp' analog (or 'Date' analog, if no Timestamp analog is available) that semantically corresponds as closely as possible to &lt;aChronosDateAndTime&gt;.	PRECONDITION: The receiver must already have been bound to its calendar; 		specificially, the instance variable &lt;secondsFromCalendarEpochUpToSystemClockEpoch&gt; must contain a valid value."	^ChronosSystemFacade current nativeCalendricalCoordinateFromChronosDateAndTime: aChronosDateAndTime</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>private-UT operations</category><body package="Chronos-Calendars-Foundation" selector="mutableDateAndTimeAtStartOfDayFromUTSecondsSinceSystemClockEpoch:timeZone:">mutableDateAndTimeAtStartOfDayFromUTSecondsSinceSystemClockEpoch: utSecondsSinceSystemClockEpoch timeZone: aTimeZone 	"Answer a Timepoint (bound to the specified &lt;calendar&gt;) whose local time in the time zone defined by the receiver, and as defined by the time-of-day clock of the specified &lt;calendar&gt;, is the first moment of the day (as defined by the specified &lt;calendar&gt;) that starts less than one day prior to the moment in time that is &lt;utSecondsSinceGregorianEpoch&gt; seconds since the Gregorian epoch (relative to Universal Time) and &lt;utSecondsSinceCalendarEpoch&gt; seconds since the epoch of the specified &lt;calendar&gt; (relative to Universal Time)."	"{HebrewCalendar clock		mutableDateAndTimeAtStartOfDayFromUTSecondsSinceSystemClockEpoch: SystemClock secondsNowSinceSystemClockEpoch		timeZone: Timezone default}"	"{AnsiStandardCalendarClock		mutableDateAndTimeAtStartOfDayFromUTSecondsSinceSystemClockEpoch: SystemClock secondsNowSinceSystemClockEpoch 		timeZone: Timezone default}"		| timeZone utSecondsSinceGregorianEpoch secondsDiv128 secondsMod128 gregorianDaysSinceEpoch utcSecondsSinceStartOfDay offsetSecondsFromUT localTZ annualPolicy gregorianYMD today secondsSinceStartOfDay dayDelta |	utSecondsSinceGregorianEpoch := utSecondsSinceSystemClockEpoch + secondsFromGregorianEpochUpToSystemClockEpoch.	secondsDiv128 := utSecondsSinceGregorianEpoch bitShift: -7. "Bit shifting is faster than LargeInteger math."	gregorianDaysSinceEpoch := secondsDiv128 // 675. "128 * 675 = 86400"	secondsMod128 := utSecondsSinceGregorianEpoch bitAnd: 127.	utcSecondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7). "seconds \\ 128 + (seconds // 128 \\ 675 * 128)"	timeZone := aTimeZone.	localTZ := aTimeZone asNonProxy.	localTZ isStatic 		ifTrue: [offsetSecondsFromUT := localTZ offsetSecondsFromUT]		ifFalse: 			[gregorianYMD := Gregorian dateSpecFromDaysSinceEpoch: gregorianDaysSinceEpoch.			annualPolicy := 				localTZ					annualPolicyForUTYear: gregorianYMD year					dayOfYear: gregorianYMD dayOfYearOrdinal					secondsSinceStartOfDayFunction: [:offsetSeconds | utcSecondsSinceStartOfDay].			offsetSecondsFromUT := annualPolicy offsetSecondsFromUT.			aTimeZone isProxy ifFalse: [timeZone := annualPolicy]].	today := (DateAndTimeFactory basicNew)				basicSetCalendar: calendar;				setNanosecondsSinceSecond: 0.	calendar isGregorian 		ifTrue: 			[secondsSinceStartOfDay := utcSecondsSinceStartOfDay + offsetSecondsFromUT.			offsetSecondsFromUT abs &gt;= SecondsPerDay 				ifTrue: 					[dayDelta := secondsSinceStartOfDay // SecondsPerDay.					secondsSinceStartOfDay := secondsSinceStartOfDay \\ SecondsPerDay]				ifFalse: 					[secondsSinceStartOfDay &lt; 0 						ifTrue: 							[dayDelta := -1.							secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]						ifFalse: 							[secondsSinceStartOfDay &gt;= SecondsPerDay 								ifTrue: 									[dayDelta := 1.									secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]								ifFalse: [dayDelta := 0]]].			gregorianYMD == nil 				ifTrue: 					[aTimeZone isInvariantToNominalTime 						ifTrue: 							[today								basicSetSecondsSinceStartOfDay: 0;								basicSetDaysSinceEpoch: gregorianDaysSinceEpoch + dayDelta]						ifFalse: 							[utcSecondsSinceStartOfDay := utcSecondsSinceStartOfDay - secondsSinceStartOfDay.							utcSecondsSinceStartOfDay &lt; 0 								ifTrue: 									[utcSecondsSinceStartOfDay := SecondsPerDay + utcSecondsSinceStartOfDay.									gregorianDaysSinceEpoch := gregorianDaysSinceEpoch - 1].							today								basicSetSecondsSinceStartOfDay: utcSecondsSinceStartOfDay;								basicSetDaysSinceEpoch: gregorianDaysSinceEpoch;								basicSetTimeZone: timeZone]]				ifFalse: 					[gregorianYMD 						addingDays: dayDelta						setYearAndCalendarDayInto: 							[:year :calendarDay | 							aTimeZone isInvariantToNominalTime 								ifTrue: 									[today										basicSetSecondsSinceStartOfDay: 0;										setYear: year											calendarDay: calendarDay											daysSinceEpoch: gregorianDaysSinceEpoch + dayDelta]								ifFalse: 									[utcSecondsSinceStartOfDay := utcSecondsSinceStartOfDay - secondsSinceStartOfDay.									utcSecondsSinceStartOfDay &lt; 0 										ifTrue: 											[utcSecondsSinceStartOfDay := SecondsPerDay + utcSecondsSinceStartOfDay.											gregorianDaysSinceEpoch := gregorianDaysSinceEpoch - 1].									today										basicSetSecondsSinceStartOfDay: utcSecondsSinceStartOfDay;										setYear: year											calendarDay: calendarDay											daysSinceEpoch: gregorianDaysSinceEpoch;										basicSetTimeZone: timeZone]]]]		ifFalse: 			[| utSecondsSinceCalendarEpoch daysSinceEpoch |			utSecondsSinceCalendarEpoch := utSecondsSinceSystemClockEpoch + secondsFromCalendarEpochUpToSystemClockEpoch.			utSecondsSinceCalendarEpoch := 				aTimeZone isInvariantToNominalTime 					ifTrue: [utSecondsSinceCalendarEpoch + offsetSecondsFromUT]					ifFalse: [utSecondsSinceCalendarEpoch].			secondsDiv128 := utSecondsSinceCalendarEpoch bitShift: -7. "Bit shifting is faster than LargeInteger math."			daysSinceEpoch := secondsDiv128 // 675. "128 * 675 = 86400"			aTimeZone isInvariantToNominalTime 				ifTrue: [secondsSinceStartOfDay := 0]				ifFalse:					[secondsMod128 := utSecondsSinceCalendarEpoch bitAnd: 127.					utcSecondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7). "seconds \\ 128 + (seconds // 128 \\ 675 * 128)"					secondsSinceStartOfDay := utcSecondsSinceStartOfDay + offsetSecondsFromUT.					offsetSecondsFromUT abs &gt;= SecondsPerDay 						ifTrue: [secondsSinceStartOfDay := secondsSinceStartOfDay \\ SecondsPerDay]						ifFalse: 							[secondsSinceStartOfDay &lt; 0 								ifTrue: [secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]								ifFalse: 									[secondsSinceStartOfDay &gt;= SecondsPerDay 										ifTrue: [secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]]].					secondsSinceStartOfDay := utcSecondsSinceStartOfDay - secondsSinceStartOfDay.					secondsSinceStartOfDay &lt; 0 						ifTrue: 							[secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay.							daysSinceEpoch := daysSinceEpoch - 1].					today basicSetTimeZone: timeZone].			today				basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;				basicSetDaysSinceEpoch: daysSinceEpoch].	^today</body><body package="Chronos-Calendars-Foundation" selector="mutableDateAndTimeFromUTSecondsSinceGregorianEpoch:nanoseconds:timeZone:">mutableDateAndTimeFromUTSecondsSinceGregorianEpoch: utSecondsSinceGregorianEpoch nanoseconds: nanosecondsSinceSecond timeZone: aTimeZone	"Answer a Timepoint (bound to the Gregorian Calendar) whose local time in the time zone defined by the receiver is &lt;utSecondsSinceGregorianEpoch&gt; seconds since the Gregorian epoch (relative to Universal Time) and &lt;nanosecondsSinceSecond&gt; nanoseconds since the start of the specified second."	"{AnsiStandardCalendarClock		mutableDateAndTimeFromUTSecondsSinceGregorianEpoch: 63240832637 		nanoseconds: 0		timeZone: (ChronosTimezone at: #'America/Los_Angeles') }"	"{AnsiStandardCalendarClock		mutableDateAndTimeFromUTSecondsSinceGregorianEpoch: 63240832637 		nanoseconds: 0		timeZone: (ChronosTimezone at: #'Australia/Adelaide')}"	| dateAndTime |	dateAndTime := 		(DateAndTimeFactory basicNew)			basicSetCalendar: Gregorian;			setNanosecondsSinceSecond: nanosecondsSinceSecond.	aTimeZone isInvariantToUT 		ifTrue: 			[dateAndTime				basicSetTimeZone: aTimeZone root;				basicSetSecondsSinceEpoch: utSecondsSinceGregorianEpoch]		ifFalse: 			[| secondsDiv128 secondsMod128 gregorianDaysSinceEpoch gregorianYMD utcSecondsSinceStartOfDay secondsSinceStartOfDay localTZ offsetSecondsFromUT dayDelta timeZone |			secondsDiv128 := utSecondsSinceGregorianEpoch bitShift: -7. "Bit shifting is faster than LargeInteger math."			gregorianDaysSinceEpoch := secondsDiv128 // 675. "128 * 675 = 86400"			secondsMod128 := utSecondsSinceGregorianEpoch bitAnd: 127.			utcSecondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7). "seconds \\ 128 + (seconds // 128 \\ 675 * 128)"			localTZ := aTimeZone asNonProxy.			localTZ isStatic 				ifTrue: 					[timeZone := localTZ binding.					offsetSecondsFromUT := timeZone offsetSecondsFromUT]				ifFalse: 					[gregorianYMD := Gregorian dateSpecFromDaysSinceEpoch: gregorianDaysSinceEpoch.					timeZone := 						localTZ 							bindingForUTYear: gregorianYMD year							dayOfYear: gregorianYMD dayOfYearOrdinal							secondsSinceStartOfDayFunction: [:offsetSeconds | utcSecondsSinceStartOfDay].					offsetSecondsFromUT := timeZone offsetSecondsFromUT].			secondsSinceStartOfDay := utcSecondsSinceStartOfDay + offsetSecondsFromUT.			offsetSecondsFromUT abs &gt;= SecondsPerDay 				ifTrue: 					[dayDelta := secondsSinceStartOfDay // SecondsPerDay.					secondsSinceStartOfDay := secondsSinceStartOfDay \\ SecondsPerDay]				ifFalse: 					[secondsSinceStartOfDay &lt; 0 						ifTrue: 							[dayDelta := -1.							secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]						ifFalse: 							[secondsSinceStartOfDay &gt;= SecondsPerDay 								ifTrue: 									[dayDelta := 1.									secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]								ifFalse: [dayDelta := 0]]].			gregorianDaysSinceEpoch := gregorianDaysSinceEpoch + dayDelta.			gregorianYMD == nil 				ifTrue: 					[dateAndTime						basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;						basicSetDaysSinceEpoch: gregorianDaysSinceEpoch]				ifFalse: 					[dateAndTime						basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay.					dayDelta = 0						ifTrue: [dateAndTime setYear: gregorianYMD year calendarDay: gregorianYMD calendarDay daysSinceEpoch: gregorianDaysSinceEpoch]						ifFalse: 							[gregorianYMD 								addingDays: dayDelta 								setYearAndCalendarDayInto: 									[:year :calendarDay | 										dateAndTime											setYear: year											calendarDay: calendarDay											daysSinceEpoch: gregorianDaysSinceEpoch]]]].	^dateAndTime</body><body package="Chronos-Calendars-Foundation" selector="mutableDateAndTimeFromUTSecondsSinceSystemClockEpoch:nanoseconds:timeZone:">mutableDateAndTimeFromUTSecondsSinceSystemClockEpoch: utSecondsSinceSystemClockEpoch nanoseconds: nanosecondsSinceSecond timeZone: aTimeZone	"Answer a Timepoint (bound to the specified &lt;calendar&gt;) whose local time in the time zone defined by the receiver, and as defined by the time-of-day clock of the specified &lt;calendar&gt;, is &lt;utSecondsSinceGregorianEpoch&gt; seconds since the Gregorian epoch (relative to Universal Time), &lt;utSecondsSinceCalendarEpoch&gt; seconds since the epoch of the specified &lt;calendar&gt; (relative to Universal Time), and &lt;nanosecondsSinceSecond&gt; nanoseconds since the start of the specified second."	"{(Gregorian clock		mutableDateAndTimeFromUTSecondsSinceSystemClockEpoch: SystemClock secondsNowSinceSystemClockEpoch 		nanoseconds: 0 		timeZone: ChronosTimezone nominal) canonicalize}"	"{Julian clock		mutableDateAndTimeFromUTSecondsSinceSystemClockEpoch: SystemClock secondsNowSinceSystemClockEpoch 		nanoseconds: 0 		timeZone: (ChronosTimezone at: #'America/Los_Angeles')}"	"{Calendar julian clock		mutableDateAndTimeFromUTSecondsSinceSystemClockEpoch: SystemClock secondsNowSinceSystemClockEpoch 		nanoseconds: 0 		timeZone: (ChronosTimezone at: #'Australia/Adelaide')}"	| utSecondsSinceGregorianEpoch utSecondsSinceCalendarEpoch dateAndTime |	utSecondsSinceGregorianEpoch := utSecondsSinceSystemClockEpoch + secondsFromGregorianEpochUpToSystemClockEpoch.	calendar isGregorian ifTrue: [^self mutableDateAndTimeFromUTSecondsSinceGregorianEpoch: utSecondsSinceGregorianEpoch nanoseconds: nanosecondsSinceSecond timeZone: aTimeZone].	utSecondsSinceCalendarEpoch := utSecondsSinceSystemClockEpoch + secondsFromCalendarEpochUpToSystemClockEpoch.	dateAndTime := 		DateAndTimeFactory basicNew			basicSetCalendar: calendar;			setNanosecondsSinceSecond: nanosecondsSinceSecond.	aTimeZone isInvariantToUT		ifTrue: 			[dateAndTime 				basicSetTimeZone: aTimeZone root;				basicSetSecondsSinceEpoch: utSecondsSinceCalendarEpoch]		ifFalse: 			[| secondsDiv128 secondsMod128 gregorianDaysSinceEpoch gregorianYMD utcSecondsSinceStartOfDay localTZ offsetSecondsFromUT timeZone |				secondsDiv128 := utSecondsSinceGregorianEpoch bitShift: -7. "Bit shifting is faster than LargeInteger math."			gregorianDaysSinceEpoch := secondsDiv128 // 675. "128 * 675 = 86400"			secondsMod128 := utSecondsSinceGregorianEpoch bitAnd: 127.			utcSecondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7). "seconds \\ 128 + (seconds // 128 \\ 675 * 128)"			localTZ := aTimeZone asNonProxy.			localTZ isStatic				ifTrue: 					[timeZone := localTZ binding.					offsetSecondsFromUT := timeZone offsetSecondsFromUT]				ifFalse:					[gregorianYMD := Gregorian dateSpecFromDaysSinceEpoch: gregorianDaysSinceEpoch.					timeZone := 						localTZ 							bindingForUTYear: gregorianYMD year							dayOfYear: gregorianYMD dayOfYearOrdinal							secondsSinceStartOfDayFunction: [:offsetSeconds | utcSecondsSinceStartOfDay].					offsetSecondsFromUT := timeZone offsetSecondsFromUT].			dateAndTime				basicSetSecondsSinceEpoch: utSecondsSinceCalendarEpoch + offsetSecondsFromUT].	^dateAndTime</body><body package="Chronos-Calendars-Foundation" selector="mutableDateFromUTSecondsSinceSystemClockEpoch:timeZone:">mutableDateFromUTSecondsSinceSystemClockEpoch: utSecondsSinceSystemClockEpoch timeZone: aTimezone 	"Answer a YearMonthDay (bound to the specified &lt;calendar&gt;) whose local time in the time zone defined by the receiver is the day that starts (as defined by the specified &lt;calendar&gt;) less than one day prior to the moment in time that is &lt;utSecondsSinceGregorianEpoch&gt; seconds since the Gregorian epoch (relative to Universal Time) and &lt;utSecondsSinceCalendarEpoch&gt; seconds since the epoch of the specified &lt;calendar&gt; (relative to Universal Time)."	"{HebrewCalendar clock		mutableDateFromUTSecondsSinceSystemClockEpoch: SystemClock secondsNowSinceSystemClockEpoch		timeZone: ChronosTimezone default}"	"{Gregorian clock		mutableDateFromUTSecondsSinceSystemClockEpoch: SystemClock secondsNowSinceSystemClockEpoch 		timeZone: ChronosTimezone default}"	| utSecondsSinceGregorianEpoch secondsDiv128 secondsMod128 timeZone gregorianDaysSinceEpoch gregorianYMD secondsSinceStartOfDay offsetSecondsFromUT dayDelta |	utSecondsSinceGregorianEpoch := utSecondsSinceSystemClockEpoch + secondsFromGregorianEpochUpToSystemClockEpoch.	secondsDiv128 := utSecondsSinceGregorianEpoch bitShift: -7.	"Bit shifting is faster than LargeInteger math."	gregorianDaysSinceEpoch := secondsDiv128 // 675.	"128 * 675 = 86400"	secondsMod128 := utSecondsSinceGregorianEpoch bitAnd: 127.	secondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7).	"seconds \\ 128 + (seconds // 128 \\ 675 * 128)"	aTimezone isStatic 		ifTrue: [offsetSecondsFromUT := aTimezone offsetSecondsFromUT]		ifFalse: 			[gregorianYMD := 				Gregorian 					dateSpecFromDaysSinceEpoch: gregorianDaysSinceEpoch.			timeZone := 				aTimezone 					bindingForUTYear: gregorianYMD year					dayOfYear: gregorianYMD dayOfYearOrdinal					secondsSinceStartOfDayFunction: [:offsetSeconds | secondsSinceStartOfDay].			offsetSecondsFromUT := timeZone offsetSecondsFromUT].	^calendar isGregorian 		ifTrue: 			[secondsSinceStartOfDay := secondsSinceStartOfDay + offsetSecondsFromUT.			offsetSecondsFromUT abs &gt;= SecondsPerDay 				ifTrue: [dayDelta := secondsSinceStartOfDay // SecondsPerDay]				ifFalse: 					[secondsSinceStartOfDay &lt; 0 						ifTrue: [dayDelta := -1]						ifFalse: 							[secondsSinceStartOfDay &gt;= SecondsPerDay 								ifTrue: [dayDelta := 1]								ifFalse: [dayDelta := 0]]].			gregorianYMD == nil 				ifTrue: 					[(DateFactory basicNew)						basicSetCalendar: calendar;						basicSetDaysSinceEpoch: gregorianDaysSinceEpoch + dayDelta]				ifFalse: 					[| date |					date := DateFactory basicNew.					date basicSetCalendar: calendar.					gregorianYMD addingDays: dayDelta setYearAndCalendarDayInto: date]]		ifFalse: 			[(DateFactory basicNew)				basicSetCalendar: calendar;				basicSetSecondsSinceEpoch: utSecondsSinceSystemClockEpoch + secondsFromCalendarEpochUpToSystemClockEpoch + offsetSecondsFromUT]</body><body package="Chronos-Calendars-Foundation" selector="mutableTimeOfDayFromUTSecondsSinceGregorianEpoch:nanoseconds:timeZone:">mutableTimeOfDayFromUTSecondsSinceGregorianEpoch: utSecondsSinceGregorianEpoch nanoseconds: nanosecondsSinceSecond timeZone: aTimezone	"Answer a TimeOfDay whose local time in the time zone defined by the receiver, and as defined by the time-of-day clock of the specified &lt;calendar&gt;, is &lt;utSecondsSinceGregorianEpoch&gt; seconds since the Gregorian epoch (relative to Universal Time), &lt;utSecondsSinceCalendarEpoch&gt; seconds since the epoch of the specified &lt;calendar&gt; (relative to Universal Time), and &lt;nanosecondsSinceSecond&gt; nanoseconds since the start of the specified second."	"{Calendar gregorian clock		mutableTimeOfDayFromUTSecondsSinceGregorianEpoch: Calendar gregorian clock now utSecondsSinceEpoch 		nanoseconds: 0 timeZone: ChronosTimezone default}" 	"{Calendar gregorian clock		mutableTimeOfDayFromUTSecondsSinceGregorianEpoch: Calendar gregorian clock utNow secondsSinceEpoch 		nanoseconds: 0 timeZone: (ChronosTimezone at: #'America/Los_Angeles')}"	"{Calendar gregorian clock		mutableTimeOfDayFromUTSecondsSinceGregorianEpoch: Calendar gregorian clock utNow secondsSinceEpoch  		nanoseconds: 0 timeZone: (ChronosTimezone at: #'Australia/Adelaide')}"	"{EthiopicCalendar clock		mutableTimeOfDayFromUTSecondsSinceGregorianEpoch: Calendar gregorian clock now utSecondsSinceEpoch 		nanoseconds: 0 timeZone: ChronosTimezone default}" 	"The Ethiopian clock time T00:00:00 corresponds to ISO 8601 T06:00:00 (6 am) Gregorian Calendar. It's a cultural difference in both the zero-point for labelling the hours of the day and in the time-of-day at which one day ends and the next begins. It is not a difference of timezone offset."	| timeOfDay secondsDiv128 secondsMod128 gregorianDaysSinceEpoch utcSecondsSinceStartOfDay offsetSecondsFromUT gregorianYMD timeZone secondsSinceStartOfDay |	timeOfDay := 		(TimeOfDayFactory basicNew)			setNanosecondsSinceSecond: nanosecondsSinceSecond.	secondsDiv128 := utSecondsSinceGregorianEpoch bitShift: -7. "Bit shifting is faster than LargeInteger math."	gregorianDaysSinceEpoch := secondsDiv128 // 675. "128 * 675 = 86400"	secondsMod128 := utSecondsSinceGregorianEpoch bitAnd: 127.	utcSecondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7). "seconds \\ 128 + (seconds // 128 \\ 675 * 128)"	aTimezone isStatic 		ifTrue: [offsetSecondsFromUT := aTimezone offsetSecondsFromUT]		ifFalse: 			[gregorianYMD := Gregorian dateSpecFromDaysSinceEpoch: gregorianDaysSinceEpoch.			timeZone := 				aTimezone asNonProxy					bindingForUTYear: gregorianYMD year					dayOfYear: gregorianYMD dayOfYearOrdinal					secondsSinceStartOfDayFunction: [:offsetSeconds | utcSecondsSinceStartOfDay].			offsetSecondsFromUT := timeZone offsetSecondsFromUT].	secondsSinceStartOfDay := utcSecondsSinceStartOfDay + offsetSecondsFromUT.	calendar timeOfDayClockStartsAtMidnight		ifFalse: [secondsSinceStartOfDay := calendar secondsSinceStartOfDayFromSecondsSinceMidnight:  secondsSinceStartOfDay].	offsetSecondsFromUT abs &gt;= SecondsPerDay 		ifTrue: [secondsSinceStartOfDay := secondsSinceStartOfDay \\ SecondsPerDay]		ifFalse: 			[secondsSinceStartOfDay &lt; 0 				ifTrue: [secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]				ifFalse: 					[secondsSinceStartOfDay &gt;= SecondsPerDay 						ifTrue: 							[secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]]].	^timeOfDay 		setSecondsSinceStartOfDay: secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>printing</category><body package="Chronos-Calendars-Foundation" selector="printOn:">printOn: stream	super printOn: stream.	stream		nextPut: $(;		nextPutAll: 'tick resolution = ';		nextPutAll: systemClock tickResolutionName;		nextPutAll: ' | ';		nextPutAll: 'Calendar = ';		nextPutAll: calendar name;		nextPutAll: ' | ';		nextPutAll: 'Clock Epoch = ';		nextPutAll: (self epoch printStringUsing: ChronosPrintPolicy verbose).	calendar isGregorian		ifFalse: 			[stream				nextPutAll: ' / ';				nextPutAll: (self gregorianEpoch printStringUsing: ChronosPrintPolicy verbose)].	stream nextPut: $)</body></methods><methods><class-id>Chronos.CalendarClock</class-id> <category>calendar binding</category><body package="Chronos-Calendars-Foundation" selector="bindToCalendar">bindToCalendar	"Set the instance variables &lt;secondsFromCalendarEpochUpToSystemClockEpoch&gt; and &lt;ticksFromCalendarEpochUpToSystemClockEpoch&gt; to values valid for the receiver's calendar, computed de novo.	POSTCONDITION: The instance variables &lt;secondsFromCalendarEpochUpToSystemClockEpoch&gt; and &lt;ticksFromCalendarEpochUpToSystemClockEpoch&gt; should contain the number of seconds and ticks (respectively) from the Epoch date/time of the receiver's calendar (i.e., Year 1, Month 1, Day1 in a calendar that uses ordinal numbering) up to the Epoch date/time of the internal system clock encapsulated by the receiver (i.e., where clock ticks = 0)."	"NOTE: The method #chronosDateAndTimeFromNativeCalendricalCoordinate: will not work correctly unless and until the instance variable &lt;secondsFromCalendarEpochUpToSystemClockEpoch&gt; has been set to a valid value--consequently, that method cannot be used to compute the values for which this method is responsible."	calendar == nil ifTrue: [^nil].	secondsFromGregorianEpochUpToSystemClockEpoch := systemClock secondsFromGregorianEpochUpToSystemClockEpoch.	secondsFromCalendarEpochUpToSystemClockEpoch := 			calendar isGregorian 				ifTrue: [secondsFromGregorianEpochUpToSystemClockEpoch]				ifFalse: 					[calendar 						secondsSinceEpochFromForeignSecondsSinceEpoch: secondsFromGregorianEpochUpToSystemClockEpoch						convertingFrom: Calendar gregorian].</body></methods><methods><class-id>Chronos.CalendarClock class</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="ansiStandard">ansiStandard	"Answer the CalendarClock bound to the ANSI-Smalltalk Standard Calendar (Gregorian.)"	^AnsiStandardCalendarClock</body><body package="Chronos-Calendars-Foundation" selector="default">default	"Answer the default CalendarClock."	^AnsiStandardCalendarClock</body></methods><methods><class-id>Chronos.CalendarClock class</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^(Calendar referencedBy: (literalArray at: 2)) clock</body><body package="Chronos-Calendars-Foundation" selector="implementationClassForSystemClock:">implementationClassForSystemClock: aSystemClock	^(aSystemClock isRelativeToUT 		ifTrue: [UTCalendarClock]		ifFalse: [LocalTimeCalendarClock])</body></methods><methods><class-id>Chronos.CalendarClock class</class-id> <category>instance creation</category><body package="Chronos-Calendars-Foundation" selector="systemClock:">systemClock: aSystemClock	"Answer a new (mutable) instance of the receiver that encapsulates the given &lt;systemClock&gt; (which must be an instance of a concrete subclass of ChronosSystemClock.)"	^(self implementationClassForSystemClock: aSystemClock) new		setSystemClock: aSystemClock</body></methods><methods><class-id>Chronos.CalendarClock class</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="invalidateCalendarBindings">invalidateCalendarBindings	"CalendarClock invalidateCalendarBindings"	self allInstancesDo: [:calendrical | calendrical invalidateCalendar].	self subclasses do: [:class | class invalidateCalendarBindings]</body></methods><methods><class-id>Chronos.LocalTimeCalendarClock</class-id> <category>API-Current Dates &amp; Times</category><body package="Chronos-Calendars-Foundation" selector="utNow">utNow	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the UT timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock utNow}"	"{Calendar julian clock utNow}"	^self nowIn: ChronosTimezone universal includeNanoseconds: true</body><body package="Chronos-Calendars-Foundation" selector="utTimeOfDayNow">utTimeOfDayNow	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the UT timezone."	"{Calendar gregorian clock utTimeOfDayNow}"	"{Calendar julian clock utTimeOfDayNow}"	^self timeOfDayNowIn: ChronosTimezone universal includeNanoseconds: true</body><body package="Chronos-Calendars-Foundation" selector="utToday">utToday	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the UT timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock utToday}"	"{Calendar julian clock utToday}"	^self basicTodayIn: ChronosTimezone universal</body></methods><methods><class-id>Chronos.LocalTimeCalendarClock</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicTodayIn:">basicTodayIn: aTimezone	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the timezone implemented by &lt;aTimezone&gt; (which must be an instance of a concrete subclass of ChronosTimezone,) and with invariant-to-UT semantics." 	| ticksNow now |	ticksNow := systemClock ticksNowSinceSystemClockEpoch.	now :=		self class dateAndTimeFactory basicNew			basicSetCalendar: calendar;			basicSetTimeZone: ChronosTimezone system;			setNanosecondsSinceSecond: 0;			basicSetSecondsSinceEpoch: 				(systemClock secondsFromTicks: ticksNow) + secondsFromCalendarEpochUpToSystemClockEpoch.	^now 		canonicalizeFromLocalTime;		convertToTimeZone: aTimezone;		addSeconds: now secondsSinceStartOfDay negated;		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="mutableDateTodayIn:">mutableDateTodayIn: aTimezone	"Answer a date value representing today's date, in the receiver's calendar, and relative to the timezone implemented by &lt;aTimezone&gt; (which must be an instance of a concrete subclass of ChronosTimezone.)"	^DateFactory basicNew		initializeFrom: (self nowIn: aTimezone includeNanoseconds: false)</body><body package="Chronos-Calendars-Foundation" selector="nowIn:includeNanoseconds:">nowIn: aTimeZone includeNanoseconds: includeNanoseconds 	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the  timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;, and with invariant-to-UT semantics. If &lt;includeNanoseconds&gt; is true, include the number of nanoseconds-since-the-second in the answered DateAndTime; otherwise, have the answered DateAndTime specify zero nanoseconds-since-the-second (so that the current date and time is reported only to the latest second.)"	| ticksNow now nanosecondsSinceSecond |	ticksNow := systemClock ticksNowSinceSystemClockEpoch.	nanosecondsSinceSecond := includeNanoseconds 				ifTrue: [systemClock nanosecondsSinceSecondFromTicks: ticksNow]				ifFalse: [0].	^(aTimeZone isInvariantToNominalTime and: [aTimeZone asNonProxy isSystem])		ifTrue:			[self class dateAndTimeFactory 				nominalSecondsSinceEpoch: 					(systemClock secondsFromTicks: ticksNow) 					+ secondsFromCalendarEpochUpToSystemClockEpoch				nanoseconds: nanosecondsSinceSecond				calendar: calendar]		ifFalse:			[now :=				DateAndTimeFactory basicNew					basicSetCalendar: calendar;					basicSetTimeZone: ChronosTimezone system;					setNanosecondsSinceSecond: nanosecondsSinceSecond;					basicSetSecondsSinceEpoch: 						(systemClock secondsFromTicks: ticksNow) + secondsFromCalendarEpochUpToSystemClockEpoch.			now 				canonicalizeFromLocalTime;				convertToTimeZone: aTimeZone;				beImmutable]</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayNowIn:includeNanoseconds:">timeOfDayNowIn: aTimezone includeNanoseconds: includeNanoseconds 	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;. If &lt;includeNanoseconds&gt; is true, include the number of nanoseconds-since-the-second in the answered time-of-day value; otherwise, have the answered time-of-day value specify zero nanoseconds-since-the-second (so that the current date and time is reported only to the latest second.)"	^(self nowIn: aTimezone includeNanoseconds: includeNanoseconds) timeOfDay</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>INTRA-period-enumerating</category><body package="Chronos-DateTimeInterval" selector="every:collect:">every: period collect: block1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the one whose starting point-in-time is the same as that of the receiver, with each having &lt;period&gt; (a Durational instance) as its temporal extent, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, and ending with the last such Timeperiod whose starting point-in-time is included by the temporal interval represented by the receiver, evaluate &lt;block1&gt; with each such Timeperiod in the sequence so defined as the argument, add the resulting value to a SequenceableCollection, and (when all the Timeperiods have been added to the SequenceableCollection as previously specified) answer the SequenceableCollection."	"{Timeperiod currentYear every: (CalendarDuration months: 1) collect: [:interval | interval last]}"	| list |	list := SequenceFactory new.	self 		every: period 		do: [:timePeriod | list add: (block1 value: timePeriod)].	^list</body><body package="Chronos-DateTimeInterval" selector="every:contains:">every: period contains: block1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the one whose starting point-in-time is the same as that of the receiver, with each having &lt;period&gt; (a Durational instance) as its temporal extent, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, and ending with the last such Timeperiod whose starting point-in-time is included by the temporal interval represented by the receiver, evaluate &lt;block1&gt; with each such Timeperiod in the sequence so defined as the argument, and if the result is the value true, then immediately return with the value true as the answered value. Otherwise, if none of the Timeperiods in the sequence (as defined) resulted in the value true when &lt;block1&gt; wa evaluated (as specified,) then answer false."	"Is the last day of any month in the current year a leap day?	{Timeperiod currentYear 		every: (CalendarDuration months: 1) 		contains: [:interval | interval last calendarDay occursEveryYear not]}"	"Do any months in the current year have both their first and last days occurring on the weekend?	{Timeperiod currentYear		every: (CalendarDuration months: 1) 		contains: [:interval | interval first isWeekendDay and: [interval last isWeekendDay]]}"	self 		every: period		do: [:timePeriod | (block1 value: timePeriod) ifTrue: [^true]].	^false</body><body package="Chronos-DateTimeInterval" selector="every:detect:ifNone:">every: period detect: block1 ifNone: unsatisfiedAction 	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the one whose starting point-in-time is the same as that of the receiver, with each having &lt;period&gt; (a Durational instance) as its temporal extent, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, and ending with the last such Timeperiod whose starting point-in-time is included by the temporal interval represented by the receiver, evaluate &lt;block1&gt; with each such Timeperiod in the sequence so defined as the argument, and if the result is the value true, then immediately return with that Timeperiod as the answerd value. Otherwise, if none of the Timeperiods in the sequence (as defined) resulted in the value true when &lt;block1&gt; wa evaluated (as specified,) then answer the result of evaluating &lt;unsatisfiedAction&gt;."	"Find the first month in the current year that has its first day occurring on the weekend (if any):	{Timeperiod currentYear		every: (CalendarDuration months: 1) 		detect: [:interval | interval first isWeekendDay]		ifNone: ['No such months this year']}"	self 		every: period		do: [:timePeriod | (block1 value: timePeriod) ifTrue: [^timePeriod]].	^unsatisfiedAction value</body><body package="Chronos-DateTimeInterval" selector="every:do:">every: period do: block1 	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the one whose starting point-in-time is the same as that of the receiver, with each having &lt;period&gt; (a Durational instance) as its temporal extent, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, and ending with the last such Timeperiod whose starting point-in-time is included by the temporal interval represented by the receiver, evaluate &lt;block1&gt; with each such Timeperiod in the sequence (as specified) as the argument."	"{Timeperiod today every: (Duration hours: 7) do: [:interval | Transcript cr; show: interval printString]}"	| start limit |	start := self start.	limit := start + (self duration - period).	start through: limit every: period do: [:tp | block1 value: (self class timeperiodFactory from: tp duration: period)].</body><body package="Chronos-DateTimeInterval" selector="every:inject:into:">every: period inject: initialValue into: mapper 	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the one whose starting point-in-time is the same as that of the receiver, with each having &lt;period&gt; (a Durational instance) as its temporal extent, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, and ending with the last such Timeperiod whose starting point-in-time is included by the temporal interval represented by the receiver, evaluate &lt;mapper&gt; with the following arugments (labelled `a` and `b,` with `a` being the first and `b` the second argument): a) the given &lt;initialValue&gt; in the case of the first evaluation, but otherwise the value resulting from the previous evaluation of &lt;mapper&gt;, and b) each successive Timeperiod in the sequence (as specified.) Answer the value resulting from the last evaluation of &lt;mapper&gt;--unless there were no such evaluations, in which case answer &lt;initialValue&gt;. "	"EXAMPLE: Count the number of weekend days occurring this year:		{Timeperiod currentYear			every: (CalendarDuration days: 1)			inject: 0			into: [:count :dayInterval | dayInterval start isWeekendDay ifTrue: [count + 1] ifFalse: [count]]}"	"EXAMPLE: Count the number of US Federal Holidays occurring in the next year (starting with today):		{(Timeperiod yearStartingAt: YearMonthDay today)			every: (CalendarDuration days: 1)			inject: 0			into: [:count :dayInterval | dayInterval start isUSFederalHoliday ifTrue: [count + 1] ifFalse: [count]]}"	"EXAMPLE: Count the number of leap years in the next 400 years:		{(Timeperiod from: YearMonthDay today duration: (CalendarDuration years: 400))			every: (CalendarDuration years: 1)			inject: 0			into: [:count :yearInterval | yearInterval start isLeapYear ifTrue: [count + 1] ifFalse: [count]]}"	| value |	value := initialValue.	self 		every: period		do: [:timePeriod | value := mapper value: value value: timePeriod].	^value</body><body package="Chronos-DateTimeInterval" selector="every:select:">every: period select: block1 	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the one whose starting point-in-time is the same as that of the receiver, with each having &lt;period&gt; (a Durational instance) as its temporal extent, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, and ending with the last such Timeperiod whose starting point-in-time is included by the temporal interval represented by the receiver, evaluate &lt;block1&gt; with each such Timeperiod in the sequence so defined as the argument, and if the result is the value true, then add the that Timeperiod to a SequenceableCollection, and (when all the Timeperiods have been evaluated by &lt;block1&gt; as previously specified) answer the SequenceableCollection."	"{Timeperiod currentYear every: (CalendarDuration months: 1) select: [:interval | interval start isWeekendDay]}"	"Compute all the years from 1950 to 2049 where both the first and the last days of the year are weekend days:	{(Timeperiod 		from: (YearMonthDay year: 1950 day: 1)		duration: (CalendarDuration years: 100))			every: (CalendarDuration years: 1) 			select: [:interval | interval first isWeekendDay and: [interval last isWeekendDay]]}"	| list |	list := SequenceFactory new.	self 		every: period		do: [:timePeriod | (block1 value: timePeriod) ifTrue: [list add: timePeriod]].	^list</body><body package="Chronos-DateTimeInterval" selector="every:select:thenCollect:">every: period select: selector thenCollect: mapper 	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the one whose starting point-in-time is the same as that of the receiver, with each having &lt;period&gt; (a Durational instance) as its temporal extent, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, and ending with the last such Timeperiod whose starting point-in-time is included by the temporal interval represented by the receiver, evaluate &lt;selector&gt; with each such Timeperiod in the sequence so defined as the argument, and if the result is the value true, then add the result of evaluating &lt;mapper&gt; with that Timeperiod as the argument to a SequenceableCollection, and (when all the Timeperiods have been evaluated by &lt;selector&gt; as previously specified) answer the SequenceableCollection."	"{Timeperiod currentYear every: (CalendarDuration months: 1) select: [:interval | interval start isWeekendDay] thenCollect: [:interval | interval start monthName]}"	"Compute all the years from 1950 to 2049 where both the first and the last days of the year are weekend days:	{(Timeperiod 		from: (YearMonthDay year: 1950 day: 1)		duration: (CalendarDuration years: 100))			every: (CalendarDuration years: 1) 			select: [:interval | interval first isWeekendDay and: [interval last isWeekendDay]]			thenCollect: [:interval | interval start year]}"	| list |	list := SequenceFactory new.	self 		every: period		do: [:timePeriod | (selector value: timePeriod) ifTrue: [list add: (mapper value: timePeriod)]].	^list</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>INTER-period-enumerating</category><body package="Chronos-DateTimeInterval" selector="through:every:daysDo:">through: end every: count daysDo: block1 	"Closed interval"	"(YearMonthDay daysSinceEpoch: 732000) through: (YearMonthDay daysSinceEpoch: 732030) every: 1 daysDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: 			(count = 1 				ifTrue: [CalendarDayDuration]				ifFalse: [CalendarDuration days: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="through:every:do:">through: end every: durationStep do: block1 	"Closed interval"	"{Transcript cr. YearMonthDay today yesterday through: YearMonthDay today tomorrow every: (CalendarDuration days: 1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today tomorrow through: YearMonthDay today yesterday every: (CalendarDuration days: -1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today through: YearMonthDay today every: (CalendarDuration days: 1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today through: YearMonthDay today every: (CalendarDuration days: -1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	| induction |	durationStep isZero ifTrue: [^self].	induction := self + durationStep.	end &gt;= self 		ifTrue: 			[induction &lt; self ifTrue: [^induction].			block1 value: self.			[induction &lt;= end] whileTrue: 					[block1 value: induction.					induction := induction + durationStep]]		ifFalse: 			[induction &gt; self ifTrue: [^induction].			block1 value: self.			[induction &gt;= end] whileTrue: 					[block1 value: induction.					induction := induction + durationStep]].	^induction</body><body package="Chronos-DateTimeInterval" selector="through:every:hoursDo:">through: end every: count hoursDo: block1 	"Closed interval"	"(DateAndTime daysSinceEpoch: 733000) through: (DateAndTime daysSinceEpoch: 733000.9) every: 1 hoursDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: 			(count = 1 				ifTrue: [HourDuration]				ifFalse: [self class civilDurationFactory  hours: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="through:every:minutesDo:">through: end every: count minutesDo: block1 	"Closed interval"	"(DateAndTime daysSinceEpoch: 733000) through: (DateAndTime daysSinceEpoch: 733000.03d) every: 1 minutesDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: 			(count = 1 				ifTrue: [MinuteDuration]				ifFalse: [self class civilDurationFactory  minutes: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="through:every:monthsDo:">through: end every: count monthsDo: block1 	"Closed interval"	"(YearMonthDay daysSinceEpoch: 732000) through: (YearMonthDay daysSinceEpoch: 732300) every: 1 monthsDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: 			(count = 1 				ifTrue: [MonthDuration]				ifFalse: [self class calendarDurationFactory  months: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="through:every:quartersDo:">through: end every: count quartersDo: block1 	"Closed interval"	"(YearMonthDay daysSinceEpoch: 732000) through: (YearMonthDay daysSinceEpoch: 733000) every: 1 quartersDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: (self class calendarDurationFactory  quarters: count)		do: block1</body><body package="Chronos-DateTimeInterval" selector="through:every:secondsDo:">through: end every: count secondsDo: block1 	"Closed interval"	"(DateAndTime daysSinceEpoch: 733000) through: (DateAndTime daysSinceEpoch: 733000.001d) every: 1 secondsDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: 			(count = 1 				ifTrue: [SecondDuration]				ifFalse: [self class durationFactory  seconds: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="through:every:weeksDo:">through: end every: count weeksDo: block1 	"Closed interval"	"(YearMonthDay daysSinceEpoch: 732000) through: (YearMonthDay daysSinceEpoch: 732030) every: 1 weeksDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: 			(count = 1 				ifTrue: [WeekDuration]				ifFalse: [self class calendarDurationFactory  weeks: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="through:every:yearsDo:">through: end every: count yearsDo: block1 	"Closed interval"	"(YearMonthDay daysSinceEpoch: 730000) through: (YearMonthDay daysSinceEpoch: 735000) every: 1 yearsDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: 			(count = 1 				ifTrue: [YearDuration]				ifFalse: [self class calendarDurationFactory  years: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:daysDo:">to: end every: count daysDo: block1 	"Left closed, right open interval"	"(YearMonthDay daysSinceEpoch: 732000) to: (YearMonthDay daysSinceEpoch: 732030) every: 1 daysDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		to: end		every: 			(count = 1 				ifTrue: [CalendarDayDuration]				ifFalse: [CalendarDuration days: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:do:">to: end every: durationStep do: block1 	"Left closed, right open interval"	"{Transcript cr. YearMonthDay today yesterday to: YearMonthDay today tomorrow every: (CalendarDuration days: 1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today  tomorrow to: YearMonthDay today yesterday every: (CalendarDuration days: -1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today  to: YearMonthDay today every: (CalendarDuration days: 1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today  to: YearMonthDay today tomorrow every: (CalendarDuration days: 1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today tomorrow  to: YearMonthDay today every: (CalendarDuration days: -1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	"{Transcript cr. YearMonthDay today  to: YearMonthDay today every: (CalendarDuration days: 1) do: [:eachDay | Transcript cr; show: eachDay printString]}"	| induction |	durationStep isZero ifTrue: [^self].	end &gt; self 		ifTrue: 			[induction := self + durationStep.			induction &lt; self ifTrue: [^induction].			block1 value: self.			[induction &lt; end] whileTrue: 					[block1 value: induction.					induction := induction + durationStep]]		ifFalse: 			[end &lt; self				ifTrue: 					[induction := self + durationStep.					induction &gt; self ifTrue: [^induction].					block1 value: self.					[induction &gt; end] whileTrue: 							[block1 value: induction.							induction := induction + durationStep]]				ifFalse: [induction := self]].	^induction</body><body package="Chronos-DateTimeInterval" selector="to:every:hoursDo:">to: end every: count hoursDo: block1 	"Left closed, right open interval"	"(DateAndTime daysSinceEpoch: 733000) to: (DateAndTime daysSinceEpoch: 733000.9) every: 1 hoursDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		to: end		every: 			(count = 1 				ifTrue: [HourDuration]				ifFalse: [self class durationFactory  hours: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:minutesDo:">to: end every: count minutesDo: block1 	"Left closed, right open interval"	"(DateAndTime daysSinceEpoch: 733000) to: (DateAndTime daysSinceEpoch: 733000.03d) every: 1 minutesDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		to: end		every: 			(count = 1 				ifTrue: [MinuteDuration]				ifFalse: [self class durationFactory  minutes: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:monthsDo:">to: end every: count monthsDo: block1 	"Left closed, right open interval"	"(YearMonthDay daysSinceEpoch: 732000) to: (YearMonthDay daysSinceEpoch: 732300) every: 1 monthsDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		to: end		every: 			(count = 1 				ifTrue: [MonthDuration]				ifFalse: [self class calendarDurationFactory  months: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:quartersDo:">to: end every: count quartersDo: block1 	"Left closed, right open interval"	"(YearMonthDay daysSinceEpoch: 732000) through: (YearMonthDay daysSinceEpoch: 733000) every: 1 quartersDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		through: end		every: (self class calendarDurationFactory  quarters: count)		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:secondsDo:">to: end every: count secondsDo: block1 	"Left closed, right open interval"	"(DateAndTime daysSinceEpoch: 733000) to: (DateAndTime daysSinceEpoch: 733000.001d) every: 1 secondsDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		to: end		every: 			(count = 1 				ifTrue: [SecondDuration]				ifFalse: [self class durationFactory  seconds: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:weeksDo:">to: end every: count weeksDo: block1 	"Left closed, right open interval"	"(YearMonthDay daysSinceEpoch: 732000) to: (YearMonthDay daysSinceEpoch: 732030) every: 1 weeksDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		to: end		every: 			(count = 1 				ifTrue: [WeekDuration]				ifFalse: [self class calendarDurationFactory  weeks: count])		do: block1</body><body package="Chronos-DateTimeInterval" selector="to:every:yearsDo:">to: end every: count yearsDo: block1 	"Left closed, right open interval"	"(YearMonthDay daysSinceEpoch: 730000) to: (YearMonthDay daysSinceEpoch: 735000) every: 1 yearsDo: [:date | Transcript cr; show: date printString]"	count = 0 ifTrue: [^self].	^self 		to: end		every: 			(count = 1 				ifTrue: [YearDuration]				ifFalse: [self class calendarDurationFactory  years: count])		do: block1</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="addedToCalendarDuration:">addedToCalendarDuration: aDuration	^aDuration addedToTemporalInterval: self</body><body package="Chronos-DateTimeInterval" selector="addedToCivilDuration:">addedToCivilDuration: aDuration	^aDuration addedToTemporalInterval: self</body><body package="Chronos-DateTimeInterval" selector="addedToDuration:">addedToDuration: aDuration 	^aDuration addedToTemporalInterval: self</body><body package="Chronos-DateTimeInterval" selector="addedToInfiniteDuration:">addedToInfiniteDuration: anInfiniteDuration	^InfiniteTimepoint polarity: anInfiniteDuration positive</body><body package="Chronos-DateTimeInterval" selector="addedToTemporalInterval:">addedToTemporalInterval: aTemporalInterval	| thisStart thisNextStart thatStart thatNextStart |	thisStart := self start.	thisNextStart := self limit.	thatStart := aTemporalInterval start.	thatNextStart := aTemporalInterval limit.	^thisNextStart &gt;= thisStart 		ifTrue: 			[thatNextStart &gt;= thatStart 				ifTrue: [(thisStart min: thatStart) to: (thisNextStart max: thatNextStart)]				ifFalse: 					[(thisStart min: thatNextStart + thatNextStart resolutionQuantum) 						to: (thisNextStart max: thatStart + thatStart resolutionQuantum)]]		ifFalse: 			[thatNextStart &gt;= thatStart 				ifTrue: 					[(thisNextStart + thisNextStart resolutionQuantum min: thatStart) 						to: (thisStart + thisStart resolutionQuantum max: thatNextStart)]				ifFalse: [(thisStart max: thatStart) to: (thisNextStart min: thatNextStart)]]</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCalendarDuration:">subtractedFromCalendarDuration: aDuration 	^aDuration 		subtractingHours: self hour		minutes: self minute		seconds: self second		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aDuration	^aDuration		subtractingHours: self hour		minutes: self minute		seconds: self second		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="subtractedFromDuration:">subtractedFromDuration: aDuration	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="subtractedFromInfiniteDuration:">subtractedFromInfiniteDuration: anInfiniteDuration	^anInfiniteDuration</body><body package="Chronos-DateTimeInterval" selector="subtractedFromInfiniteTimepoint:">subtractedFromInfiniteTimepoint: anInfiniteTimepoint	^InfiniteDuration polarity: anInfiniteTimepoint isInfiniteFuture</body><body package="Chronos-DateTimeInterval" selector="subtractedFromTemporalInterval:">subtractedFromTemporalInterval: aTemporalInterval	^self class durationFactory 		seconds: (aTemporalInterval basicSecondsSince: self)		nanoseconds: aTemporalInterval nanosecondsSinceSecond - self nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>arithmetic</category><body package="Chronos-DateTimeInterval" selector="*">* aTemporalInterval 	"Answer the intersection of the receiver with &lt;aTemporalInterval&gt;.  Answer nil if there is no intersection."	"{(Timeperiod dayStartingAt: (Timepoint todayIn: 'Asia/Calcutta')) * (Timeperiod dayStartingAt: (Timepoint todayIn: 'America/Los_Angeles'))}"	"{Timeperiod currentMonth * (Timeperiod monthStartingAt: YearMonthDay today)}"	"{Timeperiod currentMonth * (Timeperiod monthStartingAt: (YearMonthDay today addingMonths: 1))}"	"{Timeperiod currentMonth * (Timeperiod from: YearMonthDay today duration: (CivilDuration months: -1))}"	"{Timeperiod currentMonth * (Timeperiod from: (YearMonthDay today subtractingMonths: 1) duration: (CivilDuration months: -1))}"	"{(Timeperiod from: YearMonthDay today duration: (CivilDuration months: -1)) * Timeperiod currentMonth}"	"{(Timeperiod from: (YearMonthDay today subtractingMonths: 1) duration: (CivilDuration months: -1)) * Timeperiod currentMonth}"	"{Timeperiod currentMonth * (Timeperiod monthStartingAt: (YearMonthDay today subtractingMonths: 1))}"	"{Timeperiod currentMonth * (YearMonthDay atLastDayOfMonth @ (TimeOfDay hour: 12 minute: 0 second: 0))}"	| thisStart thisLimit thatStart thatLimit iStart iLimit |	(self duration isZero or: [aTemporalInterval duration isZero]) ifTrue: [^nil].	thisStart := self start.	thisLimit := self limit.	thatStart := aTemporalInterval start.	thatLimit := aTemporalInterval limit.	thisLimit &gt; thisStart 		ifTrue: 			[thatLimit &gt; thatStart 				ifTrue: 					[iStart := thisStart max: thatStart.					iLimit := thisLimit min: thatLimit]				ifFalse: 					[iStart := thisStart max: thatLimit + thatLimit resolutionQuantum.					iLimit := thisLimit min: thatStart + thatStart resolutionQuantum]]		ifFalse: 			[thatLimit &gt; thatStart 				ifTrue: 					[iStart := thisLimit + thisLimit resolutionQuantum max: thatStart.					iLimit := thisStart + thisStart resolutionQuantum min: thatLimit]				ifFalse: 					[iStart := thisStart min: thatStart.					iLimit := thisLimit max: thatLimit]].	^iLimit &gt; iStart ifTrue: [iStart to: iLimit]</body><body package="Chronos-DateTimeInterval" selector="+">+ aDurationOrTemporalInterval	"Specified and required by the ANSI-Smalltalk Standard."	"{Timeperiod today + Timeperiod currentMonth}"	"{(Timeperiod 		from: (YearMonthDay today subtractingDays: 10)		duration: (CalendarDuration days: 1)) + Timeperiod today}"	"{Timeperiod today + (CalendarDuration days: 1)}"	^aDurationOrTemporalInterval addedToTemporalInterval: self</body><body package="Chronos-DateTimeInterval" selector="-">- aDurationOrTemporalInterval	"Specified and required by the ANSI-Smalltalk Standard."	"{Timeperiod today - (ScientificDuration days: 1)}"	^aDurationOrTemporalInterval subtractedFromTemporalInterval: self</body><body package="Chronos-DateTimeInterval" selector="hoursSince:">hoursSince: aTemporalCoordinate	^(self - aTemporalCoordinate) asHours</body><body package="Chronos-DateTimeInterval" selector="hoursUntil:">hoursUntil: aTemporalCoordinate	^(aTemporalCoordinate - self) asHours</body><body package="Chronos-DateTimeInterval" selector="microsecondsSince:">microsecondsSince: aTemporal	^(self - aTemporal) asMicroseconds</body><body package="Chronos-DateTimeInterval" selector="microsecondsUntil:">microsecondsUntil: aTemporal	^(aTemporal - self) asMicroseconds</body><body package="Chronos-DateTimeInterval" selector="millisecondsSince:">millisecondsSince: aTemporal	^(self - aTemporal) asMilliseconds</body><body package="Chronos-DateTimeInterval" selector="millisecondsUntil:">millisecondsUntil: aTemporal	^(aTemporal - self) asMilliseconds</body><body package="Chronos-DateTimeInterval" selector="minutesSince:">minutesSince: aTemporalCoordinate	^(self - aTemporalCoordinate) asMinutes</body><body package="Chronos-DateTimeInterval" selector="minutesUntil:">minutesUntil: aTemporalCoordinate	^(aTemporalCoordinate - self) asMinutes</body><body package="Chronos-DateTimeInterval" selector="nanoosecondsUntil:">nanoosecondsUntil: aTemporal	^(aTemporal - self) asNanoseconds</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSince:">nanosecondsSince: aTemporal	^(self - aTemporal) asNanoseconds</body><body package="Chronos-DateTimeInterval" selector="nanosecondsUntil:">nanosecondsUntil: aTemporal	^(aTemporal - self) asNanoseconds</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>INTER-period-stream protocol</category><body package="Chronos-DateTimeInterval" selector="next">next	"Answer a Timeperiod whose starting point-in-time is the receiver's limit value (end-point,) and whose temporal extent (duration) is the same as the receiver's.  See the class comment for the definition of these terms."	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="next:">next: count	"Answer a SequenceableCollection that contains a sequence of &lt;count&gt; adjacent Timeperiods, computed as follows: 		The first Timeperiod in the sequence is computed by sending the message #next to the receiver, which results in a Timeperiod whose starting point-in-time is the receiver's limit value (end-point,) and whose temporal extent (duration) is the same as the receiver's.  Each successive Timeperiod in the sequence is computed by sending the message #next to the result of the previous send (of the message #next.) Consequently, each Timeperiod in the sequence has the same temporal extent (duration) as the receiver, and each one's starting point-in-time is the same as the limit value of its predecessor in the sequence.	See the class comment for the definitions of the terminology used."	"{Timeperiod currentHour next: 10}"	"{Timeperiod today next: 10}"	"{Timeperiod currentWeek next: 10}"	"{Timeperiod currentMonth next: 10}"	"{Timeperiod currentYear next: 10}"	| list t |	count &lt;= 0 ifTrue: [^#()].	list := SequenceFactory new: count.	t := self next.	1 to: count - 1 do: [:i |		list add: t.		t := t next].	list add: t.	^list</body><body package="Chronos-DateTimeInterval" selector="next:collect:">next: count collect: mapper	"With a sequence of Timeperiods computed as defined by the method Timeperiond&gt;&gt;next:, evaluate &lt;mapper&gt; with each such Timeperiod as the argument, add the result to a SequenceableCollection, and answer said SequenceableCollection."	"{Timeperiod currentHour  next: 10 collect: [:aTimeperiod | aTimeperiod last]}"	"{Timeperiod today next: 10 collect: [:aTimeperiod | aTimeperiod asCalendricalCoordinate]}"	"{Timeperiod currentWeek next: 10 collect: [:aTimeperiod | aTimeperiod last]}"	"{Timeperiod currentMonth next: 10 collect: [:aTimeperiod | aTimeperiod last]}"	"{Timeperiod currentYear next: 10 collect: [:aTimeperiod | aTimeperiod last]}"	| list t |	count &lt;= 0 ifTrue: [^#()].	list := SequenceFactory new: count.	t := self next.	1 to: count - 1 do: [:i |		list add: (mapper value: t).		t := t next].	list add: (mapper value: t).	^list</body><body package="Chronos-DateTimeInterval" selector="nextDo:until:">nextDo: block1 until: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, do the following:		1. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		2. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value false, proceed to the next step, otherwise stop and return control to the sender.		3. Evaluate &lt;block1&gt; with the subject Timeperiod as the argument.		4. Make the successor Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 2. 	See the class comment for the definitions of the terminology used."	"Compute a schedule of payment due-dates (each on the last day of the month) until the principal amount of a loan is paid off (assuming no interest is charged):	{| dueDates principal payment |	dueDates := OrderedCollection new.	principal := 30000.	payment := 1000.	Timeperiod currentMonth 		nextDo: [:aTimeperiod | dueDates add: aTimeperiod last. principal := principal - payment] 		until:[:aTimeperiod | principal &lt;= 0].	dueDates}"	| t |	t := self next.	[predicate1 value: t]		whileFalse: 			[block1 value: t.			t := t next].</body><body package="Chronos-DateTimeInterval" selector="nextDo:while:">nextDo: block1 while: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, do the following:		1. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		2. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value true, proceed to the next step, otherwise stop and return control to the sender.		3. Evaluate &lt;block1&gt; with the subject Timeperiod as the argument.		4. Make the next Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 2. 	See the class comment for the definitions of the terminology used."	"Compute a schedule of payment due-dates (each on the last day of the month) until the principal amount of a loan is paid off (assuming no interest is charged):	{| dueDates principal payment |	dueDates := OrderedCollection new.	principal := 30000.	payment := 1000.	Timeperiod currentMonth 		nextDo: [:aTimeperiod | dueDates add: aTimeperiod last. principal := principal - payment] 		while:[:aTimeperiod | principal &gt; 0].	dueDates}"	| t |	t := self next.	[predicate1 value: t]		whileTrue: 			[block1 value: t.			t := t next].</body><body package="Chronos-DateTimeInterval" selector="nextUntil:">nextUntil: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, do the following:		1. Create an initially-empty SequenceableCollection.		2. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		3. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value false, proceed to the next step, otherwise stop and return the SequenceableCollection created in step 1.		4. Add the subject Timeperiod as the last element of the SequenceableCollection created in step 1.		5. Make the successor Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 3. 	See the class comment for the definitions of the terminology used."	"{Timeperiod currentMonth 		nextUntil:[:aTimeperiod | aTimeperiod last dayOfMonth &lt; 30]}"	| list |	list := SequenceFactory new: 15.	self nextDo: [:t | list add: t] until: predicate1.	^list</body><body package="Chronos-DateTimeInterval" selector="nextWhile:">nextWhile: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the starting point-in-time of each successor Timeperiod in the sequence is the same as the limit value of its predecessor, do the following:		1. Create an initially-empty SequenceableCollection.		2. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		3. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value true, proceed to the next step, otherwise stop and return the SequenceableCollection created in step 1.		4. Add the subject Timeperiod as the last element of the SequenceableCollection created in step 1.		5. Make the successor Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 3. 	See the class comment for the definitions of the terminology used."	"{Timeperiod currentMonth 		nextWhile:[:aTimeperiod | aTimeperiod last dayOfMonth &gt; 29]}"	| list |	list := SequenceFactory new: 15.	self nextDo: [:t | list add: t] while: predicate1.	^list</body><body package="Chronos-DateTimeInterval" selector="prev">prev	"Answer a Timeperiod whose starting point-in-time is computed by subtracting the receiver's temporal extent (duration) from its starting point-in-time, and whose temporal extent (duration) is the same as the receiver's.  See the class comment for the definition of these terms."	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="prev:">prev: count	"Answer a SequenceableCollection that contains a sequence of &lt;count&gt; adjacent Timeperiods, computed as follows: 		The first Timeperiod in the sequence is computed by sending the message #prev to the receiver, which results in a Timeperiod whose starting point-in-time is computed by subtracting the receiver's temporal extent (duration) from its starting point-in-time, and whose temporal extent (duration) is the same as the receiver's.  Each successive Timeperiod in the sequence is computed by sending the message #prev to the result of the previous send (of the message #prev.) Consequently, each Timeperiod in the sequence has the same temporal extent (duration) as the receiver, and each one's starting point-in-time is the same as the limit value of its successor in the sequence.	See the class comment for the definitions of the terminology used."	"{Timeperiod currentHour prev: 10}"	"{Timeperiod today prev: 10}"	"{Timeperiod currentWeek prev: 10}"	"{Timeperiod currentMonth prev: 10}"	"{Timeperiod currentYear prev: 10}"	| list t |	count &lt;= 0 ifTrue: [^#()].	list := SequenceFactory new: count.	t := self prev.	1 to: count - 1 do: [:i |		list add: t.		t := t prev].	list add: t.	^list</body><body package="Chronos-DateTimeInterval" selector="prev:collect:">prev: count collect: mapper	"With a sequence of Timeperiods computed as defined by the method Timeperiod&gt;&gt;prev:, evaluate &lt;mapper&gt; with each such Timeperiod as the argument, add the result to a SequenceableCollection, and answer said SequenceableCollection."	"{Timeperiod currentHour  prev: 10 collect: [:aTimeperiod | aTimeperiod last]}"	"{Timeperiod today prev: 10 collect: [:aTimeperiod | aTimeperiod asCalendricalCoordinate]}"	"{Timeperiod currentWeek prev: 10 collect: [:aTimeperiod | aTimeperiod last]}"	"{Timeperiod currentMonth prev: 10 collect: [:aTimeperiod | aTimeperiod last]}"	"{Timeperiod currentYear prev: 10 collect: [:aTimeperiod | aTimeperiod last]}"	| list t |	count &lt;= 0 ifTrue: [^#()].	list := SequenceFactory new: count.	t := self prev.	1 to: count - 1 do: [:i |		list add: (mapper value: t).		t := t prev].	list add: (mapper value: t).	^list</body><body package="Chronos-DateTimeInterval" selector="prevDo:until:">prevDo: block1 until: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the limit value of each successor Timeperiod in the sequence is the same as the starting point-in-time of its predecessor, do the following:		1. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		2. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value false, proceed to the next step, otherwise stop and return control to the sender.		3. Evaluate &lt;block1&gt; with the subject Timeperiod as the argument.		4. Make the successor Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 2. 	See the class comment for the definitions of the terminology used."	"Compute a schedule of payment due-dates (each on the last day of the month) until the principal amount of a loan is paid off (assuming no interest is charged):	{| dueDates principal payment |	dueDates := OrderedCollection new.	principal := 30000.	payment := 1000.	Timeperiod currentMonth 		prevDo: [:aTimeperiod | dueDates add: aTimeperiod last. principal := principal - payment] 		until:[:aTimeperiod | principal &lt;= 0].	dueDates}"	| t |	t := self prev.	[predicate1 value: t]		whileFalse: 			[block1 value: t.			t := t prev].</body><body package="Chronos-DateTimeInterval" selector="prevDo:while:">prevDo: block1 while: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the limit value of each successor Timeperiod in the sequence is the same as the starting point-in-time of its predecessor, do the following:		1. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		2. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value true, proceed to the next step, otherwise stop and return control to the sender.		3. Evaluate &lt;block1&gt; with the subject Timeperiod as the argument.		4. Make the successor Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 2. 	See the class comment for the definitions of the terminology used."	"Compute a schedule of payment due-dates (each on the last day of the month) until the principal amount of a loan is paid off (assuming no interest is charged):	{| dueDates principal payment |	dueDates := OrderedCollection new.	principal := 30000.	payment := 1000.	Timeperiod currentMonth 		prevDo: [:aTimeperiod | dueDates add: aTimeperiod last. principal := principal - payment] 		while:[:aTimeperiod | principal &gt; 0].	dueDates}"	| t |	t := self prev.	[predicate1 value: t]		whileTrue: 			[block1 value: t.			t := t prev].</body><body package="Chronos-DateTimeInterval" selector="prevUntil:">prevUntil: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the limit value of each successor Timeperiod in the sequence is the same as the starting point-in-time of its predecessor, do the following:		1. Create an initially-empty SequenceableCollection.		2. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		3. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value false, proceed to the next step, otherwise stop and return the SequenceableCollection created in step 1.		4. Add the subject Timeperiod as the last element of the SequenceableCollection created in step 1.		5. Make the successor Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 3. 	See the class comment for the definitions of the terminology used."	"{Timeperiod currentMonth 		prevUntil:[:aTimeperiod | aTimeperiod last dayOfMonth &lt; 30]}"	| list |	list := SequenceFactory new: 15.	self prevDo: [:t | list add: t] until: predicate1.	^list</body><body package="Chronos-DateTimeInterval" selector="prevWhile:">prevWhile: predicate1	"For each Timeperiod in an adjacent sequence of Timeperiods, starting with the receiver, all of which have the same temporal extent as the receiver, and where the limit value of each successor Timeperiod in the sequence is the same as the starting point-in-time of its predecessor, do the following:		1. Create an initially-empty SequenceableCollection.		2. Make the element of the sequence (as defined above) that is the immediate successor to the receiver the subject Timeperiod.		3. Evaluate &lt;predicate1&gt; with the subject Timeperiod as the argument.  If the result is the value true, proceed to the next step, otherwise stop and return the SequenceableCollection created in step 1.		4. Add the subject Timeperiod as the last element of the SequenceableCollection created in step 1.		5. Make the successor Timeperiod in the sequence (as defined above) the subject Timeperiod, then go to step 3. 	See the class comment for the definitions of the terminology used."	"{Timeperiod currentMonth 		prevWhile:[:aTimeperiod | aTimeperiod last dayOfMonth &gt; 29]}"	| list |	list := SequenceFactory new: 15.	self prevDo: [:t | list add: t] while: predicate1.	^list</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>INTRA-period-enumerating-common durations</category><body package="Chronos-DateTimeInterval" selector="daysDo:">daysDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-day interval (a civil/calendar day, with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentWeek daysDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 daysDo: block1</body><body package="Chronos-DateTimeInterval" selector="every:daysDo:">every: count daysDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-day interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentMonth every: 7 daysDo: [:interval | Transcript cr; show: interval printString]}"	self every: (count = 1 ifTrue: [CalendarDayDuration] ifFalse: [self class calendarDurationFactory  days: count]) do: block1</body><body package="Chronos-DateTimeInterval" selector="every:hoursDo:">every: count hoursDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-hour interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod today every: 8 hoursDo: [:interval | Transcript cr; show: interval printString]}"	self every: (count = 1 ifTrue: [HourDuration] ifFalse: [self class civilDurationFactory hours: count]) do: block1</body><body package="Chronos-DateTimeInterval" selector="every:minutesDo:">every: count minutesDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-minute interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod today every: 144 minutesDo: [:interval | Transcript cr; show: interval printString]}"	self every: (count = 1 ifTrue: [MinuteDuration] ifFalse: [self class civilDurationFactory minutes: count]) do: block1</body><body package="Chronos-DateTimeInterval" selector="every:monthsDo:">every: count monthsDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-month interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentYear every: 4 monthsDo: [:interval | Transcript cr; show: interval printString]}"	self every: (count = 1 ifTrue: [MonthDuration] ifFalse: [self class calendarDurationFactory  months: count]) do: block1</body><body package="Chronos-DateTimeInterval" selector="every:quartersDo:">every: count quartersDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-quarter (3 month) interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentYear every: 2 quartersDo: [:interval | Transcript cr; show: interval printString]}"	self every: count * 3 monthsDo: block1</body><body package="Chronos-DateTimeInterval" selector="every:secondsDo:">every: count secondsDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-second interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod today every: 864 secondsDo: [:interval | Transcript cr; show: interval printString]}"	self every: (count = 1 ifTrue: [SecondDuration] ifFalse: [self class durationFactory  seconds: count]) do: block1</body><body package="Chronos-DateTimeInterval" selector="every:weeksDo:">every: count weeksDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-week interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentYear every: 4 weeksDo: [:interval | Transcript cr; show: interval printString]}"	self every: (count = 1 ifTrue: [WeekDuration] ifFalse: [self class calendarDurationFactory  weeks: count]) do: block1</body><body package="Chronos-DateTimeInterval" selector="every:yearsDo:">every: count yearsDo: block1 	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent &lt;count&gt;-year interval whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{(Timeperiod 		from: (YearMonthDay year: 2001 month: 1 day: 20) 		duration: (CalendarDuration years: 64)) every: 4 yearsDo: [:interval | Transcript cr; show: interval printString]}"	self every: (count = 1 ifTrue: [YearDuration] ifFalse: [self class calendarDurationFactory  years: count]) do: block1</body><body package="Chronos-DateTimeInterval" selector="hoursDo:">hoursDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-hour interval (with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod today hoursDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 hoursDo: block1</body><body package="Chronos-DateTimeInterval" selector="minutesDo:">minutesDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-minute interval (with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentHour minutesDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 minutesDo: block1</body><body package="Chronos-DateTimeInterval" selector="monthsDo:">monthsDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-month interval (with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentYear monthsDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 monthsDo: block1</body><body package="Chronos-DateTimeInterval" selector="quartersDo:">quartersDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-quarter (3 month) interval (with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentYear quartersDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 quartersDo: block1</body><body package="Chronos-DateTimeInterval" selector="secondsDo:">secondsDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-second interval (with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentMinute secondsDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 secondsDo: block1</body><body package="Chronos-DateTimeInterval" selector="weeksDo:">weeksDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-week (7 civil/calendar days) interval (with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{Timeperiod currentMonth weeksDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 weeksDo: block1</body><body package="Chronos-DateTimeInterval" selector="yearsDo:">yearsDo: block1	"Evaluate &lt;block1&gt; with each Timeperiod in sequence that represents an adjacent 1-year interval (with a positive temporal exent) whose starting point-in-time occurs during the temporal interval represented by the receiver. The first interval's starting point-in-time must be the same as that of the receiver, and each subsequent interval's starting point-in-time must be the same moment as the limit (end-point) of its predecessor."	"{(Timeperiod 		from: YearMonthDay today		duration: (CalendarDuration years: 10)) yearsDo: [:interval | Transcript cr; show: interval printString]}"	self every: 1 yearsDo: block1</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="contains:">contains: aTemporalInterval 	"Answer whether the temporal interval represented by the receiver fully encloses the temporal interval represented by &lt;aTemporalInterval&gt;. If so, then the union of the two temporal intervals will be the same as the receiver's temporal interval."	"{Timeperiod currentMonth contains: YearMonthDay today}"	"{Timeperiod currentWeek contains: YearMonthDay today}"	"{Timeperiod today contains: YearMonthDay today}"	"{Timeperiod today contains: Timepoint today}"	"{Timeperiod today contains: Timepoint tomorrow}"	"{Timeperiod today contains: (Timeperiod dayStartingAt: Timepoint now)}"	"{Timeperiod currentMonth contains: (Timeperiod monthStartingAt: YearMonthDay today)}"	"{Timeperiod currentMonth contains: (Timeperiod monthStartingAt: (YearMonthDay today addingMonths: 1))}"	"{Timeperiod currentMonth contains: (Timeperiod from: YearMonthDay today duration: (CivilDuration months: -1))}"	"{Timeperiod currentMonth contains: (Timeperiod from: (YearMonthDay today subtractingMonths: 1) duration: (CivilDuration months: -1))}"	"{(Timeperiod from: YearMonthDay today duration: (CivilDuration months: -1)) contains: Timeperiod currentMonth}"	"{(Timeperiod from: (YearMonthDay today subtractingMonths: 1) duration: (CivilDuration months: -1)) contains: Timeperiod currentMonth}"	"{Timeperiod currentMonth contains: (Timeperiod monthStartingAt: (YearMonthDay today subtractingMonths: 1))}"	"{Timeperiod currentMonth contains: YearMonthDay atLastDayOfMonth @ (TimeOfDay hour: 12 minute: 0 second: 0)}"	| myStart nextStart thatStart thatNextStart |	self duration isZero ifTrue: [^false].	nextStart := self limit.	thatStart := aTemporalInterval start.	thatNextStart := aTemporalInterval limit.	myStart := self start.	^nextStart &gt; myStart 		ifTrue: 			[thatNextStart &gt; thatStart 				ifTrue: [thatStart &gt;= myStart and: [thatNextStart &lt;= nextStart]]				ifFalse: [thatStart &lt; nextStart and: [aTemporalInterval last &gt;= myStart]]]		ifFalse: 			[thatNextStart &gt; thatStart 				ifTrue: [thatStart &gt; nextStart and: [aTemporalInterval last &lt;= myStart]]				ifFalse: [thatStart &lt;= myStart and: [thatNextStart &gt;= nextStart]]]</body><body package="Chronos-DateTimeInterval" selector="includes:">includes: aTemporalInterval 	"Answer whether the temporal interval represented by the receiver intersects with the point-in-time represented by &lt;aTemporalInterval&gt;."	"{Timeperiod currentMonth includes: YearMonthDay atLastDayOfMonth + (HourDuration * 12)}"	^self intersects: aTemporalInterval</body><body package="Chronos-DateTimeInterval" selector="intersects:">intersects: aTemporalInterval	"Answer whether the temporal interval represented by the receiver has any overlap with the temporal interval represented by &lt;aTemporalInterval&gt;. If so, then the intersection of the two temporal intervals will a non-empty temporal interval."	"{Timeperiod currentMonth intersects: (Timeperiod monthStartingAt: YearMonthDay today)}"	"{Timeperiod currentMonth intersects: (Timeperiod monthStartingAt: (YearMonthDay today addingMonths: 1))}"	"{Timeperiod currentMonth intersects: (Timeperiod from: YearMonthDay today duration: (CivilDuration months: -1))}"	"{Timeperiod currentMonth intersects: (Timeperiod from: (YearMonthDay today subtractingMonths: 1) duration: (CivilDuration months: -1))}"	"{(Timeperiod from: YearMonthDay today duration: (CivilDuration months: -1)) intersects: Timeperiod currentMonth}"	"{(Timeperiod from: (YearMonthDay today subtractingMonths: 1) duration: (CivilDuration months: -1)) intersects: Timeperiod currentMonth}"	"{Timeperiod currentMonth intersects: (Timeperiod monthStartingAt: (YearMonthDay today subtractingMonths: 1))}"	"{Timeperiod currentMonth intersects: YearMonthDay atLastDayOfMonth @ (TimeOfDay hour: 12 minute: 0 second: 0)}"	| thisStart thisLimit thatStart thatLimit |	(self duration isZero or: [aTemporalInterval duration isZero]) ifTrue: [^false].		thisStart := self start.	thisLimit := self limit.	thatStart := aTemporalInterval start.	thatLimit := aTemporalInterval limit.	^thisLimit &gt;= thisStart		ifTrue:  			[thatLimit &gt; thatStart				ifTrue: [(thatStart &gt;= thisLimit or: [thatLimit &lt;= thisStart]) not]				ifFalse: [(thatLimit &gt;= thisLimit or: [thatStart &lt; thisStart]) not]]		ifFalse:			[thatLimit &gt;= thatStart				ifTrue: [(thatLimit &lt;= thisLimit or: [thatStart &gt; thisStart]) not]				ifFalse: [(thatStart &lt;= thisLimit or: [thatLimit &gt;= thisStart]) not]]	"thisStart := self start.	thisLimit := self last.	thisLimit &gt; thisStart		ifTrue:			[thisEarliest := thisStart.			thisLatest := thisLimit]		ifFalse:			[thisEarliest := thisLimit.			thisLatest := thisStart].	thatStart := aTemporalInterval start.	thatLimit := aTemporalInterval last.	thatLimit &gt; thatStart		ifTrue:			[thatEarliest := thatStart.			thatLatest := thatLimit]		ifFalse:			[thatEarliest := thatLimit.			thatLatest := thatStart].	^(thatEarliest &gt;= thisLatest or: [thatLatest &lt; thisEarliest]) not"</body><body package="Chronos-DateTimeInterval" selector="isAdjacentTo:">isAdjacentTo: aTimeperiod 	"Answer whether the temporal interval represented by the receiver is adjacent to the temporal interval represented by &lt;aTimeperiod&gt;. To be adjacent, one Timeperiod's starting point-in-time must equal the other Timeperiod's limit value (see the class comment for definitions of these terms.)"	| thisStart thisNextStart thatStart thatNextStart |	thisStart := self start.	thisNextStart := self limit.	thatStart := aTimeperiod start.	thatNextStart := aTimeperiod limit.	^thisNextStart &gt;= thisStart 		ifTrue: 			[thatNextStart &gt;= thatStart 				ifTrue: [thisNextStart = thatStart or: [thisStart = thatNextStart]]				ifFalse: [thisNextStart  = (thatStart + thisNextStart resolutionQuantum) or: [thisStart = (thatNextStart + thisStart resolutionQuantum)]]]		ifFalse: 			[thatNextStart &gt;= thatStart 				ifTrue: [(thisNextStart + thatStart resolutionQuantum) = thatStart or: [(thisStart + thatNextStart resolutionQuantum) = thatNextStart]]				ifFalse: [thisNextStart = thatStart or: [thisStart = thatNextStart]]]</body><body package="Chronos-DateTimeInterval" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^false</body><body package="Chronos-DateTimeInterval" selector="isGregorian">isGregorian	^self calendar isGregorian</body><body package="Chronos-DateTimeInterval" selector="isHourDuration">isHourDuration	"Answer whether the receiver's temporal extent is one hour."	^false</body><body package="Chronos-DateTimeInterval" selector="isInfinite">isInfinite	^false</body><body package="Chronos-DateTimeInterval" selector="isInfiniteFuture">isInfiniteFuture	^false</body><body package="Chronos-DateTimeInterval" selector="isInfinitePast">isInfinitePast	^false</body><body package="Chronos-DateTimeInterval" selector="isJulian">isJulian	^self calendar isJulian</body><body package="Chronos-DateTimeInterval" selector="isMinuteDuration">isMinuteDuration	"Answer whether the receiver's temporal extent is one minute."	^false</body><body package="Chronos-DateTimeInterval" selector="isMonthDuration">isMonthDuration	"Answer whether the receiver's temporal extent is one month."	^false</body><body package="Chronos-DateTimeInterval" selector="isMonthsPerYearInvariant">isMonthsPerYearInvariant	^self calendar isMonthsPerYearInvariant</body><body package="Chronos-DateTimeInterval" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^false</body><body package="Chronos-DateTimeInterval" selector="isSecondDuration">isSecondDuration	"Answer whether the receiver's temporal extent is one second."	^false</body><body package="Chronos-DateTimeInterval" selector="isYearDuration">isYearDuration	"Answer whether the receiver's temporal extent is one year."	^false</body><body package="Chronos-DateTimeInterval" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the receiver's calendrical system starts each day at local midnight."	^self calendar midnightIsStartOfDay</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtMidnight">timeOfDayClockStartsAtMidnight	"Answer true if the zero-point of the time-of-day clock coincides with midnight"	^self calendar timeOfDayClockStartsAtMidnight</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the receiver's calendrical system coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^self calendar timeOfDayClockStartsAtStartOfDay</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>private-comparing</category><body package="Chronos-DateTimeInterval" selector="compareToCalendricalCoordinate:">compareToCalendricalCoordinate: aCalendricalCoordinate	^self compareToTemporalCoordinate: aCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="compareToDate:">compareToDate: aDate	^self compareToTemporalCoordinate: aDate</body><body package="Chronos-DateTimeInterval" selector="compareToDateAndTime:">compareToDateAndTime: aDateAndTime	^self compareToTemporalCoordinate: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="compareToInfiniteTimepoint:">compareToInfiniteTimepoint: anInfiniteTimepoint	^anInfiniteTimepoint isInfinitePast		ifTrue: [-1]		ifFalse: [1]</body><body package="Chronos-DateTimeInterval" selector="compareToTemporalCoordinate:">compareToTemporalCoordinate: aTemporalCoordinate	| diff |	diff := aTemporalCoordinate basicSecondsSince: self.	diff = 0 ifFalse: [^diff].	^aTemporalCoordinate nanosecondsSinceSecond - self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="compareToTimeperiod:">compareToTimeperiod: aTimeperiod 	^(aTimeperiod compareToTemporalCoordinate: self) negated</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="calendar">calendar	"Answer the Calendar that implements the calendrical system associated with the receiver."	^Calendar ansiStandard</body><body package="Chronos-DateTimeInterval" selector="calendarRegistrationKey">calendarRegistrationKey	^self calendar registrationKey</body><body package="Chronos-DateTimeInterval" selector="clock">clock	^self calendar clock</body><body package="Chronos-DateTimeInterval" selector="closedExtent">closedExtent	"Answer the `closed extent` of the receiver. Conceptually, the closed extent of a Timeperiod is the temporal extent (duration) of the **fully-closed** temporal interval that contains every representable point-in-time contained by the Timeperiod. Physically, it is defined to be the temporal extent (duration) computed by subtracting the Timeperiod's granularity from its temporal exent (i.e., {aTimeperiod duration - aTimeperiod granularity}.) See the comment of the receiver's #granularity method (and also the class comment.)"	"{Timeperiod currentWeek closedExtent}"	"{Timeperiod currentHour closedExtent}"	^self duration - self granularity</body><body package="Chronos-DateTimeInterval" selector="comparisonClassIdentifier">comparisonClassIdentifier		"Answer a value that identifies the group of comparable values to which the receiver belongs.  It must be valid to use #== to compare two identifiers for equality."	^#TemporalInterval</body><body package="Chronos-DateTimeInterval" selector="duration">duration	"Answer a Duration whose value represents the receiver's temporal extent."	^self resolutionQuantum</body><body package="Chronos-DateTimeInterval" selector="earliest">earliest	"Compare the first and last element of the receiver (see the class comment,) and answer whichever one temporally precedes the other. If neither one precedes the other, answer either the receiver's first or last element."	^self first min: self last</body><body package="Chronos-DateTimeInterval" selector="earliestAndLatestDo:">earliestAndLatestDo: block2	"Evaluate &lt;block2&gt; with 'self earliest' as the first argument and with 'self latest' as the second argument."	| first last |	first := self first.	last := self last.	^last &gt;= first 		ifTrue: [block2 value: first value: last]		ifFalse: [block2 value: last value: first]</body><body package="Chronos-DateTimeInterval" selector="first">first	"Answer the first element of the receiver, which is defined to be its starting point-in-time."	^self start</body><body package="Chronos-DateTimeInterval" selector="granularity">granularity	"Answer the receiver's granularity, which is defined to be the quantum of resolution of its starting point-in-time (the quantum of resolution of any Chronos point-in-time value is accessible by sending it the message #resolutionQuantum.)  The quantum of resolution of a date value is one calendar day.  The quantum of resolution of a DateAndTime value is the same as that of a Duration value--currently implemented to be one nanosecond. The granularity of Timeperiod contributes to the definition of its closed extent (see the comment of the #closedExtent method, and also the class comment.)"	^self start resolutionQuantum</body><body package="Chronos-DateTimeInterval" selector="last">last	"Answer the last element of the receiver, which is defined to be the point-in-time computed by adding the receiver's closed extent to its starting point-in-time ({self start + self closedExtent.} Also see the class comment."	"{(Timeperiod 		startingAt: (YearMonthDay year: 1901 day: 1)		duration: (CalendarDuration years: 100)) last}"	^self start + self closedExtent</body><body package="Chronos-DateTimeInterval" selector="latest">latest	"Compare the first and last element of the receiver (see the class comment,) and answer whichever one temporally follows the other. If neither one temporally follows the other, answer either the receiver's first or last element."	^self first max: self last</body><body package="Chronos-DateTimeInterval" selector="limit">limit	"Answer the end-point or `limit value` of the receiver, which is defined to be the point-in-time computed by adding the temporal extent (duration) of a Timeperiod to its starting point. The end-point/limit is not included in the Timeperiod's temporal interval (although the points-in-time that asymptotically approach the limit from its starting point-in-time are all included in a Timeperiod's temporal interval.)"	^self start + self duration</body><body package="Chronos-DateTimeInterval" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="start">start	"Answer the point-in-time value that is the initial moment of the receiver's temporal interval (which is included in the interval.)"	^self</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>queries</category><body package="Chronos-DateTimeInterval" selector="daysInMonth:">daysInMonth: monthOrdinal	^self calendar daysInMonth: monthOrdinal forYearTypeCode: self yearTypeCode</body><body package="Chronos-DateTimeInterval" selector="nextDayOfWeek:">nextDayOfWeek: dayOfWeek 	"YearMonthDay today nextDayOfWeek: Saturday"	"YearMonthDay today nextDayOfWeek: #Monday"	"YearMonthDay yesterday nextDayOfWeek: Wednesday"	"YearMonthDay yesterday nextDayOfWeek: #Wednesday"	"YearMonthDay tomorrow nextDayOfWeek: Sunday"	"YearMonthDay tomorrow nextDayOfWeek: #Sunday"	| ansiDayOfWeekOrdinal |	ansiDayOfWeekOrdinal := 		dayOfWeek isInteger 			ifTrue: [dayOfWeek]			ifFalse: [ANSIDayOfWeekKeys indexOf: dayOfWeek].	^self addingDays: (ansiDayOfWeekOrdinal - self ansiDayOfWeekOrdinal \\ DaysPerWeek)</body><body package="Chronos-DateTimeInterval" selector="nextMonth">nextMonth	^self addingMonths: 1</body><body package="Chronos-DateTimeInterval" selector="nextWeek">nextWeek	^self addingDays: DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="nextYear">nextYear	^self addingYears: 1</body><body package="Chronos-DateTimeInterval" selector="prevDayOfWeek:">prevDayOfWeek: dayOfWeek 	"YearMonthDay today prevDayOfWeek: Saturday"	"YearMonthDay today prevDayOfWeek: #Monday"	"YearMonthDay yesterday prevDayOfWeek: Wednesday"	"YearMonthDay yesterday prevDayOfWeek: #Wednesday"	"YearMonthDay tomorrow prevDayOfWeek: Sunday"	"YearMonthDay tomorrow prevDayOfWeek: #Sunday"	| ansiDayOfWeekOrdinal |	ansiDayOfWeekOrdinal := 		dayOfWeek isInteger 			ifTrue: [dayOfWeek]			ifFalse: [ANSIDayOfWeekKeys indexOf: dayOfWeek ifAbsent: [self signalError: 'Invalid day-of-week key: ', dayOfWeek printString]].	^self subtractingDays: (self ansiDayOfWeekOrdinal - ansiDayOfWeekOrdinal  \\ DaysPerWeek)</body><body package="Chronos-DateTimeInterval" selector="prevMonth">prevMonth	^self subtractingMonths: 1</body><body package="Chronos-DateTimeInterval" selector="prevWeek">prevWeek	^self subtractingDays: DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="prevYear">prevYear	^self subtractingYears: 1</body><body package="Chronos-DateTimeInterval" selector="secondsInDay">secondsInDay	^SecondsPerDay</body><body package="Chronos-DateTimeInterval" selector="tomorrow">tomorrow	^self addingDays: 1</body><body package="Chronos-DateTimeInterval" selector="yesterday">yesterday	^self subtractingDays: 1</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="&lt;">&lt; aMagnitude 	"Answer whether the receiver is less than the argument."	"Specified and required by the ANSI-Smalltalk Standard."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &lt; 0]</body><body package="Chronos-DateTimeInterval" selector="&lt;=">&lt;= aMagnitude 	"Answer whether the receiver is less than or equal to the argument."	"Specified and required by the ANSI-Smalltalk Standard."	^(self &gt; aMagnitude) not</body><body package="Chronos-DateTimeInterval" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	"Specified and required by the ANSI-Smalltalk Standard."	self == aMagnitude ifTrue: [^true].	^(self compareTo: aMagnitude) = 0</body><body package="Chronos-DateTimeInterval" selector="&gt;">&gt; aMagnitude 	"Answer whether the receiver is greater than the argument."	"Specified and required by the ANSI-Smalltalk Standard."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &gt; 0]</body><body package="Chronos-DateTimeInterval" selector="&gt;=">&gt;= aMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	"Specified and required by the ANSI-Smalltalk Standard."	^(self &lt; aMagnitude) not</body><body package="Chronos-DateTimeInterval" selector="between:and:">between: min and: max 	"Answer whether the receiver is less than or equal to the argument, max,	and greater than or equal to the argument, min."	^self &gt;= min and: [self &lt;= max]</body><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aTemporalInterval	"Compare the value of the receiver to that of &lt;aTemporalInterval&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aTemporalInterval&gt; are the same.)"	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="hash">hash	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="max:">max: aMagnitude 	"Answer the receiver or the argument, whichever has the greater magnitude."	self &gt; aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]</body><body package="Chronos-DateTimeInterval" selector="min:">min: aMagnitude 	"Answer the receiver or the argument, whichever has the lesser magnitude."	self &lt; aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>accessing-subintervals</category><body package="Chronos-DateTimeInterval" selector="dayPeriods">dayPeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the days contained by the receiver."	"{(Timeperiod 		startingAt: (YearMonthDay year: 2004 month: 10 day: 30)		duration: (CalendarDuration days: 4)) dayPeriods}"	| sequence | 	sequence := SequenceFactory new.	self daysDo: [:each | sequence add: each].	^sequence</body><body package="Chronos-DateTimeInterval" selector="hourPeriods">hourPeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the hours contained by the receiver."	"The following examples illustrate both the results of sending the #hours message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 timeZone: 'America/Vancouver')		duration: (ScientificDuration hours: 4)) hourPeriods}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 timeZone: 'America/Vancouver')		duration: (ScientificDuration hours: 2)) hourPeriods}"	| sequence | 	sequence := SequenceFactory new.	self hoursDo: [:each | sequence add: each].	^sequence</body><body package="Chronos-DateTimeInterval" selector="minutePeriods">minutePeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the minutes contained by the receiver."	"The following examples illustrate both the results of sending the #minutes message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 hour: 1 minute: 50 second: 0 timeZone: 'America/Vancouver')		duration: (ScientificDuration minutes: 20)) minutePeriods}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 55 second: 0  timeZone: 'America/Vancouver')		duration: (ScientificDuration minutes: 10)) minutePeriods}"	| sequence | 	sequence := SequenceFactory new.	self minutesDo: [:each | sequence add: each].	^sequence</body><body package="Chronos-DateTimeInterval" selector="monthPeriods">monthPeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the months contained by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration years: 1)) monthPeriods}"	| sequence | 	sequence := SequenceFactory new.	self monthsDo: [:each | sequence add: each].	^sequence</body><body package="Chronos-DateTimeInterval" selector="quarterPeriods">quarterPeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the quartes contained by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration years: 1)) quarterPeriods}"	| sequence | 	sequence := SequenceFactory new.	self quartersDo: [:each | sequence add: each].	^sequence</body><body package="Chronos-DateTimeInterval" selector="secondPeriods">secondPeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the seconds contained by the receiver."	"The following examples illustrate both the results of sending the #seconds message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 hour: 1 minute: 59 second: 55 timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) secondPeriods}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 59 second: 55  timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) secondPeriods}"	| sequence | 	sequence := SequenceFactory new.	self secondsDo: [:each | sequence add: each].	^sequence</body><body package="Chronos-DateTimeInterval" selector="weekPeriods">weekPeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the 7-day weeks contained by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration months: 1)) weekPeriods}"	| sequence | 	sequence := SequenceFactory new.	self weeksDo: [:each | sequence add: each].	^sequence</body><body package="Chronos-DateTimeInterval" selector="yearPeriods">yearPeriods	"Answer a SequenceableCollection containing a Timeperiod representing each of the years contained by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration years: 4)) yearPeriods}"	| sequence | 	sequence := SequenceFactory new.	self yearsDo: [:each | sequence add: each].	^sequence</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="/">/ aTemporalCoordinateOrADurational	"YearMonthDay today / 1 days"	"(YearMonthDay year: 2006 day: 1) / (YearMonthDay year: 2007 month: 7 day: 1)"	^aTemporalCoordinateOrADurational asTimeperiodStartingAt: self start</body><body package="Chronos-DateTimeInterval" selector="asTimeperiod">asTimeperiod	"Answer a Timeperiod whose starting point-in-time is the receiver, and whose temporal extent is the receiver's duration."	^self</body><body package="Chronos-DateTimeInterval" selector="asTimeperiodStartingAt:">asTimeperiodStartingAt: startPoint	^startPoint to: self start</body><body package="Chronos-DateTimeInterval" selector="through:">through: finalMoment 	"Answer a Timeperiod whose starting point-in-time is the receiver and whose temporal extent is the duration computed by subtracting the receiver from &lt;finalMoment&gt; (a TemporalCoordinate) and then adding the resolution quantum of &lt;finalMoment&gt;. The result is a Timeperiod representing the closed interval [self, finalMoment]."	^self class timeperiodFactory  		from: self start		through: finalMoment</body><body package="Chronos-DateTimeInterval" selector="to:">to: limitValue 	"Answer a Timeperiod whose starting point-in-time is the receiver and whose temporal extent is the duration computed by subtracting the receiver from &lt;limitValue&gt; (a TemporalCoordinate.) The result is a Timeperiod representing the left closed, right open interval [self, limitValue)."	^self class timeperiodFactory  		from: self start		to: limitValue</body><body package="Chronos-DateTimeInterval" selector="withDuration:">withDuration: aDuration 	"Answer a Timeperiod whose starting point-in-time is the receiver and whose temporal extent is &lt;aDuration&gt; (a Durational instance.)"	^self class timeperiodFactory  from: self start duration: aDuration</body></methods><methods><class-id>Chronos.TemporalInterval</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="invalidateCalendar">invalidateCalendar	"Be default, do nothing."</body></methods><methods><class-id>Chronos.TemporalInterval class</class-id> <category>class initialization</category><body package="Chronos-DateTimeInterval" selector="invalidateCalendarBindings">invalidateCalendarBindings	"Calendrical invalidateCalendarBindings"	self allInstancesDo: [:calendrical | calendrical invalidateCalendar].	self subclasses do: [:class | class invalidateCalendarBindings]</body></methods><methods><class-id>Chronos.TemporalInterval class</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="asMutableDate">asMutableDate	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTime">asMutableDateAndTime	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTimeInvariantToUT">asMutableDateAndTimeInvariantToUT	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="asMutableTimeOfDay">asMutableTimeOfDay	^self copy</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecond">basicNanosecondsSinceSecond	^0</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceStartOfDay">basicNanosecondsSinceStartOfDay	^self basicSecondsSinceStartOfDay * NanosecondsPerSecond + self basicNanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceStartOfDay">basicSecondsSinceStartOfDay	^0</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="comparisonClassIdentifier">comparisonClassIdentifier		"Answer a value that identifies the group of comparable values to which the receiver belongs.  It must be valid to use #== to compare two identifiers for equality."	^#TimeOfDay</body><body package="Chronos-DateTimeInterval" selector="fractionalSecondsSinceMidnight">fractionalSecondsSinceMidnight	^ScaledDecimal 		numerator: self nanosecondsSinceMidnight		denominator: NanosecondsPerSecond 		scale: 9</body><body package="Chronos-DateTimeInterval" selector="fractionalSecondsSinceStartOfDay">fractionalSecondsSinceStartOfDay	^ScaledDecimal 		numerator: self nanosecondsSinceStartOfDay 		denominator: NanosecondsPerSecond 		scale: 9</body><body package="Chronos-DateTimeInterval" selector="fractionalTimeOfDay">fractionalTimeOfDay	^ScaledDecimal		numerator: self nanosecondsSinceStartOfDay		denominator: NanosecondsPerDay		scale: 9</body><body package="Chronos-DateTimeInterval" selector="fractionalTimeOfDaySinceMidnight">fractionalTimeOfDaySinceMidnight	^ScaledDecimal		numerator: self nanosecondsSinceMidnight		denominator: NanosecondsPerDay		scale: 9</body><body package="Chronos-DateTimeInterval" selector="hour">hour	"Specified and required by the ANSI-Smalltalk Standard."	^self secondsSinceStartOfTimeOfDayClock // SecondsPerHour</body><body package="Chronos-DateTimeInterval" selector="hour12">hour12	"Specified and required by the ANSI-Smalltalk Standard."	| hour |	hour := self hoursSinceMidnight \\ 12.	^hour = 0		ifTrue: [12]		ifFalse: [hour]</body><body package="Chronos-DateTimeInterval" selector="hour24">hour24	"Specified and required by the ANSI-Smalltalk Standard."	^self hoursSinceMidnight</body><body package="Chronos-DateTimeInterval" selector="hoursSinceMidnight">hoursSinceMidnight	^self secondsSinceMidnight // SecondsPerHour</body><body package="Chronos-DateTimeInterval" selector="hoursSinceStartOfDay">hoursSinceStartOfDay 	^self secondsSinceStartOfDay // SecondsPerHour</body><body package="Chronos-DateTimeInterval" selector="meridianAbbreviation">meridianAbbreviation	"Specified and required by the ANSI-Smalltalk Standard."	^ChronosLocale default 		properNameAtSemanticKey: (MeridianKeys at: (self hour // 12) + 1)</body><body package="Chronos-DateTimeInterval" selector="microsecondsSinceSecond">microsecondsSinceSecond	^(self nanosecondsSinceSecond bitShift: -3) // 125</body><body package="Chronos-DateTimeInterval" selector="microsecondsSinceStartOfDay">microsecondsSinceStartOfDay	^self nanosecondsSinceStartOfDay // NanosecondsPerMicrosecond</body><body package="Chronos-DateTimeInterval" selector="millisecond">millisecond	^(self nanosecondsSinceSecond bitShift: -6) // 15625</body><body package="Chronos-DateTimeInterval" selector="millisecondsSinceStartOfDay">millisecondsSinceStartOfDay	^self nanosecondsSinceStartOfDay // NanosecondsPerMillisecond</body><body package="Chronos-DateTimeInterval" selector="minute">minute	"Specified and required by the ANSI-Smalltalk Standard."	^self minutesSinceStartOfTimeOfDayClock \\ MinutesPerHour</body><body package="Chronos-DateTimeInterval" selector="minutesSinceMidnight">minutesSinceMidnight	^self secondsSinceMidnight // SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfDay">minutesSinceStartOfDay 	^self secondsSinceStartOfDay // SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfTimeOfDayClock">minutesSinceStartOfTimeOfDayClock	^self secondsSinceStartOfTimeOfDayClock // SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceMidnight">nanosecondsSinceMidnight	^self secondsSinceMidnight * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	^0</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceStartOfDay">nanosecondsSinceStartOfDay	^self secondsSinceStartOfDay * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="offset">offset	"Specified and required by the ANSI-Smalltalk Standard."	^self timeZone offsetFromUT</body><body package="Chronos-DateTimeInterval" selector="rootTimeZone">rootTimeZone	^self basicTimeZone root</body><body package="Chronos-DateTimeInterval" selector="second">second	"Specified and required by the ANSI-Smalltalk Standard."	^self secondsSinceStartOfTimeOfDayClock \\ SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="secondsSinceMidnight">secondsSinceMidnight	^self secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	^0</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfTimeOfDayClock">secondsSinceStartOfTimeOfDayClock	^self timeOfDayClockStartsAtStartOfDay 		ifTrue: [self secondsSinceStartOfDay]		ifFalse: [self secondsSinceMidnight]</body><body package="Chronos-DateTimeInterval" selector="timeOfDay">timeOfDay	^self class timeOfDayFactory		secondsSinceStartOfDay: self secondsSinceStartOfTimeOfDayClock		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="timeOfDaySinceMidnight">timeOfDaySinceMidnight	^self class timeOfDayFactory		secondsSinceStartOfDay: self secondsSinceMidnight 		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="timeOfDaySinceStartOfDay">timeOfDaySinceStartOfDay	^self class timeOfDayFactory		secondsSinceStartOfDay: self secondsSinceStartOfDay		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="timeZone">timeZone	"Answer the bound Timezone that has the correct offsetFromUT for the date and time represented by the receiver." 	^self basicTimeZone</body><body package="Chronos-DateTimeInterval" selector="timeZoneAbbreviation">timeZoneAbbreviation	"Specified and required by the ANSI-Smalltalk Standard."	^self timeZone abbreviation</body><body package="Chronos-DateTimeInterval" selector="timeZoneKey">timeZoneKey	^self basicTimeZone key</body><body package="Chronos-DateTimeInterval" selector="timeZoneName">timeZoneName	"Specified and required by the ANSI-Smalltalk Standard."	^self timeZone name</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[^aCalendrical compareToTemporalCoordinate: self] 			on: MessageNotUnderstood 			do: [:ex | 				((ex receiver == aCalendrical) and: [#compareToTemporalCoordinate: == ex message selector])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-DateTimeInterval" selector="hash">hash	^(self secondsSinceStartOfDay + self nanosecondsSinceSecond) hash</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="hour12MinuteSecondDo:">hour12MinuteSecondDo: block3 	^self hourMinuteSecondDo: block3 hour24Format: false</body><body package="Chronos-DateTimeInterval" selector="hour24MinuteSecondDo:">hour24MinuteSecondDo: block3 	^self hourMinuteSecondDo: block3 hour24Format: true</body><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:">hourMinuteSecondDo: block3 	^self hourMinuteSecondDo: block3 hour24Format: true</body><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:hour24Format:">hourMinuteSecondDo: block3 hour24Format: hour24	^ChronosFunction 		fromSeconds: 			(hour24 				ifTrue: [self secondsSinceStartOfTimeOfDayClock]				ifFalse: [self secondsSinceMidnight])		hourMinuteSecondDo:  block3</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isAtStartOfDay">isAtStartOfDay	self subsecondsAreZero ifFalse: [^false].	self hourMinuteSecondDo: [:hour :minute :second | (second = 0 and: [minute = 0 and: [hour = 0]]) ifFalse: [^false]].	^true</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfHour">isAtStartOfHour	self subsecondsAreZero ifFalse: [^false].	self hourMinuteSecondDo: [:hour :minute :second | (second = 0 and: [minute = 0]) ifFalse: [^false]].	^true</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfMinute">isAtStartOfMinute	^self subsecondsAreZero and: [self second = 0]</body><body package="Chronos-DateTimeInterval" selector="isBoundToTimeZone">isBoundToTimeZone	^false</body><body package="Chronos-DateTimeInterval" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer true if the receiver always represents an invariant nominal local time ('3 pm local time') in whatever Timezone to which it may be bound. Otherwise, answer false."	^true</body><body package="Chronos-DateTimeInterval" selector="isInvariantToUT">isInvariantToUT	"Answer true if the receiver always represents an invariant nominal UT time ('3 pm UT') in whatever Timezone to which it may be bound. Otherwise, answer false."	^self isInvariantToNominalTime not</body><body package="Chronos-DateTimeInterval" selector="isTemporalCoordinate">isTemporalCoordinate	^true</body><body package="Chronos-DateTimeInterval" selector="localTimeIsUniversal">localTimeIsUniversal	^self basicTimeZone isUniversalTime</body><body package="Chronos-DateTimeInterval" selector="subsecondsAreZero">subsecondsAreZero	^self nanosecondsSinceSecond = 0</body><body package="Chronos-DateTimeInterval" selector="timeZoneIsDynamic">timeZoneIsDynamic	^self basicTimeZone isDynamic</body><body package="Chronos-DateTimeInterval" selector="timeZoneIsStatic">timeZoneIsStatic	^self basicTimeZone isStatic</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="&lt;&lt;">&lt;&lt; aChronosTimezone 	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but convert the date and time-of-day as though the receiver represented a date and time in the current default time zone (i.e,. preserve date and time-of-day in Universal Time as though the receiver represented a date and time in the current default time zone.)	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is the same as that of the receiver (i.e,, preserve local date and local time-of-day, don't preserve date or time-of-day in Universal Time.)"	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="&gt;&gt;">&gt;&gt; aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="\">\ calendar	"Answer the result of converting the receiver into a calendrical coordinate whose Calendar is &lt;otherCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history)."	"YearMonthDay today \ #Hebrew"	^self as: calendar</body><body package="Chronos-DateTimeInterval" selector="as:">as: otherCalendar 	"Answer the result of converting the receiver into a calendrical coordinate whose Calendar is &lt;otherCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history)."	| newCalendar |	newCalendar := Calendar referencedBy: otherCalendar.	self calendar == newCalendar ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self asMutableDate)		convertToCalendar: newCalendar;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asAll:">asAll: anCollectionOfCalendars	"NOTE: If &lt;anCollectionOfCalendars&gt; is a Set, the result will be a Set with only one member, because Calendrical instances compare as equal to all others that represent the same moment in time."	^anCollectionOfCalendars asArray collect: [:aCalendar | self as: aCalendar]</body><body package="Chronos-DateTimeInterval" selector="asBoundToStaticTimeZone">asBoundToStaticTimeZone	"YearMonthDay today asBoundToStaticTimeZone"	^self asDateAndTime asBoundToStaticTimeZone</body><body package="Chronos-DateTimeInterval" selector="asBoundToTimeZone">asBoundToTimeZone	^self asDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asCalendricalCoordinate">asCalendricalCoordinate	"Answer the conversion of the receiver into its equivalent value implemented as a CalendricalCoordinate.  If the receiver is already a CalendricalCoordinate, answer the receiver."	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="asDate">asDate	"Answer the conversion of the receiver into a date-valued CalendricalCoordinate that represents the same date as does the receiver.  If the receiver is already a date-valued CalendricalCoordinate, answer the receiver.  A date-valued CalendricalCoordinate is one that specifies a date without specifying a particular time-of-day nor a particular timezone (i.e., it has nominal time semantics, and its quantum of resolution is 1 calendar day.)"	^self asMutableDate beImmutable</body><body package="Chronos-DateTimeInterval" selector="asDateAndTime">asDateAndTime	"Answer the conversion of the receiver into a DateAndTime value that represents the same point-in-time as does the receiver.  If the receiver is already a DateAndTime value, answer the receiver.  A DateAndTime value is a CalendricalCoordinate that specifies a point-in-time, with a quantum of resolution no larger than one second, with behavior/semantics that is invariant to UT, and that conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol. See the class comment of Timepoint for further clarification."	"Timepoint now asDateAndTime"	"TimeOfDay now asDateAndTime"	"YearMonthDay today asDateAndTime"	"GregorianEaster canonical asDateAndTime"	"(Timeperiod hourStartingAt: Timepoint now) asDateAndTime"	^self asMutableDateAndTimeInvariantToUT beImmutable</body><body package="Chronos-DateTimeInterval" selector="asDateAndTimeIn:">asDateAndTimeIn: aChronosTimezone	"Timepoint now asDateAndTimeIn: 'Pacific/Kiritimati'"	"TimeOfDay now asDateAndTimeIn: 'Pacific/Kiritimati'"	"YearMonthDay today asDateAndTimeIn: 'Pacific/Kiritimati'"	"GregorianEaster canonical asDateAndTimeIn: 'Pacific/Kiritimati'"	"(Timeperiod hourStartingAt: Timepoint now) asDateAndTimeIn: 'Pacific/Kiritimati'"	| timeZone |	timeZone := ChronosTimezone referencedBy: aChronosTimezone.	^(self asMutableDateAndTime)		basicSetTimeZone: timeZone;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asDurationSinceStartOfDay">asDurationSinceStartOfDay	^self class durationFactory		seconds: self secondsSinceStartOfDay		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="asGregorian">asGregorian	^self as: Gregorian</body><body package="Chronos-DateTimeInterval" selector="asInvariantToNominalTime">asInvariantToNominalTime	"Answer a value equivalent to that of the receiver in all respects, except that its semantics/behavior is invariant to nominal time.  If the receiver is already nominal-time invariant, answer the receiver. See the class comment of Timepoint for further clarification."	^self</body><body package="Chronos-DateTimeInterval" selector="asInvariantToUT">asInvariantToUT	"Answer a value equivalent to that of the receiver in all respects, except that it has UT-invariant behavior/semantics.  If the receiver is already invariant-to-UT, answer the receiver. See the class comment of Timepoint for further clarification."	^self asDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asJulian">asJulian	^self as: Julian</body><body package="Chronos-DateTimeInterval" selector="asLocal">asLocal	"Specified and required by the ANSI-Smalltalk Standard."	^self &gt;&gt; ChronosTimezone default</body><body package="Chronos-DateTimeInterval" selector="asNominalDateAndTime">asNominalDateAndTime	"Answer the conversion of the receiver into a nominal-time-invariant DateAndTime value that represents the same local point-in-time as does the receiver.  If the receiver is already a nominal-time-invariant DateAndTime value, answer the receiver.  A nominal-time-invariant DateAndTime value is a CalendricalCoordinate that nominally specifies a point-in-time without reference to any particular timezone, and has a quantum of resolution no larger than one second. A nominal-time-invariant DateAndTime value conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol EXCEPT that its behavior/semantics is invariant to nominal time, as opposed to being UT invariant. See the class comment of Timepoint for further clarification."	^self asMutableDateAndTime beImmutable</body><body package="Chronos-DateTimeInterval" selector="asTemporalCoordinate">asTemporalCoordinate	"Answer the conversion of the receiver into its equivalent value implemented as a TemporalCoordinate.  If the receiver is already a TemporalCoordinate, answer the receiver."	^self</body><body package="Chronos-DateTimeInterval" selector="asTimeperiod">asTimeperiod	"Answer a Timeperiod whose starting point-in-time is the receiver, and whose temporal extent is the receiver's duration."	^self withDuration: self duration</body><body package="Chronos-DateTimeInterval" selector="asUT">asUT		^self in: ChronosTimezone universal</body><body package="Chronos-DateTimeInterval" selector="asUTC">asUTC	"Specified and required by the ANSI-Smalltalk Standard."	^self asUT</body><body package="Chronos-DateTimeInterval" selector="atStartOfDay">atStartOfDay	^self subclassResponsibility</body><body package="Chronos-DateTimeInterval" selector="in:">in: aChronosTimezone 	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"{YearMonthDay today in: 'America/Phoenix'}"	"{DateAndTimeFactory now in: 'Asia/Calcutta'}"	"{DateAndTimeFactory nominalNow in: 'Asia/Calcutta'}"	"{DateAndTimeFactory now in: ChronosTimezone nominal}"	^self &gt;&gt; aChronosTimezone</body><body package="Chronos-DateTimeInterval" selector="inAll:">inAll: aCollectionOfTimeZones	"NOTE: If &lt;aCollectionOfTimeZones&gt; is a Set, the result will be a Set with only one member, because all DateAndTime instances compare as equal to all others that represent the same moment in time."	^aCollectionOfTimeZones  collect: [:tz | self &gt;&gt; tz]</body><body package="Chronos-DateTimeInterval" selector="offset:">offset: aDuration	"Specified and required by the ANSI-Smalltalk Standard."	^self in: aDuration asTimezone</body><body package="Chronos-DateTimeInterval" selector="on:">on: aCalendricalCoordinate 	"TimeOfDay now on: YearMonthDay today"	"TimeOfDay now on: Timepoint today"	"(TimeOfDay hour: 17 minute: 30 second: 0) on: (YearMonthDay year: 2006 month: June day: 14)"	"(TimeOfDay hour: 17 minute: 30 second: 0) on: (Timepoint year: 2006 month: June day: 14)"	"(TimeOfDay hour: 9 minute: 20 second: 0) on: GregorianEaster canonical"	^aCalendricalCoordinate @ self</body><body package="Chronos-DateTimeInterval" selector="on:in:">on: aCalendricalCoordinate in: timeZone 	"TimeOfDay now on: YearMonthDay today in: 'Australia/Adelaide'"	"TimeOfDay now on: Timepoint today in: 'America/Vancouver'"	"(TimeOfDay hour: 17 minute: 30 second: 0) on: (YearMonthDay year: 2006 month: June day: 14) in: 'Europe/Berlin'"	"(TimeOfDay hour: 17 minute: 30 second: 0) on: (Timepoint year: 2006 month: June day: 14) in: 'Pacific/Auckland'"	"(TimeOfDay hour: 9 minute: 20 second: 0) on: GregorianEaster canonical in: 'Asia/Rangoon'"	^aCalendricalCoordinate atTimeOfDay: self in: timeZone</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>arithmetic</category><body package="Chronos-DateTimeInterval" selector="addingDays:">addingDays: dayDelta	"Answer a new CalendricalCoordinate which is the given number of civil days after the date represented by the receiver, preserving the same civil time-of-day."	dayDelta = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self asMutableDate) 		basicAddDays: dayDelta;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:">addingHours: hours	hours = 0 ifTrue: [^self isMutable ifTrue: [self asMutableTimeOfDay] ifFalse: [self]].	^(self asMutableTimeOfDay)		addHours: hours;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:">addingHours: hours minutes: minutes	minutes = 0 ifTrue: [^self addingHours: hours].	^(self asMutableTimeOfDay)		addHours: hours minutes: minutes;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:seconds:">addingHours: hours minutes: minutes seconds: seconds	seconds = 0 ifTrue: [^self addingHours: hours minutes: minutes].	^(self asMutableTimeOfDay)		addHours: hours minutes: minutes seconds: seconds;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:seconds:nanoseconds:">addingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	nanoseconds = 0 ifTrue: [^self addingHours: hours minutes: minutes seconds: seconds].	^(self asMutableTimeOfDay)		addHours: hours		minutes: minutes		seconds: seconds		nanoseconds: nanoseconds;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingMinutes:">addingMinutes: minutes	minutes = 0 ifTrue: [^self isMutable ifTrue: [self asMutableTimeOfDay] ifFalse: [self]].	^(self asMutableTimeOfDay)		addMinutes: minutes;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingMonths:">addingMonths: months	"Answer a CalendricalCoordinate which is the given number of civil months after the date represented by the receiver, preserving the same civil time-of-day.   The dayOfMonth in the new CalendricalCoordinate will be the same as in the receiver, unless it would be invalid.  For example, if the orignal date is March 31, the dayOfMonth in the answered CalendricalCoordinate will also be 31, unless the month of the answered DateAndTime has less than 31 days.  In such a case, the answered CalendricalCoordinate's dayOfMonth will be the last day of its month.	If &lt;months&gt; is negative, then the semantics are not quite as described above, but will conform to the specification for #subtracingMonths:, with &lt;months&gt; negated.	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal."	months = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^self asMutableDate 		addMonths: months;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingSeconds:">addingSeconds: seconds	"Answer a CalendricalCoordinate which is the given number of scientific seconds after the timepoint represented by the receiver. The scientific semantics of a timepoint S seconds from another will be respected (UTC)."	seconds = 0 ifTrue: [^self isMutable ifTrue: [self asMutableTimeOfDay] ifFalse: [self]].	^(self asMutableTimeOfDay)		addSeconds: seconds;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingSeconds:nanoseconds:">addingSeconds: seconds nanoseconds: nanoseconds 	"Answer a CalendricalCoordinate which is the given number of scientific seconds and nanoseconds after the timepoint represented by the receiver. The scientific semantics of a timepoint S seconds and N nanoseconds from another will be respected (UTC)."	nanoseconds = 0 ifTrue: [^self addingSeconds: seconds].	^(self asMutableTimeOfDay)		addSeconds: seconds nanoseconds: nanoseconds;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:">addingYears: years	"Answer a new CalendricalCoordinate whose date is the given number of civil years after the date represented by the receiver, and which has the same civil time-of-day.  The civil intra-year date of the answered CalendricalCoordinate will be the same as that of the receiver, unless it would be invalid.  For example, if the orignal date is March 1 in a Gregorian/Julian leap year, the date in the new year will remain March 1 after adding the specified years.  However, if the original date is February 29 and the new year is not a leap year, then the new date will be Feb 28.  	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal.  If intercalary months may occur at times other than the end of the year, the Calendar system's cultural tradition will be respected regarding the semantics of 'same civil date N years later (or earlier.)'  The implementation assumes that the only issue in that respect is whether or not 'same month' is defined by the monthOrdinal or by the monthKey (by definition of a Chronos monthKey, months with the same monthKey are semantically the same month, regardless of possibly having different monthOrdinals in different years--which does happen in some Calendars!.)"	years = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^self asMutableDate 		addYears: years;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:">addingYears: years months: months	"Answer a new CalendricalCoordinate which is the given number of civil years and months after the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years and M civil months away from another date' will be respected.	See the specifications/comments for #addingYears: abd #addingMonths:for more detailed/precise semantics."	months = 0 ifTrue: [^self addingYears: years].	^self asMutableDate		addYears: years months: months days: 0;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:">addingYears: years months: months days: days	"Answer a new CalendricalCoordinate which is the given number of civil years, months and days after the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years, M civil months and D civil days away from another date' will be respected.	See the specifications/comments for #addingYears:, #addingMonths: and #addingDays: for more detailed/precise semantics."	days = 0 ifTrue: [^self addingYears: years months: months].	^self asMutableDate		addYears: years months: months days: days;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:hours:minutes:seconds:nanoseconds:">addingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	^(self asMutableDateAndTime)		addYears: years		months: months 		days: days		hours: hours		minutes: minutes		seconds: seconds		nanoseconds: nanoseconds;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:seconds:nanoseconds:">addingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds 	"Answer a new CalendricalCoordinate which is the given number of civil years, months, days, seconds and nanoseconds after the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years, M civil months and D civil days away from another date' will be respected. The scientific semantics of a timepoint S seconds and N nanoseconds from another will be respected (UTC).	See the specifications/comments for #addingYears:, #addingMonths:, #addingDays: and #addingSeconds:nanoseconds: for more detailed/precise semantics."	^(seconds = 0 and: [nanoseconds = 0]) 		ifTrue: 			[(self asMutableDate)				addYears: years					months: months					days: days;				beImmutable]		ifFalse: 			[(self asMutableDateAndTime)				addYears: years					months: months					days: days;				addSeconds: seconds nanoseconds: nanoseconds;				beImmutable]</body><body package="Chronos-DateTimeInterval" selector="daysSince:">daysSince: aTemporalCoordinate	^0</body><body package="Chronos-DateTimeInterval" selector="daysUntil:">daysUntil: aTemporalCoordinate	^0</body><body package="Chronos-DateTimeInterval" selector="durationSince:">durationSince: aTemporalCoordinate	^aTemporalCoordinate durationUntilTimeOfDay: self</body><body package="Chronos-DateTimeInterval" selector="durationUntil:">durationUntil: aTemporalCoordinate	^aTemporalCoordinate durationSinceTimeOfDay: self</body><body package="Chronos-DateTimeInterval" selector="scientificDurationSince:">scientificDurationSince: aTemporalCoordinate	^self class durationFactory		seconds: (self basicSecondsSince: aTemporalCoordinate)		nanoseconds: self nanosecondsSinceSecond - aTemporalCoordinate nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="scientificDurationUntil:">scientificDurationUntil: aTemporalCoordinate	^self class durationFactory		seconds: (self basicSecondsUntil: aTemporalCoordinate)		nanoseconds: aTemporalCoordinate nanosecondsSinceSecond - self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="secondsSince:">secondsSince: aTemporal	| seconds |	seconds := self basicSecondsSince: aTemporal.	^(self basicNanosecondsSinceSecondSince: aTemporal) &gt;= 0 		ifTrue: [seconds]		ifFalse: [seconds - 1]</body><body package="Chronos-DateTimeInterval" selector="secondsUntil:">secondsUntil: aTemporal	| seconds |	seconds := self basicSecondsUntil: aTemporal.	^(self basicNanosecondsSinceSecondUntil: aTemporal ) &gt;= 0 		ifTrue: [seconds]		ifFalse: [seconds - 1]</body><body package="Chronos-DateTimeInterval" selector="subtractingDays:">subtractingDays: days	"Answer a new CalendricalCoordinate which is the given number of civil days before the date represented by the receiver, preserving the same civil time-of-day."	^self addingDays: days negated</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:">subtractingHours: hours	hours = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTime] ifFalse: [self]].	^(self asMutableDateAndTime)		addHours: hours negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:">subtractingHours: hours minutes: minutes	minutes = 0 ifTrue: [^self subtractingHours: hours].	^(self asMutableTimeOfDay)		addHours: hours negated minutes: minutes negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:seconds:">subtractingHours: hours minutes: minutes seconds: seconds	seconds = 0 ifTrue: [^self subtractingHours: hours minutes: minutes].	^(self asMutableDateAndTime)		addHours: hours negated minutes: minutes negated seconds: seconds negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:seconds:nanoseconds:">subtractingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	nanoseconds = 0 ifTrue: [^self subtractingHours: hours minutes: minutes seconds: seconds].	^(self asMutableDateAndTime)		addHours: hours negated		minutes: minutes negated		seconds: seconds negated		nanoseconds: nanoseconds negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingMinutes:">subtractingMinutes: minutes	minutes = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTime] ifFalse: [self]].	^(self asMutableDateAndTime)		addMinutes: minutes negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingMonths:">subtractingMonths: months	"Answer a CalendricalCoordinate which is the given number of civil months before the date represented by the receiver, preserving the same civil time-of-day.   The dayOfMonth in the new CalendricalCoordinate will be the same as in the receiver, unless it would be invalid.  For example, if the orignal date is March 31, the dayOfMonth in the answered CalendricalCoordinate will also be 31, unless the month of the answered DateAndTime has less than 31 days.  In that case,  the dayOfMonth of the answered CalendricalCoordinate will be the last day of its month.	If &lt;months&gt; is negative, then the semantics are not quite as described above, but will conform to the specification for #addingMonths:, with &lt;months&gt; negated.	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal."	months = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^self asMutableDate 		addMonths: months negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingSeconds:">subtractingSeconds: seconds	"Answer a TemporalCoordinate which is the given number of scientific seconds before the timepoint represented by the receiver. The scientific semantics of a timepoint S seconds from another will be respected (UTC)."	seconds = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTime] ifFalse: [self]].	^(self asMutableDateAndTime)		addSeconds: seconds negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingSeconds:nanoseconds:">subtractingSeconds: seconds nanoseconds: nanoseconds	"Answer a TemporalCoordinate which is the given number of scientific seconds and nanoseconds before the timepoint represented by the receiver. The scientific semantics of a timepoint S seconds and N nanoseconds from another will be respected (UTC)."	nanoseconds = 0 ifTrue: [^self subtractingSeconds: seconds].	^(self asMutableDateAndTime)		addSeconds: seconds negated nanoseconds: nanoseconds negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:">subtractingYears: years	"Answer a new CalendricalCoordinate whose date is the given number of civil years before the date represented by the receiver, and which has the same civil time-of-day.  The civil intra-year date of the answered CalendricalCoordinate will be the same as that of the receiver, unless it would be invalid.  For example, if the orignal date is March 1 in a Gregorian/Julian leap year, the date in the new year will remain March 1 after subtracting the specified years.  However, if the original date is February 29 and the new year is not a leap year, then the new date will be Feb 28. 	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal.  If intercalary months may occur at times other than the end of the year, the Calendar system's cultural tradition will be respected regarding the semantics of 'same civil date N years later (or earlier.)'  The implementation assumes that the only issue in that respect is whether or not 'same month' is defined by the monthOrdinal or by the monthKey (by definition of a Chronos monthKey, months with the same monthKey are semantically the same month, regardless of possibly having different monthOrdinals in different years--which does happen in some Calendars!.)"	years = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^self asMutableDate 		addYears: years negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:">subtractingYears: years months: months	"Answer a new CalendricalCoordinate which is the given number of civil years and months before the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years and M civil months away from another date' will be respected.	See the specifications/comments for #addingYears: and #addingMonths: for more detailed/precise semantics."	months = 0 ifTrue: [^self subtractingYears: years].	^self asMutableDate		addYears: years negated 		months: months negated 		days: 0;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:">subtractingYears: years months: months days: days	"Answer a new CalendricalCoordinate which is the given number of civil years, months and days before the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years, M civil months and D civil days away from another date' will be respected.	See the specifications/comments for #addingYears:, #addingMonths: and #addingDays: for more detailed/precise semantics."	days = 0 ifTrue: [^self subtractingYears: years months: months].	^self asMutableDate		addYears: years negated 		months: months negated 		days: days negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:hours:minutes:seconds:nanoseconds:">subtractingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	^(self asMutableDateAndTime)		addYears: years negated		months: months negated		days: days negated		hours: hours negated		minutes: minutes negated		seconds: seconds negated		nanoseconds: nanoseconds negated;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:seconds:nanoseconds:">subtractingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds	"Answer a new CalendricalCoordinate which is the given number of civil years, months, days, seconds and nanoseconds before the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years, M civil months and D civil days away from another date' will be respected. The scientific semantics of a timepoint S seconds and N nanoseconds from another will be respected (UTC).	See the specifications/comments for #subtractingYears:, #subtractingMonths:, #subtractingDays: and #subtractingSeconds:nanoseconds: for more detailed/precise semantics."	^(seconds = 0 and: [nanoseconds = 0]) 		ifTrue: 			[(self asMutableDate)				addYears: years negated					months: months negated					days: days negated;				beImmutable]		ifFalse: 			[(self asMutableDateAndTime)				addYears: years negated					months: months negated					days: days negated;				addSeconds: seconds negated nanoseconds: nanoseconds negated;				beImmutable]</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondSince:">basicNanosecondsSinceSecondSince: aTemporal	^self isInvariantToUT		ifTrue: [aTemporal basicNanosecondsSinceSecondUntilUT: self]		ifFalse: [aTemporal basicNanosecondsSinceSecondUntilNominal: self]</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondSinceNominal:">basicNanosecondsSinceSecondSinceNominal: aTemporal	^self nanosecondsSinceSecond - aTemporal nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondSinceUT:">basicNanosecondsSinceSecondSinceUT: aTemporal	^self nanosecondsSinceSecond - aTemporal nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondUntil:">basicNanosecondsSinceSecondUntil: aTemporal 	^self isInvariantToUT		ifTrue: [aTemporal basicNanosecondsSinceSecondSinceUT: self]		ifFalse: [aTemporal basicNanosecondsSinceSecondSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondUntilNominal:">basicNanosecondsSinceSecondUntilNominal: aTemporal 	^aTemporal nanosecondsSinceSecond - self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondUntilUT:">basicNanosecondsSinceSecondUntilUT: aTemporal 	^aTemporal nanosecondsSinceSecond - self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSince:">basicSecondsSince: aTemporal	^aTemporal basicSecondsSinceStartOfDayUntil: self</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochSinceNominal:">basicSecondsSinceEpochSinceNominal: aDateAndTimeInvariantToNominalTime	^self secondsSinceStartOfDay - aDateAndTimeInvariantToNominalTime secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochSinceUT:">basicSecondsSinceEpochSinceUT: aDateAndTimeInvariantToUT	^self secondsSinceStartOfDay - aDateAndTimeInvariantToUT secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochUntilNominal:">basicSecondsSinceEpochUntilNominal: aDateAndTimeInvariantToNominalTime	^aDateAndTimeInvariantToNominalTime secondsSinceStartOfDay - self secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochUntilUT:">basicSecondsSinceEpochUntilUT: aDateAndTimeInvariantToUT	^aDateAndTimeInvariantToUT secondsSinceStartOfDay - self secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceStartOfDaySince:">basicSecondsSinceStartOfDaySince: aTimeOfDay	^self secondsSinceStartOfDay - aTimeOfDay secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceStartOfDayUntil:">basicSecondsSinceStartOfDayUntil: aTimeOfDay	^aTimeOfDay secondsSinceStartOfDay - self secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="basicSecondsUntil:">basicSecondsUntil: aTemporal	^aTemporal basicSecondsSinceStartOfDaySince: self</body><body package="Chronos-DateTimeInterval" selector="durationSinceDate:">durationSinceDate: aDate	^self civilDurationSince: aDate</body><body package="Chronos-DateTimeInterval" selector="durationSinceDateAndTime:">durationSinceDateAndTime: aDateAndTime	^self scientificDurationSince: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="durationSinceTimeOfDay:">durationSinceTimeOfDay: aTimeOfDay	^self scientificDurationSince: aTimeOfDay</body><body package="Chronos-DateTimeInterval" selector="durationUntilDate:">durationUntilDate: aDate	^self civilDurationUntil: aDate</body><body package="Chronos-DateTimeInterval" selector="durationUntilDateAndTime:">durationUntilDateAndTime: aDateAndTime	^self scientificDurationUntil: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="durationUntilTimeOfDay:">durationUntilTimeOfDay: aTimeOfDay	^self scientificDurationUntil: aTimeOfDay</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>deprecated</category><body package="Chronos-DateTimeInterval" selector="upTo:">upTo: limitValue 	"Deprecated. See #to:"	^self to: limitValue</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>private-time zone operations</category><body package="Chronos-DateTimeInterval" selector="basicTimeZone">basicTimeZone	^ChronosTimezone nominal</body><body package="Chronos-DateTimeInterval" selector="offsetSecondsFromUT">offsetSecondsFromUT	^self timeZone 		netSecondsAfterAddingOffsetFromUTToSeconds: 0		nanosecondsSinceSecond: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="unbindTimeZone">unbindTimeZone	"By default, do nothing"</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>parameter validation</category><body package="Chronos-DateTimeInterval" selector="validateHour:minute:second:">validateHour: hour minute: minute second: second	HoursSinceStartOfDayRangeConstraint assertValid: hour.	MinutesSinceHourRangeConstraint assertValid: minute.	SecondsSinceMinuteRangeConstraint assertValid: second.	hour = 24 		ifTrue: 			[(second = 0 and: [minute = 0]) 				ifFalse: 					[self signalInvalidArgument: #hour:minute:second:						value: (Array with: hour with: minute with: second)]].</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>INTER-period-stream protocol</category><body package="Chronos-DateTimeInterval" selector="next">next	"Answer a Timeperiod whose starting point-in-time is the receiver's limit value (end-point,) and whose temporal extent (duration) is the same as the receiver's.  See the class comment for the definition of these terms."	^self + self resolutionQuantum</body><body package="Chronos-DateTimeInterval" selector="prev">prev	"Answer a Timeperiod whose starting point-in-time is computed by subtracting the receiver's temporal extent (duration) from its starting point-in-time, and whose temporal extent (duration) is the same as the receiver's.  See the class comment for the definition of these terms."	"{Timeperiod currentHour prev}"	"{Timeperiod today prev}"	"{Timeperiod currentWeek prev}"	"{Timeperiod currentMonth prev}"	"{Timeperiod currentYear prev}"	^self - self resolutionQuantum</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>accessing-UT</category><body package="Chronos-DateTimeInterval" selector="utFractionalTimeOfDay">utFractionalTimeOfDay	^ScaledDecimal		numerator: self utNanosecondsSinceStartOfDay		denominator: NanosecondsPerDay		scale: 9</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceSecond">utNanosecondsSinceSecond	^0</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceStartOfDay">utNanosecondsSinceStartOfDay	^self utSecondsSinceStartOfDay * NanosecondsPerSecond + self utNanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceStartOfDay">utSecondsSinceStartOfDay	^self timeZone 		netSecondsAfterSubtractingOffsetFromUTFromSeconds: self basicSecondsSinceStartOfDay		nanosecondsSinceSecond: self basicNanosecondsSinceSecond</body></methods><methods><class-id>Chronos.TemporalCoordinate</class-id> <category>examples</category><body package="Chronos-DateTimeInterval" selector="inAllCalendars">inAllCalendars	"YearMonthDay today inAllCalendars"	| allCalendars |	allCalendars := Calendar allRegisteredKeys asSortedCollection: [:a :b | a == #Gregorian ifTrue: [true] ifFalse: [b == #Gregorian ifTrue: [false] ifFalse: [a &lt; b]]].	^self asAll: allCalendars</body><body package="Chronos-DateTimeInterval" selector="inAllTimeZones">inAllTimeZones	"INSPECT IT: 		{(Timepoint 			year: 2001 			month: September 			day: 11 			hour: 8			minute: 42			second: 26			timeZone: #'America/New_York') inAllTimeZones}"	"INSPECT IT: 		{(Timepoint 			year: 1941 			month: December 			day: 7 			hour: 7			minute: 55			second: 0			timeZone: #'Pacific/Honolulu')  inAllTimeZones}"	| inAllTimezones map |	inAllTimezones := self inAll: ChronosTimezone allRegisteredKeys asArray.	map := Dictionary new.	inAllTimezones do: 		[:timepoint | 			map 				at: '[', timepoint timeZone zuluNotation, '] ', timepoint timeZone identityString 				put: timepoint localePrintString].	^map</body><body package="Chronos-DateTimeInterval" selector="inAllTimeZonesAndCalendars">inAllTimeZonesAndCalendars	"INSPECT IT: 		{(Timepoint 			year: 2001 			month: September 			day: 11 			hour: 8			minute: 42			second: 26			timeZone: #'America/New_York') inAllTimeZonesAndCalendars}"	"INSPECT IT: 		{(Timepoint 			year: 1941 			month: December 			day: 7 			hour: 7			minute: 55			second: 0			timeZone: #'Pacific/Honolulu') inAllTimeZonesAndCalendars}"	| inAllTimezones map allCalendars printPolicy |	allCalendars := Calendar allRegisteredKeys asSortedCollection: [:a :b | a == #Gregorian ifTrue: [true] ifFalse: [b == #Gregorian ifTrue: [false] ifFalse: [a &lt; b]]].	inAllTimezones := self inAll: ChronosTimezone allCanonicalKeys asArray.	printPolicy := ChronosPrintPolicy rfc2822 apply: #(showEraNameAfterDate dateAndTimeSeparator: ' @ ' use12HourFormat hourPadChar: nil showTimeZoneAbbreviation).	map := Dictionary new.	inAllTimezones do: 		[:timepoint | 			| stream timezone |			timezone := timepoint timeZone.			stream := String new writeStream.			timezone specifiesGeographicCoordinates				ifTrue: 					[stream						nextPutAll: 'Geographic coordinates: ';						print: timezone geographicCoordinates;						cr].			stream nextPutAll: 'Julian Date: '.			ChronosFunction				printFractional: timepoint utJulianDate asDecimalOn: stream decimalPoint: $. precision: 9.			stream nextPutAll: ' (Universal Time)'; cr.			(timepoint asAll: allCalendars) 				do: [:each | 					each printOn: stream using: printPolicy.					stream 						nextPutAll: ' ['.					ChronosFunction						printFractional: each fractionalDaysSinceEpoch asDecimalOn: stream decimalPoint: $. precision: 3.					stream						nextPutAll: ' days since ';						nextPutAll: each calendar name;						nextPutAll: ' Epoch]';						cr].			map 				at: '[', timezone zuluNotation, '] ', timezone identityString				put: stream contents].	^map</body><body package="Chronos-DateTimeInterval" selector="showInAllCalendars">showInAllCalendars	"(DateAndTimeFactory utYear: 1969 month: 7 day: 20 seconds: 37060 nanoseconds: 0) showInAllCalendars"	"HebrewCalendar clock now showInAllCalendars"	| printPolicy policySpec |	Transcript cr.	self inAllCalendars do: [:each | Transcript cr; show: (each printStringUsing: #universal)].	policySpec := #(#standardCalendarRegistrationKey: nil #useOrdinalDate #dateAndTimeSeparator: ' @ ' timeOfDayPrefix: nil hourPadChar: nil #use12HourFormat #hideSubsecondFraction #timeZoneSeparator: $  #timeZoneElementSeparator: nil) copy.	policySpec at: 2 put: self calendarRegistrationKey.	printPolicy := ChronosPrintPolicy applying: policySpec.	Transcript		cr;		show: (self printStringUsing: printPolicy);		show: ' [';		show: self calendar name;		show: '-ordinal date]'.	printPolicy := printPolicy apply: #(#useISOWeekOfYearDayOfWeek).	Transcript		cr;		show: (self printStringUsing: printPolicy);		show: ' [ISO]'.	printPolicy := printPolicy apply: #(#showDateAsJulianDay).	Transcript		cr;		show: (self printStringUsing: printPolicy);		show: ' [Julian Day]'.	Transcript		cr;		show: (self - ChronosSystemClock st80Epoch) printString;		show: ' days:hh:mm:ss.s.. since 1901-01-01T00:00:00Z (ST80 epoch)'.	Transcript		cr;		show: (self secondsSince: ChronosSystemClock unixEpoch) printString;		show: ' seconds since 1970-01-01T00:00:00Z (Unix epoch)'.	Transcript		cr;		show: ((self nanosecondsSince: ChronosSystemClock msWindowsNTEpoch) // 100) printString;		show: ' 100-nanosecond ticks since 1601-01-01T00:00:00Z (MS WIndows epoch)'.	SemanticDatePolicy default semanticKeysFor: self do: [:semanticKey | 		Transcript cr; tab; show: semanticKey.		semanticKey == #weekend 			ifTrue: [Transcript show: ' ('; show: self dayOfWeekName; show: ')']].	Transcript cr</body><body package="Chronos-DateTimeInterval" selector="showInCommonWorldTimezones">showInCommonWorldTimezones	"Timepoint now showInCommonWorldTimezones"	| printPolicy |	printPolicy := ChronosPrintPolicy rfc2822v.	Transcript cr.	(self inAll: ChronosTimezone commonWorldTimezones) do: 		[:each | 			Transcript 				cr; 				show: (each printStringUsing: printPolicy)]</body></methods><methods><class-id>Chronos.TemporalCoordinate class</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="clockPrecision">clockPrecision	"Answer a Duration whose value indicates the precision of the current ChronosSystemClock.  The precision of a clock is the average time interval between updates to the clock's tick count.  The 'tick size' of a clock is the minimum time interval that notationally can be represented by the clock's time counter (the clock's 'tick size' is also called the 'clock resolution.')"	"This method is required by the ANSI Smalltalk standard (which omits any mention of the clock's resolution, which is at least as important an issue as the clock's precision, especially because a) it establishes a hard limit to precision, and b) on any given platform, it is much less likely to change over time as the hardware and system software of that platform evolves.)"	"{TemporalCoordinate clockPrecision}"	^AnsiStandardCalendarClock precision</body></methods><methods><class-id>Chronos.TemporalCoordinate class</class-id> <category>class initialization</category><body package="Chronos-DateTimeInterval" selector="defineRangeConstraints">defineRangeConstraints	"TemporalCoordinate defineRangeConstraints."	NanosecondsSinceSecondRangeConstraint := 		RangeConstraint 			semanticKey: #nanosecondsSinceSecond			minValidValue: 0			maxValidValue: NanosecondsPerSecond - 1.	SecondsSinceStartOfDayRangeConstraint := 		RangeConstraint 			semanticKey: #secondsSinceStartOfDay			minValidValue: 0			maxValidValue: SecondsPerDay.	SecondsSinceMinuteRangeConstraint := 		RangeConstraint 			semanticKey: #second			minValidValue: 0			maxValidValue: SecondsPerMinute. "Leap seconds"	MinutesSinceHourRangeConstraint := 		RangeConstraint 			semanticKey: #minute			minValidValue: 0			maxValidValue: MinutesPerHour - 1.	HoursSinceStartOfDayRangeConstraint :=		RangeConstraint 			semanticKey: #hour			minValidValue: 0			maxValidValue: HoursPerDay - 1.</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="ansiDayOfWeekOrdinal">ansiDayOfWeekOrdinal	^self calendar ansiDayOfWeekOrdinalFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="calendarDay">calendarDay	^self dateSpec calendarDay</body><body package="Chronos-DateTimeInterval" selector="centuryPeriod">centuryPeriod	"YearMonthDay today centuryPeriod"	"DateAndTimeFactory now centuryPeriod"	^self class timeperiodFactory 		from: (self start subtractingYears: (self year \\ 100) - 1 months: 0 days: self dayOfYear - 1) 		duration: (self class calendarDurationFactory years: 100)</body><body package="Chronos-DateTimeInterval" selector="dayOfMonth">dayOfMonth	"Specified and required by the ANSI-Smalltalk Standard."	^self calendarDay dayOfMonth</body><body package="Chronos-DateTimeInterval" selector="dayOfMonthOrdinal">dayOfMonthOrdinal	^self calendarDay dayOfMonthOrdinal</body><body package="Chronos-DateTimeInterval" selector="dayOfWeek">dayOfWeek	"Specified and required by the ANSI-Smalltalk Standard."	^self calendar dayOfWeekOrdinalFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="dayOfWeekAbbreviation">dayOfWeekAbbreviation	"Specified and required by the ANSI-Smalltalk Standard."	^ChronosLocale default abbreviationAtSemanticKey: self dayOfWeekKey</body><body package="Chronos-DateTimeInterval" selector="dayOfWeekKey">dayOfWeekKey	^ANSIDayOfWeekKeys at: self ansiDayOfWeekOrdinal</body><body package="Chronos-DateTimeInterval" selector="dayOfWeekName">dayOfWeekName	"Specified and required by the ANSI-Smalltalk Standard."	^ChronosLocale default properNameAtSemanticKey: self dayOfWeekKey</body><body package="Chronos-DateTimeInterval" selector="dayOfYear">dayOfYear	^self calendarDay dayOfYearOrdinal</body><body package="Chronos-DateTimeInterval" selector="dayOfYearOrdinal">dayOfYearOrdinal	^self calendarDay dayOfYearOrdinal</body><body package="Chronos-DateTimeInterval" selector="dayPeriod">dayPeriod	"YearMonthDay today dayPeriod"	"DateAndTimeFactory now dayPeriod"	^self class timeperiodFactory  		from: self start 		duration: CalendarDayDuration</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch">daysSinceEpoch	^self basicComputeDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpochUpToYear">daysSinceEpochUpToYear	^self daysSinceEpoch - self daysSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfANSIWeek">daysSinceStartOfANSIWeek	^self calendar daysSinceStartOfANSIWeekFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfISOWeek">daysSinceStartOfISOWeek	^self calendar daysSinceStartOfISOWeekFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfMonth">daysSinceStartOfMonth	"Answer the number of days since the first day of the receiver's month up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the month represented by the receiver."	^self calendarDay daysSinceStartOfMonth</body><body package="Chronos-DateTimeInterval" selector="daysSinceStartOfYear">daysSinceStartOfYear	"Answer the number of days since the first day of the receiver's year up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the year represented by the receiver."	^self calendarDay daysSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="daysSinceUnificationEpoch">daysSinceUnificationEpoch	^self daysSinceEpoch + self calendar unificationDayNumberOfEpoch</body><body package="Chronos-DateTimeInterval" selector="decade">decade	"YearMonthDay today decade"	"DateAndTimeFactory now decade"	^self class timeperiodFactory  		from: (self start subtractingYears: (self year \\ 10) - 1 months: 0 days: self dayOfYear - 1) 		duration: (self class calendarDurationFactory years: 10)</body><body package="Chronos-DateTimeInterval" selector="eraName">eraName	^self calendar eraNameForYear: self year</body><body package="Chronos-DateTimeInterval" selector="fractionalDaysSinceEpoch">fractionalDaysSinceEpoch	"{(Duration days: (AnsiStandardCalendarClock now fractionalDaysSinceEpoch)) asDateAndTime}"	"{[:tp |		Array			with: tp			with: (DateAndTimeFactory secondsSinceEpoch: tp fractionalSecondsSinceEpoch)			with: (DateAndTimeFactory daysSinceEpoch: tp fractionalDaysSinceEpoch) 			with: (DateAndTimeFactory julianDay: tp julianDate)] value: DateAndTimeFactory now}"	^self daysSinceEpoch + self fractionalTimeOfDay</body><body package="Chronos-DateTimeInterval" selector="fractionalSecondsSinceEpoch">fractionalSecondsSinceEpoch	"{(Duration seconds: (AnsiStandardCalendarClock now fractionalSecondsSinceEpoch)) asDateAndTime}"	"{[:tp |		Array			with: tp			with: (DateAndTimeFactory secondsSinceEpoch: tp fractionalSecondsSinceEpoch)			with: (DateAndTimeFactory daysSinceEpoch: tp fractionalDaysSinceEpoch) 			with: (DateAndTimeFactory julianDay: tp julianDate)] value: DateAndTimeFactory now}"	^ScaledDecimal 		numerator: self nanosecondsSinceEpoch		denominator: NanosecondsPerSecond 		scale: 9</body><body package="Chronos-DateTimeInterval" selector="isoDayOfWeekOrdinal">isoDayOfWeekOrdinal	^self calendar isoDayOfWeekOrdinalFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="julianDate">julianDate	"{[:tp |		Array			with: tp			with: (DateAndTimeFactory secondsSinceEpoch: tp fractionalSecondsSinceEpoch)			with: (DateAndTimeFactory daysSinceEpoch: tp fractionalDaysSinceEpoch) 			with: (DateAndTimeFactory julianDay: tp julianDate)] value: DateAndTimeFactory now}"	^ScaledDecimal		numerator: (self nanosecondsSinceEpoch + (self calendar secondsSinceJulianDayEpochUpToEpoch * NanosecondsPerSecond))		denominator: NanosecondsPerDay		scale: 9</body><body package="Chronos-DateTimeInterval" selector="julianDay">julianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs (local time.) However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered (also local time.)"	^self calendar julianDayFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="julianDayNumber">julianDayNumber	"Answers the Julian Day Number of the Julian Day that starts at Noon on the date represented by the receiver (local time.)"	^self calendar julianDayFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="microsecondsSinceEpoch">microsecondsSinceEpoch	"{(Duration microseconds: (AnsiStandardCalendarClock dateToday microsecondsSinceEpoch)) asDateAndTime}"	^self secondsSinceEpoch * MicrosecondsPerSecond + self microsecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="milleniumPeriod">milleniumPeriod	"YearMonthDay today milleniumPeriod"	"DateAndTimeFactory now milleniumPeriod"	^self class timeperiodFactory  		from: (self start subtractingYears: (self year \\ 1000) - 1 months: 0 days: self dayOfYear - 1) 		duration: (self class calendarDurationFactory years: 1000)</body><body package="Chronos-DateTimeInterval" selector="millisecondsSinceEpoch">millisecondsSinceEpoch	"{(Duration milliseconds: (AnsiStandardCalendarClock dateToday millisecondsSinceEpoch)) asDateAndTime}"	^self secondsSinceEpoch * MillisecondsPerSecond + self millisecond</body><body package="Chronos-DateTimeInterval" selector="month">month	"Specified and required by the ANSI-Smalltalk Standard."	^self calendarDay month</body><body package="Chronos-DateTimeInterval" selector="monthAbbreviation">monthAbbreviation	"Specified and required by the ANSI-Smalltalk Standard."	^self 		forLocale: ChronosLocale default		monthAbbreviationIfResolvable: [:name | name]		ifNot: [self calendarDay monthAbbreviation]</body><body package="Chronos-DateTimeInterval" selector="monthKey">monthKey	^self calendarDay monthKey</body><body package="Chronos-DateTimeInterval" selector="monthName">monthName	"Specified and required by the ANSI-Smalltalk Standard."	^self 		forLocale: ChronosLocale default		monthNameIfResolvable: [:name | name]		ifNot: [self calendarDay monthName]</body><body package="Chronos-DateTimeInterval" selector="monthOrdinal">monthOrdinal	^self calendarDay monthOrdinal</body><body package="Chronos-DateTimeInterval" selector="monthPeriod">monthPeriod	"YearMonthDay today monthPeriod"	"YearMonthDay today monthPeriod last"	"YearMonthDay today monthPeriod addingMonths: 6"	"DateAndTimeFactory now monthPeriod"	^self class timeperiodFactory  		from: (self start subtractingDays: self dayOfMonth - 1)		duration: MonthDuration</body><body package="Chronos-DateTimeInterval" selector="monthlyCalendar">monthlyCalendar	"YearMonthDay today monthlyCalendar lastDay"	^self calendarDay monthlyCalendar</body><body package="Chronos-DateTimeInterval" selector="monthsSinceEpoch">monthsSinceEpoch	^(self calendar monthsSinceEpochUpToYear: self year) 		+ self monthsSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="monthsSinceStartOfYear">monthsSinceStartOfYear	^self calendarDay monthsSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceEpoch">nanosecondsSinceEpoch	"{(Duration nanoseconds: (AnsiStandardCalendarClock dateToday nanosecondsSinceEpoch)) asDateAndTime}"	^self secondsSinceEpoch * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceUnificationEpoch">nanosecondsSinceUnificationEpoch	^self secondsSinceUnificationEpoch * NanosecondsPerSecond + self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="numericMonthDesignator">numericMonthDesignator	"Answer the culturally-correct numerical label for the receiver's month (usually, this is the ordinal number of the month in the sequence of months since the month that begins a year, but such is not the case in all cultures.)"	^self calendar 		numericMonthDesignatorFromMonthOrdinal: self monthOrdinal		forYearTypeCode: self yearTypeCode</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch">secondsSinceEpoch	^(self daysSinceEpoch * 675 bitShift: 7) + self secondsSinceStartOfDay	"86400 = 128 * 675"</body><body package="Chronos-DateTimeInterval" selector="secondsSinceMidnight">secondsSinceMidnight	^self calendar midnightIsStartOfDay 		ifTrue: [self secondsSinceStartOfDay]		ifFalse: 			[(self calendar 				secondsSinceMidnightFromSecondsSinceStartOfDay: self secondsSinceStartOfDay) 					\\ self secondsInDay]</body><body package="Chronos-DateTimeInterval" selector="secondsSinceUnificationEpoch">secondsSinceUnificationEpoch	^self calendar secondsSinceUnificationEpochFromSecondsSinceEpoch: self secondsSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="timeZone">timeZone	"Answer the bound Timezone that has the correct offsetFromUT for the date and time represented by the receiver." 	| timeZone |	timeZone := self basicTimeZone.	^timeZone isBound		ifTrue: [timeZone binding]		ifFalse: 			[self gregorianLocalYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo: 					[:y :dayOfYear :sssodFunction | 					timeZone 						bindingForLocalYear: y						dayOfYear: dayOfYear						secondsSinceStartOfDayFunction: sssodFunction]]</body><body package="Chronos-DateTimeInterval" selector="weekOfMonthOrdinal">weekOfMonthOrdinal	"Answer the ordinal number of the week of the month in which the day represented by the receiver occurs.  The first seven days of the month are the first week of the month."	^self weeksSinceStartOfMonth + 1</body><body package="Chronos-DateTimeInterval" selector="weekOfYearOrdinal">weekOfYearOrdinal	"NOT ISO 8601"	^self weeksSinceStartOfYear + 1</body><body package="Chronos-DateTimeInterval" selector="weeksSinceStartOfMonth">weeksSinceStartOfMonth	"Answer the CARDINAL number of the week of the month in which the day represented by the receiver occurs.  The first seven days of the month are in the week whose CARDINAL number is zero."	^self daysSinceStartOfMonth // DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="weeksSinceStartOfYear">weeksSinceStartOfYear	"NOT ISO 8601"	^self daysSinceStartOfYear // DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="year">year	"Specified and required by the ANSI-Smalltalk Standard."	^self yearMonthDayDo: [:year :month :dayOfMonth | year]</body><body package="Chronos-DateTimeInterval" selector="yearCardinal">yearCardinal	^self calendar yearNumberingPolicy cardinalFromCanonical: self year</body><body package="Chronos-DateTimeInterval" selector="yearOrdinal">yearOrdinal	^self calendar yearNumberingPolicy ordinalFromCanonical: self year</body><body package="Chronos-DateTimeInterval" selector="yearPeriod">yearPeriod	"YearMonthDay today yearPeriod"	"DateAndTimeFactory now yearPeriod"	^self class timeperiodFactory  		from: (self start subtractingDays: self dayOfYear - 1) 		duration: YearDuration</body><body package="Chronos-DateTimeInterval" selector="yearTypeCode">yearTypeCode	^self calendarDay yearTypeCode</body><body package="Chronos-DateTimeInterval" selector="yearlyCalendar">yearlyCalendar	"YearMonthDay today yearlyCalendar"	^self calendarDay yearlyCalendar</body><body package="Chronos-DateTimeInterval" selector="yearsSinceEpoch">yearsSinceEpoch	^self yearCardinal</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>queries</category><body package="Chronos-DateTimeInterval" selector="@">@ timeOfDay	"(YearMonthDay year: 2006 month: 1 day: 31) @ (TimeOfDay hour: 12 minute: 0 second: 0)"	"GregorianEaster canonical @ TimeOfDay now"	^self yearAndCalendarDayDo: 			[:year :calendarDay | 			(self class dateAndTimeFactory basicNew)				setCalendar: self calendar;				basicSetTimeZone: self basicTimeZone;				basicSetYear: year calendarDay: calendarDay;				setTimeOfDay: timeOfDay;				canonicalizeFromLocalTime;				beImmutable]</body><body package="Chronos-DateTimeInterval" selector="atFirstDayOfMonth">atFirstDayOfMonth	"{YearMonthDay today atFirstDayOfMonth}"	^self withDayOfMonth: 1</body><body package="Chronos-DateTimeInterval" selector="atFirstDayOfWeek">atFirstDayOfWeek	"{YearMonthDay today atFirstDayOfWeek}"	| dayOfWeek |	^(dayOfWeek := self dayOfWeek) &gt; Sunday 		ifTrue: [self subtractingDays: dayOfWeek - Sunday]		ifFalse: [self]</body><body package="Chronos-DateTimeInterval" selector="atFirstDayOfYear">atFirstDayOfYear	"{YearMonthDay today atFirstDayOfYear}"	^self withDayOfYear: 1</body><body package="Chronos-DateTimeInterval" selector="atLastDayOfMonth">atLastDayOfMonth	"{YearMonthDay today  atLastDayOfMonth}"	^self withDayOfMonth: DayOfMonthFactory lastDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="atLastDayOfWeek">atLastDayOfWeek	"{YearMonthDay today atLastDayOfWeek}"	| dayOfWeek |	^(dayOfWeek := self dayOfWeek) &lt; Saturday 		ifTrue: [self addingDays: Saturday - dayOfWeek]		ifFalse: [self]</body><body package="Chronos-DateTimeInterval" selector="atLastDayOfYear">atLastDayOfYear	"{YearMonthDay today atLastDayOfYear}"	^self withDayOfYear: DayOfYearFactory lastDayOfYear</body><body package="Chronos-DateTimeInterval" selector="atStartOfDay">atStartOfDay	^self</body><body package="Chronos-DateTimeInterval" selector="atTimeOfDay:">atTimeOfDay: aTimeOfDay	"YearMonthDay today atTimeOfDay: TimeOfDay now"	"Timepoint today atTimeOfDay: TimeOfDay now"	"GregorianEaster canonical atTimeOfDay: (TimeOfDay hour: 12 minute: 0 second: 0)"	^self @ aTimeOfDay</body><body package="Chronos-DateTimeInterval" selector="atTimeOfDay:in:">atTimeOfDay: aTimeOfDay in: timeZone	"YearMonthDay today atTimeOfDay: TimeOfDay now in: 'Europe/Moscow'"	"Timepoint today atTimeOfDay: TimeOfDay now in: 'America/Denver'"	"GregorianEaster canonical atTimeOfDay: (TimeOfDay hour: 12 minute: 0 second: 0)in: 'Asia/Tashkent'"	^self yearAndCalendarDayDo: 			[:year :calendarDay | 			(self class dateAndTimeFactory basicNew)				setCalendar: self calendar;				setTimeZone: timeZone;				basicSetYear: year calendarDay: calendarDay;				setTimeOfDay: aTimeOfDay;				canonicalizeFromLocalTime;				beImmutable]</body><body package="Chronos-DateTimeInterval" selector="daysInMonth">daysInMonth	^self calendarDay daysPerMonth</body><body package="Chronos-DateTimeInterval" selector="daysInYear">daysInYear	^self calendarDay daysPerYear</body><body package="Chronos-DateTimeInterval" selector="forLocale:monthAbbreviationIfResolvable:ifNot:">forLocale: aChronosLocale monthAbbreviationIfResolvable: resolvable ifNot: notResolvable 	"Evaluate &lt;resolvable&gt; with the abbreviation of the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self calendarDay forLocale: aChronosLocale monthAbbreviationIfResolvable: resolvable ifNot: notResolvable</body><body package="Chronos-DateTimeInterval" selector="forLocale:monthNameIfResolvable:ifNot:">forLocale: aChronosLocale monthNameIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKkey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self calendarDay forLocale: aChronosLocale monthNameIfResolvable: resolvable ifNot: notResolvable</body><body package="Chronos-DateTimeInterval" selector="inYear:">inYear: aYear 	"YearMonthDay today inYear: 1950"	"(YearMonthDay year: 1 month: 7 day: 3 calendar: Julian) inYear: -1"	"(YearMonthDay year: 2000 month: 2 day: 29)  inYear: 1999"	aYear = self year ifTrue: [^self].	^self addingYears: (self calendar yearNumberingPolicy ordinalFromCanonical: aYear) - self yearOrdinal</body><body package="Chronos-DateTimeInterval" selector="monthKeyIfResolvable:ifNot:">monthKeyIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the key that semantically identifies the receiver's month as the sole argument. However, if the month's semantic key is not unambiguously resolvable, answer the result of evaluationg &lt;notResolvable&gt;. Answer the result of the evaluated block."	^resolvable value: self monthKey</body><body package="Chronos-DateTimeInterval" selector="monthsInYear">monthsInYear	^self calendarDay monthsPerYear</body><body package="Chronos-DateTimeInterval" selector="withDayOfMonth:">withDayOfMonth: dayOfMonthOrdinal	"YearMonthDay today withDayOfMonth: 7"	"(YearMonthDay year: 1 month: 7 day: 30 calendar: Julian) withDayOfMonth: 1"	"(YearMonthDay year: 2000 month: 2 day: 1) withDayOfMonth: 0"	| myDayOfMonth |	myDayOfMonth := self dayOfMonth.	myDayOfMonth = dayOfMonthOrdinal ifTrue: [^self].	^self addingDays: 		(dayOfMonthOrdinal &gt; 0 			ifTrue: [dayOfMonthOrdinal - myDayOfMonth]			ifFalse: [(self daysInMonth + dayOfMonthOrdinal) - myDayOfMonth])</body><body package="Chronos-DateTimeInterval" selector="withDayOfYear:">withDayOfYear: dayOfYear 	"YearMonthDay today withDayOfYear: 182"	"(YearMonthDay year: 1 month: 7 day: 3 calendar: Julian) withDayOfYear: 1"	"(YearMonthDay year: 2000 month: 2 day: 29) withDayOfYear: -1"	| myDayOfYear |	myDayOfYear := self dayOfYear.	myDayOfYear = dayOfYear ifTrue: [^self].	^self addingDays: 		(dayOfYear &gt; 0 			ifTrue: [dayOfYear - myDayOfYear]			ifFalse: [(self daysInYear + dayOfYear) - myDayOfYear])</body><body package="Chronos-DateTimeInterval" selector="withMonth:">withMonth: monthOrdinal	"YearMonthDay today withMonth: 7"	"(YearMonthDay year: 1 month: 7 day: 3 calendar: Julian) withMonth: 1"	"(YearMonthDay year: 2000 month: 2 day: 29) withMonth: -1"	| myMonth |	myMonth := self month.	myMonth = monthOrdinal ifTrue: [^self].	^self addingMonths: 		(monthOrdinal &gt; 0 			ifTrue: [monthOrdinal - myMonth]			ifFalse: [(self monthsInYear + monthOrdinal) - myMonth])</body><body package="Chronos-DateTimeInterval" selector="withMonth:day:">withMonth: monthOrdinal day: dayOfMonthOrdinal	"YearMonthDay today withMonth: 7 day: 31"	"(YearMonthDay year: 1 month: 7 day: 3 calendar: Julian) withMonth: 1 day: 1"	"(YearMonthDay year: 2000 month: 2 day: 29) withMonth: -1 day: 0"	| calendarDay month dayOfMonth monthlyCalendar |	calendarDay := self calendarDay.	month := calendarDay monthOrdinal.	dayOfMonth := calendarDay dayOfMonthOrdinal.	month := (monthOrdinal &gt; 0 					ifTrue: [monthOrdinal]					ifFalse: [calendarDay monthsPerYear + monthOrdinal]).	monthlyCalendar := calendarDay yearlyCalendar monthAt: month.	dayOfMonth := (dayOfMonthOrdinal &gt; 0 							ifTrue: [dayOfMonthOrdinal]							ifFalse: [monthlyCalendar daysPerMonth + dayOfMonthOrdinal]).	^self withDayOfYear: (monthlyCalendar dayAt: dayOfMonth) dayOfYear</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="basicComputeDaysSinceEpoch">basicComputeDaysSinceEpoch	^self basicDaysSinceEpochUpToYear + self basicDaysSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="basicDaysSinceEpoch">basicDaysSinceEpoch	^self basicComputeDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="basicDaysSinceEpochUpToYear">basicDaysSinceEpochUpToYear	^self calendar daysSinceEpochUpToYear: self year</body><body package="Chronos-DateTimeInterval" selector="basicDaysSinceStartOfYear">basicDaysSinceStartOfYear	^self calendarDay daysSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="basicDaysSinceUnificationEpoch">basicDaysSinceUnificationEpoch	^self basicDaysSinceEpoch + self calendar unificationDayNumberOfEpoch</body><body package="Chronos-DateTimeInterval" selector="basicEnsureYearAndCalendarDayAreSet">basicEnsureYearAndCalendarDayAreSet	"By default, do nothing"</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpoch">basicSecondsSinceEpoch	^(ChronosFunction secondsFromDays: self basicDaysSinceEpoch) + self basicSecondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceUnificationEpoch">basicSecondsSinceUnificationEpoch	^self calendar secondsSinceUnificationEpochFromSecondsSinceEpoch: self basicSecondsSinceEpoch</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="eitherMonthOrdinalDo:orMonthkeyDo:">eitherMonthOrdinalDo: block1a orMonthkeyDo: block1b	"If the receiver's month ordinal is unambigously specified, evaluate &lt;block1a&gt; with the receiver's month ordinal. Otherwise, evaluate &lt;block1b&gt; with the semantic key that identifies the receiver's month."	^block1a value: self monthOrdinal</body><body package="Chronos-DateTimeInterval" selector="eitherYearMonthDayDo:orYearMonthkeyDayDo:">eitherYearMonthDayDo: block3a orYearMonthkeyDayDo: block3b	"If the receiver's month ordinal is unambigously specified, evaluate &lt;block3a&gt; with the receiver's year, its month ordinal and its day-of-month ordinal as the arguments. Otherwise, evaluate &lt;block3b&gt; with the receiver's year,  the semantic key that identifies the receiver's month and its day-of-month ordinal as the arguments."	^self yearMonthDayDo: block3a</body><body package="Chronos-DateTimeInterval" selector="isoYearWeekDayOfWeekDo:">isoYearWeekDayOfWeekDo: block3	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"{(DateAndTime year: 2003 month: 12 day: 28) isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | Array with: isoYear with: isoWeek with: isoDayOfWeek]} #(2003 52 7)"	"{(DateAndTime year: 2003 month: 12 day: 29) isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | Array with: isoYear with: isoWeek with: isoDayOfWeek]} #(2004 1 1)"	"{(DateAndTime year: 2004 month: 12 day: 31) isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | Array with: isoYear with: isoWeek with: isoDayOfWeek]} #(2004 53 5)"	"{(DateAndTime year: 2005 month: 1 day: 2) isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | Array with: isoYear with: isoWeek with: isoDayOfWeek]} #(2004 53 7)"	"{(DateAndTime year: 2005 month: 1 day: 3) isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | Array with: isoYear with: isoWeek with: isoDayOfWeek]} #(2005 1 1)"	"{(DateAndTime year: 2010 month: 1 day: 3) isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | Array with: isoYear with: isoWeek with: isoDayOfWeek]} #(2009 53 7)"	"{(DateAndTime year: 2010 month: 1 day: 4) isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | Array with: isoYear with: isoWeek with: isoDayOfWeek]} #(2010 1 1)"	|  dse daysSinceEpochUpToYear daysSinceEpochOfFourthDayOfYear dayOfWeekCardinalOfFourthDayOfYear daysSinceEpochOfFirstDayOfISO8601Year isoDayOfYearCardinal isoDayOfWeek isoWeek isoYear |	self isGregorian ifFalse: [^self asGregorian isoYearWeekDayOfWeekDo: block3].	dse := self daysSinceEpoch.	daysSinceEpochUpToYear :=  dse - self daysSinceStartOfYear.	daysSinceEpochOfFourthDayOfYear := daysSinceEpochUpToYear + 3.	dayOfWeekCardinalOfFourthDayOfYear := daysSinceEpochOfFourthDayOfYear \\ 7. "Results in ISO value because the Gregorian Epoch day is a Monday."	daysSinceEpochOfFirstDayOfISO8601Year := daysSinceEpochOfFourthDayOfYear - dayOfWeekCardinalOfFourthDayOfYear.	isoDayOfYearCardinal := dse - daysSinceEpochOfFirstDayOfISO8601Year.	isoDayOfWeek := (isoDayOfYearCardinal \\ 7) + 1.	isoWeek := (isoDayOfYearCardinal // 7) + 1.	isoWeek &lt; 1 		ifTrue: 			[isoYear := self year - 1.			isoWeek := 53] 		ifFalse: 			[(isoWeek &gt; 52 				and: 					[| thursdayDelta |					"Next thursday is in the same week as I am BUT ALSO in the next year"					thursdayDelta := ISOThursday - isoDayOfWeek.					thursdayDelta &gt; 0 						ifTrue: ["Same week--check whether next Thursday is next year:" 								("&lt;dayOfYearOrdinal&gt;" dse - daysSinceEpochUpToYear + 1) + thursdayDelta &gt; self daysInYear] 						ifFalse: ["Not the same week, so: " false]])				ifTrue: 					[isoYear := self year + 1.					isoWeek := 1] 				ifFalse: [isoYear := self year]].	^block3 		value: isoYear		value: isoWeek		value: isoDayOfWeek</body><body package="Chronos-DateTimeInterval" selector="monthAndWeekOfMonthAndDayOfWeekDo:">monthAndWeekOfMonthAndDayOfWeekDo: block3	^block3 		value: self month 		value: (self dayOfMonth - 1 // DaysPerWeek) + 1 		value: self dayOfWeek</body><body package="Chronos-DateTimeInterval" selector="yearAndCalendarDayDo:">yearAndCalendarDayDo: block2 	^self calendar 		forDaysSinceEpoch: self daysSinceEpoch		setYearAndCalendarDayInto: block2</body><body package="Chronos-DateTimeInterval" selector="yearMonthDayDo:">yearMonthDayDo: block3 	"Evaluate &lt;block3&gt; with the calendar year number, month ordinal and day-of-month ordinal of the day represented by the receiver as the first, second and third arguments (respectively.) If the receiver is not bound to a particular year, use nil as the value of the year."	^self yearAndCalendarDayDo: 			[:year :calendarDay | 			block3 				value: year				value: calendarDay monthOrdinal				value: calendarDay dayOfMonthOrdinal]</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>accessing-UT</category><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch">utDaysSinceEpoch	^self basicDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="utFractionalDaysSinceEpoch">utFractionalDaysSinceEpoch	"{(Duration days: (AnsiStandardCalendarClock now utFractionalDaysSinceEpoch)) asDateAndTimeIn: Timezone universal}"	"{[:tp |		Array			with: tp			with: (DateAndTimeFactory utSecondsSinceEpoch: tp utcFractionalSecondsSinceEpoch)			with: (DateAndTimeFactory utDaysSinceEpoch tp utcFractionalDaysSinceEpoch) 			with: (DateAndTimeFactory utJulianDay: tp utcJulianDate)] value: DateAndTimeFactory now}"	^self utDaysSinceEpoch + self utFractionalTimeOfDay</body><body package="Chronos-DateTimeInterval" selector="utFractionalSecondsSinceEpoch">utFractionalSecondsSinceEpoch 	"{(Duration seconds: (AnsiStandardCalendarClock now utFractionalSecondsSinceEpoch)) asDateAndTimeIn: Timezone universal}"	"{[:tp |		Array			with: tp			with: (DateAndTimeFactory utcSecondsSinceEpoch: tp utFractionalSecondsSinceEpoch)			with: (DateAndTimeFactory utcDaysSinceEpoch: tp utFractionalDaysSinceEpoch) 			with: (DateAndTimeFactory utcJulianDay: tp utJulianDate)] value: DateAndTimeFactory now}"	^ScaledDecimal 		numerator: self utNanosecondsSinceEpoch		denominator: NanosecondsPerSecond 		scale: 9</body><body package="Chronos-DateTimeInterval" selector="utJulianDate">utJulianDate	"{DateAndTimeFactory utJulianDay: DateAndTimeFactory now utJulianDate}"	^ScaledDecimal		numerator: (self utNanosecondsSinceEpoch + (self calendar secondsSinceJulianDayEpochUpToEpoch * NanosecondsPerSecond))		denominator: NanosecondsPerDay		scale: 9</body><body package="Chronos-DateTimeInterval" selector="utJulianDay">utJulianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs (Universal Time.) However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered (also Universal Time.)"	^self calendar julianDayFromDaysSinceEpoch: self utDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="utJulianDayNumber">utJulianDayNumber	"Answers the Julian Day Number of the Julian Day that starts at Noon on the date represented by the receiver (Universal Time.)"	^self calendar julianDayFromDaysSinceEpoch: self utDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="utMicrosecondsSinceEpoch">utMicrosecondsSinceEpoch	^(self utNanosecondsSinceEpoch bitShift: -3) // 125</body><body package="Chronos-DateTimeInterval" selector="utMillisecondsSinceEpoch">utMillisecondsSinceEpoch	^(self utNanosecondsSinceEpoch bitShift: -6) // 15625</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceEpoch">utNanosecondsSinceEpoch	^self utSecondsSinceEpoch * NanosecondsPerSecond + self utNanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceUnificationEpoch">utNanosecondsSinceUnificationEpoch	^self utSecondsSinceUnificationEpoch * NanosecondsPerSecond + self utNanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch">utSecondsSinceEpoch	^self timeZone 		netSecondsAfterSubtractingOffsetFromUTFromSeconds: self basicSecondsSinceEpoch		nanosecondsSinceSecond: self basicNanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceUnificationEpoch">utSecondsSinceUnificationEpoch	^self calendar secondsSinceUnificationEpochFromSecondsSinceEpoch: self utSecondsSinceEpoch</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="asCalendarDurationSinceEpoch">asCalendarDurationSinceEpoch	^self class calendarDurationFactory 		years: self yearsSinceEpoch		months: self monthsSinceStartOfYear 		days: self daysSinceStartOfMonth</body><body package="Chronos-DateTimeInterval" selector="asCalendricalCoordinate">asCalendricalCoordinate	"Answer the conversion of the receiver into its equivalent value implemented as a CalendricalCoordinate.  If the receiver is already a CalendricalCoordinate, answer the receiver."	^self</body><body package="Chronos-DateTimeInterval" selector="asCivilDurationSinceEpoch">asCivilDurationSinceEpoch	^self class civilDurationFactory 		years: self yearsSinceEpoch		months: self monthsSinceStartOfYear 		days: self daysSinceStartOfMonth		seconds: self secondsSinceStartOfDay 		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="asDate">asDate	"Answer the conversion of the receiver into a date-valued CalendricalCoordinate that represents the same date as does the receiver.  If the receiver is already a date-valued CalendricalCoordinate, answer the receiver.  A date-valued CalendricalCoordinate is one that specifies a date without specifying a particular time-of-day nor a particular timezone (i.e., it has nominal time semantics, and its quantum of resolution is 1 calendar day.)"	^self</body><body package="Chronos-DateTimeInterval" selector="asDayOfMonth">asDayOfMonth	^self yearMonthDayDo: 		[:y :month :day | DayOfMonthFactory month: month day: day calendar: self calendar]</body><body package="Chronos-DateTimeInterval" selector="asDurationSinceEpoch">asDurationSinceEpoch	^self class durationFactory		seconds: self secondsSinceEpoch		nanoseconds: self nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="asNative">asNative	"Answer the native system's 'Date' analog (or 'Timestamp' analog, if no Date analog is available) that semantically corresponds as closely as possible to the receiver."	"{Julian clock dateToday asNative}"	^self clock nativeCalendricalCoordinateFromChronosDate: self</body><body package="Chronos-DateTimeInterval" selector="asWeekOfMonthDayOfWeek">asWeekOfMonthDayOfWeek	^self 		monthAndWeekOfMonthAndDayOfWeekDo: 			[:month :weekOfMonth :dayOfWeek |				WeekOfMonthDayOfWeekFactory 					month: month					week: weekOfMonth 					dayOfWeek: dayOfWeek]</body><body package="Chronos-DateTimeInterval" selector="dateAndTimeSpec">dateAndTimeSpec	^self yearAndCalendarDayDo: 			[:year :calendarDay | 			DateAndTimeSpec 				year: year				calendarDay: calendarDay				seconds: self secondsSinceStartOfDay				nanoseconds: self nanosecondsSinceSecond]</body><body package="Chronos-DateTimeInterval" selector="dateSpec">dateSpec	^self calendar dateSpecFromDaysSinceEpoch: self daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="inCanonicalCalendar">inCanonicalCalendar	^self calendar 		forSecondsSinceEpoch: self secondsSinceEpoch		canonicalCalendarAndSecondsSinceEpochDo: 			[:canonicalCalendar :seconds | 			| copy |			copy := self copy.			copy				basicSetCalendar: canonicalCalendar;				setSecondsSinceEpoch: seconds.			copy isInvariantToUT ifTrue: [copy canonicalizeFromLocalTime].			copy beImmutable]		ifSameCalendar: [self]</body><body package="Chronos-DateTimeInterval" selector="utDateSpec">utDateSpec	^self localTimeIsUniversal 		ifTrue: [self dateSpec]		ifFalse: [self calendar dateSpecFromDaysSinceEpoch: self utDaysSinceEpoch ]</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isAtStartOfMonth">isAtStartOfMonth	^self isFirstDayOfMonth and: [self isAtStartOfDay]</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfYear">isAtStartOfYear	^self isFirstDayOfYear and: [self isAtStartOfDay]</body><body package="Chronos-DateTimeInterval" selector="isCalendricalCoordinate">isCalendricalCoordinate	^true</body><body package="Chronos-DateTimeInterval" selector="isFirstDayOfMonth">isFirstDayOfMonth	^self calendarDay isFirstDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="isFirstDayOfYear">isFirstDayOfYear	^self calendarDay isFirstDayOfYear</body><body package="Chronos-DateTimeInterval" selector="isLastDayOfMonth">isLastDayOfMonth	^self calendarDay isLastDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="isLastDayOfYear">isLastDayOfYear	^self calendarDay isLastDayOfYear</body><body package="Chronos-DateTimeInterval" selector="isLeapYear">isLeapYear	"Specified and required by the ANSI-Smalltalk Standard."	^self calendarDay yearHasLeapDays</body><body package="Chronos-DateTimeInterval" selector="isMonthKeyResolvable">isMonthKeyResolvable	^true</body><body package="Chronos-DateTimeInterval" selector="isMonthOrdinalResolvable">isMonthOrdinalResolvable	^true</body><body package="Chronos-DateTimeInterval" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the receiver's calendrical system starts each day at local midnight."	^self calendar midnightIsStartOfDay</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtMidnight">timeOfDayClockStartsAtMidnight	"Answer true if the zero-point of the time-of-day clock coincides with midnight"	^self calendar timeOfDayClockStartsAtMidnight</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the receiver's calendrical system coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^self calendar timeOfDayClockStartsAtStartOfDay</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToCalendricalCoordinate: self] 			on: MessageNotUnderstood 			do: [:ex | 				((ex receiver == aCalendrical) and: [#compareToCalendricalCoordinate: == ex message selector])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-DateTimeInterval" selector="hash">hash	^self basicDaysSinceUnificationEpoch hash</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>private-comparing</category><body package="Chronos-DateTimeInterval" selector="compareToAnnualDate:">compareToAnnualDate: anAnnualDate	^(anAnnualDate compareToDate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToDate:">compareToDate: aDate	^self calendar == aDate calendar		ifTrue: [aDate daysSinceEpoch - self daysSinceEpoch]		ifFalse: [aDate daysSinceUnificationEpoch - self daysSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="compareToDayOfMonth:">compareToDayOfMonth: aDayOfMonth	^(aDayOfMonth compareToDate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToDayOfYear:">compareToDayOfYear: aDayOfYear	^(aDayOfYear compareToDate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToWeekOfMonthDayOfWeek:">compareToWeekOfMonthDayOfWeek: aWeekOfMonthDayOfWeek	^(aWeekOfMonthDayOfWeek compareToDate: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToYearMonthDaySpec:">compareToYearMonthDaySpec: aYMDSpec	| diff |	diff := aYMDSpec year - self year.	diff = 0 ifFalse: [^diff].	^aYMDSpec calendarDay compareTo: self calendarDay</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="basicSecondsSince:">basicSecondsSince: aTemporal	^self isInvariantToUT		ifTrue: [aTemporal basicSecondsSinceEpochUntilUT: self]				ifFalse: [aTemporal basicSecondsSinceEpochUntilNominal: self]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochSinceNominal:">basicSecondsSinceEpochSinceNominal: aDateAndTimeInvariantToNominalTime	^self calendar == aDateAndTimeInvariantToNominalTime calendar		ifTrue: [self secondsSinceEpoch - aDateAndTimeInvariantToNominalTime secondsSinceEpoch]		ifFalse: [self secondsSinceUnificationEpoch - aDateAndTimeInvariantToNominalTime secondsSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochSinceUT:">basicSecondsSinceEpochSinceUT: aDateAndTimeInvariantToUT 	^self calendar == aDateAndTimeInvariantToUT calendar 		ifTrue: 			[self isInvariantToUT 				ifTrue: [self utSecondsSinceEpoch - aDateAndTimeInvariantToUT utSecondsSinceEpoch]				ifFalse: [self secondsSinceEpoch - aDateAndTimeInvariantToUT secondsSinceEpoch]]		ifFalse: 			[self isInvariantToUT 				ifTrue: [self utSecondsSinceUnificationEpoch - aDateAndTimeInvariantToUT utSecondsSinceUnificationEpoch]				ifFalse: [self secondsSinceUnificationEpoch - aDateAndTimeInvariantToUT secondsSinceUnificationEpoch]]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochUntilNominal:">basicSecondsSinceEpochUntilNominal: aDateAndTimeInvariantToNominalTime 	^self calendar == aDateAndTimeInvariantToNominalTime calendar 		ifTrue: [aDateAndTimeInvariantToNominalTime secondsSinceEpoch - self secondsSinceEpoch]		ifFalse: [aDateAndTimeInvariantToNominalTime secondsSinceUnificationEpoch - self secondsSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceEpochUntilUT:">basicSecondsSinceEpochUntilUT: aDateAndTimeInvariantToUT 	^self isInvariantToUT 		ifTrue: 			[self calendar == aDateAndTimeInvariantToUT calendar 				ifTrue: [aDateAndTimeInvariantToUT utSecondsSinceEpoch - self utSecondsSinceEpoch]				ifFalse: [aDateAndTimeInvariantToUT utSecondsSinceUnificationEpoch - self utSecondsSinceUnificationEpoch]]		ifFalse: 			[self calendar == aDateAndTimeInvariantToUT calendar 				ifTrue: [aDateAndTimeInvariantToUT secondsSinceEpoch - self secondsSinceEpoch]				ifFalse: [aDateAndTimeInvariantToUT secondsSinceUnificationEpoch - self secondsSinceUnificationEpoch]]</body><body package="Chronos-DateTimeInterval" selector="basicSecondsUntil:">basicSecondsUntil: aTemporal	^self isInvariantToUT		ifTrue: [aTemporal basicSecondsSinceEpochSinceUT: self]				ifFalse: [aTemporal basicSecondsSinceEpochSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="calendarDurationNominalSinceNominal:">calendarDurationNominalSinceNominal: aDateAndTimeInvariantToNominalTime	| comparand |	comparand := 		aDateAndTimeInvariantToNominalTime calendar == self calendar			ifTrue: [aDateAndTimeInvariantToNominalTime]			ifFalse: [aDateAndTimeInvariantToNominalTime as: self calendar].	^self class calendarDurationFactory  new		beToYear: self year 		month: self month 		day: self dayOfMonth 		fromYear: comparand year		month: comparand month		day: comparand dayOfMonth		calendar: self calendar</body><body package="Chronos-DateTimeInterval" selector="calendarDurationSinceNominal:">calendarDurationSinceNominal: aDateAndTimeInvariantToNominalTime 	^self isInvariantToUT 		ifTrue: [self calendarDurationUTSinceUT: (aDateAndTimeInvariantToNominalTime in: self basicTimeZone)]		ifFalse: [self calendarDurationNominalSinceNominal: aDateAndTimeInvariantToNominalTime]</body><body package="Chronos-DateTimeInterval" selector="calendarDurationSinceUT:">calendarDurationSinceUT: aDateAndTimeInvariantToUT	^self isInvariantToUT		ifTrue: [self calendarDurationUTSinceUT: aDateAndTimeInvariantToUT]		ifFalse: [(self in: aDateAndTimeInvariantToUT basicTimeZone) calendarDurationNominalSinceNominal: aDateAndTimeInvariantToUT]</body><body package="Chronos-DateTimeInterval" selector="calendarDurationUTSinceUT:">calendarDurationUTSinceUT: aDateAndTimeInvariantToUT	| comparand thisDateSpec thatDateSpec |	comparand := 		self calendar == aDateAndTimeInvariantToUT calendar			ifTrue: [aDateAndTimeInvariantToUT]			ifFalse: [aDateAndTimeInvariantToUT as: self calendar].	thisDateSpec := self utDateSpec.	thatDateSpec := comparand utDateSpec.	^self class calendarDurationFactory  new		beToYear: thisDateSpec year 		month: thisDateSpec month 		day: thisDateSpec dayOfMonth 		fromYear: thatDateSpec year		month: thatDateSpec month		day: thatDateSpec dayOfMonth		calendar: self calendar</body><body package="Chronos-DateTimeInterval" selector="calendarDurationUntilNominal:">calendarDurationUntilNominal: aDateAndTimeInvariantToNominalTime	^self isInvariantToUT		ifTrue: [aDateAndTimeInvariantToNominalTime calendarDurationUTSinceUT: self]		ifFalse: [aDateAndTimeInvariantToNominalTime calendarDurationNominalSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="calendarDurationUntilUT:">calendarDurationUntilUT: aDateAndTimeInvariantToUT	^self isInvariantToUT		ifTrue: [aDateAndTimeInvariantToUT calendarDurationUTSinceUT: (self in: aDateAndTimeInvariantToUT basicTimeZone)]		ifFalse: [aDateAndTimeInvariantToUT calendarDurationNominalSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="civilDurationNominalSinceNominal:">civilDurationNominalSinceNominal: aDateAndTimeInvariantToNominalTime	| comparand |	comparand := 		aDateAndTimeInvariantToNominalTime calendar == self calendar			ifTrue: [aDateAndTimeInvariantToNominalTime]			ifFalse: [aDateAndTimeInvariantToNominalTime as: self calendar].	^self class civilDurationFactory new		beToYear: self year 		month: self month 		day: self dayOfMonth 		second: self secondsSinceStartOfDay		nanosecond: self nanosecondsSinceSecond		fromYear: comparand year		month: comparand month		day: comparand dayOfMonth		second: comparand secondsSinceStartOfDay		nanosecond: comparand nanosecondsSinceSecond		calendar: self calendar</body><body package="Chronos-DateTimeInterval" selector="civilDurationSinceNominal:">civilDurationSinceNominal: aDateAndTimeInvariantToNominalTime 	^self isInvariantToUT 		ifTrue: [self civilDurationUTSinceUT: (aDateAndTimeInvariantToNominalTime in: self basicTimeZone)]		ifFalse: [self civilDurationNominalSinceNominal: aDateAndTimeInvariantToNominalTime]</body><body package="Chronos-DateTimeInterval" selector="civilDurationSinceUT:">civilDurationSinceUT: aDateAndTimeInvariantToUT	^self isInvariantToUT		ifTrue: [self civilDurationUTSinceUT: aDateAndTimeInvariantToUT]		ifFalse: [(self in: aDateAndTimeInvariantToUT basicTimeZone) civilDurationNominalSinceNominal: aDateAndTimeInvariantToUT]</body><body package="Chronos-DateTimeInterval" selector="civilDurationUTSinceUT:">civilDurationUTSinceUT: aDateAndTimeInvariantToUT	| comparand thisDateSpec thatDateSpec |	comparand := 		self calendar == aDateAndTimeInvariantToUT calendar			ifTrue: [aDateAndTimeInvariantToUT]			ifFalse: [aDateAndTimeInvariantToUT as: self calendar].	thisDateSpec := self utDateSpec.	thatDateSpec := comparand utDateSpec.	^self class civilDurationFactory new		beToYear: thisDateSpec year 		month: thisDateSpec month 		day: thisDateSpec dayOfMonth 		second: self utSecondsSinceStartOfDay		nanosecond: self utNanosecondsSinceSecond		fromYear: thatDateSpec year		month: thatDateSpec month		day: thatDateSpec dayOfMonth		second: comparand utSecondsSinceStartOfDay		nanosecond: comparand utNanosecondsSinceSecond		calendar: self calendar</body><body package="Chronos-DateTimeInterval" selector="civilDurationUntilNominal:">civilDurationUntilNominal: aDateAndTimeInvariantToNominalTime	^self isInvariantToUT		ifTrue: [aDateAndTimeInvariantToNominalTime civilDurationUTSinceUT: self]		ifFalse: [aDateAndTimeInvariantToNominalTime civilDurationNominalSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="civilDurationUntilUT:">civilDurationUntilUT: aDateAndTimeInvariantToUT	^self isInvariantToUT		ifTrue: [aDateAndTimeInvariantToUT civilDurationUTSinceUT: (self in: aDateAndTimeInvariantToUT basicTimeZone)]		ifFalse: [aDateAndTimeInvariantToUT civilDurationNominalSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="daysSinceDate:">daysSinceDate: aDate	^aDate calendar == self calendar 		ifTrue: [self daysSinceEpoch - aDate daysSinceEpoch]		ifFalse: [self daysSinceUnificationEpoch - aDate daysSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="daysSinceDateAndTime:">daysSinceDateAndTime: aDateAndTime 	| dayDelta |	dayDelta := 		aDateAndTime calendar == self calendar 			ifTrue: [self daysSinceEpoch - aDateAndTime daysSinceEpoch]			ifFalse: [self daysSinceUnificationEpoch - aDateAndTime daysSinceUnificationEpoch].	dayDelta &lt;= 0 ifTrue: [^dayDelta].	^aDateAndTime isAtStartOfDay ifTrue: [dayDelta] ifFalse: [dayDelta - 1]</body><body package="Chronos-DateTimeInterval" selector="daysUntilDate:">daysUntilDate: aDate 	^aDate calendar == self calendar 		ifTrue: [aDate daysSinceEpoch - self daysSinceEpoch]		ifFalse: [aDate daysSinceUnificationEpoch - self daysSinceUnificationEpoch]</body><body package="Chronos-DateTimeInterval" selector="daysUntilDateAndTime:">daysUntilDateAndTime: aDateAndTime 	| dayDelta |	dayDelta := 		aDateAndTime calendar == self calendar 			ifTrue: [aDateAndTime daysSinceEpoch - self daysSinceEpoch]			ifFalse: [aDateAndTime daysSinceUnificationEpoch - self daysSinceUnificationEpoch].	dayDelta &gt;= 0 ifTrue: [^dayDelta].	^aDateAndTime isAtStartOfDay ifTrue: [dayDelta] ifFalse: [dayDelta + 1]</body><body package="Chronos-DateTimeInterval" selector="durationSinceDateAndTime:">durationSinceDateAndTime: aDateAndTime	^self civilDurationSince: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="durationSinceTimeOfDay:">durationSinceTimeOfDay: aTimeOfDay	^self civilDurationSince: aTimeOfDay</body><body package="Chronos-DateTimeInterval" selector="durationUntilDateAndTime:">durationUntilDateAndTime: aDateAndTime	^self civilDurationUntil: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="durationUntilTimeOfDay:">durationUntilTimeOfDay: aTimeOfDay	^self civilDurationUntil: aTimeOfDay</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCalendarDuration:">subtractedFromCalendarDuration: aDuration 	^aDuration 		subtractingYears: self yearsSinceEpoch		months: self monthsSinceStartOfYear		days: self daysSinceStartOfMonth</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aDuration	^aDuration 		subtractingYears: self yearsSinceEpoch		months: self monthsSinceStartOfYear		days: self daysSinceStartOfMonth</body><body package="Chronos-DateTimeInterval" selector="subtractedFromDuration:">subtractedFromDuration: aDuration	^aDuration		subtractingSeconds: self secondsSinceEpoch		nanoseconds: self nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>arithmetic</category><body package="Chronos-DateTimeInterval" selector="calendarDurationSince:">calendarDurationSince: aDateAndTime 	"REQUIRED INVARIANT: (alpha calendarDurationSince: beta) = (beta calendarDurationUntil: alpha)"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		calendarDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Gregorian since Gegorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		calendarDurationSince: (Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian)} [Gregorian since Julian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian) 		calendarDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 15)} [Julian until Gregorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian) 		calendarDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Julian since Gregorian]			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	"{(Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0) 		calendarDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian)} [Gregorian until Julian] 			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	^self isInvariantToUT		ifTrue: [aDateAndTime calendarDurationUntilUT: self]				ifFalse: [aDateAndTime calendarDurationUntilNominal: self]</body><body package="Chronos-DateTimeInterval" selector="calendarDurationUntil:">calendarDurationUntil: aDateAndTime 	"REQUIRED INVARIANT: (alpha calendarDurationSince: beta) = (beta calendarDurationUntil: alpha)"	"REQUIRED INVARIANT: (alpha calendarDurationSince: beta) = (beta calendarDurationUntil: alpha)"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		calendarDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Gregorian since Gegorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		calendarDurationSince: (Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian)} [Gregorian since Julian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian) 		calendarDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 15)} [Julian until Gregorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian) 		calendarDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Julian since Gregorian]			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	"{(Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0) 		calendarDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian)} [Gregorian until Julian] 			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	^self isInvariantToUT		ifTrue: [aDateAndTime calendarDurationSinceUT: self]				ifFalse: [aDateAndTime calendarDurationSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="civilDurationSince:">civilDurationSince: aDateAndTime 	"REQUIRED INVARIANT: (alpha civilDurationSince: beta) = (beta civilDurationUntil: alpha)"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		civilDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Gregorian since Gegorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		civilDurationSince: (Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian)} [Gregorian since Julian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian) 		civilDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 15)} [Julian until Gregorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian) 		civilDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Julian since Gregorian]			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	"{(Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0) 		civilDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian)} [Gregorian until Julian] 			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	^self isInvariantToUT		ifTrue: [aDateAndTime civilDurationUntilUT: self]				ifFalse: [aDateAndTime civilDurationUntilNominal: self]</body><body package="Chronos-DateTimeInterval" selector="civilDurationUntil:">civilDurationUntil: aDateAndTime 	"REQUIRED INVARIANT: (alpha calendarDurationSince: beta) = (beta calendarDurationUntil: alpha)"	"REQUIRED INVARIANT: (alpha civilDurationSince: beta) = (beta civilDurationUntil: alpha)"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		civilDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Gregorian since Gegorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 15) 		civilDurationSince: (Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian)} [Gregorian since Julian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: -4713 month: 1 day: 1 hour: 12 minute: 0 second: 0 nanosecond: 0 calendar: Calendar julian) 		civilDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 15)} [Julian until Gregorian]			= 6294 Years 10 Months +20:12:00:00 (Gregorian) [note: Gregorian yearNumberingPolicy is ordinal/astronomical (as required by ANSI)]"	"{(Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian) 		civilDurationSince: (Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0)} [Julian since Gregorian]			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	"{(Timepoint nominalYear: -4713 month: 11 day: 24 hour: 12 minute: 0 second: 0 nanosecond: 0) 		civilDurationUntil: (Timepoint nominalYear: 1582 month: 10 day: 5 calendar: Calendar julian)} [Gregorian until Julian] 			= 6294 Years 9 Months +3:12:00:00 (Julian) [note: Julian yearNumberingPolicy is zeroless-ordinal, as is traditional]"	^self isInvariantToUT		ifTrue: [aDateAndTime civilDurationSinceUT: self]				ifFalse: [aDateAndTime civilDurationSinceNominal: self]</body><body package="Chronos-DateTimeInterval" selector="daysSince:">daysSince: aCalendricalCoordinate	^aCalendricalCoordinate daysUntilDate: self</body><body package="Chronos-DateTimeInterval" selector="daysUntil:">daysUntil: aCalendricalCoordinate	^aCalendricalCoordinate daysSinceDate: self</body><body package="Chronos-DateTimeInterval" selector="durationSince:">durationSince: aTemporalCoordinate	^aTemporalCoordinate durationUntilDate: self</body><body package="Chronos-DateTimeInterval" selector="durationUntil:">durationUntil: aTemporalCoordinate	^aTemporalCoordinate durationSinceDate: self</body><body package="Chronos-DateTimeInterval" selector="monthsSince:">monthsSince: aCalendricalCoordinate 	| civilDuration |	civilDuration := self civilDurationSince: aCalendricalCoordinate.	civilDuration years = 0 ifTrue: [^civilDuration months].	^self calendar isMonthsPerYearInvariant 		ifTrue: [civilDuration years * self calendar monthsPerYear + civilDuration months]		ifFalse: 			[(self calendar monthsSinceEpochUpToYear: self year) 				- (self calendar monthsSinceEpochUpToYear: aCalendricalCoordinate year) 					+ civilDuration months]</body><body package="Chronos-DateTimeInterval" selector="monthsUntil:">monthsUntil: aCalendricalCoordinate 	| civilDuration |	civilDuration := self civilDurationUntil: aCalendricalCoordinate.	civilDuration years = 0 ifTrue: [^civilDuration months].	^self calendar isMonthsPerYearInvariant 		ifTrue: [civilDuration years * self calendar monthsPerYear + civilDuration months]		ifFalse: 			[(self calendar monthsSinceEpochUpToYear: aCalendricalCoordinate year) 				- (self calendar monthsSinceEpochUpToYear: self year) + civilDuration months]</body><body package="Chronos-DateTimeInterval" selector="quartersSince:">quartersSince: aCalendricalCoordinate 	^(self monthsSince: aCalendricalCoordinate) quo: 3</body><body package="Chronos-DateTimeInterval" selector="quartersUntil:">quartersUntil: aCalendricalCoordinate 	^(self monthsUntil: aCalendricalCoordinate) quo: 3</body><body package="Chronos-DateTimeInterval" selector="weeksSince:">weeksSince: aCalendricalCoordinate	^(self daysSince: aCalendricalCoordinate) quo: DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="weeksUntil:">weeksUntil: aCalendricalCoordinate 	^(self daysUntil: aCalendricalCoordinate) quo: DaysPerWeek</body><body package="Chronos-DateTimeInterval" selector="yearsSince:">yearsSince: aCalendricalCoordinate	^(self calendarDurationSince: aCalendricalCoordinate) years</body><body package="Chronos-DateTimeInterval" selector="yearsUntil:">yearsUntil: aCalendricalCoordinate	^(self calendarDurationUntil: aCalendricalCoordinate) years</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="canonicalizeFromLocalTime">canonicalizeFromLocalTime	"By default, do nothing."</body><body package="Chronos-DateTimeInterval" selector="canonicalizeFromUT">canonicalizeFromUT	"By default, do nothing."</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>private-time zone operations</category><body package="Chronos-DateTimeInterval" selector="gregorianLocalYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo:">gregorianLocalYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo: block3	^self isGregorian 		ifTrue: 			[block3 				value: self year				value: self dayOfYearOrdinal				value: [:offsetSecondsFromUTC | self secondsSinceStartOfDay]]		ifFalse: 			[| ymd |			ymd := self calendar 						gregorianDateSpecFromDaysSinceEpoch: self daysSinceEpoch.			block3 				value: ymd year				value: ymd dayOfYearOrdinal				value: 					[:offsetSecondsFromUTC | 					(self calendar secondsSinceMidnightFromSecondsSinceStartOfDay: self secondsSinceStartOfDay) 						\\ self secondsInDay]]</body></methods><methods><class-id>Chronos.CalendricalCoordinate</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="addDays:">addDays: dayDelta 	"Add the given number of civil days to the date represented by the receiver, preserving the same civil time-of-day."	^self addingDays: dayDelta "ST-80 compatibility"</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asDays">asDays	"Answer the number of days between January 1, 1901	and the receiver's day."	^(self isGregorian		ifTrue: [self daysSinceEpoch]		ifFalse:			[Gregorian				daysSinceEpochFromForeignDaysSinceEpoch: self daysSinceEpoch 				convertingFrom: self calendar])  - 693960</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asSeconds">asSeconds	"Answer the seconds between the initial moment of the first day of 1901 A.D. [Gregorian] and the initial moment of the receiver's day (according to the receiver's calendar.)"	^self asDays * SecondsPerDay</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asTimestamp">asTimestamp	"Answer a Timestamp representing the receiver."	^self asNominalDateAndTime asTimestamp</body><body package="Chronos-ST80 (and VW) Compatibility" selector="day">day	"Answer the day of the year represented by the receiver."	^self dayOfYear</body><body package="Chronos-ST80 (and VW) Compatibility" selector="daysInYear:">daysInYear: year	^self calendar daysInYear: year</body><body package="Chronos-ST80 (and VW) Compatibility" selector="daysLeftInYear">daysLeftInYear	"Answer the number of days in the year after the date of the receiver."	^self daysInYear - self dayOfYear</body><body package="Chronos-ST80 (and VW) Compatibility" selector="firstDayOfMonth">firstDayOfMonth	"Answer the index of the day of the year that is the first day	of the receiver's month."	^self calendarDay daysUpToMonthSinceStartOfYear + 1</body><body package="Chronos-ST80 (and VW) Compatibility" selector="firstDayOfMonthIndex:">firstDayOfMonthIndex: monthIndex 	"Answer the day of the year (an Integer) that is the first day of 	the receiver's month."	^(self calendar 		calendarDayFromMonth: monthIndex		day: 1		forYearTypeCode: self yearTypeCode) dayOfYearOrdinal</body><body package="Chronos-ST80 (and VW) Compatibility" selector="leap">leap	"Answer one if the receiver's year is a leap year and zero otherwise."	^self isLeapYear ifTrue: [1] ifFalse: [0] "Not all Calendars use integer yearTypeCodes--and others use more than 2"</body><body package="Chronos-ST80 (and VW) Compatibility" selector="monthIndex">monthIndex	"Answer the index of the month in which the receiver falls."	^self month</body><body package="Chronos-ST80 (and VW) Compatibility" selector="previous:">previous: dayName 	"Answer the previous date whose weekday name is dayName."	^self prevDayOfWeek: dayName</body><body package="Chronos-ST80 (and VW) Compatibility" selector="printFormat:">printFormat: formatArray 	"{YearMonthDay today printFormat: #(2 1 3 $  3 1)}"	"{YearMonthDay today printFormat: #(1 2 3 $- 2 2)}"	"{Timepoint today printFormat: #(2 1 3 $  3 1)}"	"{WeekOfMonthDayOfWeek today printFormat: #(2 1 3 $  3 1)}"	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream format: formatArray.	^aStream contents</body><body package="Chronos-ST80 (and VW) Compatibility" selector="printOn:format:">printOn: aStream format: formatArray	"Print a description of the receiver on aStream.  The argument	formatArray is the print format, where	1-3		positions to print day, month, year respectively 	4		character separator 	5		month format (1 month #, 2 first 3 chars, 3 entire name) 	6		year format (1 year #, 2 year # \\ 100)	See also the comment for printFormat:"	| monthIndex element monthFormat |	monthIndex := self monthIndex.	1 to: 3 do: 		[:elementIndex | 		element := formatArray at: elementIndex.		element = 1 ifTrue: [self dayOfYear - self firstDayOfMonth + 1 printOn: aStream].		element = 2			ifTrue: 				[monthFormat := formatArray at: 5.				monthFormat = 1 					ifTrue: [monthIndex printOn: aStream].				monthFormat = 2					ifTrue: [aStream nextPutAll: ((ISOMonthKeys at: monthIndex)													copyFrom: 1 to: 3)].				monthFormat = 3 					ifTrue: [aStream nextPutAll: (ISOMonthKeys at: monthIndex)]].		element = 3 			ifTrue: 				[(formatArray at: 6) = 1					ifTrue: [self year printOn: aStream]					ifFalse: [(self year \\ 100) printOn: aStream paddedWith: $0 to: 2 base: 10]].		elementIndex &lt; 3 			ifTrue: 				[(formatArray at: 4) ~= 0 					ifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]</body><body package="Chronos-ST80 (and VW) Compatibility" selector="printOn:policy:format:">printOn: aStream policy: aPolicy format: tokens 	"{Locale current printAsTime: YearMonthDay today policyNamed: #long}"	"{Locale current printAsTime: YearMonthDay today policyNamed: #short}"	| formatField |	formatField := (aPolicy numberOfFieldsIn: tokens) &gt; 2				ifTrue: [2]				ifFalse: [1].	aPolicy		print: self asNominalDateAndTime		on: aStream		using: (aPolicy fieldFormat: formatField for: tokens)</body><body package="Chronos-ST80 (and VW) Compatibility" selector="subtractDate:">subtractDate: aDate 	"Answer the number of days between the receiver and aDate."	^self asDays - aDate asDays</body><body package="Chronos-ST80 (and VW) Compatibility" selector="subtractDays:">subtractDays: dayDelta 	^self subtractingDays: dayDelta "ST-80 compatibility"</body><body package="Chronos-ST80 (and VW) Compatibility" selector="weekday">weekday	"Answer the name of the day of the week on which the receiver falls."	^self dayOfWeekName</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="addMonths:">addMonths: months 	"Add the given number of civil months to the date represented by the receiver, preserving the same civil time-of-day.   The new dayOfMonth will be the same as it had been, unless it would be invalid.  For example, if the orignal date was March 31, the new dayOfMonth will also be 31, unless the new month has less than 31 days. In such a case, the receiver's new dayOfMonth will be the last day of the receiver's new month.	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal."	months = 0 ifTrue: [^self].	self basicAddMonths: months days: 0</body><body package="Chronos-DateTimeInterval" selector="addYears:">addYears: years 	"Add the given number of civil years to the date represented by the receiver, preserving the same civil time-of-day.  The civil intra-year date in the new year will be the same as in the old year, unless it would be invalid.   For example, if the orignal date is March 1 in a Gregorian/Julian leap year, the date in the new year will remain March 1 after adding the specified years.  However, if the original date is February 29 and the new year is not a leap year, then the new date will be Feb 28.   	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal.  If intercalary months may occur at times other than the end of the year, the Calendar system's cultural tradition will be respected regarding the semantics of 'same civil date N years later (or earlier.)'  The implementation assumes that the only issue in that respect is whether or not 'same month' is defined by the monthOrdinal or by the monthKey (by definition of a Chronos monthKey, months with the same monthKey are semantically the same month, regardless of possibly having different monthOrdinals in different years--which does happen in some Calendars!.)"	| remainingDays |	years = 0 ifTrue: [^self].	remainingDays := (self basicAddYears: years) truncated.	remainingDays = 0 ifFalse: [self basicAddDays: remainingDays]</body><body package="Chronos-DateTimeInterval" selector="addYears:months:days:">addYears: years months: months days: days 	"Add the given number of civil years, months and days, and the given number of scientific seconds and nanoseconds, to the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years, M civil months and D civil days away from another date' will be respected..	See the specifications/comments for #addYears:, #addMonths:and #addDays for more detailed/precise semantics."	(days = 0 and: [months = 0 and: [years = 0]]) 		ifFalse: 			[| daysToAdd |			years = 0 				ifTrue: [daysToAdd := days truncated]				ifFalse: [daysToAdd := (days + (self basicAddYears: years)) truncated].			months = 0				ifTrue: [daysToAdd = 0 ifFalse: [self basicAddDays: daysToAdd]]				ifFalse: [self basicAddMonths: months days: daysToAdd]].</body><body package="Chronos-DateTimeInterval" selector="addYears:months:days:hours:minutes:seconds:nanoseconds:">addYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	self addYears: years months: months days: days.	self addHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds</body><body package="Chronos-DateTimeInterval" selector="addYears:months:days:seconds:nanoseconds:">addYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds 	"Add the given number of civil years, months and days, and the given number of scientific seconds and nanoseconds, to the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years, M civil months and D civil days away from another date' will be respected.  The scientific semantics of a timepoint S seconds and N nanoseconds from another will be respected (UT).	See the specifications/comments for #addYears:, #addMonths:, #addDays: and #addSeconds:nanoseconds: for more detailed/precise semantics."	self addYears: years months: months days: days.	self addSeconds: seconds nanoseconds: nanoseconds</body><body package="Chronos-DateTimeInterval" selector="convertToCalendar:">convertToCalendar: otherCalendar 	"Make the receiver represent a calendrical coordinate whose Calendar is &lt;otherCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history) as does the receiver."	| originalCalendar daysSinceEpoch |	originalCalendar := self calendar.	originalCalendar == otherCalendar ifTrue: [^self].	daysSinceEpoch := self daysSinceEpoch.	self		basicSetCalendar: otherCalendar;		setDaysSinceEpoch: 			(otherCalendar 				daysSinceEpochFromForeignDaysSinceEpoch: daysSinceEpoch				convertingFrom: originalCalendar)</body><body package="Chronos-DateTimeInterval" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	self assertMutability.	calendar := AnsiStandardCalendar</body><body package="Chronos-DateTimeInterval" selector="initializeFrom:">initializeFrom: aCalendricalCoordinate 	self		basicSetCalendar: aCalendricalCoordinate calendar;		basicSetDaysSinceEpoch: aCalendricalCoordinate daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self setCalendar: (literalArray at: 2) asSymbol</body><body package="Chronos-DateTimeInterval" selector="invalidateCalendar">invalidateCalendar	calendar := calendar == nil ifFalse: [Calendar at: calendar registrationKey ifAbsent: [calendar]]</body><body package="Chronos-DateTimeInterval" selector="setCalendar:">setCalendar: aCalendar 	self assertMutability.	calendar := Calendar referencedBy: aCalendar.</body><body package="Chronos-DateTimeInterval" selector="setDaysSinceEpoch:">setDaysSinceEpoch: daysSinceEpoch 	self basicSetDaysSinceEpoch: daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="setIsoYear:week:dayOfWeek:">setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"{(DateAndTime year: 2003 month: 12 day: 28)		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (DateAndTime isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(DateAndTime year: 2003 month: 12 day: 29) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (DateAndTime isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(DateAndTime year: 2005 month: 1 day: 2) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (DateAndTime isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(DateAndTime year: 2010 month: 1 day: 3) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (DateAndTime isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(DateAndTime year: 2010 month: 1 day: 4) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (DateAndTime isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	| daysSinceEpochUpToYear daysSinceEpochOfFourthDayOfYear dayOfWeekCardinalOfFourthDayOfYear daysSinceEpochOfFirstDayOfISO8601Year daysSinceEpoch |	daysSinceEpochUpToYear := Gregorian daysSinceEpochUpToYear: isoYear.	daysSinceEpochOfFourthDayOfYear := daysSinceEpochUpToYear + 3.	dayOfWeekCardinalOfFourthDayOfYear := Gregorian daysSinceStartOfISOWeekFromDaysSinceEpoch: daysSinceEpochOfFourthDayOfYear.	daysSinceEpochOfFirstDayOfISO8601Year := daysSinceEpochOfFourthDayOfYear - dayOfWeekCardinalOfFourthDayOfYear.	daysSinceEpoch := daysSinceEpochOfFirstDayOfISO8601Year + ((isoWeekOrdinal - 1) * 7) + (isoDayOfWeekOrdinal - 1).	Gregorian 		forDaysSinceEpoch: daysSinceEpoch 		setYearAndCalendarDayInto: self</body><body package="Chronos-DateTimeInterval" selector="setJulianDay:">setJulianDay: julianDay 	self basicSetDaysSinceEpoch: (self calendar daysSinceEpochFromJulianDay: julianDay)</body><body package="Chronos-DateTimeInterval" selector="setJulianDay:seconds:nanoseconds:">setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds 	self setJulianDay: julianDay</body><body package="Chronos-DateTimeInterval" selector="setJulianDayNumber:">setJulianDayNumber: julianDayNumber	self basicSetDaysSinceEpoch: (self calendar daysSinceEpochFromJulianDay: julianDayNumber)</body><body package="Chronos-DateTimeInterval" selector="setNanosecondsSinceEpoch:">setNanosecondsSinceEpoch: nanoseconds	self setSecondsSinceEpoch: (nanoseconds bitShift: -9) // 1953125</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceEpoch:">setSecondsSinceEpoch: seconds 	self basicSetSecondsSinceEpoch: seconds.</body><body package="Chronos-DateTimeInterval" selector="setYear:calendarDay:">setYear: aYear calendarDay: aCalendarDay 	self basicSetYear: aYear calendarDay: aCalendarDay.</body><body package="Chronos-DateTimeInterval" selector="setYear:dayOfYearOrdinal:">setYear: y dayOfYearOrdinal: dayOfYearOrdinal	| cd |	cd := (self calendar yearlyCalendarFor: y) dayAt: dayOfYearOrdinal.	cd == nil ifTrue: [self signalError: 'Invalid ordinal date: year=', y printString, ' dayOfYearOrdinal=', dayOfYearOrdinal printString].	self basicSetYear: y calendarDay: cd</body><body package="Chronos-DateTimeInterval" selector="setYear:monthOrdinal:dayOfMonthOrdinal:">setYear: y monthOrdinal: m dayOfMonthOrdinal: d	"{DateFactory year: 1969 month: 7 day: 20}"	"{DateFactory year: 1969 month: 2 day: 29}"	"{DateFactory year: 2001 month: 13 day: 0}"	| cd |	cd := self calendar calendarDayFromMonth: m day: d inYear: y.	cd == nil		ifTrue:			[| errorMessage |			errorMessage := String new writeStream.			errorMessage nextPutAll: 'Invalid date designation:'; cr.			self calendar validateYear: y month: m day: d ifInvalid: [:problems | 				problems keysAndValuesDo: [:parameter :problem | 					errorMessage						tab;						nextPutAll: parameter;						nextPutAll: ' =&gt; ';						nextPutAll: problem;						cr]].			self signalError: errorMessage contents].	self basicSetYear: y calendarDay: cd.</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="&lt;&lt;">&lt;&lt; aChronosTimezone 	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but convert the date and time-of-day as though the receiver represented a date and time in the current default time zone (i.e,. preserve date and time-of-day in Universal Time as though the receiver represented a date and time in the current default time zone.)	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is the same as that of the receiver (i.e,, preserve local date and local time-of-day, don't preserve date or time-of-day in Universal Time.)"	"YearMonthDay today &lt;&lt; 10 hours"	"YearMonthDay today &lt;&lt; #nominal"	"YearMonthDay today &lt;&lt; 'Australia/Adelaide'"	"YearMonthDay today &lt;&lt; #default"	"YearMonthDay today &lt;&lt; #system"	| timeZone dateAndTime |	timeZone := ChronosTimezone referencedBy: aChronosTimezone.	timeZone isInvariantToNominalTime ifTrue: [^self].	timeZone isDefault 		ifTrue: 			[dateAndTime := 				self isMutable 					ifTrue: [self asMutableDateAndTimeInvariantToUT]					ifFalse: [self asDateAndTime]]		ifFalse: 			[dateAndTime := self asMutableDateAndTime.			dateAndTime				deproxifyTimeZone;				convertToTimeZone: timeZone;				beImmutable].	^self duration asTimeperiodStartingAt: dateAndTime</body><body package="Chronos-DateTimeInterval" selector="&gt;&gt;">&gt;&gt; aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"YearMonthDay today &gt;&gt; 10 hours"	"YearMonthDay today &gt;&gt; #nominal"	"YearMonthDay today &gt;&gt; 'Australia/Adelaide'"	"YearMonthDay today &gt;&gt; #default"	"YearMonthDay today &gt;&gt; #system"	"{YearMonthDay today &gt;&gt; 'America/Phoenix'}"	"{YearMonthDay today &gt;&gt; 'Asia/Calcutta'}"	| timeZone |	timeZone := ChronosTimezone referencedBy: aChronosTimezone.	timeZone isInvariantToNominalTime ifTrue: [^self].	^self duration asTimeperiodStartingAt: (self asDateAndTimeIn: timeZone)</body><body package="Chronos-DateTimeInterval" selector="asNative">asNative	"Answer the native system's 'Date' analog (or 'Timestamp' analog, if no Date analog is available) that semantically corresponds as closely as possible to the receiver."	"{Julian clock dateToday asNative}"	^self clock nativeCalendricalCoordinateFromChronosDate: self</body><body package="Chronos-DateTimeInterval" selector="asSpec">asSpec	^self dateSpec</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="calendar">calendar	"Answer the Calendar that implements the calendrical system associated with the receiver."	calendar == nil ifTrue: [calendar := AnsiStandardCalendar].	^calendar</body><body package="Chronos-DateTimeInterval" selector="comparisonClassIdentifier">comparisonClassIdentifier		"Answer a value that identifies the group of comparable values to which the receiver belongs.  It must be valid to use #== to compare two identifiers for equality."	^#DateAndTime</body><body package="Chronos-DateTimeInterval" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^CalendarDayDuration</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="asMutableDate">asMutableDate	^self copy</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTime">asMutableDateAndTime	^self yearAndCalendarDayDo: 			[:year :calendarDay | 			(self class dateAndTimeFactory basicNew)				basicSetCalendar: self calendar;				basicSetYear: year calendarDay: calendarDay;				canonicalize]</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTimeInvariantToUT">asMutableDateAndTimeInvariantToUT	^self yearAndCalendarDayDo: 			[:year :calendarDay | 			(self class dateAndTimeFactory basicNew)				basicSetCalendar: self calendar;				basicSetYear: year calendarDay: calendarDay;				canonicalizeFromLocalTime]</body><body package="Chronos-DateTimeInterval" selector="asMutableTimeOfDay">asMutableTimeOfDay	^self asMutableDateAndTime</body><body package="Chronos-DateTimeInterval" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self calendarRegistrationKey</body><body package="Chronos-DateTimeInterval" selector="value:value:">value: aYear value: aCalendarDay 	^self subclassResponsibility</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>private-initialize-release</category><body package="Chronos-DateTimeInterval" selector="basicSetCalendar:">basicSetCalendar: aCalendar	self assertMutability.	calendar := aCalendar</body><body package="Chronos-DateTimeInterval" selector="basicSetDaysSinceEpoch:">basicSetDaysSinceEpoch: daysSinceEpoch 	self calendar 		forDaysSinceEpoch: daysSinceEpoch truncated		setYearAndCalendarDayInto: self</body><body package="Chronos-DateTimeInterval" selector="basicSetSecondsSinceEpoch:">basicSetSecondsSinceEpoch: seconds 	self basicSetDaysSinceEpoch: (seconds truncated bitShift: -7) // 675 	"128 * 675 = 86400"	"Bit shifting is faster than LargeInteger math."</body><body package="Chronos-DateTimeInterval" selector="basicSetYear:calendarDay:">basicSetYear: aYear calendarDay: aCalendarDay 	self value: aYear value: aCalendarDay.</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="basicAddDays:">basicAddDays: dayDelta 	"Add the given number of civil days to the date represented by the receiver, preserving the same civil time-of-day."	dayDelta = 0 ifTrue: [^self].	self setDaysSinceEpoch: self daysSinceEpoch + dayDelta</body><body package="Chronos-DateTimeInterval" selector="basicAddMonths:days:">basicAddMonths: months days: days 	"Add the given number of civil months and days to the date represented by the receiver.   Any of the &lt;months&gt;, or the &lt;days&gt;, or both, may be fractional numbers--however, only an integer number of months and days will be added. Fractional months will be converted to an integer number of days, plus some fraction of a day. Fractional days will be converted to an integer number of days, plus some fraction of a day. Answer any fraction of a day not added (which will be the sum of the day fractions left over from both &lt;months&gt; and &lt;days&gt;, if any.)	If &lt;days&gt; is zero: The new dayOfMonth will be the same as it had been, unless it would be invalid.  For example, if the orignal date was March 31, the new dayOfMonth will also be 31, unless the new month has less than 31 days.  In such a case, the receiver's new dayOfMonth will be the last day of the receiver's new month.	If &lt;days&gt; is non-zero: The recevier's new date will the same as it would have been, had this method been invoked with &lt;days = 0&gt;, followed by performing &lt;self addDays: days&gt;.  See the comment/specification of the method #addDays.  In other words, this method introduces no new semantics, but is simply for improved performance.	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal."	| dayFraction |	self yearAndCalendarDayDo: 			[:localYear :localCalendarDay | 			| monthsToAdd monthFraction  daysToAdd |			months isInteger				ifTrue: 					[monthsToAdd := months.					monthFraction := 0]				ifFalse: 					[monthsToAdd := months truncated.					monthFraction := months - monthsToAdd].			self calendar 				startingWithYear: localYear				addingMonths: localCalendarDay monthsSinceStartOfYear + monthsToAdd				setYearAndMonthsSinceStartOfYearInto: 					[:newYear :newMonthsSinceStartOfYear | 					| newMonth daysInMonth dayOfMonth newYearTypeCode yearTypeCodeIsTheSame newCalendarDay |					newMonth := newMonthsSinceStartOfYear + 1.					dayOfMonth := localCalendarDay dayOfMonth.					newYear = localYear 						ifTrue: 							[yearTypeCodeIsTheSame := true.							newYearTypeCode := localCalendarDay yearTypeCode.							daysInMonth := localCalendarDay yearlyCalendar daysInMonthAt: newMonth]						ifFalse: 							[newYearTypeCode := self calendar typeCodeOfYear: newYear.							daysInMonth := 								newYearTypeCode = localCalendarDay yearTypeCode 									ifTrue: 										[yearTypeCodeIsTheSame := true.										localCalendarDay yearlyCalendar daysInMonthAt: newMonth]									ifFalse: 										[yearTypeCodeIsTheSame := false.										self calendar daysInMonth: newMonth forYearTypeCode: newYearTypeCode]].					dayOfMonth &gt; daysInMonth ifTrue: [dayOfMonth := daysInMonth].					newCalendarDay := 						yearTypeCodeIsTheSame 							ifTrue: [localCalendarDay yearlyCalendar basicMonthAt: newMonth dayAt: dayOfMonth]							ifFalse: 								[self calendar 									calendarDayFromMonth: newMonth									day: dayOfMonth									forYearTypeCode: newYearTypeCode].					days isInteger						ifTrue: 							[daysToAdd := days.							dayFraction := 0]						ifFalse: 							[daysToAdd := days truncated.							dayFraction := days - daysToAdd].					monthFraction = 0						ifFalse: 							[| delta iDelta |							delta := monthFraction * daysInMonth.							iDelta := delta truncated.							daysToAdd := daysToAdd + iDelta.							dayFraction := (delta - iDelta) + dayFraction.							dayFraction &gt;= 1								ifTrue:									[daysToAdd := daysToAdd + 1.									dayFraction := dayFraction - 1]								ifFalse:									[dayFraction &gt;= -1										ifTrue: 											[daysToAdd := daysToAdd - 1.											dayFraction := dayFraction + 1]]].					daysToAdd = 0						ifTrue: 							[self 								setYear: newYear 								calendarDay: newCalendarDay]						ifFalse: 							[newCalendarDay 								startingWithYear: newYear 								addingDays: daysToAdd 								setYearAndCalendarDayInto: [:y :cd | self setYear: y calendarDay: cd]]]].	^dayFraction</body><body package="Chronos-DateTimeInterval" selector="basicAddYears:">basicAddYears: years 	"Add the given number of civil years to the date represented by the receiver.  The civil intra-year date in the new year will be the same as in the old year, unless it would be invalid.  For example, if the orignal date is March 1 in a Gregorian/Julian leap year, the date in the new year will remain March 1 after adding the specified years.  However, if the original date is February 29 and the new year is not a leap year, then the new date will be Feb 28.  	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal.  If intercalary months may occur at times other than the end of the year, the Calendar system's cultural tradition will be respected regarding the semantics of 'same civil date N years later (or earlier.)'  The implementation assumes that the only issue in that respect is whether or not 'same month' is defined by the monthOrdinal or by the monthKey (by definition of a Chronos monthKey, months with the same monthKey are semantically the same month, regardless of possibly having different monthOrdinals in different years--which does happen in some Calendars!.)	The &lt;years&gt; parameter may be a fractional number, in which case it will be converted to an integer value with a fractional remainder.  The fractional remainder (which may be zero) will be multiplied by the number of days in the year which resulted from adding the integer number of years, and that value will be answered by the method."	| intYears yearFraction |	self assertMutability.	years isInteger 		ifTrue: 			[intYears := years.			yearFraction := 0]		ifFalse:			[intYears := years truncated.			yearFraction := years - intYears].	self yearAndCalendarDayDo: 		[:localYear :localCalendarDay | 		| yearNumberingPolicy newYear newYearTypeCode newCalendarDay |		yearNumberingPolicy := self calendar yearNumberingPolicy.		newYear := yearNumberingPolicy canonicalFromOrdinal: (yearNumberingPolicy ordinalFromCanonical: localYear) + intYears.		newYearTypeCode := self calendar typeCodeOfYear: newYear.		newYearTypeCode = localCalendarDay yearTypeCode 			ifTrue: [newCalendarDay := localCalendarDay]			ifFalse: 				["When the yearTypeCode differs, the calendarDay MUST be replaced by one that is bound to the correct yearTypeCode.  There is also the possibility that the old calendarDay's monthOrdinal and/or dayOfMonthOrdinal will no longer be valid."				| monthOrdinal daysInMonth |				monthOrdinal := 					self calendar yearArithmeticPreferablyPreservesMonthOrdinal 						ifTrue: [localCalendarDay monthOrdinal	"Usual case."]						ifFalse: [self calendar monthOrdinalForMonthWithKey: localCalendarDay monthKey forYearTypeCode: newYearTypeCode].				self calendar isMonthsPerYearInvariant 					ifFalse: 						["Most calendars have an invariant number months in a year.  The one we're dealing with here, unfortunately, can have a different number of months in different years."						| monthsInYear |						monthOrdinal &gt; (monthsInYear := self calendar monthsInYearForYearTypeCode: newYearTypeCode) 								ifTrue: 									["The monthOrdinal is not valid for a year of this type.  Use the monthOrdinal of the last month of the year."									monthOrdinal := monthsInYear	"Collapses ALL the intercalary months, if more than one in the old year--which can happen!"]].					newCalendarDay := 						localCalendarDay dayOfMonthOrdinal &gt; (daysInMonth := self calendar daysInMonth: monthOrdinal forYearTypeCode: newYearTypeCode) 							ifTrue: 								["The dayOfMonth is not valid for this month in a year of this type. Use the last dayOfMonth."								self calendar 									calendarDayFromMonth: monthOrdinal									day: daysInMonth									forYearTypeCode: newYearTypeCode]							ifFalse: 								[self calendar 									calendarDayFromMonth: monthOrdinal									day: localCalendarDay dayOfMonthOrdinal									forYearTypeCode: newYearTypeCode]].		self 			setYear: newYear 			calendarDay: newCalendarDay].	^yearFraction = 0		ifTrue: [0]		ifFalse: [yearFraction * self daysInYear]</body><body package="Chronos-DateTimeInterval" selector="durationSinceDate:">durationSinceDate: aDate	^self calendarDurationSince: aDate</body><body package="Chronos-DateTimeInterval" selector="durationUntilDate:">durationUntilDate: aDate	^self calendarDurationUntil: aDate</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isAtStartOfDay">isAtStartOfDay	^true</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfHour">isAtStartOfHour	^true</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfMinute">isAtStartOfMinute	^true</body><body package="Chronos-DateTimeInterval" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^true</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>semantic keys</category><body package="Chronos-Semantic Dates" selector="annualDateSemanticKeyFrom:satisfies:">annualDateSemanticKeyFrom: aSemanticDatePolicy satisfies: predicate 	aSemanticDatePolicy 		forEachSemanticAnnualEventOccurringOn: self		do: [:semanticKey :date | (predicate value: semanticKey) ifTrue: [^true]].	^false</body><body package="Chronos-Semantic Dates" selector="annualDateSemanticKeySatisfies:">annualDateSemanticKeySatisfies: predicate	^self annualDateSemanticKeyFrom: SemanticDatePolicy default satisfies: predicate</body><body package="Chronos-Semantic Dates" selector="annualDateSemanticKeysFrom:ifNone:">annualDateSemanticKeysFrom: aSemanticDatePolicy ifNone: ifNone 	"In the United States (in all time zones except for Pacific/Guam,) 	Unix's `2038 bug` will strike in the eveving of Martin Luther King Day	(assuming no time zone changes, no new territories added to	the US inventory, and no changes to the rule for determining the	date on which Martin Luther King Day occurs):		{((Timepoint utYear: 1970 day: 1 timeZone: 'America/New_York') + (Duration seconds: 2 ** 31 - 1)) 			annualDateSemanticKeysFrom: SemanticDatePolicy unitedStates ifNone: []}"	| set |	set := Set new.	aSemanticDatePolicy 		forEachSemanticAnnualEventOccurringOn: self		do: [:semanticKey :date | set add: semanticKey].	^set isEmpty ifTrue: [ifNone value] ifFalse: [set]</body><body package="Chronos-Semantic Dates" selector="annualDateSemanticKeysIfNone:">annualDateSemanticKeysIfNone: ifNone	^self annualDateSemanticKeysFrom: SemanticDatePolicy default ifNone: ifNone</body><body package="Chronos-Semantic Dates" selector="dayOfWeekSemanticKeyFrom:ifNone:">dayOfWeekSemanticKeyFrom: aSemanticDatePolicy ifNone: ifNone	aSemanticDatePolicy forEachSemanticWeeklyEventOccurringOnTheDayOfWeekOf: self do: [:semanticKey :date | ^semanticKey].	^ifNone value</body><body package="Chronos-Semantic Dates" selector="dayOfWeekSemanticKeyFrom:satisfies:">dayOfWeekSemanticKeyFrom: aSemanticDatePolicy satisfies: predicate	^predicate value: (self dayOfWeekSemanticKeyFrom: aSemanticDatePolicy ifNone: [^false])</body><body package="Chronos-Semantic Dates" selector="dayOfWeekSemanticKeyIfNone:">dayOfWeekSemanticKeyIfNone: ifNone	^self dayOfWeekSemanticKeyFrom: SemanticDatePolicy default ifNone: ifNone</body><body package="Chronos-Semantic Dates" selector="dayOfWeekSemanticKeySatisfies:">dayOfWeekSemanticKeySatisfies: predicate	^self dayOfWeekSemanticKeyFrom: SemanticDatePolicy default satisfies: predicate</body><body package="Chronos-Semantic Dates" selector="semanticKeyDetect:ifNone:">semanticKeyDetect: predicate ifNone: ifNone 	^self 		semanticKeyFrom: SemanticDatePolicy default		detect: predicate		ifNone: ifNone</body><body package="Chronos-Semantic Dates" selector="semanticKeyFrom:detect:ifNone:">semanticKeyFrom: aSemanticDatePolicy detect: predicate ifNone: ifNone 	^aSemanticDatePolicy 		semanticKeysFor: self		detect: predicate		ifNone: ifNone</body><body package="Chronos-Semantic Dates" selector="semanticKeys">semanticKeys	"(YearMonthDay year: 2006 month: 1 day: 1) semanticKeys"	"(YearMonthDay year: 2006 month: 1 day: 2) semanticKeys"	"(YearMonthDay year: 2005 month: 12 day: 25) semanticKeys"	"(YearMonthDay year: 2005 month: 12 day: 26) semanticKeys"		| set |	set := Set new.	self semanticKeysDo: [:semanticKey | set add: semanticKey].	^set</body><body package="Chronos-Semantic Dates" selector="semanticKeysDo:">semanticKeysDo: block1 	^self semanticKeysFrom: SemanticDatePolicy default do: block1</body><body package="Chronos-Semantic Dates" selector="semanticKeysFrom:do:">semanticKeysFrom: aSemanticDatePolicy do: block1	aSemanticDatePolicy semanticKeysFor: self do: block1</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>semantic keys-examples</category><body package="Chronos-Semantic Dates" selector="isNYSETradingHoliday">isNYSETradingHoliday	"YearMonthDay today isNYSETradingHoliday"	"(YearMonthDay year: 2004 month: December day: 31) isNYSETradingHoliday" "Friday before New Year's Day--a trading day!"	"(YearMonthDay year: 2005 month: March day: 25) isNYSETradingHoliday" "Good Friday"	"(YearMonthDay year: 2004 month: June day: 11) isNYSETradingHoliday" "Funeral of Ronald Reagan"	"(YearMonthDay year: 2001 month: September day: 14) isNYSETradingHoliday" "World Trade Center Event"	"(YearMonthDay year: 1969 month: July day: 21) isNYSETradingHoliday" "Monday after the first Lunar Landing"	"(YearMonthDay year: 1952 month: November day: 8) isNYSETradingHoliday" "A Saturday--but a trading day!"	"(YearMonthDay year: 1933 month: March day: 13) isNYSETradingHoliday" "A Monday--but FDR had all the banks and stock exchanges closed (Great Depression)!"	"| count |	count := 0.	(YearMonthDay year: 2000 month: January day: 14) 		through: YearMonthDay today 		every: 1 		daysDo: [:date | date isNYSETradingHoliday ifFalse: [count := count + 1]].	count" "Count of trading days from 2000-01-14 through today."	^(self 		semanticKeyFrom: SemanticDatePolicy nyse		detect: 			[:semanticKey | 			semanticKey == #weekend 				ifTrue: 					[(self year between: 1873 and: 1952) "Open for a 2-hour trading session on Saturdays from 1873 to 1952!"						ifTrue: [self dayOfWeek = Sunday]						ifFalse: [true]]				ifFalse: [true]]		ifNone: []) notNil</body><body package="Chronos-Semantic Dates" selector="isUSFederalHoliday">isUSFederalHoliday	"(YearMonthDay year: 2004 month: 12 day: 31) isUSFederalHoliday"	^self annualDateSemanticKeyFrom: SemanticDatePolicy unitedStates		satisfies: 			[:semanticKey | 			SemanticDatePolicy usFederalHolidaySemanticKeys includes: semanticKey]</body><body package="Chronos-Semantic Dates" selector="isWeekendDay">isWeekendDay	"(YearMonthDay year: 2006 month: 01 day: 01) isWeekendDay"	^self dayOfWeekSemanticKeySatisfies: [:semanticKey | semanticKey == #weekend]</body></methods><methods><class-id>Chronos.AbstractDate</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	"If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy default (or ChronosPrintPolicy ansiStandard or ChronosPrintPolicy iso8601,) AND if the receiver does not represent a partial date (such as an AnnualDate,) then the receiver's printString will be formatted as required by the ISO 8601 Standard."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printDate: self on: stream</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>instance creation-local time-current</category><body package="Chronos-DateTimeInterval" selector="atFirstDayOfMonth">atFirstDayOfMonth	"{YearMonthDay atFirstDayOfMonth}"	^self today atFirstDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="atFirstDayOfWeek">atFirstDayOfWeek	"{YearMonthDay atFirstDayOfWeek}"	^self today atFirstDayOfWeek</body><body package="Chronos-DateTimeInterval" selector="atFirstDayOfYear">atFirstDayOfYear	"{YearMonthDay atFirstDayOfYear}"	^self today atFirstDayOfYear</body><body package="Chronos-DateTimeInterval" selector="atLastDayOfMonth">atLastDayOfMonth	"{YearMonthDay atLastDayOfMonth}"	^self today atLastDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="atLastDayOfWeek">atLastDayOfWeek	"{YearMonthDay atLastDayOfWeek}"	^self today atLastDayOfWeek</body><body package="Chronos-DateTimeInterval" selector="atLastDayOfYear">atLastDayOfYear	"{YearMonthDay atLastDayOfYear}"	^self today atLastDayOfYear</body><body package="Chronos-DateTimeInterval" selector="today">today	^AnsiStandardCalendarClock dateToday</body><body package="Chronos-DateTimeInterval" selector="todayAs:">todayAs: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock dateToday	"{DateFactory todayAs: Gregorian}"	"{DateFactory todayAs: #Gregorian}" 		"{DateFactory todayAs: GregorianCalendar}" 	"{DateFactory todayAs: Julian}" 		"{DateFactory todayAs: #Julian}" 			"{DateFactory todayAs: JulianCalendar}"			"{DateFactory todayAs: #Bahai}" 			"{DateFactory todayAs: BahaiCalendar}"	"{DateFactory todayAs: #Coptic}" 			"{DateFactory todayAs: CopticCalendar}"	"{DateFactory todayAs: #Ethiopic}" 			"{DateFactory todayAs: EthiopicCalendar}"	"{DateFactory todayAs: #Hebrew}" 			"{DateFactory todayAs: HebrewCalendar}"	"{DateFactory todayAs: #Indian}" 			"{DateFactory todayAs: IndianCalendar}"	"{DateFactory todayAs: #'Islamic-Fatimid'}" 	"{DateFactory todayAs: IslamicFatimidCalendar}"	"{DateFactory todayAs: #Persian}" 			"{DateFactory todayAs: PersianCalendar}"	"{DateFactory todayAs: #Solarian}" 			"{DateFactory todayAs: SolarianCalendar}"</body><body package="Chronos-DateTimeInterval" selector="todayIn:">todayIn: aTimezone	^AnsiStandardCalendarClock dateTodayIn: aTimezone</body><body package="Chronos-DateTimeInterval" selector="todayIn:as:">todayIn: aTimezone as: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock dateTodayIn: aTimezone</body><body package="Chronos-DateTimeInterval" selector="tomorrow">tomorrow	^self today tomorrow</body><body package="Chronos-DateTimeInterval" selector="yesterday">yesterday	^self today yesterday</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>instance creation-local time</category><body package="Chronos-DateTimeInterval" selector="year:calendarDay:">year: year calendarDay: aCalendarDay	^self basicNew		basicSetYear: year calendarDay: aCalendarDay;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:">year: year day: dayOfYear	^self basicNew		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:calendar:">year: year day: dayOfYear calendar: calendar	^self basicNew		setCalendar: calendar;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:">year: year month: month day: dayOfMonth	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:calendar:">year: year month: month day: dayOfMonth calendar: calendar	"{(DateFactory year: 5766 month: 1 day: 1 calendar: HebrewCalendar) as: GregorianCalendar}"	"{(DateFactory year: 5766 month: 1 day: 1 calendar: HebrewCalendar canonical) as: Calendar gregorian}"	"{(DateFactory year: 5766 month: 1 day: 1 calendar: #Hebrew) as: #Gregorian}"	"{(DateFactory year: 5766 month: 1 day: 1 calendar: #Hebrew) as: Gregorian}"	^self basicNew		setCalendar: calendar;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>instance creation</category><body package="Chronos-DateTimeInterval" selector="fromNative:">fromNative: aNativeTimestampOrDate	^self 		fromNative: aNativeTimestampOrDate 		as: AnsiStandardCalendar</body><body package="Chronos-DateTimeInterval" selector="fromNative:as:">fromNative: aNativeCalendricalCoordinate as: calendar	^(Calendar referencedBy: calendar) clock 		chronosDateFromNativeCalendricalCoordinate: aNativeCalendricalCoordinate</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextDateFrom: stream usingFactory: self</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>instance creation-local time-Julian Days</category><body package="Chronos-DateTimeInterval" selector="julianDay:">julianDay: julianDay	"DateAndTime julianDay: YearMonthDay today julianDay"	^self basicNew		setJulianDay: julianDay;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDay:calendar:">julianDay: julianDay calendar: calendar	^self basicNew		setCalendar: calendar;		setJulianDay: julianDay;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDayNumber:">julianDayNumber: julianDay	"For compatibility with other Date/Time libraries."	^self basicNew		setJulianDayNumber: julianDay;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>instance creation-ISO 8601</category><body package="Chronos-DateTimeInterval" selector="isoYear:week:dayOfWeek:">isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal 	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"YearMonthDay isoYear: 2006 week: 1 dayOfWeek: ISOMonday"	"DateAndTime isoYear: 2006 week: 1 dayOfWeek: ISOMonday"	"{(YearMonthDay year: 2003 month: 12 day: 28)		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (YearMonthDay isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(YearMonthDay year: 2003 month: 12 day: 29) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (YearMonthDay isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(YearMonthDay year: 2005 month: 1 day: 2) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (YearMonthDay isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(YearMonthDay year: 2010 month: 1 day: 3) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (YearMonthDay isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	"{(YearMonthDay year: 2010 month: 1 day: 4) 		isoYearWeekDayOfWeekDo: [:isoYear :isoWeek :isoDayOfWeek | 			(Array with: isoYear with: isoWeek with: isoDayOfWeek) -&gt; (YearMonthDay isoYear: isoYear week: isoWeek dayOfWeek: isoDayOfWeek)]}"	^self basicNew		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>instance creation-local time-since epoch</category><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:">daysSinceEpoch: days	^self basicNew		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:calendar:">daysSinceEpoch: days calendar: calendar	^self basicNew		setCalendar: calendar;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>accessing</category><body package="Chronos-Parsing" selector="defaultParser">defaultParser	^ChronosParser ansiStandard</body></methods><methods><class-id>Chronos.AbstractDate class</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="dateAndTimeNow">dateAndTimeNow	"Answer an Array with first element Date today and second element  	Time now."	| now |	now := self class dateAndTimeFactory now.	^Array with: now asDate with: now timeOfDay</body><body package="Chronos-ST80 (and VW) Compatibility" selector="dayOfWeek:">dayOfWeek: dayName 	"Answer the index in a week, 1 - 7, of the day named dayName.  	Provide an error notification if no such day exists."	"CalendricalCoordinate dayOfWeek: #Sunday"	"Date dayOfWeek: #Sunday"	^(ISODayOfWeekKeys indexOf: dayName ifAbsent: [self signalError: 'Invalid day-of-week key: ', dayName printString])</body><body package="Chronos-ST80 (and VW) Compatibility" selector="daysInMonth:forYear:">daysInMonth: monthName forYear: yearInteger 	"Answer the number of days in the month named monthName in the 	year yearInteger."	^Gregorian daysInMonth: monthName inYear: yearInteger "ST-80 Dates are invariantly Gregorian."</body><body package="Chronos-ST80 (and VW) Compatibility" selector="daysInYear:">daysInYear: yearInteger 	"Answer the number of days in the year, yearInteger."	^Gregorian daysInYear: yearInteger "ST-80 Dates are invariantly Gregorian."</body><body package="Chronos-ST80 (and VW) Compatibility" selector="fromDays:">fromDays: daysSince1901	"YearMonthDay fromDays: Date today asDays"	^self daysSinceEpoch: daysSince1901 + 693960 "1901-01-01."</body><body package="Chronos-ST80 (and VW) Compatibility" selector="indexOfMonth:">indexOfMonth: monthName 	"Answer the index, 1 - 12, of the month monthName. Three letters 	as well as full month names are accepted; upper or lower case okay. 	Provide an error notification if no such month exists."	^monthName size = 3 		ifTrue: 			[ChronosFunction 				indexOfName: monthName				in: (ISOMonthKeys collect: [:monthKey | monthKey copyFrom: 1 to: 3])]		ifFalse: 			[ChronosFunction 				indexOfName: monthName				in: ISOMonthKeys]</body><body package="Chronos-ST80 (and VW) Compatibility" selector="leapYear:">leapYear: yearInteger 	"Answer 1 if the year yearInteger is a leap year;  answer 0 if it is 	not. "	^(Gregorian typeCodeOfYear: yearInteger) - 1 "ST-80 Dates are invariantly Gregorian."		"&lt;Calendar gregorian&gt; (and &lt;Calendar julian&gt;) will always use integer &lt;1&gt; for normal years and integer &lt;2&gt; for leap years. 		Warning: No such invariant holds for all Calendars, which may use more than two codes, and/or may use non-integer values 		(e.g., an Array of the number of days in the months of the year)"</body><body package="Chronos-ST80 (and VW) Compatibility" selector="nameOfDay:">nameOfDay: dayIndex 	"Answer a symbol representing the name of the day indexed by dayIndex (an ISO day-of-week ordinal)."	"CalendricalCoordinate nameOfDay: 1"	"Date nameOfDay: 1"	^ISODayOfWeekKeys at: dayIndex</body><body package="Chronos-ST80 (and VW) Compatibility" selector="nameOfMonth:">nameOfMonth: monthIndex 	"Answer a symbol representing the name of the month indexed by 	monthIndex, 1 - 12."	^Gregorian monthKeyForMonthAt: monthIndex forYearTypeCode: 1 "ST-80 Dates are invariantly Gregorian."		"&lt;Calendar gregorian&gt; (and &lt;Calendar julian&gt;) will always use integer &lt;1&gt; for normal years and integer &lt;2&gt; for leap years. 		Warning: No such invariant holds for all Calendars, which may use more than two codes, and/or may use non-integer values 		(e.g., an Array of the number of days in the months of the year)"</body><body package="Chronos-ST80 (and VW) Compatibility" selector="newDay:month:year:">newDay: day month: monthName year: year 	"Answer with an instance of Date which is the day'th day of the month named 	monthName in the year'th year.  The year may be specified as the actual 	number of years since the beginning of the Roman calendar or the 	number of years since the beginning of the century."	^self newDay: day monthNumber: (self indexOfMonth: monthName) year: year</body><body package="Chronos-ST80 (and VW) Compatibility" selector="newDay:monthNumber:year:">newDay: day monthNumber: monthIndex year: year 	"Answer with an instance of Date which is the day'th day of the month numbered 	monthNumber in the year'th year.  The year may be specified as the actual 	number of years since the beginning of the Roman calendar or the 	number of years since the beginning of the current century."	^self year: year month: monthIndex day: day</body><body package="Chronos-ST80 (and VW) Compatibility" selector="newDay:year:">newDay: dayCount year: referenceYear 	"Answer with a Date which is dayCount days after the beginning of the 	year referenceYear."	"DateFactory newDay: 1461 year: 2000" 	^(Gregorian "ST-80 Dates are invariantly Gregorian."		startingWithYear: referenceYear		addingDays: dayCount "ST-80 permits 'dayCount' to be any value, so we can't limit it to being in the range of a dayOfYear ordinal."		setYearAndCalendarDayInto: self new) beImmutable</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="ansiDayOfWeekOrdinalInYear:">ansiDayOfWeekOrdinalInYear: year	^(self daysSinceStartOfANSIWeekInYear: year) + 1</body><body package="Chronos-Annual Dates" selector="calendarDayInYear:">calendarDayInYear: year 	^self subclassResponsibility</body><body package="Chronos-Annual Dates" selector="dayOfMonthOrdinalInYear:">dayOfMonthOrdinalInYear: year	^(self calendarDayInYear: year) dayOfMonthOrdinal</body><body package="Chronos-Annual Dates" selector="dayOfYearOrdinalInYear:">dayOfYearOrdinalInYear: year	^(self calendarDayInYear: year) dayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="daysInMonthInYear:">daysInMonthInYear: year	^(self calendarDayInYear: year) daysPerMonth</body><body package="Chronos-Annual Dates" selector="daysSinceEpochInYear:">daysSinceEpochInYear: year	^(self calendar daysSinceEpochUpToYear: year) + (self daysSinceStartOfYearInYear: year)</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfANSIWeekInYear:">daysSinceStartOfANSIWeekInYear: year	^self calendar 		daysSinceStartOfANSIWeekFromDaysSinceEpoch: (self daysSinceEpochInYear: year)</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfISOWeekInYear:">daysSinceStartOfISOWeekInYear: year	^self calendar 		daysSinceStartOfISOWeekFromDaysSinceEpoch: (self daysSinceEpochInYear: year)</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfMonthInYear:">daysSinceStartOfMonthInYear: year	^(self calendarDayInYear: year) daysSinceStartOfMonth</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfYearInYear:">daysSinceStartOfYearInYear: year	^(self calendarDayInYear: year) daysSinceStartOfYear</body><body package="Chronos-Annual Dates" selector="daysSinceUnificationEpochInYear:">daysSinceUnificationEpochInYear: year	^(self daysSinceEpochInYear: year) + self calendar unificationDayNumberOfEpoch</body><body package="Chronos-Annual Dates" selector="daysUpToMonthSinceStartOfYearInYear:">daysUpToMonthSinceStartOfYearInYear: year	^(self calendarDayInYear: year) daysSinceStartOfMonth</body><body package="Chronos-Annual Dates" selector="forYear:monthDayDo:">forYear: year monthDayDo: block2	^(self calendarDayInYear: year) monthDayDo: block2</body><body package="Chronos-Annual Dates" selector="inYear:">inYear: year 	^(self class dateFactory basicNew)		basicSetCalendar: self calendar;		setYear: year calendarDay: (self calendarDayInYear: year)</body><body package="Chronos-Annual Dates" selector="isoDayOfWeekOrdinalInYear:">isoDayOfWeekOrdinalInYear: year	^(self daysSinceStartOfISOWeekInYear: year) + 1</body><body package="Chronos-Annual Dates" selector="julianDayInYear:">julianDayInYear: year	^self calendar 		julianDayFromDaysSinceEpoch: (self daysSinceEpochInYear: year)</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinal">maxDayOfYearOrdinal	^self calendar maxDaysPerYear</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinalForYearOfType:">maxDayOfYearOrdinalForYearOfType: yearTypeCode	^(self calendar yearlyCalendarForYearTypeCode: yearTypeCode) daysPerYear</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinal">minDayOfYearOrdinal	^1</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinalForYearOfType:">minDayOfYearOrdinalForYearOfType: yearTypeCode	^1</body><body package="Chronos-Annual Dates" selector="monthKeyInYear:">monthKeyInYear: year	^(self calendarDayInYear: year) monthKey</body><body package="Chronos-Annual Dates" selector="monthOrdinalInYear:">monthOrdinalInYear: year 	^(self calendarDayInYear: year) monthOrdinal</body><body package="Chronos-Annual Dates" selector="monthsSinceStartOfYearInYear:">monthsSinceStartOfYearInYear: year	^(self calendarDayInYear: year) monthsSinceStartOfYear</body><body package="Chronos-Annual Dates" selector="nextYear">nextYear	^self inYear: self year + 1</body><body package="Chronos-Annual Dates" selector="numericMonthDesignatorInYear:">numericMonthDesignatorInYear: year 	^(self calendarDayInYear: year) numericMonthDesignator</body><body package="Chronos-Annual Dates" selector="prevYear">prevYear	^self inYear: self year - 1</body><body package="Chronos-Annual Dates" selector="secondsSinceEpochInYear:">secondsSinceEpochInYear: year	^(self daysSinceEpochInYear: year) * SecondsPerDay</body><body package="Chronos-Annual Dates" selector="startingAt:forYears:">startingAt: firstYear forYears: years 	^years &gt;= 0 		ifTrue: 			[| list |			list := SequenceFactory new: years.			0 to: years - 1 do: [:i | list add: (self inYear: firstYear + i)].			list]		ifFalse: [self startingAt: firstYear + years + 1 forYears: years negated]</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isDayOfMonthInvariant">isDayOfMonthInvariant	^false</body><body package="Chronos-Annual Dates" selector="isDayOfWeekInvariant">isDayOfWeekInvariant	^false</body><body package="Chronos-Annual Dates" selector="isDayOfYearInvariant">isDayOfYearInvariant	^false</body><body package="Chronos-Annual Dates" selector="isMonthKeyInvariant">isMonthKeyInvariant	^false</body><body package="Chronos-Annual Dates" selector="isMonthOrdinalInvariant">isMonthOrdinalInvariant	^false</body><body package="Chronos-Annual Dates" selector="isWeekOfMonthInvariant">isWeekOfMonthInvariant	^false</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>private-comparing</category><body package="Chronos-Annual Dates" selector="compareToCalendricalCoordinate:">compareToCalendricalCoordinate: aCalendricalCoordinate	^self compareToDate: aCalendricalCoordinate</body><body package="Chronos-Annual Dates" selector="compareToDate:">compareToDate: aDate	| leftComparand leftComparandDayOfYear delta |	leftComparand := 		aDate calendar == self calendar			ifTrue: [aDate]			ifFalse: [aDate as: self calendar].	leftComparandDayOfYear := leftComparand dayOfYear.	delta := leftComparandDayOfYear - self maxDayOfYearOrdinal.	delta &gt; 0 ifTrue: [^delta].	delta := leftComparandDayOfYear - self minDayOfYearOrdinal.	delta &lt; 0 ifTrue: [^delta].	^leftComparandDayOfYear - (self dayOfYearOrdinalInYear: leftComparand year)</body><body package="Chronos-Annual Dates" selector="compareToDateAndTime:">compareToDateAndTime: aDateAndTime	^self compareToDate: aDateAndTime</body><body package="Chronos-Annual Dates" selector="compareToDayOfMonth:">compareToDayOfMonth: aDayOfMonth	| diff |	aDayOfMonth == self ifTrue: [^0].	aDayOfMonth calendar = self calendar ifFalse: [^nil].	diff := aDayOfMonth minDayOfYearOrdinal - self minDayOfYearOrdinal.	diff = 0 ifFalse: [^diff].	^aDayOfMonth maxMinDayOfYearDelta - self maxMinDayOfYearDelta</body><body package="Chronos-Annual Dates" selector="compareToDayOfYear:">compareToDayOfYear: aDayOfYear	| diff |	aDayOfYear == self ifTrue: [^0].	aDayOfYear calendar = self calendar ifFalse: [^nil].	diff := aDayOfYear minDayOfYearOrdinal - self minDayOfYearOrdinal.	diff = 0 ifFalse: [^diff].	^aDayOfYear maxMinDayOfYearDelta - self maxMinDayOfYearDelta</body><body package="Chronos-Annual Dates" selector="compareToMonth:">compareToMonth: aMonth	| diff |	aMonth == self ifTrue: [^0].	aMonth calendar = self calendar ifFalse: [^nil].	diff := aMonth minDayOfYearOrdinal - self minDayOfYearOrdinal.	diff = 0 ifFalse: [^diff].	^aMonth maxMinDayOfYearDelta - self maxMinDayOfYearDelta</body><body package="Chronos-Annual Dates" selector="compareToWeekOfMonthDayOfWeek:">compareToWeekOfMonthDayOfWeek:  aWeekOfMonthDayOfWeek	| diff |	aWeekOfMonthDayOfWeek == self ifTrue: [^0].	aWeekOfMonthDayOfWeek calendar == self calendar ifFalse: [^nil].	diff := aWeekOfMonthDayOfWeek minDayOfYearOrdinal - self minDayOfYearOrdinal.	diff = 0 ifFalse: [^diff].	^aWeekOfMonthDayOfWeek maxMinDayOfYearDelta - self maxMinDayOfYearDelta</body><body package="Chronos-Annual Dates" selector="compareToYearMonthDaySpec:">compareToYearMonthDaySpec: aYMDSpec	^(self calendarDayInYear: aYMDSpec year) compareTo: aYMDSpec calendarDay</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>comparing</category><body package="Chronos-Annual Dates" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToAnnualDate: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aCalendrical and: [ex message selector == #compareToAnnualDate:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="calendarDay">calendarDay	^self calendarDayInYear: self year</body><body package="Chronos-Annual Dates" selector="identifiers">identifiers	| identifiers |	identifiers := (Array new: 1) writeStream.	self identifiersDo: [:key :value | identifiers nextPut: key-&gt;value].	^identifiers contents</body><body package="Chronos-Annual Dates" selector="identifiersDo:">identifiersDo: block2	block2 value: #className value: self class name.	block2 value: #calendar value: self calendarRegistrationKey</body><body package="Chronos-Annual Dates" selector="maxMinDayOfYearDelta">maxMinDayOfYearDelta	^self maxDayOfYearOrdinal - self minDayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="selfDescribingKey">selfDescribingKey	^self encodedString asSymbol</body><body package="Chronos-Annual Dates" selector="semanticKey">semanticKey	^self class name</body><body package="Chronos-Annual Dates" selector="year">year	^self clock thisYear</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="asMutableDate">asMutableDate	| thisYear |	thisYear := self year.	^(self class dateFactory basicNew)		basicSetCalendar: self calendar;		setYear: thisYear calendarDay: (self calendarDayInYear: thisYear)</body><body package="Chronos-Annual Dates" selector="asMutableDateAndTime">asMutableDateAndTime	| thisYear |	thisYear := self year.	^(self class dateAndTimeFactory basicNew)		basicSetCalendar: self calendar;		basicSetYear: thisYear calendarDay: (self calendarDayInYear: thisYear);		canonicalize</body><body package="Chronos-Annual Dates" selector="asMutableDateAndTimeInvariantToUT">asMutableDateAndTimeInvariantToUT	| thisYear |	thisYear := self year.	^(self class dateAndTimeFactory basicNew)		basicSetCalendar: self calendar;		basicSetYear: thisYear calendarDay: (self calendarDayInYear: thisYear);		canonicalizeFromLocalTime</body><body package="Chronos-Annual Dates" selector="basicComputeDaysSinceEpoch">basicComputeDaysSinceEpoch	^self daysSinceEpochInYear: self year</body><body package="Chronos-Annual Dates" selector="resolveMonthKeyFromMonthOrdinal:forYearTypeCode:">resolveMonthKeyFromMonthOrdinal: monthOrdinal forYearTypeCode: yearTypeCode	^self calendar monthKeyForMonthAt: monthOrdinal forYearTypeCode: yearTypeCode</body><body package="Chronos-Annual Dates" selector="resolveMonthOrdinalFromMonthKey:forYearTypeCode:">resolveMonthOrdinalFromMonthKey: monthKey forYearTypeCode: yearTypeCode	^self calendar monthOrdinalForMonthWithKey: monthKey forYearTypeCode: yearTypeCode</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>printing</category><body package="Chronos-Annual Dates" selector="encodeOn:">encodeOn: stream 	| literalArray encodeAspect |	literalArray := self literalArrayEncoding.	encodeAspect := [:value | 		value isString 			ifTrue: [stream nextPutAll: value]			ifFalse: [stream print: value]].	literalArray at: 1 put: self class name.	stream nextPut: $(.	1 to: literalArray size - 1 do: 			[:index | 			encodeAspect value: (literalArray at: index).			stream nextPut: $|].	encodeAspect value: literalArray last.		stream nextPut: $).</body><body package="Chronos-Annual Dates" selector="encodedString">encodedString	| stream |	stream := (String new: 320) writeStream.	self encodeOn: stream.	^stream contents</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printAnnualDate: self on: stream</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>converting</category><body package="Chronos-Annual Dates" selector="asDate">asDate	"Answer the conversion of the receiver into a date-valued CalendricalCoordinate that represents the same date as does the receiver.  If the receiver is already a date-valued CalendricalCoordinate, answer the receiver.  A date-valued CalendricalCoordinate is one that specifies a date without specifying a particular time-of-day nor a particular timezone (i.e., it has nominal time semantics, and its quantum of resolution is 1 calendar day.)"	^self asMutableDate beImmutable</body><body package="Chronos-Annual Dates" selector="asDateAndTimeInUTYear:timeZone:">asDateAndTimeInUTYear: year timeZone: timeZone	"GregorianEaster canonical asDateAndTimeInUTYear: 2005 timeZone: 3 hours"	^self 		forYear: year 		monthDayDo: [:month :day | 			self class dateAndTimeFactory				utYear: year				month: month				day: day				timeZone: timeZone				calendar: self calendar]</body><body package="Chronos-Annual Dates" selector="asDateAndTimeInYear:">asDateAndTimeInYear: year	"GregorianEaster canonical asDateAndTimeInYear: 2005"	^self 		forYear: year 		monthDayDo: [:month :day | 			self class dateAndTimeFactory				year: year				month: month				day: day				calendar: self calendar]</body><body package="Chronos-Annual Dates" selector="asDateAndTimeInYear:timeZone:">asDateAndTimeInYear: year timeZone: timeZone	"GregorianEaster canonical asDateAndTimeInYear: 2005 timeZone: 3 hours"	^self 		forYear: year 		monthDayDo: [:month :day | 			self class dateAndTimeFactory				year: year				month: month				day: day				timeZone: timeZone				calendar: self calendar]</body><body package="Chronos-Annual Dates" selector="asDateAndTimeSpecInYear:">asDateAndTimeSpecInYear: year	"GregorianEaster canonical asDateAndTimeSpecInYear: 2005"	| thisYear |	thisYear := self year.	^(DateAndTimeSpec new)		setYear: thisYear calendarDay: (self calendarDayInYear: thisYear)</body><body package="Chronos-Annual Dates" selector="asDateInYear:">asDateInYear: year	"GregorianEaster canonical asDateInYear: 2005"	^(self class dateFactory basicNew)		basicSetCalendar: self calendar;		setYear: year calendarDay: (self calendarDayInYear: year)</body><body package="Chronos-Annual Dates" selector="asDateSpecInYear:">asDateSpecInYear: year	"GregorianEaster canonical asDateSpecInYear: 2005"	^(DateSpec basicNew)		setYear: year calendarDay: (self calendarDayInYear: year)</body><body package="Chronos-Annual Dates" selector="asFlyweight">asFlyweight	^self class registry at: self selfDescribingKey ifAbsentPut: [self]</body><body package="Chronos-Annual Dates" selector="dateSpec">dateSpec	| year |	year := self year.	^DateSpec year: year calendarDay: (self calendarDayInYear: year)</body><body package="Chronos-Annual Dates" selector="thisYear">thisYear	^self inYear: self year</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>accessing-multivalued</category><body package="Chronos-Annual Dates" selector="yearAndCalendarDayDo:">yearAndCalendarDayDo: block2	| year |	year := self year. 	^block2 value: year value: (self calendarDayInYear: year)</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processAnnualDate: self</body></methods><methods><class-id>Chronos.AnnualDate</class-id> <category>deprecated</category><body package="Chronos-Annual Dates" selector="lastYear">lastYear	^self inYear: self year - 1</body></methods><methods><class-id>Chronos.AnnualDate class</class-id> <category>instance creation</category><body package="Chronos-Annual Dates" selector="decodeFrom:">decodeFrom: stream	"{AnnualDate decodeFrom: (WeekOfMonthDayOfWeek month: October week: 0 dayOfWeek: Sunday) encodedString readStream}"	"{AnnualDate decodeFrom: GregorianEaster canonical encodedString readStream}"		ChronosFunction skipSeparators: stream.	(stream peekFor: $()		ifFalse: [^self signalError: 'Invalid encoding format--must begin with `(`'].	^self decodeFromLiteralArray: (ChronosFunction componentsFromString: (ChronosFunction nextFrom: stream until: [:ch | ch = $)]) separator: $|)</body><body package="Chronos-Annual Dates" selector="gregorianNewYear">gregorianNewYear	^self newYearsDayInCalendar: Gregorian</body><body package="Chronos-Annual Dates" selector="newYearsDayInCalendar:">newYearsDayInCalendar: calendar	^DayOfYearFactory  		ordinal: 1		calendar: calendar</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	"Parser support not yet implemented."	^self decodeFrom: stream</body></methods><methods><class-id>Chronos.AnnualDate class</class-id> <category>class initialization</category><body package="Chronos-Annual Dates" selector="initialize">initialize	"AnnualDate initialize."	Registry := nil</body></methods><methods><class-id>Chronos.AnnualDate class</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="at:">at: selfDesribingKey 	"Answers a flyweight instance of an AnnualDate as specified by &lt;selfDesribingKey&gt;.  If no AnnualDate with the same value is currently registered as a flyweight, a new one will be created and registered."	| key value |	key := selfDesribingKey asSymbol.	value := self registry at: key ifAbsentPut: [self decodeFrom: selfDesribingKey readStream].	value == nil 		ifTrue: 			[value := self decodeFrom: selfDesribingKey readStream.			self registry at: key put: value].	^value</body><body package="Chronos-Annual Dates" selector="at:ifAbsent:">at: selfDescribingKey ifAbsent: block0	"Answers a flyweight instance of an AnnualDate as specified by &lt;selfDesribingKey&gt;.  If no AnnualDate with the same value is currently registered as a flyweight, the result of evaluating &lt;block0&gt; will be returned."	| value |	value := self registry at: selfDescribingKey asSymbol ifAbsent: [^block0 value].	^value == nil			ifTrue: [block0 value]		ifFalse: [value]</body><body package="Chronos-Annual Dates" selector="referencedBy:">referencedBy: aChronosObjectOrChronosObjectLiteralString	"Anser the value referenced by &lt;aChronosObjectOrChronosObjectLiteralString&gt;. If the value is a key, answer the value bound to the key. If the value is a literal representation of a value encoded as a String, answer the result of decoding the value encoded by the String.  Otherwise, answer the value of &lt;aChronosObjectOrChronosObjectLiteralString&gt; itself."	aChronosObjectOrChronosObjectLiteralString isString ifFalse: [^aChronosObjectOrChronosObjectLiteralString].	^self at: aChronosObjectOrChronosObjectLiteralString</body></methods><methods><class-id>Chronos.AnnualDate class</class-id> <category>examples</category><body package="Chronos-Annual Dates" selector="showDateOfEasterForNextTenYears">showDateOfEasterForNextTenYears	"AnnualDate showDateOfEasterForNextTenYears"	| year |	year := GregorianCalendar clock thisYear.	Transcript cr.	10 timesRepeat:		[Transcript cr; show: (GregorianEaster canonical inYear: year) localePrintString.		year := year + 1].</body><body package="Chronos-Annual Dates" selector="showSelectedJewishHolidaysForThisYearAndNextYear">showSelectedJewishHolidaysForThisYearAndNextYear	"AnnualDate showSelectedJewishHolidaysForThisYearAndNextYear"	| year roshHoshannah yomKippur khanukkah purim pesach list printSpec |	year := HebrewCalendar clock thisYear.	roshHoshannah := 	DayOfMonth monthKey: #Tishri 	day: 1   calendar: #Hebrew.	yomKippur := 		DayOfMonth monthKey: #Tishri 	day: 10 calendar: #Hebrew.	khanukkah :=		DayOfMonth monthKey: #Kislev 	day: 25 calendar: #Hebrew.	purim := 				DayOfMonth monthKey: #Adar 	day: 14 calendar: #Hebrew.	pesach :=			DayOfMonth monthKey: #Nisan 	day: 15 calendar: #Hebrew.	list := OrderedCollection new.	printSpec := #(showDayOfWeekAbbreviation useMonthName dateSeparator: $ datePadChar: nil).	2 timesRepeat: [		| hDate |		hDate := roshHoshannah inYear: year. 		list add: (Array 					with: #'Rosh Hoshannah' 					with: hDate % printSpec 					with: hDate asGregorian % printSpec).		hDate := yomKippur inYear: year. 		list add: (Array					with: #'Yom Kippur' 					with: hDate % printSpec 					with: hDate asGregorian % printSpec).		hDate := khanukkah inYear: year. 		list add: (Array 					with: #'Khanukkah' 					with: hDate % printSpec 					with: hDate asGregorian % printSpec).		hDate := purim inYear: year. 		list add: (Array 					with: #'Purim' 					with: hDate % printSpec 					with: hDate asGregorian % printSpec).		hDate := pesach inYear: year. 		list add: (Array 					with: #'Pesach' 					with: hDate % printSpec 					with: hDate asGregorian % printSpec).		year := year + 1].	Transcript cr.	list do: 		[:array | 			Transcript 				cr; show: (array at: 1); show: ':';  				cr; tab; show: (array at: 2); 				cr; tab; show: (array at: 3); 				show: ' (starting sundown of the day before)']</body></methods><methods><class-id>Chronos.AnnualDate class</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="registry">registry	Registry == nil ifTrue: [Registry := EnvironmentFacade current newWeakDictionary].	^Registry</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>testing</category><body package="Passport-Kernel" selector="syntaxPermitsFragment">syntaxPermitsFragment	^false</body><body package="Passport-Kernel" selector="syntaxPermitsHostname">syntaxPermitsHostname	^true</body><body package="Passport-Kernel" selector="syntaxPermitsPort">syntaxPermitsPort	^false</body><body package="Passport-Kernel" selector="syntaxPermitsProtocol">syntaxPermitsProtocol	^false</body><body package="Passport-Kernel" selector="syntaxPermitsQueryString">syntaxPermitsQueryString	^false</body><body package="Passport-Kernel" selector="syntaxPermitsUserCredentials">syntaxPermitsUserCredentials	^false</body><body package="Passport-Kernel" selector="syntaxRequiresHostname">syntaxRequiresHostname	^false</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>printing services</category><body package="Passport-Kernel" selector="encodeString:on:">encodeString: aString on: stream	stream nextPutAll: aString</body><body package="Passport-Kernel" selector="print:on:">print: aResourcePath on: stream 	self syntaxPermitsProtocol ifTrue: [self printProtocolOf: aResourcePath on: stream].	(self syntaxRequiresHostname or: [aResourcePath isRemote])		ifTrue: 			[self printAuthorityOf: aResourcePath on: stream.			self printNamespaceOf: aResourcePath isPrefixed: true on: stream]		ifFalse: [self printNamespaceOf: aResourcePath isPrefixed: false on: stream].	self printPathnameOf: aResourcePath on: stream.	self syntaxPermitsQueryString ifTrue: [self printQueryOf: aResourcePath on: stream].	self syntaxPermitsFragment ifTrue: [self printFragmentOf: aResourcePath on: stream].</body><body package="Passport-Kernel" selector="printAuthorityOf:on:">printAuthorityOf: aResourcePath on: stream 	| separator credentialsPrinted hasDefaultPort |	separator := self pathnameSeparator.	stream		nextPut: separator;		nextPut: separator.	credentialsPrinted := false.	self syntaxPermitsUserCredentials 		ifTrue: [credentialsPrinted := self printUserAndPasswordOf: aResourcePath on: stream].	hasDefaultPort := aResourcePath hasDefaultPort.	(credentialsPrinted or: [self syntaxRequiresHostname or: [aResourcePath isRemote or: [hasDefaultPort not]]]) 		ifTrue: [stream nextPutAll: aResourcePath hostname].	hasDefaultPort 		ifFalse: 			[stream 				nextPut: $:;				print: aResourcePath port].</body><body package="Passport-Kernel" selector="printFragmentOf:on:">printFragmentOf: aResourcePath on: stream 	aResourcePath hasFragment 		ifTrue: 			[stream nextPut: $#.			self encodeString: aResourcePath fragment on: stream]</body><body package="Passport-Kernel" selector="printNamespaceOf:isPrefixed:on:">printNamespaceOf: aResourcePath isPrefixed: isPrefixed on: stream 	| separator |	separator := self pathnameSeparator.	aResourcePath specifiesNamespace 		ifTrue: [self basicPrintNamespaceOf: aResourcePath isPrefixed: isPrefixed on: stream]		ifFalse: 			[isPrefixed 				ifTrue: [stream nextPut: separator]				ifFalse: 					[stream nextPutAll: self currentDirectoryMetavalueString.					aResourcePath pathnameIsEmpty ifFalse: [stream nextPut: separator]]]</body><body package="Passport-Kernel" selector="printPathnameOf:on:">printPathnameOf: aResourcePath on: stream 	aResourcePath pathnameIsEmpty 		ifFalse: [aResourcePath pathname printOn: stream usingSeparator: self pathnameSeparator]</body><body package="Passport-Kernel" selector="printProtocolOf:on:">printProtocolOf: aResourcePath on: stream 	stream		nextPutAll: self protocol;		nextPut: $:</body><body package="Passport-Kernel" selector="printQueryOf:on:">printQueryOf: aResourcePath on: stream 	| count |	count := aResourcePath queryCount.	count &gt; 0		ifTrue: 			[stream nextPut: $?.			aResourcePath 				queryKeysAndValuesDo:					[:key :value | 					self encodeString: key isInQuery: true on: stream.					stream nextPut: $=.					self encodeString: value isInQuery: true on: stream.					count := count - 1.					count &gt; 0 ifTrue: [stream nextPut: $&amp;]]]</body><body package="Passport-Kernel" selector="printUserAndPasswordOf:on:">printUserAndPasswordOf: aResourcePath on: stream 	^aResourcePath specifiesUser 		ifTrue: 			[self encodeString: aResourcePath user on: stream.			aResourcePath specifiesPassword 				ifTrue: 					[stream nextPut: $:.					self encodeString: aResourcePath password on: stream].			stream nextPut: $@.			true]		ifFalse: 			[aResourcePath specifiesPassword 				ifTrue: 					[stream nextPut: $:.					self encodeString: aResourcePath password on: stream.					stream nextPut: $@.					true]				ifFalse: [false]]</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>private</category><body package="Passport-Kernel" selector="basicPrintNamespaceOf:isPrefixed:on:">basicPrintNamespaceOf: aResourcePath isPrefixed: isPrefixed on: stream 	| ns |	ns := aResourcePath basicNamespace.	ns == nil ifTrue: [ns := self defaultNamespace].	ns = self rootDirectoryMetavalueString 		ifTrue: [stream nextPutAll: self defaultRootDirectoryString]		ifFalse: 			[ns isEmpty 				ifTrue: [isPrefixed ifTrue: [stream nextPut: self pathnameSeparator]]				ifFalse: 					[isPrefixed ifTrue: [ns first = self pathnameSeparator ifFalse: [stream nextPut: self pathnameSeparator]].					stream nextPutAll: ns.					ns last = self pathnameSeparator 						ifFalse: [stream nextPut: self pathnameSeparator]]]</body><body package="Passport-Kernel" selector="newDefaultRootDirectoryString">newDefaultRootDirectoryString	| separator |	separator := self pathnameSeparator.	^separator = $: ifTrue: [''] ifFalse: [String with: separator]</body><body package="Passport-Kernel" selector="newResourcePath">newResourcePath	^(ResourcePath new)		setResourcePathContext: self resourcePathContext;		setProtocol: self protocol</body><body package="Passport-Kernel" selector="newRootDirectoryMetavalueString">newRootDirectoryMetavalueString	^String with: (Character codePoint: 0)</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="initialize">initialize	rootDirectoryMetavalueString := self newRootDirectoryMetavalueString.	defaultRootDirectoryString := self newDefaultRootDirectoryString</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>accessing</category><body package="Passport-Kernel" selector="currentDirectoryMetavalueString">currentDirectoryMetavalueString	"Answer a String that is a metavalue signifying the current derfault directory/folder." 	^'.' "Unix/WIndows; won't work on the Macintosh (which uses ':')"</body><body package="Passport-Kernel" selector="defaultDirectoryPathnameString">defaultDirectoryPathnameString	"Answer a String that names/identifies the pathname of the external-file namespace relative to which non-absolute filenames will be interpreted.  In more conventional terminology, answer a String naming/identifying the actual full absolute pathname of the current default directory/folder.  It is acceptable, but not ideal, to answer a metavalue that serves as an indirect reference to the default directory (e.g., '.' on UNIX/Windows systems, and ':' on the Macintosh.) If not answering a metavalue, the answered String must start with the root directory of the current default volume/device (e.g., '/' on a Unix system, 'C:\' or 'D:\' (or whatever volume is the default) on a Windows system.)" 	^self currentDirectoryMetavalueString "Not ideal--subimplementing is recommended."</body><body package="Passport-Kernel" selector="defaultNamespace">defaultNamespace	^self resourcePathContext isPlatformDefault 		ifTrue: [self defaultDirectoryPathnameString]		ifFalse: 			[self resourcePathContext defaultNamespaceAt: self protocol				ifAbsent: [self defaultDirectoryPathnameString]]</body><body package="Passport-Kernel" selector="defaultRootDirectoryString">defaultRootDirectoryString	defaultRootDirectoryString == nil ifTrue: [defaultRootDirectoryString := self newDefaultRootDirectoryString].	^defaultRootDirectoryString</body><body package="Passport-Kernel" selector="fileExtensionSeparator">fileExtensionSeparator	"Answer the character that is used to separate file extensions from the rest of the file's name."	^$.</body><body package="Passport-Kernel" selector="pathnameSeparator">pathnameSeparator	"Answer the character that is used to separate file pathname components (in other words, the directory separator character.)"	^$/</body><body package="Passport-Kernel" selector="protocol">protocol	^#platform</body><body package="Passport-Kernel" selector="resourcePathContext">resourcePathContext	^resourcePathContext == nil 		ifTrue: 			[self protocol == #platform 				ifTrue: [ResourcePathContext platformDefault]				ifFalse: [ResourcePathContext default]]		ifFalse: [resourcePathContext]</body><body package="Passport-Kernel" selector="resourcePathContext:">resourcePathContext: aResourcePathContext	resourcePathContext := aResourcePathContext.</body><body package="Passport-Kernel" selector="rootDirectoryMetavalueString">rootDirectoryMetavalueString	"Answer a String that is a metavalue signifying the current derfault directory/folder." 	rootDirectoryMetavalueString == nil ifTrue: [rootDirectoryMetavalueString := self newRootDirectoryMetavalueString].	^rootDirectoryMetavalueString</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>directory services</category><body package="Passport-Kernel" selector="copyResource:to:">copyResource: sourceOperand to: destinationOperand 	"Copy the contents of the resource (e.g., a file) named/identified by &lt;sourceOperand&gt; to &lt;destinationOperand&gt;.  If the resource named/identified by &lt;destinationOperand&gt; does not exist, create it. If a resource so-named already exists, make it have exactly the same contents as the resource named/identified by &lt;sourceNativeFileID&gt;."	| sourceStream targetStream |	sourceStream := self newExternalReadStream: sourceOperand type: #binary.	[targetStream := 		self 			newExternalWriteStream: destinationOperand			mode: #truncate			check: false			type: #binary.	[[sourceStream atEnd] whileFalse: [targetStream nextPut: sourceStream next]] 		ensure: [targetStream close]] 			ensure: [sourceStream close]</body><body package="Passport-Kernel" selector="deleteResource:">deleteResource: operand	"Delete the resource (e.g., a file) named/identified by &lt;operand&gt;. If the resource named/identified by &lt;operand&gt; does not exist, raise an exception."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="makeDirectory:">makeDirectory: operand	"Create a directory named &lt;operand&gt;. If the resource named/identified by &lt;operand&gt; already exists, raise an exception. A 'directory'  is a resource that serves as a namespace containing other resources."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="moveResource:to:">moveResource: sourceOperand to: destinationOperand	"Move the resource (e.g., a file) named/identified by &lt;sourceOperand&gt; to &lt;destinationOperand&gt;. If possible, implement the 'move' by removing and adding directory entries, instead of by actually copying the contents of the source resource. However, if that is not possible, then a) copy &lt;sourceOperand&gt; to &lt;destinationOperand&gt;, and then b) delete &lt;sourceOperand&gt;."	self copyResource: sourceOperand to: destinationOperand.	self deleteResource: sourceOperand</body><body package="Passport-Kernel" selector="renameResource:to:">renameResource: originalOperand to: newOperand	"Rename the resource (e.g., a file) named/identified by &lt;originalOperand&gt; to &lt;newOperand&gt;"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="resourceExists:">resourceExists: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; exists"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="resourceIsDirectory:">resourceIsDirectory: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; is a directory.  A resource is a directory if it acts as a namespace containing other resources."	^self subclassResponsibility</body><body package="Passport-Kernel" selector="sizeOfResource:">sizeOfResource: operand	"Answer the size (in bytes) of the resource (e.g., a file) named/identified by &lt;operand&gt;"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="withResourcePathsOfResourcesInDirectory:do:">withResourcePathsOfResourcesInDirectory: operand do: block1	"For each external/persistent/remote resource (e.g., a file) contained by the resource directory named/identified by &lt;operand&gt;, evaluate the one-argument Block &lt;block1&gt; with an argument that is a ResourcePath (which see) naming/identifying the external/persistent/remote resource (e.g, a file.) If &lt;operand&gt; does not name/identify a directory, raise an exception."	^self subclassResponsibility</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>conversion services</category><body package="Passport-Kernel" selector="constructNativeResourceIDFromResourcePath:">constructNativeResourceIDFromResourcePath: aResourcePath	"Answer whatever value the current Smalltalk execution environment canonically would use to name/identify the external/persistent/remote resouce (e.g, a file) referenced by &lt;aResourcePath&gt; (.e.g, a String in Squeak, a Filename in VisualWorks, etc.)"	^self constructNativeResourceIDFromString: (aResourcePath withProtocol: self protocol) printString</body><body package="Passport-Kernel" selector="constructNativeResourceIDFromStream:">constructNativeResourceIDFromStream: aStream	"Answer whatever value the current Smalltalk execution environment canonically would use to name/identify the external/persistent/remote resource (e.g, a file) whose name is contained as the remaining characters in &lt;aStream&gt; (.e.g, a String in Squeak, a Filename in VisualWorks, etc.)"	^self constructNativeResourceIDFromString: aStream upToEnd</body><body package="Passport-Kernel" selector="constructNativeResourceIDFromString:">constructNativeResourceIDFromString: aString	"Answer whatever value the current Smalltalk execution environment canonically would use to name/identify the external/persistent/remote resource (e.g, a file) referenced by &lt;aString&gt; (.e.g, a String in Squeak, a Filename in VisualWorks, etc.)"	^aString	"This may not work in any Smalltalk environment that doesn't use Strings as the canonical form of file identifiers (e.g., VisualWorks, which uses Filename objects.)"</body><body package="Passport-Kernel" selector="constructResourcePathFromNativeResourceID:">constructResourcePathFromNativeResourceID: aNativeResourceID	"Construct and answer a ResourcePath that identifies the same resource (e.g, a file) as does &lt;aNativeResourceID&gt; (where &lt;aNativeResourceID&gt; is an object canonically used by the host Smalltalk implementation to name/identify external/persistent/remote resources;) in most Smalltalk implementations such an object would be a String.)"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="constructResourcePathFromStream:">constructResourcePathFromStream: aStream	"Construct and answer a ResourcePath that identifies the same resource (e.g., a file) as does the characters remaining in &lt;aStream&gt; (where those characters are assumed to specify a pathname to a resource with the same syntax as would be used by the host Smalltalk environment.)"	^self constructResourcePathFromString: aStream upToEnd</body><body package="Passport-Kernel" selector="constructResourcePathFromString:">constructResourcePathFromString: aString	"Construct and answer a ResourcePath that identifies the same resource (e.g., a file) as does &lt;aString&gt; (where &lt;aString&gt; is a pathname to a resource with the same syntax as would be used by the host Smalltalk environment.)"	^self constructResourcePathFromNativeResourceID: (self constructNativeResourceIDFromString: aString)</body><body package="Passport-Kernel" selector="operandFromResourcePath:">operandFromResourcePath: aResourcePath	^aResourcePath asNative</body></methods><methods><class-id>Passport.ResourcePathFacade</class-id> <category>stream creation</category><body package="Passport-Kernel" selector="newExternalReadStream:type:">newExternalReadStream: operand type: fileType	"Synopsis		Returns an external readStream that reads from the external data source with the given name.	Specification (based on ANSI Smalltalk standard)		Locate an external data source that is identified by the value of &lt;operand&gt;. The &lt;operand&gt; parameter is an instance of whatever class the host Smalltalk implementation would canonically use to identify an external data source (e.g., a Strring, a Filename, a URL, etc.)  If &lt;operand&gt; is a String (or if its content requires syntactical interpretation,) then its syntax is implementation-dependent.		Return an object conforming to the ANSI &lt;readFileStream&gt; protocol whose future sequence values initially consist of the elements of the external data source and which initially has no past sequence values. The ordering of the sequence values is the same as the ordering within the external data source. The external data source serves as the stream backing store of the returned object. The value of &lt;fileType&gt; determines the external stream type and sequence value type of the result object.	Parameters		operand 		&lt;readableString&gt; 	identifies the external data source (typically, but not necessarily, a disk file)		fileType		&lt;symbol&gt; 			an enumeration constant that specifies the type of the external data source, as defined by the ANSI Smalltalk standard	Return Value		&lt;readFileStream&gt; new	Errors		It is an error if the data source identified by &lt;operand&gt; does not exist, or if the user does not have read access permission"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="newExternalWriteStream:mode:check:type:">newExternalWriteStream: operand mode: mode check: enforceExistentialConstraint type: fileType	"Synopsis		Returns an external writeStream that writes to the external data source with the given name.	Specification (based on ANSI Smalltalk standard)		Depending upon the values of &lt;enforceExistentialConstraint&gt; and &lt;mode&gt;, either a) create a new external data source, or b) locate an existing external data source, which in either case is identified by the value of &lt;operand&gt;. The &lt;operand&gt; parameter is an instance of whatever class the host Smalltalk implementation would canonically use to identify an external data source (e.g., a Strring, a Filename, a URL, etc.)  If &lt;operand&gt; is a String (or if its content requires syntactical interpretation,) then its syntax is implementation-dependent.		Return an object conforming to the ANSI Smalltalk &lt;writeFileStream&gt; protocol. The external data source serves as the stream backing store of the returned object. The returned object is a write-back stream. The value of &lt;fileType&gt; determines the external stream type and sequence value type of the result object.		Valid values for &lt;mode&gt; are: #’create’, #’append’, and #’truncate’. The meaning of these values are:				#’create’ create a new external data source, with initial position at the beginning				#’append’ use an existing external data source, with initial position at its end				#’truncate’ use an existing external data source, initially truncating it.		The value of &lt;mode&gt; determines the initial state of the past sequence values and future sequence values of the result object. If &lt;mode&gt; is #’create’ or #’truncate’ the past sequence values and future sequence values are both initially empty. If &lt;mode&gt; is #’append’ the past sequence values initially consist of the elements of the external data source and future sequence values is initially empty. The ordering of the sequence values is the same as the ordering within the external data source. The &lt;enforceExistentialConstraint&gt; flag determines whether the data source specified by &lt;operand&gt; must exist or not exist.		If &lt;mode&gt; = #’create’ and &lt;enforceExistentialConstraint&gt; = false and the data source exists, then the existing file is used.		If &lt;mode&gt; = #’append’ and &lt;enforceExistentialConstraint&gt; = false and the data source does not exist, then it is created.		If &lt;mode&gt; = #’truncate’ and &lt;enforceExistentialConstraint&gt; = false and the data source  does not exist, then it is created.		This operation is undefined if a value other than #’create’, #’append’ or #’truncate’ is used as the &lt;mode&gt; argument.	Parameters		operand 						&lt;readableString&gt; 	identifies the external data source (typically, but not necessarily, a disk file)		mode 						&lt;symbol&gt; 			an enumeration constant that specifies the initial state of the external stream, as defined by the ANSI Smalltalk standard		enforceExistentialConstraint 	&lt;boolean&gt; 			specifies whether or not the existence or non-existence of the data source identified by &lt;operand&gt; is an error		fileType						&lt;symbol&gt; 			an enumeration constant that specifies the type of the external data source, as defined by the ANSI Smalltalk standard	Return Value		&lt;writeFileStream&gt; new	Errors		If &lt;mode&gt; = #create and &lt;enforceExistentialConstraint&gt; = true and the file exists.		If &lt;mode&gt; = #append and &lt;enforceExistentialConstraint&gt; = true and the file does not exist.		If &lt;mode&gt; = #truncate and &lt;enforceExistentialConstraint&gt; = true and the file does not exist.		If the user does not have write permissions for the external data source.		If the user does not have creation permissions for an external data source that is to be created."	^self subclassResponsibility</body></methods><methods><class-id>Passport.ResourcePathFacade class</class-id> <category>instance creation</category><body package="Passport-Kernel" selector="resourcePathContext:">resourcePathContext: aResourcePathManager 	^self new resourcePathContext: aResourcePathManager</body></methods><methods><class-id>Passport.VWFilenameFacade</class-id> <category>directory services</category><body package="Passport-Kernel-VW" selector="copyResource:to:">copyResource: sourceOperand to: destinationOperand 	"Copy the contents of the resource (e.g., a file) named/identified by &lt;sourceOperand&gt; to &lt;destinationOperand&gt;.  If the resource named/identified by &lt;destinationOperand&gt; does not exist, create it. If a resource so-named already exists, make it have exactly the same contents as the resource named/identified by &lt;sourceNativeFileID&gt;."	sourceOperand copyTo: destinationOperand</body><body package="Passport-Kernel-VW" selector="deleteResource:">deleteResource: operand	"Delete the resource (e.g., a file) named/identified by &lt;operand&gt;. If the resource named/identified by &lt;operand&gt; does not exist, raise an exception."	operand delete</body><body package="Passport-Kernel-VW" selector="makeDirectory:">makeDirectory: operand	"Create a directory named &lt;operand&gt;. If the resource named/identified by &lt;operand&gt; already exists, raise an exception. A 'directory'  is a resource that serves as a namespace containing other resources."	operand makeDirectory</body><body package="Passport-Kernel-VW" selector="moveResource:to:">moveResource: sourceOperand to: destinationOperand	"Move the resource (e.g., a file) named/identified by &lt;sourceOperand&gt; to &lt;destinationOperand&gt;. If possible, implement the 'move' by removing and adding directory entries, instead of by actually copying the contents of the source resource. However, if that is not possible, then a) copy &lt;sourceOperand&gt; to &lt;destinationOperand&gt;, and then b) delete &lt;sourceOperand&gt;."	sourceOperand moveTo: destinationOperand</body><body package="Passport-Kernel-VW" selector="renameResource:to:">renameResource: originalOperand to: newOperand	"Rename the resource (e.g., a file) named/identified by &lt;originalOperand&gt; to &lt;newOperand&gt;"	originalOperand renameTo: newOperand</body><body package="Passport-Kernel-VW" selector="resourceExists:">resourceExists: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; exists"	^[operand exists] on: Error do: [:ex | ex return: false]</body><body package="Passport-Kernel-VW" selector="resourceIsDirectory:">resourceIsDirectory: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; is a directory.  A resource is a directory if it acts as a namespace containing other resources."	^operand isDirectory</body><body package="Passport-Kernel-VW" selector="sizeOfResource:">sizeOfResource: operand	"Answer the size (in bytes) of the resource (e.g., a file) named/identified by &lt;operand&gt;"	^operand fileSize</body><body package="Passport-Kernel-VW" selector="withResourcePathsOfResourcesInDirectory:do:">withResourcePathsOfResourcesInDirectory: operand do: block1	"For each external/persistent/remote resource (e.g., a file) contained by the resource directory named/identified by &lt;operand&gt;, evaluate the one-argument Block &lt;block1&gt; with an argument that is a ResourcePath (which see) naming/identifying the external/persistent/remote resource (e.g, a file.) If &lt;operand&gt; does not name/identify a directory, raise an exception."	| directory |	directory := self constructResourcePathFromNativeResourceID: operand.	operand directoryContents do: [:each | block1 value: (directory appending: each)]</body></methods><methods><class-id>Passport.VWFilenameFacade</class-id> <category>stream creation</category><body package="Passport-Kernel-VW" selector="newExternalReadStream:type:">newExternalReadStream: operand type: fileType	"Synopsis		Returns an external readStream that reads from the external data source with the given name.	Specification (based on ANSI Smalltalk standard)		Locate an external data source that is identified by the value of &lt;operand&gt;. The &lt;operand&gt; parameter is an instance of whatever class the host Smalltalk implementation would canonically use to identify an external data source (e.g., a Strring, a Filename, a URL, etc.)  If &lt;operand&gt; is a String (or if its content requires syntactical interpretation,) then its syntax is implementation-dependent.		Return an object conforming to the ANSI &lt;readFileStream&gt; protocol whose future sequence values initially consist of the elements of the external data source and which initially has no past sequence values. The ordering of the sequence values is the same as the ordering within the external data source. The external data source serves as the stream backing store of the returned object. The value of &lt;fileType&gt; determines the external stream type and sequence value type of the result object.	Parameters		operand 		&lt;readableString&gt; 	identifies the external data source (typically, but not necessarily, a disk file)		fileType		&lt;symbol&gt; 			an enumeration constant that specifies the type of the external data source, as defined by the ANSI Smalltalk standard	Return Value		&lt;readFileStream&gt; new	Errors		It is an error if the data source identified by &lt;operand&gt; does not exist, or if the user does not have read access permission"	| stream |	stream := operand readStream.	stream perform: fileType.	^stream</body><body package="Passport-Kernel-VW" selector="newExternalWriteStream:mode:check:type:">newExternalWriteStream: operand mode: mode check: enforceExistentialConstraint type: fileType 	"Synopsis		Returns an external writeStream that writes to the external data source with the given name.	Specification (based on ANSI Smalltalk standard)		Depending upon the values of &lt;enforceExistentialConstraint&gt; and &lt;mode&gt;, either a) create a new external data source, or b) locate an existing external data source, which in either case is identified by the value of &lt;operand&gt;. The &lt;operand&gt; parameter is an instance of whatever class the host Smalltalk implementation would canonically use to identify an external data source (e.g., a Strring, a Filename, a URL, etc.)  If &lt;operand&gt; is a String (or if its content requires syntactical interpretation,) then its syntax is implementation-dependent.		Return an object conforming to the ANSI Smalltalk &lt;writeFileStream&gt; protocol. The external data source serves as the stream backing store of the returned object. The returned object is a write-back stream. The value of &lt;fileType&gt; determines the external stream type and sequence value type of the result object.		Valid values for &lt;mode&gt; are: #’create’, #’append’, and #’truncate’. The meaning of these values are:				#’create’ create a new external data source, with initial position at the beginning				#’append’ use an existing external data source, with initial position at its end				#’truncate’ use an existing external data source, initially truncating it.		The value of &lt;mode&gt; determines the initial state of the past sequence values and future sequence values of the result object. If &lt;mode&gt; is #’create’ or #’truncate’ the past sequence values and future sequence values are both initially empty. If &lt;mode&gt; is #’append’ the past sequence values initially consist of the elements of the external data source and future sequence values is initially empty. The ordering of the sequence values is the same as the ordering within the external data source. The &lt;enforceExistentialConstraint&gt; flag determines whether the data source specified by &lt;operand&gt; must exist or not exist.		If &lt;mode&gt; = #’create’ and &lt;enforceExistentialConstraint&gt; = false and the data source exists, then the existing file is used.		If &lt;mode&gt; = #’append’ and &lt;enforceExistentialConstraint&gt; = false and the data source does not exist, then it is created.		If &lt;mode&gt; = #’truncate’ and &lt;enforceExistentialConstraint&gt; = false and the data source  does not exist, then it is created.		This operation is undefined if a value other than #’create’, #’append’ or #’truncate’ is used as the &lt;mode&gt; argument.	Parameters		operand 						&lt;readableString&gt; 	identifies the external data source (typically, but not necessarily, a disk file)		mode 						&lt;symbol&gt; 			an enumeration constant that specifies the initial state of the external stream, as defined by the ANSI Smalltalk standard		enforceExistentialConstraint 	&lt;boolean&gt; 			specifies whether or not the existence or non-existence of the data source identified by &lt;operand&gt; is an error		fileType						&lt;symbol&gt; 			an enumeration constant that specifies the type of the external data source, as defined by the ANSI Smalltalk standard	Return Value		&lt;writeFileStream&gt; new	Errors		If &lt;mode&gt; = #create and &lt;enforceExistentialConstraint&gt; = true and the file exists.		If &lt;mode&gt; = #append and &lt;enforceExistentialConstraint&gt; = true and the file does not exist.		If &lt;mode&gt; = #truncate and &lt;enforceExistentialConstraint&gt; = true and the file does not exist.		If the user does not have write permissions for the external data source.		If the user does not have creation permissions for an external data source that is to be created."	| exists stream |	exists := operand exists.	enforceExistentialConstraint 		ifTrue: 			[exists 				ifTrue: 					[mode == #create 						ifTrue: 							[Error 								raiseSignal: 'The file named ' , operand printString , ' already exists.']]				ifFalse: 					[mode == #create 						ifFalse: 							[NotFoundError 								raiseSignal: 'The file named ' , operand printString , ' does not exist.']]].	stream := operand 				perform: 					((exists 						ifTrue: [#(#readWriteStream #appendStream #writeStream)]						ifFalse: [#(#newReadWriteStream #newReadAppendStream #writeStream)]) 							at: (#(#create #append #truncate) indexOf: mode)).	stream perform: fileType.	^stream</body></methods><methods><class-id>Passport.VWFilenameFacade</class-id> <category>accessing</category><body package="Passport-Kernel-VW" selector="currentDirectoryMetavalueString">currentDirectoryMetavalueString	"Answer a String that is a metavalue signifying the current derfault directory/folder." 	^Filename currentDirectory asString</body><body package="Passport-Kernel-VW" selector="defaultDirectoryPathnameString">defaultDirectoryPathnameString	"Answer a String that names/identifies the pathname of the external-file namespace relative to which non-absolute filenames will be interpreted.  In more conventional terminology, answer a String naming/identifying the actual full absolute pathname of the current default directory/folder.  It is acceptable, but not ideal, to answer a metavalue that serves as an indirect reference to the default directory (e.g., '.' on UNIX/Windows systems, and ':' on the Macintosh.) If not answering a metavalue, the answered String must start with the root directory of the current default volume/device (e.g., '/' on a Unix system, 'C:\' or 'D:\' (or whatever volume is the default) on a Windows system.)" 	^Filename defaultDirectoryName</body><body package="Passport-Kernel-VW" selector="pathnameSeparator">pathnameSeparator	^Filename separator</body></methods><methods><class-id>Passport.VWFilenameFacade</class-id> <category>conversion services</category><body package="Passport-Kernel-VW" selector="constructNativeResourceIDFromString:">constructNativeResourceIDFromString: aString 	"Answer whatever value the current Smalltalk execution environment canonically would use to name/identify the external/persistent/remote resource (e.g, a file) referenced by &lt;aString&gt; (.e.g, a String in Squeak, a Filename in VisualWorks, etc.)"	^aString isEmpty 		ifTrue: [Filename currentDirectory]		ifFalse: [aString asFilename]</body><body package="Passport-Kernel-VW" selector="constructResourcePathFromNativeResourceID:">constructResourcePathFromNativeResourceID: aNativeResourceID 	"Construct and answer a ResourcePath that identifies the same resource (e.g, a file) as does &lt;aNativeResourceID&gt; (where &lt;aNativeResourceID&gt; is an object canonically used by the host Smalltalk implementation to name/identify external/persistent/remote resources;) in most Smalltalk implementations such an object would be a String.)"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: Filename defaultDirectory}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (UnixFilename named: '/foo/bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (UnixFilename named: 'foo\bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (UnixFilename named: 'bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (UnixFilename named: './bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (NTFSFilename named: 'c:\foo\bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (NTFSFilename named: 'c:foo\bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (NTFSFilename named: '\foo\bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (NTFSFilename named: 'foo\bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (NTFSFilename named: 'bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (NTFSFilename named: '.\bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (MacFilename named: 'hd:foo:bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (MacFilename named: ':foo:bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (MacFilename named: 'bar.txt')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: (MacFilename named: ':')}"	"{VWFilenameFacade new constructResourcePathFromNativeResourceID: '.' asFilename}" 	"{ResourcePath fromString: '.'}"	"{ResourcePath fromString: ''}"	^self hostNameAndComponentsFromFilename: aNativeResourceID		into: 			[:hostname :allComponents | 			| ns components |			ns := nil.			components := allComponents.			components size &gt; 0 				ifTrue: 					[| root |					root := components first.					root = '.' 						ifTrue: "A relative path"							[(components size = 2 and: [components last = '.']) 								ifTrue: [components := Array new]								ifFalse: [components := components copyFrom: 2 to: components size]]						ifFalse: "An absolute path"							[| endsWithColon |							endsWithColon := root last = $:.							(endsWithColon or: [Filename separator = $:]) 								ifTrue: 									[ns := endsWithColon ifTrue: [root] ifFalse: [root , ':'].									components := components copyFrom: 2 to: components size]								ifFalse: [ns := self rootDirectoryMetavalueString]]].			(self newResourcePath)				setHostname: hostname;				setNamespace: ns;				setComponents: components]</body><body package="Passport-Kernel-VW" selector="hostNameAndComponentsFromFilename:into:">hostNameAndComponentsFromFilename: aFilename into: block2 	| fn |	fn := aFilename asFilename.	^(fn respondsTo: #uriComponents) 		ifTrue: 			[| p |			p := aFilename asFilename uriComponents.			(p respondsTo: #key) 				ifTrue: [block2 value: p key value: p value]				ifFalse: [block2 value: #localhost value: p]]		ifFalse: [block2 value: #localhost value: (Filename components: fn asResolvedString)]</body></methods><methods><class-id>Passport.VWClassicFilenameFacade</class-id> <category>conversion services</category><body package="Passport-Kernel-VW" selector="hostNameAndComponentsFromFilename:into:">hostNameAndComponentsFromFilename: aFilename into: block2 	^block2 value: #localhost value: (Filename components: aFilename asFilename asString)</body></methods><methods><class-id>Chronos.TimezoneProcessor</class-id> <category>processing-AnnuallyRecurringTZPolicyFactories</category><body package="Chronos-TimeZones" selector="processAnnuallyRecurringTZPolicy:">processAnnuallyRecurringTZPolicy: annuallyRecurringTZPolicy	"By default, do nothing"</body><body package="Chronos-TimeZones" selector="processIntraYearTimeZoneTransition:">processIntraYearTimeZoneTransition: annuallyRecurringTZPolicy	^self processAnnuallyRecurringTZPolicy: annuallyRecurringTZPolicy</body><body package="Chronos-TimeZones" selector="processUntilAnnualDateTimeZoneTransition:">processUntilAnnualDateTimeZoneTransition: annuallyRecurringTZPolicy	^self processIntraYearTimeZoneTransition: annuallyRecurringTZPolicy</body><body package="Chronos-TimeZones" selector="processUntilAnnualDayOfYearTimeZoneTransition:">processUntilAnnualDayOfYearTimeZoneTransition: annuallyRecurringTZPolicy	^self processIntraYearTimeZoneTransition: annuallyRecurringTZPolicy</body><body package="Chronos-TimeZones" selector="processUntilEndOfYearTimeZoneTransition:">processUntilEndOfYearTimeZoneTransition: annuallyRecurringTZPolicy	^self processAnnuallyRecurringTZPolicy: annuallyRecurringTZPolicy</body></methods><methods><class-id>Chronos.TimezoneProcessor</class-id> <category>processing-Timezones</category><body package="Chronos-TimeZones" selector="processAlwaysDefaultTZ:">processAlwaysDefaultTZ: timezone	^self processProxyTimezone: timezone</body><body package="Chronos-TimeZones" selector="processAlwaysSystemTZ:">processAlwaysSystemTZ: timezone	^self processProxyTimezone: timezone</body><body package="Chronos-TimeZones" selector="processBasicTimezone:">processBasicTimezone: timezone	^self processUnboundTimezone: timezone</body><body package="Chronos-TimeZones" selector="processBoundTimezone:">processBoundTimezone: timezone	"By default, do nothing"</body><body package="Chronos-TimeZones" selector="processNominalTime:">processNominalTime: timezone	^self processProxyTimezone: timezone</body><body package="Chronos-TimeZones" selector="processNonStandardTime:">processNonStandardTime: timezone	^self processStandardTime: timezone</body><body package="Chronos-TimeZones" selector="processProxyTimezone:">processProxyTimezone: timezone	depth := depth + 1.	timezone asNonProxy processBy: self.	depth := depth - 1.</body><body package="Chronos-TimeZones" selector="processStandardTime:">processStandardTime: timezone	^self processBasicTimezone: timezone</body><body package="Chronos-TimeZones" selector="processUnboundTimezone:">processUnboundTimezone: timezone	defaultZoneName := timezone name</body><body package="Chronos-TimeZones" selector="processVariableOffsetTimezone:">processVariableOffsetTimezone: timezone	self processUnboundTimezone: timezone.	depth := depth + 1.	timezone policy processBy: self.	depth := depth - 1.</body></methods><methods><class-id>Chronos.TimezoneProcessor</class-id> <category>processing-AnnualDates</category><body package="Chronos-TimeZones" selector="processAnnualDate:">processAnnualDate: annualDate	"By default, do nothing"</body><body package="Chronos-TimeZones" selector="processCalendricalAnnualDate:">processCalendricalAnnualDate: annualDate	self processAnnualDate: annualDate</body><body package="Chronos-TimeZones" selector="processComputedAnnualDate:">processComputedAnnualDate: annualDate	self processAnnualDate: annualDate</body><body package="Chronos-TimeZones" selector="processDayOfMonth:">processDayOfMonth: annualDate	self processMonthOfYear: annualDate</body><body package="Chronos-TimeZones" selector="processDayOfYear:">processDayOfYear: annualDate	self processCalendricalAnnualDate: annualDate</body><body package="Chronos-TimeZones" selector="processGregorianEaster:">processGregorianEaster: annualDate	self processComputedAnnualDate: annualDate</body><body package="Chronos-TimeZones" selector="processJulianEaster:">processJulianEaster: annualDate	self processComputedAnnualDate: annualDate</body><body package="Chronos-TimeZones" selector="processMonthOfYear:">processMonthOfYear: annualDate	self processCalendricalAnnualDate: annualDate</body><body package="Chronos-TimeZones" selector="processWeekOfMonthDayOfWeek:">processWeekOfMonthDayOfWeek: annualDate	self processMonthOfYear: annualDate</body></methods><methods><class-id>Chronos.TimezoneProcessor</class-id> <category>API</category><body package="Chronos-TimeZones" selector="process:">process: aChronosTimezone	"TimezoneProcessor new process: ChronosTimezone default"	^(ChronosTimezone referencedBy: aChronosTimezone) processBy: self</body></methods><methods><class-id>Chronos.TimezoneProcessor</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="initialize">initialize	depth := 0</body></methods><methods><class-id>Chronos.TimezoneProcessor</class-id> <category>processing-TimeZonePolicyFactories</category><body package="Chronos-TimeZones" selector="processTimezoneAnnualTransitionPolicyFactory:">processTimezoneAnnualTransitionPolicyFactory: timeZonePolicy	depth := depth + 1.	timeZonePolicy annuallyRecurringTransitionsDo: [:index :each | each processBy: self].	depth := depth - 1.</body><body package="Chronos-TimeZones" selector="processTimezonePolicyFactory:">processTimezonePolicyFactory: timeZonePolicy	depth := depth + 1.	timeZonePolicy annualTransitionPoliciesDo: [:index :each | each processBy: self].	depth := depth - 1.</body></methods><methods><class-id>Chronos.TimezoneProcessor class</class-id> <category>instance creation</category><body package="Chronos-TimeZones" selector="new">new	^self basicNew initialize</body></methods><methods><class-id>Passport.Registratable</class-id> <category>printing</category><body package="Passport-Kernel" selector="printOn:">printOn: stream	stream nextPutAll: self globalNameOfClass.	registrationKey == nil 		ifFalse: 			[stream				nextPut: $(;				print: registrationKey;				nextPut: $)]</body></methods><methods><class-id>Passport.Registratable</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="apply:">apply: initializationSpec	"ChronosPrintPolicy new 		apply: #(hideTimeOfDay useTwoDigitYears dateSeparator: $- useMonthName useMonthDayYearOrder);		yourself"	| argStack argCount selector | 	self isImmutable ifTrue: [^self copy apply: initializationSpec].	argStack := nil.	argCount := 0.	selector := nil.	initializationSpec do: [:selectorOrArg | 		argCount &gt; 0			ifTrue: 				[argStack nextPut: (UtilityFunction ansiValueOfLiteralArrayElement: selectorOrArg).				argCount := argCount - 1.				argCount &gt; 0					ifFalse: 						[self perform: selector withArguments: argStack contents.						argStack := nil]]			ifFalse: 				[(argCount := selectorOrArg numArgs) &gt; 0					ifTrue: 						[selector := selectorOrArg.						argStack := (Array new: argCount) writeStream]					ifFalse: [self perform: selectorOrArg]]].		(argCount &gt; 0 or: [argStack notNil]) ifTrue: [self signalError: 'Selector numArgs inconsistent with number of supplied arguments'].</body><body package="Passport-Kernel" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self setRegistrationKey: (literalArray at: 2)</body><body package="Passport-Kernel" selector="release">release	super release.	self deregister</body><body package="Passport-Kernel" selector="setKey:">setKey: aKey	self assertMutability.	self setRegistrationKey: aKey.</body></methods><methods><class-id>Passport.Registratable</class-id> <category>accessing</category><body package="Passport-Kernel" selector="key">key	^registrationKey</body><body package="Passport-Kernel" selector="registrationKey">registrationKey	^registrationKey</body></methods><methods><class-id>Passport.Registratable</class-id> <category>registration</category><body package="Passport-Kernel" selector="deregister">deregister	^(self class registryIfNone: [^self]) removeKey: self registrationKey ifAbsent: []</body><body package="Passport-Kernel" selector="forceRegistration">forceRegistration	self hasKey ifFalse: [self signalError: 'Key required for registration'].	self class registry at: self registrationKey put: self beImmutable</body><body package="Passport-Kernel" selector="register">register	self registerButIfPresent: [:collision | self signalError: 'Unable to register--another value is registered with the same key (', self registrationKey printString, ')']</body><body package="Passport-Kernel" selector="registerAs:ifPresent:">registerAs: aKey ifPresent: keyCollision 	| collision |	aKey == nil ifTrue: [^self signalError: 'Registration requires a non-nil registration key'].	self hasKey 		ifTrue: 			[self key = aKey 				ifFalse: 					[self isImmutable 						ifTrue: [^self asMutable registerAs: aKey ifPresent: keyCollision]						ifFalse: [self setKey: aKey]]]		ifFalse: [self assertMutability].	collision := self class registry at: aKey ifAbsentPut: [self beImmutable].	^(collision == self or: [collision == nil])		ifTrue: 			[self setRegistrationKey: aKey.			self]		ifFalse: [keyCollision value: collision]</body><body package="Passport-Kernel" selector="registerButIfPresent:">registerButIfPresent: keyCollision	^self registerAs: self registrationKey ifPresent: keyCollision</body></methods><methods><class-id>Passport.Registratable</class-id> <category>testing</category><body package="Passport-Kernel" selector="hasKey">hasKey	^registrationKey notNil</body><body package="Passport-Kernel" selector="isRegistered">isRegistered	^self hasKey		ifTrue: [(self class registryIfNone: [^false]) includesKey: self registrationKey]		ifFalse: [false]</body></methods><methods><class-id>Passport.Registratable</class-id> <category>private</category><body package="Passport-Kernel" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self registrationKey</body><body package="Passport-Kernel" selector="setRegistrationKey:">setRegistrationKey: aKey	registrationKey := aKey == nil ifFalse: [aKey asSymbol]</body></methods><methods><class-id>Passport.Registratable class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="allRegisteredKeys">allRegisteredKeys	^self registry keys</body><body package="Passport-Kernel" selector="at:">at: aKey	^self at: aKey ifAbsent: [self handleUnregistered: aKey]</body><body package="Passport-Kernel" selector="at:do:">at: aKey do: block1	| referent value |	referent := self at: aKey. 	value := block1 value: referent.	referent yourself.	^value</body><body package="Passport-Kernel" selector="at:ifAbsent:">at: aKey ifAbsent: ifAbsent 	^aKey == nil 		ifTrue: [ifAbsent value]		ifFalse: 			[| value |			aKey == #default ifTrue: [^self default].			value := self registry at: aKey ifAbsent: [0].			(value == nil or: [value = 0])				ifTrue: [ifAbsent value]				ifFalse: [value]]</body><body package="Passport-Kernel" selector="default">default	"Answer the default instance of the receiver"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="handleUnregistered:">handleUnregistered: aKey	^self signalError: 'No value registered at ', aKey printString</body><body package="Passport-Kernel" selector="referencedBy:">referencedBy: aChronosRegistratableOrChronosRegistratableKey 	"Anser the value referenced by &lt;aChronosRegistratableOrChronosRegistratableKey&gt;. If the value is a key, answer the value bound to the key. Otherwise, answer aChronosRegistratableOrChronosRegistratableKey itself."	^aChronosRegistratableOrChronosRegistratableKey == nil 		ifTrue: [self default]		ifFalse: 			[aChronosRegistratableOrChronosRegistratableKey isString 				ifTrue: [self at: aChronosRegistratableOrChronosRegistratableKey]				ifFalse: [aChronosRegistratableOrChronosRegistratableKey]]</body></methods><methods><class-id>Passport.Registratable class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="basicInitialize">basicInitialize	registry := nil.</body><body package="Passport-Kernel" selector="basicInitializeAll">basicInitializeAll	self basicInitialize.	self subclasses do: [:each | each basicInitializeAll]</body><body package="Passport-Kernel" selector="initialize">initialize	self basicInitializeAll.</body><body package="Passport-Kernel" selector="initializeAll">initializeAll	"ChronosRegistratable initializeAll"	self initialize.	self subclasses do: [:each | each initializeAll]</body></methods><methods><class-id>Passport.Registratable class</class-id> <category>instance creation</category><body package="Passport-Kernel" selector="applying:">applying: initializationSpec	^self newConfigurable		apply: initializationSpec</body><body package="Passport-Kernel" selector="newConfigurable">newConfigurable	^self new</body></methods><methods><class-id>Passport.Registratable class</class-id> <category>private</category><body package="Passport-Kernel" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body><body package="Passport-Kernel" selector="basicRegistry">basicRegistry	"Answer the registry of instances, which must be a Dictionary-like object where each key is the canonical registration key of an instance, and where each value is a registered instance. Answer nil if the registry has not been created."	^registry</body><body package="Passport-Kernel" selector="newRegistry">newRegistry	^EnvironmentFacade current newWeakDictionary</body><body package="Passport-Kernel" selector="registry">registry	"Answer the registry of instances, which must be a Dictionary-like object where each key is the canonical registration key of an instance, and where each value is a registered instance. Create the instance registry if that has not yet been done."	^self registryIfNone: 			[self				setRegistry;				basicRegistry]</body><body package="Passport-Kernel" selector="registryIfNone:">registryIfNone: ifNone 	"Answer the registry of instances, which must be a Dictionary-like object where each key is the canonical registration key of an instance, and where each value is a registered instance. If the instance registry has not been created, answer the result of evaluating the zero-argument block &lt;ifNone&gt;."	^registry == nil ifTrue: [ifNone value] ifFalse: [registry]</body><body package="Passport-Kernel" selector="setRegistry">setRegistry	"Set the value of the class variable (or class instance variable) that will contain the registry of instances, which must be a Dictionary-like object."	registry := self newRegistry</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>testing</category><body package="Chronos-Printing" selector="canConformToLocale">canConformToLocale	^false</body><body package="Chronos-Printing" selector="hidesDayOfWeek">hidesDayOfWeek	^true</body><body package="Chronos-Printing" selector="hidesTimeZone">hidesTimeZone	^false</body><body package="Chronos-Printing" selector="showsDayOfWeek">showsDayOfWeek	^self hidesDayOfWeek not</body><body package="Chronos-Printing" selector="showsNameOfEra">showsNameOfEra	^false</body><body package="Chronos-Printing" selector="showsNamesOfCalendarDurationElements">showsNamesOfCalendarDurationElements	^false</body><body package="Chronos-Printing" selector="showsNamesOfDurationElements">showsNamesOfDurationElements	^false</body><body package="Chronos-Printing" selector="showsTimeOfDay">showsTimeOfDay	| maxPrecision |	maxPrecision := self dateAndTimeMaxPrecision.	^maxPrecision isInteger 		ifTrue: [true]		ifFalse: [(#(#all #minute #hour #day #month #year) indexOf: maxPrecision)  &lt; 4]</body><body package="Chronos-Printing" selector="showsTimeZone">showsTimeZone	^self hidesTimeZone not</body><body package="Chronos-Printing" selector="suppressesZeroValuedCalendarDurationElements">suppressesZeroValuedCalendarDurationElements	^true</body><body package="Chronos-Printing" selector="suppressesZeroValuedDurationElements">suppressesZeroValuedDurationElements	^false</body><body package="Chronos-Printing" selector="uses12HourClock">uses12HourClock	^self uses24HourClock not</body><body package="Chronos-Printing" selector="uses24HourClock">uses24HourClock	^true</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>accessing--punctuation characters</category><body package="Chronos-Printing" selector="calendarDurationDayHourSeparator">calendarDurationDayHourSeparator	^$T</body><body package="Chronos-Printing" selector="calendarDurationElementSeparator">calendarDurationElementSeparator	^nil</body><body package="Chronos-Printing" selector="calendarDurationPadChar">calendarDurationPadChar	^nil</body><body package="Chronos-Printing" selector="dateAndTimeSeparator">dateAndTimeSeparator	^nil</body><body package="Chronos-Printing" selector="dayOfMonthPadChar">dayOfMonthPadChar	^$0</body><body package="Chronos-Printing" selector="dayYearSeparator">dayYearSeparator	^$-</body><body package="Chronos-Printing" selector="decimalPointChar">decimalPointChar	^$. "Per ANSI Smalltalk Standard"</body><body package="Chronos-Printing" selector="durationDayHourSeparator">durationDayHourSeparator	^$:</body><body package="Chronos-Printing" selector="durationElementSeparator">durationElementSeparator	^$:</body><body package="Chronos-Printing" selector="durationPadChar">durationPadChar	^$0</body><body package="Chronos-Printing" selector="hourMinuteSecondSeparator">hourMinuteSecondSeparator	^$:</body><body package="Chronos-Printing" selector="hourPadChar">hourPadChar	^$0</body><body package="Chronos-Printing" selector="monthDaySeparator">monthDaySeparator	^$-</body><body package="Chronos-Printing" selector="monthPadChar">monthPadChar	^$0</body><body package="Chronos-Printing" selector="timeOfDayPrefix">timeOfDayPrefix	^$T</body><body package="Chronos-Printing" selector="timeZoneElementSeparator">timeZoneElementSeparator	^$:</body><body package="Chronos-Printing" selector="timeZoneSeparator">timeZoneSeparator	^nil</body><body package="Chronos-Printing" selector="yearMonthSeparator">yearMonthSeparator	^$-</body><body package="Chronos-Printing" selector="yearPadChar">yearPadChar	^$0</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-utility</category><body package="Chronos-Printing" selector="printSeparator:on:">printSeparator: separator on: stream	separator isSequenceable		ifTrue: [stream nextPutAll: separator]		ifFalse: [separator == nil ifFalse: [stream nextPut: separator]].</body><body package="Chronos-Printing" selector="printTemporalUnitName:value:on:">printTemporalUnitName: nameKey value: value on: stream	stream nextPutAll: 		((value = 1)			ifTrue: [self singularNounAtSemanticKey: nameKey]			ifFalse: [self pluralNounAtSemanticKey: nameKey]).</body><body package="Chronos-Printing" selector="printValue:elementNameKey:isPrefixed:separator:padWith:to:suppressIfZero:on:">printValue: element elementNameKey: elementNameKey isPrefixed: isPrefixed separator: separator padWith: padChar to: minDigits suppressIfZero: suppressIfZero on: stream 	"Answer true if the element was printed, false if it was suppressed."	^(suppressIfZero and: [element = 0]) 		ifTrue: [false]		ifFalse: 			[| int |			isPrefixed ifTrue: [self printSeparator: separator on: stream].			int := element truncated.			ChronosFunction  				print: int				paddedWith: padChar				to: minDigits				on: stream.			element isInteger				ifFalse: 					[ChronosFunction						print: ((element - int) * NanosecondsPerSecond) truncated						asPostDecimalOn: stream 						decimalPoint: self decimalPointChar						scale: 9 						minPrecision: 0						maxPrecision: 9						prependingZero: false].			elementNameKey == nil 				ifFalse: 					[stream space.					self 						printTemporalUnitName: elementNameKey						value: element						on: stream].			true]</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-durations</category><body package="Chronos-Printing" selector="printCivilDuration:on:">printCivilDuration: aCalendarDuration on: stream 	self 		printCivilDuration: aCalendarDuration		separator: self calendarDurationElementSeparator		dayHourSeparator: self calendarDurationDayHourSeparator		padWith: self calendarDurationPadChar		appendElementNames: self showsNamesOfCalendarDurationElements		suppressZeroValuedElements: self suppressesZeroValuedCalendarDurationElements		on: stream</body><body package="Chronos-Printing" selector="printCivilDuration:separator:dayHourSeparator:padWith:appendElementNames:suppressZeroValuedElements:on:">printCivilDuration: aCalendarDuration separator: separator dayHourSeparator: dayHourSeparator padWith: padChar appendElementNames: showNamesOfDurationElements suppressZeroValuedElements: suppressZeroValuedDurationElements on: stream 	| years months days seconds nanosecondsSinceSecond secondsAndNanosecondsAreZero monthsAndDaysAreZero hasPrefix |	hasPrefix := false.	showNamesOfDurationElements ifFalse: [stream nextPut: $P].	years := aCalendarDuration years.	months := aCalendarDuration months.	days := aCalendarDuration days.	seconds := aCalendarDuration secondsSinceStartOfDay.	nanosecondsSinceSecond := aCalendarDuration nanosecondsSinceSecond.	secondsAndNanosecondsAreZero := seconds = 0 and: [nanosecondsSinceSecond = 0].	monthsAndDaysAreZero := days = 0 and: [months = 0].	(suppressZeroValuedDurationElements and: 			[secondsAndNanosecondsAreZero and: [monthsAndDaysAreZero and: [years = 0]]]) 		ifTrue: [self printZeroDurationPadWith: padChar appendElementNames: showNamesOfDurationElements on: stream]		ifFalse: 			[(self 				printValue: years elementNameKey: (showNamesOfDurationElements ifTrue: [#year])				isPrefixed: false separator: nil				padWith: padChar to: 4				suppressIfZero: suppressZeroValuedDurationElements				on: stream) 					ifTrue: 						[hasPrefix := true.						showNamesOfDurationElements 							ifFalse: [suppressZeroValuedDurationElements ifTrue: [stream nextPut: $Y]]].			(suppressZeroValuedDurationElements 				and: [secondsAndNanosecondsAreZero and: [monthsAndDaysAreZero]]) 					ifFalse: 						[(self 							printValue: months elementNameKey: (showNamesOfDurationElements ifTrue: [#month])							isPrefixed: hasPrefix separator: separator							padWith: padChar to: 2							suppressIfZero: suppressZeroValuedDurationElements							on: stream) 								ifTrue: 									[hasPrefix := true.									showNamesOfDurationElements 										ifFalse: [suppressZeroValuedDurationElements ifTrue: [stream nextPut: $M]]].						(suppressZeroValuedDurationElements 							and: [secondsAndNanosecondsAreZero and: [days = 0]]) 								ifFalse: 									[self 										printDurationElementsFromSeconds: days * SecondsPerDay + seconds										nanoseconds: nanosecondsSinceSecond										isPrefixed: hasPrefix										dayHourSeparator: dayHourSeparator										hmsSeparator: separator										padWith: padChar										appendElementNames: showNamesOfDurationElements										suppressZeroValuedElements: suppressZeroValuedDurationElements										on: stream]]].</body><body package="Chronos-Printing" selector="printDuration:on:">printDuration: aDuration on: stream	aDuration positive ifFalse: [stream nextPut: $-].	self 		printDurationElementsFromSeconds: aDuration asSeconds abs		nanoseconds: aDuration nanosecondsSinceSecond abs		isPrefixed: false		dayHourSeparator: self durationDayHourSeparator		hmsSeparator: self durationElementSeparator		padWith: self durationPadChar		appendElementNames: self showsNamesOfDurationElements		suppressZeroValuedElements: self suppressesZeroValuedDurationElements		on: stream</body><body package="Chronos-Printing" selector="printDurationElementsFromSeconds:nanoseconds:isPrefixed:dayHourSeparator:hmsSeparator:padWith:appendElementNames:suppressZeroValuedElements:on:">printDurationElementsFromSeconds: seconds nanoseconds: nanoseconds isPrefixed: isPrefixed dayHourSeparator: daysAndHoursSep hmsSeparator: hourMinuteSecondSeparator padWith: durationPadChar appendElementNames: showNamesOfDurationElements suppressZeroValuedElements: suppressZeroValuedDurationElements on: stream 	| secondsSinceMinute days subDays hours subHours minutes hasPrefix secondsPrinted |	(seconds = 0 and: [nanoseconds = 0]) 		ifTrue: [self printZeroDurationPadWith: durationPadChar appendElementNames: showNamesOfDurationElements on: stream]		ifFalse: 			[days := seconds quo: SecondsPerDay.			subDays := seconds rem: SecondsPerDay.			hours := subDays quo: SecondsPerHour.			subHours := subDays rem: SecondsPerHour.			minutes := subHours quo: SecondsPerMinute.			secondsSinceMinute := subHours rem: SecondsPerMinute.			hasPrefix := isPrefixed.			secondsPrinted := false.			(self 				printValue: days elementNameKey: (showNamesOfDurationElements ifTrue: [#day])				isPrefixed: isPrefixed separator: hourMinuteSecondSeparator				padWith: durationPadChar to: (suppressZeroValuedDurationElements ifTrue: [1] ifFalse: [2])				suppressIfZero: suppressZeroValuedDurationElements				on: stream) 					ifTrue: 						[hasPrefix := true.						showNamesOfDurationElements 							ifFalse: [suppressZeroValuedDurationElements ifTrue: [stream nextPut: $D]]].			(suppressZeroValuedDurationElements 				and: [subDays = 0 and: [nanoseconds = 0]]) 					ifFalse: 						[(self 							printValue: hours elementNameKey: (showNamesOfDurationElements ifTrue: [#hour])							isPrefixed: hasPrefix separator: daysAndHoursSep							padWith: durationPadChar to: 2							suppressIfZero: suppressZeroValuedDurationElements							on: stream) 								ifTrue: 									[hasPrefix := true.									showNamesOfDurationElements 										ifFalse: [suppressZeroValuedDurationElements ifTrue: [stream nextPut: $H]]]								ifFalse: 									[suppressZeroValuedDurationElements 										ifTrue: [minutes = 0 													ifFalse: 														["The ISO8601 standard label 'M' is ambiguous (month or minute,) so we have to use the &lt;daysAndHoursSep&gt; in this case to disambiguate."														self printSeparator: daysAndHoursSep on: stream]]].						(suppressZeroValuedDurationElements 							and: [subHours = 0 and: [nanoseconds = 0]]) 								ifFalse: 									[(self 										printValue: minutes elementNameKey: (showNamesOfDurationElements ifTrue: [#minute])										isPrefixed: hasPrefix separator: hourMinuteSecondSeparator										padWith: durationPadChar to: 2										suppressIfZero: suppressZeroValuedDurationElements										on: stream) 											ifTrue: 												[hasPrefix := true.												showNamesOfDurationElements 													ifFalse: [suppressZeroValuedDurationElements ifTrue: [stream nextPut: $M]]].									(suppressZeroValuedDurationElements 										and: [secondsSinceMinute = 0 and: [nanoseconds = 0]]) 											ifFalse: 												[secondsPrinted := false.												(self 													printValue: secondsSinceMinute elementNameKey: nil													isPrefixed: hasPrefix separator: hourMinuteSecondSeparator													padWith: durationPadChar to: 2													suppressIfZero: suppressZeroValuedDurationElements													on: stream) ifTrue: [secondsPrinted := true].												(hasPrefix and: [secondsPrinted not]) ifTrue: [self printSeparator: hourMinuteSecondSeparator on: stream].												self 													printNanosecondsSinceSecond: nanoseconds													asSubsecondFractionOn: stream													minPrecision: 0													maxPrecision: self subSecondDurationMaxPrecision													prependingZero: secondsPrinted not.												showNamesOfDurationElements 													ifTrue: 														[stream space.														self 															printTemporalUnitName: #second															value: ((seconds abs = 1 and: [nanoseconds = 0]) ifTrue: [1] ifFalse: [2])															on: stream]													ifFalse: 														[suppressZeroValuedDurationElements 															ifTrue: [stream nextPut: $S]]]]]]</body><body package="Chronos-Printing" selector="printInfiniteDuration:on:">printInfiniteDuration: anInfiniteDuration on: stream	stream		nextPut: (anInfiniteDuration positive ifTrue: [$+] ifFalse: [$-]);		nextPutAll: 'infiniteDuration'</body><body package="Chronos-Printing" selector="printZeroDurationPadWith:appendElementNames:on:">printZeroDurationPadWith: padChar appendElementNames: showNamesOfDurationElements on: stream 	ChronosFunction  print: 0 paddedWith: padChar to: 2 on: stream.	stream nextPut: $:.	ChronosFunction  print: 0 paddedWith: padChar to: 2 on: stream.	stream nextPut: $:.	ChronosFunction  print: 0 paddedWith: padChar to: 2 on: stream.	stream nextPut: $:.	ChronosFunction  print: 0 paddedWith: padChar to: 2 on: stream.</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>accessing</category><body package="Chronos-Printing" selector="dateAndTimeMaxPrecision">dateAndTimeMaxPrecision	^#all</body><body package="Chronos-Printing" selector="dateAndTimeOrder">dateAndTimeOrder 	^#useDateBeforeTimeOrder</body><body package="Chronos-Printing" selector="effectiveLocale">effectiveLocale	^ChronosLocale english</body><body package="Chronos-Printing" selector="eraPolicy">eraPolicy	^nil "Don't show the era name"</body><body package="Chronos-Printing" selector="standardCalendarRegistrationKey">standardCalendarRegistrationKey	"Answer the registration key of the receiver's standard calendar (which is the calendar whose name may optionally be hidden when printing a calendrical value.)"	^AnsiStandardCalendar registrationKey</body><body package="Chronos-Printing" selector="subSecondDurationMaxPrecision">subSecondDurationMaxPrecision	^#all</body><body package="Chronos-Printing" selector="subSecondTimeMinPrecision">subSecondTimeMinPrecision	^0</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>name lookup</category><body package="Chronos-Printing" selector="abbreviationAtSemanticKey:">abbreviationAtSemanticKey: semanticKey	^self effectiveLocale abbreviationAtSemanticKey: semanticKey</body><body package="Chronos-Printing" selector="monthAbbreviationFrom:">monthAbbreviationFrom: aDate	^aDate		forLocale: self effectiveLocale		monthAbbreviationIfResolvable: [:name | name]		ifNot: [(self singularNounAtSemanticKey: #month), aDate monthOrdinal printString]</body><body package="Chronos-Printing" selector="monthNameFrom:">monthNameFrom: aDate	^aDate		forLocale: self effectiveLocale		monthNameIfResolvable: [:name | name]		ifNot: [(self singularNounAtSemanticKey: #month), aDate monthOrdinal printString]</body><body package="Chronos-Printing" selector="nameAbbreviationOfDayOfWeekAt:">nameAbbreviationOfDayOfWeekAt: dayOfWeekKey	^self effectiveLocale abbreviationAtSemanticKey: dayOfWeekKey</body><body package="Chronos-Printing" selector="pluralNounAtSemanticKey:">pluralNounAtSemanticKey: semanticKey	^self effectiveLocale pluralNounAtSemanticKey: semanticKey</body><body package="Chronos-Printing" selector="properNameAtSemanticKey:">properNameAtSemanticKey: semanticKey	^self effectiveLocale properNameAtSemanticKey: semanticKey</body><body package="Chronos-Printing" selector="singularNounAtSemanticKey:">singularNounAtSemanticKey: semanticKey	^self effectiveLocale singularNounAtSemanticKey: semanticKey</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-time of day-elements</category><body package="Chronos-Printing" selector="printHour12:on:">printHour12: h24 on: stream	self printHour12: h24 padWith: $  on: stream</body><body package="Chronos-Printing" selector="printHour12:padWith:on:">printHour12: h24 padWith: pad on: stream	| hour |	hour := h24 rem: 12.	ChronosFunction  print: (hour = 0 ifTrue: [12] ifFalse: [hour]) paddedWith: pad to: 2 on: stream</body><body package="Chronos-Printing" selector="printHour24:on:">printHour24: h24 on: stream	ChronosFunction  print: h24 paddedWith: self hourPadChar to: 2 on: stream</body><body package="Chronos-Printing" selector="printHour:on:">printHour: h24 on: stream	self uses24HourClock		ifTrue: [self printHour24: h24 on: stream]		ifFalse: [self printHour12: h24 on: stream]</body><body package="Chronos-Printing" selector="printNanosecondsSinceSecond:asSubsecondFractionOn:minPrecision:maxPrecision:prependingZero:">printNanosecondsSinceSecond: nanosecondsSinceSecond asSubsecondFractionOn: stream minPrecision: minPrecision maxPrecision: maxPrecision prependingZero: shouldPrependZero	ChronosFunction		print: nanosecondsSinceSecond 		asPostDecimalOn: stream 		decimalPoint: self decimalPointChar 		scale: 9		minPrecision: minPrecision		maxPrecision: maxPrecision		prependingZero: shouldPrependZero</body><body package="Chronos-Printing" selector="printTimeElement:on:">printTimeElement: aTimeElement on: stream	ChronosFunction  print: aTimeElement paddedWith: $0 to: 2 on: stream</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-time zones</category><body package="Chronos-Printing" selector="printAbbreviationOfTimeZoneFrom:on:">printAbbreviationOfTimeZoneFrom: aTimepoint on: stream 	self 		printAbbreviationOfTimeZoneFrom: aTimepoint		prefix: $ 		on: stream</body><body package="Chronos-Printing" selector="printAbbreviationOfTimeZoneFrom:prefix:on:">printAbbreviationOfTimeZoneFrom: aTimepoint prefix: prefix on: stream 	self printSeparator: prefix on: stream.	stream nextPutAll: aTimepoint timeZoneAbbreviation</body><body package="Chronos-Printing" selector="printKeyOfTimeZoneFrom:on:">printKeyOfTimeZoneFrom: aTimepoint on: stream 	self 		printKeyOfTimeZoneFrom: aTimepoint		prefix: $ 		on: stream</body><body package="Chronos-Printing" selector="printKeyOfTimeZoneFrom:prefix:on:">printKeyOfTimeZoneFrom: aTimepoint prefix: prefix on: stream 	self printSeparator: prefix on: stream.	aTimepoint timeZone printKeyOn: stream</body><body package="Chronos-Printing" selector="printNameOfTimeZoneFrom:on:">printNameOfTimeZoneFrom: aTimepoint on: stream 	self 		printNameOfTimeZoneFrom: aTimepoint		prefix: $ 		on: stream</body><body package="Chronos-Printing" selector="printNameOfTimeZoneFrom:prefix:on:">printNameOfTimeZoneFrom: aTimepoint prefix: prefix on: stream 	self printSeparator: prefix on: stream.	stream nextPutAll: aTimepoint timeZoneName</body><body package="Chronos-Printing" selector="printOffsetOfTimeZoneFrom:on:">printOffsetOfTimeZoneFrom: aTimepoint on: stream 	self printTimeZoneOffset: aTimepoint offset on: stream</body><body package="Chronos-Printing" selector="printTimeZoneFrom:on:">printTimeZoneFrom: aTimepoint on: stream 	self printOffsetOfTimeZoneFrom: aTimepoint on: stream</body><body package="Chronos-Printing" selector="printTimeZoneOffset:on:">printTimeZoneOffset: offsetFromUTC on: stream 	self 		printTimeZoneOffset: offsetFromUTC		prefix: self timeZoneSeparator		elementSeparator: self timeZoneElementSeparator		on: stream</body><body package="Chronos-Printing" selector="printTimeZoneOffset:prefix:elementSeparator:on:">printTimeZoneOffset: offsetFromUTC prefix: prefix elementSeparator: elementSeparator on: stream 	| seconds secondsSinceMinute hours minutes |	offsetFromUTC isZero 		ifTrue: 			[^self 				printTimeZoneZeroOffsetWithPrefix: prefix				elementSeparator: elementSeparator				on: stream].	self printSeparator: prefix on: stream.	offsetFromUTC positive 		ifTrue: [stream nextPut: $+]		ifFalse: [stream nextPut: $-].	seconds := offsetFromUTC asSeconds.	secondsSinceMinute := seconds abs.	hours := secondsSinceMinute // SecondsPerHour.	secondsSinceMinute := secondsSinceMinute \\ SecondsPerHour.	minutes := secondsSinceMinute // SecondsPerMinute.	secondsSinceMinute := secondsSinceMinute \\ SecondsPerMinute.	ChronosFunction  		print: hours		paddedWith: $0		to: 2		on: stream.	self printSeparator: elementSeparator on: stream.	ChronosFunction		print: minutes		paddedWith: $0		to: 2		on: stream.	(secondsSinceMinute = 0 and: [offsetFromUTC subsecondsAreZero]) 		ifFalse: 			[self printSeparator: elementSeparator on: stream.			ChronosFunction 				print: secondsSinceMinute				paddedWith: $0				to: 2				on: stream.			self 				printNanosecondsSinceSecond: offsetFromUTC nanosecondsSinceSecond 				asSubsecondFractionOn: stream				minPrecision: 0				maxPrecision: #all				prependingZero: false]</body><body package="Chronos-Printing" selector="printTimeZoneVerboselyFrom:on:">printTimeZoneVerboselyFrom: aTimepoint on: stream 	| timeZone |	self printOffsetOfTimeZoneFrom: aTimepoint on: stream.	timeZone := aTimepoint timeZone.	(timeZone isDynamic or: [timeZone specifiesAbbreviation or: [timeZone specifiesName]])		ifTrue: 			[| prefix |			stream nextPutAll: ' ('.			timeZone specifiesAbbreviation				ifTrue: 					[self printAbbreviationOfTimeZoneFrom: aTimepoint prefix: nil on: stream.					stream nextPutAll: ':'.					prefix := $ ]				ifFalse: [prefix := nil].			timeZone isDynamic				ifTrue: 					[self printKeyOfTimeZoneFrom: aTimepoint prefix: prefix on: stream.					prefix := ' | '].			timeZone specifiesName				ifTrue: 					[self printNameOfTimeZoneFrom: aTimepoint prefix: prefix on: stream].			stream nextPut: $)].</body><body package="Chronos-Printing" selector="printTimeZoneZeroOffsetWithPrefix:elementSeparator:on:">printTimeZoneZeroOffsetWithPrefix: prefix elementSeparator: elementSeparator on: stream 	self printSeparator: prefix on: stream.	stream nextPut: $+.	ChronosFunction  		print: 0		paddedWith: $0		to: 2		on: stream.	self printSeparator: elementSeparator on: stream.	ChronosFunction  		print: 0		paddedWith: $0		to: 2		on: stream.</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>utility/examples</category><body package="Chronos-Printing" selector="dateToday">dateToday	"ChronosPrintPolicy usShort dateToday"	^DateFactory today printStringUsing: self</body><body package="Chronos-Printing" selector="dateTodayAs:">dateTodayAs: calendar	"ChronosPrintPolicy universal dateTodayAs: #'Julian-Imperial'"	^(DateFactory todayAs: calendar) printStringUsing: self</body><body package="Chronos-Printing" selector="dateTodayIn:">dateTodayIn: aTimezone	"ChronosPrintPolicy usLong dateTodayIn: 'Pacific/Auckland'"	"ChronosPrintPolicy isoWeekOfYearDayOfWeek dateTodayIn: 'Pacific/Honolulu'"	^(DateFactory todayIn: aTimezone) printStringUsing: self</body><body package="Chronos-Printing" selector="dateTodayIn:as:">dateTodayIn: aTimezone as: aCalendar	"ChronosPrintPolicy verbose dateTodayIn: 'Pacific/Auckland' as: #'Julian-Imperial'"	^(DateFactory todayIn: aTimezone as: aCalendar) printStringUsing: self</body><body package="Chronos-Printing" selector="nominalNow">nominalNow	"ChronosPrintPolicy usShort nominalNow"	^DateAndTimeFactory nominalNow printStringUsing: self</body><body package="Chronos-Printing" selector="nominalNowAs:">nominalNowAs: calendar	"ChronosPrintPolicy rfc2822 nominalNowAs: #Hebrew"	^(DateAndTimeFactory nominalNowAs: calendar) printStringUsing: self</body><body package="Chronos-Printing" selector="now">now	"ChronosPrintPolicy universal now"	"ChronosPrintPolicy rfc2822 now"	"ChronosPrintPolicy verbose now"	"ChronosPrintPolicy usLong now"	"ChronosPrintPolicy usShort now"	"ChronosPrintPolicy iso8601 now"	"(ChronosPrintPolicy applying: 		#(showEraNameBeforeDate)) now" 	"{(ChronosPrintPolicy applying: 		#(useTimeBeforeDateOrder 		useMonthDayYearOrder		useMonthName		dateSeparator: $ 		timeOfDayPrefix: '                The current local time: ' 		dateAndTimeSeparator: '.                Today''s date: '		hideSubsecondFraction		timeZoneSeparator: '.                Time zone offset: '		timeZoneElementSeparator: $h)) now}"	^DateAndTimeFactory now printStringUsing: self</body><body package="Chronos-Printing" selector="nowAs:">nowAs: calendar	"ChronosPrintPolicy rfc2822 nowAs: #Ethiopic"	"ChronosPrintPolicy universal nowAs: #Ethiopic"	"ChronosPrintPolicy verbose nowAs: #Ethiopic"	^(DateAndTimeFactory nowAs: calendar) printStringUsing: self</body><body package="Chronos-Printing" selector="nowIn:">nowIn: aTimezone	"ChronosPrintPolicy universal nowIn: 'Europe/Moscow'"	"ChronosPrintPolicy rfc2822 nowIn: 'Europe/Moscow'"	"ChronosPrintPolicy usLong nowIn: 'Europe/Moscow'"	^(DateAndTimeFactory nowIn: aTimezone) printStringUsing: self</body><body package="Chronos-Printing" selector="nowIn:as:">nowIn: aTimezone as: aCalendar	"ChronosPrintPolicy verbose nowIn: 'Asia/Tehran' as: #Persian"	^(DateAndTimeFactory nowIn: aTimezone as: aCalendar) printStringUsing: self</body><body package="Chronos-Printing" selector="nowToTheSecond">nowToTheSecond	"ChronosPrintPolicy universal nowToTheSecond"	"ChronosPrintPolicy rfc2822 nowToTheSecond"	"ChronosPrintPolicy verbose nowToTheSecond"	"ChronosPrintPolicy usLong nowToTheSecond"	"ChronosPrintPolicy usShort nowToTheSecond"	"ChronosPrintPolicy iso8601 nowToTheSecond"	^DateAndTimeFactory nowToTheSecond printStringUsing: self</body><body package="Chronos-Printing" selector="today">today	"ChronosPrintPolicy usLong today"	^DateAndTimeFactory today printStringUsing: self</body><body package="Chronos-Printing" selector="todayAs:">todayAs: calendar	"ChronosPrintPolicy universal todayAs: #Coptic"	^(DateAndTimeFactory todayAs: calendar) printStringUsing: self</body><body package="Chronos-Printing" selector="todayIn:">todayIn: aTimezone	"ChronosPrintPolicy universal todayIn: 'Europe/Moscow'"	^(DateAndTimeFactory todayIn: aTimezone) printStringUsing: self</body><body package="Chronos-Printing" selector="todayIn:as:">todayIn: aTimezone as: aCalendar	"ChronosPrintPolicy universal todayIn: 'Asia/Tehran' as: #Persian"	^(DateAndTimeFactory todayIn: aTimezone as: aCalendar) printStringUsing: self</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-dates-elements</category><body package="Chronos-Printing" selector="dontPrintYear:on:">dontPrintYear: year on: stream 	" Do nothing!"</body><body package="Chronos-Printing" selector="printCalendarElementsFrom:maxPrecision:on:">printCalendarElementsFrom: aDate maxPrecision: maxPrecision on: stream 	self printYearMonthDayFrom: aDate maxPrecision: maxPrecision on: stream</body><body package="Chronos-Printing" selector="printCalendarElementsFrom:on:">printCalendarElementsFrom: aDate on: stream</body><body package="Chronos-Printing" selector="printCalendarNameFrom:on:">printCalendarNameFrom: aDate on: stream	stream 		nextPut: $[;		nextPutAll: (self properNameAtSemanticKey: aDate  calendarRegistrationKey);		nextPut: $]</body><body package="Chronos-Printing" selector="printDayMonthYearFrom:maxPrecision:dayMonthSeparator:monthYearSeparator:on:">printDayMonthYearFrom: aDate maxPrecision: maxPrecision  dayMonthSeparator: monthDaySep monthYearSeparator: yearMonthSep on: stream 	| mp |	mp := 		maxPrecision isInteger			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	(mp &lt; 6) 			ifTrue: 				[(mp &lt; 5) 						ifTrue: 							[self printDayOfMonthFrom: aDate on: stream.							self printSeparator: monthDaySep on: stream].				self printMonthAbbreviationFrom: aDate on: stream.				self printSeparator: yearMonthSep on: stream].	self printYear: aDate year on: stream</body><body package="Chronos-Printing" selector="printDayMonthYearFrom:maxPrecision:on:">printDayMonthYearFrom: aDate maxPrecision: maxPrecision on: stream 	self 		printDayMonthYearFrom: aDate		maxPrecision: maxPrecision		dayMonthSeparator: self monthDaySeparator		monthYearSeparator: self yearMonthSeparator		on: stream</body><body package="Chronos-Printing" selector="printDayOfMonthFrom:on:">printDayOfMonthFrom: aDate on: stream 	ChronosFunction 		print: aDate dayOfMonth		paddedWith: self dayOfMonthPadChar		to: 2		on: stream</body><body package="Chronos-Printing" selector="printDayOfWeekFrom:on:">printDayOfWeekFrom: aDate on: stream 	self printProperNameAt: aDate dayOfWeekKey on: stream.</body><body package="Chronos-Printing" selector="printDayOfYearFrom:on:">printDayOfYearFrom: aDate on: stream 	ChronosFunction 		print: aDate dayOfYear		paddedWith: $0		to: 3		on: stream</body><body package="Chronos-Printing" selector="printDaysSinceEpochFrom:maxPrecision:on:">printDaysSinceEpochFrom: aDate maxPrecision: maxPrecision on: stream	stream nextPutAll: 'D.S.E. '.	aDate daysSinceEpoch printOn: stream.</body><body package="Chronos-Printing" selector="printEraNameFrom:on:">printEraNameFrom: aDate on: stream	stream 		nextPutAll: aDate eraName</body><body package="Chronos-Printing" selector="printFullYear:on:">printFullYear: year on: stream 	ChronosFunction 		print: year		paddedWith: self yearPadChar		to: 4		on: stream</body><body package="Chronos-Printing" selector="printGregorianDayFrom:maxPrecision:on:">printGregorianDayFrom: aDate maxPrecision: maxPrecision on: stream	stream nextPutAll: 'G.D. '.	aDate asGregorian daysSinceEpoch printOn: stream.</body><body package="Chronos-Printing" selector="printISOWeekOfYearDayOfWeekFrom:maxPrecision:on:">printISOWeekOfYearDayOfWeekFrom: aDate maxPrecision: maxPrecision on: stream 	| mp |	mp := 		maxPrecision isInteger 			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	aDate isoYearWeekDayOfWeekDo: 			[:year :week :dayOfWeek | 			year == nil 				ifFalse: 					[self printYear: year on: stream.					mp &lt; 6 ifTrue: [self printSeparator: $- on: stream]].			mp &lt; 6 				ifTrue: 					[stream nextPut: $W.					ChronosFunction 						print: week						paddedWith: $0						to: 2						on: stream.					mp &lt; 5						ifTrue:							[self printSeparator: $- on: stream.							stream print: dayOfWeek]]]</body><body package="Chronos-Printing" selector="printJulianDayFrom:maxPrecision:on:">printJulianDayFrom: aDate maxPrecision: maxPrecision on: stream	stream nextPutAll: 'J.D. '.	aDate julianDay printOn: stream.</body><body package="Chronos-Printing" selector="printMonthAbbreviationFrom:on:">printMonthAbbreviationFrom: date on: stream 	stream nextPutAll: (self monthAbbreviationFrom: date)</body><body package="Chronos-Printing" selector="printMonthDayFrom:monthDaySeparator:on:">printMonthDayFrom: aDate monthDaySeparator: monthDaySep on: stream 	aDate isMonthKeyResolvable		ifTrue: [self printMonthAbbreviationFrom: aDate on: stream]		ifFalse: [self printMonthOrdinalFrom: aDate on: stream].		self printSeparator: monthDaySep on: stream.	self printDayOfMonthFrom: aDate on: stream.</body><body package="Chronos-Printing" selector="printMonthDayFrom:on:">printMonthDayFrom: aDate on: stream 	self 		printMonthDayFrom: aDate		monthDaySeparator: self monthDaySeparator		on: stream</body><body package="Chronos-Printing" selector="printMonthDayYearFrom:maxPrecision:monthDaySeparator:dayYearSeparator:on:">printMonthDayYearFrom: aDate maxPrecision: maxPrecision monthDaySeparator: monthDaySep dayYearSeparator: dayYearSep on: stream 	| mp |	mp := 		maxPrecision isInteger 			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	(mp &lt; 6)		ifTrue:			[self printMonthFrom: aDate on: stream.			self printSeparator: monthDaySep on: stream.			(mp &lt; 5)				ifTrue:					[self printDayOfMonthFrom: aDate on: stream.					self printSeparator: dayYearSep on: stream]].	self printYear: aDate year on: stream</body><body package="Chronos-Printing" selector="printMonthDayYearFrom:maxPrecision:on:">printMonthDayYearFrom: aDate maxPrecision: maxPrecision on: stream 	self 		printMonthDayYearFrom: aDate		maxPrecision: maxPrecision		monthDaySeparator: self monthDaySeparator		dayYearSeparator: self dayYearSeparator		on: stream</body><body package="Chronos-Printing" selector="printMonthFrom:on:">printMonthFrom: date on: stream 	self printMonthOrdinalFrom: date on: stream</body><body package="Chronos-Printing" selector="printMonthNameFrom:on:">printMonthNameFrom: date on: stream 	stream nextPutAll: (self monthNameFrom: date)</body><body package="Chronos-Printing" selector="printMonthOrdinalFrom:on:">printMonthOrdinalFrom: date on: stream 	ChronosFunction  		print: date month		paddedWith: self monthPadChar		to: 2		on: stream</body><body package="Chronos-Printing" selector="printNumericMonthDesignatorFrom:on:">printNumericMonthDesignatorFrom: date on: stream 	ChronosFunction  		print: date numericMonthDesignator		paddedWith: self monthPadChar		to: 2		on: stream</body><body package="Chronos-Printing" selector="printOrdinalDateFrom:maxPrecision:on:">printOrdinalDateFrom: aDate maxPrecision: maxPrecision on: stream 	| mp |	mp := 		maxPrecision isInteger 			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	self printYear: aDate year on: stream.	(mp &lt; 5)		ifTrue: 			[self printSeparator: $- on: stream.			self printDayOfYearFrom: aDate on: stream]</body><body package="Chronos-Printing" selector="printSemanticKeyFrom:on:">printSemanticKeyFrom: aDate on: stream 	self printProperNameAt: (aDate semanticKeyIfNone: [^self]) on: stream</body><body package="Chronos-Printing" selector="printTwoDigitYear:on:">printTwoDigitYear: year on: stream 	ChronosFunction  		print: (ChronosFunction twoDigitYearFromFullYear: year)		paddedWith: self yearPadChar		to: 2		on: stream</body><body package="Chronos-Printing" selector="printYear:on:">printYear: year on: stream 	self printFullYear:year on: stream</body><body package="Chronos-Printing" selector="printYearDayMonthFrom:maxPrecision:on:">printYearDayMonthFrom: aDate maxPrecision: maxPrecision on: stream 	self 		printYearDayMonthFrom: aDate		maxPrecision: maxPrecision		yearDaySeparator: self dayYearSeparator		dayMonthSeparator: self monthDaySeparator		on: stream</body><body package="Chronos-Printing" selector="printYearDayMonthFrom:maxPrecision:yearDaySeparator:dayMonthSeparator:on:">printYearDayMonthFrom: aDate maxPrecision: maxPrecision yearDaySeparator: dayYearSep dayMonthSeparator: monthDaySep on: stream 	| mp |	mp := 		maxPrecision isInteger 			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	self printYear: aDate year on: stream.	(mp &lt; 6)		ifTrue:			[self printSeparator: dayYearSep on: stream.			(mp &lt; 5)				ifTrue:					[self printDayOfMonthFrom: aDate on: stream.					self printSeparator: monthDaySep on: stream].			self printMonthAbbreviationFrom: aDate on: stream]</body><body package="Chronos-Printing" selector="printYearMonthDayFrom:maxPrecision:on:">printYearMonthDayFrom: aDate maxPrecision: maxPrecision on: stream 	self 		printYearMonthDayFrom: aDate		maxPrecision: maxPrecision		yearMonthSeparator: self yearMonthSeparator		monthDaySeparator: self monthDaySeparator		on: stream</body><body package="Chronos-Printing" selector="printYearMonthDayFrom:maxPrecision:yearMonthSeparator:monthDaySeparator:on:">printYearMonthDayFrom: aDate maxPrecision: maxPrecision yearMonthSeparator: yearMonthSep monthDaySeparator: monthDaySep on: stream 	| mp |	mp := 		maxPrecision isInteger 			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	self printYear: aDate year on: stream.	(mp &lt; 6)		ifTrue:			[self printSeparator: yearMonthSep on: stream.			self printMonthFrom: aDate on: stream.			(mp &lt; 5)				ifTrue:					[self printSeparator: monthDaySep on: stream.					self printDayOfMonthFrom: aDate on: stream]]</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-annual dates</category><body package="Chronos-Printing" selector="printAnnualDate:on:">printAnnualDate: anAnnualDate on: stream 	(self shouldShowCalendarNameOf: anAnnualDate) 		ifTrue: 			[stream space.			self printCalendarNameFrom: anAnnualDate on: stream].	anAnnualDate class printOn: stream</body><body package="Chronos-Printing" selector="printDayOfMonth:on:">printDayOfMonth: aDayOfMonth on: stream 	self printMonthDayFrom: aDayOfMonth on: stream.	(self shouldShowCalendarNameOf: aDayOfMonth) 		ifTrue: 			[stream space.			self printCalendarNameFrom: aDayOfMonth on: stream].</body><body package="Chronos-Printing" selector="printDayOfYear:on:">printDayOfYear: aDayOfYear on: stream 	stream nextPutAll: 'YYYY'.	self printSeparator: $- on: stream.	self printDayOfYearFrom: aDayOfYear on: stream.	(self shouldShowCalendarNameOf: aDayOfYear) 		ifTrue: 			[stream space.			self printCalendarNameFrom: aDayOfYear on: stream].</body><body package="Chronos-Printing" selector="printWeekOfMonthDayOfWeek:on:">printWeekOfMonthDayOfWeek: aWeekOfMonthDayOfWeek on: stream 	stream		nextPut: ${;		nextPutAll: (self singularNounAtSemanticKey: #month);		nextPut: $=.	aWeekOfMonthDayOfWeek isMonthKeyResolvable		ifTrue: [self printMonthAbbreviationFrom: aWeekOfMonthDayOfWeek on: stream]		ifFalse: [self printMonthOrdinalFrom: aWeekOfMonthDayOfWeek on: stream].		stream nextPutAll: ' | '.	stream nextPutAll: (self pluralNounAtSemanticKey: #dayOfMonth).	stream nextPut: $=.	aWeekOfMonthDayOfWeek minDayOfMonthOrdinal printOn: stream.	stream nextPutAll: '..'.	aWeekOfMonthDayOfWeek maxDayOfMonthOrdinal printOn: stream.	stream nextPutAll: ' | '.	stream nextPutAll: (self singularNounAtSemanticKey: #dayOfWeek).	stream nextPut: $=.	self printDayOfWeekFrom: aWeekOfMonthDayOfWeek on: stream.	(self shouldShowCalendarNameOf: aWeekOfMonthDayOfWeek) 		ifTrue: 			[stream space.			self printCalendarNameFrom: aWeekOfMonthDayOfWeek on: stream].	stream nextPut: $}.</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-names</category><body package="Chronos-Printing" selector="printAbbreviationAt:on:">printAbbreviationAt: semanticKey on: stream	stream		nextPutAll: (self abbreviationAtSemanticKey: semanticKey)</body><body package="Chronos-Printing" selector="printProperNameAt:on:">printProperNameAt: semanticKey on: stream	stream		nextPutAll: (self properNameAtSemanticKey: semanticKey)</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-calendarPeriods</category><body package="Chronos-Printing" selector="printCalendarDay:on:">printCalendarDay: aCalendarDay on: stream	self printMonthDayFrom: aCalendarDay on: stream.</body><body package="Chronos-Printing" selector="printMonthlyCalendar:on:">printMonthlyCalendar: aMonthlyCalendar on: stream	aMonthlyCalendar basicPrintOn: stream</body><body package="Chronos-Printing" selector="printYearlyCalendar:on:">printYearlyCalendar: aYearlyCalendar on: stream	aYearlyCalendar basicPrintOn: stream</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-polymorphic</category><body package="Chronos-Printing" selector="print:on:">print: aTemporal on: stream	aTemporal printOn: stream using: self</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>private</category><body package="Chronos-Printing" selector="shouldShowCalendarNameOf:">shouldShowCalendarNameOf: aCalendrical	^aCalendrical calendarRegistrationKey ~~ self standardCalendarRegistrationKey</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-dates/timepoints</category><body package="Chronos-Printing" selector="printDate:maxPrecision:showCalendar:on:">printDate: aDate maxPrecision: maxPrecision showCalendar: showCalendar on: stream 	self 		printDate: aDate		showDayOfWeek: self showsDayOfWeek		maxPrecision: maxPrecision		eraPolicy: self eraPolicy		showCalendar: showCalendar		on: stream</body><body package="Chronos-Printing" selector="printDate:on:">printDate: aDate on: stream 	self 		printDate: aDate		maxPrecision: self dateAndTimeMaxPrecision		showCalendar: (self shouldShowCalendarNameOf: aDate) 		on: stream</body><body package="Chronos-Printing" selector="printDate:showDayOfWeek:maxPrecision:eraPolicy:showCalendar:on:">printDate: aDate showDayOfWeek: showDayOfWeek maxPrecision: maxPrecision eraPolicy: eraPolicy showCalendar: showCalendar on: stream 	showDayOfWeek 		ifTrue: 			[self printDayOfWeekFrom: aDate on: stream.			stream nextPutAll: ', '].	eraPolicy == #showEraNameBeforeDate		ifTrue: 			[self printEraNameFrom: aDate on: stream.			stream space].	self printCalendarElementsFrom: aDate maxPrecision: maxPrecision on: stream.	eraPolicy == #showEraNameAfterDate		ifTrue: 			[stream space.			self printEraNameFrom: aDate on: stream].	showCalendar		ifTrue: 			[stream space.			self printCalendarNameFrom: aDate on: stream]</body><body package="Chronos-Printing" selector="printDateAndTime:maxPrecision:dateAndTimeSeparator:showTimeZone:on:">printDateAndTime: aDateAndTime maxPrecision: maxPrecision dateAndTimeSeparator: dateAndTimeSeparator showTimeZone: showTimeZone on: stream 	self dateAndTimeOrder == #useDateBeforeTimeOrder 		ifTrue: 			[aDateAndTime isCalendricalCoordinate 				ifTrue: 					[self 						printDate: aDateAndTime						maxPrecision: maxPrecision						showCalendar: false						on: stream].			(maxPrecision isInteger 				or: [(#(#all #minute #hour #day #month #year) indexOf: maxPrecision) &lt; 4]) 					ifTrue: 						[self printSeparator: dateAndTimeSeparator on: stream.						self 							printTimeOfDay: aDateAndTime							maxPrecision: maxPrecision							on: stream]]		ifFalse: 			[(maxPrecision isInteger 				or: [(#(#all #minute #hour #day #month #year) indexOf: maxPrecision) &lt; 4]) 					ifTrue: 						[self 							printTimeOfDay: aDateAndTime							maxPrecision: maxPrecision							on: stream.						self printSeparator: dateAndTimeSeparator on: stream].			aDateAndTime isCalendricalCoordinate 				ifTrue: 					[self 						printDate: aDateAndTime						maxPrecision: maxPrecision						showCalendar: false						on: stream]].	showTimeZone ifTrue: [self printTimeZoneFrom: aDateAndTime on: stream].	(self shouldShowCalendarNameOf: aDateAndTime) 		ifTrue: 			[stream space.			self printCalendarNameFrom: aDateAndTime on: stream]</body><body package="Chronos-Printing" selector="printDateAndTime:on:">printDateAndTime: aDateAndTime on: stream 	self 		printDateAndTime: aDateAndTime		maxPrecision: self dateAndTimeMaxPrecision 		dateAndTimeSeparator: self dateAndTimeSeparator		showTimeZone: (self showsTimeZone and: [aDateAndTime isInvariantToUT])		on: stream</body><body package="Chronos-Printing" selector="printInfiniteTimepoint:on:">printInfiniteTimepoint: anInfiniteTimepoint on: stream	stream		nextPut: (anInfiniteTimepoint isInfinitePast ifTrue: [$-] ifFalse: [$+]);		nextPutAll: 'infiniteTimepoint'</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-time of day</category><body package="Chronos-Printing" selector="printSubsecondFractionFrom:on:prependingZero:">printSubsecondFractionFrom: aTimeOfDay on: stream prependingZero: shouldPrependZero	| maxPrecision |	maxPrecision := self dateAndTimeMaxPrecision.	self 		printNanosecondsSinceSecond: aTimeOfDay nanosecondsSinceSecond 		asSubsecondFractionOn: stream 		minPrecision: self subSecondTimeMinPrecision		maxPrecision: ((maxPrecision isInteger or: [maxPrecision == #all]) ifTrue: [maxPrecision] ifFalse: [0])		prependingZero: shouldPrependZero</body><body package="Chronos-Printing" selector="printTimeOfDay:maxPrecision:on:">printTimeOfDay: aTimeOfDay maxPrecision: maxPrecision on: stream 	self 		printTimeOfDay: aTimeOfDay		prefix: self timeOfDayPrefix		maxPrecision: maxPrecision		hour24Format: self uses24HourClock		separator: self hourMinuteSecondSeparator		on: stream</body><body package="Chronos-Printing" selector="printTimeOfDay:on:">printTimeOfDay: aTimeOfDay on: stream 	self 		printTimeOfDay: aTimeOfDay		maxPrecision: self dateAndTimeMaxPrecision		on: stream</body><body package="Chronos-Printing" selector="printTimeOfDay:prefix:maxPrecision:hour24Format:separator:on:">printTimeOfDay: aTimeOfDay prefix: prefix maxPrecision: maxPrecision hour24Format: hour24 separator: hourMinuteSecondSeparator on: stream 	self printSeparator: prefix on: stream.	aTimeOfDay 		hourMinuteSecondDo: 			[:hour :minute :second | 			| mp |			hour24 				ifTrue: [self printHour24: hour on: stream]				ifFalse: [self printHour12: hour on: stream].			mp := 				maxPrecision isInteger					ifTrue: [maxPrecision negated]					ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].			(mp &lt; 3)				ifTrue: 					[self printSeparator: hourMinuteSecondSeparator on: stream.					self printTimeElement: minute on: stream.					(mp &lt; 2)						ifTrue:							[self printSeparator: hourMinuteSecondSeparator on: stream.							self printTimeElement: second on: stream.							self 								printSubsecondFractionFrom: aTimeOfDay								on: stream								prependingZero: false]].			hour24 				ifFalse: 					[stream space.					self printProperNameAt: (MeridianKeys at: hour // 12 + 1) on: stream]]		hour24Format: hour24</body></methods><methods><class-id>Chronos.ChronosPrintPolicy</class-id> <category>printing-timeperiods</category><body package="Chronos-Printing" selector="printTimeperiod:on:">printTimeperiod: aTimeperiod on: stream 	"ISO8601 format--since ANSI doesn't specify a format for timeperiods (intervals.)"	| start duration timeperiodDefaultPrinter |	start := aTimeperiod start.	duration := aTimeperiod duration.	timeperiodDefaultPrinter := 		[start printOn: stream using: self class iso8601.		stream nextPut: $/.		duration printOn: stream using: self class ansiStandard].	duration isMinimumResolutionQuantum 		ifTrue: [start printOn: stream using: self]		ifFalse: 			[(start subsecondsAreZero and: [duration subsecondsAreZero]) 				ifTrue: 					[| dateAndTimePrinter seconds minutes hours days months years |					dateAndTimePrinter :=						[:maxPrecision | 							self 								printDateAndTime: start								maxPrecision: maxPrecision								dateAndTimeSeparator: self dateAndTimeSeparator								showTimeZone: (self showsTimeZone and: [start isInvariantToUT])								on: stream].					seconds := duration seconds.					minutes := duration minutes.					hours := duration hours.					days := duration days.					months := duration months.					years := duration years.					(seconds = 1 and: [minutes = 0 and: [hours = 0 and: [days = 0 and: [months = 0 and: [years = 0]]]]])						ifTrue: [dateAndTimePrinter value: 0]						ifFalse: 							[| timeOfDay |							timeOfDay := start timeOfDaySinceStartOfDay.							(seconds = 0 and: [timeOfDay second = 0]) 								ifTrue: 									[(minutes = 1 and: [hours = 0 and: [days = 0 and: [months = 0 and: [years = 0]]]])										ifTrue: [dateAndTimePrinter value: #minute]										ifFalse: 											[(minutes = 0 and: [timeOfDay minute = 0]) 												ifTrue: 													[(hours = 1 and: [days = 0 and: [months = 0 and: [years = 0]]])														ifTrue: [dateAndTimePrinter value: #hour]														ifFalse: 															[(hours = 0 and: [timeOfDay hour = 0]) 																ifTrue: 																	[| datePrinter |																	datePrinter := 																		[:maxPrecision | 																			self  printDate: start maxPrecision: maxPrecision showCalendar: false on: stream.																			(self showsTimeZone and: [start isInvariantToUT]) 																				ifTrue: [self printTimeZoneFrom: start on: stream].																			(self shouldShowCalendarNameOf: start) 																				ifTrue: 																					[stream space.																					self printCalendarNameFrom: start on: stream]].																	(days = 1 and: [months = 0 and: [years = 0]]) 																		ifTrue: [datePrinter value: #day]																		ifFalse: 																			[(days = 0 and: [start isFirstDayOfMonth]) 																				ifTrue: 																					[(months = 1 and: [years = 0]) 																						ifTrue: [datePrinter value: #month]																						ifFalse: 																							[(months = 0 and: [start isFirstDayOfYear]) 																								ifTrue: 																									[years := duration years.																									years = 1 																										ifTrue: [datePrinter value: #year]																										ifFalse: [timeperiodDefaultPrinter value]]																								ifFalse: [timeperiodDefaultPrinter value]]]																				ifFalse: [timeperiodDefaultPrinter value]]]																ifFalse: [timeperiodDefaultPrinter value]]]												ifFalse: [timeperiodDefaultPrinter value]]]								ifFalse: [timeperiodDefaultPrinter value]]]				ifFalse: [timeperiodDefaultPrinter value]]</body></methods><methods><class-id>Chronos.ChronosPrintPolicy class</class-id> <category>accessing</category><body package="Chronos-Printing" selector="ansiStandard">ansiStandard	"ChronosPrintPolicy ansiStandard now"	ANSIStandard == nil 		ifTrue: 			[| ansiStandard |			ansiStandard := self newANSIStandard.			ansiStandard  				setKey: #ansiStandard;				forceRegistration.			ANSIStandard := ansiStandard].	^ANSIStandard</body><body package="Chronos-Printing" selector="at:ifAbsent:">at: key ifAbsent: notFound 	"ChronosPrintPolicy at: #default"	"ChronosPrintPolicy at: #ansiStandard"	"ChronosPrintPolicy at: #iso8601"	"ChronosPrintPolicy at: #rfc2822"	| policy |	(key == #default or: [key == #ansiStandard]) ifTrue: [^self ansiStandard].	key == #iso8601 ifTrue: [^self iso8601].	policy := self registry at: key ifAbsent: [0].	^(policy == nil or: [policy = 0])		ifTrue: 			[(self applying: (self specificationAt: key ifAbsent: [^notFound value]))				setKey: key; forceRegistration]		ifFalse: [policy]</body><body package="Chronos-Printing" selector="default">default	^self ansiStandard</body><body package="Chronos-Printing" selector="dmyOnly">dmyOnly	"ChronosPrintPolicy dmyOnly now"	^self at: #dmyOnly</body><body package="Chronos-Printing" selector="forLocaleAt:do:">forLocaleAt: localeKey do: block1	^ChronosLocale at: localeKey do: [:locale | block1 value: locale temporalPrintPolicy]</body><body package="Chronos-Printing" selector="germanLong">germanLong	"ChronosPrintPolicy germanLong now"	"{ChronosPrintPolicy forLocaleAt: #'de_DE' do: [:printPolicy | (printPolicy apply: (self specificationAt: #germanLong ifAbsent: [])) nowIn: 'Europe/Berlin']}"	^self at: #germanLong</body><body package="Chronos-Printing" selector="germanShort">germanShort	"ChronosPrintPolicy germanShort now"	"{ChronosPrintPolicy forLocaleAt: #'de_DE' do: [:printPolicy | (printPolicy apply: (self specificationAt: #germanShort ifAbsent: [])) nowIn: 'Europe/Berlin']}"	^self at: #germanShort</body><body package="Chronos-Printing" selector="handleUnregistered:">handleUnregistered: aKey	^self signalError: 'Unrecognized printPolicy key: ', aKey printString</body><body package="Chronos-Printing" selector="iso8601">iso8601	"ChronosPrintPolicy iso8601 now"	ISO8601 == nil 		ifTrue: 			[| iso8601 |			iso8601 := self newISO8601.			iso8601 				setKey: #iso8601;				forceRegistration.			ISO8601 := iso8601].	^ISO8601</body><body package="Chronos-Printing" selector="isoWeekOfYearDayOfWeek">isoWeekOfYearDayOfWeek	"ChronosPrintPolicy isoWeekOfYearDayOfWeek now"	^self at: #isoWeekOfYearDayOfWeek</body><body package="Chronos-Printing" selector="mdyOnly">mdyOnly	"ChronosPrintPolicy mdyOnly now"	^self at: #mdyOnly</body><body package="Chronos-Printing" selector="referencedBy:">referencedBy: aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec 	"Answer the value referenced by &lt;aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec&gt;. If the value is a key, answer the value bound to the key. If the value is a sequenceable collection, answer the result of creating an instance of ChronosConfigurablePrintPolicy and then sending it the messages that are the elements of the sequenceable collection.  Otherwise, answer aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec itself."	"(ChronosPrintPolicy referencedBy: ChronosPrintPolicy iso8601) now"	"(ChronosPrintPolicy referencedBy: #rfc2822) now"	"(ChronosPrintPolicy referencedBy: 		#(useNumericMonthDesignator 		showEraName 		dateAndTimeSeparator: ' @ ' 		use12HourFormat 		hourPadChar: nil 		hideSubsecondFraction		timeZoneSeparator: $ 		timeZoneElementSeparator: nil 		showStandardCalendarName)) now"	^aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec 		isString 			ifTrue: 				[super 					referencedBy: aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec]			ifFalse: 				[aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec 					isSequenceable 						ifTrue: 							[(self 								applying: aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec) beImmutable]						ifFalse: 							[super 								referencedBy: aChronosPrintPolicyOrChronosPrintPolicyKeyOrChronosPrintPolicySpec]]</body><body package="Chronos-Printing" selector="rfc2822">rfc2822	"ChronosPrintPolicy rfc2822 now"	^self at: #rfc2822</body><body package="Chronos-Printing" selector="rfc2822v">rfc2822v	"ChronosPrintPolicy rfc2822v now"	^self at: #rfc2822v</body><body package="Chronos-Printing" selector="rfc822">rfc822	"ChronosPrintPolicy rfc822 now"	^self at: #rfc822</body><body package="Chronos-Printing" selector="universal">universal	"ChronosPrintPolicy universal now"	^self at: #universal</body><body package="Chronos-Printing" selector="usLong">usLong	"ChronosPrintPolicy usLong now"	^self at: #usLong</body><body package="Chronos-Printing" selector="usShort">usShort	"ChronosPrintPolicy usShort now"	^self at: #usShort</body><body package="Chronos-Printing" selector="verbose">verbose	"ChronosPrintPolicy verbose now"	^self at: #verbose</body><body package="Chronos-Printing" selector="vwTimestamp">vwTimestamp	"{ChronosPrintPolicy vwTimestamp now}"	"{Timestamp now printString}"	^self at: #vwTimestamp</body><body package="Chronos-Printing" selector="ymdOnly">ymdOnly	"ChronosPrintPolicy ymdOnly now"	^self at: #ymdOnly</body></methods><methods><class-id>Chronos.ChronosPrintPolicy class</class-id> <category>specifications</category><body package="Chronos-Printing" selector="specificationAt:ifAbsent:">specificationAt: key ifAbsent: ifAbsent	^self specRegistry at: key ifAbsent: ifAbsent</body><body package="Chronos-Printing" selector="specificationAt:put:">specificationAt: key put: aPrintPolicySpec	self specRegistry at: key put: aPrintPolicySpec</body></methods><methods><class-id>Chronos.ChronosPrintPolicy class</class-id> <category>private</category><body package="Chronos-Printing" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	| key |	key := literalArray at: 2.	^ChronosPrintPolicy 		at: key		ifAbsent: 			[(self new)				initializeFromLiteralArray: literalArray;				beImmutable]</body><body package="Chronos-Printing" selector="setSpecRegistry">setSpecRegistry	SpecRegistry := IdentityDictionary new.</body><body package="Chronos-Printing" selector="specRegistry">specRegistry	SpecRegistry == nil ifTrue: [self setSpecRegistry].	^SpecRegistry</body></methods><methods><class-id>Chronos.ChronosPrintPolicy class</class-id> <category>instance creation</category><body package="Chronos-Printing" selector="new">new	^self newConfigurable</body><body package="Chronos-Printing" selector="newANSIStandard">newANSIStandard	"PRINT IT: {ChronosPrintPolicy newANSIStandard}"	^ChronosPrintPolicy basicNew</body><body package="Chronos-Printing" selector="newConfigurable">newConfigurable	^ConfigurableChronosPrintPolicy basicNew initialize</body><body package="Chronos-Printing" selector="newISO8601">newISO8601	"PRINT IT: {ChronosPrintPolicy newISO8601}"	^ISO8601PrintPolicy new</body></methods><methods><class-id>Chronos.ChronosPrintPolicy class</class-id> <category>class initialization</category><body package="Chronos-Printing" selector="initialize">initialize	"ChronosPrintPolicy initialize" 	self basicInitializeAll.		ANSIStandard := nil.	ISO8601 := nil.	self initializeSpecifications</body><body package="Chronos-Printing" selector="initializeSpecifications">initializeSpecifications	"ChronosPrintPolicy initializeSpecifications"	| rfc2822Spec |	self setSpecRegistry.	self 		specificationAt: #dmyOnly 		put: #(hideTimeOfDay				hideTimeZone				useMonthAbbreviation				useDayMonthYearOrder 				hideDayOfWeek 				hideEraName 				hideStandardCalendarName 				dateSeparator: $ 				datePadChar: nil).	self 		specificationAt: #mdyOnly 		put: #(hideTimeOfDay				hideTimeZone				useMonthAbbreviation				useMonthDayYearOrder 				hideDayOfWeek 				hideEraName 				hideStandardCalendarName 				dateSeparator: $ ).	self 		specificationAt: #ymdOnly 		put: #(hideTimeOfDay				hideTimeZone				useNumericMonthDesignator				useYearMonthDayOrder 				hideDayOfWeek 				hideEraName 				hideStandardCalendarName 				dateSeparator: $-).	rfc2822Spec := 				#(confomToLocale: #en				padChar: $0				showDayOfWeekAbbreviation 				useDayMonthYearOrder 				useMonthAbbreviation 				yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator: $ $  ', '				hideEraName 				showTimeOfDay				dateAndTimeSeparator: $ 				use24HourFormat				timeOfDayPrefix: nil				hideSubsecondFraction				showTimeZoneOffset				timeZoneSeparator: $ 				timeZoneElementSeparator: nil				hideNamesOfDurationElements				showNamesOfCalendarDurationElements				durationElementSeparator: $:				calendarDurationElementSeparator: $ 				durationDayHourSeparator: $T 				calendarDurationDayHourSeparator: $ 				durationPadChar: $0				calendarDurationPadChar: nil).	self 		specificationAt: #rfc2822 		put: rfc2822Spec.	self 		specificationAt: #rfc822 		put: (rfc2822Spec copyWith: #useTwoDigitYears).	self 		specificationAt: #rfc2822v 		put: (rfc2822Spec copyWith: #showTimeZoneVerbosely).	self		specificationAt: #isoWeekOfYearDayOfWeek		put: #(useISOWeekOfYearDayOfWeek).	self 		specificationAt: #usLong		put: #(confomToLocale: #'en_US'				showDayOfWeekName 				useMonthDayYearOrder 				useMonthName 				yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator: $ $  ', '				padChar: nil 				dateAndTimeSeparator: '  ' 				timeOfDayPrefix: nil				showTimeOfDay				use12HourFormat				hideSubsecondFraction				timeZoneSeparator: $ 				timeZoneElementSeparator: nil				showTimeZoneAbbreviation				showNamesOfDurationElements				showNamesOfCalendarDurationElements				durationElementSeparator: $ 				calendarDurationElementSeparator: $ 				durationDayHourSeparator: $ 				calendarDurationDayHourSeparator: $ 				durationPadChar: nil				calendarDurationPadChar: nil).	self 		specificationAt: #usShort		put: #(confomToLocale: #'en_US'				useMonthOrdinal				useMonthDayYearOrder 				yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator: $/ $/ $/				padChar: nil 				dateAndTimeSeparator: $ 				timeOfDayPrefix: nil				showTimeOfDay				use12HourFormat				hideTimeOfDaySecond				timeZoneSeparator: $ 				timeZoneElementSeparator: nil				showTimeZoneAbbreviation				showNamesOfCalendarDurationElements				calendarDurationElementSeparator: $ 				durationDayHourSeparator: $T 				calendarDurationDayHourSeparator: $ 				calendarDurationPadChar: nil).	self		specificationAt: #germanShort		put: #(useMonthOrdinal				useDayMonthYearOrder 				yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator: '. ' '. ' '. '				padChar: nil 				useMonthAbbreviation				dateAndTimeSeparator: $  				timeOfDayPrefix: nil				showTimeOfDay				hourMinuteSecondSeparator: $.				use24HourFormat				hideSubsecondFraction				timeZoneSeparator: $ 				timeZoneElementSeparator: nil				showTimeZoneAbbreviation				durationDayHourSeparator: $T 				calendarDurationDayHourSeparator: $T).	self		specificationAt: #germanLong		put: #(showDayOfWeekName 				useMonthOrdinal				useDayMonthYearOrder 				yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator: $  '. ' '. '				padChar: nil 				useMonthName				dateAndTimeSeparator: $  				timeOfDayPrefix: nil				showTimeOfDay				hourMinuteSecondSeparator: $.				use24HourFormat				hideSubsecondFraction				timeZoneSeparator: $ 				timeZoneElementSeparator: nil				showTimeZoneAbbreviation				durationDayHourSeparator: $T 				calendarDurationDayHourSeparator: $T).	self		specificationAt: #universal		put: #(useNumericMonthDesignator 				showEraNameAfterDate 				dateAndTimeSeparator: ' @ ' 				timeOfDayPrefix: nil				use12HourFormat 				hourPadChar: nil 				hideSubsecondFraction				timeZoneSeparator: $ 				timeZoneElementSeparator: nil 				showStandardCalendarName).	self 		specificationAt: #verbose 		put: #(showDayOfWeekName 				useDayMonthYearOrder 				useMonthName 				yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator: $  $  $ 				showEraNameAfterDate 				padChar: nil				dateAndTimeSeparator: ' @ ' 				timeOfDayPrefix: nil				showTimeOfDay				use12HourFormat				showTimeOfDaySecondWithFraction				timeZoneSeparator: $ 				timeZoneElementSeparator: nil				showTimeZoneVerbosely				showNamesOfDurationElements				showNamesOfCalendarDurationElements				durationElementSeparator: $ 				calendarDurationElementSeparator: $ 				durationDayHourSeparator: $ 				calendarDurationDayHourSeparator: $ 				durationPadChar: nil				calendarDurationPadChar: nil).	self 		specificationAt: #vwTimestamp		put: #(confomToLocale: #'en_US'				showTimeOfDay				showTimeOfDaySecondWithFraction				hideTimeZone 				useMonthName 				useMonthDayYearOrder 				hideDayOfWeek				hideEraName 				hideStandardCalendarName 				datePadChar: nil 				yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator: $ $  ', '				timeOfDayPrefix: $  				dateAndTimeSeparator: nil				use24HourFormat				hourPadChar: nil				subSecondTimeMinPrecision: 3				dateAndTimeMaxPrecision: 3				subSecondDurationMaxPrecision: 6).</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring-dates</category><body package="Chronos-Printing" selector="datePadChar:">datePadChar: pad	self yearPadChar: pad monthPadChar: pad dayOfMonthPadChar: pad</body><body package="Chronos-Printing" selector="dateSeparator:">dateSeparator: aChar	self yearMonthSeparator: aChar monthDayOfMonthSeparator: aChar dayOfMonthYearSeparator: aChar</body><body package="Chronos-Printing" selector="hideDayOfDate">hideDayOfDate	self assertMutability.	dateAndTimeMaxPrecision := 		dateAndTimeMaxPrecision isInteger 			ifTrue: [#month]			ifFalse: 				[| index |				index := #(#all #minute #hour #day #month #year) indexOf: dateAndTimeMaxPrecision.				index &gt;= 5 ifTrue: [dateAndTimeMaxPrecision] ifFalse: [#month]]</body><body package="Chronos-Printing" selector="hideEraName">hideEraName	self assertMutability.	eraPolicy := nil</body><body package="Chronos-Printing" selector="hideMonthOfDate">hideMonthOfDate	self assertMutability.	dateAndTimeMaxPrecision := #year</body><body package="Chronos-Printing" selector="showDateToTheDay"> showDateToTheDay	self assertMutability.	dateAndTimeMaxPrecision := #day</body><body package="Chronos-Printing" selector="showDateToTheMonth"> showDateToTheMonth	self assertMutability.	dateAndTimeMaxPrecision := #month</body><body package="Chronos-Printing" selector="showDateToTheYear"> showDateToTheYear	self assertMutability.	dateAndTimeMaxPrecision := #year</body><body package="Chronos-Printing" selector="showEraName">showEraName	"Deprecated. Use #showEraNameAfterDate or #showEraNameBeforeDate"	self showEraNameAfterDate</body><body package="Chronos-Printing" selector="showEraNameAfterDate">showEraNameAfterDate	"NOTE: The formal convention for most calendars is to put the era designator AFTER the rest of the date--the Gregorian/Julian calendars (in English speaking countries, but not universally) being the major exceptions.  However, in actual modern English usage the 'AD' or 'BC' much more frequently follows the date.  And in the case of the revisionist 'CE' and 'BCE' era designations (which were invented and insisted upon by Jewish Talmudists originally,) putting the designation after the date is also the formally-correct placement.  Consequently, for calendar polymorphism/symmetry, for year-month-day order independence, to match actual modern usage, and for compatibility with international standards (such as ISO 8601,) it is recommended to put the era designation after the date, instead of using the formal English placement rule, which is no longer commonly observed, and would not be appropriate for 'CE'/'BCE,' for some year-month-day orderings, for many non-English speakers, nor for most other calendars."		self assertMutability.	eraPolicy := #showEraNameAfterDate</body><body package="Chronos-Printing" selector="showEraNameBeforeDate">showEraNameBeforeDate	"NOTE: The formal convention for most calendars is to put the era designator AFTER the rest of the date--the Gregorian/Julian calendars (in English speaking countries, but not universally) being the major exceptions.  However, in actual modern English usage the 'AD' or 'BC' much more frequently follows the date.  And in the case of the revisionist 'CE' and 'BCE' era designations (which were invented and insisted upon by Jewish Talmudists originally,) putting the designation after the date is also the formally-correct placement.  Consequently, for calendar polymorphism/symmetry, for year-month-day order independence, to match actual modern usage, and for compatibility with international standards (such as ISO 8601,) it is recommended to put the era designation after the date, instead of using the formal English placement rule, which is no longer commonly observed, and would not be appropriate for 'CE'/'BCE,' for some year-month-day orderings, for many non-English speakers, nor for most other calendars."		self assertMutability.	eraPolicy := #showEraNameBeforeDate</body><body package="Chronos-Printing" selector="standardCalendarRegistrationKey:">standardCalendarRegistrationKey: aSymbol	"Set the registration key of the receiver's standard calendar (which is the calendar whose name may optionally be hidden when printing a calendrical value.)  If set to nil, the receiver will always show the calendar name."	self assertMutability.	standardCalendarRegistrationKey := aSymbol</body><body package="Chronos-Printing" selector="yearMonthSeparator:monthDayOfMonthSeparator:dayOfMonthYearSeparator:">yearMonthSeparator: ymSep monthDayOfMonthSeparator: mdSep dayOfMonthYearSeparator: dySep	self assertMutability.	yearMonthSep := ymSep.	monthDaySep := mdSep.	dayYearSep := dySep</body><body package="Chronos-Printing" selector="yearPadChar:monthPadChar:dayOfMonthPadChar:">yearPadChar: yChar monthPadChar: mChar dayOfMonthPadChar: dChar	self assertMutability.	yearPadChar := yChar.	monthPadChar := mChar.	dayOfMonthPadChar := dChar.</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>accessing--punctuation characters</category><body package="Chronos-Printing" selector="calendarDurationDayHourSeparator">calendarDurationDayHourSeparator	^calendarDurationDayHourSep</body><body package="Chronos-Printing" selector="calendarDurationElementSeparator">calendarDurationElementSeparator	^calendarDurationElementSep</body><body package="Chronos-Printing" selector="calendarDurationPadChar">calendarDurationPadChar	^calendarDurationPadChar</body><body package="Chronos-Printing" selector="dateAndTimeSeparator">dateAndTimeSeparator	^dateAndTimeSeparator</body><body package="Chronos-Printing" selector="dayOfMonthPadChar">dayOfMonthPadChar	^dayOfMonthPadChar</body><body package="Chronos-Printing" selector="dayYearSeparator">dayYearSeparator	^dayYearSep</body><body package="Chronos-Printing" selector="decimalPointChar">decimalPointChar	^decimalPointChar</body><body package="Chronos-Printing" selector="durationDayHourSeparator">durationDayHourSeparator	^durationDayHourSep</body><body package="Chronos-Printing" selector="durationElementSeparator">durationElementSeparator	^durationElementSep</body><body package="Chronos-Printing" selector="durationPadChar">durationPadChar	^durationPadChar</body><body package="Chronos-Printing" selector="hourMinuteSecondSeparator">hourMinuteSecondSeparator	^hourMinuteSecondSeparator</body><body package="Chronos-Printing" selector="hourPadChar">hourPadChar	^hourPadChar</body><body package="Chronos-Printing" selector="monthDaySeparator">monthDaySeparator	^monthDaySep</body><body package="Chronos-Printing" selector="monthPadChar">monthPadChar	^monthPadChar</body><body package="Chronos-Printing" selector="timeOfDayPrefix">timeOfDayPrefix	^timeOfDayPrefix</body><body package="Chronos-Printing" selector="timeZoneElementSeparator">timeZoneElementSeparator	^timeZoneElementSeparator</body><body package="Chronos-Printing" selector="timeZoneSeparator">timeZoneSeparator	^timeZoneSeparator</body><body package="Chronos-Printing" selector="yearMonthSeparator">yearMonthSeparator	^yearMonthSep</body><body package="Chronos-Printing" selector="yearPadChar">yearPadChar	^yearPadChar</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>printing-time zones</category><body package="Chronos-Printing" selector="printAbbreviationOfTimeZoneFrom:on:">printAbbreviationOfTimeZoneFrom: aTimepoint on: stream 	self 		printAbbreviationOfTimeZoneFrom: aTimepoint		prefix: timeZoneSeparator		on: stream</body><body package="Chronos-Printing" selector="printKeyOfTimeZoneFrom:on:">printKeyOfTimeZoneFrom: aTimepoint on: stream 	self 		printKeyOfTimeZoneFrom: aTimepoint		prefix: timeZoneSeparator		on: stream</body><body package="Chronos-Printing" selector="printNameOfTimeZoneFrom:on:">printNameOfTimeZoneFrom: aTimepoint on: stream 	self 		printNameOfTimeZoneFrom: aTimepoint		prefix: timeZoneSeparator		on: stream</body><body package="Chronos-Printing" selector="printTimeZoneFrom:on:">printTimeZoneFrom: aTimepoint on: stream 	timeZonePrintPolicy == nil 		ifTrue: [super printTimeZoneFrom: aTimepoint on: stream]		ifFalse: 			[self 				perform: timeZonePrintPolicy				with: aTimepoint				with: stream]</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>testing</category><body package="Chronos-Printing" selector="canConformToLocale">canConformToLocale	^true</body><body package="Chronos-Printing" selector="hidesDayOfWeek">hidesDayOfWeek	^dayOfWeekPolicy == nil</body><body package="Chronos-Printing" selector="hidesTimeZone">hidesTimeZone	^timeZonePrintPolicy == nil</body><body package="Chronos-Printing" selector="showsNameOfEra">showsNameOfEra	^eraPolicy notNil</body><body package="Chronos-Printing" selector="showsNamesOfCalendarDurationElements">showsNamesOfCalendarDurationElements	^showNamesOfCalendarDurationElements</body><body package="Chronos-Printing" selector="showsNamesOfDurationElements">showsNamesOfDurationElements	^showNamesOfDurationElements</body><body package="Chronos-Printing" selector="suppressesZeroValuedCalendarDurationElements">suppressesZeroValuedCalendarDurationElements	^suppressZeroValuedCalendarDurationElements</body><body package="Chronos-Printing" selector="suppressesZeroValuedDurationElements">suppressesZeroValuedDurationElements	^suppressZeroValuedDurationElements</body><body package="Chronos-Printing" selector="uses24HourClock">uses24HourClock	^hour24</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring-dates-day of week</category><body package="Chronos-Printing" selector="hideDayOfWeek">hideDayOfWeek	self assertMutability.	dayOfWeekPolicy := nil</body><body package="Chronos-Printing" selector="showDayOfWeekAbbreviation">showDayOfWeekAbbreviation	self assertMutability.	dayOfWeekPolicy := #printAbbreviationAt:on:</body><body package="Chronos-Printing" selector="showDayOfWeekName">showDayOfWeekName	self assertMutability.	dayOfWeekPolicy := #printProperNameAt:on:</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring-time of day</category><body package="Chronos-Printing" selector="hideSubsecondFraction"> hideSubsecondFraction	self assertMutability.	dateAndTimeMaxPrecision := 0</body><body package="Chronos-Printing" selector="hideTimeOfDay">hideTimeOfDay	self hideTimeOfDayHour</body><body package="Chronos-Printing" selector="hideTimeOfDayHour">hideTimeOfDayHour	self assertMutability.	dateAndTimeMaxPrecision := 		dateAndTimeMaxPrecision isInteger 			ifTrue: [#day]			ifFalse: 				[| index |				index := #(#all #minute #hour #day #month #year) indexOf: dateAndTimeMaxPrecision.				index &gt;= 4 ifTrue: [dateAndTimeMaxPrecision] ifFalse: [#day]]</body><body package="Chronos-Printing" selector="hideTimeOfDayMinute">hideTimeOfDayMinute	self assertMutability.	dateAndTimeMaxPrecision := 		dateAndTimeMaxPrecision isInteger 			ifTrue: [#hour]			ifFalse: 				[| index |				index := #(#all #minute #hour #day #month #year) indexOf: dateAndTimeMaxPrecision.				index &gt;= 3 ifTrue: [dateAndTimeMaxPrecision] ifFalse: [#hour]]</body><body package="Chronos-Printing" selector="hideTimeOfDaySecond">hideTimeOfDaySecond	self assertMutability.	dateAndTimeMaxPrecision := 		dateAndTimeMaxPrecision isInteger 			ifTrue: [#minute]			ifFalse: 				[dateAndTimeMaxPrecision == #all 					ifTrue: [#minute]					ifFalse: [dateAndTimeMaxPrecision]]</body><body package="Chronos-Printing" selector="hideTimeZone">hideTimeZone	self assertMutability.	timeZonePrintPolicy := nil</body><body package="Chronos-Printing" selector="hourMinuteSecondSeparator:">hourMinuteSecondSeparator: aCharacterArrayOrCharacter 	self assertMutability.	hourMinuteSecondSeparator := aCharacterArrayOrCharacter</body><body package="Chronos-Printing" selector="hourPadChar:">hourPadChar: pad	self assertMutability.	hourPadChar := pad</body><body package="Chronos-Printing" selector="showTimeOfDay">showTimeOfDay	(dateAndTimeMaxPrecision isInteger or: [dateAndTimeMaxPrecision == #all])		ifFalse: [self dateAndTimeMaxPrecision: #all]</body><body package="Chronos-Printing" selector="showTimeOfDaySecondWithFraction"> showTimeOfDaySecondWithFraction	self assertMutability.	dateAndTimeMaxPrecision := #all</body><body package="Chronos-Printing" selector="showTimeOfDaySecondWithoutFraction"> showTimeOfDaySecondWithoutFraction	self assertMutability.	dateAndTimeMaxPrecision := 0</body><body package="Chronos-Printing" selector="showTimeOfDayToTheHour"> showTimeOfDayToTheHour	self assertMutability.	dateAndTimeMaxPrecision := #hour</body><body package="Chronos-Printing" selector="showTimeOfDayToTheMinute"> showTimeOfDayToTheMinute	self assertMutability.	dateAndTimeMaxPrecision := #minute</body><body package="Chronos-Printing" selector="showTimeZoneAbbreviation">showTimeZoneAbbreviation	self assertMutability.	timeZonePrintPolicy := #printAbbreviationOfTimeZoneFrom:on:</body><body package="Chronos-Printing" selector="showTimeZoneKey">showTimeZoneKey	self assertMutability.	timeZonePrintPolicy := #printKeyOfTimeZoneFrom:on:</body><body package="Chronos-Printing" selector="showTimeZoneName">showTimeZoneName	self assertMutability.	timeZonePrintPolicy := #printNameOfTimeZoneFrom:on:</body><body package="Chronos-Printing" selector="showTimeZoneOffset">showTimeZoneOffset	self assertMutability.	timeZonePrintPolicy := #printOffsetOfTimeZoneFrom:on:</body><body package="Chronos-Printing" selector="showTimeZoneVerbosely">showTimeZoneVerbosely	self assertMutability.	timeZonePrintPolicy := #printTimeZoneVerboselyFrom:on:</body><body package="Chronos-Printing" selector="subSecondTimeMinPrecision:">subSecondTimeMinPrecision: anInt	self assertMutability.	subSecondTimeMinPrecision := anInt max: 0</body><body package="Chronos-Printing" selector="subSecondTimePrecision:">subSecondTimePrecision: anInt	self subSecondTimeMinPrecision: anInt.	self dateAndTimeMaxPrecision: anInt.</body><body package="Chronos-Printing" selector="timeOfDayPrefix:">timeOfDayPrefix: aCharOrStringOrNil	self assertMutability.	timeOfDayPrefix := aCharOrStringOrNil</body><body package="Chronos-Printing" selector="timeZoneElementSeparator:">timeZoneElementSeparator: aCharOrString	self assertMutability.	timeZoneElementSeparator := aCharOrString</body><body package="Chronos-Printing" selector="timeZoneSeparator:">timeZoneSeparator: aCharOrStringOrNil	self assertMutability.	timeZoneSeparator := aCharOrStringOrNil</body><body package="Chronos-Printing" selector="use12HourFormat">use12HourFormat	self assertMutability.	hour24 := false</body><body package="Chronos-Printing" selector="use24HourFormat">use24HourFormat	self assertMutability.	hour24 := true</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>accessing</category><body package="Chronos-Printing" selector="dateAndTimeMaxPrecision">dateAndTimeMaxPrecision	^dateAndTimeMaxPrecision</body><body package="Chronos-Printing" selector="dateAndTimeOrder">dateAndTimeOrder	^dateAndTimeOrder == nil ifTrue: [#useDateBeforeTimeOrder] ifFalse: [dateAndTimeOrder]</body><body package="Chronos-Printing" selector="effectiveLocale">effectiveLocale	^effectiveLocaleKey == nil 		ifTrue: [ChronosLocale default]		ifFalse: 			[ChronosLocale at: effectiveLocaleKey ifAbsent: [ChronosLocale default]]</body><body package="Chronos-Printing" selector="eraPolicy">eraPolicy	^eraPolicy</body><body package="Chronos-Printing" selector="standardCalendarRegistrationKey">standardCalendarRegistrationKey	"Answer the registration key of the receiver's standard calendar (which is the calendar whose name may optionally be hidden when printing a calendrical value.)"	^standardCalendarRegistrationKey</body><body package="Chronos-Printing" selector="subSecondDurationMaxPrecision">subSecondDurationMaxPrecision	^subSecondDurationMaxPrecision</body><body package="Chronos-Printing" selector="subSecondTimeMinPrecision">subSecondTimeMinPrecision	^subSecondTimeMinPrecision</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring-durations</category><body package="Chronos-Printing" selector="calendarDurationDayHourSeparator:">calendarDurationDayHourSeparator: aCharOrCharArray	self assertMutability.	calendarDurationDayHourSep := aCharOrCharArray</body><body package="Chronos-Printing" selector="calendarDurationElementSeparator:">calendarDurationElementSeparator: aCharOrCharArray	self assertMutability.	calendarDurationElementSep := aCharOrCharArray</body><body package="Chronos-Printing" selector="calendarDurationPadChar:">calendarDurationPadChar: pad	self assertMutability.	calendarDurationPadChar := pad</body><body package="Chronos-Printing" selector="durationDayHourSeparator:">durationDayHourSeparator: aCharOrCharArray	self assertMutability.	durationDayHourSep := aCharOrCharArray</body><body package="Chronos-Printing" selector="durationElementSeparator:">durationElementSeparator: aCharOrCharArray	self assertMutability.	durationElementSep := aCharOrCharArray</body><body package="Chronos-Printing" selector="durationPadChar:">durationPadChar: pad	self assertMutability.	durationPadChar := pad</body><body package="Chronos-Printing" selector="hideNamesOfCalendarDurationElements">hideNamesOfCalendarDurationElements	self assertMutability.	showNamesOfCalendarDurationElements := false</body><body package="Chronos-Printing" selector="hideNamesOfDurationElements">hideNamesOfDurationElements	self assertMutability.	showNamesOfDurationElements := false</body><body package="Chronos-Printing" selector="hideZeroValuedCalendarDurationElements">hideZeroValuedCalendarDurationElements	self assertMutability.	suppressZeroValuedCalendarDurationElements := true</body><body package="Chronos-Printing" selector="hideZeroValuedDurationElements">hideZeroValuedDurationElements	self assertMutability.	suppressZeroValuedDurationElements := true</body><body package="Chronos-Printing" selector="showNamesOfCalendarDurationElements">showNamesOfCalendarDurationElements	self assertMutability.	showNamesOfCalendarDurationElements := true</body><body package="Chronos-Printing" selector="showNamesOfDurationElements">showNamesOfDurationElements	self assertMutability.	showNamesOfDurationElements := true</body><body package="Chronos-Printing" selector="showZeroValuedCalendarDurationElements">showZeroValuedCalendarDurationElements	self assertMutability.	suppressZeroValuedCalendarDurationElements := false</body><body package="Chronos-Printing" selector="showZeroValuedDurationElements">showZeroValuedDurationElements	self assertMutability.	suppressZeroValuedDurationElements := false</body><body package="Chronos-Printing" selector="subSecondDurationMaxPrecision:">subSecondDurationMaxPrecision: anIntOrTheSymbolAll 	self assertMutability.	subSecondDurationMaxPrecision := anIntOrTheSymbolAll isInteger 				ifTrue: [anIntOrTheSymbolAll max: 0]				ifFalse: [anIntOrTheSymbolAll asSymbol]</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring</category><body package="Chronos-Printing" selector="dateAndTimeMaxPrecision:">dateAndTimeMaxPrecision: anIntOrSymbol 	"ConfigurableChronosPrintPolicy newConfigurable dateAndTimeMaxPrecision: #foo" 	self assertMutability.	anIntOrSymbol isInteger 		ifTrue: [dateAndTimeMaxPrecision := anIntOrSymbol max: 0]		ifFalse: 			[| newSymbol |			newSymbol := anIntOrSymbol asSymbol.			(#(all minute hour day month year) includes: newSymbol) ifFalse: [self signalError: 'dateAndTimeMaxPrecision must be either A) an integer =&gt; 0 or B) one of the following Symbols: #all #minute #hour #day #month #year'].			dateAndTimeMaxPrecision := newSymbol]</body><body package="Chronos-Printing" selector="dateAndTimeSeparator:">dateAndTimeSeparator: aCharOrString	self assertMutability.	dateAndTimeSeparator := aCharOrString</body><body package="Chronos-Printing" selector="decimalPointChar:">decimalPointChar: aChar	self assertMutability.	decimalPointChar := aChar</body><body package="Chronos-Printing" selector="hideStandardCalendarName">hideStandardCalendarName	self standardCalendarRegistrationKey: self effectiveLocale standardCalendarRegistrationKey</body><body package="Chronos-Printing" selector="padChar:">padChar: pad	self hourPadChar: pad.	self datePadChar: pad</body><body package="Chronos-Printing" selector="showStandardCalendarName">showStandardCalendarName	self standardCalendarRegistrationKey: nil</body><body package="Chronos-Printing" selector="subSecondMaxPrecision:"> subSecondMaxPrecision: anInt	self dateAndTimeMaxPrecision: anInt.	self subSecondDurationMaxPrecision: anInt</body><body package="Chronos-Printing" selector="useDateBeforeTimeOrder">useDateBeforeTimeOrder	self assertMutability.	dateAndTimeOrder := #useDateBeforeTimeOrder</body><body package="Chronos-Printing" selector="useTimeBeforeDateOrder">useTimeBeforeDateOrder	self assertMutability.	dateAndTimeOrder := #useTimeBeforeDateOrder</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>printing-dates-elements</category><body package="Chronos-Printing" selector="printCalendarElementsFrom:maxPrecision:on:">printCalendarElementsFrom: aDate maxPrecision: maxPrecision on: stream 	self perform: datePolicy with: aDate with: maxPrecision with: stream.</body><body package="Chronos-Printing" selector="printDayMonthYearFrom:maxPrecision:dayMonthSeparator:monthYearSeparator:on:">printDayMonthYearFrom: aDate maxPrecision: maxPrecision  dayMonthSeparator: mdSep monthYearSeparator: ymSep on: stream 	| mp |	mp := 		maxPrecision isInteger			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	(mp &lt; 6)		ifTrue:			[(mp &lt; 5)				ifTrue:					[self printDayOfMonthFrom: aDate on: stream.					self printSeparator: mdSep on: stream].			self printMonthFrom: aDate on: stream.			self printSeparator: ymSep on: stream].	self printYear: aDate year on: stream</body><body package="Chronos-Printing" selector="printDayOfWeekFrom:on:">printDayOfWeekFrom: aDate on: stream 	dayOfWeekPolicy == nil 		ifTrue: [super printDayOfWeekFrom: aDate on: stream]		ifFalse: 			[self 				perform: dayOfWeekPolicy				with: aDate dayOfWeekKey				with: stream]</body><body package="Chronos-Printing" selector="printMonthFrom:on:">printMonthFrom: date on: stream 	self perform: monthPolicy with: date with: stream</body><body package="Chronos-Printing" selector="printYear:on:">printYear: year on: stream 	self perform: yearPolicy with: year with: stream</body><body package="Chronos-Printing" selector="printYearDayMonthFrom:maxPrecision:yearDaySeparator:dayMonthSeparator:on:">printYearDayMonthFrom: aDate maxPrecision: maxPrecision yearDaySeparator: dySep dayMonthSeparator: mdSep on: stream 	| mp |	mp := 		maxPrecision isInteger 			ifTrue: [maxPrecision negated]			ifFalse: [#(#all #minute #hour #day #month #year) indexOf: maxPrecision].	self printYear: aDate year on: stream.	(mp &lt; 6)		ifTrue:			[self printSeparator: dySep on: stream.			(mp &lt; 5)				ifTrue:					[self printDayOfMonthFrom: aDate on: stream.					self printSeparator: mdSep on: stream].			self printMonthFrom: aDate on: stream]</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>printing-time of day-elements</category><body package="Chronos-Printing" selector="printHour12:on:">printHour12: h24 on: stream	self printHour12: h24 padWith: hourPadChar on: stream</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring-dates-month format</category><body package="Chronos-Printing" selector="useMonthAbbreviation">useMonthAbbreviation	self assertMutability.	monthPolicy := #printMonthAbbreviationFrom:on:</body><body package="Chronos-Printing" selector="useMonthName">useMonthName	self assertMutability.	monthPolicy := #printMonthNameFrom:on:</body><body package="Chronos-Printing" selector="useMonthOrdinal">useMonthOrdinal	self assertMutability.	monthPolicy := #printMonthOrdinalFrom:on:</body><body package="Chronos-Printing" selector="useNumericMonthDesignator">useNumericMonthDesignator	self assertMutability.	monthPolicy := #printNumericMonthDesignatorFrom:on:</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring-dates-year format</category><body package="Chronos-Printing" selector="hideYears">hideYears	self assertMutability.	yearPolicy := #dontPrintYear:on:</body><body package="Chronos-Printing" selector="useFullDigitYears">useFullDigitYears	self assertMutability.	yearPolicy := #printFullYear:on:</body><body package="Chronos-Printing" selector="useTwoDigitYears">useTwoDigitYears	self assertMutability.	yearPolicy := #printTwoDigitYear:on:</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>initialize-release</category><body package="Chronos-Printing" selector="beANSIStandard">beANSIStandard	self assertMutability.	self standardCalendarRegistrationKey: GregorianCalendar registrationKey.	self hideDayOfWeek. 	self useDateBeforeTimeOrder.	self useFullDigitYears.	self useMonthOrdinal.	self useYearMonthDayOrder.	self dateSeparator: $-.	self padChar: $0.	self hideEraName.	self dateAndTimeSeparator: nil.	self timeOfDayPrefix: $T.	self showTimeOfDay.	self use24HourFormat.	self hourMinuteSecondSeparator: $:.	self decimalPointChar: $..	self subSecondTimeMinPrecision: 0.	self dateAndTimeMaxPrecision: #all.	self showTimeZoneOffset.	self timeZoneSeparator: nil.	self timeZoneElementSeparator: $:.	self durationDayHourSeparator: $:.	self calendarDurationDayHourSeparator: $T.	self durationElementSeparator: $:.	self calendarDurationElementSeparator: nil.	self durationPadChar: $0.	self calendarDurationPadChar: nil.	self hideNamesOfDurationElements.	self hideNamesOfCalendarDurationElements.	self showZeroValuedDurationElements.	self hideZeroValuedCalendarDurationElements.	self subSecondDurationMaxPrecision: #all.</body><body package="Chronos-Printing" selector="confomToLocale:">confomToLocale: aChronosLocale 	self assertMutability.	aChronosLocale == nil 		ifTrue: [effectiveLocaleKey := nil]		ifFalse: 			[| locale |			locale := ChronosLocale referencedBy: aChronosLocale.			registrationKey := locale registrationKey.			effectiveLocaleKey := locale registrationKey.			standardCalendarRegistrationKey := locale standardCalendarRegistrationKey.			self setPunctuationFromLocale: locale.			self setNotationalPoliciesFromLocale: locale.			self registerButIfPresent: [:collision | ]]</body><body package="Chronos-Printing" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	self beANSIStandard.</body><body package="Chronos-Printing" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	effectiveLocaleKey := (literalArray at: 3).	dayOfWeekPolicy := (literalArray at: 4).	dateAndTimeOrder := (literalArray at: 5).	datePolicy := (literalArray at: 6).	yearPolicy := (literalArray at: 7).	monthPolicy := (literalArray at: 8).	yearMonthSep := (literalArray at: 9).	monthDaySep := (literalArray at: 10).	dayYearSep := (literalArray at: 11).	yearPadChar := (literalArray at: 12).	monthPadChar := (literalArray at: 13).	dayOfMonthPadChar := (literalArray at: 14).	eraPolicy := (literalArray at: 15).	standardCalendarRegistrationKey := (literalArray at: 16).	hour24 := (literalArray at: 17).	dateAndTimeSeparator := (literalArray at: 18).	timeOfDayPrefix := (literalArray at: 19).	hourMinuteSecondSeparator := (literalArray at: 20).	hourPadChar := (literalArray at: 21).	decimalPointChar := (literalArray at: 22).	subSecondTimeMinPrecision := (literalArray at: 23).	dateAndTimeMaxPrecision := (literalArray at: 24).	timeZonePrintPolicy := (literalArray at: 25).	timeZoneSeparator := (literalArray at: 26).	timeZoneElementSeparator := (literalArray at: 27).	showNamesOfDurationElements := (literalArray at: 28).	showNamesOfCalendarDurationElements := (literalArray at: 29).	suppressZeroValuedDurationElements := (literalArray at: 30).	suppressZeroValuedCalendarDurationElements := (literalArray at: 31).	durationElementSep := (literalArray at: 32).	calendarDurationElementSep := (literalArray at: 33).	durationDayHourSep := (literalArray at: 34).	calendarDurationDayHourSep := (literalArray at: 35).	durationPadChar := (literalArray at: 36).	calendarDurationPadChar := (literalArray at: 37).	subSecondDurationMaxPrecision := (literalArray at: 38).</body><body package="Chronos-Printing" selector="setNotationalPoliciesFromLocale:">setNotationalPoliciesFromLocale: aChronosLocale	self assertMutability.	self 		perform: aChronosLocale dateAndTimeOrder;		perform: aChronosLocale datePolicy;		perform: aChronosLocale monthPolicy;		perform: aChronosLocale yearPolicy;		perform: aChronosLocale dayOfWeekPolicy;		perform: aChronosLocale eraPolicy;		perform: aChronosLocale timeOfDayPolicy;		perform: aChronosLocale hourPolicy;		perform: aChronosLocale timeOfDaySubsecondPolicy;		perform: aChronosLocale timeZonePolicy;		perform: aChronosLocale durationElementNamePolicy;		perform: aChronosLocale durationElementZeroValuePolicy;		perform: aChronosLocale calendarDurationElementNamePolicy;		perform: aChronosLocale calendarDurationElementZeroValuePolicy</body><body package="Chronos-Printing" selector="setPunctuationFromLocale:">setPunctuationFromLocale: aChronosLocale	self assertMutability.	decimalPointChar := aChronosLocale decimalPointChar.	yearPadChar := aChronosLocale yearPadChar.	monthPadChar := aChronosLocale monthPadChar.	dayOfMonthPadChar := aChronosLocale dayOfMonthPadChar.	yearMonthSep := aChronosLocale yearMonthSeparator.	monthDaySep := aChronosLocale monthDayOfMonthSeparator.	dayYearSep := aChronosLocale dayOfMonthYearSeparator.	dateAndTimeSeparator := aChronosLocale dateAndTimeSeparator.	timeOfDayPrefix := aChronosLocale timeOfDayPrefix.	hourPadChar := aChronosLocale hourPadChar.	hourMinuteSecondSeparator := aChronosLocale hourMinuteSecondSeparator.	timeZoneSeparator := aChronosLocale timeZoneSeparator.	timeZoneElementSeparator := aChronosLocale timeZoneElementSeparator.	durationElementSep := aChronosLocale durationElementSeparator.	calendarDurationElementSep := aChronosLocale calendarDurationElementSeparator.	durationDayHourSep := aChronosLocale durationDayHourSeparator.	calendarDurationDayHourSep := aChronosLocale calendarDurationDayHourSeparator.	durationPadChar := aChronosLocale durationPadChar.	calendarDurationPadChar := aChronosLocale calendarDurationPadChar.</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>printing-durations</category><body package="Chronos-Printing" selector="printZeroDurationPadWith:appendElementNames:on:">printZeroDurationPadWith: padChar appendElementNames: showNames on: stream 	showNames 		ifTrue: 			[ChronosFunction 				print: 0				paddedWith: padChar				to: 2				on: stream.			stream space.			self 				printTemporalUnitName: #second				value: 0				on: stream]		ifFalse: 			[super 				printZeroDurationPadWith: padChar				appendElementNames: showNames				on: stream]</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>configuring-dates-form/content</category><body package="Chronos-Printing" selector="showDateAsDaysSinceEpoch">showDateAsDaysSinceEpoch	self assertMutability.	datePolicy := #printDaysSinceEpochFrom:maxPrecision:on:</body><body package="Chronos-Printing" selector="showDateAsGregorianDay">showDateAsGregorianDay	self assertMutability.	datePolicy := #printGregorianDayFrom:maxPrecision:on:</body><body package="Chronos-Printing" selector="showDateAsJulianDay">showDateAsJulianDay	self assertMutability.	datePolicy := #printJulianDayFrom:maxPrecision:on:.</body><body package="Chronos-Printing" selector="useDayMonthYearOrder">useDayMonthYearOrder	self assertMutability.	datePolicy := #printDayMonthYearFrom:maxPrecision:on:</body><body package="Chronos-Printing" selector="useISOWeekOfYearDayOfWeek">useISOWeekOfYearDayOfWeek	self assertMutability.	datePolicy := #printISOWeekOfYearDayOfWeekFrom:maxPrecision:on:</body><body package="Chronos-Printing" selector="useMonthDayYearOrder">useMonthDayYearOrder	self assertMutability.	datePolicy := #printMonthDayYearFrom:maxPrecision:on:</body><body package="Chronos-Printing" selector="useOrdinalDate">useOrdinalDate	self assertMutability.	datePolicy := #printOrdinalDateFrom:maxPrecision:on:</body><body package="Chronos-Printing" selector="useYearMonthDayOrder">useYearMonthDayOrder	self assertMutability.	datePolicy := #printYearMonthDayFrom:maxPrecision:on:</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>deprecated</category><body package="Chronos-Printing" selector="hideSeconds">hideSeconds	self hideTimeOfDaySecond</body><body package="Chronos-Printing" selector="showSecondsWithFraction"> showSecondsWithFraction	self showTimeOfDaySecondWithFraction</body><body package="Chronos-Printing" selector="showSecondsWithoutFraction"> showSecondsWithoutFraction	self showTimeOfDaySecondWithoutFraction</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy</class-id> <category>private</category><body package="Chronos-Printing" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: effectiveLocaleKey;		nextPut: dayOfWeekPolicy;		nextPut: dateAndTimeOrder;		nextPut: datePolicy;		nextPut: yearPolicy;		nextPut: monthPolicy;		nextPut: yearMonthSep;		nextPut: monthDaySep;		nextPut: dayYearSep;		nextPut: yearPadChar;		nextPut: monthPadChar;		nextPut: dayOfMonthPadChar;		nextPut: eraPolicy;		nextPut: standardCalendarRegistrationKey;		nextPut: hour24;		nextPut: dateAndTimeSeparator;		nextPut: timeOfDayPrefix;		nextPut: hourMinuteSecondSeparator;		nextPut: hourPadChar;		nextPut: decimalPointChar;		nextPut: subSecondTimeMinPrecision;		nextPut: dateAndTimeMaxPrecision;		nextPut: timeZonePrintPolicy;		nextPut: timeZoneSeparator;		nextPut: timeZoneElementSeparator;		nextPut: showNamesOfDurationElements;		nextPut: showNamesOfCalendarDurationElements;		nextPut: suppressZeroValuedDurationElements;		nextPut: suppressZeroValuedCalendarDurationElements;		nextPut: durationElementSep;		nextPut: calendarDurationElementSep;		nextPut: durationDayHourSep;		nextPut: calendarDurationDayHourSep;		nextPut: durationPadChar;		nextPut: calendarDurationPadChar;		nextPut: subSecondDurationMaxPrecision</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy class</class-id> <category>accessing</category><body package="Chronos-Printing" selector="default">default	^ChronosLocale default temporalPrintPolicy</body></methods><methods><class-id>Chronos.ConfigurableChronosPrintPolicy class</class-id> <category>private</category><body package="Chronos-Printing" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body><body package="Chronos-Printing" selector="newRegistry">newRegistry	^self superclass registry</body></methods><methods><class-id>Passport.UrlPathFacade</class-id> <category>printing services</category><body package="Passport-Kernel" selector="encodeString:isInQuery:on:">encodeString: aString isInQuery: isInQuery on: stream 	aString do: 			[:ch | 			(self isTransparentChar: ch) 				ifTrue: [stream nextPut: ch]				ifFalse: 					[(isInQuery and: [ch = Character space]) 						ifTrue: [stream nextPut: $+]						ifFalse: 							[stream nextPut: $%.							ch codePoint printOn: stream base: 16]]]</body><body package="Passport-Kernel" selector="encodeString:on:">encodeString: aString on: stream 	self encodeString: aString isInQuery: false on: stream</body><body package="Passport-Kernel" selector="encodingOfString:">encodingOfString: aString	"UrlPathFacade new encodingOfString: 'Hello, world! / and burn?'"	| stream |	stream := aString copy writeStream.	self encodeString: aString on: stream.	^stream contents</body><body package="Passport-Kernel" selector="printPathnameOf:on:">printPathnameOf: aResourcePath on: stream 	aResourcePath pathnameIsEmpty 		ifFalse: 			[aResourcePath pathname 				printOn: stream				usingSeparator: self pathnameSeparator				andTransformer: [:component | self encodingOfString: component]]</body></methods><methods><class-id>Passport.UrlPathFacade</class-id> <category>testing</category><body package="Passport-Kernel" selector="syntaxPermitsPort">syntaxPermitsPort	^true</body><body package="Passport-Kernel" selector="syntaxPermitsProtocol">syntaxPermitsProtocol	^true</body><body package="Passport-Kernel" selector="syntaxRequiresHostname">syntaxRequiresHostname	^true</body></methods><methods><class-id>Passport.UrlPathFacade</class-id> <category>queries</category><body package="Passport-Kernel" selector="isTransparentChar:">isTransparentChar: ch	^TransparentCharSet includes: ch</body></methods><methods><class-id>Passport.UrlPathFacade</class-id> <category>conversion services</category><body package="Passport-Kernel" selector="constructResourcePathFromNativeResourceID:">constructResourcePathFromNativeResourceID: aNativeResourceID	"Construct and answer a ResourcePath that identifies the same resource (e.g, a file) as does &lt;aNativeResourceID&gt; (where &lt;aNativeResourceID&gt; is an object canonically used by the host Smalltalk implementation to name/identify external/persistent/remote resources;) in most Smalltalk implementations such an object would be a String.)"	^ResourcePath 		fromString: aNativeResourceID asString 		withContext: self resourcePathContext</body><body package="Passport-Kernel" selector="constructResourcePathFromStream:">constructResourcePathFromStream: stream	"Construct and answer a ResourcePath that identifies the same resource (e.g., a file) as does the characters remaining in &lt;aStream&gt; (where those characters are assumed to specify a pathname to a resource with the same syntax as would be used by the host Smalltalk environment.)"	| slashCount rp index pathname component |	rp := self newResourcePath.	slashCount := 0.	(stream peekFor: $/) ifTrue: [slashCount := slashCount + 1].	(stream peekFor: $/) ifTrue: [slashCount := slashCount + 1].	slashCount = 2 ifTrue: [self parseAuthorityFrom: stream into: rp].	index := 0.	pathname := UtilityFunction nextFrom: stream until: [:ch | (index := #($? $#) indexOf: ch ifAbsent: [0]) &gt; 0].	pathname := Pathname readFrom: pathname readStream separator: $/ transformer: [:segment | self decodeStringFrom: segment readStream].	slashCount &gt; 0 		ifTrue: 			[pathname componentCount &gt; 0				ifTrue:					[component := pathname componentAt: 1.					(component size &gt; 0 and: [component last = $:]) 						ifTrue: 							[rp setNamespace: component.							pathname := pathname suffixFrom: 2]						ifFalse: [rp setNamespace: self rootDirectoryMetavalueString]]				ifFalse: [rp setNamespace: self rootDirectoryMetavalueString]].	rp setPathname: pathname.	index &gt; 0 ifTrue: [self parseQueryStringAndFragmentFrom: stream into: rp].	^rp beImmutable</body><body package="Passport-Kernel" selector="constructResourcePathFromString:">constructResourcePathFromString: aString	"Construct and answer a ResourcePath that identifies the same resource (e.g., a file) as does &lt;aString&gt; (where &lt;aString&gt; is a pathname to a resource with the same syntax as would be used by the host Smalltalk environment.)"	^self constructResourcePathFromStream: aString readStream</body><body package="Passport-Kernel" selector="decodeFrom:isInQuery:onto:">decodeFrom: readStream isInQuery: isInQuery onto: writeStream 	| ch |	[readStream atEnd] whileFalse: 			[(readStream peekFor: $%) 				ifTrue: 					[writeStream nextPut: 						(Character codePoint: readStream next digitValue * 16 + readStream next digitValue)]				ifFalse: 					[isInQuery 						ifTrue: 							[ch := readStream next.							ch = $+								ifTrue: [writeStream space]								ifFalse: [writeStream nextPut: ch]]						ifFalse: [writeStream nextPut: readStream next]]]</body><body package="Passport-Kernel" selector="decodeStringFrom:">decodeStringFrom: readStream	"UrlPathFacade new decodeStringFrom: 'A%20B' readStream"	| writeStream |	writeStream := (String new: 32) writeStream.	self decodeFrom: readStream isInQuery: false onto: writeStream.	^writeStream contents</body><body package="Passport-Kernel" selector="decodeStringInQueryFrom:">decodeStringInQueryFrom: readStream	"UrlPathFacade new decodeStringInQueryFrom: 'A+B' readStream"	| writeStream |	writeStream := (String new: 32) writeStream.	self decodeFrom: readStream isInQuery: true onto: writeStream.	^writeStream contents</body><body package="Passport-Kernel" selector="parseAuthorityFrom:into:">parseAuthorityFrom: stream into: aResourcePath 	| port index string1 string2 |	port := nil.	index := 0.	string1 := UtilityFunction nextFrom: stream until: [:ch | (index := #($/ $: $@) indexOf: ch ifAbsent: [0]) &gt; 0].	stream next.	index = 1 		ifTrue: [aResourcePath setHostname: string1]		ifFalse: 			[index = 2 				ifTrue: 					[string2 := UtilityFunction nextFrom: stream until: [:ch | (index := #($/ $@) indexOf: ch ifAbsent: [0]) &gt; 0].					stream next.					index = 1 						ifTrue: 							[aResourcePath setHostname: string1.							port := string2 asNumber]						ifFalse: 							[aResourcePath 								setUser: (self decodeStringFrom: string1 readStream);								setPassword: (self decodeStringFrom: string2 readStream)]]				ifFalse: [aResourcePath setUser: (self decodeStringFrom: string1 readStream)].			port == nil 				ifTrue: 					[aResourcePath setHostname: (UtilityFunction nextFrom: stream until: [:ch | (index := #($/ $:) indexOf: ch ifAbsent: [0]) &gt; 0]).					stream next.					index = 2 ifTrue: [aResourcePath setPort: (stream upTo: $/) asNumber]]				ifFalse: [aResourcePath setPort: port]].</body><body package="Passport-Kernel" selector="parseQueryStringAndFragmentFrom:into:">parseQueryStringAndFragmentFrom: stream into: aResourcePath 	| continue index |	(stream peekFor: $?) 		ifTrue: 			[continue := stream atEnd not.			[continue] whileTrue: 					[aResourcePath 						addQueryAssociation: 							(self decodeStringInQueryFrom: (stream upTo: $=) readStream)							-&gt; (self decodeStringInQueryFrom: (UtilityFunction nextFrom: stream										until: [:ch | (index := #($&amp; $; $#) indexOf: ch ifAbsent: [0]) &gt; 0]) 											readStream).					stream atEnd 						ifTrue: [continue := false]						ifFalse: 							[stream next.							continue := stream atEnd not and: [index &lt; 3]]].			index = 3 				ifTrue: [aResourcePath setFragment: (self decodeStringFrom: stream)]]		ifFalse: 			[(stream peekFor: $#) 				ifTrue: [aResourcePath setFragment: (self decodeStringFrom: stream)]]</body></methods><methods><class-id>Passport.UrlPathFacade</class-id> <category>accessing</category><body package="Passport-Kernel" selector="defaultDirectoryPathnameString">defaultDirectoryPathnameString	"Answer a String that names/identifies the pathname of the external-file namespace relative to which non-absolute filenames will be interpreted.  In more conventional terminology, answer a String naming/identifying the actual full absolute pathname of the current default directory/folder.  It is acceptable, but not ideal, to answer a metavalue that serves as an indirect reference to the default directory (e.g., '.' on UNIX/Windows systems, and ':' on the Macintosh.) If not answering a metavalue, the answered String must start with the root directory of the current default volume/device (e.g., '/' on a Unix system, 'C:\' or 'D:\' (or whatever volume is the default) on a Windows system.)" 	^self protocol, ':///'</body><body package="Passport-Kernel" selector="defaultNamespace">defaultNamespace	| ns |	ns := self resourcePathContext defaultNamespaceAt: self protocol ifAbsent: [^self rootDirectoryMetavalueString].	^ns = self defaultRootDirectoryString ifTrue: [self rootDirectoryMetavalueString] ifFalse: [ns]</body></methods><methods><class-id>Passport.UrlPathFacade</class-id> <category>directory services</category><body package="Passport-Kernel" selector="resourceIsDirectory:">resourceIsDirectory: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; is a directory.  A resource is a directory if it acts as a namespace containing other resources."	^false</body></methods><methods><class-id>Passport.UrlPathFacade class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="initialize">initialize	"UrlPathFacade initialize"	TransparentCharSet := Set new.	$A codePoint to: $Z codePoint do: [:codePoint | TransparentCharSet add: (Character codePoint: codePoint)].	$a codePoint to: $z codePoint do: [:codePoint | TransparentCharSet add: (Character codePoint: codePoint)].	$0 codePoint to: $9 codePoint do: [:codePoint | TransparentCharSet add: (Character codePoint: codePoint)].	TransparentCharSet 		add: $';		addAll: '-_.!~*()'</body></methods><methods><class-id>Passport.VWUrlPathFacade</class-id> <category>conversion services</category><body package="Passport-Kernel-VW" selector="constructNativeResourceIDFromString:">constructNativeResourceIDFromString: aString	"Answer whatever value the current Smalltalk execution environment canonically would use to name/identify the external/persistent/remote resource (e.g, a file) referenced by &lt;aString&gt; (.e.g, a String in Squeak, a Filename in VisualWorks, etc.)"	^aString asURI</body></methods><methods><class-id>Passport.VWUrlPathFacade</class-id> <category>stream creation</category><body package="Passport-Kernel-VW" selector="newExternalReadStream:type:">newExternalReadStream: operand type: fileType 	"Synopsis		Returns an external readStream that reads from the external data source with the given name.	Specification (based on ANSI Smalltalk standard)		Locate an external data source that is identified by the value of &lt;operand&gt;. The &lt;operand&gt; parameter is an instance of whatever class the host Smalltalk implementation would canonically use to identify an external data source (e.g., a Strring, a Filename, a URL, etc.)  If &lt;operand&gt; is a String (or if its content requires syntactical interpretation,) then its syntax is implementation-dependent.		Return an object conforming to the ANSI &lt;readFileStream&gt; protocol whose future sequence values initially consist of the elements of the external data source and which initially has no past sequence values. The ordering of the sequence values is the same as the ordering within the external data source. The external data source serves as the stream backing store of the returned object. The value of &lt;fileType&gt; determines the external stream type and sequence value type of the result object.	Parameters		operand 		&lt;readableString&gt; 	identifies the external data source (typically, but not necessarily, a disk file)		fileType		&lt;symbol&gt; 			an enumeration constant that specifies the type of the external data source, as defined by the ANSI Smalltalk standard	Return Value		&lt;readFileStream&gt; new	Errors		It is an error if the data source identified by &lt;operand&gt; does not exist, or if the user does not have read access permission"	^fileType == #text 		ifTrue: [operand readStream]		ifFalse: [operand binaryReadStream]</body><body package="Passport-Kernel-VW" selector="newExternalWriteStream:mode:check:type:">newExternalWriteStream: operand mode: mode check: enforceExistentialConstraint type: fileType	^self shouldNotImplement</body></methods><methods><class-id>Passport.VWUrlPathFacade</class-id> <category>directory services</category><body package="Passport-Kernel-VW" selector="copyResource:to:">copyResource: sourceOperand to: destinationOperand 	"Copy the contents of the resource (e.g., a file) named/identified by &lt;sourceOperand&gt; to &lt;destinationOperand&gt;.  If the resource named/identified by &lt;destinationOperand&gt; does not exist, create it. If a resource so-named already exists, make it have exactly the same contents as the resource named/identified by &lt;sourceNativeFileID&gt;."	sourceOperand copyTo: destinationOperand</body><body package="Passport-Kernel-VW" selector="resourceExists:">resourceExists: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; exists"	^[operand readStreamDo: [:stream :response | true]] on: Error do: [:ex | ex return: false]</body><body package="Passport-Kernel-VW" selector="sizeOfResource:">sizeOfResource: operand	"Answer the size (in bytes) of the resource (e.g., a file) named/identified by &lt;operand&gt;"	^([operand readStreamDo: [:s :h | h at:'content-length' ifAbsent: [[0]]]] on: Error do: [:ex | ex return: [0]]) value</body></methods><methods><class-id>Passport.VWHttpUrlFacade</class-id> <category>accessing</category><body package="Passport-Kernel-VW" selector="protocol">protocol	^#http</body></methods><methods><class-id>Passport.VWHttpUrlFacade</class-id> <category>testing</category><body package="Passport-Kernel-VW" selector="syntaxPermitsFragment">syntaxPermitsFragment	^true</body><body package="Passport-Kernel-VW" selector="syntaxPermitsQueryString">syntaxPermitsQueryString	^true</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransition</class-id> <category>private-comparing</category><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilAnnualDateTZPolicy:">compareToUntilAnnualDateTZPolicy: anUntilAnnualDateTZPolicy	^-1</body><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilAnnualDayOfYearTZPolicy:">compareToUntilAnnualDayOfYearTZPolicy: anUntilAnnualDayOfYearTZPolicy	^-1</body><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilEndOfYearAnnualTZPolicy:">compareToUntilEndOfYearAnnualTZPolicy: anUntilEndOfYearAnnualTZPolicy	^anUntilEndOfYearAnnualTZPolicy binding compareTo: boundTZ</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransition</class-id> <category>queries</category><body package="Chronos-TimeZones-Policies-Annual" selector="intraYearPolicyForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">intraYearPolicyForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).  Assume the receiver's policy is in effect during the specified year.	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^self</body><body package="Chronos-TimeZones-Policies-Annual" selector="intraYearPolicyForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">intraYearPolicyForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).  Assume the receiver's policy is in effect during the specified year.	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^self</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year 	^DateAndTimeFactory 		year: year		month: 12		day: 31		timeZone: self offsetFromUT asTimezone</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransition</class-id> <category>converting</category><body package="Chronos-TimeZones-Policies-Annual" selector="asAnnuallyRecurringTZPolicyFactory">asAnnuallyRecurringTZPolicyFactory	"Answer the AnnuallyRecurringTZPolicyFactory that would serve as a factory to recreate an instance of the receiver's class with the same value as the receiver."	^UntilEndOfYearTimeZoneTransitionFactory 		offsetSeconds: self offsetSecondsFromUT		stdTimeOffsetSeconds: self stdTimeOffsetSecondsFromUT		commonAbbreviation: self commonAbbreviation</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransition</class-id> <category>printing</category><body package="Chronos-TimeZones-Policies-Annual" selector="printTranstionRuleOn:">printTranstionRuleOn: stream	stream nextPutAll: 'end-of-year'.</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransition</class-id> <category>comparing</category><body package="Chronos-TimeZones-Policies-Annual" selector="compareTo:">compareTo: anUntilEndOfYearAnnualTZPolicy	"Answer a strictly positive integer if the receiver's transition time is greater than that of the argument; answer 0 if equal; and answer a negative integer if less."	self == anUntilEndOfYearAnnualTZPolicy ifTrue: [^0].	^[anUntilEndOfYearAnnualTZPolicy compareToUntilEndOfYearAnnualTZPolicy: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == anUntilEndOfYearAnnualTZPolicy and: [ex message selector == #compareToUntilEndOfYearAnnualTZPolicy:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>comparing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="compareTo:">compareTo: anAnnualTZPolicyElement	"Compare the value of the receiver to that of &lt;aTimeZoneOffsetPolicyAtomSpec&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aTimeZoneOffsetPolicyAtomSpec&gt; are the same.)"	self == anAnnualTZPolicyElement ifTrue: [^0].	^[anAnnualTZPolicyElement compareToAnnualTZPolicyElement: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == anAnnualTZPolicyElement and: [ex message selector == #compareToAnnualTZPolicyElement:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="hash">hash	^(offsetSecondsFromUT + commonAbbreviation hash) hash</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>converting</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="asPolicyFor:">asPolicyFor: anInterYearTimeZonePolicy 	^self subclassResponsibility</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="withTransitionDayOfYear:transitionSecondsSinceStartOfDay:relativity:">withTransitionDayOfYear: dayOfYearOrdinal transitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol 	^UntilAnnualDayOfYearTimeZoneTransitionFactory		offsetSeconds: offsetSecondsFromUT		stdTimeOffsetSeconds: stdTimeOffsetSecondsFromUT		commonAbbreviation: commonAbbreviation		transitionDayOfYear: dayOfYearOrdinal		transitionSecondsSinceStartOfDay: transitionSeconds		relativity: aRelativitySymbol</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="hasName">hasName	^false</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isStandardTime">isStandardTime	^offsetSecondsFromUT = stdTimeOffsetSecondsFromUT</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^commonAbbreviation ~~ nil</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="specifiesIntraYearTransition">specifiesIntraYearTransition	^false</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="specifiesSingleTransition">specifiesSingleTransition	^false</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>printing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeOn:">encodeOn: stream	stream		nextPutAll: self typeKey;		nextPut: $:;		nextPutAll: commonAbbreviation;		nextPut: $:;		print: offsetSecondsFromUT;		nextPut: $:;		print: stdTimeOffsetSecondsFromUT.</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="printOn:">printOn: stream	stream		cr; tab; tab; nextPut: ${;		nextPutAll: self typeKey;		nextPut: $};		cr; tab; tab; tab; nextPutAll: 'commonAbbreviation=';		nextPutAll: commonAbbreviation;		nextPutAll: ' offsetSecondsFromUT=';		print: offsetSecondsFromUT;		nextPutAll: ' stdTimeOffsetSecondsFromUT=';		print: stdTimeOffsetSecondsFromUT</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	offsetSecondsFromUT := 0.	stdTimeOffsetSecondsFromUT := 0.	commonAbbreviation := #Unspecified</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setOffsetSeconds: (literalArray at: 3) asNumber		stdTimeOffsetSeconds: (literalArray at: 4) asNumber		commonAbbreviation: (literalArray at: 2)</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="setOffsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:">setOffsetSeconds: secondsFromUTC stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol	self assertMutability.	offsetSecondsFromUT := secondsFromUTC.	stdTimeOffsetSecondsFromUT := stdTimeSecondsFromUTC.	commonAbbreviation := aSymbol asSymbol</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="commonAbbreviation">commonAbbreviation	^commonAbbreviation</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="name">name	^commonAbbreviation</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="offsetDeltaSeconds">offsetDeltaSeconds	"Answer the number of seconds to be added to the receiver's standard-time offset from UT in order to compute the receiver's offset from UT when Daylight Saving Time (Summer Time) is in effect."	^self offsetSecondsFromUT - self stdTimeOffsetSecondsFromUT</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="offsetFromUT">offsetFromUT	^DurationFactory seconds: self offsetSecondsFromUT</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="offsetSecondsFromUT">offsetSecondsFromUT	^offsetSecondsFromUT</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="semanticKey">semanticKey		"Answer a value that identifies the conceptual type of the receiver."	^self subclassResponsibility</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="stdTimeOffsetFromUT">stdTimeOffsetFromUT	^DurationFactory seconds: self stdTimeOffsetSecondsFromUT</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="stdTimeOffsetSecondsFromUT">stdTimeOffsetSecondsFromUT	^stdTimeOffsetSecondsFromUT</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="typeKey">typeKey	^self subclassResponsibility</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>queries</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year	^self subclassResponsibility</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnFirstDayOfYear:">transitionOccursOnFirstDayOfYear: year	^false</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnLastDayOfYear:">transitionOccursOnLastDayOfYear: year	^false</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	stream 		nextPut: self globalNameOfClass;		nextPut: self commonAbbreviation;		nextPut: self stdTimeOffsetSecondsFromUT;		nextPut: self offsetSecondsFromUT</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>private-comparing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="compareToAnnualTZPolicyElement:">compareToAnnualTZPolicyElement: otherAnnualTZPolicyElement	| diff |	self == otherAnnualTZPolicyElement ifTrue: [^0].	diff := otherAnnualTZPolicyElement offsetSecondsFromUT - offsetSecondsFromUT.	diff = 0 ifFalse: [^diff].	otherAnnualTZPolicyElement commonAbbreviation &gt; commonAbbreviation ifTrue: [^1].	^otherAnnualTZPolicyElement commonAbbreviation &lt; commonAbbreviation		ifTrue: [-1] ifFalse: [0]</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id> <category>processing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory class</class-id> <category>class initialization</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initialize">initialize	"AnnuallyRecurringTZPolicyFactory initialize."	ClassByTypeKeyRegistry := nil</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory class</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isConcrete">isConcrete	^false</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory class</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	^self isConcrete 		ifTrue: 			[(self new)				initializeFromLiteralArray: literalArray;				beImmutable]		ifFalse: [super decodeFromLiteralArray: literalArray]</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="classByTypeKeyRegistry">classByTypeKeyRegistry	"AnnuallyRecurringTZPolicyFactory classByTypeKeyRegistry" 	ClassByTypeKeyRegistry == nil 		ifTrue: [self initializeClassByTypeKeyRegistry].	^ClassByTypeKeyRegistry</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initializeClassByTypeKeyRegistry">initializeClassByTypeKeyRegistry	| map |	map := IdentityDictionary new.	map 		at: #'Until-End-Of-Year'										put: (Pathname components: #(UntilEndOfYearTimeZoneTransitionFactory));		at: #'Until-Annual-Date-Transition'							put: (Pathname components: #(UntilAnnualDateTimeZoneTransitionFactory));		at: #'Until-Day-Of-Year-Transition'							put: (Pathname components: #(UntilAnnualDayOfYearTimeZoneTransitionFactory));		at: #TimeZoneInvariantOffsetPolicyAtomSpec				put: (Pathname components: #(UntilEndOfYearTimeZoneTransitionFactory));		at: #TimeZoneAnnualTransitionOffsetPolicyAtomSpec	put: (Pathname components: #(UntilAnnualDateTimeZoneTransitionFactory));		at: #TimeZoneSingleTransitionOffsetPolicyAtomSpec		put: (Pathname components: #(UntilAnnualDayOfYearTimeZoneTransitionFactory)).	ClassByTypeKeyRegistry := map	"#'Until-End-Of-Year' 										-&gt; UntilEndOfYearAnnualTZPolicyFactory	#'Until-Annual-Date-Transition' 							-&gt; UntilAnnualDateTZPolicyFactory	#'Until-Day-Of-Year-Transition' 							-&gt; UntilAnnualDayOfYearTZPolicyFactory	#TimeZoneInvariantOffsetPolicyAtomSpec				-&gt; UntilEndOfYearAnnualTZPolicyFactory	#'TimeZoneAnnualTransitionOffsetPolicyAtomSpec	-&gt; UntilAnnualDateTZPolicyFactory	#TimeZoneSingleTransitionOffsetPolicyAtomSpec		-&gt; UntilAnnualDayOfYearTZPolicyFactory"</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="resolveClassFromLiteralArray:">resolveClassFromLiteralArray: literalArray 	| typeKey |	typeKey := literalArray first asSymbol.	^(self classByTypeKeyRegistry at: typeKey		ifAbsent: [^super resolveClassFromLiteralArray: literalArray]) valueIn: (EnvironmentFacade current namespaceOfClass: self)</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="decodeFrom:">decodeFrom: stream	"{AnnuallyRecurringTZPolicyFactory 		decodeFrom: 			'Until-Annual-Date-Transition:NZDT:46800:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|3|15|1|0)' readStream}"	^self decodeFromLiteralArray: (ChronosFunction componentsFromStream: stream separator: $:)</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="referencedBy:">referencedBy: aTimeZoneOffsetPolicyAtomSpecOrTimeZoneOffsetPolicyAtomSpecLiteralString	"Anser the value referenced by &lt;aChronosObjectOrChronosObjectLiteralString&gt;. If the value is a key, answer the value bound to the key. If the value is a literal representation of a value encoded as a String, answer the result of decoding the value encoded by the String.  Otherwise, answer aChronosObjectOrChronosObjectLiteralString itself."	"{TimeZoneOffsetPolicyAtomSpec 		referencedBy: 			'TimeZoneAnnualTransitionOffsetPolicyAtomSpec:NZDT:46800:43200:standard:7200:/WeekOfMonthDayOfWeek/Gregorian/March/15/1/0'}"	^aTimeZoneOffsetPolicyAtomSpecOrTimeZoneOffsetPolicyAtomSpecLiteralString isString 			ifTrue: 				[self decodeFromLiteralArray: 					(ChronosFunction 						componentsFromString: aTimeZoneOffsetPolicyAtomSpecOrTimeZoneOffsetPolicyAtomSpecLiteralString						separator: $:)]			ifFalse: [aTimeZoneOffsetPolicyAtomSpecOrTimeZoneOffsetPolicyAtomSpecLiteralString].</body></methods><methods><class-id>Chronos.AnnuallyRecurringTZPolicyFactory class</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="appOrLibraryName">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransitionFactory</class-id> <category>converting</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="asPolicyFor:">asPolicyFor: anInterYearTimeZonePolicy 	^UntilEndOfYearTimeZoneTransition 		for: anInterYearTimeZonePolicy		offsetSeconds: offsetSecondsFromUT		stdTimeOffsetSeconds: stdTimeOffsetSecondsFromUT		commonAbbreviation: commonAbbreviation</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransitionFactory</class-id> <category>queries</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year 	^DateAndTimeFactory 		year: year		month: 12		day: 31		timeZone: self offsetFromUT asTimezone</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransitionFactory</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="semanticKey">semanticKey		"Answer a value that identifies the conceptual type of the receiver."	^#UntilEndOfYearTimeZoneTransition</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="typeKey">typeKey	^#'Until-End-Of-Year'</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransitionFactory</class-id> <category>processing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	^aTimezoneProcessor processUntilEndOfYearTimeZoneTransition: self</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransitionFactory class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:">offsetSeconds: secondsFromUTC stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol	^self new		setOffsetSeconds: secondsFromUTC  stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol;		beImmutable</body></methods><methods><class-id>Chronos.UntilEndOfYearTimeZoneTransitionFactory class</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isConcrete">isConcrete	^true</body></methods><methods><class-id>Chronos.AlwaysSystemTZ</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isAlwaysSystem">isAlwaysSystem	"Answer whether the receiver is the `always system` time zone."	^true</body><body package="Chronos-TimeZones" selector="isSystem">isSystem	"Answer whether the receiver is the system time zone."	^true</body></methods><methods><class-id>Chronos.AlwaysSystemTZ</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processAlwaysSystemTZ: self</body></methods><methods><class-id>Chronos.AlwaysSystemTZ</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="asNonProxy">asNonProxy	"Answer the time zone to which the receiver indirectly refers by proxy.  If the receiver is not a proxy for a time zone other than itself, answer the receiver."	^ChronosTimezone system</body><body package="Chronos-TimeZones" selector="canonical">canonical	"Answer the canonical instance of the receiver's class whose value is equivalent to that of the receiver's."	^ChronosTimezone alwaysSystem</body></methods><methods><class-id>Chronos.AlwaysSystemTZ</class-id> <category>private</category><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneblock	^'Dynamic Local Time (System)'</body></methods><methods><class-id>Chronos.AlwaysSystemTZ class</class-id> <category>private</category><body package="Chronos-TimeZones" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self alwaysSystem</body></methods><methods><class-id>Chronos.AlwaysSystemTZ class</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="registrationKey">registrationKey	"Anser the canonical key that uniquely identifies the receiver's canonical instance."	^#alwaysSystem</body></methods><methods><class-id>Passport.ExternalResource</class-id> <category>accessing</category><body package="Passport-Kernel" selector="aliasingKeys">aliasingKeys	^self class aliasingKeysOf: self registrationKey</body></methods><methods><class-id>Passport.ExternalResource</class-id> <category>registration</category><body package="Passport-Kernel" selector="aliasAs:onCollision:">aliasAs: aliasingKey onCollision: keyCollision 	aliasingKey == nil ifTrue: [^self signalError: 'Aliasing requires a non-nil alias key'].	self hasKey ifFalse: [^self registerAs: aliasingKey ifPresent: keyCollision].	(self class registry includesKey: aliasingKey) ifTrue: [^keyCollision value: (self class registry at: aliasingKey)].	self class alias: self registrationKey as: aliasingKey.	^self</body><body package="Passport-Kernel" selector="registerAs:ifPresent:">registerAs: aKey ifPresent: keyCollision 	aKey == nil ifTrue: [^self signalError: 'Registration requires a non-nil registration key'].	self hasKey		ifTrue: [self registrationKey == aKey ifFalse: [^self aliasAs: aKey onCollision: keyCollision]]		ifFalse: [self assertMutability].	^(self class registry includesKey: aKey) 		ifTrue: [keyCollision value: (self class registry at: aKey)]		ifFalse: 			[self setRegistrationKey: aKey.			self class registry at: self registrationKey put: self beImmutable].</body></methods><methods><class-id>Passport.ExternalResource class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="alias:as:">alias: canonicalKey as: aliasingKey 	^self registry alias: canonicalKey as: aliasingKey</body><body package="Passport-Kernel" selector="aliasingKeysOf:">aliasingKeysOf: canonicalKey	^self registry aliasingKeysOf: canonicalKey</body><body package="Passport-Kernel" selector="allAliasedKeys">allAliasedKeys	^self registry aliasedKeys</body><body package="Passport-Kernel" selector="allAliasingKeys">allAliasingKeys	^self registry aliasingKeys</body><body package="Passport-Kernel" selector="allCanonicalKeys">allCanonicalKeys	^self registry canonicalKeys</body><body package="Passport-Kernel" selector="at:ifAbsent:">at: aKey ifAbsent: ifAbsent 	^[super at: aKey ifAbsent: ifAbsent] on: Error do: [:ex | ex return: ifAbsent value]</body><body package="Passport-Kernel" selector="canonicalKeyAt:ifNone:">canonicalKeyAt: aKey ifNone: ifNone	"TimeZonePolicyFactory canonicalKeyAt: #GB ifNone: []"	^self registry canonicalKeyAt: aKey ifNone: ifNone</body><body package="Passport-Kernel" selector="define:">define: aKey	self registry define: aKey.</body></methods><methods><class-id>Passport.ExternalResource class</class-id> <category>repository management</category><body package="Passport-Kernel" selector="writeAliasesOn:">writeAliasesOn: stream 	self registry writeAliasesOn: stream</body><body package="Passport-Kernel" selector="writeCanonicalKeysOn:">writeCanonicalKeysOn: stream 	self registry writeCanonicalKeysOn: stream</body></methods><methods><class-id>Passport.ExternalResource class</class-id> <category>private</category><body package="Passport-Kernel" selector="newRegistry">newRegistry	^ExternalResourceRepository defaultBroker: self resourceBroker</body><body package="Passport-Kernel" selector="registrationKeyFrom:">registrationKeyFrom: stream 	UtilityFunction skipSeparators: stream.	^(stream upTo: $:) asSymbol</body></methods><methods><class-id>Chronos.SolarianCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"SolarianCalendar canonical 		forDaysSinceEpoch: 1029983		setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	| cycles days year daysSinceEpochUpToYear daysSinceStartOfYear |	days := daysSinceEpoch - 173125.	cycles := days // 1029983.	days := days \\ 1029983.	days = 1029982 		ifTrue: [year := 2820]		ifFalse: [year := (2816 * days + 1031337) // 1028522].	year := yearNumberingPolicy canonicalFromOrdinal: (2820 * cycles + 474 + year). " 2820 + 474 =  3294"	daysSinceEpochUpToYear := self daysSinceEpochUpToYear: year.	daysSinceStartOfYear :=  daysSinceEpoch - daysSinceEpochUpToYear.		^yearMonthDaySpecOrBlock2 		value: year		value: ((yearlyCalendars at: (self typeCodeOfYear: year)) basicDayAt: daysSinceStartOfYear + 1)</body></methods><methods><class-id>Chronos.SolarianCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"{SolarianCalendar canonical daysSinceEpochUpToYear: 5}"	"{SolarianCalendar canonical daysSinceEpochUpToYear: 475} = 173125"	"{(SolarianCalendar canonical daysSinceEpochUpToYear: 2821)}  = 1029983"	| cardinalYear dividend year |	cardinalYear := yearNumberingPolicy cardinalFromCanonical: calendarYear.	dividend := cardinalYear - 473.	year := (dividend \\ 2820)  + 474.	^(1029983 * (dividend // 2820)) + (365 * (year - 1)) + ((682 * year - 110) // 2816)</body></methods><methods><class-id>Chronos.SolarianCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^174249 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.SolarianCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	"SolarianCalendar canonical typeCodeOfYear: 0"	"SolarianCalendar canonical typeCodeOfYear: 1"	"SolarianCalendar canonical typeCodeOfYear: 475"	"SolarianCalendar canonical typeCodeOfYear: 479"	"{(1 to: 2820) inject: 0 into: [:total :year | (SolarianCalendar canonical typeCodeOfYear: year) = 2 ifTrue: [total + 1] ifFalse: [total]]} =  683"	| cardinalYear dividend year |	cardinalYear := yearNumberingPolicy cardinalFromCanonical: calendarYear.	dividend := cardinalYear - 473.	year := (dividend \\ 2820)  + 474.	^((year + 38) * 682 \\ 2816) &lt; 682		ifTrue: [2] ifFalse: [1]</body></methods><methods><class-id>Chronos.SolarianCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Month1	daysPerMonth: 28 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month2	daysPerMonth: 31 leapDayOrdinals: #(31));		nextPut: (MonthlyCalendarSpec newWithKey: #Month3 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month4 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month5	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month6 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month7	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month8	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month9	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month10 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month11	 daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month12	 daysPerMonth: 28 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Month1	daysPerMonth: 28 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month2	daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month3 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month4 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month5	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month6 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month7	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month8	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month9	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month10 	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month11	 daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Month12	 daysPerMonth: 28 leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.SolarianCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Solarian</body></methods><methods><class-id>Chronos.SolarianCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"SolarianCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>converting</category><body package="Passport-Kernel" selector="asDouble">asDouble	^self</body><body package="Passport-Kernel-VW" selector="asFixedPoint:">asFixedPoint: newScale	^self asScaledDecimal: newScale</body><body package="Passport-Kernel" selector="asFloat">asFloat	^self</body><body package="Passport-Kernel" selector="asInteger">asInteger	^self</body><body package="Passport-Kernel" selector="asMetaNumber">asMetaNumber	^self</body><body package="Passport-Kernel" selector="asRational">asRational	^self</body><body package="Passport-Kernel" selector="asScaledDecimal:">asScaledDecimal: newScale	^self</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>testing</category><body package="Passport-Kernel" selector="even">even	^false</body><body package="Passport-Kernel" selector="isImmutable">isImmutable	^lock ~~ nil</body><body package="Passport-Kernel" selector="isMutable">isMutable	^lock == nil</body><body package="Passport-Kernel" selector="isZero">isZero	^false</body><body package="Passport-Kernel" selector="negative">negative	^false</body><body package="Passport-Kernel" selector="odd">odd	^false</body><body package="Passport-Kernel" selector="positive">positive	^false</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>private</category><body package="Passport-Kernel" selector="assertMutability">assertMutability	lock == nil ifFalse: [self signalMutationException]</body><body package="Passport-Kernel" selector="isImmutable:">isImmutable: aBoolean	"Prevent VW from making me immutable at the VM level, because that's much too strict and draconian."	aBoolean ifTrue: [self beImmutable]	"I can't become mutable--and I'm always mutable in the VW sense, anyway."</body><body package="Passport-Kernel" selector="nilFields">nilFields	"Store nil into all pointer fields of the receiver."	EnvironmentFacade current makeMutable: self.	super nilFields</body><body package="Passport-Kernel" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	lock := nil.	EnvironmentFacade current makeMutable: self</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>comparing</category><body package="Passport-Kernel" selector="&lt;">&lt; aMagnitude 	"Answer whether the receiver is less than the argument."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &lt; 0]</body><body package="Passport-Kernel" selector="&lt;=">&lt;= otherMagnitude 	"Answer whether the receiver is less than or equal to the argument."	^(self &gt; otherMagnitude) not</body><body package="Passport-Kernel" selector="=">= otherMagnitude	self == otherMagnitude ifTrue: [^true].	^(self compareTo: otherMagnitude) = 0</body><body package="Passport-Kernel" selector="&gt;">&gt; aMagnitude 	"Answer whether the receiver is greater than the argument."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &gt; 0]</body><body package="Passport-Kernel" selector="&gt;=">&gt;= otherMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	^(self &lt; otherMagnitude) not</body><body package="Passport-Kernel" selector="between:and:">between: min and: max 	"Answer whether the receiver is less than or equal to the argument, max,	and greater than or equal to the argument, min."	^self &gt;= min and: [self &lt;= max]</body><body package="Passport-Kernel" selector="compareTo:">compareTo: otherMagnitude	"Compare the value of the receiver to that of &lt;otherMagnitude&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;otherMagnitude&gt; are the same.)"	^self subclassResponsibility</body><body package="Passport-Kernel" selector="max:">max: otherMagnitude 	"Answer the receiver or the argument, whichever has the greater magnitude."	self &gt; otherMagnitude		ifTrue: [^self]		ifFalse: [^otherMagnitude]</body><body package="Passport-Kernel" selector="min:">min: otherMagnitude 	"Answer the receiver or the argument, whichever has the lesser magnitude."	self &lt; otherMagnitude		ifTrue: [^self]		ifFalse: [^otherMagnitude]</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>error signalling</category><body package="Passport-Kernel" selector="signal:message:">signal: anExceptionFactory message: message	^EnvironmentFacade signal: anExceptionFactory message: message contextName: self class name</body><body package="Passport-Kernel" selector="signalMutationException">signalMutationException	^self signal: Error message: 'Attempt to mutate an immutable instance'</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>mathematical functions</category><body package="Passport-Kernel" selector="raisedToInteger:">raisedToInteger: anInteger 	^self</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>copying</category><body package="Passport-Kernel" selector="copy">copy	"Answer a copy of the receiver which 1) is mutable,  2) compares (#=) as equal to the receiver, and 3) satisfies the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the behavior of the copy it answers in response to this message will not be changed, and b) whenever the copy answered by the receiver in response to this message mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the behavior of the receiver will not be changed.  An associative reference is one where the semantics of the reference are defined by the object identity (#==) of the referenced object.  An attributive reference is one where the semantics of the reference are defined by the value (#=) of the referenced object."	"Subclasses should override this message for only one reason: to raise a 'NotCopyable' exception.  To change the behavior of #copy, subimplment #postCopy."	^self shallowCopy postCopy</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="beImmutable">beImmutable	"Make the receiver immutable.  Idempotent.  Must answer the receiver."	lock == nil 		ifTrue: 			[self canonicalize.			lock := #immutable]</body><body package="Passport-Kernel" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	"By default, do nothing"</body><body package="Passport-Kernel" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	"By default, do nothing"</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>arithmetic</category><body package="Passport-Kernel" selector="abs">abs	^self</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>truncation and roundoff</category><body package="Passport-Kernel" selector="truncated">truncated	^self</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>coercing-VW</category><body package="Passport-Kernel-VW" selector="coerce:">coerce: aNumber	^aNumber</body><body package="Passport-Kernel-VW" selector="generality">generality	^120</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>private-arithmetic-VW</category><body package="Passport-Kernel-VW" selector="differenceFromDouble:">differenceFromDouble: aDouble	^self differenceFromNumber: aDouble</body><body package="Passport-Kernel-VW" selector="differenceFromFloat:">differenceFromFloat: aFloat	^self differenceFromNumber: aFloat</body><body package="Passport-Kernel-VW" selector="differenceFromFraction:">differenceFromFraction: aFraction	^self differenceFromNumber: aFraction</body><body package="Passport-Kernel-VW" selector="differenceFromInteger:">differenceFromInteger: anInteger	^self differenceFromNumber: anInteger</body><body package="Passport-Kernel-VW" selector="differenceFromNumber:">differenceFromNumber: aNumber	^self</body><body package="Passport-Kernel-VW" selector="productFromDouble:">productFromDouble: aDouble	^self productFromNumber: aDouble</body><body package="Passport-Kernel-VW" selector="productFromFloat:">productFromFloat: aFloat	^self productFromNumber: aFloat</body><body package="Passport-Kernel-VW" selector="productFromFraction:">productFromFraction: aFraction	^self productFromNumber: aFraction</body><body package="Passport-Kernel-VW" selector="productFromInteger:">productFromInteger: anInteger	^self productFromNumber: anInteger</body><body package="Passport-Kernel-VW" selector="productFromNumber:">productFromNumber: aNumber 	^self</body><body package="Passport-Kernel-VW" selector="quotientFromDouble:">quotientFromDouble: aDouble	^self quotientFromNumber: aDouble</body><body package="Passport-Kernel-VW" selector="quotientFromFloat:">quotientFromFloat: aFloat	^self quotientFromNumber: aFloat</body><body package="Passport-Kernel-VW" selector="quotientFromFraction:">quotientFromFraction: aFraction	^self quotientFromNumber: aFraction</body><body package="Passport-Kernel-VW" selector="quotientFromInteger:">quotientFromInteger: anInteger	^self quotientFromNumber: anInteger</body><body package="Passport-Kernel-VW" selector="quotientFromNumber:">quotientFromNumber: aNumber 	^self</body><body package="Passport-Kernel-VW" selector="sumFromDouble:">sumFromDouble: aDouble	^self sumFromNumber: aDouble</body><body package="Passport-Kernel-VW" selector="sumFromFloat:">sumFromFloat: aFloat	^self sumFromNumber: aFloat</body><body package="Passport-Kernel-VW" selector="sumFromFraction:">sumFromFraction: aFraction	^self sumFromNumber: aFraction</body><body package="Passport-Kernel-VW" selector="sumFromInteger:">sumFromInteger: anInteger	^self sumFromNumber: anInteger</body><body package="Passport-Kernel-VW" selector="sumFromNumber:">sumFromNumber: aNumber	^self</body></methods><methods><class-id>Passport.PassportMetanumber</class-id> <category>private-comparing-VW</category><body package="Passport-Kernel-VW" selector="equalFromDouble:">equalFromDouble: aDouble	^false</body><body package="Passport-Kernel-VW" selector="equalFromFloat:">equalFromFloat: aFloat	^false</body><body package="Passport-Kernel-VW" selector="equalFromFraction:">equalFromFraction: aFraction	^false</body><body package="Passport-Kernel-VW" selector="equalFromInteger:">equalFromInteger: anInteger	^false</body></methods><methods><class-id>Passport.PassportMetanumber class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="appOrLibraryName">appOrLibraryName	^'Passport'</body></methods><methods><class-id>Passport.PassportMetanumber class</class-id> <category>instance creation</category><body package="Passport-Kernel" selector="new">new	^self shouldNotImplement</body></methods><methods><class-id>Passport.PassportNotANumber</class-id> <category>private-arithmetic</category><body package="Passport-Kernel" selector="addedToInfinitesimal:">addedToInfinitesimal: anInfinitesimal	^self</body><body package="Passport-Kernel" selector="addedToInfinity:">addedToInfinity: anInfinity	^self</body><body package="Passport-Kernel" selector="dividingInfinitesimal:">dividingInfinitesimal: anInfinitesimal	^self</body><body package="Passport-Kernel" selector="dividingInfinity:">dividingInfinity: anInfinity	^self</body><body package="Passport-Kernel" selector="multipliedByInfinitesimal:">multipliedByInfinitesimal: anInfinitesimal	^self</body><body package="Passport-Kernel" selector="multipliedByInfinity:">multipliedByInfinity: anInfinity	^self</body><body package="Passport-Kernel" selector="subtractedFromInfinitesimal:">subtractedFromInfinitesimal: anInfinitesimal	^self</body><body package="Passport-Kernel" selector="subtractedFromInfinity:">subtractedFromInfinity: anInfinity	^self</body></methods><methods><class-id>Passport.PassportNotANumber</class-id> <category>testing</category><body package="Passport-Kernel" selector="isNaN">isNaN	^true</body><body package="Passport-Kernel" selector="strictlyPositive">strictlyPositive	^false</body></methods><methods><class-id>Passport.PassportNotANumber</class-id> <category>arithmetic</category><body package="Passport-Kernel" selector="*">* aNumber	^self</body><body package="Passport-Kernel" selector="+">+ aNumber	^self</body><body package="Passport-Kernel" selector="-">- aNumber	^self</body><body package="Passport-Kernel" selector="/">/ aNumber	^self</body></methods><methods><class-id>Passport.PassportNotANumber</class-id> <category>printing</category><body package="Passport-Kernel" selector="printOn:">printOn: stream	stream nextPutAll: 'NaN'</body></methods><methods><class-id>Passport.PassportNotANumber</class-id> <category>private</category><body package="Passport-Kernel" selector="printOn:printPolicy:">printOn: aStream printPolicy: aNumberPrintPolicy	" *** This method was defined by Number as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Passport.PassportNotANumber</class-id> <category>comparing</category><body package="Passport-Kernel" selector="compareTo:">compareTo: otherMagnitude	"Compare the value of the receiver to that of &lt;otherMagnitude&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;otherMagnitude&gt; are the same.)"	^-1</body><body package="Passport-Kernel" selector="hash">hash	^16383 hash</body></methods><methods><class-id>Passport.PassportNotANumber</class-id> <category>private-comparing-VW</category><body package="Passport-Kernel-VW" selector="lessFromDouble:">lessFromDouble: aDouble	^true</body><body package="Passport-Kernel-VW" selector="lessFromFloat:">lessFromFloat: aFloat	^true</body><body package="Passport-Kernel-VW" selector="lessFromFraction:">lessFromFraction: aFraction	^true</body><body package="Passport-Kernel-VW" selector="lessFromInteger:">lessFromInteger: comparand	^true</body></methods><methods><class-id>Passport.PassportNotANumber class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="initialize">initialize	Canonical := nil</body></methods><methods><class-id>Passport.PassportNotANumber class</class-id> <category>constants</category><body package="Passport-Kernel" selector="canonical">canonical	Canonical == nil ifTrue: [Canonical := self basicNew].	^Canonical</body></methods><methods><class-id>Chronos.ImperialJulianCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2 	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"ImperialJulianCalendar canonical forDaysSinceEpoch: 0 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 366 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 731 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch:1096 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 1461 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 1827 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 258232 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 258597 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 258962 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 260058 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 272479 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 273209 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 273574 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 275034 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical forDaysSinceEpoch: 276129 setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 1"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 2"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 3"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 4"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 5"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 708 = 258232"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 709 = 258597"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 710 = 258962"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 713 = 260058"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 747 = 272479"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 749  = 273209"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 750 = 273574"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 754 = 275034"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 757 = 276129"	"Until 706: Every 4 years; 1 and 705 are leap years.	706 - 709: No leap years (a five year gap--709 should have been a leap year, but wasn't).	710 - 746: Every three years; 710 and 746 are leap years.	747 - 756: No leap years.	Since 757: Every 4 years; 757 is a leap year."	| year days yearTypeCode |	^(daysSinceEpoch &lt; 258597 "709 AUC" or: [daysSinceEpoch &gt;= 275034 "754 AUC"]) 		ifTrue: 			[| quadYear |			quadYear := daysSinceEpoch // 1461.			days := daysSinceEpoch \\ 1461.			days &gt; 365 				ifTrue: 					[yearTypeCode := 1.					days := days - 366.					days &gt; 364 						ifTrue: 							[days := days - 365.							days &gt; 364 								ifTrue: 									[days := days - 365.									year := 3]								ifFalse: [year := 2]]						ifFalse: [year := 1]]				ifFalse: 					[yearTypeCode := 2.					year := 0].	"&lt;year&gt; and &lt;days&gt; are both CARDINAL numbers here"			yearMonthDaySpecOrBlock2 				value: (yearNumberingPolicy canonicalFromCardinal: year + (quadYear * 4))				value: ((yearlyCalendars at: yearTypeCode) basicDayAt: days + 1)]		ifFalse: 			[| daysSinceAdjustmentEpoch |			daysSinceEpoch &gt;= 272479 "747 AUC"				ifTrue: 					[daysSinceAdjustmentEpoch := daysSinceEpoch - 272479.					yearMonthDaySpecOrBlock2 						value: 747 + (daysSinceAdjustmentEpoch // 365)						value: ((yearlyCalendars at: 1) basicDayAt: (daysSinceAdjustmentEpoch \\ 365) + 1)]				ifFalse: 					[daysSinceAdjustmentEpoch := daysSinceEpoch - 258597. "709 AUC"					daysSinceAdjustmentEpoch &lt; 365						ifTrue: 							[yearMonthDaySpecOrBlock2 								value: 709								value: ((yearlyCalendars at: 1) basicDayAt: daysSinceAdjustmentEpoch + 1)]						ifFalse: 							[| triadYear | 							daysSinceAdjustmentEpoch := daysSinceAdjustmentEpoch - 365.							triadYear := daysSinceAdjustmentEpoch // 1096.							days := daysSinceAdjustmentEpoch \\ 1096.							days &gt; 365 								ifTrue: 									[yearTypeCode := 1.									days := days - 366.									days &gt; 364 										ifTrue: 											[days := days - 365.											year := 2]										ifFalse: [year := 1]]								ifFalse: 									[yearTypeCode := 2.									year := 0].	"&lt;year&gt; and &lt;days&gt; are both CARDINAL numbers here"							yearMonthDaySpecOrBlock2 								value: 710 + (year + (triadYear * 3))								value: ((yearlyCalendars at: yearTypeCode) basicDayAt: days + 1)]]]</body></methods><methods><class-id>Chronos.ImperialJulianCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsFromEpochUpToGregorianStart">computeSecondsFromEpochUpToGregorianStart	^(self 		daysSinceEpochUpToMonth: 10		day: 5		inYear: 2336) * SecondsPerDay</body><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1446389 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.ImperialJulianCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 1"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 2"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 3"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 4"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 5"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 708 = 258232" 	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 709 = 258597" 	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 710 = 258962" 	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 713 = 260058"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 754 = 275034"	| estimate correction  |	estimate := (calendarYear - 1) * 365.	correction := (calendarYear &lt; 710 or: [calendarYear &gt; 753]) 		ifTrue: [(calendarYear + 2) // 4]		ifFalse:			[calendarYear &lt; 747				ifTrue: [correction := 177 + ((calendarYear - 708) // 3)]				ifFalse: [correction := 189]].	^estimate + correction	"Until 706: Every 4 years; 1 and 705 are leap years.	706 - 709: No leap years (a five year gap--709 should have been a leap year, but wasn't).	710 - 746: Every three years; 710 and 746 are leap years.	747 - 756: No leap years.	Since 757: Every 4 years; 757 is a leap year."</body></methods><methods><class-id>Chronos.ImperialJulianCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="eraNameForYear:">eraNameForYear: calendarYear	"Answer the abbreviation of the name of the era to which &lt;calendarYear&gt; belongs.  The name of an era identifies the epoch date of a calendrical system and/or the calendrical system itself (although it may do so ambiguously.) The era name may also identify whether or not the &lt;calendarYear&gt; occurs before or after the epoch date."	^(yearNumberingPolicy cardinalFromCanonical: calendarYear) &gt;= 0		ifTrue: [self defaultLocale properNameAtSemanticKey: #'ImperialJulian-era-postEpoch'] 		ifFalse: [self defaultLocale properNameAtSemanticKey: #'ImperialJulian-era-preEpoch']</body><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear 	"Answer the year type code of the given &lt;calendarYear&gt;."	^(calendarYear &gt;= 757 or: [calendarYear &lt; 709]) 		ifTrue: [calendarYear \\ 4 == 1 ifTrue: [2] ifFalse: [1]]		ifFalse: [calendarYear &lt; 749 ifTrue: [calendarYear \\ 3 == 2 ifTrue: [2] ifFalse: [1]] ifFalse: [1]]	"								Modern 			Imperial Roman		Imperial Roman		Julian Year		Year AUC			Leap Status				753 BC			1					leap				{Julian typeCodeOfYear: -753}	{ImperialJulianCalendar canonical typeCodeOfYear: 1}		752 BC			2					standard			{Julian typeCodeOfYear: -752}	{ImperialJulianCalendar canonical typeCodeOfYear: 2}		751 BC			3					standard			{Julian typeCodeOfYear: -751}	{ImperialJulianCalendar canonical typeCodeOfYear: 3}		750 BC			4					standard			{Julian typeCodeOfYear: -750}	{ImperialJulianCalendar canonical typeCodeOfYear: 4}		749 BC			5					leap				{Julian typeCodeOfYear: -749}	{ImperialJulianCalendar canonical typeCodeOfYear: 5}		45 BC			709					standard			{Julian typeCodeOfYear: -45}		{ImperialJulianCalendar canonical typeCodeOfYear: 709}		44 BC			710					leap				{Julian typeCodeOfYear: -45}		{ImperialJulianCalendar canonical typeCodeOfYear: 710}		42 BC			712					standard			{Julian typeCodeOfYear: -42}		{ImperialJulianCalendar canonical typeCodeOfYear: 712}		41 BC			713					leap				{Julian typeCodeOfYear: -41}		{ImperialJulianCalendar canonical typeCodeOfYear: 713}		38 BC			716					leap				{Julian typeCodeOfYear: -38}		{ImperialJulianCalendar canonical typeCodeOfYear: 716}		35 BC			719					leap				{Julian typeCodeOfYear: -35}		{ImperialJulianCalendar canonical typeCodeOfYear: 719}		32 BC			722 				leap				{Julian typeCodeOfYear: -32}		{ImperialJulianCalendar canonical typeCodeOfYear: 722}		29 BC			725 				leap				{Julian typeCodeOfYear: -29}		{ImperialJulianCalendar canonical typeCodeOfYear: 725}		26 BC			728					leap				{Julian typeCodeOfYear: -26}		{ImperialJulianCalendar canonical typeCodeOfYear: 728}		23 BC			731					leap				{Julian typeCodeOfYear: -23}		{ImperialJulianCalendar canonical typeCodeOfYear: 730}		20 BC			734					leap				{Julian typeCodeOfYear: -20}		{ImperialJulianCalendar canonical typeCodeOfYear: 731}		17 BC			737					leap				{Julian typeCodeOfYear: -17}		{ImperialJulianCalendar canonical typeCodeOfYear: 737}		14 BC			740					leap				{Julian typeCodeOfYear: -14}		{ImperialJulianCalendar canonical typeCodeOfYear: 740}		11 BC			743					leap				{Julian typeCodeOfYear: -11}		{ImperialJulianCalendar canonical typeCodeOfYear: 743}		8 BC			746					leap				{Julian typeCodeOfYear: -8}		{ImperialJulianCalendar canonical typeCodeOfYear: 746}		5 BC			749					standard			{Julian typeCodeOfYear: -5}		{ImperialJulianCalendar canonical typeCodeOfYear: 749}		2 BC			752					standard			{Julian typeCodeOfYear: -6}		{ImperialJulianCalendar canonical typeCodeOfYear: 752}		1 BC			753					standard			{Julian typeCodeOfYear: -1}		{ImperialJulianCalendar canonical typeCodeOfYear: 753}		1 AD			754					standard			{Julian typeCodeOfYear: 1}		{ImperialJulianCalendar canonical typeCodeOfYear: 754}		4 AD			757					leap				{Julian typeCodeOfYear: 4}		{ImperialJulianCalendar canonical typeCodeOfYear: 757}		8 AD			761					leap				{Julian typeCodeOfYear: 8}		{ImperialJulianCalendar canonical typeCodeOfYear: 761}		"</body></methods><methods><class-id>Chronos.ImperialJulianCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#'Julian-Imperial'</body></methods><methods><class-id>Chronos.ImperialJulianCalendar class</class-id> <category>functional verification</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToMonthDayInYearPassesVerification">daysSinceEpochUpToMonthDayInYearPassesVerification	^self daysSinceEpochUpToMonthDayInYearVerifier value: self canonical</body></methods><methods><class-id>Chronos.ImperialJulianCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"ImperialJulianCalendar initialize"	self basicInitialize.</body></methods><methods><class-id>Chronos.ImperialJulianCalendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 1"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 2"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 3"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 4"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 5"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 708 = 258232" 	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 709 = 258597" 	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 710 = 258962" 	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 713 = 260058"	"ImperialJulianCalendar canonical daysSinceEpochUpToYear: 754 = 275034"	| estimate correction  |	estimate := (calendarYear - 1) * 365.	correction := (calendarYear &lt; 710 or: [calendarYear &gt; 753]) 		ifTrue: [(calendarYear + 2) // 4]		ifFalse:			[calendarYear &lt; 747				ifTrue: [correction := 177 + ((calendarYear - 708) // 3)]				ifFalse: [correction := 189]].	^estimate + correction	"Until 706: Every 4 years; 1 and 705 are leap years.	706 - 709: No leap years (a five year gap--709 should have been a leap year, but wasn't).	710 - 746: Every three years; 710 and 746 are leap years.	747 - 756: No leap years.	Since 757: Every 4 years; 757 is a leap year."</body><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear 	"Answer the year type code of the given &lt;calendarYear&gt;."	^(calendarYear &gt;= 757 or: [calendarYear &lt; 709]) 		ifTrue: [calendarYear \\ 4 == 1 ifTrue: [2] ifFalse: [1]]		ifFalse: [calendarYear &lt; 749 ifTrue: [calendarYear \\ 3 == 2 ifTrue: [2] ifFalse: [1]] ifFalse: [1]]	"								Modern 			Imperial Roman		Imperial Roman		Julian Year		Year AUC			Leap Status				753 BC			1					leap				{Julian typeCodeOfYear: -753}	{ImperialJulianCalendar canonical typeCodeOfYear: 1}		752 BC			2					standard			{Julian typeCodeOfYear: -752}	{ImperialJulianCalendar canonical typeCodeOfYear: 2}		751 BC			3					standard			{Julian typeCodeOfYear: -751}	{ImperialJulianCalendar canonical typeCodeOfYear: 3}		750 BC			4					standard			{Julian typeCodeOfYear: -750}	{ImperialJulianCalendar canonical typeCodeOfYear: 4}		749 BC			5					leap				{Julian typeCodeOfYear: -749}	{ImperialJulianCalendar canonical typeCodeOfYear: 5}		45 BC			709					standard			{Julian typeCodeOfYear: -45}		{ImperialJulianCalendar canonical typeCodeOfYear: 709}		44 BC			710					leap				{Julian typeCodeOfYear: -45}		{ImperialJulianCalendar canonical typeCodeOfYear: 710}		42 BC			712					standard			{Julian typeCodeOfYear: -42}		{ImperialJulianCalendar canonical typeCodeOfYear: 712}		41 BC			713					leap				{Julian typeCodeOfYear: -41}		{ImperialJulianCalendar canonical typeCodeOfYear: 713}		38 BC			716					leap				{Julian typeCodeOfYear: -38}		{ImperialJulianCalendar canonical typeCodeOfYear: 716}		35 BC			719					leap				{Julian typeCodeOfYear: -35}		{ImperialJulianCalendar canonical typeCodeOfYear: 719}		32 BC			722 				leap				{Julian typeCodeOfYear: -32}		{ImperialJulianCalendar canonical typeCodeOfYear: 722}		29 BC			725 				leap				{Julian typeCodeOfYear: -29}		{ImperialJulianCalendar canonical typeCodeOfYear: 725}		26 BC			728					leap				{Julian typeCodeOfYear: -26}		{ImperialJulianCalendar canonical typeCodeOfYear: 728}		23 BC			731					leap				{Julian typeCodeOfYear: -23}		{ImperialJulianCalendar canonical typeCodeOfYear: 730}		20 BC			734					leap				{Julian typeCodeOfYear: -20}		{ImperialJulianCalendar canonical typeCodeOfYear: 731}		17 BC			737					leap				{Julian typeCodeOfYear: -17}		{ImperialJulianCalendar canonical typeCodeOfYear: 737}		14 BC			740					leap				{Julian typeCodeOfYear: -14}		{ImperialJulianCalendar canonical typeCodeOfYear: 740}		11 BC			743					leap				{Julian typeCodeOfYear: -11}		{ImperialJulianCalendar canonical typeCodeOfYear: 743}		8 BC			746					leap				{Julian typeCodeOfYear: -8}		{ImperialJulianCalendar canonical typeCodeOfYear: 746}		5 BC			749					standard			{Julian typeCodeOfYear: -5}		{ImperialJulianCalendar canonical typeCodeOfYear: 749}		2 BC			752					standard			{Julian typeCodeOfYear: -6}		{ImperialJulianCalendar canonical typeCodeOfYear: 752}		1 BC			753					standard			{Julian typeCodeOfYear: -1}		{ImperialJulianCalendar canonical typeCodeOfYear: 753}		1 AD			754					standard			{Julian typeCodeOfYear: 1}		{ImperialJulianCalendar canonical typeCodeOfYear: 754}		4 AD			757					leap				{Julian typeCodeOfYear: 4}		{ImperialJulianCalendar canonical typeCodeOfYear: 757}		8 AD			761					leap				{Julian typeCodeOfYear: 8}		{ImperialJulianCalendar canonical typeCodeOfYear: 761}		"</body></methods><methods><class-id>Chronos.Durational</class-id> <category>arithmetic</category><body package="Chronos-Duration" selector="addingDays:">addingDays: addedDays	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedDays&gt; days greater than that of the receiver's." 	addedDays = 0 ifTrue: [^self].	^(self copy)		addDays: addedDays;		beImmutable</body><body package="Chronos-Duration" selector="addingHours:">addingHours: addedHours	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedHours&gt; hours greater than that of the receiver's." 	addedHours = 0 ifTrue: [^self].	^(self asSubDayMutable)		addHours: addedHours;		beImmutable</body><body package="Chronos-Duration" selector="addingHours:minutes:">addingHours: addedHours minutes: addedMinutes	addedMinutes = 0 ifTrue: [^self addingHours: addedHours] .	^(self asSubDayMutable)		addHours: addedHours minutes: addedMinutes;		beImmutable</body><body package="Chronos-Duration" selector="addingHours:minutes:seconds:">addingHours: addedHours minutes: addedMinutes seconds: addedSeconds	addedSeconds = 0 ifTrue: [^addedMinutes = 0 ifTrue: [self addingHours: addedHours] ifFalse: [self addingHours: addedHours minutes: addedMinutes]].	^(self asSubDayMutable)		addHours: addedHours minutes: addedMinutes seconds: addedSeconds;		beImmutable</body><body package="Chronos-Duration" selector="addingHours:minutes:seconds:nanoseconds:">addingHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds 	^(self asSubDayMutable)		addHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds;		beImmutable</body><body package="Chronos-Duration" selector="addingMinutes:">addingMinutes: addedMinutes	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedMinutes&gt; minutes greater than that of the receiver's." 	addedMinutes = 0 ifTrue: [^self].	^(self asSubDayMutable)		addMinutes: addedMinutes;		beImmutable</body><body package="Chronos-Duration" selector="addingMonths:">addingMonths: addedMonths	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedMonths&gt; months greater than that of the receiver's." 	addedMonths = 0 ifTrue: [^self].	^(self asCalendricalMutable)		addMonths: addedMonths;		beImmutable</body><body package="Chronos-Duration" selector="addingSeconds:">addingSeconds: addedSeconds 	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedSeconds&gt; seconds greater than that of the receiver's."	addedSeconds = 0 ifTrue: [^self].	^(self asSubDayMutable)		addSeconds: addedSeconds;		beImmutable</body><body package="Chronos-Duration" selector="addingSeconds:nanoseconds:">addingSeconds: addedSeconds nanoseconds: addedNanoseconds 	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedSeconds&gt; seconds and &lt;addedNanoseconds&gt; nanoseconds greater than that of the receiver's." 	addedNanoseconds = 0 ifTrue: [^self addingSeconds: addedSeconds].	^(self asSubDayMutable)		addSeconds: addedSeconds nanoseconds: addedNanoseconds;		beImmutable</body><body package="Chronos-Duration" selector="addingYears:">addingYears: addedYears	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedYears&gt; years greater than that of the receiver's." 	addedYears = 0 ifTrue: [^self].	^(self asCalendricalMutable)		addYears: addedYears;		beImmutable</body><body package="Chronos-Duration" selector="addingYears:months:">addingYears: addedYears months: addedMonths	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedYears&gt; years and &lt;addedMonths&gt; months greater than that of the receiver's." 	addedMonths = 0 ifTrue: [^self addingYears: addedYears].	^self asCalendricalMutable		addYears: addedYears months: addedMonths;		beImmutable</body><body package="Chronos-Duration" selector="addingYears:months:days:">addingYears: addedYears months: addedMonths days: addedDays	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedYears&gt; years, &lt;addedMonths&gt; months, &lt;addedDays&gt; days, &lt;addedSeconds&gt; seconds and &lt;addedNanoseconds&gt; nanoseconds greater than that of the receiver's." 	addedDays = 0 ifTrue: [^addedMonths = 0 ifTrue: [self addingYears: addedYears] ifFalse: [self addingYears: addedYears months: addedMonths]].	^self asCalendricalMutable		addYears: addedYears months: addedMonths days: addedDays;		beImmutable</body><body package="Chronos-Duration" selector="addingYears:months:days:hours:minutes:seconds:">addingYears: addedYears months: addedMonths days: addedDays hours: addedHours minutes: addedMinutes seconds: addedSeconds	^(self asCivilSubDayMutable)		addYears: addedYears months: addedMonths days: addedDays;		addHours: addedHours minutes: addedMinutes seconds: addedSeconds;		beImmutable</body><body package="Chronos-Duration" selector="addingYears:months:days:hours:minutes:seconds:nanoseconds:">addingYears: addedYears months: addedMonths days: addedDays hours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds	^(self asCivilSubDayMutable)		addYears: addedYears months: addedMonths days: addedDays;		addHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds;		beImmutable</body><body package="Chronos-Duration" selector="addingYears:months:days:seconds:nanoseconds:">addingYears: addedYears months: addedMonths days: addedDays seconds: addedSeconds nanoseconds: addedNanoseconds	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedYears&gt; years, &lt;addedMonths&gt; months, &lt;addedDays&gt; days, &lt;addedSeconds&gt; seconds and &lt;addedNanoseconds&gt; nanoseconds greater than that of the receiver's." 	^(self asCivilSubDayMutable)		addYears: addedYears months: addedMonths days: addedDays;		addSeconds: addedSeconds nanoseconds: addedNanoseconds;		beImmutable</body><body package="Chronos-Duration" selector="subtractingDays:">subtractingDays: subtractedDays	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;subtractedDays&gt; days less than that of the receiver's." 	subtractedDays = 0 ifTrue: [^self].	^(self asCalendricalMutable)		addDays: subtractedDays negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingHours:">subtractingHours: subtractedHours	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;subtractedHours&gt; hours less than that of the receiver's." 	subtractedHours = 0 ifTrue: [^self].	^(self asSubDayMutable)		addHours: subtractedHours negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingHours:minutes:">subtractingHours: subtractedHours minutes: subtractedMinutes	subtractedMinutes = 0 ifTrue: [^self subtractingHours: subtractedHours] .	^(self asSubDayMutable)		addHours: subtractedHours negated minutes: subtractedMinutes negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingHours:minutes:seconds:">subtractingHours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds	subtractedSeconds = 0 ifTrue: [^subtractedMinutes = 0 ifTrue: [self subtractingHours: subtractedHours] ifFalse: [self subtractingHours: subtractedHours minutes: subtractedMinutes]].	^(self asSubDayMutable)		addHours: subtractedHours negated minutes: subtractedMinutes negated seconds: subtractedSeconds negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingHours:minutes:seconds:nanoseconds:">subtractingHours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds nanoseconds: subtractedNanoseconds 	^(self asSubDayMutable)		addHours: subtractedHours negated minutes: subtractedMinutes negated seconds: subtractedSeconds negated nanoseconds: subtractedNanoseconds negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingMinutes:">subtractingMinutes: subtractedMinutes	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;subtractedMinutes&gt; minutes less than that of the receiver's." 	subtractedMinutes = 0 ifTrue: [^self].	^(self asSubDayMutable)		addMinutes: subtractedMinutes negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingMonths:">subtractingMonths: subtractedMonths	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedMonths&gt; months less than that of the receiver's." 	subtractedMonths = 0 ifTrue: [^self].	^(self asCalendricalMutable)		addMonths: subtractedMonths negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingSeconds:">subtractingSeconds: subtractedSeconds	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;subtractedSeconds&gt; seconds less than that of the receiver's." 	subtractedSeconds = 0 ifTrue: [^self].	^(self asSubDayMutable)		addSeconds: subtractedSeconds negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingSeconds:nanoseconds:">subtractingSeconds: subtractedSeconds nanoseconds: subtractedNanoseconds 	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;subtractedSeconds&gt; seconds and &lt;subtractedNanoseconds&gt; nanoseconds less than that of the receiver's."	subtractedNanoseconds = 0 ifTrue: [^self addingSeconds: subtractedSeconds negated].	^(self asSubDayMutable)		addSeconds: subtractedSeconds negated nanoseconds: subtractedNanoseconds negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingYears:">subtractingYears: subtractedYears	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;subtractedYears&gt; years less than that of the receiver's." 	subtractedYears = 0 ifTrue: [^self].	^(self asCalendricalMutable)		addYears: subtractedYears negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingYears:months:">subtractingYears: subtractedYears months: subtractedMonths	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;subtractedYears&gt; years and &lt;subtractedMonths&gt; months greater than that of the receiver's." 	subtractedMonths = 0 ifTrue: [^self subtractingYears: subtractedYears].	^self asCalendricalMutable		addYears: subtractedYears negated months: subtractedMonths negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingYears:months:days:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedYears&gt; years, &lt;addedMonths&gt; months, &lt;addedDays&gt; days, &lt;addedSeconds&gt; seconds and &lt;addedNanoseconds&gt; nanoseconds less than that of the receiver's." 	subtractedDays = 0 ifTrue: [^subtractedMonths = 0 ifTrue: [self subtractingYears: subtractedYears] ifFalse: [self subtractingYears: subtractedYears months: subtractedMonths]].	^self asCalendricalMutable		addYears: subtractedYears negated months: subtractedMonths negated days: subtractedDays negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingYears:months:days:hours:minutes:seconds:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays hours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds	^(self asCivilSubDayMutable)		addYears: subtractedYears negated months: subtractedMonths negated days: subtractedDays negated;		addHours: subtractedHours negated minutes: subtractedMinutes negated seconds: subtractedSeconds negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingYears:months:days:hours:minutes:seconds:nanoseconds:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays hours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds nanoseconds: subtractedNanoseconds	^(self asCivilSubDayMutable)		addYears: subtractedYears negated months: subtractedMonths negated days: subtractedDays negated;		addHours: subtractedHours negated minutes: subtractedMinutes negated seconds: subtractedSeconds negated nanoseconds: subtractedNanoseconds negated;		beImmutable</body><body package="Chronos-Duration" selector="subtractingYears:months:days:seconds:nanoseconds:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays seconds: subtractedSeconds nanoseconds: subtractedNanoseconds	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedYears&gt; years, &lt;addedMonths&gt; months, &lt;addedDays&gt; days, &lt;addedSeconds&gt; seconds and &lt;addedNanoseconds&gt; nanoseconds less than that of the receiver's." 	^(self asCivilSubDayMutable)		addYears: subtractedYears negated months: subtractedMonths negated days: subtractedDays negated;		addSeconds: subtractedSeconds negated nanoseconds: subtractedNanoseconds negated;		beImmutable</body></methods><methods><class-id>Chronos.Durational</class-id> <category>accessing</category><body package="Chronos-Duration" selector="comparisonClassIdentifier">comparisonClassIdentifier		"Answer a value that identifies the group of comparable values to which the receiver belongs.  It must be valid to use #== to compare two identifiers for equality."	^#Durational</body><body package="Chronos-Duration" selector="days">days	"Answer the integer number of days (truncated towards zero) represented by the receiver, independent of the number of months and/or years it may represent."	"Specified and required by the ANSI-Smalltalk Standard."	^0</body><body package="Chronos-Duration" selector="duration">duration	"Answer a Duration whose value represents the receiver's temporal extent."	^self</body><body package="Chronos-Duration" selector="hours">hours	"Answer the integer number of hours-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in hours after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^0</body><body package="Chronos-Duration" selector="microsecondsSinceSecond">microsecondsSinceSecond	"Answer the integer number of microseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in microseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^(self nanosecondsSinceSecond bitShift: -3) // 125</body><body package="Chronos-Duration" selector="millisecondsSinceSecond">millisecondsSinceSecond	"Answer the integer number of milliseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in milliseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^(self nanosecondsSinceSecond bitShift: -6) // 15625</body><body package="Chronos-Duration" selector="minutes">minutes	"Answer the integer number of minutes-since-the-hour (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in minutes after subtracting from its temporal extent integer number of hours (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^0</body><body package="Chronos-Duration" selector="months">months	"Answer the integer number of months (truncated towards zero) represented by the receiver, independent of the number of years or seconds it may represent."	^0</body><body package="Chronos-Duration" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	"Answer the integer number of nanoseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in nanoseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^0</body><body package="Chronos-Duration" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^self subclassResponsibility</body><body package="Chronos-Duration" selector="seconds">seconds	"Answer the integer number of seconds-since-the-minute (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of minutes (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^0</body><body package="Chronos-Duration" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	"Answer the integer number of seconds-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.) Assume an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^0</body><body package="Chronos-Duration" selector="weeks">weeks	"Answer the integer number of weeks (truncated towards zero) represented by the receiver, solely as a function of the number of days it represents, and independent of the number of months and/or years it may represent."	^self asDays quo: DaysPerWeek</body><body package="Chronos-Duration" selector="years">years	"Answer the integer number of years (truncated towards zero) represented by the receiver, independent of the number of months or seconds it may represent."	^0</body></methods><methods><class-id>Chronos.Durational</class-id> <category>testing</category><body package="Chronos-Duration" selector="calendarPeriodsAreZero">calendarPeriodsAreZero	"Answer whether the components of the receiver's duration vector that represent calendrical periods (years, months, days) all have the value zero."	^self subclassResponsibility</body><body package="Chronos-Duration" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^false</body><body package="Chronos-Duration" selector="isDurational">isDurational	^true</body><body package="Chronos-Duration" selector="isHourDuration">isHourDuration	"Answer whether the receiver's temporal extent is one hour."	^false</body><body package="Chronos-Duration" selector="isInfinite">isInfinite	^false</body><body package="Chronos-Duration" selector="isMinimumResolutionQuantum">isMinimumResolutionQuantum	"Answer whether the receiver's temporal extent is the receiver's minimum resolution quantum."	^self isNanosecondDuration</body><body package="Chronos-Duration" selector="isMinuteDuration">isMinuteDuration	"Answer whether the receiver's temporal extent is one minute."	^false</body><body package="Chronos-Duration" selector="isMonthDuration">isMonthDuration	"Answer whether the receiver's temporal extent is one month."	^false</body><body package="Chronos-Duration" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^false</body><body package="Chronos-Duration" selector="isSecondDuration">isSecondDuration	"Answer whether the receiver's temporal extent is one second."	^false</body><body package="Chronos-Duration" selector="isYearDuration">isYearDuration	"Answer whether the receiver's temporal extent is one year."	^false</body><body package="Chronos-Duration" selector="isZero">isZero	"Answer the whether the receiver represents a zero-length temporal extent."	^self subclassResponsibility</body><body package="Chronos-Duration" selector="negative">negative	"Answer whether the receiver represents a temporal extent whose magnitude is negative."	"Specified and required by the ANSI-Smalltalk Standard."	^self nonCalendarPeriodsNegative</body><body package="Chronos-Duration" selector="nonCalendarPeriodsAreZero">nonCalendarPeriodsAreZero	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is zero."	^true</body><body package="Chronos-Duration" selector="nonCalendarPeriodsNegative">nonCalendarPeriodsNegative	"Answer whether the non-calendrical temporal extent (seconds/nanoseconds) of the receiver is negative."	^self nonCalendarPeriodsPositive not</body><body package="Chronos-Duration" selector="nonCalendarPeriodsPositive">nonCalendarPeriodsPositive	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is positive."	^true</body><body package="Chronos-Duration" selector="positive">positive	"Answer whether the receiver represents a temporal extent whose magnitude is positive (or zero.)"	"Specified and required by the ANSI-Smalltalk Standard."	^self nonCalendarPeriodsPositive</body><body package="Chronos-Duration" selector="subsecondsAreNonZero">subsecondsAreNonZero	"Answer whether the sub-second temporal extent (seconds/nanoseconds) of the receiver is non-zero."	^self subsecondsAreZero not</body><body package="Chronos-Duration" selector="subsecondsAreZero">subsecondsAreZero	"Answer whether the sub-second temporal extent (seconds/nanoseconds) of the receiver is zero."	^true</body></methods><methods><class-id>Chronos.Durational</class-id> <category>enumerating</category><body package="Chronos-Duration" selector="startingFrom:every:collect:">startingFrom: start every: period collect: mapper	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding the given durational &lt;period&gt; to the preceding point-in-time in the sequence, do the following: 1) evaluate &lt;mapper&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument, and 2) add the result of each evaluation to a sequential collection. When all the moments (in the monotonic sequence as specified) have been evaluated, answer the sequential collection. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	"EXAMPLE: Compute the formatted printString of the first day of each quarter for the next year (where the first quarter starts today):		{(CalendarDuration years: 1) 			startingFrom: DateFactory today 			every: (CalendarDuration months: 3) 			collect: [:date | date printStringUsing: #verbose]}"	| list |	list := SequenceFactory new.	self startingFrom: start every: period do: [:time |		list add: (mapper value: time).	].	^list</body><body package="Chronos-Duration" selector="startingFrom:every:contains:">startingFrom: start every: period contains: predicate	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding the given durational &lt;period&gt; to the preceding point-in-time in the sequence, 1) apply &lt;predicate&gt; as a predicate test, with each successive point-in-time (in the monotonic sequence as specified) as the argument, and 2) if any such point-in-time in the mononotic sequence satisfies the predicate test, answer true.  Otherwise, answer false. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	"EXAMPLE: Compute whether a weekly recurring event, starting from today, would coincide with any US Federal Holidays over the next year:		{(CalendarDuration years: 1) 			startingFrom: DateFactory today 			every: (CalendarDuration weeks: 1) 			contains: [:date | date isUSFederalHoliday]}"	self startingFrom: start every: period		do: [:time | (predicate value: time) ifTrue: [^true]].	^false</body><body package="Chronos-Duration" selector="startingFrom:every:detect:ifNone:">startingFrom: start every: period detect: predicate ifNone: unsatisfiedAction	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding the given durational &lt;period&gt; to the preceding point-in-time in the sequence, 1) apply &lt;predicate&gt; as a predicate test, with each successive point-in-time (in the monotonic sequence as specified) as the argument, and 2) if any such point-in-time in the mononotic sequence satisfies the predicate test, answer that point-in-time value.  Otherwise, answer the result of evaluating &lt;unsatisfiedAction&gt;. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	"EXAMPLE: For a weekly recurring event, starting from today, compute the first day where the event would coincide with any US Federal Holiday over the next year (if any--and if not, try using some day other than today):		{(CalendarDuration years: 1) 			startingFrom: DateFactory today 			every: (CalendarDuration weeks: 1) 			detect: [:date | date isUSFederalHoliday]			ifNone: ['No collisions with any holidays']}"	self startingFrom: start every: period		do: [:time | (predicate value: time) ifTrue: [^time]].	^unsatisfiedAction value</body><body package="Chronos-Duration" selector="startingFrom:every:do:">startingFrom: start every: durationStep do: block1 	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding the given durational &lt;period&gt; to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	"EXAMPLE: Show the date of each day for a week, starting with today:		{Transcript cr.		(CalendarDuration weeks: 1) 			startingFrom: DateFactory today 			every: (CalendarDuration days: 1) 			do: [:date | Transcript cr; show: (date printStringUsing: #verbose)]}"	start to: self + start every: durationStep do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:inject:into:">startingFrom: start every: period inject: initialValue into: mapper 	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding the given durational &lt;period&gt; to the preceding point-in-time in the sequence, evaluate &lt;mapper&gt; with the following arugments (labelled `a` and `b,` with `a` being the first and `b` the second argument): a) the given &lt;initialValue&gt; in the case of the first evaluation, but otherwise the value resulting from the previous evaluation of &lt;mapper&gt;, and b) each successive point-in-time (in the monotonic sequence as specified.) Answer the value resulting from the last evaluation of &lt;mapper&gt;--unless there were no such evaluations, in which case answer &lt;initialValue&gt;. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	"EXAMPLE: Count the number of weekend days for the next year, starting with today:		{(CalendarDuration years: 1) 			startingFrom: DateFactory today 			every: (CalendarDuration days: 1) 			inject: 0 			into: [:result :date | 				date isWeekendDay 					ifTrue: [result + 1] 					ifFalse: [result]]}"	| value |	value := initialValue.	self startingFrom: start every: period		do: [:time | value := mapper value: value value: time].	^value</body><body package="Chronos-Duration" selector="startingFrom:every:select:">startingFrom: start every: period select: selector 	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding the given durational &lt;period&gt; to the preceding point-in-time in the sequence, do the following: 1) apply &lt;selector&gt; as a predicate test, with each successive point-in-time (in the monotonic sequence as specified) as the argument, and 2) for each point-in-time in the mononotic sequence for which the aforesaid evaluation results in the value true, add the evaluated argument to a sequential collection. When all the moments (in the monotonic sequence as specified) have been evaluated, answer the sequential collection (containing all--and only--those moments in the specified monotonic sequence that satisfied the predicate test represented by &lt;selector&gt;.) (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	"EXAMPLE: For a weekly recurring event, starting from today, compute all the days over the next year where the event would coincide with any US Federal Holiday (if any--and if not, try using some day other than today):		{(CalendarDuration years: 1) 			startingFrom: DateFactory today 			every: (CalendarDuration weeks: 1) 			select: [:date | date isUSFederalHoliday]}"	| list |	list := SequenceFactory new.	self startingFrom: start every: period		do: [:time | (selector value: time) ifTrue: [list add: time]].	^list</body><body package="Chronos-Duration" selector="startingFrom:every:select:thenCollect:">startingFrom: start every: period select: selector thenCollect: mapper 	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding the given durational &lt;period&gt; to the preceding point-in-time in the sequence, do the following: 1) apply &lt;selector&gt; as a predicate test, with each successive point-in-time (in the monotonic sequence as specified) as the argument, and 2) for each point-in-time in the mononotic sequence for which the aforesaid evaluation results in the value true, add to a sequential collection the result of evaluating &lt;mapper&gt; with that point-in-time as the argument. When all the moments (in the monotonic sequence as specified) have been evaluated, and all the ones that satisfied the predicate test (as implemented by &lt;selector&gt;) have been added to a sequential collenction, answer the sequential collection. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	"EXAMPLE: For a weekly recurring event, starting from today, for each day over the next year where the event would coincide with any US Federal Holiday, compute the day's date and it's associated holiday (if any--and if not, try using some day other than today):		{(CalendarDuration years: 1) 			startingFrom: DateFactory today 			every: (CalendarDuration weeks: 1) 			select: [:date | date isUSFederalHoliday]			thenCollect: [:holiday | 				holiday-&gt;(holiday annualDateSemanticKeyFrom: SemanticDatePolicy unitedStates ifNone: [])]}"	| list |	list := SequenceFactory new.	self startingFrom: start every: period		do: [:time | (selector value: time) ifTrue: [list add: (mapper value: time)]].	^list</body></methods><methods><class-id>Chronos.Durational</class-id> <category>enumerating-common durations</category><body package="Chronos-Duration" selector="startingFrom:every:calendarDaysDo:">startingFrom: start every: count calendarDaysDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; calendar days (which may or may not contain exactly 86400 seconds) to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class calendarDurationFactory  days: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:daysDo:">startingFrom: start every: count daysDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; days to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class days: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:hoursDo:">startingFrom: start every: count hoursDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; hours to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class hours: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:minutesDo:">startingFrom: start every: count minutesDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; minutes to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class minutes: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:monthsDo:">startingFrom: start every: count monthsDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; months to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class calendarDurationFactory  months: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:nonCalendarDaysDo:">startingFrom: start every: count nonCalendarDaysDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; calendar days (each of which must contain exactly 86400 seconds) to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class durationFactory days: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:quartersDo:">startingFrom: start every: count quartersDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; quarters to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class calendarDurationFactory  quarters: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:secondsDo:">startingFrom: start every: count secondsDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; seconds to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class seconds: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:weeksDo:">startingFrom: start every: count weeksDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; weeks to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class weeks: count) do: block1</body><body package="Chronos-Duration" selector="startingFrom:every:yearsDo:">startingFrom: start every: count yearsDo: block1	"For every point-in-time in a monotonic sequence of moments contained by the left-closed, right-open interval `[&lt;start&gt;, &lt;start&gt; + self)`, such that the initial moment is the point-in-time specified by &lt;start&gt;, and such that each succeeding moment is the point-in-time computed by adding &lt;count&gt; years to the preceding point-in-time in the sequence, evaluate &lt;block1&gt; with each successive point-in-time (in the monotonic sequence as specified) as the argument. (Note: a closed interval is one that contains its end-points.  An open interval is one that does not contain its endpoints.  A left-closed, right-open interval contains its left endpoint, but not its right endpoint.)"	self startingFrom: start every: (self class calendarDurationFactory  years: 1) do: block1</body></methods><methods><class-id>Chronos.Durational</class-id> <category>converting</category><body package="Chronos-Duration" selector="abs">abs	"Answer a new (immutable) value of the receiver's type whose temporal extent is the absolute value of that of the receiver's." 	"Specified and required by the ANSI-Smalltalk Standard."	^self copy		beAbsolute;		beImmutable</body><body package="Chronos-Duration" selector="asCalendarDuration">asCalendarDuration	^self asCalendricalMutable beImmutable</body><body package="Chronos-Duration" selector="asCivilDuration">asCivilDuration	^self asSubDayMutable beImmutable</body><body package="Chronos-Duration" selector="asDays">asDays	"Answer the integer number of days (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)"	self yearsAndMonthsMustBeZero.	^self days + (self secondsSinceStartOfDay quo: SecondsPerDay)</body><body package="Chronos-Duration" selector="asFractionalDays">asFractionalDays	"Answer the number of days (including any fractional part) represented by the receiver's temporal extent."	^self asDays</body><body package="Chronos-Duration" selector="asFractionalSeconds">asFractionalSeconds	"Answer the number of seconds (including any fractional part) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^ScaledDecimal 		numerator: self asNanoseconds		denominator: NanosecondsPerSecond		scale: 9</body><body package="Chronos-Duration" selector="asHours">asHours	"Answer the integer number of hours (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^self asSeconds quo: SecondsPerHour</body><body package="Chronos-Duration" selector="asMicroseconds">asMicroseconds	"Answer the integer number of microseconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	self yearsAndMonthsMustBeZero.	^((self nanosecondsSinceSecond bitShift: -3) // 125) + ((self asSeconds bitShift: 6) * 15625)</body><body package="Chronos-Duration" selector="asMilliseconds">asMilliseconds	"Answer the integer number of milliseconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	self yearsAndMonthsMustBeZero.	^((self nanosecondsSinceSecond bitShift: -6) // 15625) + ((self asSeconds * 125)  bitShift: 3)</body><body package="Chronos-Duration" selector="asMinutes">asMinutes	"Answer the integer number of minutes (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^self asSeconds quo: SecondsPerMinute</body><body package="Chronos-Duration" selector="asNanoseconds">asNanoseconds	"Answer the integer number of nanoseconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^self asSeconds * NanosecondsPerSecond</body><body package="Chronos-Duration" selector="asSeconds">asSeconds	"Answer the integer number of seconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	self yearsAndMonthsMustBeZero.	^self days * SecondsPerDay</body><body package="Chronos-Duration" selector="asTimeperiodStartingAt:">asTimeperiodStartingAt: startPoint	"Answer a Timeperiod whose starting value is &lt;initialMoment&gt; (a CalendricalCoordinate) and whose duration is the receiver."	^startPoint withDuration: self</body><body package="Chronos-Duration" selector="asTimezone">asTimezone	"(CivilDuration hours: -8) asTimezone"	self yearsAndMonthsMustBeZero.	^ChronosTimezone offset: (DurationFactory days: self days hours: self hours minutes: self minutes seconds: self seconds nanoseconds: self nanosecondsSinceSecond)</body><body package="Chronos-Duration" selector="asWeeks">asWeeks	"Answer the integer number of weeks (truncated towards zero, 1 week = 7 days) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)"	^self asDays quo: (DaysPerWeek * SecondsPerDay)</body><body package="Chronos-Duration" selector="negated">negated	"Answer a new (immutable) value of the receiver's type whose temporal extent is the negation (additive inverse) of that of the receiver's." 	"Specified and required by the ANSI-Smalltalk Standard."	^self copy		beNegated;		beImmutable</body></methods><methods><class-id>Chronos.Durational</class-id> <category>private</category><body package="Chronos-Duration" selector="asCalendricalMutable">asCalendricalMutable	^self copy</body><body package="Chronos-Duration" selector="asCivilSubDayMutable">asCivilSubDayMutable	^self subclassResponsibility</body><body package="Chronos-Duration" selector="asSubDayMutable">asSubDayMutable	^self subclassResponsibility</body><body package="Chronos-Duration" selector="yearsAndMonthsMustBeZero">yearsAndMonthsMustBeZero	(self months isZero and: [self years isZero]) ifFalse: [self signalError: 'Illegal operation: Both years and months must be zero'].</body><body package="Chronos-Duration" selector="yearsAndMonthsMustBeZeroOrNegative">yearsAndMonthsMustBeZeroOrNegative	(self months &lt;= 0 and: [self years &lt;= 0]) ifFalse: [self signalError: 'Illegal operation: Both years and months must be less than or equal to zero'].</body><body package="Chronos-Duration" selector="yearsAndMonthsMustBeZeroOrPositive">yearsAndMonthsMustBeZeroOrPositive	(self months &gt;= 0 and: [self years &gt;= 0]) ifFalse: [self signalError: 'Illegal operation: Both years and months must be greater than or equal to zero'].</body></methods><methods><class-id>Chronos.Durational</class-id> <category>initialize-release</category><body package="Chronos-Duration" selector="setWeeks:">setWeeks: w	"Set the component of the receiver's duration vector that represents its temporal extent in days to the value &lt;w&gt; * 7. Fail if the receiver is not mutable."	self setDays: (w * DaysPerWeek)</body></methods><methods><class-id>Chronos.Durational</class-id> <category>private-arithmetic</category><body package="Chronos-Duration" selector="addedToInfiniteDuration:">addedToInfiniteDuration: anInfiniteDuration	^anInfiniteDuration</body><body package="Chronos-Duration" selector="addedToTimePeriod:">addedToTimePeriod: aTimeperiod	^aTimeperiod asTimeperiodStartingAt: aTimeperiod start + self</body><body package="Chronos-Duration" selector="subtractedFromInfiniteDuration:">subtractedFromInfiniteDuration: anInfiniteDuration	^anInfiniteDuration</body></methods><methods><class-id>Chronos.Durational</class-id> <category>private-comparing</category><body package="Chronos-Duration" selector="compareToInfiniteDuration:">compareToInfiniteDuration: anInfiniteDuration	^anInfiniteDuration negative		ifTrue: [-1]		ifFalse: [1]</body></methods><methods><class-id>Chronos.Durational class</class-id> <category>accessing</category><body package="Chronos-Duration" selector="zero">zero	"Answer a Durational value that represent a temporal extent of zero."	"Specified and required by the ANSI-Smalltalk Standard."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.Durational class</class-id> <category>deprecated</category><body package="Chronos-Duration" selector="quantum">quantum	"Answer a Durational value that specifies the quantum of temporal resolution of instances of the receiver (i.e., the minimum amount by which the temporal extent represented by an instance may differ from that of any other.)"	^NanosecondDuration</body></methods><methods><class-id>Chronos.Durational class</class-id> <category>instance creation</category><body package="Chronos-Duration" selector="days:">days: d	"Answer an immutable durational value representing a temporal extent of &lt;d&gt; days."	"{ScientificDuration days: 3/4}"	"{(ScientificDuration days: (AnsiStandardCalendarClock now fractionalDaysSinceEpoch)) asDateAndTime}"	^self new		setDays: d;		beImmutable</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextDurationalFrom: stream</body><body package="Chronos-Duration" selector="weeks:">weeks: w	"Answer an immutable durational value representing a temporal extent of &lt;w&gt; weeks."	"{ScientificDuration weeks: 1.5}"	"{CalendarDuration weeks: 1.5}"	^self new		setWeeks: w;		beImmutable</body></methods><methods><class-id>Chronos.Durational class</class-id> <category>private</category><body package="Chronos-Duration" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body></methods><methods><class-id>Chronos.Durational class</class-id> <category>utilities</category><body package="Chronos-Duration" selector="toRun:">toRun: timedBlock	"Evaluate the zero-argument block &lt;timedBlock&gt;. Answer a Durational value that represents the duration (extent) of time required for the execution."	^self nanoseconds: (ChronosSystemClock current nanosecondsToRun: timedBlock)	"Date/Time Benchmarks:"	"{Duration toRun: [1000000 timesRepeat: [Gregorian clock now]]}"	"{Duration toRun: [1000000 timesRepeat: [Timestamp now]]}"	"{Duration toRun: [1000000 timesRepeat: [Gregorian clock dateToday]]}"	"{Duration toRun: [1000000 timesRepeat: [Date today]]}"	"{Duration toRun: [1000000 timesRepeat: [Gregorian clock utTimeOfDayNow]]}"	"{Duration toRun: [1000000 timesRepeat: [Gregorian clock timeOfDayNowToTheSecond]]}"	"{Duration toRun: [1000000 timesRepeat: [Time now]]}"	"1969-07-20T10:17:40 UTC is the official time of the Apollo-11 lunar landing."	"{Duration toRun: [1000000 timesRepeat: [DateSpec year: 1969 month: 7 day: 20]]}"	"{Duration toRun: [1000000 timesRepeat: [Date newDay: 20 monthNumber: 7 year: 1969]]}"	"{Duration toRun: [1000000 timesRepeat: [DateFactory year: 1969 month: 7 day: 20]]}"  	"{Duration toRun: [1000000 timesRepeat: [DateSpec daysSinceEpoch: 718997]]}"	"{Duration toRun: [1000000 timesRepeat: [DateFactory daysSinceEpoch:  718997]]}" 	"{Duration toRun: [1000000 timesRepeat: [Date fromDays: 25037]]}" 	"{Duration toRun: [1000000 timesRepeat: [Timestamp new year: 1969; month: 7; day: 20; hour: 5; minute: 17; second: 40; millisecond: 0]]}"	"{Duration toRun: [1000000 timesRepeat: 		[(DateAndTimeSpec basicNew) 			setYear: 1969 monthOrdinal: 7 dayOfMonthOrdinal: 20 calendar: Gregorian;  			setHour: 5 minute: 17 second: 40; 			setNanosecondsSinceSecond: 0]]}"	"{Duration toRun: [1000000 timesRepeat: [Timestamp fromDate: (Date newDay: 20 monthNumber: 7 year: 1969) andTime: (Time fromSeconds: 19060)]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory fromNative: (Timestamp new year: 1969; month: 7; day: 20; hour: 5; minute: 17; second: 40; millisecond: 0)]]}"	"{Duration toRun: [1000000 timesRepeat: [(DateAndTimeSpec year: 1969 month: 7 day: 20 hour: 5 minute: 17 second: 40 nanosecond: 0) asNative]]}"	"{Duration toRun: [1000000 timesRepeat: [(DateAndTimeSpec year: 1969 month: 7 day: 20 seconds: 19060 nanoseconds: 0) asNative]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeSpec year: 1969 month: 7 day: 20 hour: 5 minute: 17 second: 40 nanosecond: 0]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeSpec year: 1969 month: 7 day: 20 seconds: 19060 nanoseconds: 0]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory nominalYear: 1969 day: 201 seconds: 19060 nanoseconds: 0]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory nominalYear: 1969 month: 7 day: 20 seconds: 19060 nanoseconds: 0]]}"	"{| ut |		ut := Timezone universal.	Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory utYear: 1969 month: 7 day: 20 seconds: 37060 nanoseconds: 0 timeZone: ut]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory utYear: 1969 month: 7 day: 20 seconds: 37060 nanoseconds: 0]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory year: 1969 month: 7 day: 20 seconds: 11860 nanoseconds: 0]]}"	"{| tz |	tz := ChronosTimezone at: 'America/Chicago'.	Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory year: 1969 month: 7 day: 20  seconds: 19060 nanoseconds: 0 timeZone: tz]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeSpec secondsSinceEpoch: 62121359860]]}" 	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory nominalSecondsSinceEpoch: 62121359860]]}"	"{Duration toRun: [1000000 timesRepeat: [DateAndTimeFactory utSecondsSinceEpoch: 62121377860]]}"	"{Duration toRun: [1000000 timesRepeat: [Timestamp fromSeconds: 2163215860]]}" 	"{Duration toRun: [100000 timesRepeat: [Gregorian clock dateToday localePrintString]]}"	"{Duration toRun: [100000 timesRepeat: [Date today printString]]}"	"{Duration toRun: [100000 timesRepeat: [Gregorian clock timeOfDayNowToTheSecond localePrintString]]}"	"{Duration toRun: [100000 timesRepeat: [Time  now printString]]}"	"{Duration toRun: [100000 timesRepeat: [Gregorian clock now localePrintString]]}"	"{Duration toRun: [100000 timesRepeat: [Timestamp now printString]]}"	"{| date |	date := Gregorian clock dateToday.	Duration toRun: [1000000 timesRepeat: [date daysSinceEpoch]]}"	"{| dateAndTime |	dateAndTime := Gregorian clock now.	Duration toRun: [1000000 timesRepeat: [dateAndTime secondsSinceEpoch]]}"	"{| date |	date := Gregorian clock dateToday.	Duration toRun: [1000000 timesRepeat: [date year; month; day]]}"	"{| dateAndTime |	dateAndTime := Gregorian clock now.	Duration toRun: [1000000 timesRepeat: [dateAndTime year; month; day]]}"</body></methods><methods><class-id>Chronos.ComparableDuration</class-id> <category>comparing</category><body package="Chronos-Duration" selector="&lt;">&lt; aMagnitude 	"Answer whether the receiver is less than the argument."	"Specified and required by the ANSI-Smalltalk Standard."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &lt; 0]</body><body package="Chronos-Duration" selector="&lt;=">&lt;= aMagnitude 	"Answer whether the receiver is less than or equal to the argument."	"Specified and required by the ANSI-Smalltalk Standard."	^(self &gt; aMagnitude) not</body><body package="Chronos-Duration" selector="&gt;">&gt; aMagnitude 	"Answer whether the receiver is greater than the argument."	"Specified and required by the ANSI-Smalltalk Standard."	| comparison |	comparison := self compareTo: aMagnitude.	^comparison == nil		ifTrue: [self signalError: 'Cannot compare a ', aMagnitude class printString, ' to a ', self class printString]		ifFalse: [comparison &gt; 0]</body><body package="Chronos-Duration" selector="&gt;=">&gt;= aMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	"Specified and required by the ANSI-Smalltalk Standard."	^(self &lt; aMagnitude) not</body><body package="Chronos-Duration" selector="between:and:">between: min and: max 	"Answer whether the receiver is less than or equal to the argument, max,	and greater than or equal to the argument, min."	^self &gt;= min and: [self &lt;= max]</body><body package="Chronos-Duration" selector="max:">max: aMagnitude 	"Answer the receiver or the argument, whichever has the greater magnitude."	self &gt; aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]</body><body package="Chronos-Duration" selector="min:">min: aMagnitude 	"Answer the receiver or the argument, whichever has the lesser magnitude."	self &lt; aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]</body></methods><methods><class-id>Chronos.ComparableDuration</class-id> <category>private-comparing</category><body package="Chronos-Duration" selector="compareToInfiniteDuration:">compareToInfiniteDuration: anInfiniteDuration	^anInfiniteDuration negative		ifTrue: [-1]		ifFalse: [1]</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>arithmetic</category><body package="Chronos-Duration" selector="*">* aNumber	"Specified and required by the ANSI-Smalltalk Standard."	^aNumber negative 		ifTrue: [self negated]		ifFalse: [self]</body><body package="Chronos-Duration" selector="+">+ aDurationOrTemporalCoordinate	"Specified and required by the ANSI-Smalltalk Standard."	^aDurationOrTemporalCoordinate addedToInfiniteDuration: self</body><body package="Chronos-Duration" selector="-">- aDurationOrTemporalCoordinate	"Specified and required by the ANSI-Smalltalk Standard."	^aDurationOrTemporalCoordinate subtractedFromInfiniteDuration: self</body><body package="Chronos-Duration" selector="/">/ aDurationOrNumber 	"Specified and required by the ANSI-Smalltalk Standard."	^aDurationOrNumber negative ifTrue: [self negated] ifFalse: [self]</body><body package="Chronos-Duration" selector="addingDays:">addingDays: addedDays	^self</body><body package="Chronos-Duration" selector="addingHours:">addingHours: addedHours	^self</body><body package="Chronos-Duration" selector="addingHours:minutes:">addingHours: addedHours minutes: addedMinutes	^self</body><body package="Chronos-Duration" selector="addingHours:minutes:seconds:">addingHours: addedHours minutes: addedMinutes seconds: addedSeconds	^self</body><body package="Chronos-Duration" selector="addingHours:minutes:seconds:nanoseconds:">addingHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds 	^self</body><body package="Chronos-Duration" selector="addingMinutes:">addingMinutes: addedMinutes	^self</body><body package="Chronos-Duration" selector="addingMonths:">addingMonths: addedMonths	^self</body><body package="Chronos-Duration" selector="addingSeconds:">addingSeconds: addedSeconds 	^self</body><body package="Chronos-Duration" selector="addingSeconds:nanoseconds:">addingSeconds: addedSeconds nanoseconds: addedNanoseconds 	^self</body><body package="Chronos-Duration" selector="addingYears:">addingYears: addedYears	^self</body><body package="Chronos-Duration" selector="addingYears:months:">addingYears: addedYears months: addedMonths	^self</body><body package="Chronos-Duration" selector="addingYears:months:days:">addingYears: addedYears months: addedMonths days: addedDays	^self</body><body package="Chronos-Duration" selector="addingYears:months:days:hours:minutes:seconds:">addingYears: addedYears months: addedMonths days: addedDays hours: addedHours minutes: addedMinutes seconds: addedSeconds	^self</body><body package="Chronos-Duration" selector="addingYears:months:days:hours:minutes:seconds:nanoseconds:">addingYears: addedYears months: addedMonths days: addedDays hours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds	^self</body><body package="Chronos-Duration" selector="addingYears:months:days:seconds:nanoseconds:">addingYears: addedYears months: addedMonths days: addedDays seconds: addedSeconds nanoseconds: addedNanoseconds	^self</body><body package="Chronos-Duration" selector="subtractingDays:">subtractingDays: subtractedDays	^self</body><body package="Chronos-Duration" selector="subtractingHours:">subtractingHours: subtractedHours	^self</body><body package="Chronos-Duration" selector="subtractingHours:minutes:">subtractingHours: subtractedHours minutes: subtractedMinutes	^self</body><body package="Chronos-Duration" selector="subtractingHours:minutes:seconds:">subtractingHours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds	^self</body><body package="Chronos-Duration" selector="subtractingHours:minutes:seconds:nanoseconds:">subtractingHours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds nanoseconds: subtractedNanoseconds 	^self</body><body package="Chronos-Duration" selector="subtractingMinutes:">subtractingMinutes: subtractedMinutes	^self</body><body package="Chronos-Duration" selector="subtractingMonths:">subtractingMonths: subtractedMonths	^self</body><body package="Chronos-Duration" selector="subtractingSeconds:">subtractingSeconds: subtractedSeconds	^self</body><body package="Chronos-Duration" selector="subtractingSeconds:nanoseconds:">subtractingSeconds: subtractedSeconds nanoseconds: subtractedNanoseconds 	^self</body><body package="Chronos-Duration" selector="subtractingYears:">subtractingYears: subtractedYears	^self</body><body package="Chronos-Duration" selector="subtractingYears:months:">subtractingYears: subtractedYears months: subtractedMonths	^self</body><body package="Chronos-Duration" selector="subtractingYears:months:days:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays	"Answer a new (immutable) value of the receiver's type whose temporal extent is &lt;addedYears&gt; years, &lt;addedMonths&gt; months, &lt;addedDays&gt; days, &lt;addedSeconds&gt; seconds and &lt;addedNanoseconds&gt; nanoseconds less than that of the receiver's." 	^self</body><body package="Chronos-Duration" selector="subtractingYears:months:days:hours:minutes:seconds:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays hours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds	^self</body><body package="Chronos-Duration" selector="subtractingYears:months:days:hours:minutes:seconds:nanoseconds:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays hours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds nanoseconds: subtractedNanoseconds	^self</body><body package="Chronos-Duration" selector="subtractingYears:months:days:seconds:nanoseconds:">subtractingYears: subtractedYears months: subtractedMonths days: subtractedDays seconds: subtractedSeconds nanoseconds: subtractedNanoseconds	^self</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>initialize-release</category><body package="Chronos-Duration" selector="addDays:">addDays: addedDays	"Do nothing"</body><body package="Chronos-Duration" selector="addHours:">addHours: addedHours	"Do nothing"</body><body package="Chronos-Duration" selector="addHours:minutes:">addHours: addedHours minutes: addedMinutes	"Do nothing"</body><body package="Chronos-Duration" selector="addHours:minutes:seconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds	"Do nothing"</body><body package="Chronos-Duration" selector="addHours:minutes:seconds:nanoseconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds	"Do nothing"</body><body package="Chronos-Duration" selector="addMinutes:">addMinutes: addedMinutes	"Do nothing"</body><body package="Chronos-Duration" selector="addMonths:">addMonths: addedMonths	"Do nothing"</body><body package="Chronos-Duration" selector="addSeconds:">addSeconds: addedSeconds	"Do nothing"</body><body package="Chronos-Duration" selector="addSeconds:nanoseconds:">addSeconds: addedSeconds nanoseconds: addedNanoseconds	"Do nothing"</body><body package="Chronos-Duration" selector="addYears:">addYears: addedYears	"Do nothing"</body><body package="Chronos-Duration" selector="addYears:months:">addYears: addedYears months: addedMonths	"Do nothing"</body><body package="Chronos-Duration" selector="addYears:months:days:">addYears: addedYears months: addedMonths days: addedDays	"Do nothing"</body><body package="Chronos-Duration" selector="beNegative">beNegative	self assertMutability.	extent := PassportInfinity negative</body><body package="Chronos-Duration" selector="bePositive">bePositive	self assertMutability.	extent := PassportInfinity positive</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>comparing</category><body package="Chronos-Duration" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	"Specified and required by the ANSI-Smalltalk Standard."	self == aMagnitude ifTrue: [^true].	^[aMagnitude isEqualToInfiniteDuration: self]		on: MessageNotUnderstood		do: [:ex | 			(ex receiver == aMagnitude and: [ex message selector == #isEqualToInfiniteDuration:])				ifTrue: [ex return: false]				ifFalse: [ex pass]]</body><body package="Chronos-Duration" selector="compareTo:">compareTo: aDuration	"Compare the value of the receiver to that of &lt;aDuration&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aDuration&gt; are the same.)"	self == aDuration ifTrue: [^0].	^[^aDuration compareToInfiniteDuration: self]			on: MessageNotUnderstood		do: [:ex | (ex receiver == aDuration and: [#compareToInfiniteDuration: == ex message selector]) 					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-Duration" selector="hash">hash	^extent hash</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>converting</category><body package="Chronos-Duration" selector="abs">abs	^extent negative ifTrue: [InfiniteDuration positive] ifFalse: [self]</body><body package="Chronos-Duration" selector="asCalendarDuration">asCalendarDuration	^self</body><body package="Chronos-Duration" selector="asCivilDuration">asCivilDuration	^self</body><body package="Chronos-Duration" selector="asDays">asDays	"Answer the integer number of days (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)"	^extent</body><body package="Chronos-Duration" selector="asFractionalDays">asFractionalDays	"Answer the number of days (including any fractional part) represented by the receiver's temporal extent."	^extent</body><body package="Chronos-Duration" selector="asFractionalSeconds">asFractionalSeconds	"Answer the number of seconds (including any fractional part) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^extent</body><body package="Chronos-Duration" selector="asHours">asHours	"Answer the integer number of hours (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^extent</body><body package="Chronos-Duration" selector="asMicroseconds">asMicroseconds	"Answer the integer number of microseconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^extent</body><body package="Chronos-Duration" selector="asMilliseconds">asMilliseconds	"Answer the integer number of milliseconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^extent</body><body package="Chronos-Duration" selector="asMinutes">asMinutes	"Answer the integer number of minutes (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^extent</body><body package="Chronos-Duration" selector="asNanoseconds">asNanoseconds	"Answer the integer number of nanoseconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	^extent</body><body package="Chronos-Duration" selector="asSeconds">asSeconds	"Answer the integer number of seconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^extent</body><body package="Chronos-Duration" selector="asWeeks">asWeeks	"Answer the integer number of weeks (truncated towards zero, 1 week = 7 days) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)"	^extent</body><body package="Chronos-Duration" selector="negated">negated	^InfiniteDuration polarity: extent negative</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>testing</category><body package="Chronos-Duration" selector="calendarPeriodsAreZero">calendarPeriodsAreZero	^false</body><body package="Chronos-Duration" selector="isInfinite">isInfinite	^true</body><body package="Chronos-Duration" selector="isZero">isZero	^false</body><body package="Chronos-Duration" selector="negative">negative	"Answer whether the receiver represents a temporal extent whose magnitude is negative."	"Specified and required by the ANSI-Smalltalk Standard."	^extent negative</body><body package="Chronos-Duration" selector="nonCalendarPeriodsAreZero">nonCalendarPeriodsAreZero	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is zero."	^false</body><body package="Chronos-Duration" selector="nonCalendarPeriodsNegative">nonCalendarPeriodsNegative	"Answer whether the non-calendrical temporal extent (seconds/nanoseconds) of the receiver is negative."	^extent negative</body><body package="Chronos-Duration" selector="nonCalendarPeriodsPositive">nonCalendarPeriodsPositive	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is positive."	^extent positive</body><body package="Chronos-Duration" selector="positive">positive	"Answer whether the receiver represents a temporal extent whose magnitude is positive (or zero.)"	"Specified and required by the ANSI-Smalltalk Standard."	^extent positive</body><body package="Chronos-Duration" selector="subsecondsAreZero">subsecondsAreZero	^false</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>accessing</category><body package="Chronos-Duration" selector="days">days	"Answer the integer number of days (truncated towards zero) represented by the receiver, independent of the number of years, months or seconds it may represent."	"Specified and required by the ANSI-Smalltalk Standard."	^extent</body><body package="Chronos-Duration" selector="hours">hours	"Answer the integer number of hours-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in hours after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^extent</body><body package="Chronos-Duration" selector="microsecondsSinceSecond">microsecondsSinceSecond	"Answer the integer number of microseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in microseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^extent</body><body package="Chronos-Duration" selector="millisecondsSinceSecond">millisecondsSinceSecond	"Answer the integer number of milliseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in milliseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^extent</body><body package="Chronos-Duration" selector="minutes">minutes	"Answer the integer number of minutes-since-the-hour (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in minutes after subtracting from its temporal extent integer number of hours (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^extent</body><body package="Chronos-Duration" selector="months">months	"Answer the integer number of months (truncated towards zero) represented by the receiver, independent of the number of years or seconds it may represent."	^extent</body><body package="Chronos-Duration" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	"Answer the integer number of nanoseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in nanoseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^extent</body><body package="Chronos-Duration" selector="resolutionQuantum">resolutionQuantum	^extent negative ifTrue: [InfiniteDuration positive] ifFalse: [self]</body><body package="Chronos-Duration" selector="seconds">seconds	"Answer the integer number of seconds-since-the-minute (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of minutes (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^extent</body><body package="Chronos-Duration" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	"Answer the integer number of seconds-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.) Assume an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^extent</body><body package="Chronos-Duration" selector="weeks">weeks	"Answer the integer number of weeks (truncated towards zero) represented by the receiver, solely as a function of the number of days it represents, and independent of the number of months and/or years it may represent."	^extent</body><body package="Chronos-Duration" selector="years">years	"Answer the integer number of years (truncated towards zero) represented by the receiver, independent of the number of months or seconds it may represent."	^extent</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>private-comparing</category><body package="Chronos-Duration" selector="compareToDuration:">compareToDuration: aDuration	^extent negative		ifTrue: [1]		ifFalse: [-1]</body><body package="Chronos-Duration" selector="compareToInfiniteDuration:">compareToInfiniteDuration: anInfiniteDuration	^anInfiniteDuration negative		ifTrue: [self negative ifTrue: [0] ifFalse: [-1]]		ifFalse: [self negative ifTrue: [1] ifFalse: [0]]</body><body package="Chronos-Duration" selector="isEqualToInfiniteDuration:">isEqualToInfiniteDuration: anInfiniteDuration	^anInfiniteDuration negative == self negative</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>private-arithmetic</category><body package="Chronos-Duration" selector="addedToCalendarDuration:">addedToCalendarDuration: aCalendarDuration	^self</body><body package="Chronos-Duration" selector="addedToCivilDuration:">addedToCivilDuration: aCivilDuration	^self</body><body package="Chronos-Duration" selector="addedToDuration:">addedToDuration: aDuration	^self</body><body package="Chronos-Duration" selector="addedToTemporalInterval:">addedToTemporalInterval: aTemporalInterval 	^InfiniteTimepoint polarity: self positive</body><body package="Chronos-Duration" selector="subtractedFromCalendarDuration:">subtractedFromCalendarDuration: aCalendarDuration	^self negated</body><body package="Chronos-Duration" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aCivilDuration	^self negated</body><body package="Chronos-Duration" selector="subtractedFromDuration:">subtractedFromDuration: aDuration	^self negated</body><body package="Chronos-Duration" selector="subtractedFromTemporalInterval:">subtractedFromTemporalInterval: aTemporalInterval 	^InfiniteTimepoint polarity: self negative</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>private</category><body package="Chronos-Duration" selector="asCivilSubDayMutable">asCivilSubDayMutable	^self shouldNotImplement</body><body package="Chronos-Duration" selector="asSubDayMutable">asSubDayMutable	^self shouldNotImplement</body></methods><methods><class-id>Chronos.InfiniteDuration</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy 	aChronosPrintPolicy printInfiniteDuration: self on: stream</body></methods><methods><class-id>Chronos.InfiniteDuration class</class-id> <category>unit test</category><body package="Chronos-Duration" selector="testDoIts">testDoIts	"InfiniteDuration positive = InfiniteDuration positive	InfiniteDuration positive = InfiniteDuration negative	InfiniteDuration negative = InfiniteDuration positive	InfiniteDuration negative = InfiniteDuration negative	InfiniteDuration negative = Duration zero	InfiniteDuration negative = Duration zero	Duration zero = InfiniteDuration negative	Duration zero = InfiniteDuration negative	InfiniteDuration positive &gt; InfiniteDuration positive	InfiniteDuration positive &gt; InfiniteDuration negative	InfiniteDuration negative &gt; InfiniteDuration positive	InfiniteDuration negative &gt; InfiniteDuration negative	InfiniteDuration positive &gt; Duration zero	InfiniteDuration negative &gt; Duration zero	Duration zero &gt; InfiniteDuration positive	Duration zero &gt; InfiniteDuration negative	Duration zero + InfiniteDuration positive	Duration zero + InfiniteDuration negative	Duration zero - InfiniteDuration positive	Duration zero - InfiniteDuration negative	InfiniteDuration positive + Duration zero	InfiniteDuration negative + Duration zero	InfiniteDuration positive - Duration zero	InfiniteDuration negative - Duration zero"</body></methods><methods><class-id>Chronos.InfiniteDuration class</class-id> <category>class initialization</category><body package="Chronos-Duration" selector="initialize">initialize	Positive := nil.	Negative := nil</body></methods><methods><class-id>Chronos.InfiniteDuration class</class-id> <category>constants</category><body package="Chronos-Duration" selector="negative">negative	Negative == nil 		ifTrue: 			[Negative := 				(self basicNew)						beNegative;						beImmutable].	^Negative</body><body package="Chronos-Duration" selector="positive">positive	Positive == nil 		ifTrue: 			[Positive := 				(self basicNew)						bePositive;						beImmutable].	^Positive</body><body package="Chronos-Duration" selector="zero">zero	self shouldNotImplement</body></methods><methods><class-id>Chronos.InfiniteDuration class</class-id> <category>instance creation</category><body package="Chronos-Duration" selector="new">new	^self shouldNotImplement</body><body package="Chronos-Duration" selector="polarity:">polarity: polarity	^polarity		ifTrue: [self positive]		ifFalse: [self negative]</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isBound">isBound	"Answer whether the receiver is a bound time zone. A bound time zone is one that defines a single offset/abbreviation tuple, and that conforms to the `BOUND TIMEZONE API` (as defined in the class comment of ChronosTimezone.)"	^true</body><body package="Chronos-TimeZones" selector="isProxyOrStatic">isProxyOrStatic	"Answer whether the receiver is either a proxy time zone or a static time zone."	^true</body><body package="Chronos-TimeZones" selector="isStandardTime">isStandardTime	"Answer whether or not the offset from UT specified by the receiver defines the `standard time` of the time zone represented by the receiver (as opposed to `daylight saving time`, `summer time`, `war time`, 'three-year-long-year-round energy-saving-during-a-crisis time', etc)."	^self offsetFromUT = self stdTimeOffsetFromUT</body><body package="Chronos-TimeZones" selector="isStatic">isStatic	"Answer whether or not the timezone policy (key, offset, name and abbreviation) of the timezone represented by the receiver is invariant, constant and never subject to change or revision.  If the receiver's timezone policy is dynamically redefinable, answer false."	^true</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="abbreviation">abbreviation	"Answer the abbreviation for the timezone represented by the receiver--according to the default locale if possible."	^self commonAbbreviation</body><body package="Chronos-TimeZones" selector="commonAbbreviation">commonAbbreviation	"Answer the common abbreviation for the timezone represented by the receiver."	^self name</body><body package="Chronos-TimeZones" selector="defaultAnnualPolicy">defaultAnnualPolicy	"Answer the AnnuallyRecurringTZPolicy that specifies the time zone rules that are in effect during the current year."	^UntilEndOfYearTimeZoneTransition 		for: self		offsetSeconds: self offsetSecondsFromUT		stdTimeOffsetSeconds: self stdTimeOffsetSecondsFromUT		commonAbbreviation: self commonAbbreviation</body><body package="Chronos-TimeZones" selector="namespaceKey">namespaceKey	^#static</body><body package="Chronos-TimeZones" selector="offsetDelta">offsetDelta	"Answer a Duration that specifies the amount of time to be added to the receiver's standard-time offset from UT in order to compute the receiver's offset from UT when Daylight Saving Time (Summer Time) is in effect."	^ZeroDuration</body><body package="Chronos-TimeZones" selector="offsetDeltaSeconds">offsetDeltaSeconds	"Answer the number of seconds to be added to the receiver's standard-time offset from UT in order to compute the receiver's offset from UT when Daylight Saving Time (Summer Time) is in effect."	^0</body><body package="Chronos-TimeZones" selector="offsetFromUT">offsetFromUT	"Answer a Duration that specifies the receiver's offset from Universal Time (which is defined as the amount of time to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the local time defined by the receiver.)"	^self subclassResponsibility</body><body package="Chronos-TimeZones" selector="offsetSecondsFromUT">offsetSecondsFromUT	"Answer the receiver's offset from Universal Time in seconds (which is defined as the number of seconds to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the local time defined by the receiver.)"	^self offsetFromUT asSeconds</body><body package="Chronos-TimeZones" selector="stdTimeOffsetFromUT">stdTimeOffsetFromUT	"Answer a Duration that specifies the receiver's offset from Universal Time when `standard time` is in effect (which is defined as the amount of time to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^self offsetFromUT</body><body package="Chronos-TimeZones" selector="stdTimeOffsetSecondsFromUT">stdTimeOffsetSecondsFromUT	"Answer the receiver's offset from Universal Time in seconds when `standard time` is in effect (which is defined as the number of seconds to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^self stdTimeOffsetFromUT asSeconds</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-TimeZones" selector="canonicalizeFromLocal:">canonicalizeFromLocal: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time in the local time defined by the receiver, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use Universal Time coordinates instead of local time coordinates.)"	^aDateAndTime canonicalizeFromLocal: self offsetSecondsFromUT nanoseconds: 0</body><body package="Chronos-TimeZones" selector="canonicalizeFromUT:">canonicalizeFromUT: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time using Universal Time coordinates, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use coordinates in the local time defined by the receiver instead of using Universal Time coordinates.)"	^aDateAndTime canonicalizeFromUT: self offsetSecondsFromUT nanoseconds: 0</body><body package="Chronos-TimeZones" selector="netSecondsAfterAddingOffsetFromUTToSeconds:nanosecondsSinceSecond:">netSecondsAfterAddingOffsetFromUTToSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from adding the receiver's offset from UT to the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^seconds + self offsetSecondsFromUT</body><body package="Chronos-TimeZones" selector="netSecondsAfterSubtractingOffsetFromUTFromSeconds:nanosecondsSinceSecond:">netSecondsAfterSubtractingOffsetFromUTFromSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from subtracting the receiver's offset from UT from the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^seconds - self offsetFromUT asSeconds</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="asStatic">asStatic	^self</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processBoundTimezone: self</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>queries</category><body package="Chronos-TimeZones" selector="binding">binding	"Answer the bound timezone referenced by the receiver.  If there is none, answer nil."	^self</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>printing</category><body package="Chronos-TimeZones" selector="offsetString">offsetString	"Answer a String that describes the receiver's offset from UT in ANSI format."	"(Duration hours: -7) asTimezone offsetString"	| stream |	stream := (String new: 10) writeStream.	self printOffsetOn: stream.	^stream contents</body><body package="Chronos-TimeZones" selector="printOffsetOn:">printOffsetOn: stream	ChronosPrintPolicy ansiStandard printTimeZoneOffset: self offsetFromUT on: stream.</body><body package="Chronos-TimeZones" selector="printZuluNotationOn:">printZuluNotationOn: stream	stream nextPut: $Z.	self printOffsetOn: stream.</body><body package="Chronos-TimeZones" selector="zuluNotation">zuluNotation	"Answer a String that describes the receiver's offset from UT in `Zulu Notation.`"	"(Duration hours: -7) asTimezone zuluNotation"	| stream |	stream := (String new: 10) writeStream.	self printZuluNotationOn: stream.	^stream contents</body></methods><methods><class-id>Chronos.BoundTimezone</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="convertGMT:do:">convertGMT: utSecondsSinceST80Epoch do: block2 	"{| tz |	tz := ChronosTimezone offset: -6 hours.	tz convertGMT: Time secondClock do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]}"	"{| tz |	tz := ChronosTimezone offset: -6 hours.	[1000000 timesRepeat: [tz convertGMT: Time secondClock do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun}"	"{| tz |	tz := TimeZone timeDifference: -6 DST: 0 at: 0 from: 0 to: 0 startDay: #Sunday.	[1000000 timesRepeat:  [tz convertGMT: Time secondClock do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun}"	^ChronosFunction 		daysAndSecondsSinceStartOfDayFromSeconds: utSecondsSinceST80Epoch + self offsetSecondsFromUT		into: 			[:daysSinceEpoch :secondsSinceStartOfDay | 			block2 value: (Date fromDays: daysSinceEpoch) value: secondsSinceStartOfDay]</body><body package="Chronos-ST80 (and VW) Compatibility" selector="convertToGMT:do:">convertToGMT: localSecondsSinceST80Epoch do: block2	"{| tz |	tz := ChronosTimezone offset: -6 hours.	tz convertToGMT: Timepoint now asSeconds do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]}"	"{| tz |	tz := ChronosTimezone offset: -6 hours.	[1000000 timesRepeat: [tz convertToGMT: Timepoint now asSeconds do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun}"	"{| tz |	tz := TimeZone timeDifference: -6 DST: 0 at: 0 from: 0 to: 0 startDay: #Sunday.	[1000000 timesRepeat:  [tz convertToGMT: Timestamp now asSeconds do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun}"	^ChronosFunction 		daysAndSecondsSinceStartOfDayFromSeconds: localSecondsSinceST80Epoch - self offsetSecondsFromUT		into: 			[:daysSinceEpoch :secondsSinceStartOfDay | 			block2 value: (Date fromDays: daysSinceEpoch) value: secondsSinceStartOfDay]</body></methods><methods><class-id>Chronos.BasicTimezone</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processBasicTimezone: self</body></methods><methods><class-id>Chronos.BasicTimezone</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="commonAbbreviation">commonAbbreviation	"Answer the common abbreviation for the timezone represented by the receiver."	^commonAbbreviation == nil 		ifTrue: 			[self isUniversalTime 				ifTrue: [ChronosTimezone universal commonAbbreviation]				ifFalse: [super commonAbbreviation]]		ifFalse: [commonAbbreviation]</body><body package="Chronos-TimeZones" selector="key">key	"Answer the key that identifies the receiver."	^self isUniversalTime 		ifTrue: [ChronosTimezone universal key]		ifFalse: 			[self hasSubsecondOffset 				ifTrue: [self offsetFromUT asFractionalSeconds]				ifFalse: [self offsetSecondsFromUT]]</body><body package="Chronos-TimeZones" selector="nameIfNone:">nameIfNone: noneBlock	"Answer the name of the receiver."	^name == nil 		ifTrue: 			[self isUniversalTime 				ifTrue: [ChronosTimezone universal nameIfNone: noneBlock]				ifFalse: [self defaultNameIfNone: noneBlock]]		ifFalse: [name]</body><body package="Chronos-TimeZones" selector="netSecondsAfterAddingOffsetFromUTToSeconds:nanosecondsSinceSecond:">netSecondsAfterAddingOffsetFromUTToSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from adding the receiver's offset from UT to the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^offsetFromUT subsecondsAreZero		ifTrue: [seconds + offsetFromUT asSeconds]		ifFalse: [(offsetFromUT addingSeconds: seconds nanoseconds: nanosecondsSinceSecond) asSeconds]</body><body package="Chronos-TimeZones" selector="netSecondsAfterSubtractingOffsetFromUTFromSeconds:nanosecondsSinceSecond:">netSecondsAfterSubtractingOffsetFromUTFromSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from subtracting the receiver's offset from UT from the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^offsetFromUT subsecondsAreZero		ifTrue: [seconds - offsetFromUT asSeconds]		ifFalse: [(offsetFromUT negated addingSeconds: seconds nanoseconds: nanosecondsSinceSecond) asSeconds]</body><body package="Chronos-TimeZones" selector="offsetFromUT">offsetFromUT	"Answer a Duration that specifies the receiver's offset from Universal Time (which is defined as the amount of time to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the local time defined by the receiver.)"	^offsetFromUT</body><body package="Chronos-TimeZones" selector="offsetSecondsFromUT">offsetSecondsFromUT	"Answer the receiver's offset from Universal Time in seconds (which is defined as the number of seconds to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the local time defined by the receiver.)"	^offsetFromUT asSeconds</body><body package="Chronos-TimeZones" selector="stdTimeOffsetFromUT">stdTimeOffsetFromUT	"Answer a Duration that specifies the receiver's offset from Universal Time when `standard time` is in effect (which is defined as the amount of time to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^offsetFromUT</body><body package="Chronos-TimeZones" selector="stdTimeOffsetSecondsFromUT">stdTimeOffsetSecondsFromUT	"Answer the receiver's offset from Universal Time in seconds when `standard time` is in effect (which is defined as the number of seconds to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^offsetFromUT asSeconds</body></methods><methods><class-id>Chronos.BasicTimezone</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="hasSubsecondOffset">hasSubsecondOffset	"Answer whether the receiver has fractional seconds of offset."	^offsetFromUT subsecondsAreNonZero</body><body package="Chronos-TimeZones" selector="isUniversalTime">isUniversalTime	"Anwser whether the receiver has all the properties and behaviors of the international reference zero-offset time zone."	^offsetFromUT isZero</body><body package="Chronos-TimeZones" selector="offsetIsZero">offsetIsZero	"Anwser whether the receiver's offset from UT is zero."	^offsetFromUT isZero</body><body package="Chronos-TimeZones" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^commonAbbreviation ~~ nil</body><body package="Chronos-TimeZones" selector="specifiesName">specifiesName	^name ~~ nil</body></methods><methods><class-id>Chronos.BasicTimezone</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="beUniversal">beUniversal	"Make the receiver have the properties of the Universal Time zone. Fail if the receiver is not mutable."	self assertMutability.	offsetFromUT := ZeroDuration.</body><body package="Chronos-TimeZones" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	self beUniversal</body><body package="Chronos-TimeZones" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self setName: (literalArray at: 3).	self setOffsetFromUT: (literalArray at: 4) decodeAsLiteralArray commonAbbreviation: (literalArray at: 5)</body><body package="Chronos-TimeZones" selector="setName:">setName: aStringOrSymbol	"Set the name of the receiver to &lt;aStringOrSymbol&gt;. Fail if the receiver is not mutable."	self assertMutability.	name := aStringOrSymbol == nil ifFalse: [aStringOrSymbol asString]</body><body package="Chronos-TimeZones" selector="setOffsetFromUT:">setOffsetFromUT: aDuration 	"Set the receiver's offset from UT to be &lt;aDuration&gt;. Fail if the receiver is not mutable."	self assertMutability.	offsetFromUT := aDuration</body><body package="Chronos-TimeZones" selector="setOffsetFromUT:commonAbbreviation:">setOffsetFromUT: aDuration commonAbbreviation: aSymbol	"Set the receiver's offset from UT to be &lt;aDuration&gt;, and set the receiver's common abbreviation to be &lt;aSymbol&gt;. Fail if the receiver is not mutable."	self assertMutability.	offsetFromUT := aDuration.	commonAbbreviation := aSymbol</body></methods><methods><class-id>Chronos.BasicTimezone</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-TimeZones" selector="canonicalizeFromLocal:">canonicalizeFromLocal: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time in the local time defined by the receiver, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use Universal Time coordinates instead of local time coordinates.)"	^aDateAndTime canonicalizeFromLocal: self offsetSecondsFromUT nanoseconds: offsetFromUT nanosecondsSinceSecond</body><body package="Chronos-TimeZones" selector="canonicalizeFromUT:">canonicalizeFromUT: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time using Universal Time coordinates, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use coordinates in the local time defined by the receiver instead of using Universal Time coordinates.)"	^aDateAndTime canonicalizeFromUT: self offsetSecondsFromUT nanoseconds: offsetFromUT nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.BasicTimezone</class-id> <category>private</category><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneBlock	^self isUniversalTime 		ifTrue: [ChronosTimezone universal nameIfNone: noneBlock]		ifFalse: [noneBlock value]</body><body package="Chronos-TimeZones" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: name;		nextPut: self offsetFromUT literalArrayEncoding; 		nextPut: self commonAbbreviation</body></methods><methods><class-id>Chronos.BasicTimezone</class-id> <category>printing</category><body package="Chronos-TimeZones" selector="printKeyOn:">printKeyOn: stream	stream print: self key</body></methods><methods><class-id>Chronos.BasicTimezone class</class-id> <category>instance creation</category><body package="Chronos-TimeZones" selector="offset:">offset: aDuration	"Answer a BasicTimezone whose offset from UT is &lt;aDuration&gt;."	"{BasicTimezone offset: (Duration hours: -7)}"	^self new		setOffsetFromUT: aDuration;		beImmutable</body><body package="Chronos-TimeZones" selector="offset:commonAbbreviation:">offset: aDuration commonAbbreviation: aSymbol	"Answer a BasicTimezone whose offset from UT is &lt;aDuration&gt; and whose common abbreviation is &lt;aSymbol&gt;."	"{BasicTimezone		offset: (Duration hours: -7)		commonAbbreviation: #MST}"	^self new		setOffsetFromUT: aDuration commonAbbreviation: aSymbol;		beImmutable</body><body package="Chronos-TimeZones" selector="offset:name:commonAbbreviation:">offset: aDuration name: aStringOrSymbol commonAbbreviation: aSymbol	"Answer a BasicTimezone whose offset from UT is &lt;aDuration&gt;, whose name is &lt;aStringOrSymbol&gt; and whose common abbreviation is &lt;aSymbol&gt;."	"{BasicTimezone		offset: (Duration hours: -7)		name: 'US Mountain Time (Arizona)'		commonAbbreviation: #MST}"	^self new		setName: aStringOrSymbol;		setOffsetFromUT: aDuration commonAbbreviation: aSymbol;		beImmutable</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>printing</category><body package="Chronos-Calendars-Foundation" selector="printCalendarDaysOn:indent:">printCalendarDaysOn: stream indent: depth	self daysDo: [:day |		stream cr.		day printOn: stream indent: depth + 1]</body><body package="Chronos-Calendars-Foundation" selector="printOn:indent:">printOn: stream indent: depth	stream 		tab: depth;		nextPut: ${;		nextPutAll: self class name;		nextPutAll: ' monthKey=';		print: self monthKey;		tab;		nextPutAll: ' name=';		nextPutAll: self name;		crtab;		tab: depth;		nextPutAll: ' ordinal=';		print: self monthOrdinal;		tab;		nextPutAll: ' yearTypeCode=';		print: self yearTypeCode;		tab;		nextPutAll: ' daysPerMonth=';		print: self daysPerMonth;		tab;		nextPutAll: ' intercalaryMonth=';		print: isIntercalary;		tab;		nextPutAll: ' leapMonth=';		print: isLeap;		tab;		nextPutAll: ' leapDayOrdinals: ';		print: self leapDayOrdinals;		nextPut: $}</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printMonthlyCalendar: self on: stream</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>enumerating</category><body package="Chronos-Calendars-Foundation" selector="dayOfMonthOrdinalsDo:">dayOfMonthOrdinalsDo: block1	"For each day of the receiver's month, evaluate &lt;block1&gt; with the day-of-month ordinal (in ascending sequence) of the day as the argument."	1 to: self daysPerMonth do: [:index | block1 value: index]</body><body package="Chronos-Calendars-Foundation" selector="daysDo:">daysDo: block1	"For each day of the receiver's month, evaluate &lt;block1&gt; with the receiver's CalendarDay representing that day as the argument."	1 to: self daysPerMonth do: [:dayOfMonth | block1 value: (self basicDayAt: dayOfMonth)]</body><body package="Chronos-Calendars-Foundation" selector="leapDayOrdinalsDo:">leapDayOrdinalsDo: block1	"For each leap day in the receiver's month, evaluate &lt;block1&gt; with the day-of-month ordinal (in ascending sequence) of the day as the argument."	leapDayOrdinals do: block1</body><body package="Chronos-Calendars-Foundation" selector="leapDaysDo:">leapDaysDo: block1	"For each leap day in the receiver's month, evaluate &lt;block1&gt; with the receiver's CalendarDay representing that day as the argument."	self leapDayOrdinalsDo: [:index | block1 value: (self basicDayAt: index)]</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	isIntercalary = false.	daysUpToMonthSinceStartOfYear := 0.	leapDayOrdinals := #()</body><body package="Chronos-Calendars-Foundation" selector="setYearlyCalendar:specification:">setYearlyCalendar: aYearlyCalendar specification: aMonthlyCalendarSpecification	"Initialize the receiver as one of the months of &lt;aYearlyCalendar&gt; (an instance of YearlyCalendar,) so that the receiver specifies the same properties for the month it represents as are specifed by &lt;aMonthlyCalendarSpecification&gt; (an instance of MonthlyCalendarSpec.)"	self assertMutability.	containingPeriod := aYearlyCalendar.	key := aMonthlyCalendarSpecification monthKey.	nameKey := aMonthlyCalendarSpecification nameKey.	isLeap := aMonthlyCalendarSpecification isLeapMonth.	isIntercalary := isLeap or: [aMonthlyCalendarSpecification isIntercalaryMonth].	leapDayOrdinals := aMonthlyCalendarSpecification leapDayOrdinals.	self setDaysPerMonth: aMonthlyCalendarSpecification daysPerMonth</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="abbreviation">abbreviation	"Answer the abbreviation of the receiver's month name according to the current default ChronosLocale."	^self forLocale: ChronosLocale default monthAbbreviationIfResolvable: [:name | name] ifNot: [self nameKey]</body><body package="Chronos-Calendars-Foundation" selector="basicDayAt:">basicDayAt: index	"Answer the CalendarDay with the given &lt;dayOfMonthOrdinal&gt;.  Fail if the &lt;dayOfMonthOrdinal&gt; is invalid."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="dayAt:">dayAt: dayOfMonthOrdinal	"Answer the CalendarDay with the given &lt;dayOfMonthOrdinal&gt;.  Answer nil if the &lt;dayOfMonthOrdinal&gt; is invalid."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysPerMonth">daysPerMonth	"For the type of year of the receiver, answer the number of days in the month whose properties are specified by the receiver."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="daysUpToMonthSinceStartOfYear">daysUpToMonthSinceStartOfYear	"For the type of year of the receiver, answer the number of days from the first day of the year up to (but not including) the first day of the receiver's month."	^daysUpToMonthSinceStartOfYear</body><body package="Chronos-Calendars-Foundation" selector="lastDay">lastDay	"Answer the CalendarDay that specifies the properties of the last day of the month specified by the receiver."	^self basicDayAt: self daysPerMonth</body><body package="Chronos-Calendars-Foundation" selector="leapDayCount">leapDayCount	"For the type of year of the receiver, answer the number of leap days in the month whose properties are specified by the receiver."	^leapDayOrdinals size</body><body package="Chronos-Calendars-Foundation" selector="leapDayOrdinals">leapDayOrdinals	^leapDayOrdinals</body><body package="Chronos-Calendars-Foundation" selector="month">month	"For the type of year of the receiver, answer the ordinal of the receiver's month."	^monthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="monthAbbreviation">monthAbbreviation	"Answer the abbreviation of the receiver's month name according to the current default ChronosLocale."	^self abbreviation</body><body package="Chronos-Calendars-Foundation" selector="monthKey">monthKey	"Answer the semantic key that identifies the receiver's month."	^key</body><body package="Chronos-Calendars-Foundation" selector="monthName">monthName	"Answer the name of the receiver's month according to the current default ChronosLocale."	^self name</body><body package="Chronos-Calendars-Foundation" selector="monthOrdinal">monthOrdinal	"Answer the ordinal of the receiver's month."	^monthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="monthlyCalendar">monthlyCalendar	"Answer the MonthlyCalendar instance that specifies the properties the receiver's month (if the receiver is itself a MonthlyCalendar, answer the receiver.)"	^self</body><body package="Chronos-Calendars-Foundation" selector="monthsSinceStartOfYear">monthsSinceStartOfYear	"For the type of year of the receiver, answer the number of months from the first month of the year up to (but not including) the receiver's month (the answer must be the cardinal number of the receiver's month.)"	^monthOrdinal - 1</body><body package="Chronos-Calendars-Foundation" selector="name">name	"Answer the receiver's name according to the current default ChronosLocale."	^self forLocale: ChronosLocale default monthNameIfResolvable: [:name | name] ifNot: [self nameKey]</body><body package="Chronos-Calendars-Foundation" selector="nameKey">nameKey	^nameKey == nil		ifTrue: [key]		ifFalse: [nameKey]</body><body package="Chronos-Calendars-Foundation" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^MonthDuration</body><body package="Chronos-Calendars-Foundation" selector="yearlyCalendar">yearlyCalendar	"Answer the YearlyCalendar instance that specifies the properties of the receiver's year type (if the receiver is itself a YearlyCalendar, answer the receiver.)"	^containingPeriod</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>testing</category><body package="Chronos-Calendars-Foundation" selector="hasLeapDayAt:">hasLeapDayAt: dayOfMonthOrdinal	"Answer whether the day of the receiver's month with the given &lt;dayOfMonthOrdinal&gt; is a leap day."	^leapDayOrdinals includes: dayOfMonthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="hasLeapDays">hasLeapDays	"Answer whether there are any leap days in the receiver's month."	^leapDayOrdinals size &gt; 0</body><body package="Chronos-Calendars-Foundation" selector="isIntercalaryMonth">isIntercalaryMonth	"Answer whether the receiver's month is an intercalary month. An intercalary month is one that either a) does not occur every year, and/or b) does not have nearly the same number of days as the majority of months in the year."	^isIntercalary</body><body package="Chronos-Calendars-Foundation" selector="isLeapMonth">isLeapMonth	"Answer true if the month represented by the receiver does not occur in every type of year."	^isLeap</body><body package="Chronos-Calendars-Foundation" selector="isStandardMonth">isStandardMonth	"Answer whether the receiver's month is a 'normal' month. A normal month is one that a) occurs every year, and b) has about the same number of days as the majority of months in the year."	^isIntercalary not</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>queries</category><body package="Chronos-Calendars-Foundation" selector="forLocale:monthAbbreviationIfResolvable:ifNot:">forLocale: aChronosLocale monthAbbreviationIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the abbreviation of the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^resolvable value: ((ChronosLocale referencedBy: aChronosLocale) abbreviationAtSemanticKey: self nameKey)</body><body package="Chronos-Calendars-Foundation" selector="forLocale:monthNameIfResolvable:ifNot:">forLocale: aChronosLocale monthNameIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKkey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^resolvable value: ((ChronosLocale referencedBy: aChronosLocale) properNameAtSemanticKey: self nameKey)</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="calendarDayClass">calendarDayClass	"Answer the concrete subclass of CalendarDays that should be used to instantiate CalendarDays to represent the days of the receiver's month."	^self subclassResponsibility</body><body package="Chronos-Calendars-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self monthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="setDaysPerMonth:">setDaysPerMonth: daysPerMonth	"Initialize the receiver so that it represents a month with &lt;daysPerMonth&gt; days. Fail if the receiver is immutable."	^self subclassResponsibility</body></methods><methods><class-id>Chronos.MonthlyCalendar</class-id> <category>converting</category><body package="Chronos-Calendars-Foundation" selector="canonical">canonical	^self yearlyCalendar canonical monthAt: self monthOrdinal</body></methods><methods><class-id>Chronos.MonthlyCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^((Calendar referencedBy: (literalArray at: 2)) canonical		yearlyCalendarForYearTypeCode: (literalArray at: 3) decodeAsLiteralArray)			monthAt: (literalArray at: 4)</body></methods><methods><class-id>Chronos.DynamicMonthlyCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Irregular" selector="calendarDayClass">calendarDayClass	"Answer the concrete subclass of CalendarDays that should be used to instantiate CalendarDays to represent the days of the receiver's month."	^DynamicCalendarDay</body><body package="Chronos-Calendars-Irregular" selector="newCalendarDay:">newCalendarDay: dayOfMonth	^self calendarDayClass		newInMonth: self 		dayOfMonthOrdinal: dayOfMonth 		dayOfYearOrdinal: dayOfMonth + daysUpToMonthSinceStartOfYear</body><body package="Chronos-Calendars-Irregular" selector="nextDayInYearAfter:count:">nextDayInYearAfter: aCalendarDay count: count	| nextDayOfMonth |	nextDayOfMonth := aCalendarDay dayOfMonthOrdinal + count.	^nextDayOfMonth &gt; daysPerMonth		ifTrue: [containingPeriod dayAt: aCalendarDay dayOfYearOrdinal + count]		ifFalse: 			[nextDayOfMonth &lt; 1				ifTrue: [self signalError: 'Invalid operation']				ifFalse: [self newCalendarDay: nextDayOfMonth]]</body><body package="Chronos-Calendars-Irregular" selector="prevDayInYearBefore:count:">prevDayInYearBefore: aCalendarDay count: count	| prevDayOfMonth |	prevDayOfMonth := aCalendarDay dayOfMonthOrdinal - count.	^prevDayOfMonth &lt; 1 		ifTrue: [containingPeriod dayAt: aCalendarDay dayOfYearOrdinal - count]		ifFalse: 			[prevDayOfMonth &gt; daysPerMonth				ifTrue: [self signalError: 'Invalid operation']				ifFalse: [self  newCalendarDay: prevDayOfMonth]]</body><body package="Chronos-Calendars-Irregular" selector="setDaysPerMonth:">setDaysPerMonth: daysInMonth	"Initialize the receiver so that it represents a month with &lt;daysPerMonth&gt; days. Fail if the receiver is immutable."	self assertMutability.	daysPerMonth := daysInMonth</body></methods><methods><class-id>Chronos.DynamicMonthlyCalendar</class-id> <category>accessing</category><body package="Chronos-Calendars-Irregular" selector="basicDayAt:">basicDayAt: dayOfMonthOrdinal	"Answer the CalendarDay with the given &lt;dayOfMonthOrdinal&gt;.  Fail if the &lt;dayOfMonthOrdinal&gt; is invalid."	^self newCalendarDay: dayOfMonthOrdinal</body><body package="Chronos-Calendars-Irregular" selector="dayAt:">dayAt: dayOfMonthOrdinal	"Answer the CalendarDay with the given &lt;dayOfMonthOrdinal&gt;.  Answer nil if the &lt;dayOfMonthOrdinal&gt; is invalid."	(dayOfMonthOrdinal &gt; daysPerMonth or: [dayOfMonthOrdinal &lt; 1])		ifTrue: [^nil].	^self newCalendarDay: dayOfMonthOrdinal</body><body package="Chronos-Calendars-Irregular" selector="daysPerMonth">daysPerMonth	"For the type of year of the receiver, answer the number of days in the month whose properties are specified by the receiver."	^daysPerMonth</body></methods><methods><class-id>Chronos.DynamicMonthlyCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Irregular" selector="setYearlyCalendar:monthOrdinal:daysUpToMonthSinceStartOfYear:specification:">setYearlyCalendar: aYearlyCalendar monthOrdinal: monthIndex daysUpToMonthSinceStartOfYear: daysUpToMonth specification: aMonthlyCalendarSpecification	"Initialize the receiver as the &lt;monthIndex&gt;th month of &lt;aYearlyCalendar&gt; (an instance of YearlyCalendar,) so that the receiver specifies the same properties for the month it represents as are specifed by &lt;aMonthlyCalendarSpecification&gt; (an instance of MonthlyCalendarSpec,) and so that the receiver specifies that there are &lt;daysUpToMonth&gt; days from the first day of the year up to (but not including) the first day of the month represented by the receiver."	self assertMutability.	monthOrdinal := monthIndex.	daysUpToMonthSinceStartOfYear := daysUpToMonth.	super setYearlyCalendar: aYearlyCalendar specification: aMonthlyCalendarSpecification</body><body package="Chronos-Calendars-Irregular" selector="setYearlyCalendar:specification:">setYearlyCalendar: aYearlyCalendar specification: aMonthlyCalendarSpecification	self shouldNotImplement</body></methods><methods><class-id>Chronos.DynamicMonthlyCalendar class</class-id> <category>instance creation</category><body package="Chronos-Calendars-Irregular" selector="monthInYear:monthOrdinal:daysUpToMonthSinceStartOfYear:specification:">monthInYear: aYearlyCalendar monthOrdinal: monthOrdinal daysUpToMonthSinceStartOfYear: daysUpToMonthSinceStartOfYear specification: aCalendarMonthSpecification	^self new 		setYearlyCalendar: aYearlyCalendar 		monthOrdinal: monthOrdinal		daysUpToMonthSinceStartOfYear: daysUpToMonthSinceStartOfYear 		specification: aCalendarMonthSpecification</body><body package="Chronos-Calendars-Irregular" selector="monthInYear:monthOrdinal:specification:">monthInYear: aYearlyCalendar monthOrdinal: monthOrdinal specification: aCalendarMonthSpecification	^self new 		setYearlyCalendar: aYearlyCalendar 		monthOrdinal: monthOrdinal		specification: aCalendarMonthSpecification</body></methods><methods><class-id>Passport.UtilityFunction class</class-id> <category>stream/parsing services</category><body package="Passport-Kernel" selector="componentsFromStream:separator:">componentsFromStream: source separator: separator	"Answer an Array containing the 'components' ('tokens') parsed from the &lt;source&gt; Stream.  Each component (token) is separated from others by one or more occurrences of the &lt;separator&gt; value."	"{UtilityFunction componentsFromStream: 'foo.bar.mitzvah' readStream separator: $.}" 	^self componentsFromStream: source separator: separator transformer: nil</body><body package="Passport-Kernel" selector="componentsFromStream:separator:transformer:">componentsFromStream: source separator: separator transformer: block1	"Answer an Array containing the 'components' ('tokens') parsed from the &lt;source&gt; Stream.  Each component (token) is separated from others by one or more occurrences of the &lt;separator&gt; value."	"{UtilityFunction componentsFromStream: 'foo.bar.mitzvah' readStream separator: $. transformer: [:component | component asUppercase]}" 	| components |	components := (Array new: 5) writeStream.	[source peekFor: separator] whileTrue.	block1 == nil		ifTrue: [[source atEnd] whileFalse: [components nextPut: (source upTo: separator)]]		ifFalse: [[source atEnd] whileFalse: [components nextPut: (block1 value: (source upTo: separator))]].	^components contents</body><body package="Passport-Kernel" selector="componentsFromString:separator:">componentsFromString: source separator: separator 	"Answer an Array containing the 'components' ('tokens') parsed from the &lt;source&gt; String.  Each component (token) is separated from others by one or more occurrences of the &lt;separator&gt; value."	"{UtilityFunction componentsFromString: 'foo/bar/mitzvah' separator: $/}"	^self componentsFromStream: source readStream separator: separator</body><body package="Passport-Kernel" selector="componentsFromString:separator:transformer:">componentsFromString: source separator: separator  transformer: block1	"Answer an Array containing the 'components' ('tokens') parsed from the &lt;source&gt; String.  Each component (token) is separated from others by one or more occurrences of the &lt;separator&gt; value."	"{UtilityFunction componentsFromString: 'foo/bar/mitzvah' separator: $/ transformer: [:component | component asUppercase]}"	^self componentsFromStream: source readStream separator: separator transformer: block1</body><body package="Passport-Kernel" selector="expandMacrosFrom:withBindings:">expandMacrosFrom: sourceStream withBindings: argBindings	"{| bindings |	bindings := Dictionary new.	bindings		at: #page put: [(3 + 4) printString];		at: #whatever put: 'mitzvah';		at: #localTimeZone put: 'Australia/Adelaide';		at: #timeOnServer put: (Timepoint now withDefaultPrintPolicy: #rfc2822).	UtilityFunction 		expandMacrosFrom: 			'			Page: &lt;v:page&gt;. &lt;s:unknown&gt;			Foo bar &lt;s:whatever&gt; 			Local time: &lt;e:localTimeZone | (DateAndTime now &gt;&gt; localTimeZone) % #rfc2822!&gt;.			Server time: &lt;p:timeOnServer&gt;' readStream 		withBindings: bindings}"	"{| bindings date printInt |	date := YearMonthDay today.	printInt := [:int :width |		| stream |		stream := (String new: 10) writeStream.	  	int printOn: stream paddedWith: $  to: width base: 10.		stream contents].	bindings := Dictionary new.	bindings		at: #year put: [printInt value: date year value: 4];		at: #month put: [date monthName];		at: #day put: [printInt value: date dayOfMonth value: 2].	UtilityFunction expandMacrosFrom: 'Date: &lt;v:day&gt; &lt;v:month&gt; &lt;v:year&gt;' readStream withBindings: bindings}"	| outStream processor |	[outStream := (String new: 1024) writeStream.	processor := Array with: [:v | v printString] with: [:v | v] with: [:v | v value].	[sourceStream atEnd] 		whileFalse: 			[| ch0 ch1 |			ch0 := sourceStream next.			ch0 = $&lt;				ifTrue: 					[| index |					ch1 := sourceStream next. 					ch1 = $e						ifTrue: 							[(sourceStream peekFor: $:)								ifTrue:									[| string argKey argValue |									string := sourceStream upTo: $|.									argKey := (self nextFrom: string readStream until: [:ch | ch isSeparator]) asSymbol.									argValue := argBindings at: argKey ifAbsent: [].									argValue == nil										ifTrue: [outStream nextPut: ch0; nextPut: ch1; nextPut: $:; nextPutAll: string; nextPut: $!]										ifFalse: 											[| expression |											expression := (String new: 32) writeStream.											expression nextPutAll: '[:'; nextPutAll: argKey; nextPutAll: ' |'.											[expression nextPutAll: (sourceStream upTo: $!).											sourceStream peekFor: $&gt;] whileFalse.											expression nextPut: $].											outStream nextPutAll: ((EnvironmentFacade current evaluateExpression: expression contents) value: argValue)]]								ifFalse: [outStream nextPut: ch0; nextPut: ch1]]						ifFalse:							[(((index := #($p $s $v) indexOf: ch1) &gt; 0) and: [sourceStream peekFor: $:])								ifTrue: 									[| argKey argValue |									argKey := (sourceStream upTo: $&gt;) asSymbol.									argValue := argBindings at: argKey ifAbsent: [].									argValue == nil										ifTrue: [outStream nextPut: ch0; nextPut: ch1; nextPut: $:; nextPutAll: argKey; nextPut: $&gt;]										ifFalse: [outStream nextPutAll: ((processor at: index) value: argValue)]]								ifFalse: [outStream nextPut: ch0; nextPut: ch1]]]						ifFalse: [outStream nextPut: ch0]]] ensure: [sourceStream close].	^outStream contents</body><body package="Passport-Kernel" selector="nextFrom:until:">nextFrom: stream until: predicate	"Starting with the next element of the Stream &lt;stream&gt;, for each element in the &lt;stream&gt; that does NOT satisfy the &lt;predicate&gt;, up to (but not including) the first element that DOES satisfy the &lt;predicate&gt;, answer a SequenceableCollection containing all such elements in the same order as they occur in the &lt;stream&gt;. An element of the &lt;stream&gt; satisfies the &lt;predicate&gt; if and only if &lt;predicate value: element&gt; evaluates to true.  Leave the stream positioned before the first elment that DOES satsify the &lt;predicate&gt;."	"{UtilityFunction nextFrom: '123abc' readStream until: [:each | each isAlphabetic]}"	| tokenStream |	tokenStream := (String new: 13) writeStream.	[stream atEnd or: [predicate value: stream peek]]		whileFalse: 			[tokenStream nextPut: stream next].	^tokenStream contents</body><body package="Passport-Kernel" selector="nextFrom:while:">nextFrom: stream while: predicate	"Starting with the next element of the Stream &lt;stream&gt;, for each element in the &lt;stream&gt; that DOES satisfy the &lt;predicate&gt;, up to (but not including) the first element that does NOT satisfy the &lt;predicate&gt;, answer a SequenceableCollection containing all such elements in the same order as they occur in the &lt;stream&gt;. An element of the &lt;stream&gt; satisfies the &lt;predicate&gt; if and only if &lt;predicate value: element&gt; evaluates to true.  Leave the stream positioned before the first elment that does NOT satsify the &lt;predicate&gt;."	"{UtilityFunction nextFrom: '123abc' readStream while: [:each | each isDigit]}"	| tokenStream |	tokenStream := (String new: 13) writeStream.	[stream atEnd or: [(predicate value: stream peek) not]]		whileFalse: 			[tokenStream nextPut: stream next].	^tokenStream contents</body><body package="Passport-Kernel" selector="nextFrom:while:minChars:maxChars:onUnexpectedEOD:">nextFrom: inStream while: predicate minChars: minChars maxChars: maxChars onUnexpectedEOD: unexpectedEODAction	"UtilityFunction nextFrom: '1234abc' readStream while: [:ch | ch isDigit] minChars: 4 maxChars: 7 onUnexpectedEOD: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"UtilityFunction nextFrom: '1234abc' readStream while: [:ch | true] minChars: 1 maxChars: nil onUnexpectedEOD: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"UtilityFunction nextFrom: '1234abc' readStream while: [:ch | ch isDigit] minChars: 1 maxChars: 2 onUnexpectedEOD: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"UtilityFunction nextFrom: '1234abc' readStream while: [:ch | ch isDigit] minChars: 5 maxChars: 5 onUnexpectedEOD: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	| continue count ch outStream |	count := 0.	outStream := (String new: 8) writeStream.	continue := inStream atEnd not.	[continue]		whileTrue:			[ch := inStream peek.			(predicate value: ch)				ifTrue: 					[count := count + 1.					outStream nextPut: inStream next.					continue := (inStream atEnd or: [maxChars notNil and: [count &gt;= maxChars]]) not]				ifFalse:					[continue := false]].	^count &gt;= minChars		ifTrue: [outStream contents]		ifFalse: [unexpectedEODAction value: outStream contents value: ch value: inStream position]</body><body package="Passport-Kernel" selector="nextLineFrom:">nextLineFrom: stream 	"Answer a String containing the next line of text from the Stream &lt;stream&gt;. Do not include the end-of-line character(s) in the answered String. Leave the &lt;stream&gt; positioned at the beginning of the next line. Transparently handle all three common line-end conventions (CR, LF and CRLF.)"	| lineStream ch cr lf atEnd |	lineStream := (String new: 37) writeStream.	cr := Character cr.	lf := Character lf.	atEnd := stream atEnd.	[atEnd] whileFalse: 			[ch := stream next.			ch = lf 				ifTrue: [atEnd := true]				ifFalse: 					[ch = cr 						ifTrue: 							[stream peekFor: lf.							atEnd := true]						ifFalse: 							[lineStream nextPut: ch.							atEnd := stream atEnd]]].	^lineStream contents</body><body package="Passport-Kernel" selector="nextScaledDecimalFrom:minDigits:maxDigits:maxValue:handleRejection:">nextScaledDecimalFrom: stream minDigits: minDigits maxDigits: maxDigits maxValue: maxValue handleRejection: handleRejection	"UtilityFunction nextScaledDecimalFrom: '59' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '60' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '05' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '0' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '00.123' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '01.999999999' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '60.999999999' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '00.x' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: '61' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"UtilityFunction nextScaledDecimalFrom: 'x7' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	| second |	second := 		UtilityFunction 			nextUnsignedIntegerFrom: stream			minDigits: minDigits			maxDigits: maxDigits			acceptancePredicate: [:int :digitCount | maxValue == nil or: [int &lt;= maxValue]]			handleRejection: [:value :count :rejectionReason | ^handleRejection value: value value: count value: rejectionReason].	((stream peekFor: $.) or: [stream peekFor: $,]) 		ifTrue: 			[| subSeconds |			subSeconds := 				UtilityFunction 					nextFrom: stream					while: [:ch | ch isDigit]					minChars: 0					maxChars: 99999999					onUnexpectedEOD: [:prefix :ch :position | ^handleRejection value: prefix value: 0 value: #notAnInteger].			subSeconds size &gt; 0 				ifTrue: 					[| scale denominator |					scale := subSeconds size.					denominator := 10 raisedToInteger: scale.					second := (ScaledDecimal  numerator: second * denominator + (Integer readFrom: subSeconds readStream) denominator: denominator scale: scale)]].	^second</body><body package="Passport-Kernel" selector="nextUnsignedIntegerFrom:minDigits:maxDigits:acceptancePredicate:handleRejection:">nextUnsignedIntegerFrom: stream minDigits: minDigits maxDigits: maxDigits acceptancePredicate: acceptancePredicate handleRejection: handleRejection 	"{| stream result |	stream := ' 14 Feb 2006' readStream.	result := UtilityFunction nextUnsignedIntegerFrom: stream minDigits: 1 maxDigits: 4 				acceptancePredicate: [:int :digitCount | digitCount &lt;= 2] 				handleRejection: [:value :digitCount :rejectionReason | rejectionReason-&gt;(Array with: value with: digitCount)].	Array with: result with: stream upToEnd}"	"{| stream result |	stream := ' 2006-02-14' readStream.	result := UtilityFunction nextUnsignedIntegerFrom: stream minDigits: 1 maxDigits: 4 				acceptancePredicate: [:int :digitCount | digitCount &lt;= 2 or: [digitCount = 4]] 				handleRejection: [:value :digitCount :rejectionReason | rejectionReason-&gt;(Array with: value with: digitCount)].	Array with: result with: stream upToEnd}"	"{| stream result |	stream := ' 20060214' readStream.	result := UtilityFunction nextUnsignedIntegerFrom: stream minDigits: 1 maxDigits: 4 				acceptancePredicate: [:int :digitCount | digitCount &lt;= 2] 				handleRejection: [:value :digitCount :rejectionReason | rejectionReason-&gt;(Array with: value with: digitCount)].	Array with: result with: stream upToEnd}"	"{| stream result |	stream := ' 238' readStream.	result := UtilityFunction nextUnsignedIntegerFrom: stream minDigits: 1 maxDigits: 3 				acceptancePredicate: [:int :digitCount | digitCount &lt;= 2] 				handleRejection: [:value :digitCount :rejectionReason | rejectionReason-&gt;(Array with: value with: digitCount)].	Array with: result with: stream upToEnd}"	| integer ch digitCount |	self skipSeparators: stream.	stream atEnd 		ifTrue: 			[^handleRejection 				value: nil				value: 0				value: #streamAtEnd].	digitCount := 0.	integer := 0.	ch := stream peek.	[(maxDigits == nil or: [digitCount &lt; maxDigits]) and: [ch notNil and: [ch isDigit]]] whileTrue: 			[digitCount := digitCount + 1.			integer := integer * 10 + stream next digitValue.			ch := stream peek].	^digitCount &gt;= minDigits 		ifTrue: 			[(acceptancePredicate value: integer value: digitCount) 				ifTrue: [integer]				ifFalse: 					[stream skip: digitCount negated.					handleRejection 						value: integer						value: digitCount						value: #notAccepted]]		ifFalse: 			[digitCount &gt; 0 				ifTrue: 					[handleRejection 						value: integer						value: digitCount						value: #lessThanMinDigits]				ifFalse: 					[handleRejection 						value: nil						value: digitCount						value: #notAnInteger]]</body><body package="Passport-Kernel" selector="skipOver:until:">skipOver: stream until: predicate	"Advance the position of the &lt;stream&gt; up to (but not past) the first element that DOES satisfy the &lt;predicate&gt;. An element of the &lt;stream&gt; satisfies the &lt;predicate&gt; if and only if &lt;predicate value: element&gt; evaluates to true."	[stream atEnd or: [predicate value: stream peek]]		whileFalse: 			[stream next].</body><body package="Passport-Kernel" selector="skipOver:while:">skipOver: stream while: predicate	"Advance the position of the &lt;stream&gt; up to (but not past) the first element that does NOT satisfy the &lt;predicate&gt;. An element of the &lt;stream&gt; satisfies the &lt;predicate&gt; if and only if &lt;predicate value: element&gt; evaluates to true."	[stream atEnd or: [(predicate value: stream peek) not]]		whileFalse: 			[stream next].</body><body package="Passport-Kernel" selector="skipSeparators:">skipSeparators:  stream	"Advance the position of the &lt;stream&gt; up to (but not past) the first element of the &lt;stream&gt; that is not a separator character."	self skipOver: stream while: [:ch | ch isSeparator]</body><body package="Passport-Kernel" selector="skipToNextLineOf:">skipToNextLineOf: stream 	"Advance the position of the &lt;stream&gt; to the beginning of the next line of text. Transparently handle all three common line-end conventions (CR, LF and CRLF.)"	| ch cr lf atEnd |	cr := Character cr.	lf := Character lf.	atEnd := stream atEnd.	[atEnd] whileFalse: 			[ch := stream next.			ch = lf 				ifTrue: [atEnd := true]				ifFalse: 					[ch = cr 						ifTrue: 							[stream peekFor: lf.							atEnd := true]						ifFalse: [atEnd := stream atEnd]]]</body></methods><methods><class-id>Passport.UtilityFunction class</class-id> <category>collection services</category><body package="Passport-Kernel" selector="allElementsOf:satisfy:">allElementsOf: aCollection satisfy: predicate	"Answer true if the result of evaluating the one-argument block &lt;predicate&gt; with each element of &lt;aCollection&gt; as the argument is the value true for all members."	aCollection do: [:element | (predicate value: element) ifFalse: [^false]].	^true</body><body package="Passport-Kernel" selector="ansiValueOfArrayLiteral:">ansiValueOfArrayLiteral: aLiteralArray 	"UtilityFunction ansiValueOfArrayLiteral: #(1 #nil 2 #true 3 #false)"	aLiteralArray == nil ifTrue: [^nil].	^aLiteralArray collect: [:literalArrayElement | self ansiValueOfLiteralArrayElement: literalArrayElement]</body><body package="Passport-Kernel" selector="ansiValueOfLiteralArrayElement:">ansiValueOfLiteralArrayElement: anArrayLiteralElement 	"#(1 #nil 2 #true 3 #false) collect: [:literalArrayElement | UtilityFunction ansiValueOfLiteralArrayElement: literalArrayElement]"	anArrayLiteralElement == #nil ifTrue: [^nil].	anArrayLiteralElement == #true ifTrue: [^true].	^anArrayLiteralElement == #false 		ifTrue: [false]		ifFalse: [anArrayLiteralElement]</body><body package="Passport-Kernel" selector="decodeDictionaryFromLiteralArray:">decodeDictionaryFromLiteralArray: literalArray 	"Construct a `Dictionary' from the values containted in &lt;literalArray&gt;, which is an array that contains the keys and values of a Dictionary encoded as literal Arrays. This method must successfully consume any literalArray produced by UtilityFunction&gt;&gt;encodeDictionaryAsLiteralArray:."	"{| dict |	dict := IdentityDictionary new.	dict at: #foo put: 'bar'.	dict at: #bar put: #(1 2 3).	UtilityFunction decodeDictionaryFromLiteralArray: (ChronosUtility encodeDictionaryAsLiteralArray: dict)}"	| dictClass dict |	literalArray == nil ifTrue: [^nil].	dictClass := 		EnvironmentFacade current			resolveClassFromFullyQualifiedName: (literalArray at: 1)			ifAbsent: [Dictionary].	dict := dictClass new: literalArray size * 2.	2 to: literalArray size		by: 2		do: 			[:index | 			| key value |			key := (literalArray at: index) decodeAsLiteralArray.			value := literalArray at: index + 1.			value := value class == Array 						ifTrue: 							[value size &gt; 0 								ifTrue: 									[| firstElement |									firstElement := value first.									(firstElement isSymbol and: 											[(EnvironmentFacade current												resolveClassFromFullyQualifiedName: firstElement												ifAbsent: []) notNil]) 										ifTrue: [value decodeAsLiteralArray]										ifFalse: [value]]								ifFalse: [value]]						ifFalse: [value].			dict at: key put: value].	^dict</body><body package="Passport-Kernel" selector="encodeDictionaryAsLiteralArray:">encodeDictionaryAsLiteralArray: aDictionary	"Answer the literal Array encoding of &lt;aDictionary&gt;.'"	"{| dict |	dict := IdentityDictionary new.	dict at: #foo put: 'bar'.	dict at: #bar put: #(1 2 3).	UtilityFunction encodeDictionaryAsLiteralArray: dict}"	| dictStream |	aDictionary == nil ifTrue: [^nil].	dictStream := (Array new: aDictionary size * 2 + 1) writeStream.	dictStream nextPut: (EnvironmentFacade current fullyQualifiedNameOfClass: aDictionary class).	aDictionary keysAndValuesDo: 		[:key :value | dictStream nextPut: key literalArrayEncoding; nextPut: value literalArrayEncoding].	^dictStream contents</body><body package="Passport-Kernel" selector="indexOfName:in:">indexOfName: aStringOrSymbol in: aCollectionOfStringsOrSymbols	"Answer the index of &lt;aStringOrSymbol&gt; in &lt;aCollectionOfStringsOrSymbols&gt;.  If not present, raise an exception.  Ignore case differences in matching &lt;aStringOrSymbol&gt; to the elements of &lt;aCollectionOfStringsOrSymbols&gt;."	"{UtilityFunction indexOfName: #may in: #(January February March April May June July August September October November December)}"	^self indexOfName: aStringOrSymbol in: aCollectionOfStringsOrSymbols ifAbsent: [self signalError: 'Element not found: ', aStringOrSymbol printString]</body><body package="Passport-Kernel" selector="indexOfName:in:ifAbsent:">indexOfName: aStringOrSymbol in: aCollectionOfStringsOrSymbols ifAbsent: block0 	"Answer the index of &lt;aStringOrSymbol&gt; in &lt;aCollectionOfStringsOrSymbols&gt;.  If not present, answer the evaluation of &lt;block0&gt;.  Ignore case differences in matching &lt;aStringOrSymbol&gt; to the elements of &lt;aCollectionOfStringsOrSymbols&gt;."	"{UtilityFunction indexOfName: #may in: #(January February March April May June July August September October November December) ifAbsent: [0]}"	| canonicalName |	canonicalName := aStringOrSymbol asUppercase.	1 to: aCollectionOfStringsOrSymbols size		do: 			[:index | 			(aCollectionOfStringsOrSymbols at: index) asUppercase = canonicalName 				ifTrue: [^index]].	^block0 value</body><body package="Passport-Kernel" selector="isNilOrEmpty:">isNilOrEmpty: aValue	"UtilityFunction isNilOrEmpty: #()"	aValue == nil ifTrue: [^true].	^aValue isEmpty</body><body package="Passport-Kernel" selector="map:by:">map: aDictionary by: transformer	"Same as the ANSI-Standard defined behavior of #collect: when sent to &lt;aDictionary&gt;." 	| map |	map := aDictionary species new: aDictionary size.	aDictionary 		keysAndValuesDo: [:key :value | map at: key put: (transformer value: value)].	^map</body></methods><methods><class-id>Passport.UtilityFunction class</class-id> <category>printing services</category><body package="Passport-Kernel" selector="print:asPostDecimalOn:decimalPoint:scale:minPrecision:maxPrecision:prependingZero:">print: anInteger asPostDecimalOn: stream decimalPoint: decimalPointChar scale: scale minPrecision: minPrecision maxPrecision: maxPrecision prependingZero: shouldPrependZero	"Vary the scale:		{(5 to: 9) collect: [:scale | 			| stream |			stream := String new writeStream.			UtilityFunction				print: 91827				asPostDecimalOn: stream 				decimalPoint: $. 				scale: scale 				minPrecision: 1				maxPrecision: #all				prependingZero: true.			stream contents]}"	"Vary the minPrecision:		{(2 to: 4) collect: [:minPrecision | 			| stream |			stream := String new writeStream.			UtilityFunction				print: 9				asPostDecimalOn: stream 				decimalPoint: $. 				scale: 2 				minPrecision: minPrecision				maxPrecision: 4				prependingZero: true.			stream contents]}"	"Vary the maxPrecision:		{(0 to: 6) collect: [:maxPrecision | 			| stream |			stream := String new writeStream.			UtilityFunction				print: 91827				asPostDecimalOn: stream 				decimalPoint: $. 				scale: 6 				minPrecision: 1				maxPrecision: maxPrecision				prependingZero: true.			stream contents]}"	| isZero absValue n divisor d maxDigits z |	isZero := anInteger isZero.	(isZero and: [minPrecision &lt; 1]) ifTrue: [^self].	shouldPrependZero 		ifTrue: 			[anInteger negative ifTrue: [stream nextPut: $-].			stream nextPut: $0].	maxDigits := maxPrecision == #all ifTrue: [scale max: minPrecision] ifFalse: [maxPrecision].	maxDigits = 0 ifTrue: [^self].	stream nextPut: decimalPointChar.	isZero 		ifTrue: 			[(minPrecision min: maxPrecision) timesRepeat: [stream nextPut: $0]. 			^self].	absValue := anInteger abs.	d := 1.	n := 1.	divisor := 10.	[divisor &lt;= absValue] 		whileTrue: 			[d := d + 1.			n := divisor.			divisor := divisor * 10].	z := scale - d.	(z min: maxDigits) timesRepeat: [stream nextPut: $0].	z &gt;= maxDigits ifTrue: [^self].	d := z.	divisor := n.	n := absValue.	[d := d + 1.	divisor &gt; 1] 			whileTrue: 			[stream nextPut: (Character digitValue: (n quo: divisor)).			d &gt;= maxDigits ifTrue: [^self].			n := n rem: divisor.			n isZero ifTrue: 				[(minPrecision min: maxDigits) - d  timesRepeat: [stream nextPut: $0].				^self].			divisor := divisor // 10].	stream nextPut: (Character digitValue: n).	(minPrecision min: maxDigits) - d  timesRepeat: [stream nextPut: $0].</body><body package="Passport-Kernel" selector="print:paddedWith:to:on:">print: anInt paddedWith: padChar to: minDigits on: stream 	"There is no ANSI-standard message to an Integer that performs this operation.  One of the unfortunate sins of omission on the part of the ANSI Smalltalk Committee.  VisualWorks provides this functionality--but as of VW 7.2.1, it doesn't work correctly for negative integers."	"{| stream | 	stream := (String new: 10) writeStream.	UtilityFunction print: -1 paddedWith: $0 to: 4 on: stream.	stream contents}"	| digits padCount |	padChar == nil ifTrue: [^anInt printOn: stream].	digits := anInt abs printString.	anInt negative ifTrue: [stream nextPut: $-].	padCount := minDigits - digits size.	[padCount &gt; 0] whileTrue: 			[stream nextPut: padChar.			padCount := padCount - 1].	stream nextPutAll: digits</body><body package="Passport-Kernel" selector="printFractional:asDecimalOn:decimalPoint:precision:">printFractional: aNumber asDecimalOn: stream decimalPoint: decimalPointChar precision: precision	"{| stream |	stream := String new writeStream.	UtilityFunction		printFractional: 123.5d 		asDecimalOn: stream 		decimalPoint: $. 		precision: 2.	stream contents}" 	"{| stream |	stream := String new writeStream.	UtilityFunction		printFractional: 1/3		asDecimalOn: stream 		decimalPoint: $. 		precision: 33.	stream contents}"	aNumber isInteger		ifTrue: [aNumber printOn: stream]		ifFalse: 			[| int |			int := aNumber truncated.			int printOn: stream.			self				print: ((aNumber - int) * (10 raisedToInteger: precision)) rounded				asPostDecimalOn: stream				decimalPoint: decimalPointChar				scale: precision				minPrecision: precision 				maxPrecision: precision				prependingZero: false]</body></methods><methods><class-id>Chronos.ChronosFunction class</class-id> <category>date/time services</category><body package="Chronos-Foundation" selector="daysAndSecondsSinceStartOfDayFromSeconds:into:">daysAndSecondsSinceStartOfDayFromSeconds: seconds into: block2	"ChronosFunction daysAndSecondsSinceStartOfDayFromSeconds: Timepoint now secondsSinceEpch into: [:days :secondsSinceStartOfDay | Array with: days with: secondsSinceStartOfDay]"	| secondsDiv128 |	secondsDiv128 := seconds bitShift: -7. "Bit shifting is faster than LargeInteger math."	^block2 		value:  (secondsDiv128 // 675) "128 * 675 = 86400"		value: ((seconds bitAnd: 127) + (secondsDiv128 \\ 675 bitShift: 7)) "seconds \\ 128 + (seconds // 128 \\ 675 * 128)"</body><body package="Chronos-Foundation" selector="fromSeconds:hourMinuteSecondDo:">fromSeconds: secondsSinceStartOfTimeOfDayClock hourMinuteSecondDo: block3	| seconds hour minute second |	seconds := secondsSinceStartOfTimeOfDayClock.	hour := seconds // SecondsPerHour.	seconds := seconds \\ SecondsPerHour.	minute := seconds // SecondsPerMinute.	second := seconds \\ SecondsPerMinute.	^block3 value: hour value: minute value: second</body><body package="Chronos-Foundation" selector="secondsFromDays:">secondsFromDays: days	"ChronosFunction secondsFromDays: YearMonthDay today daysSinceEpoch"	^days * 675 bitShift: 7</body><body package="Chronos-Foundation" selector="twoDigitYearFromFullYear:">twoDigitYearFromFullYear: fullYear	"Answer the least two significant digits of the calendar year &lt;fullYear&gt; (which must be an Integer.)"	^fullYear rem: 100</body></methods><methods><class-id>Chronos.ChronosFunction class</class-id> <category>arithmetic services</category><body package="Chronos-Foundation" selector="divBy1000000000:">divBy1000000000: numerator	"[1000000 timesRepeat: [ChronosFunction divBy1000000000: 53694252136]] durationToRun"	"[1000000 timesRepeat: [53694252136 // 1000000000]] durationToRun"	"[1000000 timesRepeat: [ChronosFunction divBy1000000000: 33554431]] durationToRun"	"[1000000 timesRepeat: [33554431 // 1000000000]] durationToRun"	^(numerator bitShift: -9) // 1953125</body><body package="Chronos-Foundation" selector="times1000000:">times1000000: factor	"[1000000 timesRepeat: [ChronosFunction times1000000: 53694252]] durationToRun"	"[1000000 timesRepeat: [53694252 * 1000000]] durationToRun"	"[1000000 timesRepeat: [ChronosFunction times1000000: 33554431]] durationToRun"	"[1000000 timesRepeat: [33554431 * 1000000]] durationToRun"	^(factor bitShift: 6) * 15625</body><body package="Chronos-Foundation" selector="times1000:">times1000: factor	"[1000000 timesRepeat: [ChronosFunction times1000: 53694252]] durationToRun"	"[1000000 timesRepeat: [53694252 * 1000000]] durationToRun"	"[1000000 timesRepeat: [ChronosFunction times1000: 33554431]] durationToRun"	"[1000000 timesRepeat: [33554431 * 1000000]] durationToRun"	^(factor bitShift: 3) * 125</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="asMutableDate">asMutableDate	 ^self asMutableDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTime">asMutableDateAndTime	 | today |	today := AnsiStandardCalendarClock mutableDateTodayIn: ChronosTimezone default.	^(self class dateAndTimeFactory basicNew)		basicSetCalendar: AnsiStandardCalendar;		basicSetTimeZone: DateAndTimeFactory nominalTZ;		setYear: today year calendarDay: today calendarDay;		setTimeOfDay: self</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTimeInvariantToUT">asMutableDateAndTimeInvariantToUT	 | today |	today := AnsiStandardCalendarClock mutableDateTodayIn: ChronosTimezone default.	^(self class dateAndTimeFactory basicNew)		basicSetYear: today year calendarDay: today calendarDay;		setTimeOfDay: self;		canonicalizeFromLocalTime</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecond">basicNanosecondsSinceSecond	^nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceStartOfDay">basicSecondsSinceStartOfDay	^(hour * SecondsPerHour) + (minute * SecondsPerMinute) + second</body><body package="Chronos-DateTimeInterval" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self hour;		nextPut: self minute;		nextPut: self second;		nextPut: self nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:">hourMinuteSecondDo: block3 	^block3		value: hour		value: minute		value: second</body><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:hour24Format:">hourMinuteSecondDo: block3 hour24Format: hour24	^block3		value: (hour24 ifTrue: [hour] ifFalse: [self hour12])		value: minute		value: second</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="hour">hour	^hour</body><body package="Chronos-DateTimeInterval" selector="hoursSinceMidnight">hoursSinceMidnight	^hour</body><body package="Chronos-DateTimeInterval" selector="hoursSinceStartOfDay">hoursSinceStartOfDay 	^hour</body><body package="Chronos-DateTimeInterval" selector="minute">minute	^minute</body><body package="Chronos-DateTimeInterval" selector="minutesSinceMidnight">minutesSinceMidnight	^self minutesSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfDay">minutesSinceStartOfDay 	^hour * MinutesPerHour + minute</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfTimeOfDayClock">minutesSinceStartOfTimeOfDayClock	^self minutesSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	^nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^NanosecondDuration</body><body package="Chronos-DateTimeInterval" selector="second">second	^second</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	^(hour * SecondsPerHour) + (minute * SecondsPerMinute) + second</body><body package="Chronos-DateTimeInterval" selector="timeOfDay">timeOfDay	^self</body><body package="Chronos-DateTimeInterval" selector="timeOfDaySinceMidnight">timeOfDaySinceMidnight	^self</body><body package="Chronos-DateTimeInterval" selector="timeOfDaySinceStartOfDay">timeOfDaySinceStartOfDay	^self</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^true</body><body package="Chronos-DateTimeInterval" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the receiver's calendrical system starts each day at local midnight."	^true</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtMidnight">timeOfDayClockStartsAtMidnight	"Answer true if the zero-point of the time-of-day clock coincides with midnight"	^true</body><body package="Chronos-DateTimeInterval" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the receiver's calendrical system coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^true</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="addHours:">addHours: addedHours	self assertMutability.	hour := hour + addedHours.	hour isInteger		ifFalse:			[| h |			h := hour.			hour := hour truncated.			self addMinutes: (h - hour) * MinutesPerHour].	(hour &lt; 0 or: [hour &gt;= HoursPerDay])		ifTrue: [hour := hour \\ HoursPerDay]</body><body package="Chronos-DateTimeInterval" selector="addHours:minutes:">addHours: addedHours minutes: addedMinutes	self 		addMinutes: addedMinutes;		addHours: addedHours</body><body package="Chronos-DateTimeInterval" selector="addHours:minutes:seconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds	self 		addSeconds: addedSeconds;		addMinutes: addedMinutes;		addHours: addedHours</body><body package="Chronos-DateTimeInterval" selector="addHours:minutes:seconds:nanoseconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds	self 		addSeconds: addedSeconds nanoseconds: addedNanoseconds;		addMinutes: addedMinutes;		addHours: addedHours</body><body package="Chronos-DateTimeInterval" selector="addMinutes:">addMinutes: addedMinutes	self assertMutability.	minute := minute + addedMinutes.	minute isInteger		ifFalse:			[| m |			m := minute.			minute := minute truncated.			self addSeconds: (m - minute) * SecondsPerMinute].	(minute &lt; 0 or: [minute &gt;= MinutesPerHour])		ifTrue: 			[self addHours: minute // MinutesPerHour.			minute := minute \\ MinutesPerHour]</body><body package="Chronos-DateTimeInterval" selector="addSeconds:">addSeconds: seconds	"Add the given number of seconds to the time-of-day represented by the receiver."	seconds isInteger		ifTrue: 			[self assertMutability.			second := second + seconds]		ifFalse:			[| s |			s := seconds truncated.			self addSeconds: s nanoseconds: (s - seconds) * NanosecondsPerSecond].	(second &lt; 0 or: [second &gt;= MinutesPerHour])		ifTrue: 			[self addMinutes: second // MinutesPerHour.			second := second \\ MinutesPerHour]</body><body package="Chronos-DateTimeInterval" selector="addSeconds:nanoseconds:">addSeconds: seconds nanoseconds: nanoseconds 	"Add the given number of seconds and nanoseconds to the time-of-day represented by the receiver."	| nanoSecondsToAdd secondsToAdd |	nanoseconds = 0 ifTrue: [^self addSeconds:  seconds].	self assertMutability.	nanoSecondsToAdd := seconds isInteger		ifTrue: 			[secondsToAdd := seconds.			nanoseconds rounded]		ifFalse:			[secondsToAdd := seconds truncated.			((seconds - secondsToAdd) * NanosecondsPerSecond) rounded + nanoseconds rounded].	nanosecondsSinceSecond := nanosecondsSinceSecond + nanoSecondsToAdd.	(nanosecondsSinceSecond &lt; 0 		or: [nanosecondsSinceSecond &gt;= NanosecondsPerSecond]) 			ifTrue: 				[secondsToAdd := secondsToAdd +  ((nanosecondsSinceSecond bitShift: -9) // 1953125).				nanosecondsSinceSecond := nanosecondsSinceSecond \\ NanosecondsPerSecond].	secondsToAdd = 0		ifFalse:			[second := second + secondsToAdd.			(second &lt; 0 or: [second &gt;= SecondsPerMinute])				ifTrue: 					[self addMinutes: second // SecondsPerMinute.					second := second \\ SecondsPerMinute]]</body><body package="Chronos-DateTimeInterval" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	hour == nil		ifTrue: [hour := 0].	minute == nil		ifTrue: [minute := 0].	second == nil		ifTrue: [second := 0].	nanosecondsSinceSecond == nil		ifTrue: [nanosecondsSinceSecond := 0].</body><body package="Chronos-DateTimeInterval" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	hour := 0.	minute := 0.	second := 0.		nanosecondsSinceSecond := 0.</body><body package="Chronos-DateTimeInterval" selector="initializeFrom:">initializeFrom: aTemporalCoordinate 	self setNanosecondsSinceSecond: aTemporalCoordinate nanosecondsSinceSecond.		aTemporalCoordinate hourMinuteSecondDo: [:h :m :s | self setHour: h minute: m second: s].</body><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setNanosecondsSinceSecond: (literalArray at: 5) asNumber;		setHour: (literalArray at: 2) asNumber minute: (literalArray at: 3) asNumber second: (literalArray at: 4) asNumber</body><body package="Chronos-DateTimeInterval" selector="setHour:minute:second:">setHour: h minute: m second: s 	self validateHour: h minute: m second: s.	self assertMutability.	s isInteger		ifTrue: [second := s]		ifFalse:			[second := s truncated.			self setNanosecondsSinceSecond: (s - second) * NanosecondsPerSecond]	.	minute := m truncated.	hour := h truncated.	m isInteger ifFalse: [self addSeconds: (m - minute) * SecondsPerMinute nanoseconds: 0].	h isInteger ifFalse: [self addMinutes: (h - hour) * MinutesPerHour].</body><body package="Chronos-DateTimeInterval" selector="setNanosecondsSinceSecond:">setNanosecondsSinceSecond: n	self assertMutability.	nanosecondsSinceSecond := n truncated</body><body package="Chronos-DateTimeInterval" selector="setNanosecondsSinceStartOfDay:">setNanosecondsSinceStartOfDay: nanosecondsSinceStartOfDay	| nanoseconds |	nanoseconds := nanosecondsSinceStartOfDay rounded.	self 		setNanosecondsSinceSecond: (nanoseconds \\ NanosecondsPerSecond);		setSecondsSinceStartOfDay: (ChronosFunction divBy1000000000: nanoseconds)</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceStartOfDay:">setSecondsSinceStartOfDay: secondsSinceStartOfDay 	| seconds |	secondsSinceStartOfDay isInteger		ifTrue: [seconds := secondsSinceStartOfDay] 		ifFalse: 			[seconds := secondsSinceStartOfDay truncated.			self setNanosecondsSinceSecond: (secondsSinceStartOfDay - seconds) * NanosecondsPerSecond].	self assertMutability.	seconds := seconds abs &lt;= SecondsPerDay 				ifTrue: 					[secondsSinceStartOfDay positive 						ifTrue: [seconds]						ifFalse: [SecondsPerDay + seconds]]				ifFalse: [seconds \\ SecondsPerDay].	hour := seconds // SecondsPerHour.	seconds := seconds \\ SecondsPerHour.	minute := seconds // SecondsPerMinute.	second := seconds \\ SecondsPerMinute.	(hour == 24 and: [minute == 0 and: [second == 0]]) 		ifTrue: 			[hour := 23.			minute := 59.			second := 60]</body><body package="Chronos-DateTimeInterval" selector="subtractHours:minutes:seconds:nanoseconds:">subtractHours: subtractedHours minutes: subtractedMinutes seconds: subtractedSeconds nanoseconds: subtractedNanoseconds	self assertMutability.	nanosecondsSinceSecond := nanosecondsSinceSecond - subtractedNanoseconds.	second := second - subtractedSeconds.	minute := minute - subtractedMinutes.	hour := hour - subtractedHours.</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="&lt;&lt;">&lt;&lt; aChronosTimezone 	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but convert the date and time-of-day as though the receiver represented a date and time in the current default time zone (i.e,. preserve date and time-of-day in Universal Time as though the receiver represented a date and time in the current default time zone.)	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is the same as that of the receiver (i.e,, preserve local date and local time-of-day, don't preserve date or time-of-day in Universal Time.)"	"TimeOfDay now &lt;&lt; 10 hours"	"TimeOfDay now &lt;&lt; 'Australia/Adelaide'"	"TimeOfDay now &lt;&lt; #nominal"	"WeekOfMonthDayOfWeek today &lt;&lt; 'Pacific/Kiritimati'"	"(Timepoint nowIn: 'Pacific/Kiritimati') &lt;&lt; #nominal"	"(Timepoint nowIn: 'Pacific/Kiritimati') &lt;&lt; #default"	"(Timepoint nowIn: 'Pacific/Kiritimati') &lt;&lt; #system"	"Timepoint nominalNow &lt;&lt; 10 hours"	"Timepoint nominalNow &lt;&lt; 'Australia/Adelaide'"	| timeZone |	timeZone := ChronosTimezone referencedBy: aChronosTimezone.	timeZone isDefault ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTimeInvariantToUT] ifFalse: [self asDateAndTime]].	^((self asMutableDateAndTime)		deproxifyTimeZone;		convertToTimeZone: timeZone)			beImmutable</body><body package="Chronos-DateTimeInterval" selector="&gt;&gt;">&gt;&gt; aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"TimeOfDay now &gt;&gt; 10 hours"	"TimeOfDay now &gt;&gt; 'Australia/Adelaide'"	| newTimeZone |	newTimeZone := ChronosTimezone referencedBy: aChronosTimezone.	newTimeZone isDefault ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTimeInvariantToUT] ifFalse: [self asDateAndTime]].	^(self asMutableDateAndTime)		basicSetTimeZone: newTimeZone;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asCalendricalCoordinate">asCalendricalCoordinate	"Answer the conversion of the receiver into its equivalent value implemented as a CalendricalCoordinate.  If the receiver is already a CalendricalCoordinate, answer the receiver."	^self asNominalDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asNative">asNative	"Answer the native 'TimeOfDay' analog that semantically corresponds as closely as possible to the receiver."	"{TimeOfDay now asNative}"	^ChronosSystemFacade current nativeTimeOfDayFromChronosTimeOfDay: self</body><body package="Chronos-DateTimeInterval" selector="asSpec">asSpec	^self</body><body package="Chronos-DateTimeInterval" selector="atStartOfDay">atStartOfDay	^self class startOfDay</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="subtractedFromDuration:">subtractedFromDuration: aDuration	^aDuration		subtractingHours: self hour		minutes: self minute		seconds: self second		nanoseconds: self nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printTimeOfDay: self on: stream</body></methods><methods><class-id>Chronos.TimeOfDay</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="addTime:">addTime: anST80Time	^self addingSeconds: anST80Time asSeconds</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asSeconds">asSeconds	^self secondsSinceStartOfDay</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asTimestamp">asTimestamp	"TimeOfDay now asTimestamp"	"Time now asTimestamp"	^self class dateAndTimeFactory zero fromTime: self</body><body package="Chronos-ST80 (and VW) Compatibility" selector="hours">hours	^self hour</body><body package="Chronos-ST80 (and VW) Compatibility" selector="minutes">minutes	^self minute</body><body package="Chronos-ST80 (and VW) Compatibility" selector="printOn:policy:format:">printOn: aStream policy: aPolicy format: tokens 	"{Locale current printAsTime: TimeOfDay now policyNamed: #long}"	"{Locale current printAsTime: TimeOfDay now policyNamed: #short}"	| formatField |	formatField := (aPolicy numberOfFieldsIn: tokens) &gt; 2				ifTrue: [3]				ifFalse: [1].	aPolicy		print: (self class dateAndTimeFactory new fromDate: self class dateFactory today andTime: self)		on: aStream		using: (aPolicy fieldFormat: formatField for: tokens)</body><body package="Chronos-ST80 (and VW) Compatibility" selector="seconds">seconds	^self second</body><body package="Chronos-ST80 (and VW) Compatibility" selector="subtractTime:">subtractTime: anST80Time	^self subtractingSeconds: anST80Time asSeconds</body></methods><methods><class-id>Chronos.TimeOfDay class</class-id> <category>instance creation</category><body package="Chronos-DateTimeInterval" selector="hour:minute:second:">hour: hour minute: minute second: second	"{TimeOfDay hour: 13 minute: 44 second: 15}"	^self basicNew		setHour: hour minute: minute second: second;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="hour:minute:second:nanosecond:">hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond	"{TimeOfDay hour: 13 minute: 44 second: 15 nanosecond: 418000000}"	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceStartOfDay:">nanosecondsSinceStartOfDay: nanosecondsSinceStartOfDay	"{TimeOfDay nanosecondsSinceStartOfDay: 86399999999999}"	^self basicNew		setNanosecondsSinceStartOfDay: nanosecondsSinceStartOfDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="now">now		"{TimeOfDay now}"	^AnsiStandardCalendarClock timeOfDayNow</body><body package="Chronos-DateTimeInterval" selector="nowIn:">nowIn: aTimezone	"{TimeOfDay nowIn: 'Asia/Calcutta'}"	^AnsiStandardCalendarClock timeOfDayNowIn: aTimezone</body><body package="Chronos-DateTimeInterval" selector="nowToTheSecond">nowToTheSecond	"{TimeOfDay nowToTheSecond}"	^AnsiStandardCalendarClock timeOfDayNowToTheSecond</body><body package="Chronos-DateTimeInterval" selector="nowToTheSecondIn:">nowToTheSecondIn: aTimezone	"{TimeOfDay nowToTheSecondIn: 'Asia/Calcutta'}"	^AnsiStandardCalendarClock timeOfDayNowToTheSecondIn: aTimezone</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextTimeOfDayFrom: stream usingFactory: self</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay:">secondsSinceStartOfDay: secondsSinceStartOfDay	"{TimeOfDay secondsSinceStartOfDay: 86399}"	"{TimeOfDay secondsSinceStartOfDay: 86400}"	"{TimeOfDay secondsSinceStartOfDay: 86401}"	^self basicNew		setSecondsSinceStartOfDay: secondsSinceStartOfDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay:nanoseconds:">secondsSinceStartOfDay: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond	"{TimeOfDay secondsSinceStartOfDay: 86399 nanoseconds: 999999999}"	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setSecondsSinceStartOfDay: secondsSinceStartOfDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utNow">utNow		"{TimeOfDay utNow}"	^AnsiStandardCalendarClock utTimeOfDayNow</body></methods><methods><class-id>Chronos.TimeOfDay class</class-id> <category>class initialization</category><body package="Chronos-DateTimeInterval" selector="initialize">initialize	"TimeOfDay initialize" 	StartOfDay := nil.</body></methods><methods><class-id>Chronos.TimeOfDay class</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="initializeStartOfDay">initializeStartOfDay	StartOfDay := self secondsSinceStartOfDay: 0 nanoseconds: 0</body></methods><methods><class-id>Chronos.TimeOfDay class</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="startOfDay">startOfDay	"{TimeOfDay startOfDay}"	StartOfDay == nil ifTrue: [self initializeStartOfDay].	^StartOfDay</body></methods><methods><class-id>Chronos.TimeOfDay class</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="fromSeconds:">fromSeconds: secondsSinceStartOfDay 	"Answer a TimeOfDay that is &lt;secondsSinceStartOfDay&gt; seconds since the zero-point of the time-of-day clock."	^self new 		setSecondsSinceStartOfDay: secondsSinceStartOfDay;			beImmutable</body></methods><methods><class-id>Passport.ResourceBroker</class-id> <category>private</category><body package="Passport-Kernel" selector="baseDirectory">baseDirectory	^self context 		resourcePathTo: self baseDirectoryKey		ifNone: [self context defaultResourcePath]</body><body package="Passport-Kernel" selector="defaultDecodeSelector">defaultDecodeSelector	^#decodeFrom:</body><body package="Passport-Kernel" selector="defaultEncodeSelector">defaultEncodeSelector	^#encodeOn:</body><body package="Passport-Kernel" selector="defaultStreamType">defaultStreamType	^#text</body><body package="Passport-Kernel" selector="readStreamAt:do:ifAbsent:">readStreamAt: key do: block1 ifAbsent: ifAbsentBlock	| rp stream value |	rp := self resourcePathForKey: key createBaseDirIfAbsent: false.	rp exists ifFalse: [^ifAbsentBlock value].	[stream := self readStreamFrom: rp.		value := block1 value: stream] ensure: [stream close].	^value</body><body package="Passport-Kernel" selector="readStreamAt:do:ifAbsentThenWriteStreamAt:do:">readStreamAt: readKey do: readStreamBlock1 ifAbsentThenWriteStreamAt: writeKey do: writeStreamBlock1	| rp stream value |	rp := self resourcePathForKey: readKey createBaseDirIfAbsent: false.	rp exists 		ifTrue: 			[[stream := self readStreamFrom: rp.			value := readStreamBlock1 value: stream] ensure: [stream close]]		ifFalse: 			[readKey = writeKey ifFalse: [rp := self resourcePathForKey: writeKey createBaseDirIfAbsent: true].			rp prefix makeDirectory.			[stream := self writeStreamFrom:  rp.			value := writeStreamBlock1 value: stream] ensure: [stream close]].	^value</body><body package="Passport-Kernel" selector="readStreamFrom:">readStreamFrom: aResoucePath	^aResoucePath readStreamWithType: self streamType</body><body package="Passport-Kernel" selector="resourcePathForKey:createBaseDirIfAbsent:">resourcePathForKey: aKey createBaseDirIfAbsent: createBaseDirIfAbsent 	| rp |	rp := self baseDirectory.	rp exists		ifFalse: 			[createBaseDirIfAbsent 				ifTrue: [rp makeDirectory]				ifFalse: 					[(self context handleNonExistenceOfResourcePathReferencedBy: self baseDirectoryKey)						ifTrue: [rp := self baseDirectory]						ifFalse: [rp := self context defaultResourcePath]]].	^(rp , ((Pathname fromString: aKey)) appendingExtension: elementExtension)</body><body package="Passport-Kernel" selector="storeValue:on:">storeValue: aValue on: stream	aValue perform: encodeSelector with: stream.	self streamTypeIsText ifTrue: [stream cr].	^aValue</body><body package="Passport-Kernel" selector="valueFromStream:">valueFromStream: stream	^factory perform: decodeSelector with: stream</body><body package="Passport-Kernel" selector="writeStreamAt:do:">writeStreamAt: key do: block1	| rp stream value |	rp := self resourcePathForKey: key createBaseDirIfAbsent: true.	rp prefix makeDirectory.	[stream := self writeStreamFrom: rp.		value := block1 value:  stream] ensure: [stream close].	^value</body><body package="Passport-Kernel" selector="writeStreamFrom:">writeStreamFrom: aResoucePath	^aResoucePath writeStreamWithMode: #truncate check: false type: self streamType</body></methods><methods><class-id>Passport.ResourceBroker</class-id> <category>accessing</category><body package="Passport-Kernel" selector="baseDirectoryKey">baseDirectoryKey	^baseDirectoryKey</body><body package="Passport-Kernel" selector="baseDirectoryKey:">baseDirectoryKey: anObject	baseDirectoryKey := anObject</body><body package="Passport-Kernel" selector="context">context	^context == nil		ifTrue: [ResourcePathContext default]		ifFalse: [context]</body><body package="Passport-Kernel" selector="context:">context: aResourcePathContext	context := aResourcePathContext</body><body package="Passport-Kernel" selector="decodeSelector">decodeSelector	^decodeSelector</body><body package="Passport-Kernel" selector="decodeSelector:">decodeSelector: aSymbol	decodeSelector := aSymbol</body><body package="Passport-Kernel" selector="elementExtension">elementExtension	^elementExtension</body><body package="Passport-Kernel" selector="elementExtension:">elementExtension: anObject	elementExtension := anObject</body><body package="Passport-Kernel" selector="encodeSelector">encodeSelector	^encodeSelector</body><body package="Passport-Kernel" selector="encodeSelector:">encodeSelector: aSymbol	encodeSelector := aSymbol</body><body package="Passport-Kernel" selector="factory">factory	^factory</body><body package="Passport-Kernel" selector="factory:">factory: anObject	factory := anObject</body><body package="Passport-Kernel" selector="newReferenceTo:">newReferenceTo: key	^ExternalResourceReference new		broker: self;		key: key</body><body package="Passport-Kernel" selector="streamType">streamType	^streamType == nil ifTrue: [self defaultStreamType]</body><body package="Passport-Kernel" selector="streamType:">streamType: aSymbol	streamType := aSymbol</body></methods><methods><class-id>Passport.ResourceBroker</class-id> <category>accessing-remote values</category><body package="Passport-Kernel" selector="at:ifAbsent:">at: key ifAbsent: ifAbsentBlock 	^self 		readStreamAt: key		do: [:stream | self valueFromStream: stream]		ifAbsent: [^ifAbsentBlock value]</body><body package="Passport-Kernel" selector="at:ifAbsentPut:">at: key ifAbsentPut: valueBlock 	^self 		readStreamAt: key		do: [:stream | self valueFromStream: stream]		ifAbsentThenWriteStreamAt: key do: [:stream | self storeValue: valueBlock value on: stream]</body><body package="Passport-Kernel" selector="at:ifAbsentThenAt:put:">at: readKey ifAbsentThenAt: writeKey put: valueBlock 	^self 		readStreamAt: readKey		do: [:stream | self valueFromStream: stream]		ifAbsentThenWriteStreamAt: writeKey do: [:stream | self storeValue: valueBlock value on: stream]</body><body package="Passport-Kernel" selector="at:put:">at: key put: aValue	self 		writeStreamAt: key		do: [:stream | self storeValue: aValue on: stream].	^aValue</body><body package="Passport-Kernel" selector="removeKey:ifAbsent:">removeKey: aKey ifAbsent: aBlock	| rp inactive |	rp := self resourcePathForKey: aKey createBaseDirIfAbsent: false.	rp exists ifFalse: [^aBlock value].	inactive := rp withoutExtension.	inactive exists ifTrue: [inactive delete].	rp renameTo: inactive.	^nil</body></methods><methods><class-id>Passport.ResourceBroker</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="initialize">initialize	encodeSelector := self defaultEncodeSelector.	decodeSelector := self defaultDecodeSelector.</body></methods><methods><class-id>Passport.ResourceBroker</class-id> <category>testing</category><body package="Passport-Kernel" selector="streamTypeIsBinary">streamTypeIsBinary	^self streamType == #binary</body><body package="Passport-Kernel" selector="streamTypeIsText">streamTypeIsText	^self streamType == #text</body></methods><methods><class-id>Passport.ResourceBroker</class-id> <category>queries</category><body package="Passport-Kernel" selector="includesKey:">includesKey: key	^(self resourcePathForKey: key createBaseDirIfAbsent: false) exists</body></methods><methods><class-id>Chronos.Timescale</class-id> <category>interconversion</category><body package="Chronos-Timescales" selector="secondsSinceEpochFromDaysSinceEpoch:">secondsSinceEpochFromDaysSinceEpoch: daysSinceEpoch	^self subclassResponsibility</body><body package="Chronos-Timescales" selector="secondsSinceEpochFromForeignSecondsSinceEpoch:convertingFrom:">secondsSinceEpochFromForeignSecondsSinceEpoch: foreignSecondsSinceEpoch convertingFrom: aForeignTimescale 	^self 		secondsSinceEpochFromSecondsSinceUnificationEpoch: 			(aForeignTimescale 				secondsSinceUnificationEpochFromSecondsSinceEpoch: foreignSecondsSinceEpoch)</body><body package="Chronos-Timescales" selector="secondsSinceEpochFromSecondsSinceUnificationEpoch:">secondsSinceEpochFromSecondsSinceUnificationEpoch: secondsSinceUnificationEpoch	"Answer the number of seconds since the initial moment of the receiver's timescale, converted from &lt;secondsSinceUnificationEpoch&gt; seconds from the initial moment of the unification timescale."	^secondsSinceUnificationEpoch - secondsSinceUnificationEpochUpToEpoch</body><body package="Chronos-Timescales" selector="secondsSinceUnificationEpochFromSecondsSinceEpoch:">secondsSinceUnificationEpochFromSecondsSinceEpoch: secondsSinceEpoch	"Answer the number of seconds since the initial moment of the unification timescale, converted from &lt;secondsSinceEpoch&gt; seconds from the initial moment of the receiver's timescale."	^secondsSinceEpoch + secondsSinceUnificationEpochUpToEpoch</body></methods><methods><class-id>Chronos.Timescale</class-id> <category>initialize-release</category><body package="Chronos-Timescales" selector="initialize">initialize	"Initialize the receiver so that it becomes fully functional as a Calendar object that implements a particular calenrdical system. Fail if the receiver is not mutable."	self initializeConversionFactors.</body><body package="Chronos-Timescales" selector="secondsSinceJulianDayEpochUpToEpoch:">secondsSinceJulianDayEpochUpToEpoch: seconds	"Set the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's time scale."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	"Example 'de novo' calculation for the Gregorian Calendar:		 {| uDays uSeconds |		uDays := Gregorian 					daysSinceEpochUpToMonth: 11					day: 24					inYear: -4713.		uSeconds := uDays * 86400.		uSeconds negated - Gregorian secondsSinceStartOfDayAtStartOfJulianDay}"	"Example 'de novo' calculation for the Hebrew Calendar:		 {| uDays uSeconds |		uDays := HebrewCalendar canonical					daysSinceEpochUpToMonth: 4					day: 20					inYear: -952.		uSeconds := uDays * 86400.		uSeconds negated - HebrewCalendar canonical secondsSinceStartOfDayAtStartOfJulianDay}"	self assertMutability.	secondsSinceJulianDayEpochUpToEpoch := seconds</body></methods><methods><class-id>Chronos.Timescale</class-id> <category>private</category><body package="Chronos-Timescales" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the receiver's timescale."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	"Example 'de novo' calculation for the Gregorian Calendar:		 {| uDays uSeconds |		uDays := Gregorian 					daysSinceEpochUpToMonth: 11					day: 24					inYear: -4713.		uSeconds := uDays * 86400.		uSeconds negated - Gregorian secondsSinceStartOfDayAtStartOfJulianDay}"	"Example 'de novo' calculation for the Hebrew Calendar:		 {| uDays uSeconds |		uDays := HebrewCalendar canonical					daysSinceEpochUpToMonth: 4					day: 20					inYear: -952.		uSeconds := uDays * 86400.		uSeconds negated - HebrewCalendar canonical secondsSinceStartOfDayAtStartOfJulianDay}"	self subclassResponsibility</body><body package="Chronos-Timescales" selector="initializeConversionFactors">initializeConversionFactors	"Initialize the instance variables of the receiver that store values used to convert between timescales, or that otherwise serve to provide temporal reference points for interpreting point-in-time values in the receiver's timescale in a timescale-neutral manner."	self secondsSinceJulianDayEpochUpToEpoch: self computeSecondsSinceJulianDayEpochUpToEpoch.	self setSecondsSinceUnificationEpochUpToEpoch</body><body package="Chronos-Timescales" selector="setSecondsSinceUnificationEpochUpToEpoch">setSecondsSinceUnificationEpochUpToEpoch	"Set the number of seconds since the initial moment of the unification timescale up to the initial moment of the receiver's timescale."	self assertMutability.	secondsSinceUnificationEpochUpToEpoch := secondsSinceJulianDayEpochUpToEpoch - Timescale unification secondsSinceJulianDayEpochUpToEpoch</body></methods><methods><class-id>Chronos.Timescale</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-Timescales" selector="fromFractionalSecondsSinceEpoch:relativeToUT:setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto:">fromFractionalSecondsSinceEpoch: secondsSinceEpoch relativeToUT: isRelativeToUT setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: aTimepoint 	| integerSeconds |	integerSeconds := secondsSinceEpoch truncated.	self 		fromSecondsSinceEpoch: integerSeconds		andNanosecondsSinceSecond: (secondsSinceEpoch - integerSeconds) * NanosecondsPerSecond		relativeToUT: isRelativeToUT		setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: aTimepoint</body><body package="Chronos-Timescales" selector="fromSecondsSinceEpoch:andNanosecondsSinceSecond:specifiedAsUT:setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto:">fromSecondsSinceEpoch: secondsSinceEpoch andNanosecondsSinceSecond: nanosecondsSinceSecond specifiedAsUT: isSpecifiedAsUT setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: aTimepoint 	^self subclassResponsibility</body></methods><methods><class-id>Chronos.Timescale</class-id> <category>accessing</category><body package="Chronos-Timescales" selector="secondsSinceJulianDayEpochUpToEpoch">secondsSinceJulianDayEpochUpToEpoch	"Answer the number of seconds since the initial moment (Noon) of Julian Day 0 (Monday, January 1, 4713 BC in the proleptic Julian calendar; or November 24, -4713 in the proleptic Gregorian calendar) up to the initial moment of the receiver's time scale."	^secondsSinceJulianDayEpochUpToEpoch</body></methods><methods><class-id>Chronos.Timescale class</class-id> <category>accessing</category><body package="Chronos-Timescales" selector="default">default 	^self unification</body><body package="Chronos-Timescales" selector="unification">unification 	^UT1Timescale new</body></methods><methods><class-id>Chronos.Timescale class</class-id> <category>private</category><body package="Chronos-Timescales" selector="newRegistry">newRegistry	^IdentityDictionary new</body></methods><methods><class-id>Chronos.TerrestrialTimescale</class-id> <category>private</category><body package="Chronos-Timescales" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the receiver's timescale."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1721425 * SecondsPerDay +  43200</body></methods><methods><class-id>Chronos.TerrestrialTimescale</class-id> <category>interconversion</category><body package="Chronos-Timescales" selector="secondsSinceEpochFromDaysSinceEpoch:">secondsSinceEpochFromDaysSinceEpoch: daysSinceEpoch	^daysSinceEpoch * 675 bitShift: 7</body></methods><methods><class-id>Chronos.TerrestrialTimescale</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-Timescales" selector="fromSecondsSinceEpoch:andNanosecondsSinceSecond:specifiedAsUT:setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto:">fromSecondsSinceEpoch: secondsSinceEpoch andNanosecondsSinceSecond: nanosecondsSinceSecond specifiedAsUT: isSpecifiedAsUT setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: aTimepoint 	| secondsDiv128 secondsMod128 |	secondsDiv128 := secondsSinceEpoch bitShift: -7.	"Bit shifting is faster than LargeInteger math."	secondsMod128 := secondsSinceEpoch bitAnd: 127.	aTimepoint 		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7);	"secondsSinceEpoch \\ 128 + (seconds // 128 \\ 675 * 128)"		basicSetDaysSinceEpoch: secondsDiv128 // 675.	"128 * 675 = 86400"	isSpecifiedAsUT		ifTrue: [aTimepoint canonicalizeFromUT]		ifFalse: [aTimepoint canonicalizeFromLocalTime]</body></methods><methods><class-id>Chronos.TerrestrialTimescale class</class-id> <category>private</category><body package="Chronos-Timescales" selector="newRegistry">newRegistry	^self superclass registry</body></methods><methods><class-id>Chronos.UT1Timescale</class-id> <category>private</category><body package="Chronos-Timescales" selector="setSecondsSinceUnificationEpochUpToEpoch">setSecondsSinceUnificationEpochUpToEpoch	"Set the number of seconds since the initial moment of the unification timescale up to the initial moment of the receiver's timescale."	self assertMutability.	secondsSinceUnificationEpochUpToEpoch := 0</body></methods><methods><class-id>Chronos.UT1Timescale class</class-id> <category>private</category><body package="Chronos-Timescales" selector="newRegistry">newRegistry	^self superclass registry</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="hasEffectiveYear">hasEffectiveYear	^effectiveYear notNil</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="hasEverBeenInEffect">hasEverBeenInEffect	^self effectiveYearIsLessThanOrEqualTo: 		(self effectiveYearTimeZone dateTodayAs: effectiveYearCalendarKey) year</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="isNotYetInEffect">isNotYetInEffect	^self hasEverBeenInEffect not</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="isSymmetric">isSymmetric	"Answer true the receiver should create instances of TimeZonePolicy, and false if the receiver should create instances of AsymmetricTimeZonePolicy. See the class comment of AsymmetricTimeZonePolicy for an explanation of the difference."	^isSymmetric</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^annuallyRecurringTransitions contains: [:each | each specifiesCommonAbbreviation]</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>queries</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYearIsGreaterThanOrEqualTo:">effectiveYearIsGreaterThanOrEqualTo: aYear	^effectiveYear == nil 		ifTrue: [aYear == nil]		ifFalse: 			[aYear == nil 				ifTrue: [true]				ifFalse: [aYear &lt;= effectiveYear]]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYearIsLessThanOrEqualTo:">effectiveYearIsLessThanOrEqualTo: aYear	^effectiveYear == nil 		ifTrue: [true]		ifFalse: 			[aYear == nil 				ifTrue: [false]				ifFalse: [aYear &gt;= effectiveYear]]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="isSymmetricTransitionTo:">isSymmetricTransitionTo: nextTZOffsetPolicySpec 	| element0 element1 |	element0 := annuallyRecurringTransitions last.	element1 := nextTZOffsetPolicySpec annuallyRecurringTransitions first.	^element0 = element1 		ifTrue: 			[| onLastDayOfYear |			annuallyRecurringTransitions size &gt; 1 				ifTrue: 					[element0 := annuallyRecurringTransitions at: annuallyRecurringTransitions size - 1.					onLastDayOfYear := element0 transitionOccursOnLastDayOfYear: nextTZOffsetPolicySpec effectiveYear - 1]				ifFalse: [onLastDayOfYear := false].			(onLastDayOfYear or: [element1 transitionOccursOnFirstDayOfYear: nextTZOffsetPolicySpec effectiveYear]) not]		ifFalse: [false]</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self effectiveYear;		nextPut: self isSymmetric;		nextPut: (annuallyRecurringTransitions collect: [:element | element literalArrayEncoding])</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="timeZonePolicyClass">timeZonePolicyClass	^self isSymmetric		ifTrue: [TimeZonePolicy]		ifFalse: [AsymmetricTimeZonePolicy]</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>comparing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="=">= otherMagnitude	^self == otherMagnitude</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="compareTo:">compareTo: otherMagnitude	"Compare the value of the receiver to that of &lt;otherMagnitude&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;otherMagnitude&gt; are the same.)"	| otherEffectiveYear |	self == otherMagnitude ifTrue: [^0].	effectiveYear = (otherEffectiveYear := otherMagnitude effectiveYear) ifTrue: [^0].	effectiveYear == nil ifTrue: [^-1].	otherEffectiveYear == nil ifTrue: [^1].	^effectiveYear - otherEffectiveYear</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="hash">hash	^self identityHash</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	effectiveYearCalendarKey := #Gregorian.	effectiveYearRelativity := #nominal.	annuallyRecurringTransitions := Array new.	isSymmetric := true.</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	| yearLiteral |	yearLiteral := literalArray at: 2.	self setEffectiveYear: (yearLiteral == nil ifFalse: [yearLiteral asNumber]).	(literalArray at: 3) ifFalse: [self setAsNonSymmetric].	self setAnnuallyRecurringTransitions: ((literalArray at: 4) collect: [:elementLiteral | elementLiteral decodeAsLiteralArray])</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setAnnuallyRecurringTransitions:">setAnnuallyRecurringTransitions: anArrayOfAnnuallyRecurringTransitions	self assertMutability.	annuallyRecurringTransitions := anArrayOfAnnuallyRecurringTransitions</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setAsNonSymmetric">setAsNonSymmetric	self assertMutability.	isSymmetric := false</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setEffectiveYear:">setEffectiveYear: aYear	self assertMutability.	effectiveYear := aYear</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setEffectiveYearCalendarKey:">setEffectiveYearCalendarKey: aSymbol	self assertMutability.	effectiveYearCalendarKey := aSymbol</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setEffectiveYearRelativity:">setEffectiveYearRelativity: aSymbol	self assertMutability.	effectiveYearRelativity := aSymbol</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setKey:">setKey: aKey	self assertMutability.	key := aKey == nil ifFalse: [aKey asSymbol].</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setSymmetryBasedOnTransitionFrom:">setSymmetryBasedOnTransitionFrom: prevTZOffsetPolicySpec	isSymmetric := prevTZOffsetPolicySpec isSymmetricTransitionTo: self.</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="annuallyRecurringTransitions">annuallyRecurringTransitions	^annuallyRecurringTransitions</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="annuallyRecurringTransitionsCount">annuallyRecurringTransitionsCount	^annuallyRecurringTransitions size</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYear">effectiveYear	^effectiveYear</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYear:">effectiveYear: aYear	^self copy		setEffectiveYear: aYear;		beImmutable</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYearCalendar">effectiveYearCalendar	^Calendar at: effectiveYearCalendarKey</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYearCalendarKey">effectiveYearCalendarKey	^effectiveYearCalendarKey = nil ifTrue: [#Gregorian] ifFalse: [effectiveYearCalendarKey]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYearRelativity">effectiveYearRelativity	^effectiveYearRelativity</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="effectiveYearTimeZone">effectiveYearTimeZone	^effectiveYearRelativity == #universal 		ifTrue: [ChronosTimezone universal]		ifFalse: [ChronosTimezone at: self key]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="key">key	^key</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="registrationKey">registrationKey	^key</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="semanticKey">semanticKey		"Answer a value that identifies the conceptual type of the receiver."	^self hasEffectiveYear		ifTrue: [#SinceEffectiveYearTimeZoneAnnualTransitionPolicy]		ifFalse:[#SinceForeverTimeZoneAnnualTransitionPolicy]</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>printing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="encodeOn:">encodeOn: stream 	stream 		print: effectiveYear;		space;		print: self isSymmetric.	annuallyRecurringTransitions do: 			[:each | 			stream space.			each encodeOn: stream].</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="printOn:">printOn: stream	stream		cr; tab;		nextPut: ${;		nextPutAll: self class name;		nextPut: $};		cr; tab; tab; nextPutAll: 'effectiveYear=';		print: self effectiveYear;		tab; nextPutAll: ' isSymmetric=';		print: self isSymmetric;		cr; tab; tab; nextPutAll: 'annuallyRecurringTransitions=';		print: annuallyRecurringTransitions</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>processing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processTimezoneAnnualTransitionPolicyFactory: self.</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>enumerating</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="annuallyRecurringTransitionsDo:">annuallyRecurringTransitionsDo: block2	| index | 	index := 0.	annuallyRecurringTransitions do: [:each | block2 value: (index := index + 1) value: each]</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory</class-id> <category>converting</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="asPolicyFor:">asPolicyFor: anUnboundDynamicTimeZone 	| interYearPolicy annualPolicyChain |	interYearPolicy := self timeZonePolicyClass  newFor: anUnboundDynamicTimeZone.	annualPolicyChain := nil.	annuallyRecurringTransitions do: 			[:annualPolicyElement | 			| annualPolicy |			annualPolicy := annualPolicyElement asPolicyFor: interYearPolicy.			annualPolicyChain == nil 				ifTrue: [annualPolicyChain := annualPolicy]				ifFalse: [annualPolicyChain := annualPolicyChain asListSortedInCanonicalOrderByTransitionTimeAdding: annualPolicy]].	^interYearPolicy		setEffectiveYear: effectiveYear;		setEffectiveYearCalendar: self effectiveYearCalendar;		setEffectiveYearRelativity: effectiveYearRelativity;		setAnnualPolicy: annualPolicyChain</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory class</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="decodeFrom:key:">decodeFrom: stream key: tzKey	"{TimeZoneAnnualTransitionPolicyFactory 		decodeFrom: 			'1990 true Until-Annual-Date-Transition:NZDT:46800:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|3|15|1|0) Until-Annual-Date-Transition:NZST:43200:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|10|1|1|0) Until-End-Of-Year:NZDT:46800:43200' readStream key: #'Pacific/Auckland'}"	"{TimeZoneAnnualTransitionPolicyFactory 		decodeFrom: 			'Julian 1990 true Until-Annual-Date-Transition:NZDT:46800:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|3|15|1|0) Until-Annual-Date-Transition:NZST:43200:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|10|1|1|0) Until-End-Of-Year:NZDT:46800:43200' readStream key: #'Pacific/Auckland'}"	"{TimeZoneAnnualTransitionPolicyFactory 		decodeFrom: 			'nil true Until-Annual-Date-Transition:NZDT:46800:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|3|15|1|0) Until-Annual-Date-Transition:NZST:43200:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|10|1|1|0) Until-End-Of-Year:NZDT:46800:43200' readStream key: #'Pacific/Auckland'}"	| calendar effectiveYear polarity yearRelativity isSymmetric encodedAnnuallyRecurringTransitions policy |	ChronosFunction skipSeparators: stream.	stream peek isLetter		ifTrue: 			[calendar := ChronosFunction nextFrom: stream until: [:ch | ch isSeparator].			calendar = 'nil' 				ifTrue: 					[calendar := #Gregorian.					effectiveYear := #negativeInfinity]				ifFalse: [calendar := calendar asSymbol]]		ifFalse: [calendar := #Gregorian].	effectiveYear = #negativeInfinity		ifTrue: 			[effectiveYear := nil.			yearRelativity := #nominal]		ifFalse:			[| c index |			(c := stream peek) isDigit				ifTrue: [polarity := 1]				ifFalse: 					[index := #($- $+) indexOf: c ifAbsent: [0].					index &gt; 0						ifTrue: 							[polarity := #(1 -1) at: index.							stream next]						ifFalse: [polarity := 1]].			effectiveYear = #negativeInfinity				ifTrue: [effectiveYear := nil]				ifFalse: 					[effectiveYear := 						ChronosFunction 							nextUnsignedIntegerFrom: stream 							minDigits: 1 							maxDigits: 10 							acceptancePredicate: [:int :digitCount | true] 							handleRejection: [:value :digitCount :rejectionReason | 								self signalError: (digitCount &lt; 1 ifTrue: ['Invalid effective year-- must be a number'] ifFalse: ['Invalid effective year--too many digits'])].					index := #($u $s $n) indexOf: stream peek ifAbsent: [0].					yearRelativity := index &gt; 0											ifTrue: 													[stream next.													#(universal standard nominal) at: index]											ifFalse: [#nominal]]].	ChronosFunction skipSeparators: stream.	isSymmetric := (ChronosFunction nextFrom: stream until: [:ch | ch isSeparator]) = 'true'.	encodedAnnuallyRecurringTransitions := 		ChronosFunction 			componentsFromStream: (ChronosFunction nextLineFrom: stream) readStream			separator: $ .	policy := self new		setKey: tzKey;		setEffectiveYear: (effectiveYear == nil ifFalse: [effectiveYear * polarity]);		setEffectiveYearCalendarKey: calendar;		setEffectiveYearRelativity: yearRelativity;		setAnnuallyRecurringTransitions: (encodedAnnuallyRecurringTransitions collect: [:each | AnnuallyRecurringTZPolicyFactory decodeFrom: each readStream]).	isSymmetric ifFalse: [policy setAsNonSymmetric].	^policy beImmutable</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="key:effectiveYear:annuallyRecurringTransitions:">key: aKey effectiveYear: aYear annuallyRecurringTransitions: anArrayOfAnnuallyRecurringTransitions	^self new		setKey: aKey;		setEffectiveYear: aYear;		setAnnuallyRecurringTransitions: anArrayOfAnnuallyRecurringTransitions;		beImmutable</body></methods><methods><class-id>Chronos.TimeZoneAnnualTransitionPolicyFactory class</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="appOrLibraryName">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.StaticMonthlyCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="advanceToNextMonth:after:">advanceToNextMonth: aMonthlyCalendarSpecification after: prev	self assertMutability.	key := aMonthlyCalendarSpecification monthKey.	nameKey := aMonthlyCalendarSpecification nameKey.	nextInYear := nil.	prevInYear := prev.	monthOrdinal := monthOrdinal + 1.	isLeap := aMonthlyCalendarSpecification isLeapMonth.	isIntercalary := isLeap or: [aMonthlyCalendarSpecification isIntercalaryMonth].	daysUpToMonthSinceStartOfYear := daysUpToMonthSinceStartOfYear + prev daysPerMonth.	leapDayOrdinals := aMonthlyCalendarSpecification leapDayOrdinals.	self setDaysPerMonth: aMonthlyCalendarSpecification daysPerMonth</body><body package="Chronos-Calendars-Regular" selector="calendarDayClass">calendarDayClass	"Answer the concrete subclass of CalendarDays that should be used to instantiate CalendarDays to represent the days of the receiver's month."	^StaticCalendarDay</body><body package="Chronos-Calendars-Regular" selector="newFirstDayOfMonth">newFirstDayOfMonth	^self calendarDayClass firstDayOfMonth: self</body><body package="Chronos-Calendars-Regular" selector="newForNextMonth:">newForNextMonth: aCalendarMonthSepcification	self assertMutability.	nextInYear := self copy.	nextInYear advanceToNextMonth: aCalendarMonthSepcification after: self.	self beImmutable.	^nextInYear</body><body package="Chronos-Calendars-Regular" selector="nextInYear">nextInYear	^nextInYear</body><body package="Chronos-Calendars-Regular" selector="setDaysPerMonth:">setDaysPerMonth: daysPerMonth	"Initialize the receiver so that it represents a month with &lt;daysPerMonth&gt; days. Fail if the receiver is immutable."	| d |	self assertMutability.	days := Array new: daysPerMonth.	d := prevInYear == nil 		ifTrue: [self newFirstDayOfMonth] 		ifFalse: [prevInYear lastDay newForNextDayOfNextMonth].	days at: 1 put: d.	2 to: days size do: [:i | days at: i put: (d := d newForNextDayOfMonth)].</body></methods><methods><class-id>Chronos.StaticMonthlyCalendar</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="basicDayAt:">basicDayAt: dayOfMonthOrdinal	"Answer the CalendarDay with the given &lt;dayOfMonthOrdinal&gt;.  Fail if the &lt;dayOfMonthOrdinal&gt; is invalid."	^days at: dayOfMonthOrdinal</body><body package="Chronos-Calendars-Regular" selector="dayAt:">dayAt: dayOfMonthOrdinal	"Answer the CalendarDay with the given &lt;dayOfMonthOrdinal&gt;.  Answer nil if the &lt;dayOfMonthOrdinal&gt; is invalid."	^(dayOfMonthOrdinal &gt; days size or: [dayOfMonthOrdinal &lt; 1])		ifFalse: [days at: dayOfMonthOrdinal]</body><body package="Chronos-Calendars-Regular" selector="daysPerMonth">daysPerMonth	"For the type of year of the receiver, answer the number of days in the month whose properties are specified by the receiver."	^days size</body><body package="Chronos-Calendars-Regular" selector="lastDay">lastDay	"Answer the CalendarDay that specifies the properties of the last day of the month specified by the receiver."	^days last</body></methods><methods><class-id>Chronos.StaticMonthlyCalendar</class-id> <category>enumerating</category><body package="Chronos-Calendars-Regular" selector="daysDo:">daysDo: block1	"For each day of the receiver's month, evaluate &lt;block1&gt; with the receiver's CalendarDay representing that day."	^days do: block1</body></methods><methods><class-id>Chronos.StaticMonthlyCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	days := #().</body></methods><methods><class-id>Chronos.StaticMonthlyCalendar class</class-id> <category>instance creation</category><body package="Chronos-Calendars-Regular" selector="firstMonthInYear:specification:">firstMonthInYear: aYearlyCalendar specification: aCalendarMonthSpecification	^self new 		setYearlyCalendar: aYearlyCalendar 		specification: aCalendarMonthSpecification</body></methods><methods><class-id>Chronos.ComputedAnnualDate</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="comparisonClassIdentifier">comparisonClassIdentifier		"Answer a value that identifies the group of comparable values to which the receiver belongs.  The value might be a Smalltalk class, or might be a Symbol, or might be something else."	^self semanticKey</body><body package="Chronos-Annual Dates" selector="daysOffset">daysOffset	"Needed for 'Good Friday' (for example)."	daysOffset == nil ifTrue: [daysOffset := 0].	^daysOffset</body><body package="Chronos-Annual Dates" selector="daysOffset:">daysOffset: daysAsInteger 	^self isMutable 		ifTrue: [self setDaysOffset: daysAsInteger]		ifFalse: 			[(self copy)				setDaysOffset: daysAsInteger;				beImmutable]</body><body package="Chronos-Annual Dates" selector="identifiersDo:">identifiersDo: block2	block2 value: #semanticKey value: self semanticKey.	block2 value: #daysOffset value: self daysOffset</body><body package="Chronos-Annual Dates" selector="name">name	^self nameInLocale: self defaultLocale</body><body package="Chronos-Annual Dates" selector="nameInLocale:">nameInLocale: aChronosLocale	^(ChronosLocale referencedBy: aChronosLocale) properNameAtSemanticKey: self semanticKey</body><body package="Chronos-Annual Dates" selector="selfDescribingKey">selfDescribingKey	^self semanticKey</body><body package="Chronos-Annual Dates" selector="semanticKey">semanticKey	^self globalNameOfClass</body></methods><methods><class-id>Chronos.ComputedAnnualDate</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isComputed">isComputed	^true</body></methods><methods><class-id>Chronos.ComputedAnnualDate</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	stream		nextPut: self globalNameOfClass;		nextPut: self semanticKey.	self daysOffset = 0 ifFalse: [stream nextPut: self daysOffset]</body><body package="Chronos-Annual Dates" selector="value:value:">value: aYear value: aCalendarDay	self shouldNotImplement</body></methods><methods><class-id>Chronos.ComputedAnnualDate</class-id> <category>comparing</category><body package="Chronos-Annual Dates" selector="hash">hash	^self semanticKey hash</body></methods><methods><class-id>Chronos.ComputedAnnualDate</class-id> <category>initialize-release</category><body package="Chronos-Annual Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	daysOffset := 0</body><body package="Chronos-Annual Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	literalArray size &gt;= 3 		ifTrue: [self setDaysOffset: (literalArray at: 3) asNumber]</body><body package="Chronos-Annual Dates" selector="setDaysOffset:">setDaysOffset: days	self assertMutability.	daysOffset := days == nil ifTrue: [0] ifFalse: [days]</body></methods><methods><class-id>Chronos.ComputedAnnualDate</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processComputedAnnualDate: self</body></methods><methods><class-id>Chronos.ComputedAnnualDate class</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="canonical">canonical	"Answer the canonical instance of the receiver."	canonical == nil 		ifTrue: [canonical := self new].	^canonical</body></methods><methods><class-id>Chronos.ComputedAnnualDate class</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^literalArray size &lt; 3 		ifTrue: [self canonical]		ifFalse: 			[(self new)				initializeFromLiteralArray: literalArray;				beImmutable]</body></methods><methods><class-id>Chronos.ComputedAnnualDate class</class-id> <category>instance creation</category><body package="Chronos-Annual Dates" selector="daysOffset:">daysOffset: daysOffset 	"Good Friday: {(GregorianEaster daysOffset: -2) inYear: 2006}"	"Easter: {GregorianEaster canonical inYear: 2006}"	^(self new)		setDaysOffset: daysOffset;		beImmutable</body></methods><methods><class-id>Chronos.ComputedAnnualDate class</class-id> <category>class initialization</category><body package="Chronos-Annual Dates" selector="initialize">initialize	canonical := nil</body><body package="Chronos-Annual Dates" selector="initializeAll">initializeAll	self initialize.	self subclasses do: [:each | each initializeAll]</body><body package="Chronos-Annual Dates" selector="invalidateCalendarBindings">invalidateCalendarBindings	"ComputedAnnualDate invalidateCalendarBindings"	self initialize.	super invalidateCalendarBindings</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	annualTransitionPolicies := Array new</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray .	self 		setDefaultName: (literalArray at: 3);		setGeographicCoordinates: (literalArray at: 4) decodeAsLiteralArray;		setAnnualTransitionPolicies: 			((literalArray at: 5) collect: [:annualTransitionPolicyArrayLiteral | annualTransitionPolicyArrayLiteral decodeAsLiteralArray])</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="markNonSymmetricEffectiveYearTransitions">markNonSymmetricEffectiveYearTransitions	| policy0 policy1 |	self assertMutability.	policy1 := nil.	1 to: annualTransitionPolicies size		do: 			[:index | 			policy0 := annualTransitionPolicies at: index.			policy1 == nil 				ifFalse: [policy1 setSymmetryBasedOnTransitionFrom: policy0].			policy1 := policy0]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setAnnualTransitionPolicies:">setAnnualTransitionPolicies: anArrayOfAnnualTransitionPolicies	self assertMutability.	annualTransitionPolicies := anArrayOfAnnualTransitionPolicies</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setDefaultName:">setDefaultName: aString	self assertMutability.	defaultName := aString</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="setGeographicCoordinates:">setGeographicCoordinates: aGeographicCoordinatesSpect	self assertMutability.	geographicCoordinates := aGeographicCoordinatesSpect</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>enumerating</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="annualTransitionPoliciesDo:">annualTransitionPoliciesDo: block2	| index | 	index := 0.	annualTransitionPolicies do: [:each | block2 value: (index := index + 1) value: each]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="everyAnnualTransitionPolicyEverInEffectSinceYear:do:">everyAnnualTransitionPolicyEverInEffectSinceYear: year do: block1 	| prev |	prev := nil.	annualTransitionPolicies reverseDo: 			[:annualTransitionPolicy | 			(annualTransitionPolicy effectiveYearIsGreaterThanOrEqualTo: year) 				ifTrue: 					[(prev == nil or: [year = annualTransitionPolicy effectiveYear]) 						ifFalse: [block1 value: prev].					block1 value: annualTransitionPolicy.					prev := nil]				ifFalse: [prev := annualTransitionPolicy]].	prev == nil 		ifFalse: 			[block1 value: prev]</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>processing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processTimezonePolicyFactory: self.</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="annualTransitionPolicies">annualTransitionPolicies		^annualTransitionPolicies</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="annualTransitionPoliciesCount">annualTransitionPoliciesCount	^annualTransitionPolicies size</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="defaultName">defaultName	^defaultName</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="geographicCoordinates">geographicCoordinates	^geographicCoordinates</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="semanticKey">semanticKey		"Answer a value that identifies the conceptual type of the receiver."	^#TimeZoneRuleSet</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>printing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="encodeOn:">encodeOn: stream 	| position bangSwitch |	stream cr.	position := stream position.	stream		nextPutAll: registrationKey;		nextPut: $:.	annualTransitionPolicies do: 			[:each | 			stream cr; tab.			each encodeOn: stream].	stream nextPut: $!; cr.	bangSwitch := false.	geographicCoordinates == nil		ifFalse: 			[stream cr; nextPutAll: 'geographicCoordinates: '; print: geographicCoordinates.			bangSwitch := true].	defaultName == nil		ifFalse: [stream cr; nextPutAll: 'defaultName: '; nextPutAll: defaultName.			bangSwitch := true].	bangSwitch ifTrue: [stream nextPut: $!].	^position</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="printOn:">printOn: stream	stream		nextPut: ${;		nextPutAll: self class name.	registrationKey == nil 		ifFalse: 			[stream				cr; tab;				nextPutAll: 'key=';				print: registrationKey].	self specifiesDefaultName		ifTrue: 			[stream				nextPutAll: ' | ';				nextPutAll: ' defaultName='; nextPutAll: self defaultName].	self specifiesGeographicCoordinates 		ifTrue: [stream cr; tab; nextPutAll: 'geographicCoordinates='; print: self geographicCoordinates].	stream		nextPutAll: '} annualTransitionPolicies=';		print: annualTransitionPolicies;		nextPut: $}</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>converting</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="asPolicyFor:">asPolicyFor: anUnboundDynamicTimeZone 	| timeZonePolicy |	timeZonePolicy := nil.	annualTransitionPolicies do: 			[:annualTransitionPolicy | 			| tzPolicy |			tzPolicy := annualTransitionPolicy asPolicyFor: anUnboundDynamicTimeZone.			tzPolicy 				setRegistrationKey: self registrationKey;				setDefaultName: self defaultName;				setGeographicCoordinates: self geographicCoordinates.			timeZonePolicy == nil 				ifTrue: [timeZonePolicy := tzPolicy]				ifFalse: [timeZonePolicy := timeZonePolicy asListSortedInCanonicalOrderByTransitionTimeAdding: tzPolicy]].	ChronosTimezone invalidateBoundDynamicFlyweights.	^timeZonePolicy beImmutable</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: defaultName;		nextPut: geographicCoordinates literalArrayEncoding;		nextPut: annualTransitionPolicies literalArrayEncoding</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>queries</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="annualTransitionPolicyEffectiveInYear:ifNone:">annualTransitionPolicyEffectiveInYear: year ifNone: ifNone	annualTransitionPolicies do: [:annualTransitionPolicy | (annualTransitionPolicy effectiveYearIsLessThanOrEqualTo: year) ifTrue: [^annualTransitionPolicy]].	^ifNone value</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="defaultAnnualTransitionPolicy">defaultAnnualTransitionPolicy	annualTransitionPolicies do: [:annualTransitionPolicy | annualTransitionPolicy hasEverBeenInEffect ifTrue: [^annualTransitionPolicy]].	^annualTransitionPolicies last</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^annualTransitionPolicies contains: [:each | each specifiesCommonAbbreviation]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="specifiesDefaultName">specifiesDefaultName	^defaultName ~~ nil</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="specifiesGeographicCoordinates">specifiesGeographicCoordinates	^geographicCoordinates ~~ nil</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory class</class-id> <category>validation</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="assertValidityOfTimezoneKey:">assertValidityOfTimezoneKey: aTimeZoneKey	"Assert that &lt;aTimeZoneKey&gt; is the key of a time zone persistently stored in the Chronos time-zones repository (to which this execution environment is attached.) If it is, do nothing. If it is not, raise an Exception."	(self timezoneKeyIsGloballyDefined: aTimeZoneKey) ifFalse: [self signalInvalidTimezoneKey: aTimeZoneKey]</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="signalInvalidTimezoneKey:">signalInvalidTimezoneKey: aTimeZoneKey	self signalError: 'Unrecognized Timezone identifier: ', aTimeZoneKey printString</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="timezoneKeyIsGloballyDefined:">timezoneKeyIsGloballyDefined: aTimeZoneKey	^self registry includesKey: aTimeZoneKey</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory class</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="default">default	^self at: #Universal</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="keysByAbbreviation">keysByAbbreviation	"Answer a Dictionary that maps time zone abbreviations to Sets of the all the time zone keys of time zones that currently use that abbreviation (according to the information in the current Chronos Time Zone Repository.)"	"TimeZonePolicyFactory keysByAbbreviation"	| map set |	map := IdentityDictionary new.	self allRegisteredKeys do: 			[:tzKey | 			| annualPolicyFactory |			annualPolicyFactory := (TimeZonePolicyFactory at: tzKey asSymbol ifAbsent: []) defaultAnnualTransitionPolicy.			annualPolicyFactory annuallyRecurringTransitionsDo: 				[:index :annuallyPolicyElement | 					set := map at: annuallyPolicyElement commonAbbreviation ifAbsentPut: [Set new].					set add: tzKey]].	^map</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory class</class-id> <category>repository management</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="createTZRepositoryFrom:">createTZRepositoryFrom: aCollectionOfTimeZonePolicyFactories 	self basicInitialize.	aCollectionOfTimeZonePolicyFactories do: [:factory | factory forceRegistration].	ChronosTimezone invalidate</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="persistAliases">persistAliases	"TimeZonePolicyFactory persistAliases"	ChronosSystemFacade resourceRepositoryContext persistTimeZoneAliases</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory class</class-id> <category>foreign keys</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="parseWindowsToOlsonTZKeyMappingsFrom:">parseWindowsToOlsonTZKeyMappingsFrom: stream 	"{ChronosSystemFacade current resourceRepositoryContext invalidateWindowsToOlsonTZKeyMappings}"	WindowsToOlsonTZKeyMap := Dictionary new.	OlsonToWindowsTZNameMap  := nil.		[ChronosFunction skipSeparators: stream.	stream atEnd] whileFalse: 		[| line keys |		line := ChronosFunction nextLineFrom: stream.		keys := ChronosFunction componentsFromString: line separator: $|.		WindowsToOlsonTZKeyMap at: keys first put: keys last asSymbol].</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="timeZoneKeyFromWindowsTZName:ifAbsent:">timeZoneKeyFromWindowsTZName: windowsTZName ifAbsent: block0	^WindowsToOlsonTZKeyMap at: windowsTZName ifAbsent: block0</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="windowsTimeZoneNameFromTZKey:ifAbsent:">windowsTimeZoneNameFromTZKey: olsonKey ifAbsent: block0	"TimeZonePolicyFactory windowsTimeZoneNameFromTZKey: #'America/Chicago' ifAbsent: []"	^self olsonToWindowsTZNameMap at: olsonKey asSymbol ifAbsent: block0</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory class</class-id> <category>class initialization</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="initialize">initialize	self basicInitializeAll.	WindowsToOlsonTZKeyMap := Dictionary new.	OlsonToWindowsTZNameMap := nil.</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory class</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="computeOlsonToWindowsTZNameMap">computeOlsonToWindowsTZNameMap	"TimeZonePolicyFactory computeOlsonToWindowsTZNameMap"	| sortedListMap map ammendedMappings |	ammendedMappings := Dictionary new.	ammendedMappings		at: 'GMT' put: 'London Time';		at: 'Romance' put: 'Paris Time';		at: 'GTB' put: 'Greek Time'.	sortedListMap := Dictionary new.	WindowsToOlsonTZKeyMap keysAndValuesDo: 			[:windowsName :olsonKey | 			(sortedListMap at: olsonKey asSymbol				ifAbsentPut: [SortedCollection sortBlock: [:a :b | a size &lt; b size]]) 					add: windowsName].	map := Dictionary new.	sortedListMap keysAndValuesDo: 			[:olsonKey :windowsNamesSortedBySize | 			| index shortestGoodWindowsName |			shortestGoodWindowsName := 				ammendedMappings 					at: windowsNamesSortedBySize first					ifAbsent: 						[index := 1.						[shortestGoodWindowsName := windowsNamesSortedBySize at: index.						index := index + 1.						index &gt; windowsNamesSortedBySize size 							or: [shortestGoodWindowsName size &gt; 3]] 								whileFalse.						('*Time*' match: shortestGoodWindowsName) 							ifTrue: [shortestGoodWindowsName]							ifFalse: [shortestGoodWindowsName , ' Time']].			map at: olsonKey put: shortestGoodWindowsName].	^map</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="olsonToWindowsTZNameMap">olsonToWindowsTZNameMap	OlsonToWindowsTZNameMap == nil ifTrue: [OlsonToWindowsTZNameMap := self computeOlsonToWindowsTZNameMap].	^OlsonToWindowsTZNameMap</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="resourceBroker">resourceBroker	^ChronosSystemFacade resourceRepositoryContext timeZoneResourceBroker</body></methods><methods><class-id>Chronos.TimeZonePolicyFactory class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="decodeFrom:">decodeFrom: stream 	"{TimeZonePolicyFactory 		decodeFrom: 			'Pacific/Auckland:				1990 true Until-Annual-Date-Transition:NZDT:46800:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|3|15|1|0) Until-Annual-Date-Transition:NZST:43200:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|10|1|1|0) Until-End-Of-Year:NZDT:46800:43200				1989 true Until-Annual-Date-Transition:NZDT:46800:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|3|1|1|0) Until-Day-Of-Year-Transition:NZST:43200:43200:standard:7200:281 Until-End-Of-Year:NZDT:46800:43200				1976 true Until-Annual-Date-Transition:NZDT:46800:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|3|1|1|0) Until-Annual-Date-Transition:NZST:43200:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|10|-6|1|0) Until-End-Of-Year:NZDT:46800:43200				1975 true Until-Day-Of-Year-Transition:NZDT:46800:43200:standard:7200:54 Until-Annual-Date-Transition:NZST:43200:43200:standard:7200:(WeekOfMonthDayOfWeek|Gregorian|10|-6|1|0) Until-End-Of-Year:NZDT:46800:43200				1974 true Until-Day-Of-Year-Transition:NZST:43200:43200:standard:7200:307 Until-End-Of-Year:NZDT:46800:43200				1947 true Until-End-Of-Year:NZST:43200:43200				1946 false Until-Day-Of-Year-Transition:NZST:45000:43200:nominal:0:1 Until-End-Of-Year:NZST:43200:43200				1941 true Until-End-Of-Year:NZST:43200:41400				1934 true Until-Annual-Date-Transition:NZST:43200:41400:nominal:7200:(WeekOfMonthDayOfWeek|Gregorian|4|-6|1|0) Until-Annual-Date-Transition:NZMT:41400:41400:nominal:7200:(WeekOfMonthDayOfWeek|Gregorian|9|-6|1|0) Until-End-Of-Year:NZST:43200:41400				1929 true Until-Annual-Date-Transition:NZST:43200:41400:nominal:7200:(WeekOfMonthDayOfWeek|Gregorian|3|15|1|0) Until-Annual-Date-Transition:NZMT:41400:41400:nominal:7200:(WeekOfMonthDayOfWeek|Gregorian|10|8|1|0) Until-End-Of-Year:NZST:43200:41400				1928 true Until-Day-Of-Year-Transition:NZST:45000:41400:nominal:7200:64 Until-Annual-Date-Transition:NZMT:41400:41400:nominal:7200:(WeekOfMonthDayOfWeek|Gregorian|10|8|1|0) Until-End-Of-Year:NZST:43200:41400				1927 true Until-Day-Of-Year-Transition:NZT:41400:41400:nominal:7200:310 Until-End-Of-Year:NZST:45000:41400				1869 true Until-End-Of-Year:NZT:41400:41400				1868 true Until-Day-Of-Year-Transition:LMT:41944:41944:nominal:0:307 Until-End-Of-Year:NZT:41400:41400				nil true Until-End-Of-Year:LMT:41944:41944!geographicCoordinates: -365200+1744600defaultName: New Zealand Time!' readStream}"	| zoneKey elementStream timeZonePolicyElements attributes key value defaultName geographicCoordinates |	zoneKey := self registrationKeyFrom: stream.	ChronosFunction skipSeparators: stream.	timeZonePolicyElements := OrderedCollection new.	elementStream := (stream upTo: $!) readStream.	[elementStream atEnd]		whileFalse: 			[timeZonePolicyElements add: (TimeZoneAnnualTransitionPolicyFactory decodeFrom: elementStream key: zoneKey).			ChronosFunction skipSeparators: elementStream].	ChronosFunction skipSeparators: stream.	stream atEnd		ifTrue: [defaultName := geographicCoordinates := nil]		ifFalse: 			[elementStream := (stream upTo: $!) readStream.			attributes := IdentityDictionary new.			[elementStream atEnd]				whileFalse: 					[key := (elementStream upTo: $:) asSymbol.					ChronosFunction skipSeparators: elementStream.					value := ChronosFunction nextLineFrom: elementStream.					attributes at: key put: value.					ChronosFunction skipSeparators: elementStream].			defaultName := attributes at: #defaultName ifAbsent: [].			geographicCoordinates := attributes at: #geographicCoordinates ifAbsent: [].			geographicCoordinates == nil ifFalse: [geographicCoordinates := GeographicCoordinateSpec readFromString: geographicCoordinates]].	^self 		key: zoneKey 		defaultName: defaultName 		geographicCoordinates: geographicCoordinates		annualTransitionPolicyArray: timeZonePolicyElements asArray</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="key:defaultName:geographicCoordinates:annualTransitionPolicyArray:">key: registrationKey defaultName: aString geographicCoordinates: aGeographicCoordinatesSpec annualTransitionPolicyArray: anArrayOfAnnualTransitionPolicies	^self new		setKey: registrationKey;		setDefaultName: aString;		setGeographicCoordinates: aGeographicCoordinatesSpec;		setAnnualTransitionPolicies: anArrayOfAnnualTransitionPolicies;		beImmutable</body><body package="Chronos-TimeZones-PolicyFactories-Diachronic" selector="newKey:defaultName:geographicCoordinates:annualTransitionPolicyArray:">newKey: registrationKey defaultName: aString geographicCoordinates: aGeographicCoordinatesSpec annualTransitionPolicyArray: anArrayOfAnnualTransitionPolicies	^self new		setKey: registrationKey;		setDefaultName: aString;		setGeographicCoordinates: aGeographicCoordinatesSpec;		setAnnualTransitionPolicies: anArrayOfAnnualTransitionPolicies;		markNonSymmetricEffectiveYearTransitions;		beImmutable</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>accessing</category><body package="Chronos-TimeZones-Policies-Annual" selector="maxDaysFromStartOfYearUntilTransitionForYearOfType:">maxDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^transitionDayOfYear - 1</body><body package="Chronos-TimeZones-Policies-Annual" selector="minDaysFromStartOfYearUntilTransitionForYearOfType:">minDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^transitionDayOfYear - 1</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDayOfYear">transitionDayOfYear	^transitionDayOfYear</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-Policies-Annual" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	transitionDayOfYear := 1</body><body package="Chronos-TimeZones-Policies-Annual" selector="setTransitionDayOfYear:">setTransitionDayOfYear: aDayOfYearOrdinal	self assertMutability.	transitionDayOfYear := aDayOfYearOrdinal</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>converting</category><body package="Chronos-TimeZones-Policies-Annual" selector="asAnnuallyRecurringTZPolicyFactory">asAnnuallyRecurringTZPolicyFactory	"Answer the AnnuallyRecurringTZPolicyFactory that would serve as a factory to recreate an instance of the receiver's class with the same value as the receiver."	^UntilAnnualDayOfYearTimeZoneTransitionFactory 		offsetSeconds: self offsetSecondsFromUT		stdTimeOffsetSeconds: self stdTimeOffsetSecondsFromUT		commonAbbreviation: self commonAbbreviation		transitionDayOfYear: self transitionDayOfYear		transitionSecondsSinceStartOfDay: self transitionSecondsSinceStartOfDay		relativity: self relativity</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>queries</category><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year 	^self isSpecifiedAsLocalTime 		ifTrue: 			[DateAndTimeFactory 				year: year				day: transitionDayOfYear				seconds: transitionSecondsSinceStartOfDay				nanoseconds: 0				timeZone: self offsetFromUT asTimezone]		ifFalse: 			[self isSpecifiedAsStandardTime 				ifTrue: 					[DateAndTimeFactory 						year: year						day: transitionDayOfYear						seconds: transitionSecondsSinceStartOfDay						nanoseconds: 0						timeZone: self stdTimeOffsetFromUT asTimezone]				ifFalse: 					[DateAndTimeFactory 						utYear: year						day: transitionDayOfYear						seconds: transitionSecondsSinceStartOfDay						nanoseconds: 0						timeZone: self offsetFromUT asTimezone]]</body><body package="Chronos-TimeZones-Policies-Annual" selector="transitionDayOfWeekInYear:">transitionDayOfWeekInYear: year	^(DateFactory year: year day: transitionDayOfYear) dayOfWeek</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>comparing</category><body package="Chronos-TimeZones-Policies-Annual" selector="compareTo:">compareTo: anUntilAnnualDayOfYearTZPolicy	"Answer a strictly positive integer if the receiver's transition time is greater than that of the argument; answer 0 if equal; and answer a negative integer if less."	self == anUntilAnnualDayOfYearTZPolicy ifTrue: [^0].	^[anUntilAnnualDayOfYearTZPolicy compareToUntilAnnualDayOfYearTZPolicy: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == anUntilAnnualDayOfYearTZPolicy and: [ex message selector == #compareToUntilAnnualDayOfYearTZPolicy:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>private-comparing</category><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilAnnualDateTZPolicy:">compareToUntilAnnualDateTZPolicy: anUntilAnnualDateTZPolicy	| diff |	diff := anUntilAnnualDateTZPolicy annualDate minDayOfYearOrdinal - transitionDayOfYear.	diff = 0 ifFalse: [^diff].	^anUntilAnnualDateTZPolicy transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body><body package="Chronos-TimeZones-Policies-Annual" selector="compareToUntilAnnualDayOfYearTZPolicy:">compareToUntilAnnualDayOfYearTZPolicy: anUntilAnnualDayOfYearTZPolicy	| diff |	diff := anUntilAnnualDayOfYearTZPolicy transitionDayOfYear - transitionDayOfYear.	diff = 0 ifFalse: [^diff].	^anUntilAnnualDayOfYearTZPolicy transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>printing</category><body package="Chronos-TimeZones-Policies-Annual" selector="printTranstionRuleOn:">printTranstionRuleOn: stream	stream 		nextPutAll: 'dayOfYear=';		print: transitionDayOfYear.	self printTransitionTimeOfDayOn: stream</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition</class-id> <category>private</category><body package="Chronos-TimeZones-Policies-Annual" selector="transitionOccursOnOrAfterYear:dayOfYear:relativity:secondsSinceStartOfDayFunction:">transitionOccursOnOrAfterYear: year dayOfYear: dayOfYearOrdinal relativity: parameterRelativity secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction	| offsetSecondsFromUT deltaSeconds transitionSeconds dayDelta secondsSinceStartOfDay |	relativity == parameterRelativity 		ifTrue: 			[dayOfYearOrdinal &gt; transitionDayOfYear ifTrue: [^true].			dayOfYearOrdinal &lt; transitionDayOfYear ifTrue: [^false].			offsetSecondsFromUT := boundTZ offsetSecondsFromUT.			transitionSeconds := transitionSecondsSinceStartOfDay.			secondsSinceStartOfDay := secondsSinceStartOfDayFunction value: offsetSecondsFromUT.			secondsSinceStartOfDay &lt; 0				ifTrue: [secondsSinceStartOfDay := SecondsPerDay + secondsSinceStartOfDay]				ifFalse: 					[secondsSinceStartOfDay &gt; SecondsPerDay 						ifTrue: [secondsSinceStartOfDay := SecondsPerDay - secondsSinceStartOfDay]]]		ifFalse: 			[dayDelta := dayOfYearOrdinal - transitionDayOfYear.			dayDelta &lt; -1 ifTrue: [^false].			dayDelta &gt; 1 ifTrue: [^true].			offsetSecondsFromUT := boundTZ offsetSecondsFromUT.			relativity == #nominal				ifTrue: 					["parameterRelativity == #universal"					deltaSeconds := offsetSecondsFromUT negated]				ifFalse: 					[relativity == #standard						ifTrue: 							[parameterRelativity == #nominal								ifTrue: 									["parameterRelativity == #nominal"									deltaSeconds := boundTZ offsetDeltaSeconds]								ifFalse:									["parameterRelativity == #universal"									deltaSeconds := boundTZ stdTimeOffsetSecondsFromUT negated]]						ifFalse: 							["parameterRelativity == #nominal"							deltaSeconds := offsetSecondsFromUT]].			transitionSeconds := transitionSecondsSinceStartOfDay + deltaSeconds.			"Assumption: No REGISTERED Timezone (with a well-known key in the Olson TZ database) will have an offsetSecondsFromUT greater than SecondsPerDay."			transitionSeconds &lt; 0 				ifTrue: 					[dayDelta := dayDelta + 1.					transitionSeconds := transitionSeconds + SecondsPerDay]				ifFalse: 					[transitionSeconds &gt;= SecondsPerDay 						ifTrue: 							[dayDelta := dayDelta - 1.							transitionSeconds := transitionSeconds - SecondsPerDay]].			dayDelta &lt; 0 ifTrue: [^false].			dayDelta &gt; 0 ifTrue: [^true].			secondsSinceStartOfDay := secondsSinceStartOfDayFunction value: offsetSecondsFromUT].	^secondsSinceStartOfDay &gt;= transitionSeconds</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransition class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-Policies-Annual" selector="for:offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:transitionDayOfYear:transitionSecondsSinceStartOfDay:relativity:">for: anInterYearTimeZonePolicy offsetSeconds: offsetSeconds stdTimeOffsetSeconds: stdTimeOffsetSeconds commonAbbreviation: abbreviation transitionDayOfYear: dayOfYearOrdinal transitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol	^(self new)		setInterYearPolicy: anInterYearTimeZonePolicy offsetSeconds: offsetSeconds stdTimeOffsetSeconds: stdTimeOffsetSeconds commonAbbreviation: abbreviation;		setTransitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol;		setTransitionDayOfYear: dayOfYearOrdinal</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>control</category><body package="Chronos-System" selector="onStartupDoNotSetSystemTimeZoneUnlessBaseSystemTimeZoneIsAnOlsonTimeZone">onStartupDoNotSetSystemTimeZoneUnlessBaseSystemTimeZoneIsAnOlsonTimeZone	"{ChronosSystemFacade current onStartupDoNotSetSystemTimeZoneUnlessBaseSystemTimeZoneIsAnOlsonTimeZone} 			^-- Best when system timezone is unlikely to ever change once set correctly"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToAnalogOfNativeSystemTimeZone}		^-- Best when system clock keeps local time"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone}		^-- Best when users change time zones frequently"	systemTimeZoneBindingStrategy := #setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone</body><body package="Chronos-System" selector="onStartupSetSystemTimeZoneToAnalogOfNativeSystemTimeZone">onStartupSetSystemTimeZoneToAnalogOfNativeSystemTimeZone	"{ChronosSystemFacade current onStartupDoNotSetSystemTimeZoneUnlessBaseSystemTimeZoneIsAnOlsonTimeZone} 			^-- Best when system timezone is unlikely to ever change once set correctly"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToAnalogOfNativeSystemTimeZone}		^-- Best when system clock keeps local time"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone}		^-- Best when users change time zones frequently"	systemTimeZoneBindingStrategy := #setSystemTimeZoneToAnalogOfNativeSystemTimeZone</body><body package="Chronos-System" selector="onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone">onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone	"{ChronosSystemFacade current onStartupDoNotSetSystemTimeZoneUnlessBaseSystemTimeZoneIsAnOlsonTimeZone} 			^-- Best when system timezone is unlikely to ever change once set correctly"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToAnalogOfNativeSystemTimeZone}		^-- Best when system clock keeps local time"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone}		^-- Best when users change time zones frequently"	systemTimeZoneBindingStrategy := #setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem</body><body package="Chronos-System" selector="onStartupShowReports:">onStartupShowReports: flag	showReports := flag == true</body><body package="Chronos-System" selector="resourcePathPrefix:">resourcePathPrefix: prefixString 	^self resourceRepositoryContext resourcePathPrefix: prefixString</body><body package="Chronos-System" selector="showReportsWhile:">showReportsWhile: block0	| originalState |	originalState := showReports.	showReports := true.	block0 ensure: [showReports := originalState].</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>initialize-release</category><body package="Chronos-System" selector="initialize">initialize	systemTimeZone := nil.					"Set to nil so we will know it hasn't been set yet."	systemLanguageCode := #en.			"English by default"	systemCountryCode := #US.				"Unites States by default"	showReports := true.	self setResourceRepositoryContext.	self onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone.</body><body package="Chronos-System" selector="release">release	self unregisterForStartupNotification</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>queries</category><body package="Chronos-System" selector="rfc868SecondsSince1900">rfc868SecondsSince1900	"Answer the number of seconds since 1900-01-01T00:00:00 UTC [Gregorian], using the network time service defined by RFC-868.  Purpose: To enable retrieving the current time in situations where a) there is no local clock available, or b) there is reason to believe the local clock may not be correctly set, or may not keep time with sufficient accuracy. Note: Asking for and receiving back the current time over the internet would typically require on the order of 200 milliseconds--so obtaining the current time over the internet should only be done infrequently (once per minute at most.)  Applications with extreme current-time accuracy requirements should configure the host platform to use a local NTP time server that uses the NTP standard to keep the local clock accurate to within nanosecond tolerances (the NTP standard is NOT the same as the one defined in RFC-868.)"	"{DateAndTimeFactory 		utSecondsSinceEpoch: 			((Calendar gregorian secondsSinceEpochUpToYear: 1900) 			+ ChronosSystemFacade current rfc868SecondsSince1900)		timeZone: Timezone default}"	^self subclassResponsibility	"To implement:		1. Establish a datagram socket connection to a network time server on port 37 (e.g. 't2.timegps.net', or Google for 'network time server'.)		2. Send a datagram packet to the time server, with any byte sequence as the data payload.		3. Receive a 4-byte response containing the number of seconds since 1900-01-01T00:00:00 (as an unsigned big-endian value.)"</body><body package="Chronos-System" selector="systemCountryCode">systemCountryCode	^systemCountryCode</body><body package="Chronos-System" selector="systemLanguageCode">systemLanguageCode	^systemLanguageCode</body><body package="Chronos-System" selector="systemLocaleKey">systemLocaleKey	^ChronosLocale 		localeKeyFromLanguageCode: self systemLanguageCode		countryCode: self systemCountryCode</body><body package="Chronos-System" selector="systemTimeZone">systemTimeZone	^systemTimeZone == nil 		ifTrue: [ChronosTimezone universal]		ifFalse: [systemTimeZone]</body><body package="Chronos-System" selector="systemTimeZoneBindingStrategy">systemTimeZoneBindingStrategy	"Options: #resolveMostCongruentOlsonTimeZone | #onlyResolveOlsonTimeZoneToOlsonTimeZone | #setSystemTimeZoneToAnalogOfNativeSystemTimeZone"	^systemTimeZoneBindingStrategy</body><body package="Chronos-System" selector="timeServerHostName">timeServerHostName	^'time.nist.gov'</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>private-system timezone</category><body package="Chronos-System" selector="defaultSystemTimeZoneBindingStrategy">defaultSystemTimeZoneBindingStrategy	"Answer the strategy that Chronos should use by default whenever Chronos attempts resolve the Chronos system timezone based on the local timezone of the host system and/or Smalltalk execution environment. See class comment for a full explanation of the options.  This default can be overridden by sending control messages to the receiver."	^ChronosSystemClock current isRelativeToLocalTime		ifTrue: [#setSystemTimeZoneToAnalogOfNativeSystemTimeZone]		ifFalse: [#setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone]	"Options: 		#setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem		#setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone 		#setSystemTimeZoneToAnalogOfNativeSystemTimeZone"</body><body package="Chronos-System" selector="evaluateTZEnvironmentVariableValue:ifOlsonTZKey:ifTZRuleLiteral:otherwise:">evaluateTZEnvironmentVariableValue: tz ifOlsonTZKey: olsonTZKeyAction ifTZRuleLiteral: tzRuleLiteralAction otherwise: unknownContentAction 	"Parse the value of &lt;tz&gt;, whose value should be a String conforming to the POSIX specification for the value of the TZ environment variable. However, if &lt;tz&gt; is nil or is the empty String, then just answer nil.	If the parse determines that &lt;tz&gt; contains a value that identifies the key of an Olson timezone known to Chronos, then evaluate &lt;olsonTZKeyAction&gt; (a 1-arg block) with said timezone Olson key, then answer the result.	If the parse determines that &lt;tz&gt; contains a POSIX timezone rule literal, parse the abbreviations for standard time and DST from the POSIX rule literal, and then evaluate &lt;tzRuleLiteralAction&gt; (a 2-arg block) with the standard-time and DST abbreviations parsed from the rule literal as the first and second arguments (respectively.) If &lt;tzRuleLiteralAction&gt; is nil, then answer nil, otherwise answer the resul of the evaluation.	If the parse determines that &lt;tz&gt; contains neither an Olson timezone key known to Chronos, nor a valid POSIX timezone rule literal, then answer the result of evaluatiing &lt;unknownContentAction&gt; (a zero-arg block.)"	"The well-known keys used by Chronos to identify the attributes of a POSIX timezone rule literal, and the value that should be associated with each key:				Key									Semantics and Smalltalk type of associated value that should be computed by this method (as values in a Dictionary)		#StdAbbreviation					-&gt;	&lt;Symbol&gt; whose value is timezone's abbreviation during STANDARD TIME.		#StdOffsetSecondsFromUT		-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the Universal time-of-day to derive local time-of-day during STANDARD TIME.			-- The following entries should not be present if the timezone does not observe DST: 		#NonStdAbbreviation				-&gt;	&lt;Symbol&gt; whose value is the timezone's abbreviation during NON-STANDARD TIME.		#NonStdOffsetSecondsFromUT	-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the Universal time-of-day to derive local time-of-day during NON-STANDARD TIME.			-- The following entries may or may not be present:		#StdDate								-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `standard` time--or not present if there is no transition to standard time.		#StdTimeOfDay						-&gt; 	&lt;TimeOfDay&gt; at which the timezone transitions to `standard` time (always local 'wall-clock' time)--or not present if there is no transition to standard time.		#NonStdDate						-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `daylight-saving/summer` time.		#NonStdTimeOfDay				-&gt; &lt;TimeOfDay&gt; at which the timezone transitions to `daylight-saving/summer` time (always local 'wall-clock' time.)."	"{ChronosSystemFacade current		evaluateTZEnvironmentVariableValue: ':/usr/share/zoneinfo/America/Detroit' 		ifOlsonTZKey: [:tzKey | (Timezone at: tzKey) now printStringUsing: #verbose] 		ifTZRuleLiteral: 			[:tzAttributes | tzAttributes] 		otherwise: [#invalidValueOfTZEnvVar]}"	"{ChronosSystemFacade current		evaluateTZEnvironmentVariableValue: '&lt;CST&gt;5&lt;CDT&gt;' 		ifOlsonTZKey: [:tzKey | (Timezone at: tzKey) now printStringUsing: #verbose] 		ifTZRuleLiteral: [:tzAttributes | tzAttributes] 		otherwise: [#invalidValueOfTZEnvVar]}"	"{ChronosSystemFacade current		evaluateTZEnvironmentVariableValue: '&lt;CST&gt;5&lt;CDT&gt;4' 		ifOlsonTZKey: [:tzKey | (Timezone at: tzKey) now printStringUsing: #verbose] 		ifTZRuleLiteral: [:tzAttributes | tzAttributes] 		otherwise: [#invalidValueOfTZEnvVar]}"	"{ChronosSystemFacade current		evaluateTZEnvironmentVariableValue: 'MST7MDT' 		ifOlsonTZKey: [:tzKey | (Timezone at: tzKey) now printStringUsing: #verbose] 		ifTZRuleLiteral: [:tzAttributes | tzAttributes] 		otherwise: [#invalidValueOfTZEnvVar]}"	"The abbreviation BOT uniquely maps to to 'America/La_Paz':	{ChronosSystemFacade current		evaluateTZEnvironmentVariableValue: 'BOT' 		ifOlsonTZKey: [:tzKey | (Timezone at: tzKey) now printStringUsing: #verbose] 		ifTZRuleLiteral: [:tzAttributes | tzAttributes] 		otherwise: [#invalidValueOfTZEnvVar]}"	"{ChronosSystemFacade current		evaluateTZEnvironmentVariableValue: 'IST-5:30ISST-6:30,M3.5.0,M10.1.0/3:00' 		ifOlsonTZKey: [:tzKey | (Timezone at: tzKey) now printStringUsing: #verbose] 		ifTZRuleLiteral: [:tzAttributes | tzAttributes] 		otherwise: [#invalidValueOfTZEnvVar]}"	| tzStream resolveOlsonTZKey tzKey tzAttributes parseAbbreviation parsePolarity parseOffsetOrTime parseDate stdAbbreviation stdPolarity stdOffset dstAbbreviation dstPolarity dstOffset toNonStdDate toNonStdTimeOfDay toStdDate toStdTimeOfDay |	(tz == nil or: [tz size = 0]) ifTrue: [^nil].	tzStream := tz readStream.	ChronosFunction skipSeparators: tzStream.	resolveOlsonTZKey :=		[tzStream peek = $/ "If it starts with the POSIX file separator, then it's an absolute pathname of a zoneinfo binary file. It is ASSUMED that this is never done on Windows."			ifTrue: 				["We have an absolute pathname referring to a zoneinfo file in some non-standard location. So we have to ATTEMPT to derive the key from the filename (life can be so unfair...)  The operation will succeed PROVIDED the suffix of the pathname matches that of an Olson timezone key."				TimeZonePolicyFactory allRegisteredKeys do: [:key | 					('*' , key match: tz) 						ifTrue: [^olsonTZKeyAction value: key]]]			ifFalse: 				[| returnToPosition |				"Check whether it's an Olson TZ key known to Chronos."				returnToPosition := tzStream position.				tzKey := (ChronosFunction nextFrom: tzStream until: [:ch | ch isSeparator]) asSymbol.				(TimeZonePolicyFactory timezoneKeyIsGloballyDefined: tzKey) 					ifTrue: [^olsonTZKeyAction value: tzKey]					ifFalse: [tzStream position: returnToPosition]]].	(tzStream peekFor: $:) 		ifTrue: 			["It's either an Olson key known to Chronos, or else it's an unknown value."			resolveOlsonTZKey value. "If an Olson key is recognized, the olsonTZKeyAction.will be evaluated with the key as its argument, and the method will return to the sender."			^unknownContentAction value].	resolveOlsonTZKey value. "Check for an Olson key not prefixed by a colon (':'). If an Olson key is recognized, the olsonTZKeyAction.will be evaluated with the key as its argument, and the method will return to the sender."	"We have an ISO POSIX-1 literal rule specification."	parseAbbreviation :=		[tzStream atEnd			ifFalse: 				[(tzStream peekFor: $&lt;)					ifTrue: 						[| abbreviation | 						abbreviation := ChronosFunction nextFrom: tzStream until: [:ch | ch = $&gt;].						tzStream next.						abbreviation]					ifFalse: [ChronosFunction nextFrom: tzStream while: [:ch | ch isLetter]]]].	parsePolarity := 		["The POSIX polarity is inverted from standard practice (POSIX uses `seconds west of UT.`)"		tzStream atEnd			ifTrue: [-1]			ifFalse:				[(#($+ $-) includes: tzStream peek)					ifTrue: [tzStream next = $+ ifTrue: [-1] ifFalse: [1]]					ifFalse: [-1]]].	parseOffsetOrTime :=		[tzStream atEnd			ifFalse: 				[| hours minutes seconds |				hours := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].				hours := hours size = 0 ifTrue: [0] ifFalse: [hours asNumber].				minutes := 0.				seconds := 0.				(tzStream peekFor: $:)					ifTrue: 						[minutes := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].						minutes := minutes size = 0 ifTrue: [0] ifFalse: [minutes asNumber].						(tzStream peekFor: $:)							ifTrue: 								[seconds := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].								seconds := seconds size = 0 ifTrue: [0] ifFalse: [seconds asNumber]]].				(hours * SecondsPerHour) + (minutes * SecondsPerMinute) + seconds]].	parseDate :=		[tzStream atEnd			ifFalse: 				[(tzStream peekFor: $M)					ifTrue:						["It's a week-of-month/day-of-week specification."						| month weekOfMonth dayOfWeek |						month := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].						month := month size = 0 ifTrue: [^unknownContentAction value] ifFalse: [month asNumber].						(tzStream peekFor: $.) ifFalse: [^unknownContentAction value].						weekOfMonth := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].						weekOfMonth := weekOfMonth size = 0 ifTrue: [^unknownContentAction value] ifFalse: [weekOfMonth asNumber].						(tzStream peekFor: $.) ifFalse: [^unknownContentAction value].						dayOfWeek := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].						dayOfWeek := dayOfWeek size = 0 ifTrue: [^unknownContentAction value] ifFalse: [dayOfWeek asNumber + 1].						WeekOfMonthDayOfWeekFactory							month: month							week: (weekOfMonth &gt;= 5 ifTrue: [5 - weekOfMonth] ifFalse: [weekOfMonth])							dayOfWeek: dayOfWeek]					ifFalse: 						["It's an ordinal date (wrongly called a 'Julian Date' by IT tradition (especially in the mainframe world.)"						| yearlyCalendar dayOfYear calendarDay  |						(tzStream peekFor: $J)							ifTrue: 								["Non leap-year day-of-year ordinal (1..365)"								yearlyCalendar := Gregorian yearlyCalendarForYearTypeCode: 1.								dayOfYear := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].								dayOfYear := dayOfYear size = 0 ifTrue: [^unknownContentAction value] ifFalse: [dayOfYear asNumber]]							ifFalse: 								["Leap year day-of-year cardinal (0..365)"								yearlyCalendar := Gregorian yearlyCalendarForYearTypeCode: 2.								dayOfYear := ChronosFunction nextFrom: tzStream while: [:ch | ch isDigit].								dayOfYear := dayOfYear size = 0 ifTrue: [^unknownContentAction value] ifFalse: [dayOfYear asNumber + 1]].						dayOfYear = 0 ifTrue: [dayOfYear := 1]. "Just in case..."						calendarDay := yearlyCalendar dayAt: dayOfYear.						DayOfMonthFactory month: calendarDay month day: calendarDay dayOfMonth]]].	stdAbbreviation := parseAbbreviation value.	tzKey  := TimeZoneLocalizationPolicy unique 					defaultTimeZoneKeyWithCommonAbbreviation: stdAbbreviation 					dstPreferred: false "true/false doesn't matter in this case" 					ifAbsent: []. 	tzKey == nil 		ifFalse: 			["If the abbreviation has a unique mapping to an Olson time zone key, then we have a winner!"			^olsonTZKeyAction value: tzKey].	tzStream atEnd		ifTrue: 			[^tzRuleLiteralAction == nil 				ifTrue: [nil] 				ifFalse: ["Not legal" unknownContentAction value]].	stdPolarity := parsePolarity value.	stdOffset := parseOffsetOrTime value.	stdOffset == nil		ifTrue: 			[^tzRuleLiteralAction == nil 				ifTrue: [nil] 				ifFalse: ["Not legal" unknownContentAction value]].	stdOffset := stdOffset * stdPolarity.	tzAttributes := Dictionary new.	tzAttributes at: #StdAbbreviation put: stdAbbreviation.	tzAttributes at: #StdOffsetSecondsFromUT put: stdOffset.	dstAbbreviation := parseAbbreviation value.	dstAbbreviation == nil		ifTrue: 			[tzRuleLiteralAction == nil 				ifTrue: ["So we're not interested in any POSIX rule literal that may or may not be present." ^nil]]		ifFalse:			[tzKey  := TimeZoneLocalizationPolicy unique 							defaultTimeZoneKeyWithCommonAbbreviation: dstAbbreviation 							dstPreferred: true							ifAbsent: []. 			tzKey == nil 				ifFalse: 					["If the abbreviation has a unique mapping to an Olson time zone key, then we have a winner!"					^olsonTZKeyAction value: tzKey].			tzRuleLiteralAction == nil 				ifTrue: ["So we're not interested in any POSIX rule literal that may or may not be present." ^nil].			dstPolarity := parsePolarity value.			dstOffset := parseOffsetOrTime value.			dstOffset := dstOffset == nil							ifTrue: [stdOffset + SecondsPerHour]							ifFalse: [dstOffset * dstPolarity].			tzAttributes at: #NonStdAbbreviation put: dstAbbreviation.			tzAttributes at: #NonStdOffsetSecondsFromUT put: dstOffset.			ChronosFunction skipSeparators: tzStream.			((tzStream peekFor: $,) or: [(tzStream peekFor: $;)])				ifTrue:					[ChronosFunction skipSeparators: tzStream.					toNonStdDate := parseDate value.					(tzStream peekFor: $/)						ifTrue: [toNonStdTimeOfDay := parseOffsetOrTime value]						ifFalse: [toNonStdTimeOfDay := 7200 "2am is the default"].					(tzStream peekFor: $,) ifFalse: [^unknownContentAction value].					toStdDate := parseDate value.					(tzStream peekFor: $/)						ifTrue: [toStdTimeOfDay := parseOffsetOrTime value]						ifFalse: [toStdTimeOfDay := 7200 "2am is the default"].					tzAttributes at: #NonStdDate put: toNonStdDate.					tzAttributes at: #NonStdTimeOfDay put: (TimeOfDayFactory secondsSinceStartOfDay: toNonStdTimeOfDay).					tzAttributes at: #StdDate put: toStdDate.					tzAttributes at: #StdTimeOfDay put: (TimeOfDayFactory secondsSinceStartOfDay: toStdTimeOfDay)]].	^tzRuleLiteralAction value: tzAttributes</body><body package="Chronos-System" selector="firstInstallationSystemTimeZoneBindingStrategy">firstInstallationSystemTimeZoneBindingStrategy	"Answer the strategy that Chronos should use, when it is being installed for the very first time, to resolve the Chronos system timezone based on the local timezone of the host system and/or Smalltalk execution environment. See class comment for a full explanation of the options."	^ChronosSystemClock current isRelativeToLocalTime 		ifTrue: [#setSystemTimeZoneToAnalogOfNativeSystemTimeZone]		ifFalse: [#setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem]	"Options: 		#setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem		#setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone 		#setSystemTimeZoneToAnalogOfNativeSystemTimeZone"</body><body package="Chronos-System" selector="olsonTimeZoneKeyFromWindowsTimeZoneKey">olsonTimeZoneKeyFromWindowsTimeZoneKey	"Answer the Olson timezone key for the Olson timezone that is the most congruent to the current Windows timezone.  If not running on Windows, or if it is not possible to access the Windows registry in order to discover the current Windows timezone, then answer nil."	"{ChronosSystemFacade current olsonTimeZoneKeyFromWindowsTimeZoneKey}"	| windowsTZAttributes windowsTzName |	windowsTZAttributes:= self windowsTimeZoneAttributes.	windowsTZAttributes == nil ifTrue: [^nil].	windowsTzName := windowsTZAttributes at: #StandardName.	^TimeZonePolicyFactory timeZoneKeyFromWindowsTZName: windowsTzName		ifAbsent: 			[windowsTzName == nil 				ifFalse: 					[self reportUnknownWindowsTimeZoneName: windowsTzName.					nil]]</body><body package="Chronos-System" selector="resolveSystemTimeZoneFromTZEnvironmentVariableValue">resolveSystemTimeZoneFromTZEnvironmentVariableValue	"If the TZ environment variable explicitly specifies the key of an Olson timezone known to Chronos, answer the ChronosTimezone with that key.  Otherwise, determine which of the following cases apply, and perform the operation as specified for that case:	Case 1--#setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone is the current &lt;systemTimeZoneBindingStrategy&gt;:		Answer nil.	Case 2--#setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem is the current &lt;systemTimeZoneBindingStrategy&gt;:		If the default TimeZoneLocalizationPolicy defines a to-Olson-timezone-key mapping from the standard-time offset specified by the POSIX rule literal contained in the TZ Environment Variable, or if the default TimeZoneLocalizationPolicy defines a to-Olson-timezone-key mapping from any timezone abbreviation specified by the POSIX rule literal contained in the TZ Environment Variable, then answer the ChronosTimezone that implements the Olson timezone mapped by the default TimeZoneLocalizationPolicy from either the POSIX rule's standard-time offset or else any of its abbreviations.  If no such to-Olson-timezone-key mapping is defined by the default TimeZoneLocalizationPolicy, then answer nil.		Case 3--#setSystemTimeZoneToAnalogOfNativeSystemTimeZone is the current &lt;systemTimeZoneBindingStrategy&gt;:				If the POSIX timezone rule literal in the TZ Environment Variable contains sufficient information to fully define the timezone rules (i.e., it specifies the abbreviation and offset for standard time, and if DST is observed, the abbreviation and offset for DST, as well as the dates and times-of-day when the transtion to and from DST occurs,) then construct a ChronosTimezone that emulates the timezone rules as specified.  However, if the rule literal is not syntactically valid, then answer nil. And if the rule literal does not specify sufficient information to construct ChronosTimezone analog, then answer a ChronosTimezone as specified for Case 2 (above.)"	"{ChronosSystemFacade current resolveSystemTimeZoneFromTZEnvironmentVariableValue}"	| tzEnvVarValue resolveOlsonTZ |	tzEnvVarValue := self resolveValueOfTZEnvironmentVariable.	resolveOlsonTZ := 		[:tzAttributes |		| stdOffset stdAbbreviation dstAbbreviation tzKey |		stdOffset := tzAttributes at: #StdOffsetSecondsFromUT.		dstAbbreviation := tzAttributes at: #NonStdAbbreviation ifAbsent: [].		tzKey := 			TimeZoneLocalizationPolicy default 			defaultTimeZoneKeyForStandardTimeOffsetSecondsFromUT: stdOffset			dstPreferred: dstAbbreviation notNil			ifAbsent: [].		tzKey == nil			ifTrue:				[stdAbbreviation := tzAttributes at: #StdAbbreviation ifAbsent: [].				tzKey := TimeZoneLocalizationPolicy default 								defaultTimeZoneKeyWithCommonAbbreviation: 									(dstAbbreviation == nil 										ifTrue: [stdAbbreviation]										ifFalse: [dstAbbreviation])								dstPreferred: dstAbbreviation notNil								ifAbsent: [self reportUnkownTZEnvironmentVariableValue: tzEnvVarValue. nil]].		tzKey == nil			ifFalse: [VariableOffsetTimezone at: tzKey ifAbsent: []]].	^self 		evaluateTZEnvironmentVariableValue: tzEnvVarValue		ifOlsonTZKey: [:tzKey | VariableOffsetTimezone at: tzKey]		ifTZRuleLiteral: 			(systemTimeZoneBindingStrategy == #setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone				ifFalse: 					[[:tzAttributes | 					systemTimeZoneBindingStrategy == #setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem						ifTrue: [resolveOlsonTZ value: tzAttributes]						ifFalse: 							["systemTimeZoneBindingStrategy == #setSystemTimeZoneToAnalogOfNativeSystemTimeZone"							| stdOffset stdAbbreviation dstAbbreviation |							stdAbbreviation := tzAttributes at: #StdAbbreviation.							stdOffset := tzAttributes at: #StdOffsetSecondsFromUT.							dstAbbreviation := tzAttributes at: #NonStdAbbreviation ifAbsent: [].							dstAbbreviation == nil								ifTrue: 									[BasicTimezone 										offset: (DurationFactory seconds: stdOffset) 										name: tzEnvVarValue 										commonAbbreviation: stdAbbreviation]								ifFalse: 									[| toDstDate toDstTime toStdDate toStdTime dstOffset stdOffsetDuration dstOffsetDuration |									toDstDate := tzAttributes at: #NonStdDate ifAbsent: [^resolveOlsonTZ value: tzAttributes].									toDstTime := tzAttributes at: #NonStdTimeOfDay.									toStdDate := tzAttributes at: #StdDate.									toStdTime := tzAttributes at: #StdTimeOfDay.									dstOffset := tzAttributes at: #NonStdOffsetSecondsFromUT.									stdOffsetDuration := DurationFactory seconds: stdOffset.									dstOffsetDuration := DurationFactory seconds: dstOffset.									VariableOffsetTimezone										key: #system name: #POSIXTime										initialOffset: stdOffsetDuration withAbbreviation: stdAbbreviation											until: toDstDate at: toDstTime relativity: #nominal										thenOffset: dstOffsetDuration withAbbreviation: dstAbbreviation											until: toStdDate at: toStdTime relativity: #nominal]]]])		otherwise: [self reportUnkownTZEnvironmentVariableValue: tzEnvVarValue. nil]</body><body package="Chronos-System" selector="resolveSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone">resolveSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone	"If possible, determine whether the host system is using an Olson timezone to define its local time, and also whether the Olson key of that timezone can be discovered (to the desired degreee of certainty and precision.) If so, answer the Olson timezone key so determined. Othwerwise answer nil."	"{ChronosSystemFacade current resolveSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone}"	"Even on systems that use Olson timezones, there are usually only two ways to discover which Olson timezone key identifies the user's local time: 1) from the value of the TZ environment variable, or 2) from the contents of the file /etc/localtime.  It used to be that UNIX systems only used the value of the TZ environment variable for this purpose.  Unfortunately, they were forced to adopt a now widely-used alternative mechanism for specifying the local timezone: the /etc/localtime file. Although the TZ environment variable still functions, it only does so for individual users--the UNIX kernel does not and cannot make use of it.	The reason that UNIX systems stopped using the TZ environment variable to define local time on a system-wide basis is because of Windows--or more specifically, because it became so common to dual-boot both UNIX and Windows on the same machine. UNIX traditionally expects the system clock to be set to Universal Time.  Windows expects the system clock to be set to local time.  	UNIX, of course, is the one who had to adapt in order to resolve the conflicting system clock paradigms. So the UNIX kernel was changed so that it could handle a system clock set either to UT or to local time.  As a consequence of this change to the UNIX kernel, it was necessary for the kernel to have direct access to the `compiled` binary version of the Olson timezone description of the local timezone.  And unfortunately, the binary Olson timezone files (which Chronos does not use) do not contain any information which would make it easy to determine the Olson key of the timezone whose ruleset they contain.  So now it is quite common for the contents of the `totally-lacking-any-identification-internally` /etc/localtime binary timezone ruleset file to be the only specification available regarding a UNIX system's definition of local time.	There is, however, one common practice that may make it possible to discover the Olson timezone key of the Olson timezone whose ruleset (but not identity) is specified by the contents of the /etc/localtime file: More often than not, /etc/localtime a symbolic link to one of the binary Olson timezone files in the /usr/share/zoneinfo directory (or in some directory whose pathname should be similar.)  If that's the case, then it should be possible for an application with the necessary permissions (and the ability to make UNIX system calls) to discover the target pathname of the /etc/localtime symbolic link, and then to find the suffix of the pathname that corresponds to the key of the Olson timezone whose specification resides in that file.  	This implemention of the method makes no attempt to resolve an Olson timezone key from the pathname of the /usr/share/zoneinfo/&lt;zonefile&gt; pointed to by the /etc/localtime symbolic link; but subimplementers are encouraged to do so, should the need arise.  	Another possible strategy (also not implemented here) that might be attempted would be to examine the information that is available in the /etc/localtime binary file, and use that to find the most likely corresponding Olson timezone key (an Olson binary timezone file contains every offset and abbreviation ever used for the timezone, and every point-in-time--as a number of seconds since 1970-01-01T00:00:00 UT--at which any of those values changed.) Yet another strategy would be to reverse-compile the binary timezone file into a (probably very long) sequence of Chronos TimeZonePolicySpecs--from which a TimeZonePolicy could be constructed (see TimeZonePolicy, TimeZoneOffsetPolicy, TimeZonePolicySpec, TimeZoneOffsetPolicySpec and their subclasses.)"	^self resolveSystemTimeZoneFromTZEnvironmentVariableValue</body><body package="Chronos-System" selector="resolveValueOfTZEnvironmentVariable">resolveValueOfTZEnvironmentVariable	"Answer the value of the TZ environment variable. If the host system does not support environment variables answer nil."	^EnvironmentFacade current valueOfEnvironmentVariableAt: 'TZ'</body><body package="Chronos-System" selector="setBaseSystemTimeZoneFromChronosSystemTimeZone">setBaseSystemTimeZoneFromChronosSystemTimeZone	"Set the base system's timezone (that defines its local time) to one which is as congruent as possible to the receiver's &lt;systemTimeZone&gt;.  This operation MUST NOT affect how time is reported by Chronos. If the Smalltalk execution environment has its own support for timezones (apart from either Chronos or the operating system,) then this operation should affect how the current Smalltalk execution environment reports time using its native date-time facilities.  Ideally, this operation should also affect the reporting of time by the host operating system (at least for the current user, but probably not for all users.) 	NOTE: Some systems keep time in UT, and report local time by converting from UT according to the specifications of the current timezone.  Other systems keep time in local terms, and convert to UT when needful according to the specifications of the current timezone.  In the former case, this operation optimally should change the local time-of-day natively reported by the Smalltalk execution environment.  In the latter case, it should change the UT time-of-day natively reported by the Smalltalk execution environment."	^self subclassResponsibility</body><body package="Chronos-System" selector="setSystemTimeZone:">setSystemTimeZone: aChronosTimezone 	"Set the &lt;systemTimeZone&gt; and notify ChronosTimezone of the change."	^systemTimeZone = aChronosTimezone		ifTrue: [false]		ifFalse: 			[systemTimeZone := aChronosTimezone.			ChronosTimezone invalidateSystemTimezone.			self showReportsWhile: [self reportSystemTimeZoneIdentity].			true].</body><body package="Chronos-System" selector="setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone">setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone	"If it's possible to determine that the host system is using an Olson timezone to define its local time, and if it's also possible to determine the Olson key of that timezone (to the desired degreee of certainty and precision,) then set the receiver's &lt;systemTimeZone&gt; to a Chronos VariableOffsetTimezone with the same key and answer true. Othwerwise do nothing and answer false"	"{ChronosSystemFacade current setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone}"	| tz |	tz := self resolveSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone.	^tz == nil		ifTrue: [false]		ifFalse: 			[self setSystemTimeZone: tz. 			true]</body><body package="Chronos-System" selector="setSystemTimeZoneToAnalogOfNativeSystemTimeZone">setSystemTimeZoneToAnalogOfNativeSystemTimeZone	"If it's possible to determine that the host system is using an Olson timezone to define its local time, and if it's also possible to determine the Olson key of that timezone (to the desired degreee of certainty and precision,) then set the receiver's &lt;systemTimeZone&gt; to a Chronos VariableOffsetTimezone with the same key and answer true.	Otherwise, construct a ChronosTimezone that emulates the behavior of the host system's timezone as closely as possible (i.e., serves a reasonably close analog of the host system's timezone,) set the ChronosTimezone so constructed as the &lt;systemTimeZone&gt; and answer true. However, if it's not possible to get sufficient information about the host system's timezone to construct a ChronosTimezone that will serve as a reasonable analog, then do nothing and answer false."	"{ChronosSystemFacade current setSystemTimeZoneToAnalogOfNativeSystemTimeZone}"	| tz |	tz := self resolveSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone.	^tz == nil		ifTrue: [self setSystemTimeZoneToAnalogOfWindowsTimeZone]		ifFalse: 			[self setSystemTimeZone: tz. 			true]</body><body package="Chronos-System" selector="setSystemTimeZoneToAnalogOfWindowsTimeZone">setSystemTimeZoneToAnalogOfWindowsTimeZone	"Construct a ChronosTimezone that emulates the behavior of the current user's Windows timezone as closely as possible (i.e., so that it serves a reasonably close analog of the Windows time zone,) and set the ChronosTimezone so constructed as the &lt;systemTimeZone&gt;, and answer true.  But if not running on Windows, or if it's not possible for some reason to access the Windows Registry and get the parameters of the current user's Windows timezone, do nothing and answer false."	"{ChronosSystemFacade current setSystemTimeZoneToAnalogOfWindowsTimeZone}"	"The well-known keys used by Chronos to identify the attributes of a Windows timezone ruleset specification, and the value that should be associated with each key:				Key									Semantics and Smalltalk type of associated value that should be returned by this method (as values in a Dictionary)		#BaseOffsetSecondsFromUT	-&gt;	&lt;Integer&gt; base number of seconds that should be ADDED to the Universal time-of-day to derive local time-of-day during STANDARD TIME.		#StandardName					-&gt;	&lt;String&gt; whose value is Window's canonical name for the timezone.		#StandardBias					-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the &lt;BaseOffsetSecondsFromUT&gt; during standard time (usually zero).			-- The following entries should not be present if the timezone does not observe DST: 		#StandardDate					-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `standard` time--or not present if there is no transition to standard time.		#StandardTimeOfDay			-&gt; &lt;TimeOfDay&gt; at which the timezone transitions to `standard` time (always local 'wall-clock' time)--or not present if there is no transition to standard time.		#DaylightName					-&gt;	&lt;String&gt; whose value is Window's name for the timezone when DST is in effect.		#DaylightBias					-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the &lt;BaseOffsetSecondsFromUT&gt; during 'daylight-saving/summer' time.		#DaylightDate					-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `daylight-saving/summer` time.		#DaylightTimeOfDay				-&gt; &lt;TimeOfDay&gt; at which the timezone transitions to `daylight-saving/summer` time (always local 'wall-clock' time.).	The standard time offset from UT will be computed as &lt;BaseOffsetSecondsFromUT&gt; + &lt;StandardBias&gt;; the DST offset from UT will be computed as &lt;BaseOffsetSecondsFromUT&gt; + &lt;DaylightBias&gt;."	| windowsTzAttributes baseOffsetSecondsFromUT dstBias windowsStdTimeName olsonKey name stdAbbrev dstAbbrev |	windowsTzAttributes := self windowsTimeZoneAttributes.	windowsTzAttributes == nil ifTrue: [^false].	windowsStdTimeName := windowsTzAttributes at: #StandardName.	olsonKey := TimeZonePolicyFactory timeZoneKeyFromWindowsTZName: windowsStdTimeName ifAbsent: [].	name := nil.	olsonKey == nil 		ifFalse: 			[name := TimeZonePolicyFactory windowsTimeZoneNameFromTZKey: olsonKey ifAbsent: [].			name == nil 				ifFalse: 					[| tzpf |					tzpf := TimeZonePolicyFactory at: olsonKey ifAbsent: [].					tzpf == nil						ifTrue: 							[stdAbbrev := windowsStdTimeName.							dstAbbrev := windowsTzAttributes at: #DaylightName ifAbsent: [#DST]]						ifFalse:							[tzpf defaultAnnualTransitionPolicy annuallyRecurringTransitionsDo: 								[:i :transition | 									transition isStandardTime 										ifTrue: [stdAbbrev := transition commonAbbreviation]										ifFalse: [dstAbbrev := transition commonAbbreviation]]]]].	name == nil		ifTrue:			[name := windowsStdTimeName.			stdAbbrev := windowsStdTimeName.			dstAbbrev := windowsTzAttributes at: #DaylightName ifAbsent: [#DST]].	baseOffsetSecondsFromUT := windowsTzAttributes at: #BaseOffsetSecondsFromUT.	dstBias := windowsTzAttributes at: #DaylightBias ifAbsent: [].	dstBias == nil 		ifTrue: 			[self setSystemTimeZone: 				(ChronosTimezone 				offset: (DurationFactory seconds: baseOffsetSecondsFromUT + (windowsTzAttributes at: #StandardBias))				name: name				commonAbbreviation: stdAbbrev)]		ifFalse: 			[self setSystemTimeZone: 				(ChronosTimezone 					key: #system name: name					initialOffset: (DurationFactory seconds: baseOffsetSecondsFromUT + (windowsTzAttributes at: #StandardBias)) withAbbreviation: stdAbbrev						until: (windowsTzAttributes at: #DaylightDate) at: (windowsTzAttributes at: #DaylightTimeOfDay) relativity: #nominal					thenOffset: (DurationFactory seconds: baseOffsetSecondsFromUT + (windowsTzAttributes at: #DaylightBias)) withAbbreviation: dstAbbrev						until: (windowsTzAttributes at: #StandardDate) at: (windowsTzAttributes at: #StandardTimeOfDay) relativity: #nominal)].	^true</body><body package="Chronos-System" selector="setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem">setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem	"Determine the key of the Olson timezone that is the most congruent to the host system's timezone, set the &lt;systemTimeZone&gt; to the ChronosTimezone with that key, and answer true. However, if it is not possible to obtain enough information about the host system's timezone to determine the Olson timezone key of the Olson timezone that would be reasonably congruent to the host system's timezone, then do nothing and answer false."	| tz timeZoneKey |	tz := self resolveSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone.	^tz == nil 		ifTrue: 			[timeZoneKey := self olsonTimeZoneKeyFromWindowsTimeZoneKey.			timeZoneKey == nil 				ifTrue: [false]				ifFalse: 					[self setSystemTimeZone: (VariableOffsetTimezone at: timeZoneKey ifAbsent: [^false]).					true]]		ifFalse: 			[self setSystemTimeZone: tz.			true]</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>instance creation</category><body package="Chronos-System" selector="findOrCreateChronosLocaleAt:">findOrCreateChronosLocaleAt: isoStandardLocaleKey	"Answer a ChronosLocale initialized to provide locale behavior that is correct for the language and country indicated by &lt;isoStandardLocaleKey&gt;.  	If the information necessary to provide/construct the ChronosLocale as requested is not available, answer a ChronosLocale whose behavior will match that of the one requested as closely as possible.  In the worst case, just answer a ChronosLocale configured with whatever locale information is readily available and most appropriate.	The &lt;isoStandardLocaleKey&gt; is a Symbol, whose content is structured as an ISO-639 language code, contingently followed by an underscore character and ISO-3166 country code. The country code is mandatory in cases where the language code is not sufficient to fully specify the appropriate behavior of a locale (e.g., US vs. British notational conventions.) Using the country code is recommended.	Some common locale keys:		United States: 	#en_US		Note: Not everyone lives in the United States, and notational conventions in the US sometimes differ considerably from international norms.		Great Britain:	#en_GB 		Note: 'UK' is not the ISO country code for Great Britain/The United Kingdom		Spain:				#es_ES		Note: Notational conventions may differ in Spanish-speaking countries outside of Spain		France: 			#fr_FR		Note: Notational conventions may differ in French-speaking countries outside of France		Germany:		#de_DE		Italy:				#it_IT		Japan:			#ja_JP	There are three suggested approaches to subimplement this method, for those interested in actually dealing with locales in a serious manner:		1) Create a ConfigurableChronosLocale, initialize it from whatever data source is preferred (perhaps user-managed flat files, or non-Chronos Locale objects,) and answer the newly created/initialized ConfigurableChronosLocale;		2) Define a class (perhaps named 'ChronosLocaleAdapterForWindows' or 'ChronosLocaleAdapterForSTX') whose public API is that of a ChronosLocale, but which acts as an adapter or facade (see the canonical 'Gang of Four' Design Patterns book.) The 'ChronosLocaleAdapter' (or whatever name is chosen) would delegate service requests made using the API of a ChronosLocale to native locale objects or library calls, using whatever API they require (such objects and/or services might be provided by the native Smalltalk execution environment, by the host operating system, by proprietary classes or utility libraries, or by some combination thereof).  The implementation of this method would then be to create an instance of such a locale adapter configured to provide locale behavior appropriate for the requested locale;		3) Combine approach 1 with appoach 2, using a locale adapter to initialize an instance of ConfigurableChronosLocale (which may or may not be preferrable to approach 2 by itself, depending on a variety of factors.)"	^ChronosLocale unitedStates 	"This is the abstract superclass--so the most appropriate implementation in this context is simply to answer some readily-available default locale.	Subimplementors are strongly encouraged to provide richer behavior--hopefully aided by services available in the native Smalltalk execution environment and/or host operating system."</body><body package="Chronos-System" selector="newDelayFromDuration:">newDelayFromDuration: aDuration	^Delay forMilliseconds: aDuration asMilliseconds</body><body package="Chronos-System" selector="newSystemClock">newSystemClock	^ChronosSystemClock new</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>private</category><body package="Chronos-System" selector="baseSystemLocaleKey">baseSystemLocaleKey	"This implementation assumes that it is easier to compute the baseSystemLocaleKey from the languageCode and countryCode.  If it would be easier to simply retrieve the base system's locale key directly, instead of computing it, then this method should be subimplemented."	^self 		baseSytemLocaleKeyFromLanguageCode: self systemLanguageCode		countryCode: self systemCountryCode</body><body package="Chronos-System" selector="baseSytemLocaleKeyFromChronosLocaleKey:">baseSytemLocaleKeyFromChronosLocaleKey: chronosLocaleKey 	^ChronosLocale 		fromLocaleKey: chronosLocaleKey		setLanuageCodeAndCountryCodeInto: 			[:languageCode :countryCode | 			self 				baseSytemLocaleKeyFromLanguageCode: languageCode				countryCode: countryCode]</body><body package="Chronos-System" selector="baseSytemLocaleKeyFromLanguageCode:countryCode:">baseSytemLocaleKeyFromLanguageCode: languageCode countryCode: countryCode	^ChronosLocale "Since Chronos uses the international standard encoding, we assume that the base system does as well. If not, subimplement."		localeKeyFromLanguageCode: languageCode		countryCode: countryCode</body><body package="Chronos-System" selector="basicInstall">basicInstall	"Invalidate any information stored in the receiver that needs to be synchronized with external sources, such as configuration files, environment variables, registry settings, etc. Answer true if totally successful, false otherwise."	ChronosSystemClock invalidateCurrent.	^self setChronosDefaultLanguageAndCountryCodesFromBaseSystem 		ifTrue: [self resourceRepositoryContext install]		ifFalse: [false]</body><body package="Chronos-System" selector="fromBaseSystemLocaleKey:setLanguageCodeAndCountryCodeInto:">fromBaseSystemLocaleKey: baseSystemLocaleKey setLanguageCodeAndCountryCodeInto: block2	baseSystemLocaleKey == nil ifTrue: [^block2 value: #en value: #US].	^ChronosLocale		fromLocaleKey: baseSystemLocaleKey "Since Chronos uses the ISO standard encoding, we assume that the base system does the same. If not, subimplement."		setLanuageCodeAndCountryCodeInto: block2</body><body package="Chronos-System" selector="setResourceRepositoryContext">setResourceRepositoryContext	"ChronosSystemFacade current setResourceRepositoryContext"	resourceRepositoryContext := ChronosResourceRepositoryContext new.</body><body package="Chronos-System" selector="setSystemLanguageCode:countryCode:">setSystemLanguageCode: languageCode countryCode: countryCode	"Whether or not this method has any effect outside of Chronos is not specified.  Subimplementers may choose either approach."	systemLanguageCode := languageCode.	systemCountryCode := countryCode.	ChronosLocale invalidateSystemLocale.	self reportSystemLanguageAndCountryCode.</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>private-reporting</category><body package="Chronos-System" selector="byDefaultShouldShowReportsOnStartup">byDefaultShouldShowReportsOnStartup	"Answer the default value of the flag whose value determines whether or not, when the receiver is reinstalled during the restart of a snapshotted image, it should report its (possibly changed) status (e.g..systemTimeZoneKey, systemLanguageCode, etc.) to the 'System Transcript' (or some analog thereof.)"	^false</body><body package="Chronos-System" selector="reportCommencementOfInitialChronosInstallation">reportCommencementOfInitialChronosInstallation	showReports		ifTrue: [self reportToConsole: 'Installing the Chronos Date/Time Library...' newLineCount: 2].</body><body package="Chronos-System" selector="reportException:message:">reportException: exception message: message	self		reportToConsole: message;		reportToConsole: exception description newLineCount: 1 tabCount: 1</body><body package="Chronos-System" selector="reportFailureToSetDefaultLanguageAndCountryCodesFromBaseSystem:">reportFailureToSetDefaultLanguageAndCountryCodesFromBaseSystem: exception	self		reportToConsole: 'The attempt to set the default language and country codes from the host system failed with the following exception: ';		reportToConsole: exception description newLineCount: 1 tabCount: 1</body><body package="Chronos-System" selector="reportInaccessibleResource:">reportInaccessibleResource: resourcePath	self		reportToConsole: resourcePath printString, ' persistent/remote resource is not accessible.'</body><body package="Chronos-System" selector="reportInitialChronosInstallationAsSuccessful">reportInitialChronosInstallationAsSuccessful	"ChronosSystemFacade current reportInitialChronosInstallationAsSuccessful"	[self		reportToConsole: 'Installation completed ', AnsiStandardCalendarClock now printString;		newLineToConsole] 			on: Error			do: [:ex | self reportException: ex message: 'The following error occured during installation: ']</body><body package="Chronos-System" selector="reportInstallationSkipped">reportInstallationSkipped	self		reportToConsole: 'Chronos installation was not performed because the installation flag was set to NO/false.  The installation flag is the value either of the global variable ChronosInstallationFlag or else of the environment variable CHRONOS_INSTALLATION.  To perform the installation operations required in order for Chronos to be functional, first set the installation flag to YES/true, and then evaluate "ChronosSystemFacade current installInitially." (Note: It may also be necessary to restart Smalltalk before it will be aware that the value of an environment variable has been changed.)'</body><body package="Chronos-System" selector="reportResourcePathnameMappings">reportResourcePathnameMappings	showReports 		ifTrue: 			[self 				reportToConsole: 'Logical to physical pathname bindings for persistent/remote datasources:'.			self resourceRepositoryContext resourcePathsDo: 					[:key :value | 					self 						reportToConsole: key , '-&gt;' , value printString						newLineCount: 1						tabCount: 1]]</body><body package="Chronos-System" selector="reportSystemLanguageAndCountryCode">reportSystemLanguageAndCountryCode	showReports 		ifTrue: 			[self				reportToConsole: 'System Language Code set to ', systemLanguageCode printString;				reportToConsole: 'System Country Code set to ', systemCountryCode printString]</body><body package="Chronos-System" selector="reportSystemTimeZoneIdentity">reportSystemTimeZoneIdentity	showReports 		ifTrue: 			[self				reportToConsole: 'System Timezone set to ', self systemTimeZone identityString]</body><body package="Chronos-System" selector="reportTimeZoneInvalidationFailure:">reportTimeZoneInvalidationFailure: exception	self		reportToConsole: 'The attempt to invalidate all currently-resident time zones failed with the following exception: ';		reportToConsole: exception description newLineCount: 1 tabCount: 1</body><body package="Chronos-System" selector="reportUnknownWindowsTimeZoneName:">reportUnknownWindowsTimeZoneName: windowsTzName 	showReports 		ifTrue: 			[self reportToConsole: 'Unkown Windows System Timezone Name: ' 						, windowsTzName printString]</body><body package="Chronos-System" selector="reportUnkownTZEnvironmentVariableValue:">reportUnkownTZEnvironmentVariableValue: tzEnvVarValue 	self reportToConsole: 'Unknown value of TZ environment variable: ' 				, tzEnvVarValue printString</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>services/utilities</category><body package="Chronos-System" selector="setChronosDefaultLanguageAndCountryCodesFromBaseSystem">setChronosDefaultLanguageAndCountryCodesFromBaseSystem	"This method MUST be invoked whenever the Smalltalk execution environment starts running (typically, whenever the 'image' is restarted after a snapshot, although not all ST implementations use 'images.') Answer true if successful, false otherwise."	^[self 		fromBaseSystemLocaleKey: self baseSystemLocaleKey		setLanguageCodeAndCountryCodeInto: 			[:language :country | self setSystemLanguageCode: language countryCode: country].	true] 			on: Error			do: 				[:ex | 				self reportFailureToSetDefaultLanguageAndCountryCodesFromBaseSystem: ex.				ex return: false]</body><body package="Chronos-System" selector="setChronosSystemTimeZoneFromBaseSystem">setChronosSystemTimeZoneFromBaseSystem	"Set the receiver's &lt;systemTimeZone&gt; to that of the host system, according to the current system time zone binding strategy (see class comment for details.) Answer true if the &lt;systemTimezone&gt; was successfully set (even if to the same value as before,) false otherwise."	"{ChronosSystemFacade current setChronosSystemTimeZoneFromBaseSystem}"	"{ChronosSystemFacade current onStartupDoNotSetSystemTimeZoneUnlessBaseSystemTimeZoneIsAnOlsonTimeZone} 			^-- Best when system timezone is unlikely to ever change once set correctly"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToAnalogOfNativeSystemTimeZone}		^-- Best when system clock keeps local time"	"{ChronosSystemFacade current onStartupSetSystemTimeZoneToMostCongruentOlsonTimeZone}		^-- Best when users change time zones frequently"	"This method MUST be invoked whenever the Smalltalk execution environment starts running (typically, whenever the 'image' is restarted after a snapshot, although not all ST implementations use 'images.')"	| success |	success := self perform: systemTimeZoneBindingStrategy.	success 		ifFalse: 			[self showReportsWhile: [self reportSystemTimeZoneIdentity].			systemTimeZoneBindingStrategy == #setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone				ifFalse: [self userNotify: self systemTimeZoneNotResolvableMessage]].	^success</body><body package="Chronos-System" selector="systemTimeZone:">systemTimeZone: aChronosTimezone	"Set the system's Timezone to one which is as congruent as possible to the one identified by &lt;aTimeZoneKey&gt; in the Olson TZ database.  At a minimum, this operation MUST affect how time is reported by Chronos. If the Smalltalk execution environment has its own support for Time Zones (apart from Chronos,) then this operation MUST affect how the current Smalltalk execution environment reports local time using its native date-time facilities.  IDEALLY, this operation should also affect the reporting of local time by the host operating system--but that is not strictly required (extra credit will be duly recorded...).	See the method comment of 'ChronosSystemFacade&gt;&gt;resolveBaseSystemTimeZoneKey:' for more information, advice and discussion of the issues involved."	^systemTimeZone = aChronosTimezone		ifTrue: [false]		ifFalse:			[| changed |			changed := self setSystemTimeZone:  aChronosTimezone.			changed ifTrue: [self setBaseSystemTimeZoneFromChronosSystemTimeZone].			changed]</body><body package="Chronos-System" selector="userNotify:">userNotify: aMessage 	"Notify the user of an event by displaying or logging the text of &lt;aMessage&gt;"	self reportToConsole: aMessage</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>value conversion</category><body package="Chronos-System" selector="chronosDateAndTimeFromNativeCalendricalCoordinate:calendarClock:">chronosDateAndTimeFromNativeCalendricalCoordinate: aNativeCalendricalCoordinate calendarClock: calendarClock 	"Answer a Chronos DateAndTime that semantically corresponds as closely as possible to &lt;aNativeTimestampOrDate&gt;."	^aNativeCalendricalCoordinate</body><body package="Chronos-System" selector="chronosDateFromNativeCalendricalCoordinate:calendarClock:">chronosDateFromNativeCalendricalCoordinate: aNativeCalendricalCoordinate calendarClock: calendarClock 	"Answer a Chronos date value that semantically corresponds as closely as possible to &lt;aNativeTimestampOrDate&gt;."	^aNativeCalendricalCoordinate</body><body package="Chronos-System" selector="chronosTimeOfDayFromNativeTimeOfDay:">chronosTimeOfDayFromNativeTimeOfDay: aNativeTimeOfDay	"Answer a Chronos TimeOfDay that semantically corresponds as closely as possible to &lt;aNativeTimeOfDay&gt;."	^aNativeTimeOfDay</body><body package="Chronos-System" selector="chronosTimezoneFromNativeTimeZone:">chronosTimezoneFromNativeTimeZone: aNativeTimeZone 	"Answer a ChronosTimezone that semantically corresponds as closely as possible to &lt;aNativeTimeZone&gt;."	^self subclassResponsibility</body><body package="Chronos-System" selector="nativeCalendricalCoordinateFromChronosDate:">nativeCalendricalCoordinateFromChronosDate: aChronosDate	"Answer the native 'Date' analog (or 'Timestamp' analog, if no Date analog is available) that semantically corresponds as closely as possible to &lt;aChronosDate&gt;"	^aChronosDate</body><body package="Chronos-System" selector="nativeCalendricalCoordinateFromChronosDateAndTime:">nativeCalendricalCoordinateFromChronosDateAndTime: aChronosDateAndTime 	"Answer the native 'Timestamp' analog (or 'Date' analog, if no Timestamp analog is available) that semantically corresponds as closely as possible to &lt;aChronosDateAndTime&gt;"	^aChronosDateAndTime</body><body package="Chronos-System" selector="nativeTimeOfDayFromChronosTimeOfDay:">nativeTimeOfDayFromChronosTimeOfDay: aChronosTimeOfDay	"Answer the native 'TimeOfDay' analog that semantically corresponds as closely as possible to &lt;aChronosTimeOfDay&gt;"	"{ChronosSystemFacade current  nativeTimeOfDayFromChronosTimeOfDay: Gregorian clock timeOfDayNow}"	^aChronosTimeOfDay</body><body package="Chronos-System" selector="nativeTimeZoneFromChronosTimeZone:">nativeTimeZoneFromChronosTimeZone: aChronosTimezone	"Answer the native time zoneanalog that semantically corresponds as closely as possible to &lt;aChronosTimezone&gt;. If there is no such value, or if Chronos is the native date/time library of the host environment, answer &lt;aChronosTimezone&gt;."	^aChronosTimezone</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>installation</category><body package="Chronos-System" selector="instalIInitially">instalIInitially	"This method MUST be invoked immediately after the Chronos codebase has been fully loaded into an image (after which, the image must be persisted)--or it must be invoked whenever a non-image-based Smalltalk runtime system first loads the Chronos codebase. It may not be advisable to invoke it at other times."	"{ChronosSystemFacade current instalIInitially}"	self shouldSkipInstallation ifTrue: [^self reportInstallationSkipped].	showReports := true.	self installPrerequisites.	self registerForStartupNotification.	systemTimeZone := nil.	self basicInstall 		ifTrue: 			[systemTimeZoneBindingStrategy := self firstInstallationSystemTimeZoneBindingStrategy.			self setChronosSystemTimeZoneFromBaseSystem.			systemTimeZoneBindingStrategy := self defaultSystemTimeZoneBindingStrategy.			showReports := self byDefaultShouldShowReportsOnStartup]</body><body package="Chronos-System" selector="install">install	"Invalidate any information stored in the receiver that needs to be synchronized with external sources, such as configuration files, environment variables, registry settings, etc."	"This method MUST be invoked whenever a Smalltalk image starts running (i.e., whenever the image is restarted after a snapshot.)  In the case of Smalltalk implementations that don't use images, the method #installInitially should be called instead of #install (each time the Chronos codebase is loaded.)"	"{ChronosSystemFacade current install}"	(systemTimeZone == nil or: [systemTimeZone key == nil]) ifTrue: [^self instalIInitially].	self shouldSkipInstallation ifTrue: [^self reportInstallationSkipped].	self basicInstall ifTrue: [self setChronosSystemTimeZoneFromBaseSystem]</body><body package="Chronos-System" selector="installPrerequisites">installPrerequisites	"Ensure that any non-Chronos modules, packages, parcels (or whatever) that may be required for proper Chronos operation are installed."	"By default, do nothing.  Subimplement with whatever code may be necessay or advisable--if any."</body><body package="Chronos-System" selector="registerForStartupNotification">registerForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver will be sent the message #install.	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	"ChronosSystemFacade current registerForStartupNotification"	self unregisterForStartupNotification.	EnvironmentFacade subscribe: self forImageRestartNotificationSending: #install</body><body package="Chronos-System" selector="unregisterForStartupNotification">unregisterForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver will NOT be sent the message #install (nor otherwise notified.)	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	"ChronosSystemFacade current unregisterForStartupNotification"	EnvironmentFacade cancelImageRestartNotificationSubscriptionFor: self</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>private-user notification text</category><body package="Chronos-System" selector="systemTimeZoneNotResolvableMessage">systemTimeZoneNotResolvableMessage	"Text of the user notification message to be presented to the user when Chronos has not been able to set the Chronos system timezone based on the host system's local time."	"The notification text below is aimed at programmers; change or subimplement it in order to make the text appropriate to the actual user base."		^'Chronos is unable to determine the host system timezone.', (String with: Character cr), 		'If &lt;', self systemTimeZone name, '&gt; (the current Chronos system timezone)', (String with: Character cr), 		'does not coincide with the host system''s local time, it will be necessary to set the Chronos', (String with: Character cr), 		'system timezone manually (see the class comment of ChronosTimezone for instructions.)'</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>private-queries</category><body package="Chronos-System" selector="windowsTimeZoneAttributes">windowsTimeZoneAttributes	"If on Windows, answer the attributes (as a Dictionary with well-known keys) of the current user's Windows timezone ruleset as specified in the Windows Registry.  Answer nil if not on Windows, or if this operation is not currently supported."	"{ChronosSystemFacade current windowsTimeZoneAttributes}"	"The well-known keys used by Chronos to identify the attributes of a Windows timezone ruleset specification, and the value that should be associated with each key:				Key									Semantics and Smalltalk type of associated value that should be returned by this method (as values in a Dictionary)		#BaseOffsetSecondsFromUT	-&gt;	&lt;Integer&gt; base number of seconds that should be ADDED to the Universal time-of-day to derive local time-of-day during STANDARD TIME.		#StandardName					-&gt;	&lt;String&gt; whose value is Window's canonical name for the timezone.		#StandardBias					-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the &lt;BaseOffsetSecondsFromUT&gt; during standard time (usually zero).			-- The following entries should not be present if the timezone does not observe DST: 		#StandardDate					-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `standard` time--or not present if there is no transition to standard time.		#StandardTimeOfDay			-&gt; 	&lt;TimeOfDay&gt; at which the timezone transitions to `standard` time (always local 'wall-clock' time)--or not present if there is no transition to standard time.		#DaylightName					-&gt;	&lt;String&gt; whose value is Window's name for the timezone when DST is in effect.		#DaylightBias					-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the &lt;BaseOffsetSecondsFromUT&gt; during 'daylight-saving/summer' time.		#DaylightDate					-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `daylight-saving/summer` time.		#DaylightTimeOfDay				-&gt; &lt;TimeOfDay&gt; at which the timezone transitions to `daylight-saving/summer` time (always local 'wall-clock' time.).	The standard time offset from UT will be computed as &lt;BaseOffsetSecondsFromUT&gt; + &lt;StandardBias&gt;; the DST offset from UT will be computed as &lt;BaseOffsetSecondsFromUT&gt; + &lt;DaylightBias&gt;.	Windows timezone attributes are natively represented in a 'struct' defined as follows (a 'WCHAR' is defined as 'unsigned short'):		struct _TIME_ZONE_INFORMATION {			LONG Bias;									// Number of minutes to ADD to local standard time to derive universal time (inverse polarity of standard practice.)			WCHAR StandardName[32];				// Windows canonical timezone name--used as lookup key.			SYSTEMTIME StandardDate;				// Annual date and time of transition to Standard Time--see below.			LONG StandardBias;						// Number of minutes to ADD to &lt;Bias&gt; during Standard Time.			WCHAR DaylightName[32];				// Windows name of timezone during Daylight-Saving/Summer Time.			SYSTEMTIME DaylightDate;				// Annual date and time of transition to Daylight-Saving/Summer Time--see below.			LONG DaylightBias;						// Number of minutes to ADD to &lt;Bias&gt; during Daylight-Saving/Summer Time.		}	The SYSTEMTIME struct type is defined as follows (a 'WORD' is defined as 'unsigned short'):		typedef struct SYSTEMTIME { 			WORD wYear;			WORD wMonth;			WORD wDayOfWeek;			WORD wDay;			WORD wHour;			WORD wMinute;			WORD wSecond;			WORD wMilliseconds;		}	In a Windows timezone ruleset (as opposed to its usage elsewhere,) the members (fields, slots) of a SYSTEMTIME value have the following function/semantics:		Member/Field/Slot Name			Function/Role/Semantics				wYear									Not used		wMonth								Ordinal of the month in which a transition to/from DST occurs (1=January, 12=December); 													if the value is zero, then the struct represents a 'not a date' value, which means no transition.		wDayOfWeek						Cardinal number of the day of the week on which a transition to/from DST occurs (0=Sunday; 7=Saturday.)		wDay									Ordinal of the week of the month in which a transition to/from DST occurs; 													1 means the first week, 4 means the fouth week, 													but 5 means the last week of the month.		wHour									Cardinal number of the hour of the day when a transition to/from DST occurs (0-23.)		wMinute								Cardinal number of the minute of the hour of the day when a transition to/from DST occurs (0-59.)		wSecond								Cardinal number of the second of the minute of the hour of the day when a transition to/from DST occurs (0-59.)		wMilliseconds						Not used."	^nil "By default, we assume either that we're not running Windows, or that this function is not implementable by the host Smalltalk system."</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>resource repository</category><body package="Chronos-System" selector="findValidResourcePathPrefix:">findValidResourcePathPrefix: block1	"Summary: Evaluate &lt;block1&gt; for potential prefixes of the base resource path to the Chronos resource directories, in order of precedence. 	Detailed spec: 				For each potential base path prefix that specifies an existing resource directory, evaluate &lt;block1&gt; with the pathname String of the directory.  If the evaluation of &lt;block1&gt; results in the value true, answer true and do not evaluate any further potential base path prefixes.  If the evaluation of &lt;block1&gt; results in the value false, then proceed to evaluate the next potential base path prefix (in precedence order).  If there are no further potential base path prefixes, then answer false."	"{ChronosSystemFacade current findValidResourcePathPrefix: [:resourcePathPrefixString | Transcript cr; show: resourcePathPrefixString. false]}"	| pathString rp |	pathString := EnvironmentFacade current valueOfEnvironmentVariableAt: 'CHRONOS_PATH'.	(ChronosFunction isNilOrEmpty: pathString) ifFalse:		[rp := ResourcePath fromString: pathString.		rp exists ifTrue: [(block1 value: pathString) ifTrue: [^true]]].	rp := ResourcePath currentDirectory.	(block1 value: rp printString) ifTrue: [^true].	^false</body><body package="Chronos-System" selector="resourcePathPrefix">resourcePathPrefix	^self resourceRepositoryContext resourcePathPrefix</body><body package="Chronos-System" selector="resourceRepositoryContext">resourceRepositoryContext	resourceRepositoryContext == nil ifTrue: [self setResourceRepositoryContext].	^resourceRepositoryContext</body></methods><methods><class-id>Chronos.ChronosSystemFacade</class-id> <category>private-testing</category><body package="Chronos-System" selector="shouldSkipInstallation">shouldSkipInstallation	"Answer whether the receiver's installation operation should be totally skipped (applies to either #installInitially or #install.)"	"{ChronosSystemFacade current shouldSkipInstallation}"	"{ChronosEnvironment canonical globalNamespace at: #ChronosInstallationFlag put: false}"	"{ChronosEnvironment canonical globalNamespace removeKey: #ChronosInstallationFlag ifAbsent: []}"	self class == ChronosSystemFacade ifTrue: [^true].	^ChronosEnvironment shouldSkipInstallation or: [(EnvironmentFacade current valueOfEnvironmentVariableAt: 'CHRONOS_INSTALLATION') asUppercase = 'NO']</body></methods><methods><class-id>Chronos.ChronosSystemFacade class</class-id> <category>class initialization</category><body package="Chronos-System" selector="initialize">initialize	"ChronosSystemFacade initialize"	self release</body><body package="Chronos-System" selector="release">release	"The message #release must be sent to ChronosSystemFacade whenever Chronos is about to be removed from the system (image.)  It is the responsibility of subimplementors to ensure that this message is sent at the appropriate time."	"ChronosSystemFacade release"	Current == nil ifFalse: [Current release].	Current := nil.	self allSubclassesDo: [:subclass | subclass basicRelease]</body></methods><methods><class-id>Chronos.ChronosSystemFacade class</class-id> <category>accessing</category><body package="Chronos-System" selector="appOrLibraryName">appOrLibraryName	^'Chronos'</body><body package="Chronos-System" selector="current">current	"ChronosSystemFacade current"	Current == nil 		ifTrue: [Current := ChronosEnvironment systemFacadeClass new].	^Current</body><body package="Chronos-System" selector="resourceRepositoryContext">resourceRepositoryContext	^self current resourceRepositoryContext</body></methods><methods><class-id>Chronos.ChronosSystemFacade class</class-id> <category>private</category><body package="Chronos-System" selector="basicRelease">basicRelease	"Ensure that all instances of the receiver get released."	"ChronosSystemFacade basicRelease"	self allInstancesDo: [:each | each unregisterForStartupNotification]</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>private-reporting</category><body package="Chronos-System-VW" selector="reportFailureOfWindowsTimeZoneAttributesRetrieval:">reportFailureOfWindowsTimeZoneAttributesRetrieval: exception	self		reportToConsole: 'DLLCC call to retrieve Windows TimeZone Attributes failed with the following exception: ';		reportToConsole: exception printString newLineCount: 1 tabCount: 1</body><body package="Chronos-System-VW" selector="reportInitialChronosInstallationAsSuccessful">reportInitialChronosInstallationAsSuccessful	"ChronosSystemFacade current reportInitialChronosInstallationAsSuccessful"	super reportInitialChronosInstallationAsSuccessful.	systemTimeZone == nil ifFalse: [^self].	EnvironmentFacade current isOnWindows 		ifTrue: 			[self isOSTimeZoneInstalled				ifFalse: 					[EnvironmentFacade current						reportToConsole: '-- If and only if the DLLCC and OSTimeZone parcels have been previously installed, then Chronos will usually be able to set the system timezone to match that of the operating sytem; this must be done manually otherwise.'						newLineCount: 1						tabCount: 1]]		ifFalse: 			[EnvironmentFacade current				reportToConsole: '-- On many UNIX-based systems, Chronos cannot presently determine the time zone that defines local time unless the TZ environment variable is set to a valid value.'				newLineCount: 1				tabCount: 1].	EnvironmentFacade current			reportToConsole: '(Chronos.ChronosTimezone offset: (Chronos.ScientificDuration hours: -7) name: ''Mountan Standard Time'' commonAbbreviation: #MST) beSystem.'			newLineCount: 1			tabCount: 1.	#('Australia/Sydney' 'Asia/Tokyo' 'Asia/Calcutta' 'Europe/Berlin' 'America/New_York' 'America/Los_Angeles')  do: [:tz | 		EnvironmentFacade current			reportToConsole: '(ChronosTimezone at: ', tz printString, ') beSystem.'			newLineCount: 1			tabCount: 1].	self			reportToConsole: 'The Chronos system time zone must be set manually. The examples above show how that may be done for some common time zones. The full set of Olson time zone keys can be found at http://www.timezoneconverter.com/cgi-bin/tzref.tzc';		newLineToConsole</body><body package="Chronos-System-VW" selector="reportOSSetTimeZoneFailure:">reportOSSetTimeZoneFailure: exception	self		reportToConsole: 'Evaluation of "TimeZone osSetTimeZone" failed with the following exception: ';		reportToConsole: exception printString newLineCount: 1 tabCount: 1</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>private-system timezone</category><body package="Chronos-System-VW" selector="constructChronosAnalogOfVWTimeZone:key:name:stdAbbreviation:dstAbbreviation:">constructChronosAnalogOfVWTimeZone: aVWTimeZone key: tzKey name: tzName stdAbbreviation: stdAbbreviation dstAbbreviation: dstAbbreviation	"{ChronosSystemFacade current 		constructChronosAnalogOfVWTimeZone: TimeZone default 		key: #test name: 'VisualWorks Time' stdAbbreviation: #STD dstAbbreviation: #DST}"	| stdOffsetSecondsFromUT dstDeltaSeconds dstOffsetSecondsFromUT dayOfWeekKey dayOfWeek annualDateFromLatestDayOfNonLeapYear toDstAnnualDate toStdAnnualDate |	stdOffsetSecondsFromUT := self stdTimeOffsetSecondsFromVWTimeZone: aVWTimeZone.	dstDeltaSeconds := self dstDeltaSecondsFromVWTimeZone: aVWTimeZone.	dstDeltaSeconds = 0 		ifTrue: 			[^stdOffsetSecondsFromUT = 0 				ifTrue: [ChronosTimezone universal] 				ifFalse: 					[(BasicTimezone						offset: (DurationFactory seconds: stdOffsetSecondsFromUT)						name: tzName						commonAbbreviation: stdAbbreviation)]].	dstOffsetSecondsFromUT := stdOffsetSecondsFromUT + dstDeltaSeconds.	dayOfWeekKey := self dayOfWeekKeyFromVWTimeZone: aVWTimeZone.	dayOfWeek := ANSIDayOfWeekKeys indexOf: dayOfWeekKey.	annualDateFromLatestDayOfNonLeapYear := 			[:latestDayOfNonLeapYear | 			| stdYearCalendar latestDay earliestDay |			stdYearCalendar := Gregorian yearlyCalendarForYearTypeCode: 1.			latestDay := stdYearCalendar dayAt: latestDayOfNonLeapYear.			earliestDay := latestDay subtractingDays: 6.			earliestDay month = latestDay month				ifTrue:					[| earliestDayOfMonth daysFromEndOfMonth |					earliestDayOfMonth := earliestDay dayOfMonth.					daysFromEndOfMonth := earliestDay daysPerMonth - earliestDayOfMonth.					daysFromEndOfMonth &lt; 7 ifTrue: [earliestDayOfMonth := -6 "Last week of month"].					WeekOfMonthDayOfWeekFactory						month: earliestDay monthOrdinal						minDayOfMonth: earliestDayOfMonth						dayOfWeek: dayOfWeek]				ifFalse:					[WeekOfMonthDayOfWeekFactory						month: latestDay monthOrdinal						minDayOfMonth: 1						dayOfWeek: dayOfWeek]].	toDstAnnualDate := annualDateFromLatestDayOfNonLeapYear value: (self latestDayOfYearOrdinalForFirstOffsetTansitionFromVWTimeZone: aVWTimeZone).	toStdAnnualDate := annualDateFromLatestDayOfNonLeapYear value: (self latestDayOfYearOrdinalForSecondOffsetTansitionFromVWTimeZone: aVWTimeZone).	^ChronosTimezone 		key: tzKey name: tzName		initialOffset: (DurationFactory seconds: stdOffsetSecondsFromUT) withAbbreviation: stdAbbreviation			until: toDstAnnualDate at: (TimeOfDayFactory secondsSinceStartOfDay: (self secondsSinceStartOfDayAtFirstOffsetTansitionFromVWTimeZone: aVWTimeZone)) relativity: #nominal		thenOffset: (DurationFactory seconds: dstOffsetSecondsFromUT) withAbbreviation: dstAbbreviation			until: toStdAnnualDate at: (TimeOfDayFactory secondsSinceStartOfDay: (self secondsSinceStartOfDayAtSecondOffsetTansitionFromVWTimeZone: aVWTimeZone)) relativity: #nominal</body><body package="Chronos-System-VW" selector="dayOfWeekKeyFromVWTimeZone:">dayOfWeekKeyFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 7</body><body package="Chronos-System-VW" selector="dstDeltaSecondsFromVWTimeZone:">dstDeltaSecondsFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 6</body><body package="Chronos-System-VW" selector="initializeVWTimeZone:fromChronosTimezone:">initializeVWTimeZone: vwTimeZone fromChronosTimezone: aChronosTimezone	"ChronosSystemFacade current setVWTimeZoneFromChronosSystemTimeZone"	| stdTimeOffsetHoursFromUT dstOffsetHours firstTransitionHourOfDay secondTransitionHourOfDay firstTransitionMaxDayOfYearOrdinal secondTransitionMaxDayOfYearOrdinal dayOfWeek offsetPolicy1 depth stdTimeOffsetSecondsFromUT1 offsetSecondsFromUT1 offsetDeltaSeconds1 stdTimeOffsetHoursFromUT1 offsetHoursFromUT1 dstOffsetHours1 offsetPolicy2 stdTimeOffsetHoursFromUT2 offsetHoursFromUT2 dstOffsetHours2 stdTimeOffsetSecondsFromUT2 offsetSecondsFromUT2 offsetDeltaSeconds2 |	(vwTimeZone respondsTo: #initializeFromAnnuallyRecurringTZPolicyFactoryArray:)		ifTrue: 			[vwTimeZone initializeFromAnnuallyRecurringTZPolicyFactoryArray: aChronosTimezone defaultAnnualPolicy asAnnuallyRecurringTZPolicyFactoryArray.			(vwTimeZone respondsTo: #key:) 				ifTrue: [vwTimeZone key: aChronosTimezone key].			^vwTimeZone].	firstTransitionHourOfDay := 0.	secondTransitionHourOfDay := 0.	firstTransitionMaxDayOfYearOrdinal := 0.	secondTransitionMaxDayOfYearOrdinal := 0.	dayOfWeek := Sunday.	offsetPolicy1 := aChronosTimezone defaultAnnualPolicy.	depth := offsetPolicy1 depth.	stdTimeOffsetSecondsFromUT1 := offsetPolicy1 stdTimeOffsetSecondsFromUT.	offsetSecondsFromUT1 := offsetPolicy1 offsetSecondsFromUT.	offsetDeltaSeconds1 := offsetPolicy1 offsetDeltaSeconds.  	 "The following won't work for zones that have fractional hour offsets--but the responsibility for addressing that issue rests with the owners of VisualWorks."	stdTimeOffsetHoursFromUT1 := stdTimeOffsetSecondsFromUT1 // SecondsPerHour.	offsetHoursFromUT1 := offsetSecondsFromUT1 // SecondsPerHour.  	dstOffsetHours1 := offsetDeltaSeconds1  // SecondsPerHour.  	depth &gt; 1 		ifTrue: 			["ASSUMPTIONS: 				1) There are only two transitions, and 				2) The final transition returns to the same values as pertained at the start of the year.			There are cases where one or both of these assumptions DO NOT HOLD.  However, the VW TimeZone class CANNOT HANDLE SUCH CASES, so it is pointless to even check for them unless and until the TimeZone class can handle such situations, since there would otherwise be no satisfactory solution anyway. Fortunately, such pathological cases are relatively rare, especially in the United States in modern times."						| thisYear |			thisYear := Gregorian clock thisYear.			firstTransitionMaxDayOfYearOrdinal := (offsetPolicy1 maxDaysFromStartOfYearUntilTransitionForYearOfType: 1) + 1.			dayOfWeek := offsetPolicy1 transitionDayOfWeekInYear: thisYear.			"We'll assume the dayOfWeek is the same in both cases--if not, the VW TimeZone as currently implemented can't deal with it, so..."			firstTransitionHourOfDay := offsetPolicy1 transitionSecondsSinceStartOfDay // SecondsPerHour.			offsetPolicy1 isSpecifiedAsLocalTime				ifFalse: 					["The rules for our Chronos TimeZoneOffsetPolicy are specified in UT. However, the VW TimeZone doesn't do UT rules, so we have to translate the rules into local time."					| utcHours |					utcHours := offsetPolicy1 isSpecifiedAsUT						ifTrue: [firstTransitionHourOfDay + offsetHoursFromUT1]						ifFalse: [firstTransitionHourOfDay + dstOffsetHours1].					firstTransitionHourOfDay := utcHours \\ HoursPerDay.					firstTransitionMaxDayOfYearOrdinal := firstTransitionMaxDayOfYearOrdinal + (utcHours // HoursPerDay).					dayOfWeek := (dayOfWeek - 1 + (utcHours // HoursPerDay)) \\ 7 + 1].			offsetPolicy2 := offsetPolicy1 rightLink.			stdTimeOffsetSecondsFromUT2 := offsetPolicy2 stdTimeOffsetSecondsFromUT.			offsetSecondsFromUT2 := offsetPolicy2 offsetSecondsFromUT.			offsetDeltaSeconds2 := offsetPolicy2 offsetDeltaSeconds.  			stdTimeOffsetHoursFromUT2 := stdTimeOffsetSecondsFromUT2 // SecondsPerHour.			offsetHoursFromUT2 := offsetSecondsFromUT2 // SecondsPerHour.  			dstOffsetHours2 := offsetDeltaSeconds2  // SecondsPerHour.			depth &gt; 2				ifTrue: 					[secondTransitionMaxDayOfYearOrdinal := (offsetPolicy2 maxDaysFromStartOfYearUntilTransitionForYearOfType: 1) + 1.					secondTransitionHourOfDay := offsetPolicy2 transitionSecondsSinceStartOfDay // SecondsPerHour.						offsetPolicy2 isSpecifiedAsLocalTime						ifFalse: 							[| utcHours |							utcHours := offsetPolicy2 isSpecifiedAsUT								ifTrue: [secondTransitionHourOfDay + offsetHoursFromUT2]								ifFalse: [secondTransitionHourOfDay + dstOffsetHours2].							secondTransitionHourOfDay := utcHours \\ HoursPerDay.							secondTransitionMaxDayOfYearOrdinal := secondTransitionMaxDayOfYearOrdinal + (utcHours // HoursPerDay)].					offsetDeltaSeconds1 = 0 "If the offsetDelta is zero, it's standard time--otherwise, it's DST."						ifTrue:							[stdTimeOffsetHoursFromUT := stdTimeOffsetHoursFromUT1.							dstOffsetHours := dstOffsetHours2]						ifFalse: 							["The VW TimeZone class DOES handle Time Zones in the Southern Hemisphere, where DST goes into effect in September or October, and ends in March or April. However, VW's convention for handling such cases is different than that of Chronos.  A Chronos AnnuallyRecurringTZPolicy is simply a linked list of rules, where the first rule specifies the zone offset and abbreviation from the start of the year until the transition date/time, after which the next link in the list does the same, until the final link (which only has an implied ending at the end of the year, and which typically specifies the same zone offset and abbreviation as does the first link.) In contrast, the VW TimeZone has a start-of-dst date and an end-of-dst date.  It handles Southern Hemisphere rules by having the end-of-dst date be earlier in the year than the start-of-dst date. So, to translate from Chronos to VW in the case at hand, we swap the first and second transition dates/times to conform to the VW TimeZone convention:"							| swap | 							stdTimeOffsetHoursFromUT := stdTimeOffsetHoursFromUT2.							dstOffsetHours := dstOffsetHours1.							swap := firstTransitionHourOfDay.							firstTransitionHourOfDay := secondTransitionHourOfDay.							secondTransitionHourOfDay := swap.							swap := firstTransitionMaxDayOfYearOrdinal.							firstTransitionMaxDayOfYearOrdinal := secondTransitionMaxDayOfYearOrdinal.							secondTransitionMaxDayOfYearOrdinal := swap]]				ifFalse: 					["We'll just assume that what we have here is a one time transition either TO or FROM daylight saving time--although the situation COULD be more complex.  The VW TimeZone is not designed to handle any of these cases, so we will have to improvise. We initially assume there is a single transition FROM standard time TO daylight saving time, which often happens right after a war or energy crisis has begun, but then check for and handle the case for the Southern Hemisphere, where the year starts out in DST."					secondTransitionHourOfDay := 25.					secondTransitionMaxDayOfYearOrdinal := (Gregorian daysInYear: thisYear) + 6.					offsetDeltaSeconds1 = 0 "If the offsetDelta is zero, it's standard time--otherwise, it's DST."						ifTrue:							[stdTimeOffsetHoursFromUT := stdTimeOffsetHoursFromUT1.							dstOffsetHours := dstOffsetHours2]						ifFalse: 							["Ooops!  VW's TimeZone class has a real problem with this case (where there is a one-time transition FROM daylight saving time TO standard time--which happens whenever civil authority decides to discontinue DST for some indefinite period (not everyone likes DST, to put it mildly.) So we cheat: we pretend that DST is STANDARD TIME, and vice versa."							stdTimeOffsetHoursFromUT := stdTimeOffsetHoursFromUT1.							dstOffsetHours := dstOffsetHours1 negated]]]		ifFalse:			[stdTimeOffsetHoursFromUT := stdTimeOffsetHoursFromUT1.			dstOffsetHours := dstOffsetHours1].	self 		initializeVWTimeZone: aChronosTimezone key 		toStdTimeOffset: stdTimeOffsetHoursFromUT 		dstDelta: dstOffsetHours 		firstTransitionHourOfDay: firstTransitionHourOfDay 		secondTransitionHourOfDay: secondTransitionHourOfDay 		firstTransitionMaxDayOfYearOrdinal: firstTransitionMaxDayOfYearOrdinal 		secondTransitionMaxDayOfYearOrdinal: secondTransitionMaxDayOfYearOrdinal 		dayOfWeekKey: (ANSIDayOfWeekKeys at: dayOfWeek)</body><body package="Chronos-System-VW" selector="initializeVWTimeZone:toStdTimeOffset:dstDelta:firstTransitionHourOfDay:secondTransitionHourOfDay:firstTransitionMaxDayOfYearOrdinal:secondTransitionMaxDayOfYearOrdinal:dayOfWeekKey:">initializeVWTimeZone: key toStdTimeOffset: stdTimeOffsetHoursFromUT dstDelta: dstOffsetHours firstTransitionHourOfDay: firstTransitionHourOfDay secondTransitionHourOfDay: secondTransitionHourOfDay firstTransitionMaxDayOfYearOrdinal: firstTransitionMaxDayOfYearOrdinal secondTransitionMaxDayOfYearOrdinal: secondTransitionMaxDayOfYearOrdinal dayOfWeekKey: dayOfWeekKey	| vwTimeZone |	vwTimeZone := 		TimeZone 			timeDifference: stdTimeOffsetHoursFromUT			DST: dstOffsetHours start: firstTransitionHourOfDay end: secondTransitionHourOfDay			from: firstTransitionMaxDayOfYearOrdinal			to: secondTransitionMaxDayOfYearOrdinal			startDay: dayOfWeekKey.	(vwTimeZone respondsTo: #key:)		ifTrue: [vwTimeZone key: key]</body><body package="Chronos-System-VW" selector="latestDayOfYearOrdinalForFirstOffsetTansitionFromVWTimeZone:">latestDayOfYearOrdinalForFirstOffsetTansitionFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 2</body><body package="Chronos-System-VW" selector="latestDayOfYearOrdinalForSecondOffsetTansitionFromVWTimeZone:">latestDayOfYearOrdinalForSecondOffsetTansitionFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 3</body><body package="Chronos-System-VW" selector="secondsSinceStartOfDayAtFirstOffsetTansitionFromVWTimeZone:">secondsSinceStartOfDayAtFirstOffsetTansitionFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 4</body><body package="Chronos-System-VW" selector="secondsSinceStartOfDayAtSecondOffsetTansitionFromVWTimeZone:">secondsSinceStartOfDayAtSecondOffsetTansitionFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 5</body><body package="Chronos-System-VW" selector="setBaseSystemTimeZoneFromChronosSystemTimeZone">setBaseSystemTimeZoneFromChronosSystemTimeZone	"Set the base system's Timezone to one which is as congruent as possible to the receiver's &lt;systemTimeZone&gt;.  This operation MUST NOT affect how time is reported by Chronos. If the Smalltalk execution environment has its own support for Time Zones (apart from either Chronos or the operating system,) then this operation MUST affect how the current Smalltalk execution environment reports time using its native date-time facilities.  Ideally, this operation should also affect the reporting of time by the host operating system  	NOTE: Some systems keep time in UT, and report local time by converting from UT according to the specifications of the current timezone.  Other systems keep time in local terms, and convert to UT when needful according to the specifications of the current timezone.  In the former case, this operation should change the local time-of-day natively reported by the Smalltalk execution environment.  In the latter case, it should change the UT time-of-day natively reported by the Smalltalk execution environment. Whether existing instances of native (non-Chronos) date/time objects should be translated as part of this operation is not specified (Chronos cares not.)"	self setVWTimeZoneFromChronosSystemTimeZone.	"In the future, we may also set the OS timezone here--which is why we break out the setting of the VW TimeZone into its own method."</body><body package="Chronos-System-VW" selector="setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone">setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone	"If it's possible to determine that the host system is using an Olson timezone to define its local time, and if it's also possible to determine the Olson key of that timezone (to the desired degreee of certainty and precision,) then set the receiver's &lt;systemTimeZone&gt; to a Chronos VariableOffsetTimezone with the same key and answer true. Othwerwise do nothing and answer false"	"{ChronosSystemFacade current setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone}"	^super setSystemTimeZoneOnlyFromNativeSystemOlsonTimeZone 		ifTrue: 			["Might as well set the VW TimeZone also."			self setVWTimeZoneFromChronosSystemTimeZone.			true]		ifFalse: [false]</body><body package="Chronos-System-VW" selector="setSystemTimeZoneToAnalogOfNativeSystemTimeZone">setSystemTimeZoneToAnalogOfNativeSystemTimeZone	"If it's possible to determine that the host system is using an Olson timezone to define its local time, and if it's also possible to determine the Olson key of that timezone (to the desired degreee of certainty and precision,) then set the receiver's &lt;systemTimeZone&gt; to a Chronos VariableOffsetTimezone with the same key and answer true.	Otherwise, construct a ChronosTimezone that emulates the behavior of the host system's timezone as closely as possible (i.e., serves a reasonably close analog of the host system's timezone,) set the ChronosTimezone so constructed as the &lt;systemTimeZone&gt; and answer true. However, if it's not possible to get sufficient information about the host system's timezone to construct a ChronosTimezone that will serve as a reasonable analog, then do nothing and answer false."	"This implementation uses VW's 'TimeZone default' as a last resort for obtaining 'host system' timezone information."	"{ChronosSystemFacade current setSystemTimeZoneToAnalogOfNativeSystemTimeZone}"	^super setSystemTimeZoneToAnalogOfNativeSystemTimeZone		ifTrue: [true]		ifFalse: 			[self setSystemTimeZone:  				(self 					constructChronosAnalogOfVWTimeZone: TimeZone default					key: #system					name: #VWDefaultTimeZone					stdAbbreviation: #VWST					dstAbbreviation: #VWDT).			true]</body><body package="Chronos-System-VW" selector="setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem">setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem	"Determine the key of the Olson timezone that is the most congruent to the host system's timezone, set the &lt;systemTimeZone&gt; to the ChronosTimezone with that key, and answer true. However, if it is not possible to obtain enough information about the host system's timezone to determine the Olson timezone key of the Olson timezone that would be reasonably congruent to the host system's timezone, then do nothing and answer false."	"This implementation uses VW's 'TimeZone default' as a last resort for mapping to an Olson timezone."	| success tzSetFromOS |	success := super setSystemTimeZoneToOlsonTimeZoneMostCongruentToNativeSystem.	success		ifTrue: [tzSetFromOS := true]		ifFalse: 			[| timeZoneKey tz |			"So, we have to use the VW TimeZone information. We'll map the 'secondsFromGMT' to an Olson timezone key using the default TimeZoneLocalizationPolicy."			tzSetFromOS := self setVWTimeZoneFromOS. "Worth a try."			timeZoneKey := 				TimeZoneLocalizationPolicy default 					defaultTimeZoneKeyForStandardTimeOffsetSecondsFromUT: (self stdTimeOffsetSecondsFromVWTimeZone: TimeZone default)					dstPreferred: (self dstDeltaSecondsFromVWTimeZone: TimeZone default) ~= 0 "secondsForDST"					ifAbsent: [].			timeZoneKey == nil				ifTrue: [tzSetFromOS := false]				ifFalse:					[tz :=VariableOffsetTimezone at: timeZoneKey ifAbsent: [].					tz == nil						ifTrue: [tzSetFromOS := false]						ifFalse: 							[success := true.							self setSystemTimeZone:  tz]]].	tzSetFromOS "Might as well set the VW TimeZone also."		ifTrue: [self setVWTimeZoneFromChronosSystemTimeZone].	^success</body><body package="Chronos-System-VW" selector="setVWTimeZoneFromChronosSystemTimeZone">setVWTimeZoneFromChronosSystemTimeZone	"ChronosSystemFacade current setVWTimeZoneFromChronosSystemTimeZone"	self initializeVWTimeZone: TimeZone default fromChronosTimezone: self systemTimeZone</body><body package="Chronos-System-VW" selector="setVWTimeZoneFromOS">setVWTimeZoneFromOS	^self isOSTimeZoneInstalled		ifTrue: 			[[TimeZone osSetTimeZone. true] 				on: Error 				do: [:ex | self reportOSSetTimeZoneFailure: ex. ex return: false]]		ifFalse: [false]</body><body package="Chronos-System-VW" selector="stdTimeOffsetSecondsFromVWTimeZone:">stdTimeOffsetSecondsFromVWTimeZone: aVWTimeZone	^aVWTimeZone secondsFromGMT</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>value conversion</category><body package="Chronos-System-VW" selector="chronosDateAndTimeFromNativeCalendricalCoordinate:calendarClock:">chronosDateAndTimeFromNativeCalendricalCoordinate: aNativeCalendricalCoordinate calendarClock: calendarClock 	"Answer a Chronos DateAndTime that semantically corresponds as closely as possible to &lt;aNativeTimestampOrDate&gt;."	"{ChronosSystemFacade current chronosDateAndTimeFromNativeCalendricalCoordinate: Timestamp now calendarClock: Calendar gregorian clock}	{ChronosSystemFacade current chronosDateAndTimeFromNativeCalendricalCoordinate: Timestamp now calendarClock: Calendar julian clock}	{ChronosSystemFacade current chronosDateAndTimeFromNativeCalendricalCoordinate: Date today calendarClock: Calendar julian clock}	{ChronosSystemFacade current chronosDateAndTimeFromNativeCalendricalCoordinate: Date today calendarClock: Calendar gregorian clock}"	"NOTE: Both VW Timestamps and VW Dates semantically correspond to nominal Timepoints, since neither is bound to a specific Timezone."	| calendar |	calendar := calendarClock calendar.	^(aNativeCalendricalCoordinate respondsTo: #millisecond) 		ifTrue: 			["We assume it's a Timestamp"			calendar isGregorian 				ifTrue: 					[DateAndTimeFactory 						nominalYear: aNativeCalendricalCoordinate year						month: aNativeCalendricalCoordinate month						day: aNativeCalendricalCoordinate dayOfMonth						hour: aNativeCalendricalCoordinate hour						minute: aNativeCalendricalCoordinate minute						second: aNativeCalendricalCoordinate second						nanosecond: aNativeCalendricalCoordinate millisecond * NanosecondsPerMillisecond]				ifFalse: 					[DateAndTimeFactory 						nominalSecondsSinceEpoch: 							aNativeCalendricalCoordinate asSeconds 								+ calendarClock secondsFromCalendarEpochUpToSystemClockEpoch						nanoseconds: aNativeCalendricalCoordinate millisecond * NanosecondsPerMillisecond						calendar: calendar]]		ifFalse: 			["We assume it's a Date"			calendar isGregorian 				ifTrue: 					[DateAndTimeFactory 						nominalYear: aNativeCalendricalCoordinate year						day: aNativeCalendricalCoordinate day]				ifFalse: 					[DateAndTimeFactory 						nominalDaysSinceEpoch: 							aNativeCalendricalCoordinate asDays 								+ calendarClock daysFromCalendarEpochUpToSystemClockEpoch						seconds: 							(calendarClock calendar 								secondsSinceStartOfDayFromSecondsSinceMidnight: 0)						nanoseconds: 0						calendar: calendar]]</body><body package="Chronos-System-VW" selector="chronosDateFromNativeCalendricalCoordinate:calendarClock:">chronosDateFromNativeCalendricalCoordinate: aNativeCalendricalCoordinate calendarClock: calendarClock 	"Answer a Chronos date value that semantically corresponds as closely as possible to &lt;aNativeTimestampOrDate&gt;."	"{ChronosSystemFacade current chronosDateFromNativeCalendricalCoordinate: Timestamp now calendarClock: Calendar gregorian clock}	{ChronosSystemFacade current chronosDateFromNativeCalendricalCoordinate: Timestamp now calendarClock: Calendar julian clock}	{ChronosSystemFacade current chronosDateFromNativeCalendricalCoordinate: Date today calendarClock: Calendar julian clock}	{ChronosSystemFacade current chronosDateFromNativeCalendricalCoordinate: Date today calendarClock: Calendar gregorian clock}"	"NOTE: Both VW Timestamps and VW Dates semantically correspond to nominal Timepoints, since neither is bound to a specific Timezone."	| calendar |	calendar := calendarClock calendar.	^(aNativeCalendricalCoordinate respondsTo: #millisecond) 		ifTrue: 			["We assume it's a Timestamp"			calendar isGregorian 				ifTrue: 					[DateFactory 						year: aNativeCalendricalCoordinate year						month: aNativeCalendricalCoordinate month						day: aNativeCalendricalCoordinate dayOfMonth]				ifFalse: 					[DateFactory 						daysSinceEpoch: 							(aNativeCalendricalCoordinate asSeconds 								+ calendarClock secondsFromCalendarEpochUpToSystemClockEpoch) // SecondsPerDay						calendar: calendar]]		ifFalse: 			["We assume it's a Date"			calendar isGregorian 				ifTrue: 					[DateFactory 						year: aNativeCalendricalCoordinate year						day: aNativeCalendricalCoordinate day]				ifFalse: 					[DateFactory 						daysSinceEpoch: 							aNativeCalendricalCoordinate asDays 								+ calendarClock daysFromCalendarEpochUpToSystemClockEpoch						calendar: calendar]]</body><body package="Chronos-System-VW" selector="chronosTimeOfDayFromNativeTimeOfDay:">chronosTimeOfDayFromNativeTimeOfDay: aNativeTimeOfDay 	"Answer a Chronos TimeOfDay that semantically corresponds as closely as possible to &lt;aNativeTimeOfDay&gt;."	^TimeOfDayFactory 		hour: aNativeTimeOfDay hours		minute: aNativeTimeOfDay minutes		second: aNativeTimeOfDay seconds</body><body package="Chronos-System-VW" selector="chronosTimezoneFromNativeTimeZone:">chronosTimezoneFromNativeTimeZone: aNativeTimeZone 	"Answer a ChronosTimezone that semantically corresponds as closely as possible to &lt;aNativeTimeZone&gt;."	"ChronosSystemFacade current chronosTimezoneFromNativeTimeZone: TimeZone default"	(aNativeTimeZone respondsTo: #key) 		ifTrue: 			[| tz |			tz := ChronosTimezone at: aNativeTimeZone key ifAbsent: [].			tz == nil ifFalse: [^tz]].	^self 		constructChronosAnalogOfVWTimeZone: aNativeTimeZone		key: #VWAnalog		name: #VWTimeZoneAnalog		stdAbbreviation: #VWST		dstAbbreviation: #VWDT</body><body package="Chronos-System-VW" selector="nativeCalendricalCoordinateFromChronosDate:">nativeCalendricalCoordinateFromChronosDate: aChronosDate	"Answer the native 'Date' analog (or 'Timestamp' analog, if no Date analog is available) that semantically corresponds as closely as possible to &lt;aChronosDate&gt;"	"{ChronosSystemFacade current  nativeCalendricalCoordinateFromChronosDate: Gregorian clock dateToday}"	"{ChronosSystemFacade current  nativeCalendricalCoordinateFromChronosDate: Julian clock dateToday}"	^aChronosDate isGregorian		ifTrue: [Date newDay: aChronosDate dayOfYear year: aChronosDate year]		ifFalse: [Date fromDays: aChronosDate asDays]</body><body package="Chronos-System-VW" selector="nativeCalendricalCoordinateFromChronosDateAndTime:">nativeCalendricalCoordinateFromChronosDateAndTime: aChronosDateAndTime 	"Answer the native 'Timestamp' analog (or 'Date' analog, if no Timestamp analog is available) that semantically corresponds as closely as possible to &lt;aChronosDateAndTime&gt;"	"{ChronosSystemFacade current  nativeCalendricalCoordinateFromChronosDateAndTime: Gregorian clock now}"	"{ChronosSystemFacade current  nativeCalendricalCoordinateFromChronosDateAndTime: Julian clock now}"	^aChronosDateAndTime isGregorian		ifTrue: 			[Timestamp basicNew				year: aChronosDateAndTime year;				month: aChronosDateAndTime month;				day: aChronosDateAndTime dayOfMonth;				hour: aChronosDateAndTime hour;				minute: aChronosDateAndTime minute;				second: aChronosDateAndTime second;				millisecond: aChronosDateAndTime millisecond;				yourself]		ifFalse:			[Timestamp basicNew				fromSeconds: aChronosDateAndTime secondsSinceEpoch - aChronosDateAndTime clock secondsFromCalendarEpochUpToSystemClockEpoch;				millisecond: aChronosDateAndTime millisecond;				yourself]</body><body package="Chronos-System-VW" selector="nativeTimeOfDayFromChronosTimeOfDay:">nativeTimeOfDayFromChronosTimeOfDay: aChronosTimeOfDay	"Answer the native 'TimeOfDay' analog that semantically corresponds as closely as possible to &lt;aChronosTimeOfDay&gt;"	"{ChronosSystemFacade current  nativeTimeOfDayFromChronosTimeOfDay: Gregorian clock timeOfDayNow}"	^Time fromSeconds: aChronosTimeOfDay secondsSinceStartOfDay</body><body package="Chronos-System-VW" selector="nativeTimeZoneFromChronosTimeZone:">nativeTimeZoneFromChronosTimeZone: aChronosTimezone	"Answer the native time zoneanalog that semantically corresponds as closely as possible to &lt;aChronosTimezone&gt;. If there is no such value, or if Chronos is the native date/time library of the host environment, answer &lt;aChronosTimezone&gt;."	^self initializeVWTimeZone: TimeZone new fromChronosTimezone: aChronosTimezone</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>private</category><body package="Chronos-System-VW" selector="baseSystemLocaleKey">baseSystemLocaleKey	^Locale current name</body><body package="Chronos-System-VW" selector="baseSytemLocaleKeyFromLanguageCode:countryCode:">baseSytemLocaleKeyFromLanguageCode: languageCode countryCode: countryCode 	"VW uses the standard encoding with a non-standard suffix (used to identify the host-OS-specific code page--which just should NOT be part of a cross-platform locale ID!)"	^(countryCode == nil 		ifTrue: 			[| wildcard |			wildcard := languageCode , '*'.			Locale availableLocales 				detect: [:vwLocaleKey | wildcard match: vwLocaleKey]				ifNone: [self baseSystemLocaleKey]]		ifFalse: 			[Locale availableLocales detect: 					[:vwLocaleKey | 					self 						fromBaseSystemLocaleKey: vwLocaleKey						setLanguageCodeAndCountryCodeInto: 							[:vwLang :vwCountry | 							(vwLang match: languageCode) and: [vwCountry match: countryCode]]]				ifNone: [self baseSystemLocaleKey]]) asSymbol</body><body package="Chronos-System-VW" selector="findValidResourcePathPrefix:">findValidResourcePathPrefix: block1	"Summary: Evaluate &lt;block1&gt; for potential prefixes of the base resource path to the Chronos resource directories, in order of precedence. 	Detailed spec: 				For each potential base path prefix that specifies an existing resource directory, evaluate &lt;block1&gt; with the pathname String of the directory.  If the evaluation of &lt;block1&gt; results in the value true, answer true and do not evaluate any further potential base path prefixes.  If the evaluation of &lt;block1&gt; results in the value false, then proceed to evaluate the next potential base path prefix (in precedence order).  If there are no further potential base path prefixes, then answer false."	"{Transcript cr.	ChronosSystemFacade current findValidResourcePathPrefix: [:resourcePathPrefixString | Transcript cr; show: resourcePathPrefixString. false]}"	| rp |	(super findValidResourcePathPrefix: block1) ifTrue: [^true].	rp := EnvironmentFacade current resourcePathToImageDirectory.	(rp isCurrentDirectory or: [rp = ResourcePath defaultDirectory or: [rp exists not]]) ifFalse: [(block1 value: rp printString) ifTrue: [^true]].	rp := EnvironmentFacade current resourcePathToVWDirectory.	rp == nil 		ifFalse: [rp exists ifTrue: [(block1 value: rp printString) ifTrue: [^true]]].	^false</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>instance creation</category><body package="Chronos-System-VW" selector="findOrCreateChronosLocaleAt:">findOrCreateChronosLocaleAt: isoStandardLocaleKey	"Answer a ChronosLocale initialized to provide locale behavior that is correct for the language and country indicated by &lt;isoStandardLocaleKey&gt;.  	If the information necessary to provide/construct the ChronosLocale as requested is not available, answer a ChronosLocale whose behavior will match that of the one requested as closely as possible.  In the worst case, just answer a ChronosLocale configured with whatever locale information is readily available and most appropriate.	The &lt;isoStandardLocaleKey&gt; is a Symbol, whose content is structured as an ISO-639 language code, contingently followed by an underscore character and ISO-3166 country code. The country code is mandatory in cases where the language code is not sufficient to fully specify the appropriate behavior of a locale (e.g., US vs. British notational conventions.) Using the country code is recommended.	Some common locale keys:		United States: 	#en_US		Note: Not everyone lives in the United States, and notational conventions in the US sometimes differ considerably from international norms.		Great Britain:	#en_GB 	Note: 'UK' is not the ISO country code for Great Britain/The United Kingdom		Spain:			#es_ES		Note: Notational conventions may differ in Spanish-speaking countries outside of Spain		France: 		#fr_FR		Note: Notational conventions may differ in French-speaking countries outside of France		Germany:		#de_DE		Italy:			#it_IT		Japan:			#jp_JP	There are three suggested approaches to subimplement this method, for those interested in actually dealing with locales in a serious manner:		1) Create a ConfigurableChronosLocale, initialize it from whatever data source is preferred (perhaps user-managed flat files, or non-Chronos Locale objects,) and answer the newly created/initialized ConfigurableChronosLocale;		2) Define a class (perhaps named 'ChronosLocaleAdapterForWindows' or 'ChronosLocaleAdapterForSTX') whose public API is that of a ChronosLocale, but which acts as an adapter or mediator (see the canonical 'Gang of Four' Design Patterns book.) The 'ChronosLocaleAdapter' (or whatever name is chosen) would delegate service requests made using the API of a ChronosLocale to native locale objects or library calls, using whatever API they require (such objects and/or services might be provided by the native Smalltalk execution environment, by the host operating system, by proprietary classes or utility libraries, or by some combination thereof).  The implementation of this method would then be to create an instance of such a locale adapter configured to provide locale behavior appropriate for the requested locale;		3) Combine approach 1 with appoach 2, using a locale adapter to initialize an instance of ConfigurableChronosLocale (which may or may not be preferrable to approach 2 by itself, depending on a variety of factors.)"	| isoStandardLocaleKeySymbol vwLocale properNames abbreviations characters miniFormatMap notationalPolicies timePolicy index value |	isoStandardLocaleKeySymbol :=  isoStandardLocaleKey asSymbol.	vwLocale := Locale named: (self baseSytemLocaleKeyFromChronosLocaleKey: isoStandardLocaleKeySymbol).	properNames := Dictionary new.	index := 0.	timePolicy := vwLocale timePolicy.	timePolicy longMonthNames do: 		[:monthName | properNames at: (ISOMonthKeys at: (index := index + 1)) put: monthName asSymbol].	index := timePolicy class instVarIndexFor: 'longWeekdays'. "No other way except to modify VW code--which is forbidden in the portable development version of Chronos (there are better ways to do this when 'porting' Chronos to its VisualWorks native non-development version.)"	value := timePolicy instVarAt: index.	index := 0.	value do: [:weekdayName | properNames at: (ISODayOfWeekKeys at: (index := index + 1)) put: weekdayName asSymbol].	index := timePolicy class instVarIndexFor: 'longAmPm'. "No other way except to modify VW code--which is forbidden in the portable development version of Chronos (there are better ways to do this when 'porting' Chronos to its VisualWorks native non-development version.)"	value := timePolicy instVarAt: index.	index := 0.	value do: [:meridianName | properNames at: (MeridianKeys at: (index := index + 1)) put: meridianName asSymbol].	abbreviations := Dictionary new.	index := 0.	timePolicy shortMonthNames do: 		[:monthName | abbreviations at: (ISOMonthKeys at: (index := index + 1)) put: monthName asSymbol].	index := timePolicy class instVarIndexFor: 'shortWeekdays'. "No other way except to modify VW code--which is forbidden in the portable development version of Chronos (there are better ways to do this when 'porting' Chronos to its VisualWorks native non-development version.)"	value := timePolicy instVarAt: index.	index := 0.	value do: [:weekdayName | abbreviations at: (ISODayOfWeekKeys at: (index := index + 1)) put: weekdayName asSymbol].	index := timePolicy class instVarIndexFor: 'shortAmPm'. "No other way except to modify VW code--which is forbidden in the portable development version of Chronos (there are better ways to do this when 'porting' Chronos to its VisualWorks native non-development version.)"	value := timePolicy instVarAt: index.	index := 0.	value do: [:meridianName | abbreviations at: (MeridianKeys at: (index := index + 1)) put: meridianName asSymbol].	characters := Dictionary new.	characters 		at: #decimalPoint put: vwLocale numberPolicy decimalPoint;		at: #thousandsSeparator put: vwLocale numberPolicy thousandsSeparator;		"There's no reliable/reasonable way to extract the currency symbol--and since Chronos doesn't need it, we'll just have to do without it."		at: #yearMonthSeparator put: $ ; "covers either year/month or month/year"		at: #monthDayOfMonthSeparator put: $ ; "covers either month/dayOfMonth or dayOfMonth/month"		at: #dayOfMonthYearSeparator put: ', '; "covers either dayOfMonth/year or year/dayOfMonth"		at: #yearPad put: $0; "pad character for year--nil means don't pad"		at: #monthPad put: $0; "pad character for month--nil means don't pad"		at: #dayOfMonthPad put: $0; "pad character for dayOfMonth--nil means don't pad" 		"Note: dayOfYear is always zero-padded; DaysSinceEpoch and Julian Day Numbers are never padded."		at: #dateAndTimeSeparator put: $ ;		at: #timeOfDayPrefix: put: nil;		at: #hourMinuteSecondSeparator put: timePolicy timeSeparator;		at: #hourPad put: nil; "pad character for hour (nil means don't pad)--minute and second fields always zero-padded"		at: #durationElementSeparator put: $:;		at: #calendarDurationElementSeparator put: $ ;		at: #durationPad put: $0; "pad character for all scientific (ANSI) durations (nil means don't pad)"		at: #calendarDurationPad put: nil; "pad character for calendar (ISO) durations (nil means don't pad)"		at: #durationDayHourSeparator put: $T;		at: #calendarDurationDayHourSeparator put: $T.	miniFormatMap := Dictionary new.	miniFormatMap 		at: #dmy put: #useDayMonthYearOrder; 	"Internationally the most common format"		at: #mdy put: #useMonthDayYearOrder;	"United States"		at: #ymd put: #useYearMonthDayOrder;	"ISO format--becoming popular, especially outside the US"		at: #ydm put: #useYearDayMonthOrder.	"Supported--although I don't know of anyplace that normally uses it."		"Assumption: No one puts the year in the middle!"	notationalPolicies := Dictionary new.	notationalPolicies		at: #datePolicy put: (miniFormatMap at: timePolicy dateMiniFormat);		"Other than the YMD order, the best we can do is configure the locale to minimize the possibility of confusion."		at: #monthPolicy put: #useMonthAbbreviation;		at: #yearPolicy put: #useFullDigitYears;		at: #dayOfWeekPolicy put: #hideDayOfWeek;		at: #eraPolicy put: #hideEraName;		at: #timeOfDayPolicy put: #showTimeOfDay;		at: #hourPolicy put: #use12HourFormat;		at: #timeOfDaySubsecondPolicy put: #hideSubsecondFraction;		at: #timeZonePolicy put: #showTimeZoneOffset; "We don't have the abbreviation information--and the TZ name is in Latin characters."		at: #durationElementNamePolicy put: #showNamesOfDurationElements;				at: #calendarDurationElementNamePolicy put: #hideNamesOfDurationElements; "We don't have the names."			at: #durationElementZeroValuePolicy put: #hideZeroValuedDurationElements;		at: #calendarDurationElementZeroValuePolicy put: #hideZeroValuedCalendarDurationElements.	^ConfigurableChronosLocale new		setDelegate: ChronosLocale root;		setKey: isoStandardLocaleKey;		setProperNames: properNames;		setAbbreviations: abbreviations;		setCharacters: characters;		setNotationalPolicies: notationalPolicies;		register</body><body package="Chronos-System-VW" selector="newDelayFromDuration:">newDelayFromDuration: aDuration	^Delay forMicroseconds: aDuration asMicroseconds</body><body package="Chronos-System-VW" selector="newSystemClock">newSystemClock	^VWv7xSystemClock new</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>queries</category><body package="Chronos-System-VW" selector="rfc868SecondsSince1900">rfc868SecondsSince1900	"Answer the number of seconds since 1900-01-01T00:00:00 UTC [Gregorian], using the network time service defined by RFC-868.  Purpose: To enable retrieving the current time in situations where a) there is no local clock available, or b) there is reason to believe the local clock may not be correctly set, or may not keep time with sufficient accuracy. Note: Asking for and receiving back the current time over the internet would typically require on the order of 200 milliseconds--so obtaining the current time over the internet should only be done infrequently (once per minute at most.)  Applications with extreme current-time accuracy requirements should configure the host platform to use a local NTP time server that uses the NTP standard to keep the local clock accurate to within nanosecond tolerances (the NTP standard is NOT the same as the one defined in RFC-868.)"	"{DateAndTimeFactory 		utSecondsSinceEpoch: 			((Calendar gregorian secondsSinceEpochUpToYear: 1900) 			+ ChronosSystemFacade current rfc868SecondsSince1900)		timeZone: Timezone default}"	| socket address buffer replySize |	"Create a datagram socket."	socket := SocketAccessor newUDP.	"The following is kept in an unwind block in case an exception is raised."	["Bind the socket to the server's address."	address := IPSocketAddress hostName: self timeServerHostName port: 37.	socket connectTo: address.	"Any message will trigger the time server."	socket writeAll: 'T'.	"Initialize the buffer for a 4-byte response."	buffer := ByteArray new: 4.	"Get the raw time from the server -- timeout after 15 seconds."	(socket readWaitWithTimeoutMs: 15000) 		ifFalse: [replySize := socket readInto: buffer]		ifTrue: [self signal: Error message: 'NTS: Timeout after 15 seconds.']] 			ensure: [socket close].	^replySize = 4 		ifTrue: 			["Convert the byte array to an integer (seconds since 1900)."			(UninterpretedBytes from: buffer) unsignedLongAt: 1 bigEndian: true]		ifFalse: 			[replySize = 0 				ifTrue: [self signal: Error message: 'NTS: No response']				ifFalse: [self signal: Error message: 'NTS: Invalid reply format']]</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>testing</category><body package="Chronos-System-VW" selector="isOSTimeZoneInstalled">isOSTimeZoneInstalled	^EnvironmentFacade current isDLLCCInstalled and: [OSSystemSupport respondsTo: #hasOSTimeSupport]</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>services/utilities</category><body package="Chronos-System-VW" selector="generateVWTimeZoneRepository">generateVWTimeZoneRepository	"For each time zone ruleset in the Chronos time zone repository, construct a Core.TimeZone instance that represents this year's annual ruleset for that time zone and ask it to store itself into the VisualWorks TimeZone repository.  Fail if the code for storing TimeZone instances into the VW TimeZone repository is not present in the image."	"ChronosSystemFacade current generateVWTimeZoneRepository"	ChronosTimezone allRegisteredKeys do: 			[:tzKey | 			(TimeZone new)				key: tzKey;				initializeFromTimeZonePolicyFactory: 					(TimeZonePolicyFactory 							at: tzKey asSymbol							ifAbsent: ["Just let the MNU happen"]);				storeInRepository]</body><body package="Chronos-System-VW" selector="userNotify:">userNotify: aMessage	"Notify the user of an event by displaying or logging the text of &lt;aMessage&gt;"	Dialog warn: 'Chronos Notification: ', aMessage</body></methods><methods><class-id>Chronos.VWSystemFacade</class-id> <category>private-queries</category><body package="Chronos-System-VW" selector="windowsTimeZoneAttributes">windowsTimeZoneAttributes	"If on Windows, answer the attributes (as a Dictionary with well-known keys) of the current user's Windows timezone ruleset as specified in the Windows Registry.  Answer nil if not on Windows, or if this operation is not currently supported."	"{ChronosSystemFacade current windowsTimeZoneAttributes}"	"The well-known keys used by Chronos to identify the attributes of a Windows timezone ruleset specification, and the value that should be associated with each key:				Key								Semantics and Smalltalk type of associated value that should be returned by this method (as values in a Dictionary)		#BaseOffsetSecondsFromUT	-&gt;	&lt;Integer&gt; base number of seconds that should be ADDED to the Universal time-of-day to derive local time-of-day during STANDARD TIME.		#StandardName					-&gt;	&lt;String&gt; whose value is Window's canonical name for the timezone.		#StandardBias					-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the &lt;BaseOffsetSecondsFromUT&gt; during standard time (usually zero).			-- The following entries should not be present if the timezone does not observe DST: 		#StandardDate					-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `standard` time--or not present if there is no transition to standard time.		#StandardTimeOfDay			-&gt; 	&lt;TimeOfDay&gt; at which the timezone transitions to `standard` time (always local 'wall-clock' time)--or not present if there is no transition to standard time.		#DaylightName					-&gt;	&lt;String&gt; whose value is Window's name for the timezone when DST is in effect.		#DaylightBias					-&gt;	&lt;Integer&gt; number of seconds that should be ADDED to the &lt;BaseOffsetSecondsFromUT&gt; during 'daylight-saving/summer' time.		#DaylightDate					-&gt;	&lt;AnnualDate&gt; on which the timezone transitions to `daylight-saving/summer` time.		#DaylightTimeOfDay			-&gt; &lt;TimeOfDay&gt; at which the timezone transitions to `daylight-saving/summer` time (always local 'wall-clock' time.).	The standard time offset from UT will be computed as &lt;BaseOffsetSecondsFromUT&gt; + &lt;StandardBias&gt;; the DST offset from UT will be computed as &lt;BaseOffsetSecondsFromUT&gt; + &lt;DaylightBias&gt;.	Windows timezone attributes are natively represented in a 'struct' defined as follows (a 'WCHAR' is defined as 'unsigned short'):		struct _TIME_ZONE_INFORMATION {			LONG Bias;									// Number of minutes to ADD to local standard time to derive universal time (inverse polarity of standard practice.)			WCHAR StandardName[32];				// Windows canonical timezone name--used as lookup key.			SYSTEMTIME StandardDate;				// Annual date and time of transition to Standard Time--see below.			LONG StandardBias;						// Number of minutes to ADD to &lt;Bias&gt; during Standard Time.			WCHAR DaylightName[32];				// Windows name of timezone during Daylight-Saving/Summer Time.			SYSTEMTIME DaylightDate;				// Annual date and time of transition to Daylight-Saving/Summer Time--see below.			LONG DaylightBias;						// Number of minutes to ADD to &lt;Bias&gt; during Daylight-Saving/Summer Time.		}	The SYSTEMTIME struct type is defined as follows (a 'WORD' is defined as 'unsigned short'):		typedef struct SYSTEMTIME { 			WORD wYear;			WORD wMonth;			WORD wDayOfWeek;			WORD wDay;			WORD wHour;			WORD wMinute;			WORD wSecond;			WORD wMilliseconds;		}	In a Windows timezone ruleset (as opposed to its usage elsewhere,) the members (fields, slots) of a SYSTEMTIME value have the following function/semantics:		Member/Field/Slot Name			Function/Role/Semantics				wYear									Not used		wMonth								Ordinal of the month in which a transition to/from DST occurs (1=January, 12=December); 													if the value is zero, then the struct represents a 'not a date' value, which means no transition.		wDayOfWeek						Cardinal number of the day of the week on which a transition to/from DST occurs (0=Sunday; 7=Saturday.)		wDay									Ordinal of the week of the month in which a transition to/from DST occurs; 													1 means the first week, 4 means the fouth week, 													but 5 means the last week of the month.		wHour									Cardinal number of the hour of the day when a transition to/from DST occurs (0-23.)		wMinute								Cardinal number of the minute of the hour of the day when a transition to/from DST occurs (0-59.)		wSecond								Cardinal number of the second of the minute of the hour of the day when a transition to/from DST occurs (0-59.)		wMilliseconds						Not used."	^(self isOSTimeZoneInstalled and: [EnvironmentFacade current isOnWindows])		ifTrue: 			[| sysClass sys |			sysClass := OSSystemSupport concreteClass.			sysClass hasOSTimeSupport				ifTrue: 					[| errorFlag result tzInfoStruct attributesMap annualDateFromSystemTimeStruct timeOfDayFromSystemTimeStruct standardDateAndTime dstDateAndTime dstAnnualDate |					annualDateFromSystemTimeStruct := 						[:systemTimeStruct | 							| month weekOfMonth |							month := systemTimeStruct memberAt: #wMonth.							month &gt; 0								ifTrue: 									[weekOfMonth := systemTimeStruct memberAt: #wDay.									WeekOfMonthDayOfWeekFactory										month: month 										week: (weekOfMonth = 5 ifTrue: [0] ifFalse: [weekOfMonth])  										dayOfWeek: (systemTimeStruct memberAt: #wDayOfWeek) + 1]].					timeOfDayFromSystemTimeStruct := 						[:systemTimeStruct | 							TimeOfDayFactory								hour: (systemTimeStruct memberAt: #wHour)								minute: (systemTimeStruct memberAt: #wMinute)								second: (systemTimeStruct memberAt: #wSecond)].					sys := sysClass new.					errorFlag := Object new.					result := 	[tzInfoStruct := sys _TIME_ZONE_INFORMATION gcMalloc.								tzInfoStruct zeroFill.								sys GetTimeZoneInformation: tzInfoStruct]									on: Error 									do: [:ex | self reportFailureOfWindowsTimeZoneAttributesRetrieval: ex. ex return: errorFlag].					result == errorFlag ifTrue: [^nil].					standardDateAndTime := tzInfoStruct memberAt: #StandardDate.					attributesMap := Dictionary new.					attributesMap						at: #BaseOffsetSecondsFromUT put: (tzInfoStruct memberAt: #Bias) negated * SecondsPerMinute;						at: #StandardName put: (tzInfoStruct memberAt: #StandardName) copyUnicodeStringFromHeap;						at: #StandardBias put: (tzInfoStruct memberAt: #StandardBias) negated * SecondsPerMinute;						at: #StandardDate put: (annualDateFromSystemTimeStruct value: standardDateAndTime);						at: #StandardTimeOfDay put: (timeOfDayFromSystemTimeStruct value: standardDateAndTime).					dstDateAndTime := tzInfoStruct memberAt: #DaylightDate.					dstAnnualDate := annualDateFromSystemTimeStruct value: dstDateAndTime.					dstAnnualDate == nil						ifFalse:							[dstDateAndTime := tzInfoStruct memberAt: #DaylightDate.							attributesMap								at: #DaylightName put: (tzInfoStruct memberAt: #DaylightName) copyUnicodeStringFromHeap;								at: #DaylightBias put: (tzInfoStruct memberAt: #DaylightBias) negated * SecondsPerMinute;								at: #DaylightDate put: dstAnnualDate;								at: #DaylightTimeOfDay put: (timeOfDayFromSystemTimeStruct value: dstDateAndTime)].					attributesMap]]</body></methods><methods><class-id>Chronos.VWSystemFacade class</class-id> <category>class initialization</category><body package="Chronos-System-VW" selector="removeFromSystem">removeFromSystem	"Forget the receiver, and all of its subclasses, from the receiver's Namespace. Any existing instances will refer to an obsolete version of the receiver."	self release.	super removeFromSystem</body><body package="Chronos-System-VW" selector="removeFromSystem:">removeFromSystem: loggingLevel		"Forget the receiver, and all of its subclasses, from the receiver's Namespace. Any existing instances will refer to an obsolete version of the receiver."	self release.	super removeFromSystem: loggingLevel</body></methods><methods><class-id>Passport.ClassicVWEnvironmentFacade class</class-id> <category>queries</category><body package="Passport-Kernel-VW" selector="isDLLCCInstalled">isDLLCCInstalled	^Smalltalk includesKey: #CParser</body><body package="Passport-Kernel-VW" selector="isOnMac">isOnMac	^OSHandle currentOS = #mac</body><body package="Passport-Kernel-VW" selector="isOnOS2">isOnOS2	^OSHandle currentOS = #os2</body><body package="Passport-Kernel-VW" selector="isOnUnix">isOnUnix	^OSHandle currentOS = #unix</body><body package="Passport-Kernel-VW" selector="isOnWindows">isOnWindows	^'win*' match: OSHandle currentOS</body><body package="Passport-Kernel-VW" selector="resourcePathToImageDirectory">resourcePathToImageDirectory	"Answer a ResoucePath to the directory that contains the VisualWorks image."	"{EnvironmentFacade current resourcePathToImageDirectory}"	^ResourcePath fromString:  Filename defaultDirectory</body><body package="Passport-Kernel-VW" selector="resourcePathToVWDirectory">resourcePathToVWDirectory	"Answer a ResoucePath to the VisualWorks directory. Answer nil if it's not defined."	"{EnvironmentFacade current resourcePathToVWDirectory}"	| fn |	fn := SourceFileManager default nameAt: SourceFileManager default sourcesIndex.	^fn == nil 		ifFalse: [(ResourcePath fromString: fn asString) prefix]</body><body package="Passport-Kernel-VW" selector="valueOfEnvironmentVariableAt:">valueOfEnvironmentVariableAt: envVarKey	"Answer the value of the environment variable whose key (name) is &lt;envVarKey&gt;. If the host system does not support environment variables, then answer nil."	^CEnvironment getenv: envVarKey</body></methods><methods><class-id>Passport.ClassicVWEnvironmentFacade class</class-id> <category>system operations</category><body package="Passport-Kernel-VW" selector="performGarbageCollection">performGarbageCollection	^ObjectMemory globalGarbageCollect</body></methods><methods><class-id>Passport.ClassicVWEnvironmentFacade class</class-id> <category>accessing</category><body package="Passport-Kernel-VW" selector="key">key	^#VisualWorks</body><body package="Passport-Kernel-VW" selector="versionNumber">versionNumber	^ObjectMemory versionId at: 5</body></methods><methods><class-id>Passport.ClassicVWEnvironmentFacade class</class-id> <category>class binding</category><body package="Passport-Kernel-VW" selector="nativeScaledDecimalClass">nativeScaledDecimalClass	"Anser the class that implements the ANSI-Smallltalk &lt;ScaledDecimal&gt; protocol in the native Smalltalk environment.  Answer nil if none."	^FixedPoint</body></methods><methods><class-id>Passport.ClassicVWEnvironmentFacade class</class-id> <category>namespace operations</category><body package="Passport-Kernel-VW" selector="purgeUnusedBindingsFromUndeclaredNamespace">purgeUnusedBindingsFromUndeclaredNamespace	"Remove any bindings (associations) from the Undeclared namespace (Dictionary) for which there are no active references in the system codebase."	| array |	array := WeakArray withAll: Undeclared associations.	array do: [:each | Undeclared removeKey: each key].	ObjectMemory verboseGlobalCompactingGC.	array do: [:each | each == 0 ifFalse: [Undeclared add: each]].	Symbol initialize.	" &lt;- This clears all unreferenced Symbols"</body></methods><methods><class-id>Passport.ClassicVWEnvironmentFacade class</class-id> <category>private</category><body package="Passport-Kernel-VW" selector="basicCancelImageRestartNotificationSubscriptionFor:">basicCancelImageRestartNotificationSubscriptionFor: subscriber	(ObjectMemory respondsTo: #retractAllInterestsFor:) 		ifTrue: [ObjectMemory retractAllInterestsFor: subscriber]		ifFalse: [ObjectMemory retractInterestIn: #returnFromSnapshot for: subscriber]</body><body package="Passport-Kernel-VW" selector="basicRegisterForStartupNotification">basicRegisterForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver will be sent the message #handleRestart.	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	self basicUnregisterForStartupNotification.	ObjectMemory expressInterestIn: #returnFromSnapshot for: self sendBack: #handleRestart.</body><body package="Passport-Kernel-VW" selector="basicSignal:message:contextName:">basicSignal: anExceptionFactory message: message contextName: contextName	"Using &lt;anExceptionFactory&gt;, raise an exception with the given &lt;message&gt;"	| stream |	stream := (String new: 12) writeStream.	stream		nextPut: ${;		nextPutAll: contextName;		nextPutAll: '} ';		nextPutAll: message.	^anExceptionFactory raiseSignal: stream contents</body><body package="Passport-Kernel-VW" selector="basicSubscribe:forImageRestartNotificationSending:">basicSubscribe: subscriber forImageRestartNotificationSending: restartNotificationMessage 	ObjectMemory expressInterestIn: #returnFromSnapshot for: subscriber sendBack: restartNotificationMessage.</body><body package="Passport-Kernel-VW" selector="basicUnregisterForStartupNotification">basicUnregisterForStartupNotification	"Make it so that whenever the Smalltalk image is restarted after a snapshot, the receiver will NOT be sent the message #install (nor otherwise notified.)	NOTE: This method is intended for use by image-based Smalltalk implementations.  It may or may not have any utility in the case of non-image-based Smalltalk systems."	(ObjectMemory respondsTo: #retractAllInterestsFor:) 		ifTrue: [ObjectMemory retractAllInterestsFor: self]		ifFalse: [ObjectMemory retractInterestIn: #returnFromSnapshot for: self]</body><body package="Passport-Kernel-VW" selector="initializeResourcePathFacadeFactoryReferences">initializeResourcePathFacadeFactoryReferences	"{EnvironmentFacade current initializeResourcePathFacadeFactoryReferences}"	super initializeResourcePathFacadeFactoryReferences.	ResourcePathFacadeFactoryReferences 		at: #platform put: (Pathname components: #(#VWClassicFilenameFacade))</body><body package="Passport-Kernel-VW" selector="setPlatformClass">setPlatformClass	"Set the concrete subclass of the reciever whose implmentation is specific to the current Smalltalk platform and usage context."	"This version of the method is VisualsWorks-specific. If you're porting Passport from VisualWorks to some other Smalltalk platform, this method must be rewritten so that it sets PlatformClass to be the correct subclass of EnvironmentFacade for the particular version of the Smalltalk environment/platform into which Passport finds itself being loaded when this method is invoked.  The code to figure out which version of Squeak, or of Dolphin, or or VAST, or of ST/X (etc) on which the code is running is of course specific to each Smalltalk flavor.  Also, how many different versions of EnvironmentFacade may be needed in order to handle all the versions of a particular Smalltalk environment, and which specific subclass of EnvironmentFacade is optimal for each version, depends on the platform.  	As the person doing the port, how far into the past you wish to provide support is up to you.  Support for previous (or future) versions can always be added later."	| versionNumber |	versionNumber := self versionNumber.	(versionNumber &gt;= 70 		ifTrue: [VWEnvironmentFacade]		ifFalse: 			[versionNumber &gt;= 50 				ifTrue: [VW5iEnvironmentFacade]				ifFalse: 					[versionNumber &gt;= 30 						ifTrue: [VW3xEnvironmentFacade]						ifFalse: [ClassicVWEnvironmentFacade]]]) 			beCurrent</body></methods><methods><class-id>Passport.ClassicVWEnvironmentFacade class</class-id> <category>class initialization</category><body package="Passport-Kernel-VW" selector="initialize">initialize	"EnvironmentFacade initialize."	self registerForStartupNotification.</body><body package="Passport-Kernel-VW" selector="removeFromSystem">removeFromSystem	"Forget the receiver, and all of its subclasses, from the receiver's Namespace. Any existing instances will refer to an obsolete version of the receiver."	self == self platformClass ifTrue: [self release].	super removeFromSystem</body><body package="Passport-Kernel-VW" selector="removeFromSystem:">removeFromSystem: loggingLevel		"Forget the receiver, and all of its subclasses, from the receiver's Namespace. Any existing instances will refer to an obsolete version of the receiver."	self == self platformClass ifTrue: [self release].	super removeFromSystem: loggingLevel</body></methods><methods><class-id>Passport.VW3xEnvironmentFacade class</class-id> <category>queries</category><body package="Passport-Kernel-VW" selector="resourcePathToVWDirectory">resourcePathToVWDirectory	"Answer a ResoucePath to the VisualWorks directory. Answer nil if it's not defined."	"{EnvironmentFacade current resourcePathToVWDirectory}"	| fn pathString |	fn := LogicalFilename named: '$(VISUALWORKS)'.	pathString := fn asResolvedString.	^(UtilityFunction isNilOrEmpty: pathString) ifFalse: [ResourcePath fromString: pathString]</body></methods><methods><class-id>Passport.VW5iEnvironmentFacade class</class-id> <category>namespace operations</category><body package="Passport-Kernel-VW" selector="addImport:in:private:">addImport: importedNamespacePath in: importingNamespace private: isPrivate	"Cause the &lt;importingNamespace&gt; to 'import' from the namespace whose hierarchical name key is represented (in a syntactically-portable manner) by the pathname-array &lt;importedNamespacePath&gt;. Ideally, this should be done by means of dynamic delegation from &lt;importingNamespace&gt; to the namespace specified by &lt;importedNamespacePath&gt;.  However, if necessary, it may also be achieved by copying the bindings (key-&gt;value associations) from the namespace specified by &lt;importedNamespacePath&gt; into the &lt;importingNamespace&gt;, or even by duplicating the key-&gt;value entries.	The &lt;importedNamespacePath&gt; parameter (representing the hierarchical name key of a namespace) will be an Array of Symbols. The first Symbol will be the name of a namespace accessible from the global namespace (and may even be the name of the global namespace itself.)  Each subsequent Symbol will be the name of a namespace accessible from the previous namespace.  So, if there is a namespace defined in the global namespace named #Chronos, which contains a namespace named #ChronosTemporalRatioConstants, then the hierarchical name key identifing the #ChronosTemporalRatioConstants namespace would be the Array #(Chronos ChronosTemporalRatioConstants). In this way, it is possible to portably specify hierarchical namespace pathnames without knowing or caring about the synatax used for such hierarchical names by the host Smalltalk system."	| pathStream |	pathStream := (String new: 37) writeStream.	importedNamespacePath do: 			[:component | 			pathStream				nextPutAll: component;				nextPut: $.].	pathStream skip: -1.	importingNamespace 		addImport: ((GeneralNameSpaceImport pathString: pathStream contents) private: isPrivate)</body><body package="Passport-Kernel-VW" selector="defineVariable:in:withValue:constant:category:rebindIfPresent:onCollision:">defineVariable: key in: aNamespace withValue: value constant: constant category: category rebindIfPresent: rebindIfPresent onCollision: collisionAction 	"Define a binding (key-&gt;value association) in the namespace &lt;aNamespace&gt; (which may just be a Dictionary,) whose key is &lt;key&gt;, and whose value is &lt;value&gt;.  If &lt;constant&gt; is true (and if constant/immutable bindings are supported by the functionality of &lt;aNamespace&gt;,) make the binding constant (immutable.) If supported by the functionality of &lt;aNamespace&gt;, place the binding in the semantic category &lt;category&gt;.  	If there already exists a binding in &lt;aNamespace&gt; with the given &lt;key&gt;, then:		1) If the value associated with &lt;key&gt; is the same object as &lt;value&gt;, then just answer &lt;value&gt;.  		2) If the value associated with &lt;key&gt; is nil, then:			If there is also a binding in the Undeclared namespace whose key is &lt;key&gt;, set &lt;value&gt; as the value of the binding in the Undeclared namespace, and then move the binding (which might be an Association instance, or else an object that supports Association-like behavior and/or protocol) from the Undeclared namespace to &lt;namespace&gt;. Otherwise, set &lt;value&gt; as the value of the binding already present in &lt;aNamespace&gt;.		3) If the value associated with &lt;key&gt; is neither nil nor the same object as &lt;value&gt;, but if &lt;rebindIfPresent&gt; is true, then remove any binding whose key is &lt;key&gt; from the Undeclared namespace, and reset the value of the binding in &lt;aNamespace&gt; whose key is &lt;key&gt; to the value &lt;value&gt;.		4) If the value associated with &lt;key&gt; is neither nil nor the same object as &lt;value&gt;, and if &lt;rebindIfPresent&gt; is also false, then do not change the value of the existing binding, but instead invoke the zero-argument block &lt;collisionAction&gt; (and answer the result.)"			| presentValue |	presentValue := aNamespace at: key ifAbsent: [self notAValue].	^presentValue == value 		ifTrue: [value]		ifFalse: 			[(rebindIfPresent or: [presentValue == self notAValue or: [presentValue == nil]])				ifTrue: 					[presentValue == self notAValue 						ifTrue: 							[(Undeclared includesKey: key) 								ifTrue: [aNamespace declare: key from: Undeclared]								ifFalse:									[(aNamespace includesKey: key)										ifFalse: 											[aNamespace 												defineStatic: key												private: false												constant: false												category: category												initializer: nil]]]						ifFalse: [Undeclared removeKey: key ifAbsent: []].					(aNamespace bindingFor: key)						beConstant: false;						value: value;						beConstant: constant.					value]				ifFalse: [collisionAction value]]</body><body package="Passport-Kernel-VW" selector="fullyQualifiedNameOfClass:">fullyQualifiedNameOfClass: aClass	"Answer the fully-qualified (usable anywhere) name of &lt;aClass&gt;."	"EnvironmentFacade current  fullyQualifiedNameOfClass: Timepoint"	^aClass fullName asSymbol</body><body package="Passport-Kernel-VW" selector="purgeUnusedBindingsFromUndeclaredNamespace">purgeUnusedBindingsFromUndeclaredNamespace	"Remove any bindings (associations) from the Undeclared namespace (Dictionary) for which there are no active references in the system codebase."	Undeclared purgeUnusedBindings</body><body package="Passport-Kernel-VW" selector="resolveClassFromFullyQualifiedName:ifAbsent:">resolveClassFromFullyQualifiedName: className ifAbsent: ifAbsentBlock 	"Answwer the class whose fully-qualfied (usable anywhere) name is &lt;name&gt;."	"{EnvironmentFacade current 		resolveClassFromFullyQualifiedName: (EnvironmentFacade current fullyQualifiedNameOfClass: Timepoint) 		ifAbsent: []}"	^(Pathname fromString: className separator: $.) valueIfNone: ifAbsentBlock</body></methods><methods><class-id>Passport.VW5iEnvironmentFacade class</class-id> <category>queries</category><body package="Passport-Kernel-VW" selector="isDLLCCInstalled">isDLLCCInstalled	^(Pathname components: #(External CParser)) isDefined</body></methods><methods><class-id>Passport.VW5iEnvironmentFacade class</class-id> <category>private</category><body package="Passport-Kernel-VW" selector="initializeResourcePathFacadeFactoryReferences">initializeResourcePathFacadeFactoryReferences	"{EnvironmentFacade current initializeResourcePathFacadeFactoryReferences}"	super initializeResourcePathFacadeFactoryReferences.	ResourcePathFacadeFactoryReferences 		at: #platform put: (Pathname components: #(#Passport #VWFilenameFacade));		at: #file put: (Pathname components: #(#Passport #VWFileUrlFacade))	;		at: #ftp put: (Pathname components: #(#Passport #VWFtpUrlFacade))	;		at: #http put: (Pathname components: #(#Passport #VWHttpUrlFacade))	;		at: #https put: (Pathname components: #(#Passport #VWHttpsUrlFacade))</body></methods><methods><class-id>Passport.VW5iEnvironmentFacade class</class-id> <category>character constants</category><body package="Passport-Kernel-VW" selector="euroCurrencyCharIfNone:">euroCurrencyCharIfNone: ifNone	"Answer the Character value that represents the symbol for the Euro currency.  If the Smalltalk execution environment does not support such a character value, then answer the result of evaluating the &lt;ifNone&gt; block."		^$€</body></methods><methods><class-id>Chronos.EffectiveYearTemporalRule</class-id> <category>initialize-release</category><body package="Chronos-Foundation" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setRightLink: (literalArray at: 2) decodeAsLiteralArray	;		setEffectiveYear: (literalArray at: 3)</body><body package="Chronos-Foundation" selector="setEffectiveYear:">setEffectiveYear: aYear	self assertMutability.	effectiveYear := aYear</body><body package="Chronos-Foundation" selector="setRightLink:">setRightLink: aTemporalRule	"Set &lt;aTemporalRule&gt; as the next rule `to the right` in the receiver's chain of  TemporalRules."	self assertMutability.	rightLink := aTemporalRule.	super setRightLink: aTemporalRule.</body></methods><methods><class-id>Chronos.EffectiveYearTemporalRule</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="effectiveYear">effectiveYear	"Answer the year in which the rule represented by the receiver comes into in effect."	^effectiveYear</body><body package="Chronos-Foundation" selector="rightLink">rightLink	"Answer the next rule `to the right` in the receiver's rule chain, if there is one.  If there is not, answer nil."	^rightLink</body><body package="Chronos-Foundation" selector="rightLinkIfNone:">rightLinkIfNone: block0	"Answer the next rule `to the right` in the receiver's rule chain, if there is one.  If there is not, answer the result of evaluating &lt;block0&gt;."	^rightLink == nil		ifTrue: [block0 value]		ifFalse: [rightLink]</body></methods><methods><class-id>Chronos.EffectiveYearTemporalRule</class-id> <category>comparing</category><body package="Chronos-Foundation" selector="compareEffectiveYearTo:">compareEffectiveYearTo: aYear	"Answer a strictly positive integer if the receiver's effectiveYear is greater than the argument; answer 0 if equal; and answer a negative integer if less."	effectiveYear = aYear ifTrue: [^0].	^effectiveYear == nil 		ifTrue: [-1]		ifFalse: 			[aYear == nil 				ifTrue: [1]				ifFalse: [effectiveYear - aYear]]</body><body package="Chronos-Foundation" selector="compareTo:">compareTo: aTemporalRule	"Answer a strictly positive integer if the receiver's transition time is greater than that of the argument; answer 0 if equal; and answer a negative integer if less."	^self compareEffectiveYearTo: aTemporalRule effectiveYear</body><body package="Chronos-Foundation" selector="hash">hash	^effectiveYear hash</body></methods><methods><class-id>Chronos.EffectiveYearTemporalRule</class-id> <category>testing</category><body package="Chronos-Foundation" selector="hasRightwardLink">hasRightwardLink	"Answer whether there is anonther rule after the receiver in the receiver's rightward rule chain."	^rightLink notNil</body><body package="Chronos-Foundation" selector="isAlwaysInEffect">isAlwaysInEffect	"Answer whether thre rule represented by the receiver is always in effect."	^self isAtom and: [effectiveYear == nil]</body></methods><methods><class-id>Chronos.EffectiveYearTemporalRule</class-id> <category>enumerating</category><body package="Chronos-Foundation" selector="withRightLinkDo:">withRightLinkDo: block1	"Evaluatue &lt;block1&gt; with the next rightward link in the receiver's rule chain as the argument.  If there is no such link, do nothing."	^rightLink == nil ifFalse: [block1 value: rightLink]</body></methods><methods><class-id>Chronos.EffectiveYearTemporalRule</class-id> <category>private</category><body package="Chronos-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: rightLink literalArrayEncoding;		nextPut: effectiveYear</body></methods><methods><class-id>Chronos.EffectiveYearTemporalRule</class-id> <category>queries</category><body package="Chronos-Foundation" selector="effectiveRuleInYear:ifNone:">effectiveRuleInYear: aYear ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective in &lt;aYear&gt;.  If none, answer the result of evaluating &lt;ifNone&gt;."	^(self compareEffectiveYearTo: aYear) &gt; 0 		ifTrue: 			[(self rightLinkIfNone: [^ifNone value]) 				searchRightwardForEffectiveRuleInYear: aYear				ifNone: ifNone]		ifFalse: 			[(self leftLinkIfNone: [^self]) 				searchLeftwardForEffectiveRuleInYear: aYear				ifNone: [self]]</body><body package="Chronos-Foundation" selector="searchLeftwardForEffectiveRuleInYear:ifNone:">searchLeftwardForEffectiveRuleInYear: aYear ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective in &lt;aYear&gt;--but searching only leftward.  If none, answer the result of evaluating &lt;ifNone&gt;."	| diff |	diff := self compareEffectiveYearTo: aYear.	^diff &gt; 0 		ifTrue: [ifNone value]		ifFalse: 			[diff = 0 ifTrue: [^self].			(self leftLinkIfNone: [^self]) 				searchLeftwardForEffectiveRuleInYear: aYear				ifNone: [self]]</body><body package="Chronos-Foundation" selector="searchRightwardForEffectiveRuleInYear:ifNone:">searchRightwardForEffectiveRuleInYear: aYear ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective in &lt;aYear&gt;--but searching only rightward.  If none, answer the result of evaluating &lt;ifNone&gt;."	^(self compareEffectiveYearTo: aYear) &lt;= 0 		ifTrue: [self]		ifFalse: 			[(self rightLinkIfNone: [^ifNone value]) 				searchRightwardForEffectiveRuleInYear: aYear				ifNone: ifNone]</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	super canonicalize.	annualPolicy beImmutable</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="initialize">initialize	super initialize.	effectiveYearCalendar := Gregorian.	effectiveYearRelativity := #nominal.</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self 		setAnnualPolicy: (literalArray at: 4) decodeAsLiteralArray</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="release">release	super release.	annualPolicy release.</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setAnnualPolicy:">setAnnualPolicy: anAnnualPolicy	"Set the receiver's AnnuallyRecurringTZPolicy. CONSTRAINT: The &lt;rootTZ&gt; of the 'bound, dynamic' time zone associated with &lt;anAnnualPolicy&gt; must be the same Chronos `unbound, dynamic` time zone for which the receiver will serve as a TimeZonePolicy. Fail if the receiver is not mutable."	self assertMutability.	annualPolicy := anAnnualPolicy</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setDefaultName:">setDefaultName: aString	self assertMutability.	defaultName := aString</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setEffectiveYearCalendar:">setEffectiveYearCalendar: aCalendarRef	self assertMutability.	effectiveYearCalendar := Calendar referencedBy: aCalendarRef</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setEffectiveYearRelativity:">setEffectiveYearRelativity: aSymbol	self assertMutability.	effectiveYearRelativity := aSymbol</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setGeographicCoordinates:">setGeographicCoordinates: aGeographicCoordinatesSpect	self assertMutability.	geographicCoordinates := aGeographicCoordinatesSpect</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setLeftLink:">setLeftLink: aTimeZonePolicy	"Set &lt;aTimeZonePolicy&gt; as the leftward link in the receiver's chain of TimeZonePolicies."	self assertMutability.	leftLink := aTimeZonePolicy.</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setRegistrationKey:">setRegistrationKey: aSymbol	self assertMutability.	registrationKey := aSymbol</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="setRootTZ:">setRootTZ: anUnboundDynamicTimeZone	"Set &lt;anUnboundDynamicTimeZone&gt; as the receiver's root time zone."	self assertMutability.	rootTZ := anUnboundDynamicTimeZone.</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>testing</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="hasLeftwardLink">hasLeftwardLink	"Answer whether there is anonther rule after the receiver in the receiver's leftward rule chain."	^leftLink notNil</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isBound">isBound	"Answer whether the receiver is a bound time zone. A bound time zone is one that defines a single offset/abbreviation tuple, and that conforms to the `BOUND TIMEZONE API` (as defined in the class comment of ChronosTimezone.)"	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer whether a Timepoint whose time zone is the receiver will exhibit invariance to nominal time."	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isInvariantToUT">isInvariantToUT	^true</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isProxy">isProxy	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isProxyAndInvariantToUT">isProxyAndInvariantToUT	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isProxyOrStatic">isProxyOrStatic	"Answer whether the receiver is either a proxy time zone or a static time zone."	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isStatic">isStatic	"Answer whether or not the timezone policy (key, offset, name and abbreviation) of the timezone represented by the receiver is invariant, constant and never subject to change or revision.  If the receiver's timezone policy is dynamically redefinable, answer false."	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isSymmetric">isSymmetric	"Aswer true if the receiver is an instance of AsymmetricTimeZonePolicy, false otherwise.  See the class comment of AsymmetricTimeZonePolicy for an explanation of the difference."	^true</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isTimezone">isTimezone	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="isUniversalTime">isUniversalTime	"Anwser whether the receiver has all the properties and behaviors of the international reference zero-offset time zone."	^false</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^annualPolicy specifiesCommonAbbreviation or: [rightLink notNil and: [rightLink specifiesCommonAbbreviation]]</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="specifiesDefaultName">specifiesDefaultName	^defaultName ~~ nil</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="specifiesGeographicCoordinates">specifiesGeographicCoordinates	^geographicCoordinates ~~ nil</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>converting</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="asAnnualTransitionPolicyFactory">asAnnualTransitionPolicyFactory	"Answer the TimeZoneAnnualTransitionPolicyFactory that would serve as a factory to recreate a single instance of the receiver's class with the same value as the receiver (ignoring any predecessors.)"	| factory |	factory := 		(TimeZoneAnnualTransitionPolicyFactory new)			setEffectiveYear: self effectiveYear;			setEffectiveYearCalendarKey: self effectiveYearCalendarKey;			setEffectiveYearRelativity: effectiveYearRelativity;			setAnnuallyRecurringTransitions: self annualPolicy asAnnuallyRecurringTZPolicyFactoryArray.	self isSymmetric ifFalse: [factory setAsNonSymmetric].	^factory</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="asChronosValue">asChronosValue	"Answer the translation of the receiver into an object that is an instance of whichever class in the Chronos Date/Time Library would be most appropriate for the instantiation of an object equal and/or analogous to the receiver ."	^self</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="asNonProxy">asNonProxy	"Answer the time zone to which the receiver indirectly refers by proxy.  If the receiver is not a proxy for a time zone other than itself, answer the receiver."	^self</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="asPolicyFactory">asPolicyFactory	"Answer the TimeZonePolicyFactory that would serve as a factory to recreate an instance of the receiver's class with the same value as the receiver."	| elementFactoryStream |	elementFactoryStream := Array new writeStream.	self withSelfAndAllRightwardLinksDo: [:policy | elementFactoryStream nextPut: policy asAnnualTransitionPolicyFactory].	^TimeZonePolicyFactory 		key: self key		defaultName: self defaultName 		geographicCoordinates: self geographicCoordinates		annualTransitionPolicyArray: elementFactoryStream contents</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="asTimezone">asTimezone	"Answer the conversion of the receiver into a time zone it either references or describes. If the receiver is itself a time zone, answer the receiver."	^rootTZ</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="asUnbound">asUnbound	"Answer the unbound time zone that specifies the full diachronic ruleset of the time zone represented by the receiver."	^self</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="canonical">canonical	"Answer the canonical instance of the receiver's root time zone."	^self root canonical</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>private</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	self shouldNotImplement</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>accessing</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="aliasingKeys">aliasingKeys	^TimeZonePolicyFactory aliasingKeysOf: self registrationKey</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="annualPolicy">annualPolicy	"Answer the receiver's AnnuallyRecurringTZPolicy."	^annualPolicy</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="defaultAnnualPolicy">defaultAnnualPolicy	"Answer the AnnuallyRecurringTZPolicy that specifies the time zone rules that are in effect during the current year."	^rootTZ defaultAnnualPolicy</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="defaultName">defaultName	^defaultName</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="effectiveYearCalendar">effectiveYearCalendar	^effectiveYearCalendar == nil ifTrue: [Gregorian] ifFalse: [effectiveYearCalendar]</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="effectiveYearCalendarKey">effectiveYearCalendarKey	^self effectiveYearCalendar registrationKey</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="effectiveYearRelativity">effectiveYearRelativity	^effectiveYearRelativity</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="geographicCoordinates">geographicCoordinates	^geographicCoordinates</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="interYearPolicy">interYearPolicy	^self</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="key">key	^rootTZ key</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="leftLink">leftLink	^leftLink</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="leftLinkIfNone:">leftLinkIfNone: block0	"Answer the next rule `to the left` in the receiver's rule chain, if there is one.  If there is not, answer the result of evaluating &lt;block0&gt;."	^leftLink == nil		ifTrue: [block0 value]		ifFalse: [leftLink]</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="name">name	^rootTZ name</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="nameIfNone:">nameIfNone: noneBlock	^rootTZ nameIfNone: noneBlock</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="policy">policy	"Answer the TimeZonePolicy that specifies the ruleset of the time zone represented by the instance.  The ruleset of a time zone specifies for all time values, from the infinite past to the infinite future, the (possibly varying) time zone offsets and abbreviations that apply to points-in-time within the territorial domain of the time zone. Note, however, that the `policy` (time zone ruleset) can be changed retroactively--and this is rather likely to happen for times in the future (but can also happen to times in the past.)"	^rootTZ policy</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="registrationKey">registrationKey	^registrationKey</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="root">root	^rootTZ</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>enumerating</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="withLeftLinkDo:">withLeftLinkDo: block1	"Evaluatue &lt;block1&gt; with the next leftward link in the receiver's rule chain as the argument.  If there is no such link, do nothing."	^leftLink == nil ifFalse: [block1 value: leftLink]</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>queries</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="annualPolicyForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^(self effectiveRuleInYear: year ifNone: [self]) 		annualPolicy 			intraYearPolicyForLocalYear: year			dayOfYear: dayOfYear			secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="annualPolicyForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^(self effectiveRuleInUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction ifNone: [self]) 		annualPolicy			intraYearPolicyForUTYear: year			dayOfYear: dayOfYear			secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in the local time defined by the receiver.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in local (`wall clock`) time as defined by the receiver."	^(self		annualPolicyForLocalYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) binding</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in Universal Time.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in Universal Time."	^(self		annualPolicyForUTYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) binding</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="effectiveRuleInUTYear:dayOfYear:secondsSinceStartOfDayFunction:ifNone:">effectiveRuleInUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective as of the specified (in Universal Time) &lt;year&gt;, &lt;dayOfYear&gt; and seconds-since-start-day (where the seconds-since-start-day is computed by sending the message #value: to &lt;secondsSinceStartOfDayFunction&gt;). The &lt;secondsSinceStartOfDayFunction&gt; will, if the value it computes is needed, be invoked with a single argument that represents the number of seconds of offset from UT that should be used to convert local time to UT. If no rule is found that satisfies the search criteria, answer the result of evaluating &lt;ifNone&gt;."	^(self compareEffectiveYearTo: year) &gt; 0 		ifTrue: 			[(self rightLinkIfNone: [^ifNone value]) 				searchBackwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: ifNone]		ifFalse: 			[(self leftLinkIfNone: [^self]) 				searchForwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: [self]]</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="searchBackwardForAnnualPolicyAtLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">searchBackwardForAnnualPolicyAtLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT). Assume that the receiver's &lt;annualPolicy&gt; is currently in effect (don't check whether or not it may have expired.)	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^(self searchRightwardForEffectiveRuleInYear: year ifNone: [self]) 		annualPolicy 			intraYearPolicyForLocalYear: year			dayOfYear: dayOfYear			secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="searchBackwardForAnnualPolicyAtUTYear:dayOfYear:secondsSinceStartOfDayFunction:">searchBackwardForAnnualPolicyAtUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT). Assume that the receiver's &lt;annualPolicy&gt; is currently in effect (don't check whether or not it may have expired.)	If it is necessary for the receiver to also know the time-of-day in order to determine the correct timezone binding, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^(self 		searchBackwardForEffectiveRuleInUTYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction		ifNone: [self]) 			annualPolicy 				intraYearPolicyForUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="searchBackwardForEffectiveRuleInUTYear:dayOfYear:secondsSinceStartOfDayFunction:ifNone:">searchBackwardForEffectiveRuleInUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective as of the specified (in Universal Time) &lt;year&gt;, &lt;dayOfYear&gt; and seconds-since-start-day (where the seconds-since-start-day is computed by sending the message #value: to &lt;secondsSinceStartOfDayFunction&gt;).  Assume that the receiver's &lt;annualPolicy&gt; is currently in effect (don't check whether or not it may have expired.)	The &lt;secondsSinceStartOfDayFunction&gt; will, if the value it computes is needed, be invoked with a single argument that represents the number of seconds of offset from UT that should be used to convert local time to UT. If no rule is found that satisfies the search criteria, answer the result of evaluating &lt;ifNone&gt;."	^(self compareEffectiveYearTo: year) &lt;= 0 		ifTrue: [self]		ifFalse: 			[(self rightLinkIfNone: [^ifNone value]) 				searchBackwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: ifNone]</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="searchForwardForEffectiveRuleInUTYear:dayOfYear:secondsSinceStartOfDayFunction:ifNone:">searchForwardForEffectiveRuleInUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective as of the specified (in Universal Time) &lt;year&gt;, &lt;dayOfYear&gt; and seconds-since-start-day (where the seconds-since-start-day is computed by sending the message #value: to &lt;secondsSinceStartOfDayFunction&gt;).  Assume that the receiver's &lt;annualPolicy&gt; has always been in effect since the infinite past (don't check for previous annual time zone policies.)	The &lt;secondsSinceStartOfDayFunction&gt; will, if the value it computes is needed, be invoked with a single argument that represents the number of seconds of offset from UT that should be used to convert local time to UT. If no rule is found that satisfies the search criteria, answer the result of evaluating &lt;ifNone&gt;."	| diff |	diff := self compareEffectiveYearTo: year.	^diff &gt; 0 		ifTrue: [ifNone value]		ifFalse: 			[diff = 0 ifTrue: [^self].			(self leftLinkIfNone: [^self]) 				searchForwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: [self]]</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>processing</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	^self asPolicyFactory processBy: aTimezoneProcessor</body></methods><methods><class-id>Chronos.TimeZonePolicy</class-id> <category>printing</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="printOn:">printOn: stream	stream		nextPut: ${;		nextPutAll: self class name.	self specifiesDefaultName		ifTrue: [stream cr; tab; tab; tab; nextPutAll: 'defaultName='; nextPutAll: self defaultName].	stream		cr; tab; tab; tab; nextPutAll: 'effectiveYear=';		print: effectiveYear.	self specifiesGeographicCoordinates 		ifTrue: [stream tab; nextPutAll: ' geographicCoordinates='; print: self geographicCoordinates].	stream		cr; tab; tab; tab; nextPutAll: 'annual policy=';		cr; tab; tab; tab; tab; print: annualPolicy.	rightLink == nil 		ifFalse: 			[stream				cr; tab; tab;				print: rightLink].	stream nextPut: $}</body></methods><methods><class-id>Chronos.TimeZonePolicy class</class-id> <category>private</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self shouldNotImplement</body></methods><methods><class-id>Chronos.TimeZonePolicy class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="for:ifNone:">for: anUnboundDynamicTimeZone ifNone: ifNoneBlock	"Create and answer a new TimeZonePolicy that encapsulates a fully-populated `rule chain` representing the full diachronic time zone ruleset for the `unbound, dynamic` time zone &lt;anUnboundDynamicTimeZone&gt;, deserialized from the time zone ruleset specification persistently stored in the external Chronos time-zones repository. If there is no such ruleset defined in the Chropnos time-zones repository, answer the result of evaluating the 0-argument block &lt;ifNoneBlock&gt;."	^(TimeZonePolicyFactory at: anUnboundDynamicTimeZone key ifAbsent: [^ifNoneBlock value]) 		asPolicyFor: anUnboundDynamicTimeZone</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="newFor:">newFor: unboundDynamicTimeZone 	"Create and answer a new TimeZonePolicy, representing a single ruleform (a `rule chain` with only one element,) with the specified  &lt;unboundDynamicTimeZone&gt; as the instance's root timezone."	^self new setRootTZ: unboundDynamicTimeZone</body></methods><methods><class-id>Chronos.AsymmetricTimeZonePolicy</class-id> <category>testing</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="isSymmetric">isSymmetric	"Aswer true if the receiver is an instance of AsymmetricTimeZonePolicy, false otherwise.  See the class comment of AsymmetricTimeZonePolicy for an explanation of the difference."	^false</body></methods><methods><class-id>Chronos.AsymmetricTimeZonePolicy</class-id> <category>accessing</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="defaultName">defaultName	^defaultName</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="utEffectiveDayOfYear">utEffectiveDayOfYear	^utEffectiveDayOfYear</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="utEffectiveSecondsSinceStartOfDay">utEffectiveSecondsSinceStartOfDay	^utEffectiveSecondsSinceStartOfDay</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="utEffectiveYear">utEffectiveYear	^utEffectiveYear</body></methods><methods><class-id>Chronos.AsymmetricTimeZonePolicy</class-id> <category>queries</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="effectiveRuleInUTYear:dayOfYear:secondsSinceStartOfDayFunction:ifNone:">effectiveRuleInUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective as of the specified (in Universal Time) &lt;year&gt;, &lt;dayOfYear&gt; and seconds-since-start-day (where the seconds-since-start-day is computed by sending the message #value: to &lt;secondsSinceStartOfDayFunction&gt;). The &lt;secondsSinceStartOfDayFunction&gt; will, if the value it computes is needed, be invoked with a single argument that represents the number of seconds of offset from UT that should be used to convert local time to UT. If no rule is found that satisfies the search criteria, answer the result of evaluating &lt;ifNone&gt;."	^(self compareUTEffectiveTimeToYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) &gt; 0 		ifTrue: 			[(self rightLinkIfNone: [^ifNone value]) 				searchBackwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: ifNone]		ifFalse: 			[(self leftLinkIfNone: [^self]) 				searchForwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: [self]]</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="searchBackwardForEffectiveRuleInUTYear:dayOfYear:secondsSinceStartOfDayFunction:ifNone:">searchBackwardForEffectiveRuleInUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective as of the specified (in Universal Time) &lt;year&gt;, &lt;dayOfYear&gt; and seconds-since-start-day (where the seconds-since-start-day is computed by sending the message #value: to &lt;secondsSinceStartOfDayFunction&gt;).  Assume that the receiver's &lt;annualPolicy&gt; is currently in effect (don't check whether or not it may have expired.)	The &lt;secondsSinceStartOfDayFunction&gt; will, if the value it computes is needed, be invoked with a single argument that represents the number of seconds of offset from UT that should be used to convert local time to UT. If no rule is found that satisfies the search criteria, answer the result of evaluating &lt;ifNone&gt;."	^(self compareUTEffectiveTimeToYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) &lt;= 0 		ifTrue: [self]		ifFalse: 			[(self rightLinkIfNone: [^ifNone value]) 				searchBackwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: ifNone]</body><body package="Chronos-TimeZones-Policies-Diachronic" selector="searchForwardForEffectiveRuleInUTYear:dayOfYear:secondsSinceStartOfDayFunction:ifNone:">searchForwardForEffectiveRuleInUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction ifNone: ifNone 	"Answer the rule in the receiver's rule chain effective as of the specified (in Universal Time) &lt;year&gt;, &lt;dayOfYear&gt; and seconds-since-start-day (where the seconds-since-start-day is computed by sending the message #value: to &lt;secondsSinceStartOfDayFunction&gt;).  Assume that the receiver's &lt;annualPolicy&gt; has always been in effect since the infinite past (don't check for previous annual time zone policies.)	The &lt;secondsSinceStartOfDayFunction&gt; will, if the value it computes is needed, be invoked with a single argument that represents the number of seconds of offset from UT that should be used to convert local time to UT. If no rule is found that satisfies the search criteria, answer the result of evaluating &lt;ifNone&gt;."	| diff |	diff := self compareUTEffectiveTimeToYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction.	^diff &gt; 0 		ifTrue: [ifNone value]		ifFalse: 			[diff = 0 ifTrue: [^self].			(self leftLinkIfNone: [^self]) 				searchForwardForEffectiveRuleInUTYear: year				dayOfYear: dayOfYear				secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction				ifNone: [self]]</body></methods><methods><class-id>Chronos.AsymmetricTimeZonePolicy</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	| ymd |	super canonicalize.	utEffectiveSecondsSinceStartOfDay := (Gregorian secondsSinceEpochUpToYear: self effectiveYear) - annualPolicy offsetSecondsFromUT.	utEffectiveDayOfYear := utEffectiveSecondsSinceStartOfDay // SecondsPerDay.	utEffectiveSecondsSinceStartOfDay :=  utEffectiveSecondsSinceStartOfDay \\ SecondsPerDay.	ymd := Gregorian dateSpecFromDaysSinceEpoch: utEffectiveDayOfYear.	utEffectiveDayOfYear := ymd dayOfYearOrdinal.	utEffectiveYear := ymd year.</body></methods><methods><class-id>Chronos.AsymmetricTimeZonePolicy</class-id> <category>comparing</category><body package="Chronos-TimeZones-Policies-Diachronic" selector="compareUTEffectiveTimeToYear:dayOfYear:secondsSinceStartOfDayFunction:">compareUTEffectiveTimeToYear: aYear dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction	"Answer a strictly positive integer if the receiver's effectiveYear is greater than the argument; answer 0 if equal; and answer a negative integer if less."	| diff |	diff := utEffectiveYear - aYear.	diff = 0 ifFalse: [^diff].	diff := utEffectiveDayOfYear - dayOfYear.	diff = 0 ifFalse: [^diff].	^utEffectiveSecondsSinceStartOfDay - (secondsSinceStartOfDayFunction value: annualPolicy offsetSecondsFromUT)</body></methods><methods><class-id>Chronos.PersianCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"PersianCalendar canonical forDaysSinceEpoch: 1029983  setYearAndCalendarDayInto: [:year :cd | Array with: year with: cd with: cd yearTypeCode]"	| cycles days year daysSinceEpochUpToYear daysSinceStartOfYear |	days := daysSinceEpoch - 173125.	cycles := days // 1029983.	days := days \\ 1029983.	days = 1029982 		ifTrue: [year := 2820]		ifFalse: [year := (2816 * days + 1031337) // 1028522].	year := yearNumberingPolicy canonicalFromOrdinal: (2820 * cycles + 474 + year). " 2820 + 474 =  3294"	daysSinceEpochUpToYear := self daysSinceEpochUpToYear: year.	daysSinceStartOfYear :=  daysSinceEpoch - daysSinceEpochUpToYear.		^yearMonthDaySpecOrBlock2 		value: year		value: ((yearlyCalendars at: (self typeCodeOfYear: year)) basicDayAt: daysSinceStartOfYear + 1)</body></methods><methods><class-id>Chronos.PersianCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1948320 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.PersianCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"{PersianCalendar canonical daysSinceEpochUpToYear: 5}"	"{PersianCalendar canonical daysSinceEpochUpToYear: 475} = 173125"	"{(PersianCalendar canonical daysSinceEpochUpToYear: 2821)}  = 1029983"	| cardinalYear dividend year |	cardinalYear := yearNumberingPolicy cardinalFromCanonical: calendarYear.	dividend := cardinalYear - 473.	year := (dividend \\ 2820)  + 474.	^(1029983 * (dividend // 2820)) + (365 * (year - 1)) + ((682 * year - 110) // 2816)</body></methods><methods><class-id>Chronos.PersianCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	"PersianCalendar canonical typeCodeOfYear: 475"	"PersianCalendar canonical typeCodeOfYear: 479"	"{(475 to: 3295) inject: 0 into: [:total :year | (PersianCalendar canonical typeCodeOfYear: year) = 2 ifTrue: [total + 1] ifFalse: [total]]} =  683"	| cardinalYear dividend year |	cardinalYear := yearNumberingPolicy cardinalFromCanonical: calendarYear.	dividend := cardinalYear - 473.	year := (dividend \\ 2820)  + 474.	^((year + 38) * 682 \\ 2816) &lt; 682		ifTrue: [2] ifFalse: [1]</body></methods><methods><class-id>Chronos.PersianCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newDefaultYearNumberingPolicy">newDefaultYearNumberingPolicy	"Answer a new NumberingPolicy to be used as the the policy for interpreting year numbers in the calendrical system implemented by instances of the receiver. NOTE: The ANSI Smalltalk standard REQUIRES the use of 'Astronomical Year Numbering' (i.e., an OrdinalNumberingPolicy) for dates in the Gregorian calendar. The ISO 8601 standard imposes the same requirement."	^self newZerolessOrdinalYearNumberingPolicy</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Farvardin 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ordibehesht	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Khordad 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tir 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Mordad 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shahrivar 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Mehr 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Aban 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Azar 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Day 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Bahman 		daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Esfand 		daysPerMonth: 30 leapDayOrdinals: #(30)).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Farvardin 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ordibehesht	daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Khordad 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Tir 			daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Mordad 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shahrivar 		daysPerMonth: 31 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Mehr 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Aban 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Azar 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Day 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Bahman 		daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Esfand 		daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.PersianCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#'Persian'</body></methods><methods><class-id>Chronos.PersianCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"PersianCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^((calendarYear * 11) + 14) \\ 30 &lt; 11		ifTrue: [2] ifFalse: [1]</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1948439 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2 	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	| year daysSinceEpochAtStartOfYear daysSinceStartOfYear |	year := 30 * daysSinceEpoch + 10646 // 10631.	daysSinceEpochAtStartOfYear := self daysSinceEpochUpToYear: year.	daysSinceStartOfYear := daysSinceEpoch - daysSinceEpochAtStartOfYear.	^yearMonthDaySpecOrBlock2 		value: year		value: ((yearlyCalendars at: (self typeCodeOfYear: year)) basicDayAt: daysSinceStartOfYear + 1)</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the calendrical system represented by the receiver starts each day at local midnight."	^false</body><body package="Chronos-Calendars-Regular" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the calendrical system implemented by the receiver coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^false</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar</class-id> <category>API-unification</category><body package="Chronos-Calendars-Regular" selector="secondsSinceMidnightFromSecondsSinceStartOfDay:">secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay	"Answer the number of seconds-since-start-of-day relative to midnight represented by the argument, &lt;secondsSinceStartOfDay&gt;, where the argument is specified relative to the receiver's canonical start-of-day (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since midnight clock time that corresponds to the number of seconds since the receiver's canonical start-of-day clock time, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for time systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Julian Day time system, the canonical start-of-day is Noon."	^secondsSinceStartOfDay + 64800</body><body package="Chronos-Calendars-Regular" selector="secondsSinceStartOfDayFromSecondsSinceMidnight:">secondsSinceStartOfDayFromSecondsSinceMidnight: secondsSinceMidnight	"Answer the number of seconds-since-start-of-day relative to the receiver's canonical start-of-day represented by the argument, &lt;secondsSinceMidnight&gt;, where the argument is specified relative to midnight (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since the receiver's canonical start-of-day clock time that corresponds to the number of seconds since midnight, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for calendar systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Hebrew calendar, the canonical start-of-day is 6pm."	^secondsSinceMidnight + 21600</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"IslamicCalendar canonical daysSinceEpochUpToYear: 4"	^(calendarYear - 1) * 354 + ((11 * calendarYear + 3) // 30)</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Muharram 		daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Safar 				daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Rabi1 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Rabi2 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Jumada1 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Jumada2 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Rajab 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shaban 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ramadan 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shawwal 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Dhu al-Qa''ada'	daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Dhu al-Hijja' 		daysPerMonth: 30 leapDayOrdinals: #(30)).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Muharram 		daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Safar 				daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Rabi1 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Rabi2 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Jumada1 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Jumada2 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Rajab 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shaban 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ramadan 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Shawwal 			daysPerMonth: 29 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Dhu al-Qa''ada'	daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Dhu al-Hijja' 		daysPerMonth: 29 leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#'Islamic-Fatimid'</body></methods><methods><class-id>Chronos.IslamicFatimidCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"IslamicFatimidCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>arithmetic</category><body package="Chronos-DateTimeInterval" selector="-">- aDurationOrTemporalInterval	"Specified and required by the ANSI-Smalltalk Standard."	^aDurationOrTemporalInterval subtractedFromInfiniteTimepoint: self</body><body package="Chronos-DateTimeInterval" selector="addingDays:">addingDays: dayDelta	"Answer a new CalendricalCoordinate which is the given number of civil days after the date represented by the receiver, preserving the same civil time-of-day."	^self</body><body package="Chronos-DateTimeInterval" selector="addingHours:">addingHours: hours	^self</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:">addingHours: hours minutes: minutes	^self</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:seconds:">addingHours: hours minutes: minutes seconds: seconds	^self</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:seconds:nanoseconds:">addingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	^self</body><body package="Chronos-DateTimeInterval" selector="addingMinutes:">addingMinutes: minutes	^self</body><body package="Chronos-DateTimeInterval" selector="addingMonths:">addingMonths: months	^self</body><body package="Chronos-DateTimeInterval" selector="addingSeconds:">addingSeconds: seconds	^self</body><body package="Chronos-DateTimeInterval" selector="addingSeconds:nanoseconds:">addingSeconds: seconds nanoseconds: nanoseconds 	^self</body><body package="Chronos-DateTimeInterval" selector="addingYears:">addingYears: years	^self</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:">addingYears: years months: months	^self</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:">addingYears: years months: months days: days	^self</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:hours:minutes:seconds:nanoseconds:">addingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	^self</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:seconds:nanoseconds:">addingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds 	^self</body><body package="Chronos-DateTimeInterval" selector="daysSince:">daysSince: aTemporalCoordinate	^PassportInfinity polarity: isNegative not</body><body package="Chronos-DateTimeInterval" selector="daysUntil:">daysUntil: aTemporalCoordinate	^PassportInfinity polarity: isNegative</body><body package="Chronos-DateTimeInterval" selector="durationSince:">durationSince: aTemporalCoordinate	^InfiniteDuration polarity: isNegative not</body><body package="Chronos-DateTimeInterval" selector="durationUntil:">durationUntil: aTemporalCoordinate	^InfiniteDuration polarity: isNegative</body><body package="Chronos-DateTimeInterval" selector="scientificDurationSince:">scientificDurationSince: aTemporalCoordinate	^self durationSince: aTemporalCoordinate</body><body package="Chronos-DateTimeInterval" selector="scientificDurationUntil:">scientificDurationUntil: aTemporalCoordinate	^self durationUntil: aTemporalCoordinate</body><body package="Chronos-DateTimeInterval" selector="secondsSince:">secondsSince: aTemporal	^PassportInfinity polarity: isNegative not</body><body package="Chronos-DateTimeInterval" selector="secondsUntil:">secondsUntil: aTemporal	^PassportInfinity polarity: isNegative</body><body package="Chronos-DateTimeInterval" selector="subtractingDays:">subtractingDays: days	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:">subtractingHours: hours	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:">subtractingHours: hours minutes: minutes	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:seconds:">subtractingHours: hours minutes: minutes seconds: seconds	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:seconds:nanoseconds:">subtractingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingMinutes:">subtractingMinutes: minutes	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingMonths:">subtractingMonths: months	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingSeconds:">subtractingSeconds: seconds	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingSeconds:nanoseconds:">subtractingSeconds: seconds nanoseconds: nanoseconds	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:">subtractingYears: years	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:">subtractingYears: years months: months	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:">subtractingYears: years months: months days: days	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:hours:minutes:seconds:nanoseconds:">subtractingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	^self</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:seconds:nanoseconds:">subtractingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds	^self</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isInfinite">isInfinite	^true</body><body package="Chronos-DateTimeInterval" selector="isInfiniteFuture">isInfiniteFuture	^isNegative not</body><body package="Chronos-DateTimeInterval" selector="isInfinitePast">isInfinitePast	^isNegative</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="negated">negated	^self class polarity: isNegative</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="addedToCalendarDuration:">addedToCalendarDuration: aDuration	^aDuration + (InfiniteDuration polarity: isNegative not)</body><body package="Chronos-DateTimeInterval" selector="addedToCivilDuration:">addedToCivilDuration: aDuration	^aDuration + (InfiniteDuration polarity: isNegative not)</body><body package="Chronos-DateTimeInterval" selector="addedToDuration:">addedToDuration: aDuration	^aDuration + (InfiniteDuration polarity: isNegative not)</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCalendarDuration:">subtractedFromCalendarDuration: aDuration	^aDuration - (InfiniteDuration polarity: isNegative)</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aDuration	^aDuration - (InfiniteDuration polarity: isNegative)</body><body package="Chronos-DateTimeInterval" selector="subtractedFromDuration:">subtractedFromDuration: aDuration	^aDuration - (InfiniteDuration polarity: isNegative)</body><body package="Chronos-DateTimeInterval" selector="subtractedFromTemporalInterval:">subtractedFromTemporalInterval: aTemporalInterval	^InfiniteDuration polarity: isNegative</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>INTER-period-stream protocol</category><body package="Chronos-DateTimeInterval" selector="next">next	^self</body><body package="Chronos-DateTimeInterval" selector="prev">prev	^self</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="beNegative">beNegative	self assertMutability.	isNegative := true</body><body package="Chronos-DateTimeInterval" selector="bePositive">bePositive	self assertMutability.	isNegative := false</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>private-comparing</category><body package="Chronos-DateTimeInterval" selector="compareToInfiniteTimepoint:">compareToInfiniteTimepoint: anInfiniteTimepoint	^anInfiniteTimepoint isInfinitePast		ifTrue: [isNegative ifTrue: [0] ifFalse: [-1]]		ifFalse: [isNegative ifTrue: [1] ifFalse: [0]]</body><body package="Chronos-DateTimeInterval" selector="compareToTemporalCoordinate:">compareToTemporalCoordinate: aTemporalCoordinate	^isNegative		ifTrue: [1]		ifFalse: [-1]</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aTemporalInterval	"Compare the value of the receiver to that of &lt;aTemporalInterval&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aTemporalInterval ifTrue: [^0].	^[aTemporalInterval compareToInfiniteTimepoint: self] 			on: MessageNotUnderstood 			do: [:ex | 				((ex receiver == aTemporalInterval) and: [#compareToInfiniteTimepoint: == ex message selector])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-DateTimeInterval" selector="hash">hash	^isNegative hash</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="resolutionQuantum">resolutionQuantum	^InfiniteDuration polarity:self isInfiniteFuture</body></methods><methods><class-id>Chronos.InfiniteTimepoint</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy 	aChronosPrintPolicy printInfiniteTimepoint: self on: stream</body></methods><methods><class-id>Chronos.InfiniteTimepoint class</class-id> <category>instance creation</category><body package="Chronos-DateTimeInterval" selector="new">new	^self shouldNotImplement</body><body package="Chronos-DateTimeInterval" selector="polarity:">polarity: polarity 	^polarity ifTrue: [self future] ifFalse: [self past]</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	^self notYetImplemented</body></methods><methods><class-id>Chronos.InfiniteTimepoint class</class-id> <category>constants</category><body package="Chronos-DateTimeInterval" selector="future">future	Future == nil 		ifTrue: 			[Future := 				(self basicNew)					bePositive;					beImmutable].	^Future</body><body package="Chronos-DateTimeInterval" selector="past">past	Past == nil 		ifTrue: 			[Past := 				(self basicNew)					beNegative;					beImmutable].	^Past</body></methods><methods><class-id>Chronos.InfiniteTimepoint class</class-id> <category>unit test</category><body package="Chronos-DateTimeInterval" selector="testDoIts">testDoIts	"InfiniteTimepoint future = InfiniteTimepoint future	InfiniteTimepoint future &lt; InfiniteTimepoint future	InfiniteTimepoint future &gt; InfiniteTimepoint future	InfiniteTimepoint future = InfiniteTimepoint past	InfiniteTimepoint future &lt; InfiniteTimepoint past	InfiniteTimepoint future &gt; InfiniteTimepoint past	InfiniteTimepoint past = InfiniteTimepoint future	InfiniteTimepoint past &lt; InfiniteTimepoint future	InfiniteTimepoint past &gt; InfiniteTimepoint future	InfiniteTimepoint past = InfiniteTimepoint past	InfiniteTimepoint past &lt; InfiniteTimepoint past	InfiniteTimepoint past &gt; InfiniteTimepoint past	InfiniteTimepoint future = Timepoint now	InfiniteTimepoint future &lt; Timepoint now	InfiniteTimepoint future &gt; Timepoint now	InfiniteTimepoint past = Timepoint now	InfiniteTimepoint past &lt; Timepoint now	InfiniteTimepoint past &gt; Timepoint now	(YearMonthDay today withDuration: InfiniteDuration positive) includes: YearMonthDay tomorrow	(YearMonthDay today withDuration: InfiniteDuration positive) includes: YearMonthDay yesterday	(YearMonthDay today withDuration: InfiniteDuration negative) includes: YearMonthDay tomorrow	(YearMonthDay today withDuration: InfiniteDuration negative) includes: YearMonthDay yesterday	YearMonthDay today + InfiniteDuration positive	YearMonthDay today + InfiniteDuration negative	YearMonthDay today - InfiniteDuration positive	YearMonthDay today - InfiniteDuration negative	InfiniteDuration positive +YearMonthDay today	InfiniteDuration negative +YearMonthDay today	InfiniteDuration positive -YearMonthDay today	InfiniteDuration negative -YearMonthDay today	YearMonthDay today + InfiniteTimepoint future	YearMonthDay today + InfiniteTimepoint past 	YearMonthDay today - InfiniteTimepoint future	YearMonthDay today - InfiniteTimepoint past	InfiniteTimepoint future + YearMonthDay today	InfiniteTimepoint past + YearMonthDay today	InfiniteTimepoint future - YearMonthDay today	InfiniteTimepoint past - YearMonthDay today"</body></methods><methods><class-id>Chronos.SemanticDateObservanceRule</class-id> <category>queries</category><body package="Chronos-Semantic Dates" selector="doesEventNominallyOccurInYear:">doesEventNominallyOccurInYear: aYear	"(SemanticDateObservanceRule yearBase: 0 period: 4) doesEventNominallyOccurInYear: 2003"	"(SemanticDateObservanceRule yearBase: 0 period: 4) doesEventNominallyOccurInYear: 2004"	"(SemanticDateObservanceRule yearBase: 0 period: 4) doesEventNominallyOccurInYear: 2005"	"(SemanticDateObservanceRule yearBase: 1 period: 4) doesEventNominallyOccurInYear: 2003"	"(SemanticDateObservanceRule yearBase: 1 period: 4) doesEventNominallyOccurInYear: 2004"	"(SemanticDateObservanceRule yearBase: 1 period: 4) doesEventNominallyOccurInYear: 2005"	expirationYear == nil 		ifFalse: [aYear &gt;= expirationYear ifTrue: [^false]].	^yearPeriod = 0		ifTrue: [true]		ifFalse: [aYear - yearBase \\ yearPeriod = 0]</body><body package="Chronos-Semantic Dates" selector="eventObservanceTypeNominallyOccuringOn:for:">eventObservanceTypeNominallyOccuringOn: nominalAnnualDate for: aDate 	"If &lt;aDate&gt; = &lt;nominalAnnualDate inYear: aDate year&gt;, answer #nominal.	Otherwise, if &lt;aDate&gt; = the date that the observance rule represented by the receiver specifies for &lt;nominalAnnualDate inYear: aDate year&gt;, answer #observed.	Otherwise, if &lt;aDate&gt; = a date for which the observance rule represented by the receiver forbids observance of the receiver's event, answer #notObserved.	Otherwise, answer #none."	| policy observanceConstraint |	(self doesEventNominallyOccurInYear: aDate year) ifFalse: [^#none].	observanceConstraint := self dayOfMonthObservanceConstraintOn: aDate.	observanceConstraint == #notObserved ifTrue: [^#notObserved].	dayOfWeekPolicy == nil 		ifTrue: [policy := 0]		ifFalse: 			[policy := dayOfWeekPolicy at: aDate ansiDayOfWeekOrdinal.			policy == #notObserved ifTrue: [^#notObserved]].	nominalAnnualDate = aDate ifTrue: [^#nominal].	^policy = 0 		ifTrue: [#none]		ifFalse: 			[observanceConstraint == #observedOnlyIfNominal				ifTrue: [#none]				ifFalse: 					[nominalAnnualDate = (aDate addingDays: policy) 						ifTrue: [#observed]						ifFalse: [#none]]]</body><body package="Chronos-Semantic Dates" selector="observanceDateAndTypeOf:inYear:into:ifNone:">observanceDateAndTypeOf: nominalAnnualDate inYear: aYear into: block2 ifNone: ifNoneBlock 	| nominalDate policy observanceConstraint |	(self doesEventNominallyOccurInYear: aYear) ifFalse: [^ifNoneBlock value].	nominalDate := nominalAnnualDate inYear: aYear.	dayOfWeekPolicy == nil 		ifFalse: 			[| nominalDayOfWeek |			nominalDayOfWeek := nominalDate ansiDayOfWeekOrdinal.			policy := dayOfWeekPolicy at: nominalDayOfWeek.			policy == #notObserved ifTrue: [^ifNoneBlock value].			1 to: 7				do: 					[:dayOfWeek | 					| diff |					diff := nominalDayOfWeek - dayOfWeek.					diff = 0 						ifFalse: 							[policy := dayOfWeekPolicy at: dayOfWeek.							policy == #notObserved 								ifFalse: 									[diff = policy 										ifTrue: 											[| observedDate |											observedDate := nominalDate subtractingDays: policy.											^observedDate year = aYear 												ifTrue: 													[observanceConstraint := self dayOfMonthObservanceConstraintOn: observedDate.													observanceConstraint == nil														ifTrue: [block2 value: observedDate value: #observed]														ifFalse: [ifNoneBlock value]]												ifFalse: [ifNoneBlock value]]]]]].	observanceConstraint := self dayOfMonthObservanceConstraintOn: nominalDate.	^observanceConstraint == #notObserved 		ifTrue: [ifNoneBlock value]		ifFalse: [block2 value: nominalDate value: #nominal]</body></methods><methods><class-id>Chronos.SemanticDateObservanceRule</class-id> <category>accessing</category><body package="Chronos-Semantic Dates" selector="dayOfMonthConstraints">dayOfMonthConstraints	^dayOfMonthConstraints copy</body><body package="Chronos-Semantic Dates" selector="dayOfWeekPolicy">dayOfWeekPolicy	^dayOfWeekPolicy copy</body><body package="Chronos-Semantic Dates" selector="expirationYear">expirationYear	^expirationYear</body><body package="Chronos-Semantic Dates" selector="yearBase">yearBase	^yearBase</body><body package="Chronos-Semantic Dates" selector="yearPeriod">yearPeriod	^yearPeriod</body></methods><methods><class-id>Chronos.SemanticDateObservanceRule</class-id> <category>private</category><body package="Chronos-Semantic Dates" selector="dayOfMonthObservanceConstraintOn:">dayOfMonthObservanceConstraintOn: aDate 	^dayOfMonthConstraints == nil 		ifFalse: 			[dayOfMonthConstraints isSymbol 				ifTrue: [aDate isLastDayOfMonth ifTrue: [dayOfMonthConstraints]]				ifFalse: [dayOfMonthConstraints at: aDate dayOfMonth ifAbsent: []]]</body><body package="Chronos-Semantic Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream		nextPut: yearBase;		nextPut: yearPeriod;		nextPut: expirationYear;		nextPut: dayOfWeekPolicy;		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: dayOfMonthConstraints)</body><body package="Chronos-Semantic Dates" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	super postCopy.	dayOfWeekPolicy := dayOfWeekPolicy copy.	dayOfMonthConstraints := dayOfMonthConstraints copy</body></methods><methods><class-id>Chronos.SemanticDateObservanceRule</class-id> <category>initialize-release</category><body package="Chronos-Semantic Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	yearBase := 0.	yearPeriod := 0.	expirationYear := nil.	dayOfWeekPolicy := nil.	dayOfMonthConstraints := nil</body><body package="Chronos-Semantic Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self		setYearBase: (literalArray at: 2);		setYearPeriod: (literalArray at: 3);		setExpirationYear: (literalArray at: 4);		setDayOfWeekPolicy: (literalArray at: 5);		setDayOfMonthConstraints: (ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 6))</body><body package="Chronos-Semantic Dates" selector="setDayOfMonthContraints:">setDayOfMonthContraints: aDictionaryOfSymbols	self assertMutability.	dayOfMonthConstraints := aDictionaryOfSymbols</body><body package="Chronos-Semantic Dates" selector="setDayOfWeekPolicy:">setDayOfWeekPolicy: anArrayOfIntegersIndexedByANSIDayOfWeekOrdinals 	self assertMutability.	dayOfWeekPolicy := anArrayOfIntegersIndexedByANSIDayOfWeekOrdinals.</body><body package="Chronos-Semantic Dates" selector="setExpirationYear:">setExpirationYear: anInteger 	self assertMutability.	expirationYear := anInteger</body><body package="Chronos-Semantic Dates" selector="setYearBase:">setYearBase: anInteger	self assertMutability.	yearBase := anInteger</body><body package="Chronos-Semantic Dates" selector="setYearPeriod:">setYearPeriod: anInteger 	self assertMutability.	yearPeriod := anInteger == nil ifTrue: [0] ifFalse: [anInteger]</body></methods><methods><class-id>Chronos.SemanticDateObservanceRule class</class-id> <category>instance creation</category><body package="Chronos-Semantic Dates" selector="dayOfWeekPolicy:">dayOfWeekPolicy: nilOrAnArrayOf7Integers	^self new		setDayOfWeekPolicy: nilOrAnArrayOf7Integers;		beImmutable</body><body package="Chronos-Semantic Dates" selector="dayOfWeekPolicy:dayOfMonthConstraints:">dayOfWeekPolicy: nilOrAnArrayOf7Integers dayOfMonthConstraints: aDictionaryOfWellKnownSymbols	^self new		setDayOfWeekPolicy: nilOrAnArrayOf7Integers;		setDayOfMonthContraints: aDictionaryOfWellKnownSymbols;		beImmutable</body><body package="Chronos-Semantic Dates" selector="expirationYear:">expirationYear: expirationYear	^self new		setExpirationYear: expirationYear;		beImmutable</body><body package="Chronos-Semantic Dates" selector="yearBase:period:">yearBase: base period: period	^self new		setYearBase: base;		setYearPeriod: period;		beImmutable</body><body package="Chronos-Semantic Dates" selector="yearBase:period:dayOfWeekPolicy:"> yearBase: base period: period dayOfWeekPolicy: nilOrAnArrayOf7Integers	^self new		setYearBase: base;		setYearPeriod: period;		setDayOfWeekPolicy: nilOrAnArrayOf7Integers;		beImmutable</body><body package="Chronos-Semantic Dates" selector="yearBase:period:dayOfWeekPolicy:dayOfMonthConstraints:"> yearBase: base period: period dayOfWeekPolicy: nilOrAnArrayOf7Integers dayOfMonthConstraints: aDictionaryOfWellKnownSymbols	^self new		setYearBase: base;		setYearPeriod: period;		setDayOfWeekPolicy: nilOrAnArrayOf7Integers;		setDayOfMonthContraints: aDictionaryOfWellKnownSymbols;		beImmutable</body><body package="Chronos-Semantic Dates" selector="yearBase:period:expirationYear:">yearBase: base period: period expirationYear: expirationYear	^self new		setYearBase: base;		setYearPeriod: period;		setExpirationYear: expirationYear;		beImmutable</body><body package="Chronos-Semantic Dates" selector="yearBase:period:expirationYear:dayOfWeekPolicy:"> yearBase: base period: period expirationYear: expirationYear dayOfWeekPolicy: nilOrAnArrayOf7Integers	^self new		setYearBase: base;		setYearPeriod: period;		setExpirationYear: expirationYear;		setDayOfWeekPolicy: nilOrAnArrayOf7Integers;		beImmutable</body><body package="Chronos-Semantic Dates" selector="yearBase:period:expirationYear:dayOfWeekPolicy:dayOfMonthConstraints:"> yearBase: base period: period expirationYear: expirationYear dayOfWeekPolicy: nilOrAnArrayOf7Integers dayOfMonthConstraints: aDictionaryOfWellKnownSymbols	^self new		setYearBase: base;		setYearPeriod: period;		setExpirationYear: expirationYear;		setDayOfWeekPolicy: nilOrAnArrayOf7Integers;		setDayOfMonthContraints: aDictionaryOfWellKnownSymbols;		beImmutable</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>private-initialize-release</category><body package="Chronos-DateTimeInterval" selector="basicSetYear:calendarDay:">basicSetYear: aYear calendarDay: aCalendarDay 	self assertMutability.	year := aYear.	calendarDay := aCalendarDay.</body><body package="Chronos-DateTimeInterval" selector="value:value:">value: aYear value: aCalendarDay	self assertMutability.	year := aYear.	calendarDay := aCalendarDay.</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="beImmutable">beImmutable	"Make the receiver immutable.  Idempotent.  Must answer the receiver."	lock := #immutable</body><body package="Chronos-DateTimeInterval" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	year == nil ifTrue: [year := 1].	calendarDay == nil 		ifTrue: 			[calendarDay := self calendar calendarDayFromDayOfYearOrdinal: 1 inYear: year]</body><body package="Chronos-DateTimeInterval" selector="initializeFrom:">initializeFrom: aCalendricalCoordinate 	self 		basicSetCalendar: aCalendricalCoordinate calendar;		basicSetYear: aCalendricalCoordinate year calendarDay: aCalendricalCoordinate calendarDay</body><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self basicSetDaysSinceEpoch: (literalArray at: 3) asNumber</body><body package="Chronos-DateTimeInterval" selector="invalidateCalendar">invalidateCalendar	super invalidateCalendar.	calendarDay := calendarDay == nil ifFalse: [calendarDay canonical]</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToDate: self] 			on: MessageNotUnderstood 			do: [:ex | 				((ex receiver == aCalendrical) and: [#compareToDate: == ex message selector])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="basicDaysSinceEpochUpToYear">basicDaysSinceEpochUpToYear	^calendar daysSinceEpochUpToYear: year</body><body package="Chronos-DateTimeInterval" selector="basicDaysSinceStartOfYear">basicDaysSinceStartOfYear	^calendarDay daysSinceStartOfYear</body><body package="Chronos-DateTimeInterval" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self basicDaysSinceEpoch</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="yearAndCalendarDayDo:">yearAndCalendarDayDo: block2 	^block2 value: year value: calendarDay</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="calendarDay">calendarDay	^calendarDay</body><body package="Chronos-DateTimeInterval" selector="year">year	"Specified and required by the ANSI-Smalltalk Standard."	^year</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="basicAddDays:">basicAddDays: dayDelta 	"Add the given number of civil days to the date represented by the receiver, preserving the same civil time-of-day."	dayDelta = 0 ifTrue: [^self].	calendarDay 		startingWithYear: year		addingDays: dayDelta		setYearAndCalendarDayInto: self</body></methods><methods><class-id>Chronos.YearMonthDay</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="dateSpec">dateSpec	^DateSpec year: year calendarDay: calendarDay</body></methods><methods><class-id>Chronos.YearMonthDay class</class-id> <category>examples</category><body package="Chronos-Semantic Dates" selector="allUSFederalHolidaysFromTodayForAYear">allUSFederalHolidaysFromTodayForAYear	"YearMonthDay allUSFederalHolidaysFromTodayForAYear"	| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy unitedStates 		observedAnnualEventOccurenceDatesFrom: YearMonthDay today		through: YearMonthDay yesterday + (CalendarDuration years: 1)		do: [:semanticKey :date :observanceType | 				(SemanticDatePolicy usFederalHolidaySemanticKeys includes: semanticKey)					ifTrue: [list add: date-&gt;(Array with: semanticKey with: observanceType)]].	^list</body><body package="Chronos-DateTimeInterval" selector="calendarDurationSinceFirstMoonLandingUntilToday">calendarDurationSinceFirstMoonLandingUntilToday	"YearMonthDay calendarDurationSinceFirstMoonLandingUntilToday"	^(YearMonthDay year: 1969 month: July day: 20) calendarDurationUntil: YearMonthDay today</body><body package="Chronos-Semantic Dates" selector="countOfNYSETradingDaysSince1Jan2000ThroughToday">countOfNYSETradingDaysSince1Jan2000ThroughToday	"YearMonthDay countOfNYSETradingDaysSince1Jan2000ThroughToday"	^SemanticDatePolicy 		nyseTradingDayCountFrom: (YearMonthDay year: 2000 day: 1)		through: YearMonthDay today</body><body package="Chronos-Semantic Dates" selector="countOfUSFederalBusinessDaysFromTodayForNextThreeYears">countOfUSFederalBusinessDaysFromTodayForNextThreeYears	"YearMonthDay countOfUSFederalBusinessDaysFromTodayForNextThreeYears"	^SemanticDatePolicy 		usFederalBusinessDayCountFrom: YearMonthDay today		through: YearMonthDay yesterday + (CalendarDuration years: 3)</body><body package="Chronos-DateTimeInterval" selector="daysSInceFirstMoonLandingUntilToday">daysSInceFirstMoonLandingUntilToday	"YearMonthDay daysSInceFirstMoonLandingUntilToday"	^(YearMonthDay year: 1969 month: July day: 20) daysUntil: YearMonthDay today</body><body package="Chronos-DateTimeInterval" selector="showAllCalendarEpochDates">showAllCalendarEpochDates	"YearMonthDay showAllCalendarEpochDates"	Calendar allRegisteredKeys 		do: [:toCalendar | YearMonthDay showAllCalendarEpochDatesAs: toCalendar]</body><body package="Chronos-DateTimeInterval" selector="showAllCalendarEpochDatesAs:">showAllCalendarEpochDatesAs: toCalendar 	"YearMonthDay showAllCalendarEpochDatesAs: #Gregorian"	"YearMonthDay showAllCalendarEpochDatesAs: #Julian"	"YearMonthDay showAllCalendarEpochDatesAs: #'Julian-Imperial'"	"YearMonthDay showAllCalendarEpochDatesAs: #Hebrew"	"YearMonthDay showAllCalendarEpochDatesAs: #Solarian"	| list stream pp |	list := SortedCollection new.	Calendar allRegisteredKeys 		do: [:key | list add: (self daysSinceEpoch: 0 calendar: key)].	pp := ConfigurableChronosPrintPolicy 				applying: #(#showStandardCalendarName #useNumericMonthDesignator).	Transcript cr.	list do: 			[:each | 			Transcript				cr;				show: (each printStringUsing: pp);				show: ' = ';				tab;				show: ((each as: toCalendar) printStringUsing: pp);				show: ' = ';				tab.			stream := String new writeStream.			ChronosFunction				printFractional: each julianDate				asDecimalOn: stream				decimalPoint: $. 				precision: 2.			stream nextPutAll: ' [Julian Date]'.			Transcript show: stream contents]</body><body package="Chronos-DateTimeInterval" selector="todayAsAll:">todayAsAll: calendarArray	"YearMonthDay todayAsAll: Calendar allRegisteredKeys asArray"	^calendarArray collect: [:calendar | self todayAs: calendar]</body><body package="Chronos-DateTimeInterval" selector="todayInAllCalendars">todayInAllCalendars	"YearMonthDay todayInAllCalendars"	^self todayAsAll: (Calendar allRegisteredKeys asSortedCollection: [:a :b | a == #Gregorian ifTrue: [true] ifFalse: [b == #Gregorian ifTrue: [false] ifFalse: [a &lt; b]]])</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="calendarDay">calendarDay	timeZone isProxyAndInvariantToUT 		ifTrue: 			[| localDaysSinceEpoch |			localDaysSinceEpoch := self daysSinceEpoch.			daysSinceEpoch = localDaysSinceEpoch 				ifFalse: 					[^self calendar 						forDaysSinceEpoch: localDaysSinceEpoch						setYearAndCalendarDayInto: [:y :cd | cd]]].	calendarDay == nil ifTrue: [self setYearAndCalendarDay].	^calendarDay</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch">daysSinceEpoch	| tz offsetSecondsFromUTC localSeconds days secondsInDay |	timeZone isInvariantToNominalTime ifTrue: [^self basicDaysSinceEpoch].	tz := self timeZone.	tz offsetIsZero ifTrue: [^self basicDaysSinceEpoch].	localSeconds := 		tz 			netSecondsAfterAddingOffsetFromUTToSeconds: secondsSinceStartOfDay			nanosecondsSinceSecond: nanosecondsSinceSecond.	offsetSecondsFromUTC := localSeconds - secondsSinceStartOfDay.	timeZone isProxy ifTrue: [self ensureDaysSinceEpochIsSet].	daysSinceEpoch == nil 		ifTrue: 			[daysSinceEpoch := days := self basicComputeDaysSinceEpoch.			offsetSecondsFromUTC abs &gt;= (secondsInDay := self secondsInDay)  				ifTrue: 					[daysSinceEpoch := daysSinceEpoch - (localSeconds // SecondsPerDay).					localSeconds := localSeconds \\ secondsInDay]				ifFalse: 					["Avoid division for the common case."					localSeconds &lt; 0 						ifTrue: 							[localSeconds := localSeconds + secondsInDay.							daysSinceEpoch := daysSinceEpoch + 1]						ifFalse: 							[localSeconds &gt;= secondsInDay 								ifTrue: 									[localSeconds := localSeconds - secondsInDay.									daysSinceEpoch := daysSinceEpoch - 1]]]]		ifFalse: 			[days := daysSinceEpoch.			offsetSecondsFromUTC abs &gt;= (secondsInDay := self secondsInDay) 				ifTrue: 					[days := days + (localSeconds // SecondsPerDay).					localSeconds := localSeconds \\ secondsInDay]				ifFalse: 					["Avoid division for the common case."					localSeconds &lt; 0 						ifTrue: 							[localSeconds := localSeconds + secondsInDay.							days := days - 1]						ifFalse: 							[localSeconds &gt;= secondsInDay 								ifTrue: 									[localSeconds := localSeconds - secondsInDay.									days := days + 1]]]].	^days</body><body package="Chronos-DateTimeInterval" selector="julianDay">julianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs (local time.) However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered (also local time.)"	^self calendar julianDayFromSecondsSinceEpoch: self secondsSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="microsecondsSinceEpoch">microsecondsSinceEpoch	"{(Duration microseconds: (AnsiStandardCalendarClock now microsecondsSinceEpoch)) asDateAndTime}"	^(self daysSinceEpoch * 675 bitShift: 7) * MicrosecondsPerSecond + self microsecondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="millisecondsSinceEpoch">millisecondsSinceEpoch	"{(Duration milliseconds: (AnsiStandardCalendarClock now millisecondsSinceEpoch)) asDateAndTime}"	^(self daysSinceEpoch * 675 bitShift: 7) * MillisecondsPerSecond + self millisecondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceEpoch">nanosecondsSinceEpoch	"{(Duration nanoseconds: (AnsiStandardCalendarClock now nanosecondsSinceEpoch)) asDateAndTime}"	^(self daysSinceEpoch * 675 bitShift: 7) * NanosecondsPerSecond + self nanosecondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	^timeZone isInvariantToUT 		ifTrue: 			[| tz |			tz := self timeZone.			tz hasSubsecondOffset 				ifTrue: [(nanosecondsSinceSecond + tz offsetFromUT nanosecondsSinceSecond) \\ NanosecondsPerSecond]				ifFalse: [nanosecondsSinceSecond]]		ifFalse: [nanosecondsSinceSecond]</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceStartOfDay">nanosecondsSinceStartOfDay	^timeZone isInvariantToUT 		ifTrue: 			[| tz |			tz := self timeZone.			tz hasSubsecondOffset 				ifTrue: 					[((self class durationFactory  						seconds: secondsSinceStartOfDay						nanoseconds: nanosecondsSinceSecond) + tz offsetFromUT) asNanoseconds \\ NanosecondsPerDay]				ifFalse: [(secondsSinceStartOfDay + tz offsetSecondsFromUT) \\ self secondsInDay * NanosecondsPerSecond + nanosecondsSinceSecond]]		ifFalse: [self basicNanosecondsSinceStartOfDay]</body><body package="Chronos-DateTimeInterval" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^NanosecondDuration</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch">secondsSinceEpoch	^self isInvariantToUT		ifTrue: 			[self timeZone 				netSecondsAfterAddingOffsetFromUTToSeconds: self basicSecondsSinceEpoch				nanosecondsSinceSecond: nanosecondsSinceSecond]				ifFalse: [self basicSecondsSinceEpoch]</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	^self isInvariantToUT 		ifTrue: 			[(self timeZone 				netSecondsAfterAddingOffsetFromUTToSeconds: secondsSinceStartOfDay				nanosecondsSinceSecond: nanosecondsSinceSecond) \\ self secondsInDay]		ifFalse: [secondsSinceStartOfDay]</body><body package="Chronos-DateTimeInterval" selector="timeZone">timeZone	"Answer the bound Timezone that has the correct offsetFromUT for the date and time represented by the receiver.  If the receiver's timeZone is not a proxy, the receiver's timeZone instance variable will be opportunistically set as a side effect. Also, the receiver's year and calendarDay instance variables **MAY OR MAY NOT** be opportunistically set as a side effect."	"This method has a greater impact on the performace of Timepoints than any other method in the inheritance hierarchy.  This is where the rubber meets the road."	| policy |	timeZone isBound ifTrue: [^timeZone binding].	(timeZone isInvariantToUT and: [year == nil or: [timeZone isProxy]]) 		ifTrue: 			[self isGregorian 				ifTrue: 					[| savedLock boundTZ |					savedLock := lock.					lock := nil.					year == nil ifTrue: [self setYearAndCalendarDayFromDaysSinceEpoch: self basicDaysSinceEpoch].					policy := 						timeZone							annualPolicyForUTYear: year							dayOfYear: calendarDay dayOfYearOrdinal							secondsSinceStartOfDayFunction: [:offsetSeconds | secondsSinceStartOfDay].					boundTZ := policy binding.					timeZone isProxy 						ifFalse: 							[timeZone := policy.							self 								alignCalendarDayWithLocalSecondsSinceStartOfDay: 									(boundTZ										netSecondsAfterAddingOffsetFromUTToSeconds: secondsSinceStartOfDay										nanosecondsSinceSecond: nanosecondsSinceSecond)].					lock := savedLock.					^boundTZ]				ifFalse: 					[| ymd |					ymd := self calendar gregorianDateSpecFromDaysSinceEpoch: daysSinceEpoch.					policy := 						timeZone							annualPolicyForUTYear: ymd year							dayOfYear: ymd dayOfYearOrdinal							secondsSinceStartOfDayFunction: 								[:offsetSeconds | 								"Handle calendars whose start-of-day is not midnight."								(self calendar 									secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay) 										\\ self secondsInDay].					timeZone isProxy ifFalse: [timeZone := policy].					^policy binding]]		ifFalse: 			[policy := self gregorianLocalYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo: 								[:y :dayOfYear :sssodFunction | 									timeZone										annualPolicyForLocalYear: y										dayOfYear: dayOfYear										secondsSinceStartOfDayFunction: sssodFunction].			timeZone isProxy ifFalse: [timeZone := policy].			^policy binding]</body><body package="Chronos-DateTimeInterval" selector="year">year	"Specified and required by the ANSI-Smalltalk Standard."	timeZone isProxyAndInvariantToUT 		ifTrue: 			[| localDaysSinceEpoch |			localDaysSinceEpoch := self daysSinceEpoch.			daysSinceEpoch = localDaysSinceEpoch 				ifFalse: 					[^self calendar 						forDaysSinceEpoch: localDaysSinceEpoch						setYearAndCalendarDayInto: [:y :cd | y]]].	year == nil ifTrue: [self setYearAndCalendarDay].	^year</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>private-time zone operations</category><body package="Chronos-DateTimeInterval" selector="basicGregorianYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo:">basicGregorianYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo: block3	"PRECONDIITION: The receiver's internal state has been set to a valid UTC, local or nominal timepoint. 	The sender is responsible for knowing whether the internal state represents a UTC, local or nominal time--this method just provides the raw data from the receiver's internal state, without any timezone translation. If nil, the instance variables &lt;daysSinceEpoch&gt;, &lt;year&gt; and &lt;calendarDay&gt; may be set to values computed from non-nil instance variables, but only when a) the receiver is invariant to nominal time, or b) the receiver's offset seconds from UTC is 0."	^self calendar isGregorian 		ifTrue: 			[year == nil 				ifTrue: [self setYearAndCalendarDayFromDaysSinceEpoch: daysSinceEpoch].			block3 				value: year				value: calendarDay dayOfYearOrdinal				value: [:offsetSecondsFromUT | secondsSinceStartOfDay]]		ifFalse: 			[| dayCount ymd |			daysSinceEpoch == nil 				ifTrue: 					[dayCount := self basicComputeDaysSinceEpoch.					(timeZone isProxy or: [timeZone isUniversalTime]) 						ifTrue: [daysSinceEpoch := dayCount]]				ifFalse: [dayCount := daysSinceEpoch].			ymd := Gregorian 						dateSpecFromDaysSinceEpoch: 							(Gregorian 								secondsSinceEpochFromForeignSecondsSinceEpoch: dayCount * SecondsPerDay + secondsSinceStartOfDay								convertingFrom: self calendar) // SecondsPerDay.			block3 				value: ymd year				value: ymd dayOfYearOrdinal				value: 					[:offsetSecondsFromUT | 					(self calendar 						secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay) 							\\ self secondsInDay]]</body><body package="Chronos-DateTimeInterval" selector="basicTimeZone">basicTimeZone	^timeZone</body><body package="Chronos-DateTimeInterval" selector="canonicalizeFromLocal:nanoseconds:">canonicalizeFromLocal: offsetSecondsFromUTC nanoseconds: nanoseconds 	"The receiver's internal state has been set to a timepoint relative to local time in the receiver's current timezone.  If necessary, change the receiver's internal state so that it canonically represents that same local time in the receiver's timezone. The agruments &lt;offsetSecondsFromUTC&gt; and &lt;nanoseconds&gt; are the number of seconds and nanoseconds (respectively) to add to a UTC time in order to derive the same local time in the receiver's timezone.  The value of &lt;nanoseconds&gt; MUST be less than NanosecondsPerSecond."	timeZone isInvariantToUT "When the receiver is invariant to nominal time, all time fields are supposed to be set to their local-time values. If that's already the case, then no action is necessary."		ifTrue: 			["When the receiver is invariant to UT, the &lt;daysSinceEpoch&gt; and &lt;secondsSinceStartOfDay&gt; instance variables are supposed to be set to their UT values."			| netNanoseconds netOffsetSecondsFromUTC |			self assertMutability.			nanoseconds = 0 				ifTrue: [netOffsetSecondsFromUTC := offsetSecondsFromUTC]				ifFalse: 					[netNanoseconds := nanosecondsSinceSecond - nanoseconds.					netNanoseconds &lt; 0 						ifTrue: 							[nanosecondsSinceSecond := netNanoseconds + NanosecondsPerSecond.							netOffsetSecondsFromUTC := offsetSecondsFromUTC + 1]						ifFalse: 							[netNanoseconds &gt;= NanosecondsPerSecond 								ifTrue: 									[nanosecondsSinceSecond := netNanoseconds - NanosecondsPerSecond .									netOffsetSecondsFromUTC := offsetSecondsFromUTC - 1]								ifFalse: 									[nanosecondsSinceSecond := netNanoseconds.									netOffsetSecondsFromUTC := offsetSecondsFromUTC]]].			netOffsetSecondsFromUTC = 0 ifTrue: [^self].	"Subsecond time adjustements cannot, by themselves, change the year or day."			secondsSinceStartOfDay := secondsSinceStartOfDay - netOffsetSecondsFromUTC.			(secondsSinceStartOfDay &lt; 0 or: [secondsSinceStartOfDay &gt;= self secondsInDay]) 				ifTrue: 					[| dayDelta |					daysSinceEpoch == nil 						ifFalse: 							[daysSinceEpoch := daysSinceEpoch + (dayDelta := secondsSinceStartOfDay // SecondsPerDay)].					(timeZone isProxy and: [calendarDay notNil]) "When the receiver is invariant to UT but the timezone is a proxy, the &lt;year&gt; and &lt;calendarDay&gt; instance variables are are supposed to to be set to their UT values."						ifTrue: 							[dayDelta == nil 								ifTrue: [dayDelta := secondsSinceStartOfDay // SecondsPerDay].							dayDelta = 0 ifFalse: [super basicAddDays: dayDelta]].					secondsSinceStartOfDay := secondsSinceStartOfDay \\ self secondsInDay]]</body><body package="Chronos-DateTimeInterval" selector="canonicalizeFromUT:nanoseconds:">canonicalizeFromUT: offsetSecondsFromUT nanoseconds: nanoseconds 	"The receiver's internal state has been set to a timepoint relative to UT.  If necessary, change the receiver's internal state so that it canonically represents that same UT time in the receiver's timezone.  The agruments &lt;offsetSecondsFromUT&gt; and &lt;nanoseconds&gt; are the number of seconds and nanoseconds (respectively) to add to a UT time in order to derive the same local time in the receiver's timezone.  The value of &lt;nanoseconds&gt; MUST be less than NanosecondsPerSecond."	| netNanoseconds netOffsetSecondsFromUT dayDelta |	self assertMutability.	timeZone isInvariantToNominalTime 		ifTrue: 			["When the receiver is invariant to nominal time, all time fields are supposed to be set to their local-time values."			nanoseconds = 0 				ifTrue: [netOffsetSecondsFromUT := offsetSecondsFromUT]				ifFalse: 					[netNanoseconds := nanosecondsSinceSecond + nanoseconds.					netNanoseconds &lt; 0 						ifTrue: 							[nanosecondsSinceSecond := netNanoseconds + NanosecondsPerSecond.							netOffsetSecondsFromUT := offsetSecondsFromUT + 1]						ifFalse: 							[netNanoseconds &gt;= NanosecondsPerSecond 								ifTrue: 									[nanosecondsSinceSecond := netNanoseconds - NanosecondsPerSecond.									netOffsetSecondsFromUT := offsetSecondsFromUT + 1]								ifFalse: 									[nanosecondsSinceSecond := netNanoseconds.									netOffsetSecondsFromUT := offsetSecondsFromUT]]].			netOffsetSecondsFromUT = 0 ifTrue: [^self].	"The local year and day are already correct, since there is less than one second of net offset from UT."			secondsSinceStartOfDay := secondsSinceStartOfDay + netOffsetSecondsFromUT.			(secondsSinceStartOfDay &lt; 0 or: [secondsSinceStartOfDay &gt;= self secondsInDay]) 				ifTrue: 					[| secondsDiv128 secondsMod128 |					secondsDiv128 := secondsSinceStartOfDay bitShift: -7.	"Bit shifting is faster than LargeInteger math."					dayDelta := secondsDiv128 // 675.	"128 * 675 = 86400"					self proxyTimeZoneAddDays: dayDelta.					secondsMod128 := secondsSinceStartOfDay bitAnd: 127.					secondsSinceStartOfDay := 						secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7)	"seconds \\ 128 + (seconds // 128 \\ 675 * 128)"]]		ifFalse: 			["When the receiver is invariant to UT, the &lt;daysSinceEpoch&gt; and &lt;secondsSinceStartOfDay&gt; instance variables are supposed to be set to their UT values."			year == nil ifTrue: [^self]. "The &lt;year&gt; and &lt;calendarDay&gt; are not specified, so there is no need to set them until their values are actually needed."			timeZone isProxy ifTrue: [^self]. "When the receiver is invariant to UT but the timezone is a proxy, the &lt;year&gt; and &lt;calendarDay&gt; instance variables are are supposed to to be set to their UT values--which is already the case."			"When the receiver is invariant to UT and the timezone is NOT a proxy, the &lt;year&gt; and &lt;calendar&gt; instance variables are supposed to be set to their local-time values."			nanoseconds = 0 			ifTrue: [netOffsetSecondsFromUT := offsetSecondsFromUT]			ifFalse: 				[netNanoseconds := nanosecondsSinceSecond + nanoseconds.				netNanoseconds &lt; 0 					ifTrue: [netOffsetSecondsFromUT := offsetSecondsFromUT - 1]					ifFalse: 						[netNanoseconds &gt;= NanosecondsPerSecond 							ifTrue: [netOffsetSecondsFromUT := offsetSecondsFromUT + 1]							ifFalse: [netOffsetSecondsFromUT := offsetSecondsFromUT]]].		netOffsetSecondsFromUT = 0 ifTrue: [^self ]. "The local &lt;year&gt; and &lt;calendarDay&gt; are already correct, since there is less than one second of net offset from UT."		self 				alignCalendarDayWithLocalSecondsSinceStartOfDay: secondsSinceStartOfDay + netOffsetSecondsFromUT]</body><body package="Chronos-DateTimeInterval" selector="deproxifyTimeZone">deproxifyTimeZone	| wasInvariantToUT |	timeZone isProxy ifFalse: [^self].	self assertMutability.	wasInvariantToUT := timeZone isInvariantToUT.	timeZone := timeZone asNonProxy.	wasInvariantToUT 		ifTrue: [self canonicalizeFromUT]		ifFalse: [self canonicalizeFromLocalTime]</body><body package="Chronos-DateTimeInterval" selector="gregorianLocalYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo:">gregorianLocalYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo: block3 	"PRECONDITIONS: Either A) the receiver is invariant to nominal time and the &lt;secondsSinceStartOfDay&gt; instance variable is set to represent local time, or B) the &lt;year&gt; and &lt;calendarDay&gt; instance variables are set to represent local time and the &lt;secondsSinceStartOfDay&gt; instance variable is set to represent UTC time [CONSEQUENTLY, the receiver's timeZone must not be a ProxyTZ unless it is the NominalTimeInvariantTZ.]."	| ymd |	^self isGregorian 		ifTrue: 			[block3 				value: self year				value: self dayOfYearOrdinal				value: 					(self isInvariantToUT 						ifTrue: [[:offsetSecondsFromUT | secondsSinceStartOfDay + offsetSecondsFromUT]]						ifFalse: [[:offsetSecondsFromUT | secondsSinceStartOfDay]])]		ifFalse: 			[| localDaysSinceEpoch |			localDaysSinceEpoch := 				self isInvariantToNominalTime 					ifTrue: [self daysSinceEpoch]					ifFalse: [self basicComputeDaysSinceEpoch].			ymd := self calendar gregorianDateSpecFromDaysSinceEpoch: localDaysSinceEpoch.			block3 				value: ymd year				value: ymd dayOfYearOrdinal				value: (self isInvariantToUT 						ifTrue: 							[[:offsetSecondsFromUT | 							((self calendar 								secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay) 									+ offsetSecondsFromUT) \\ self secondsInDay]]						ifFalse: 							[[:offsetSecondsFromUT | 							(self calendar 								secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay) 									\\ self secondsInDay]])]</body><body package="Chronos-DateTimeInterval" selector="offsetSecondsFromUT">offsetSecondsFromUT	^nanosecondsSinceSecond = 0 		ifTrue: [self timeZone offsetSecondsFromUT]		ifFalse: 			[self timeZone 				netSecondsAfterAddingOffsetFromUTToSeconds: 0				nanosecondsSinceSecond: nanosecondsSinceSecond]</body><body package="Chronos-DateTimeInterval" selector="unbindTimeZone">unbindTimeZone	timeZone == nil ifFalse: [timeZone := timeZone asUnbound]</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="alignCalendarDayWithLocalSecondsSinceStartOfDay:">alignCalendarDayWithLocalSecondsSinceStartOfDay: localSecondsSinceStartOfDay	"PRECONDITION: Neither &lt;year&gt; nor &lt;calendarDay&gt; are nil."	| offsetSecondsFromUTC |	timeZone isProxy		ifFalse: 			[offsetSecondsFromUTC := localSecondsSinceStartOfDay - secondsSinceStartOfDay.			offsetSecondsFromUTC abs &gt;= self secondsInDay 				ifTrue: [super basicAddDays: localSecondsSinceStartOfDay // SecondsPerDay]				ifFalse: 					["Avoid division for the common case."					localSecondsSinceStartOfDay &lt; 0 						ifTrue: [super basicAddDays: -1]						ifFalse:							[localSecondsSinceStartOfDay &gt;= self secondsInDay								ifTrue: [super basicAddDays: 1]]]]</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTime">asMutableDateAndTime	^self copy</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTimeInvariantToUT">asMutableDateAndTimeInvariantToUT	^timeZone isInvariantToUT 		ifTrue: [self copy]		ifFalse: [self copy deproxifyTimeZone]</body><body package="Chronos-DateTimeInterval" selector="asMutableTimeOfDay">asMutableTimeOfDay	^self copy</body><body package="Chronos-DateTimeInterval" selector="basicDaysSinceEpoch">basicDaysSinceEpoch	self ensureDaysSinceEpochIsSet.	^daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecond">basicNanosecondsSinceSecond	^nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceStartOfDay">basicNanosecondsSinceStartOfDay	^secondsSinceStartOfDay * NanosecondsPerSecond + nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="basicSecondsSinceStartOfDay">basicSecondsSinceStartOfDay	^secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="changedSecondsSinceStartOfDay">changedSecondsSinceStartOfDay	(secondsSinceStartOfDay &lt; 0 or: [secondsSinceStartOfDay &gt;= self secondsInDay]) 		ifTrue: 			[| secondsDiv128 secondsMod128 dayDelta |			self assertMutability.			secondsDiv128 := secondsSinceStartOfDay bitShift: -7.			dayDelta := secondsDiv128 // 675. 			secondsMod128 := secondsSinceStartOfDay bitAnd: 127.			secondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7).			timeZone isProxyOrStatic 				ifTrue: [self proxyTimeZoneAddDays: dayDelta]				ifFalse: 					[daysSinceEpoch := self basicDaysSinceEpoch + dayDelta.					self 						unbindTimeZone;						invalidateYearAndCalendarDay]]		ifFalse: 			[timeZone isProxy ifTrue: [^self].			self 				unbindTimeZone;				invalidateYearAndCalendarDay]</body><body package="Chronos-DateTimeInterval" selector="computeDaysSinceEpoch">computeDaysSinceEpoch	^timeZone isProxy		ifTrue: [self basicComputeDaysSinceEpoch]		ifFalse: 			[| tz offsetSecondsFromUTC localSeconds days secondsInDay |			days := self basicComputeDaysSinceEpoch.			tz := self timeZone.			tz offsetIsZero ifTrue: [^days].			localSeconds := tz 								netSecondsAfterAddingOffsetFromUTToSeconds: secondsSinceStartOfDay								nanosecondsSinceSecond: nanosecondsSinceSecond.			offsetSecondsFromUTC := localSeconds - secondsSinceStartOfDay.			offsetSecondsFromUTC abs &gt;= (secondsInDay := self secondsInDay) 				ifTrue: 					[days := days - (localSeconds // SecondsPerDay).					localSeconds := localSeconds \\ secondsInDay]				ifFalse: 					["Avoid division for the common case."					localSeconds &lt; 0 						ifTrue: 							[localSeconds := localSeconds + secondsInDay.							days := days + 1]						ifFalse: 							[localSeconds &gt;= secondsInDay 								ifTrue: 									[localSeconds := localSeconds - secondsInDay.									days := days - 1]]].			days]</body><body package="Chronos-DateTimeInterval" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	| unboundTz |	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self basicSecondsSinceStartOfDay;		nextPut: self basicNanosecondsSinceSecond.	unboundTz := timeZone asUnbound.	stream nextPut: 		(unboundTz keyIsGlobal 			ifTrue: [unboundTz key]			ifFalse: [unboundTz literalArrayEncoding]).</body><body package="Chronos-DateTimeInterval" selector="ensureDaysSinceEpochIsSet">ensureDaysSinceEpochIsSet	daysSinceEpoch = nil 		ifTrue: [daysSinceEpoch := self computeDaysSinceEpoch]</body><body package="Chronos-DateTimeInterval" selector="ensureYearAndCalendarDayAreSet">ensureYearAndCalendarDayAreSet	year == nil ifTrue: [self setYearAndCalendarDay].</body><body package="Chronos-DateTimeInterval" selector="invalidateDaysSinceEpoch">invalidateDaysSinceEpoch		self ensureYearAndCalendarDayAreSet.	daysSinceEpoch := nil.</body><body package="Chronos-DateTimeInterval" selector="invalidateYearAndCalendarDay">invalidateYearAndCalendarDay		self ensureDaysSinceEpochIsSet.	year := nil.	calendarDay := nil.</body><body package="Chronos-DateTimeInterval" selector="preservingCivilTimeOfDayDo:">preservingCivilTimeOfDayDo: civilTimeOfDayPreservingAction 	| oldOffsetSecondsFromUTC delta |	oldOffsetSecondsFromUTC := self offsetSecondsFromUT.	civilTimeOfDayPreservingAction value.	delta := oldOffsetSecondsFromUTC - self offsetSecondsFromUT.	delta = 0 ifFalse: [secondsSinceStartOfDay := secondsSinceStartOfDay + delta]</body><body package="Chronos-DateTimeInterval" selector="setYearAndCalendarDay">setYearAndCalendarDay	| savedLock |	savedLock := lock.	lock := nil.	timeZone isInvariantToUT 		ifTrue: 			[timeZone isProxyOrStatic ifFalse: [timeZone isBound ifFalse: [self timeZone]]. 			"If the receiver's timeZone is not a proxy, then retrieving the receiver's (bound) timeZone will usually result in the &lt;year&gt; and &lt;calendarDay&gt; being opportunistically set as a side effect.  Consequently, explicitly requesting the bound timeZone right at this point in the logic, then checking whether the year is set, makes it possible to avoid unecessarily doing the computation twice in such cases.   In the case of UT time invariant Timepoints, the timeZone must be bound in any case in order to compute the local year and calendarDay from the &lt;daysSinceEpoch&gt; and &lt;secondsSinceStartOfDay&gt; instance variables, which are both specified as UT values."			year == nil 				ifTrue: 					[self setYearAndCalendarDayFromDaysSinceEpoch: 						(timeZone isProxyAndInvariantToUT 							ifTrue: [self utDaysSinceEpoch]							ifFalse: [self daysSinceEpoch])]]		ifFalse: [self setYearAndCalendarDayFromDaysSinceEpoch: self basicDaysSinceEpoch].	lock := savedLock</body><body package="Chronos-DateTimeInterval" selector="setYearAndCalendarDayFromDaysSinceEpoch:">setYearAndCalendarDayFromDaysSinceEpoch: days	self calendar		forDaysSinceEpoch: days 		setYearAndCalendarDayInto: self.</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>private-initialize-release</category><body package="Chronos-DateTimeInterval" selector="basicAddSecondsSinceStartOfDay:">basicAddSecondsSinceStartOfDay: seconds	self assertMutability.	secondsSinceStartOfDay :=  secondsSinceStartOfDay + seconds</body><body package="Chronos-DateTimeInterval" selector="basicSetDaysSinceEpoch:">basicSetDaysSinceEpoch: days 	self assertMutability.	days isInteger 		ifTrue: [daysSinceEpoch := days]		ifFalse: 			[daysSinceEpoch := days truncated.			self basicSetSecondsSinceStartOfDay: (days - daysSinceEpoch) * self secondsInDay]</body><body package="Chronos-DateTimeInterval" selector="basicSetSecondsSinceEpoch:">basicSetSecondsSinceEpoch: secondsSinceEpoch 	| seconds secondsDiv128 secondsMod128 |	self assertMutability.	secondsSinceEpoch isInteger 		ifTrue: [seconds := secondsSinceEpoch]		ifFalse: 			[seconds := secondsSinceEpoch truncated.			self setNanosecondsSinceSecond: (secondsSinceEpoch - seconds) * NanosecondsPerSecond].	secondsDiv128 := seconds bitShift: -7.	"Bit shifting is faster than LargeInteger math."	daysSinceEpoch := secondsDiv128 // 675.	"128 * 675 = 86400"	secondsMod128 := seconds bitAnd: 127.	secondsSinceStartOfDay := secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7)	"seconds \\ 128 + (seconds // 128 \\ 675 * 128)"</body><body package="Chronos-DateTimeInterval" selector="basicSetSecondsSinceStartOfDay:">basicSetSecondsSinceStartOfDay: s 	| seconds |	self assertMutability.	s isInteger 		ifTrue: [seconds := s]		ifFalse: 			[seconds := s truncated.			self setNanosecondsSinceSecond: (s - seconds) * NanosecondsPerSecond].	secondsSinceStartOfDay := seconds</body><body package="Chronos-DateTimeInterval" selector="basicSetTimeZone:">basicSetTimeZone: aTimeZone	self assertMutability.	timeZone := aTimeZone</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="&lt;&lt;">&lt;&lt; aChronosTimezone 	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but convert the date and time-of-day as though the receiver represented a date and time in the current default time zone (i.e,. preserve date and time-of-day in Universal Time as though the receiver represented a date and time in the current default time zone.)	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is the same as that of the receiver (i.e,, preserve local date and local time-of-day, don't preserve date or time-of-day in Universal Time.)"	"Timepoint now &lt;&lt; 10 hours"	"Timepoint now &lt;&lt; 'Australia/Adelaide'"	"Timepoint now &lt;&lt; #nominal"	"(Timepoint nowIn: 'Pacific/Kiritimati') &lt;&lt; #nominal"	"(Timepoint nowIn: 'Pacific/Kiritimati') &lt;&lt; #default"	"(Timepoint nowIn: 'Pacific/Kiritimati') &lt;&lt; #system"	"Timepoint nominalNow &lt;&lt; 10 hours"	"Timepoint nominalNow &lt;&lt; 'Australia/Adelaide'"	^(self isInvariantToUT 		ifTrue: 			[(self asMutableDateAndTime)				convertToTimeZone: ChronosTimezone nominal;				convertToTimeZone: (ChronosTimezone referencedBy: aChronosTimezone)]		ifFalse: 			[(self asMutableDateAndTime)				deproxifyTimeZone;				convertToTimeZone: (ChronosTimezone referencedBy: aChronosTimezone)]) beImmutable</body><body package="Chronos-DateTimeInterval" selector="&gt;&gt;">&gt;&gt; aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"{DateAndTimeFactory now &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTimeFactory nominalNow &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTimeFactory now &gt;&gt; ChronosTimezone nominal}"	| newTimeZone |	newTimeZone := (ChronosTimezone referencedBy:  aChronosTimezone) root.	newTimeZone == timeZone root ifTrue: [^self isMutable ifTrue: [self copy] ifFalse: [self]].	^self copy 		convertToTimeZone: newTimeZone;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asBoundToStaticTimeZone">asBoundToStaticTimeZone	"(Timezone at: 'Australia/Adelaide') now asBoundToStaticTimeZone"	^timeZone isStatic 		ifFalse: 			[(self copy)				convertToTimeZone: self timeZone asStatic;				beImmutable]</body><body package="Chronos-DateTimeInterval" selector="asBoundToTimeZone">asBoundToTimeZone	^timeZone isProxy 		ifTrue: 			[(self copy)				deproxifyTimeZone;				beImmutable]		ifFalse: [self]</body><body package="Chronos-DateTimeInterval" selector="asDate">asDate	"Answer the conversion of the receiver into a date-valued CalendricalCoordinate that represents the same date as does the receiver.  If the receiver is already a date-valued CalendricalCoordinate, answer the receiver.  A date-valued CalendricalCoordinate is one that specifies a date without specifying a particular time-of-day nor a particular timezone (i.e., it has nominal time semantics, and its quantum of resolution is 1 calendar day.)"	^self class dateFactory 		year: self year		month: self month		day: self dayOfMonth		calendar: self calendar</body><body package="Chronos-DateTimeInterval" selector="asDateAndTime">asDateAndTime	"Answer the conversion of the receiver into a DateAndTime value that represents the same point-in-time as does the receiver.  If the receiver is already a DateAndTime value, answer the receiver.  A DateAndTime value is a CalendricalCoordinate that specifies a point-in-time, with a quantum of resolution no larger than one second, with behavior/semantics that is invariant to UT, and that conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol. See the class comment of Timepoint for further clarification."	^self asInvariantToUT</body><body package="Chronos-DateTimeInterval" selector="asDateAndTimeIn:">asDateAndTimeIn: aChronosTimezone	^self &gt;&gt; aChronosTimezone</body><body package="Chronos-DateTimeInterval" selector="asInvariantToNominalTime">asInvariantToNominalTime	"Answer a value equivalent to that of the receiver in all respects, except that its semantics/behavior is invariant to nominal time.  If the receiver is already nominal-time invariant, answer the receiver. See the class comment of Timepoint for further clarification."	"Timepoint now asInvariantToNominalTime"	^timeZone isInvariantToUT 		ifTrue: 			[(self copy)				convertToTimeZone: self class nominalTZ;				beImmutable]		ifFalse: [self]</body><body package="Chronos-DateTimeInterval" selector="asInvariantToUT">asInvariantToUT	"Answer a value equivalent to that of the receiver in all respects, except that it has UT-invariant behavior/semantics.  If the receiver is already invariant-to-UT, answer the receiver. See the class comment of Timepoint for further clarification."	^timeZone isInvariantToUT		ifTrue: [self]		ifFalse: [self in: ChronosTimezone default]</body><body package="Chronos-DateTimeInterval" selector="asLocal">asLocal	"Specified and required by the ANSI-Smalltalk Standard."	^self &gt;&gt; ChronosTimezone default</body><body package="Chronos-DateTimeInterval" selector="asNative">asNative	"Answer the native system's 'Timestamp' analog (or 'Date' analog, if no Timestamp analog is available) that semantically corresponds as closely as possible to the receiver."	"{Julian clock now asNative}"	^self clock nativeCalendricalCoordinateFromChronosDateAndTime: self</body><body package="Chronos-DateTimeInterval" selector="asNominalDateAndTime">asNominalDateAndTime	"Answer the conversion of the receiver into a nominal-time-invariant DateAndTime value that represents the same local point-in-time as does the receiver.  If the receiver is already a nominal-time-invariant DateAndTime value, answer the receiver.  A nominal-time-invariant DateAndTime value is a CalendricalCoordinate that nominally specifies a point-in-time without reference to any particular timezone, and has a quantum of resolution no larger than one second. A nominal-time-invariant DateAndTime value conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol EXCEPT that its behavior/semantics is invariant to nominal time, as opposed to being UT invariant. See the class comment of Timepoint for further clarification."	^self asInvariantToNominalTime</body><body package="Chronos-DateTimeInterval" selector="asSpec">asSpec	^self dateAndTimeSpec</body><body package="Chronos-DateTimeInterval" selector="asUT">asUT	^self localTimeIsUniversal 		ifTrue: [self asBoundToTimeZone]		ifFalse: 			[timeZone isInvariantToNominalTime				ifTrue: 					[self copy						basicSetTimeZone: self class universalTZ;						beImmutable]				ifFalse: [self in: self class universalTZ]]</body><body package="Chronos-DateTimeInterval" selector="dateSpec">dateSpec	^(year == nil or: [timeZone isProxyAndInvariantToUT])		ifTrue: [self calendar dateSpecFromDaysSinceEpoch: self daysSinceEpoch]		ifFalse: [super dateSpec]</body><body package="Chronos-DateTimeInterval" selector="utDateSpec">utDateSpec	^timeZone isProxy		ifTrue: 			[self ensureYearAndCalendarDayAreSet.			DateSpec year: year calendarDay: calendarDay]		ifFalse: [super utDateSpec]</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>private-comparing</category><body package="Chronos-DateTimeInterval" selector="compareToDate:">compareToDate: aDate	^(aDate compareToDateAndTime: self) negated</body><body package="Chronos-DateTimeInterval" selector="compareToDateAndTime:">compareToDateAndTime: aDateAndTime	| diff |	diff := aDateAndTime basicSecondsSince: self.	diff = 0 ifFalse: [^diff].	^(timeZone isInvariantToUT and: [aDateAndTime isInvariantToUT])		ifTrue: [aDateAndTime utNanosecondsSinceSecond - self utNanosecondsSinceSecond]		ifFalse: [aDateAndTime nanosecondsSinceSecond - self nanosecondsSinceSecond]</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="addHours:">addHours: hours 	self addSeconds: hours * SecondsPerHour</body><body package="Chronos-DateTimeInterval" selector="addHours:minutes:">addHours: hours minutes: minutes	self addSeconds: hours * SecondsPerHour + (minutes * SecondsPerMinute)</body><body package="Chronos-DateTimeInterval" selector="addHours:minutes:seconds:">addHours: hours minutes: minutes seconds: seconds 	self addSeconds: hours * SecondsPerHour + (minutes * SecondsPerMinute) + seconds</body><body package="Chronos-DateTimeInterval" selector="addHours:minutes:seconds:nanoseconds:">addHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	self 		addSeconds: hours * SecondsPerHour + (minutes * SecondsPerMinute) + seconds		nanoseconds: nanoseconds</body><body package="Chronos-DateTimeInterval" selector="addMinutes:">addMinutes: minutes 	self addSeconds: minutes * SecondsPerMinute</body><body package="Chronos-DateTimeInterval" selector="addMonths:">addMonths: months 	"Add the given number of civil months to the date represented by the receiver, preserving the same civil time-of-day.   The new dayOfMonth will be the same as it had been, unless it would be invalid.  For example, if the orignal date was March 31, the new dayOfMonth will also be 31, unless the new month has less than 31 days. In such a case, the receiver's new dayOfMonth will be the last day of the receiver's new month.	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal."	| dayFraction |	months = 0 ifTrue: [^self].	timeZone isProxyOrStatic		ifTrue: [dayFraction := self basicAddMonths: months days: 0]		ifFalse: [self preservingCivilTimeOfDayDo: [dayFraction := self basicAddMonths: months days: 0]].	dayFraction = 0 ifFalse: [self addSeconds: dayFraction * self secondsInDay]</body><body package="Chronos-DateTimeInterval" selector="addSeconds:">addSeconds: seconds	"Add the given number of scientific seconds to the timepoint represented by the receiver. The scientific semantics of a timepoint S seconds from another will be respected (UT)."	seconds = 0 ifTrue: [^self].	self isImmutable ifTrue: [^self addingSeconds: seconds].	self addSeconds: seconds nanoseconds: 0</body><body package="Chronos-DateTimeInterval" selector="addSeconds:nanoseconds:">addSeconds: seconds nanoseconds: nanoseconds 	"Add the given number of scientific seconds and nanoseconds to the timepoint represented by the receiver. The scientific semantics of a timepoint S seconds and N nanoseconds from another will be respected (UT)."	| nanoSecondsToAdd secondsToAdd |	self assertMutability.	nanoSecondsToAdd := seconds isInteger		ifTrue: 			[secondsToAdd := seconds.			nanoseconds rounded]		ifFalse:			[secondsToAdd := seconds truncated.			((seconds - secondsToAdd) * NanosecondsPerSecond) rounded + nanoseconds rounded].	nanoSecondsToAdd = 0		ifFalse:			[nanosecondsSinceSecond := nanosecondsSinceSecond + nanoSecondsToAdd.			(nanosecondsSinceSecond &lt; 0 				or: [nanosecondsSinceSecond &gt;= NanosecondsPerSecond]) 					ifTrue: 						[secondsToAdd := secondsToAdd +  ((nanosecondsSinceSecond bitShift: -9) // 1953125).						nanosecondsSinceSecond := nanosecondsSinceSecond \\ NanosecondsPerSecond]].	secondsToAdd = 0		ifFalse:			[timeZone isProxy ifFalse: [self ensureDaysSinceEpochIsSet].			secondsSinceStartOfDay := secondsSinceStartOfDay + secondsToAdd.			self changedSecondsSinceStartOfDay]</body><body package="Chronos-DateTimeInterval" selector="addYears:">addYears: years 	"Add the given number of civil years to the date represented by the receiver, preserving the same civil time-of-day.  The civil intra-year date in the new year will be the same as in the old year, unless it would be invalid.   For example, if the orignal date is March 1 in a Gregorian/Julian leap year, the date in the new year will remain March 1 after adding the specified years.  However, if the original date is February 29 and the new year is not a leap year, then the new date will be Feb 28.   	In the case of Calendar systems with intercalary months, analogous rules apply to the monthOrdinal.  If intercalary months may occur at times other than the end of the year, the Calendar system's cultural tradition will be respected regarding the semantics of 'same civil date N years later (or earlier.)'  The implementation assumes that the only issue in that respect is whether or not 'same month' is defined by the monthOrdinal or by the monthKey (by definition of a Chronos monthKey, months with the same monthKey are semantically the same month, regardless of possibly having different monthOrdinals in different years--which does happen in some Calendars!.)"	| remainingDays |	years = 0 ifTrue: [^self].	timeZone isProxyOrStatic		ifTrue: [remainingDays := (self basicAddYears: years)]		ifFalse: [self preservingCivilTimeOfDayDo: [remainingDays := (self basicAddYears: years)]].	remainingDays = 0 ifFalse: [self basicAddDays: remainingDays]</body><body package="Chronos-DateTimeInterval" selector="addYears:months:days:">addYears: years months: months days: days 	"Add the given number of civil years, months and days, and the given number of scientific seconds and nanoseconds, to the date represented by the receiver.  The traditions/conventions of the receiver's calendar with respect to the semantics of 'a date Y civil years, M civil months and D civil days away from another date' will be respected..	See the specifications/comments for #addYears:, #addMonths:and #addDays for more detailed/precise semantics."	(days = 0 and: [months = 0 and: [years = 0]]) 		ifFalse: 			[| dayFraction daysToAdd |			years = 0 				ifTrue: [daysToAdd := days]				ifFalse: [daysToAdd := days + (self basicAddYears: years)].			daysToAdd isInteger				ifTrue: [dayFraction := 0]				ifFalse: 					[| int |					int := daysToAdd truncated.					dayFraction := daysToAdd - int.					daysToAdd := int].			months = 0				ifTrue:					[timeZone isProxyOrStatic 						ifTrue: [daysToAdd = 0 ifFalse: [self proxyTimeZoneAddDays: daysToAdd]]						ifFalse:							[self preservingCivilTimeOfDayDo: 								[daysToAdd = 0 ifFalse: [self nonProxyTimeZoneAddDays: daysToAdd]]]]				ifFalse: 					[timeZone isProxyOrStatic 						ifTrue: [dayFraction := self basicAddMonths: months days: daysToAdd + dayFraction]						ifFalse:							[self preservingCivilTimeOfDayDo: 								[dayFraction := self basicAddMonths: months days: daysToAdd + dayFraction]]].			dayFraction = 0 ifFalse: [self addSeconds: dayFraction * self secondsInDay]].</body><body package="Chronos-DateTimeInterval" selector="beImmutable">beImmutable	"Make the receiver immutable.  Idempotent.  Must answer the receiver."	timeZone == nil ifTrue: [self canonicalize].	lock := #immutable</body><body package="Chronos-DateTimeInterval" selector="beInvariantToNominalTime">beInvariantToNominalTime	self convertToTimeZone: ChronosTimezone nominal</body><body package="Chronos-DateTimeInterval" selector="beInvariantToUT">beInvariantToUT	self isInvariantToUT		ifFalse: [self convertToTimeZone: ChronosTimezone default]</body><body package="Chronos-DateTimeInterval" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	timeZone == nil ifTrue: [timeZone := self class nominalTZ].	nanosecondsSinceSecond == nil ifTrue: [nanosecondsSinceSecond := 0].		secondsSinceStartOfDay == nil ifTrue: [secondsSinceStartOfDay := 0].</body><body package="Chronos-DateTimeInterval" selector="canonicalizeFromLocalTime">canonicalizeFromLocalTime	"The receiver's internal state has been set to a timepoint relative to local time in the receiver's current timezone.  If necessary, change the receiver's internal state so that it canonically represents that same local time in the receiver's timezone."	secondsSinceStartOfDay == nil ifTrue: [secondsSinceStartOfDay := 0].	nanosecondsSinceSecond == nil ifTrue: [nanosecondsSinceSecond := 0].	timeZone == nil ifTrue: [timeZone := self calendar defaultTimeZone].	timeZone isInvariantToUT 		ifTrue: 			[| annualPolicy boundTZ |			timeZone isBound 				ifTrue: [boundTZ := timeZone binding]				ifFalse: 					[annualPolicy := 						self basicGregorianYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo: 								[:y :dayOfYear :sssodFunction | 									timeZone 										annualPolicyForLocalYear: y										dayOfYear: dayOfYear										secondsSinceStartOfDayFunction: sssodFunction].					timeZone isProxy ifFalse: [timeZone := annualPolicy].					boundTZ := annualPolicy binding].			boundTZ canonicalizeFromLocal: self]</body><body package="Chronos-DateTimeInterval" selector="canonicalizeFromUT">canonicalizeFromUT	"The receiver's internal state has been set to a timepoint relative to UT.  If necessary, change the receiver's internal state so that it canonically represents that same UT time in the receiver's timezone."	| boundTZ |	secondsSinceStartOfDay == nil ifTrue: [secondsSinceStartOfDay := 0].	nanosecondsSinceSecond == nil ifTrue: [nanosecondsSinceSecond := 0].	timeZone == nil ifTrue: [timeZone := self calendar defaultTimeZone].	timeZone isProxy		ifTrue: [timeZone isInvariantToUT ifTrue: [^self]]		ifFalse: [year == nil ifTrue: [^self]].	timeZone isBound		ifTrue: [boundTZ := timeZone binding]		ifFalse:			[| annualPolicy |			annualPolicy := 				self basicGregorianYearAndDayOfYearAndSecondsSinceStartOfDayFunctionDo: 						[:y :dayOfYear :sssodFunction | 							timeZone 								bindingForUTYear: y								dayOfYear: dayOfYear								secondsSinceStartOfDayFunction: sssodFunction].			timeZone isProxy ifFalse: [timeZone := annualPolicy].			boundTZ := annualPolicy binding].	boundTZ canonicalizeFromUT: self</body><body package="Chronos-DateTimeInterval" selector="convertToCalendar:">convertToCalendar: otherCalendar 	"Make the receiver represent a calendrical coordinate whose Calendar is &lt;otherCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history) as does the receiver."	| originalCalendar secondsSinceEpoch |	originalCalendar := self calendar.	originalCalendar == otherCalendar ifTrue: [^self].	secondsSinceEpoch := 		self isInvariantToNominalTime 			ifTrue: [self secondsSinceEpoch]			ifFalse: [self utSecondsSinceEpoch].	self		basicSetCalendar: otherCalendar;		setSecondsSinceEpoch: 			(otherCalendar 				secondsSinceEpochFromForeignSecondsSinceEpoch: secondsSinceEpoch				convertingFrom: originalCalendar)</body><body package="Chronos-DateTimeInterval" selector="convertToTimeZone:">convertToTimeZone: aTimeZone 	| newTimeZone |	timeZone == nil 		ifTrue: [timeZone := self class nominalTZ].	newTimeZone := aTimeZone root.	timeZone root == newTimeZone ifTrue: [^self].	self assertMutability.	timeZone isInvariantToUT 		ifTrue: 			[newTimeZone isInvariantToUT 				ifTrue: 					[newTimeZone isProxy 						ifTrue: [timeZone isProxy ifFalse: [self invalidateYearAndCalendarDay]]						ifFalse: [self invalidateYearAndCalendarDay].					self basicSetTimeZone: newTimeZone]				ifFalse: 					[timeZone isProxy 						ifTrue: 							[self basicSetTimeZone: newTimeZone.							self canonicalizeFromUT]						ifFalse: 							[secondsSinceStartOfDay := self secondsSinceStartOfDay.							self invalidateDaysSinceEpoch.							self basicSetTimeZone: newTimeZone]]]		ifFalse: 			[self basicSetTimeZone: newTimeZone.			self canonicalizeFromLocalTime]</body><body package="Chronos-DateTimeInterval" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	daysSinceEpoch := 0.	secondsSinceStartOfDay := 0.	nanosecondsSinceSecond := 0.	timeZone := self class nominalTZ</body><body package="Chronos-DateTimeInterval" selector="initializeFrom:">initializeFrom: aCalendricalCoordinate	self		basicSetCalendar: aCalendricalCoordinate calendar;		setTimeZone: aCalendricalCoordinate basicTimeZone;		setNanosecondsSinceSecond: aCalendricalCoordinate basicNanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: aCalendricalCoordinate basicSecondsSinceStartOfDay;		basicSetDaysSinceEpoch: aCalendricalCoordinate basicDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self 		setTimeZone:  (literalArray at: 6) decodeAsLiteralArray;		setNanosecondsSinceSecond: (literalArray at: 5) asNumber;		basicSetSecondsSinceStartOfDay: (literalArray at: 4) asNumber</body><body package="Chronos-DateTimeInterval" selector="invalidateTimezone">invalidateTimezone	"Ensure that the receiver's internal state is consistent with respect to the current ruleset of the canonical instance of its timezone."	timeZone == nil 		ifTrue: 			[timeZone := self class nominalTZ.			self invalidateDaysSinceEpoch]		ifFalse: 			[timeZone isProxyOrStatic ifFalse: [self invalidateYearAndCalendarDay].			timeZone := timeZone canonical]</body><body package="Chronos-DateTimeInterval" selector="setDaysSinceEpoch:">setDaysSinceEpoch: days	self basicSetDaysSinceEpoch: days.	self invalidateYearAndCalendarDay.	self unbindTimeZone</body><body package="Chronos-DateTimeInterval" selector="setHour:minute:second:">setHour: hour minute: minute second: second 	self 		validateHour: hour		minute: minute		second: second.	self calendar timeOfDayClockStartsAtStartOfDay 		ifTrue: [self setSecondsSinceStartOfDay: hour * SecondsPerHour + (minute * SecondsPerMinute) + second]		ifFalse: [self setSecondsSinceMidnight: hour * SecondsPerHour + (minute * SecondsPerMinute) + second]</body><body package="Chronos-DateTimeInterval" selector="setJulianDay:">setJulianDay: julianDay 	self setSecondsSinceEpoch: (self calendar secondsSinceEpochFromJulianDay: julianDay)</body><body package="Chronos-DateTimeInterval" selector="setJulianDay:seconds:nanoseconds:">setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds 	self 		setNanosecondsSinceSecond: nanoseconds;		setSecondsSinceEpoch: (self calendar secondsSinceEpochFromJulianDay: julianDay) + seconds</body><body package="Chronos-DateTimeInterval" selector="setNanosecondsSinceEpoch:">setNanosecondsSinceEpoch: nanoseconds	| n |	n := nanoseconds rounded.	self 		setNanosecondsSinceSecond: n \\ NanosecondsPerSecond;		setSecondsSinceEpoch: (n bitShift: -9) // 1953125</body><body package="Chronos-DateTimeInterval" selector="setNanosecondsSinceSecond:">setNanosecondsSinceSecond: n	self assertMutability.	"NanosecondsSinceSecondRangeConstraint assertValid: n."	nanosecondsSinceSecond := n truncated</body><body package="Chronos-DateTimeInterval" selector="setOffset:">setOffset: aDuration	self convertToTimeZone: aDuration asTimezone</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceEpoch:">setSecondsSinceEpoch: seconds 	self 		basicSetSecondsSinceEpoch: seconds;		invalidateYearAndCalendarDay;		unbindTimeZone</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceMidnight:">setSecondsSinceMidnight: s 	| seconds |	self calendar midnightIsStartOfDay 		ifTrue: [self setSecondsSinceStartOfDay: s]		ifFalse: 			[s isInteger				ifTrue: [seconds := s]				ifFalse:					[seconds := s truncated.					self setNanosecondsSinceSecond: (s - seconds) * NanosecondsPerSecond].			self setSecondsSinceStartOfDay: 					(self calendar secondsSinceStartOfDayFromSecondsSinceMidnight: seconds) \\ self secondsInDay].</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceStartOfDay:">setSecondsSinceStartOfDay: s	secondsSinceStartOfDay = s ifTrue: [^self].	self basicSetSecondsSinceStartOfDay: s.	self unbindTimeZone</body><body package="Chronos-DateTimeInterval" selector="setTimeOfDay:">setTimeOfDay: aTimeOfDay 	self		setNanosecondsSinceSecond: aTimeOfDay nanosecondsSinceSecond;		setHour: aTimeOfDay hour			minute: aTimeOfDay minute			second: aTimeOfDay second</body><body package="Chronos-DateTimeInterval" selector="setTimeZone:">setTimeZone: aTimeZone 	self assertMutability.	timeZone := ChronosTimezone referencedBy: aTimeZone.</body><body package="Chronos-DateTimeInterval" selector="setYear:calendarDay:">setYear: aYear calendarDay: aCalendarDay 	self basicSetYear: aYear calendarDay: aCalendarDay.	self invalidateDaysSinceEpoch.	self unbindTimeZone</body><body package="Chronos-DateTimeInterval" selector="setYear:calendarDay:daysSinceEpoch:">setYear: aYear calendarDay: aCalendarDay daysSinceEpoch: days	self basicSetYear: aYear calendarDay: aCalendarDay.	daysSinceEpoch := days.	self unbindTimeZone</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToDateAndTime: self] 			on: MessageNotUnderstood 			do: [:ex | 				((ex receiver == aCalendrical) and: [#compareToDateAndTime: == ex message selector])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isAtStartOfDay">isAtStartOfDay	^self nanosecondsSinceSecond = 0 and: [self secondsSinceStartOfDay = 0]</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfHour">isAtStartOfHour	self subsecondsAreZero ifFalse: [^false].	^(self secondsSinceStartOfDay \\ SecondsPerHour) = 0</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfMinute">isAtStartOfMinute	self subsecondsAreZero ifFalse: [^false].	^(self secondsSinceStartOfDay \\ SecondsPerMinute) = 0</body><body package="Chronos-DateTimeInterval" selector="isBoundToTimeZone">isBoundToTimeZone	^timeZone isProxy not</body><body package="Chronos-DateTimeInterval" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^false</body><body package="Chronos-DateTimeInterval" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer true if the receiver always represents an invariant nominal local time ('3 pm local time') in whatever Timezone to which it may be bound. Otherwise, answer false."	^timeZone isInvariantToNominalTime</body><body package="Chronos-DateTimeInterval" selector="isInvariantToUT">isInvariantToUT	"Answer true if the receiver always represents an invariant nominal UT time ('3 pm UT') in whatever Timezone to which it may be bound. Otherwise, answer false."	^timeZone isInvariantToUT</body><body package="Chronos-DateTimeInterval" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^true</body><body package="Chronos-DateTimeInterval" selector="localTimeIsUniversal">localTimeIsUniversal	^timeZone isUniversalTime</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>accessing-UT</category><body package="Chronos-DateTimeInterval" selector="utJulianDay">utJulianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs (Universal Time.) However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered (also Universal Time.)"	^self calendar julianDayFromSecondsSinceEpoch: self utSecondsSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceEpoch">utNanosecondsSinceEpoch	^(self utDaysSinceEpoch * 675 bitShift: 7) * NanosecondsPerSecond + self utNanosecondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceSecond">utNanosecondsSinceSecond	^nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceStartOfDay">utNanosecondsSinceStartOfDay	^self basicNanosecondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch">utSecondsSinceEpoch	^self basicSecondsSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceStartOfDay">utSecondsSinceStartOfDay	^secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="basicAddDays:">basicAddDays: dayDelta 	"Add the given number of civil days to the date represented by the receiver, preserving the same civil time-of-day."	| daysToAdd dayFraction |	dayDelta = 0 ifTrue: [^self].	dayDelta isInteger		ifTrue: 			[daysToAdd := dayDelta.			dayFraction := 0]		ifFalse:			[daysToAdd := dayDelta truncated.			dayFraction := dayDelta - daysToAdd].	timeZone isProxyOrStatic 		ifTrue: [self proxyTimeZoneAddDays: daysToAdd]		ifFalse: [self preservingCivilTimeOfDayDo: [self nonProxyTimeZoneAddDays: daysToAdd]].	dayFraction = 0 ifFalse: [self addSeconds: dayFraction * self secondsInDay]</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondSinceUT:">basicNanosecondsSinceSecondSinceUT: aTemporal	^self isInvariantToUT		ifTrue: [self utNanosecondsSinceSecond - aTemporal utNanosecondsSinceSecond]		ifFalse: [self nanosecondsSinceSecond - aTemporal nanosecondsSinceSecond]</body><body package="Chronos-DateTimeInterval" selector="basicNanosecondsSinceSecondUntilUT:">basicNanosecondsSinceSecondUntilUT: aTemporal 	^self isInvariantToUT		ifTrue: [aTemporal utNanosecondsSinceSecond - self utNanosecondsSinceSecond]		ifFalse: [aTemporal nanosecondsSinceSecond - self nanosecondsSinceSecond]</body><body package="Chronos-DateTimeInterval" selector="daysSinceDate:">daysSinceDate: aDate	| dayDelta |	dayDelta := super daysSinceDate: aDate.	dayDelta &gt;= 0 ifTrue: [^dayDelta].	^self isAtStartOfDay ifTrue: [dayDelta] ifFalse: [dayDelta + 1]</body><body package="Chronos-DateTimeInterval" selector="daysSinceDateAndTime:">daysSinceDateAndTime: aDateAndTime 	"(Timepoint year: 2006 month: 4 day: 4 timeZone: 'America/New_York') 		daysSinceDateAndTime: (Timepoint year: 2006 month: 4 day: 1 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 1 timeZone: 'America/New_York') 		daysSinceDateAndTime: (Timepoint year: 2006 month: 4 day: 4 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York') 		daysSinceDateAndTime: (Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York') 		daysSinceDateAndTime: (Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York') 		daysSinceDateAndTime: (Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 1 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 1 timeZone: 'America/New_York') 		daysSinceDateAndTime: (Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York')"	^self rootTimeZone = aDateAndTime rootTimeZone		ifTrue: 			[| dayDelta subdayDelta |			dayDelta := super daysSinceDate: aDateAndTime.			subdayDelta := self secondsSinceStartOfDay - aDateAndTime secondsSinceStartOfDay.			subdayDelta = 0 ifTrue: [subdayDelta := self nanosecondsSinceSecond - aDateAndTime nanosecondsSinceSecond].			dayDelta &gt;= 0 				ifTrue: [subdayDelta &gt;= 0 ifTrue: [dayDelta] ifFalse: [dayDelta - 1]]				ifFalse: [subdayDelta &lt;= 0 ifTrue: [dayDelta] ifFalse: [dayDelta + 1]]]		ifFalse: [(self - aDateAndTime) asDays]</body><body package="Chronos-DateTimeInterval" selector="daysUntilDate:">daysUntilDate: aDate 	| dayDelta |	dayDelta := super daysUntilDate: aDate.	dayDelta &lt;= 0 ifTrue: [^dayDelta].	^self isAtStartOfDay ifTrue: [dayDelta] ifFalse: [dayDelta - 1]</body><body package="Chronos-DateTimeInterval" selector="daysUntilDateAndTime:">daysUntilDateAndTime: aDateAndTime	"(Timepoint year: 2006 month: 4 day: 1 timeZone: 'America/New_York') 		daysUntilDateAndTime: (Timepoint year: 2006 month: 4 day: 4 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 4 timeZone: 'America/New_York') 		daysUntilDateAndTime: (Timepoint year: 2006 month: 4 day: 1 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York') 		daysUntilDateAndTime: (Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York') 		daysUntilDateAndTime: (Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 1 timeZone: 'America/New_York') 		daysUntilDateAndTime: (Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York')"	"(Timepoint year: 2006 month: 4 day: 4 hour: 1 minute: 0 second: 0 timeZone: 'America/New_York') 		daysUntilDateAndTime: (Timepoint year: 2006 month: 4 day: 1 hour: 1 minute: 0 second: 1 timeZone: 'America/New_York')"	^self rootTimeZone = aDateAndTime rootTimeZone		ifTrue: 			[| dayDelta subdayDelta |			dayDelta := super daysUntilDate: aDateAndTime.			subdayDelta := aDateAndTime secondsSinceStartOfDay -  self secondsSinceStartOfDay.			subdayDelta = 0 ifTrue: [subdayDelta := aDateAndTime nanosecondsSinceSecond - self nanosecondsSinceSecond].			dayDelta &gt;= 0 				ifTrue: [subdayDelta &gt;= 0 ifTrue: [dayDelta] ifFalse: [dayDelta - 1]]				ifFalse: [subdayDelta &lt;= 0 ifTrue: [dayDelta] ifFalse: [dayDelta + 1]]]		ifFalse: [(aDateAndTime - self) asDays]</body><body package="Chronos-DateTimeInterval" selector="durationSinceDate:">durationSinceDate: aDate	^self civilDurationSince: aDate</body><body package="Chronos-DateTimeInterval" selector="durationSinceDateAndTime:">durationSinceDateAndTime: aDateAndTime	^self scientificDurationSince: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="durationUntilDate:">durationUntilDate: aDate	^self civilDurationUntil: aDate</body><body package="Chronos-DateTimeInterval" selector="durationUntilDateAndTime:">durationUntilDateAndTime: aDateAndTime	^self scientificDurationUntil: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="nonProxyTimeZoneAddDays:">nonProxyTimeZoneAddDays: days 	"Add the given number of civil days to the date represented by the receiver, preserving the same civil time-of-day.  The implementation is specific to the case where the receiver's time zone is a proxy time zone."	self invalidateDaysSinceEpoch.	super basicAddDays: days.	self unbindTimeZone</body><body package="Chronos-DateTimeInterval" selector="proxyTimeZoneAddDays:">proxyTimeZoneAddDays: days 	"Add the given number of civil days to the date represented by the receiver, preserving the same civil time-of-day.  The implementation is specific to the case where the receiver's time zone is a proxy."	daysSinceEpoch == nil		ifTrue: [super basicAddDays: days]		ifFalse: 			[daysSinceEpoch := daysSinceEpoch + days.			self invalidateYearAndCalendarDay].</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aDuration	^aDuration 		subtractingYears: self yearsSinceEpoch		months: self monthsSinceStartOfYear		days: self daysSinceStartOfMonth		hours: self hour		minutes: self minute		seconds: self second		nanoseconds: self nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>arithmetic</category><body package="Chronos-DateTimeInterval" selector="daysSince:">daysSince: aCalendricalCoordinate	^aCalendricalCoordinate daysUntilDateAndTime: self</body><body package="Chronos-DateTimeInterval" selector="daysUntil:">daysUntil: aCalendricalCoordinate	^aCalendricalCoordinate daysSinceDateAndTime: self</body><body package="Chronos-DateTimeInterval" selector="durationSince:">durationSince: aTemporalCoordinate	^aTemporalCoordinate durationUntilDateAndTime: self</body><body package="Chronos-DateTimeInterval" selector="durationUntil:">durationUntil: aTemporalCoordinate	^aTemporalCoordinate durationSinceDateAndTime: self</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="yearAndCalendarDayDo:">yearAndCalendarDayDo: block2 	^timeZone isProxyAndInvariantToUT 		ifTrue: 			[self calendar 				forDaysSinceEpoch: self daysSinceEpoch				setYearAndCalendarDayInto: block2]		ifFalse: 			[year == nil ifTrue: [self setYearAndCalendarDay].			block2 value: year value: calendarDay]</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>queries</category><body package="Chronos-DateTimeInterval" selector="atStartOfDay">atStartOfDay	^self		subtractingSeconds: self secondsSinceStartOfDay		nanoseconds: self nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	"If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy default (or ChronosPrintPolicy ansiStandard or ChronosPrintPolicy iso8601,) AND if the receiver is bound to a specific timezone, then the receiver's printString will be formatted as required by both the ANSI-Smalltalk and the ISO 8601 Standards. If the receiver is not bound to a specific timezone, then the receiver's printString will be formatted as required by both the ANSI-Smalltalk and the ISO 8601 Standards except for the omission of any timezone information."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printDateAndTime: self on: stream</body></methods><methods><class-id>Chronos.Timepoint</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="addMilliseconds:"> addMilliseconds: milliseconds	^self addingSeconds: 0 nanoseconds: milliseconds * NanosecondsPerMillisecond</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asMicroseconds">asMicroseconds	"Answer the microseconds between the initial moment of the first day of 1901 A.D. [Gregorian] and the point-in-time represented by the receiver."	"{Gregorian clock now asMicroseconds}"	"{EthiopicCalendar clock now asMicroseconds}"	^(self isGregorian		ifTrue: [self microsecondsSinceEpoch]		ifFalse:			[((Gregorian				secondsSinceEpochFromForeignSecondsSinceEpoch: self fractionalSecondsSinceEpoch 				convertingFrom: self calendar) * MicrosecondsPerSecond) truncated])  - 59958144000000000</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asMilliseconds">asMilliseconds	"Answer the milliseconds between the initial moment of the first day of 1901 A.D. [Gregorian] and the point-in-time represented by the receiver."	"{Gregorian clock now asMilliseconds}"	"{EthiopicCalendar clock now asMilliseconds}"	^(self isGregorian		ifTrue: [self millisecondsSinceEpoch]		ifFalse:			[((Gregorian				secondsSinceEpochFromForeignSecondsSinceEpoch: self fractionalSecondsSinceEpoch 				convertingFrom: self calendar) * MillisecondsPerSecond) truncated])  - 59958144000000</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asSeconds">asSeconds	"Answer the seconds between the initial moment of the first day of 1901 A.D. [Gregorian] and the point-in-time represented by the receiver."	"{Timepoint basicNew		fromSeconds: Gregorian clock now asSeconds;		yourself}"	"{Timestamp basicNew		fromSeconds: Gregorian clock now asSeconds;		yourself}"	^(self isGregorian		ifTrue: [self secondsSinceEpoch]		ifFalse:			[Gregorian				secondsSinceEpochFromForeignSecondsSinceEpoch: self secondsSinceEpoch 				convertingFrom: self calendar])  - 59958144000</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asTime">asTime	^self timeOfDay</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asTimestamp">asTimestamp	"Answer a Timestamp representing the receiver."	^self asNative "Not valid outside of VW--but then, the VW Timestamp isn't canonical ST-80, either...so this is acceptable."</body><body package="Chronos-ST80 (and VW) Compatibility" selector="asUTMicrosecondsSince1901">asUTMicrosecondsSince1901	"Answer the microseconds between the initial moment of the first day of 1901 A.D. [Gregorian] and the point-in-time represented by the receiver--relative to the UT timezone."	"NOTE: This method is not actually an API message of ST-80 or VisualWorks--it is, however, useful for translating Chronos Timepoints into VW Timestamps, and for generating the VW system clock's microsecond tick value that corresponds to the point-in-time specified by a Timepoint."	"{Timestamp basicNew		setFromMicroseconds: Gregorian clock now asUTMicrosecondsSince1901;		yourself}"	"{Timestamp basicNew		setFromMicroseconds: EthiopicCalendar clock now asUTMicrosecondsSince1901;		yourself}"	"{Timepoint basicNew		setFromMicroseconds: Gregorian clock now asUTMicrosecondsSince1901;		yourself}"	^(self calendar isGregorian		ifTrue: [self utMicrosecondsSinceEpoch]		ifFalse:			[((Gregorian				secondsSinceEpochFromForeignSecondsSinceEpoch: self utFractionalSecondsSinceEpoch 				convertingFrom: self calendar) * MicrosecondsPerSecond) truncated])  - 59958144000000000</body><body package="Chronos-ST80 (and VW) Compatibility" selector="day">day	"Answer the day of the month represented by the receiver."	^self dayOfMonth</body><body package="Chronos-ST80 (and VW) Compatibility" selector="firstDayOf:">firstDayOf: monthIndex 	^(self calendar calendarDayFromMonth: monthIndex day: 1 forYearTypeCode: self yearTypeCode) daysSinceStartOfYear</body><body package="Chronos-ST80 (and VW) Compatibility" selector="firstDayOf:leap:">firstDayOf: monthIndex leap: leap	^(self calendar calendarDayFromMonth: monthIndex day: 1 forYearTypeCode: leap + 1) daysSinceStartOfYear</body><body package="Chronos-ST80 (and VW) Compatibility" selector="fromDate:">fromDate: st80Date	"Set the date represented by the receiver as specified by the given &lt;st80Date&gt;. Fail if the receiver is not mutable."	self 		initialize;		basicSetCalendar: Gregorian;		setYear: st80Date year monthOrdinal: st80Date monthIndex dayOfMonthOrdinal: st80Date dayOfMonth;		canonicalizeFromLocalTime</body><body package="Chronos-ST80 (and VW) Compatibility" selector="fromDate:andTime:">fromDate: st80Date andTime: st80TimeOfDay	"Set the date represented by the receiver as specified by the given &lt;st80Date&gt;, and set the time-of-day represented by the receiver as specified by the given &lt;st80TimeOfDay&gt;. Fail if the receiver is not mutable."	self 		initialize;		basicSetCalendar: Gregorian;		setSecondsSinceStartOfDay: st80TimeOfDay asSeconds;		setYear: st80Date year monthOrdinal: st80Date monthIndex dayOfMonthOrdinal: st80Date dayOfMonth;		canonicalizeFromLocalTime</body><body package="Chronos-ST80 (and VW) Compatibility" selector="fromSeconds:">fromSeconds: secondsSince1901	"Set the receiver to represent the point-in-time that is &lt;secondsSince1901&gt; seconds from the initial moment of the first day of 1901 AD. Fail if the receiver is not mutable."	"{Timepoint basicNew		fromSeconds: Gregorian clock now asSeconds;		yourself}"	"{Timepoint basicNew		fromSeconds: Timestamp now asSeconds;		yourself}"	self basicSetCalendar: Gregorian.	self 		setNanosecondsSinceSecond: 0;		setSecondsSinceEpoch: secondsSince1901 + 59958144000;		canonicalizeFromLocalTime.</body><body package="Chronos-ST80 (and VW) Compatibility" selector="fromTime:">fromTime: st80TimeOfDay 	"Set the time-of-day represented by the receiver as specified by the given &lt;st80TimeOfDay&gt;. Fail if the receiver is not mutable."	self 		initialize;		setSecondsSinceStartOfDay: st80TimeOfDay asSeconds;		basicSetDaysSinceEpoch: -366.</body><body package="Chronos-ST80 (and VW) Compatibility" selector="printOn:policy:format:">printOn: aStream policy: aPolicy format: tokens	"{Locale current printAsTime: Timepoint now policyNamed: #long}"	"{Locale current printAsTime: Timepoint now policyNamed: #short}"	aPolicy print: self on: aStream using: (aPolicy fieldFormat: 1 for: tokens)</body><body package="Chronos-ST80 (and VW) Compatibility" selector="setFromMicroseconds:">setFromMicroseconds: utMicrosecondsSince1901	"Set the receiver to represent the point-in-time that is &lt;utMicrosecondsSince1901&gt; microseconds from the initial moment of the first day of 1901 AD (relative to Universal Time.) Fail if the receiver is not mutable."	"{Timepoint basicNew		setFromMicroseconds: Gregorian clock now asUTMicrosecondsSince1901;		yourself}"	"This examples assumes that a) The SystemClock tick resolution is 1 microsecond, and b) The SystemClock epoch is 1901-01-01T00:00:00+00:00.	Both assumptions will be true in VisualWorks 7.0 and later, and at least the first one will generally be false everywhere else:	{Timepoint basicNew		setFromMicroseconds: SystemClock ticksNowSinceSystemClockEpoch;		yourself}"	self 		basicSetCalendar: Gregorian;		setNanosecondsSinceSecond: ((utMicrosecondsSince1901 \\ MicrosecondsPerSecond) bitShift: 3) * 125;		setSecondsSinceEpoch: (utMicrosecondsSince1901 bitShift: -6) // 15625 + 59958144000;		canonicalizeFromUT.</body><body package="Chronos-ST80 (and VW) Compatibility" selector="subtractMilliseconds:"> subtractMilliseconds: milliseconds	^self subtractingSeconds: 0 nanoseconds: milliseconds * NanosecondsPerMillisecond</body><body package="Chronos-ST80 (and VW) Compatibility" selector="subtractSeconds:">subtractSeconds: secondsCount	"Answer the point-in-time value resulting from the subtraction of &lt;secondsCount&gt; seconds from the receiver."		^self subtractingSeconds: secondsCount</body><body package="Chronos-ST80 (and VW) Compatibility" selector="weekdayIndex">weekdayIndex	"Answer the ISO day-of-week ordinal."	^self isoDayOfWeekOrdinal</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-UT-current</category><body package="Chronos-DateTimeInterval" selector="utNow">utNow	^AnsiStandardCalendarClock utNow</body><body package="Chronos-DateTimeInterval" selector="utNowAs:">utNowAs: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock utNow</body><body package="Chronos-DateTimeInterval" selector="utToday">utToday	^AnsiStandardCalendarClock utToday</body><body package="Chronos-DateTimeInterval" selector="utTodayAs:">utTodayAs: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock utToday</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-UT</category><body package="Chronos-DateTimeInterval" selector="utYear:day:">utYear: year day: dayOfYear	^self basicNew		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:calendar:">utYear: year day: dayOfYear calendar: calendar	^self basicNew		setCalendar: calendar;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:hour:minute:second:">utYear: year day: dayOfYear hour: hour minute: minute second: second	^self basicNew		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:hour:minute:second:timeZone:">utYear: year day: dayOfYear hour: hour minute: minute second: second timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:hour:minute:second:timeZone:calendar:">utYear: year day: dayOfYear hour: hour minute: minute second: second timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:seconds:nanoseconds:">utYear: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:seconds:nanoseconds:calendar:">utYear: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:seconds:nanoseconds:timeZone:">utYear: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:seconds:nanoseconds:timeZone:calendar:">utYear: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:timeZone:">utYear: year day: dayOfYear timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:day:timeZone:calendar:">utYear: year day: dayOfYear timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:">utYear: year month: month day: dayOfMonth	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:calendar:">utYear: year month: month day: dayOfMonth calendar: calendar	^self basicNew		setCalendar: calendar;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:hour:minute:second:">utYear: year month: month day: dayOfMonth hour: hour minute: minute second: second	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:hour:minute:second:nanosecond:">utYear: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:hour:minute:second:nanosecond:calendar:">utYear: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:hour:minute:second:nanosecond:timeZone:">utYear: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:hour:minute:second:nanosecond:timeZone:calendar:">utYear: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:hour:minute:second:timeZone:">utYear: year month: month day: dayOfMonth hour: hour minute: minute second: second timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:hour:minute:second:timeZone:calendar:">utYear: year month: month day: dayOfMonth hour: hour minute: minute second: second timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:seconds:nanoseconds:">utYear: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:seconds:nanoseconds:calendar:">utYear: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:seconds:nanoseconds:timeZone:">utYear: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:seconds:nanoseconds:timeZone:calendar:">utYear: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:timeZone:">utYear: year month: month day: dayOfMonth timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utYear:month:day:timeZone:calendar:">utYear: year month: month day: dayOfMonth timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromUT;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-nominal time-current</category><body package="Chronos-DateTimeInterval" selector="nominalNow">nominalNow		"DateAndTime nominalNow"	^AnsiStandardCalendarClock nominalNow</body><body package="Chronos-DateTimeInterval" selector="nominalNowAs:">nominalNowAs: calendar	^(Calendar referencedBy: calendar) clock nominalNow</body><body package="Chronos-DateTimeInterval" selector="nominalNowToTheSecond">nominalNowToTheSecond	^AnsiStandardCalendarClock nominalNowToTheSecond</body><body package="Chronos-DateTimeInterval" selector="nominalNowToTheSecondAs:">nominalNowToTheSecondAs: calendar	^(Calendar referencedBy: calendar) clock nominalNowToTheSecond</body><body package="Chronos-DateTimeInterval" selector="nominalToday">nominalToday	^AnsiStandardCalendarClock nominalToday</body><body package="Chronos-DateTimeInterval" selector="nominalTodayAs:">nominalTodayAs: calendar	^(Calendar referencedBy: calendar) clock nominalToday</body><body package="Chronos-DateTimeInterval" selector="nominalTodayAt:">nominalTodayAt: aTimeOfDay 	"Timepoint nominalTodayAt: TimeOfDay now"	^aTimeOfDay asMutableDateAndTime beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalTodayIn:">nominalTodayIn: aTimezone	^AnsiStandardCalendarClock nominalTodayIn: aTimezone</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-UT-Julian Days</category><body package="Chronos-DateTimeInterval" selector="utJulianDay:">utJulianDay: julianDay	"{((DateAndTimeFactory utJulianDay: 2452164.0294675923d) 		in: 'America/New_York') localePrintString}"	^self basicNew		setJulianDay: julianDay;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:calendar:">utJulianDay: julianDay calendar: calendar	^self basicNew		setCalendar: calendar;		setJulianDay: julianDay;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:seconds:">utJulianDay: julianDay seconds: seconds	^self basicNew		setJulianDay: julianDay seconds: seconds nanoseconds: 0;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:seconds:nanoseconds:">utJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds	^self basicNew		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:seconds:nanoseconds:calendar:">utJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds calendar: calendar	^self basicNew		setCalendar: calendar;		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:seconds:nanoseconds:timeZone:">utJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:seconds:nanoseconds:timeZone:calendar:">utJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:seconds:timeZone:">utJulianDay: julianDay seconds: seconds timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setJulianDay: julianDay seconds: seconds nanoseconds: 0;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:seconds:timeZone:calendar:">utJulianDay: julianDay seconds: seconds timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setJulianDay: julianDay seconds: seconds nanoseconds: 0;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:timeZone:">utJulianDay: julianDay timeZone: timeZone	"{(DateAndTimeFactory 		utcJulianDay: 2452164.0294675923d		timeZone: 'America/New_York') localePrintString}"	^self basicNew		setTimeZone: timeZone;		setJulianDay: julianDay;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDay:timeZone:calendar:">utJulianDay: julianDay timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setJulianDay: julianDay;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDayNumber:">utJulianDayNumber: julianDay	"Timepoint utJulianDayNumber: 2400001"	^self basicNew		setJulianDayNumber: julianDay;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utJulianDayNumber:timeZone:">utJulianDayNumber: julianDay timeZone: timeZone	"Timepoint utJulianDayNumber: 2400001 timeZone: #UT"	^self basicNew		setTimeZone: timeZone;		setJulianDayNumber: julianDay;		canonicalizeFromUT;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-nominal time</category><body package="Chronos-DateTimeInterval" selector="nominalYear:day:">nominalYear: year day: dayOfYear 	"DateAndTimeFactory nominalYear: 2000 day: 1"	^self basicNew		setYear: year dayOfYearOrdinal: dayOfYear;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:day:calendar:">nominalYear: year day: dayOfYear calendar: calendar	^self basicNew		basicSetCalendar: calendar;		setYear: year dayOfYearOrdinal: dayOfYear;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:day:hour:minute:second:">nominalYear: year day: dayOfYear hour: hour minute: minute second: second 	^self basicNew		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:day:seconds:nanoseconds:">nominalYear: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond	^self basicNew		setYear: year dayOfYearOrdinal: dayOfYear;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:day:seconds:nanoseconds:calendar:">nominalYear: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond calendar: calendar 	^self basicNew		basicSetCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:">nominalYear: year month: month day: dayOfMonth 	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:calendar:">nominalYear: year month: month day: dayOfMonth calendar: calendar 	^self basicNew		basicSetCalendar: calendar;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:hour:minute:second:">nominalYear: year month: month day: dayOfMonth hour: hour minute: minute second: second 	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:hour:minute:second:calendar:">nominalYear: year month: month day: dayOfMonth hour: hour minute: minute second: second calendar: calendar	^self basicNew		basicSetCalendar: calendar;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:hour:minute:second:nanosecond:">nominalYear: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:hour:minute:second:nanosecond:calendar:">nominalYear: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond calendar: calendar 	^self basicNew		basicSetCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:seconds:nanoseconds:">nominalYear: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalYear:month:day:seconds:nanoseconds:calendar:">nominalYear: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond calendar: calendar 	^self basicNew		basicSetCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-nominal time-Julian Days</category><body package="Chronos-DateTimeInterval" selector="nominalJulianDay:">nominalJulianDay: julianDay 	^self basicNew		setJulianDay: julianDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalJulianDay:calendar:">nominalJulianDay: julianDay calendar: calendar	^self basicNew		setCalendar: calendar;		setJulianDay: julianDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalJulianDay:seconds:nanoseconds:">nominalJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds 	^self basicNew		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalJulianDay:seconds:nanoseconds:calendar:">nominalJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds calendar: calendar 	^self basicNew		setCalendar: calendar;		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-local time</category><body package="Chronos-DateTimeInterval" selector="year:day:hour:minute:second:">year: year day: dayOfYear hour: hour minute: minute second: second	"Specified and required by the ANSI-Smalltalk Standard."	^self basicNew		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:hour:minute:second:calendar:">year: year day: dayOfYear hour: hour minute: minute second: second calendar: calendar	^self basicNew		setCalendar: calendar;		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:hour:minute:second:offset:">year: year day: dayOfYear hour: hour minute: minute second: second offset: aDuration	"Specified and required by the ANSI-Smalltalk Standard."	^self basicNew		setOffset: aDuration;		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:hour:minute:second:offset:calendar:">year: year day: dayOfYear hour: hour minute: minute second: second offset: aDuration calendar: calendar	^self basicNew		setCalendar: calendar;		setOffset: aDuration;		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:hour:minute:second:timeZone:">year: year day: dayOfYear hour: hour minute: minute second: second timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:hour:minute:second:timeZone:calendar:">year: year day: dayOfYear hour: hour minute: minute second: second timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:nanoseconds:">year: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:nanoseconds:calendar:">year: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:nanoseconds:timeZone:">year: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:nanoseconds:timeZone:calendar:">year: year day: dayOfYear seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:timeZone:">year: year day: dayOfYear timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:day:timeZone:calendar:">year: year day: dayOfYear timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year dayOfYearOrdinal: dayOfYear;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second	"Specified and required by the ANSI-Smalltalk Standard."	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:calendar:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second calendar: aCalendar	^self basicNew		setCalendar: aCalendar;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:nanosecond:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:nanosecond:calendar:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:nanosecond:timeZone:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:nanosecond:timeZone:calendar:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:offset:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second offset: aDuration	"Specified and required by the ANSI-Smalltalk Standard."	^self basicNew		setOffset: aDuration;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:timeZone:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:timeZone:calendar:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:nanoseconds:">year: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:nanoseconds:calendar:">year: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:nanoseconds:timeZone:">year: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:nanoseconds:timeZone:calendar:">year: year month: month day: dayOfMonth seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		basicSetSecondsSinceStartOfDay: secondsSinceStartOfDay;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:timeZone:">year: year month: month day: dayOfMonth timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="year:month:day:timeZone:calendar:">year: year month: month day: dayOfMonth timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-local time-current</category><body package="Chronos-DateTimeInterval" selector="now">now		"Specified and required by the ANSI-Smalltalk Standard."	^AnsiStandardCalendarClock now</body><body package="Chronos-DateTimeInterval" selector="nowAs:">nowAs: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock now	"{DateAndTimeFactory todayAs: Gregorian}"	"{DateAndTimeFactory nowAs: #Gregorian}" 			"{DateAndTimeFactory nowAs: GregorianCalendar}" 	"{DateAndTimeFactory nowAs: Julian}" 		"{DateAndTimeFactory nowAs: #Julian}" 				"{DateAndTimeFactory nowAs: JulianCalendar}"			"{DateAndTimeFactory nowAs: #Bahai}" 				"{DateAndTimeFactory nowAs: BahaiCalendar}"	"{DateAndTimeFactory nowAs: #Coptic}" 				"{DateAndTimeFactory nowAs: CopticCalendar}"	"{DateAndTimeFactory nowAs: #Ethiopic}" 			"{DateAndTimeFactory nowAs: EthiopicCalendar}"	"{DateAndTimeFactory nowAs: #Hebrew}" 			"{DateAndTimeFactory nowAs: HebrewCalendar}"	"{DateAndTimeFactory nowAs: #Indian}" 				"{DateAndTimeFactory nowAs: IndianCalendar}"	"{DateAndTimeFactory nowAs: #'Islamic-Fatimid'}" 	"{DateAndTimeFactory nowAs: IslamicFatimidCalendar}"	"{DateAndTimeFactory nowAs: #Persian}" 			"{DateAndTimeFactory nowAs: PersianCalendar}"	"{DateAndTimeFactory nowAs: #Solarian}" 			"{DateAndTimeFactory nowAs: SolarianCalendar}"</body><body package="Chronos-DateTimeInterval" selector="nowIn:">nowIn: aTimezone	^AnsiStandardCalendarClock nowIn: aTimezone		"{DateAndTimeFactory nowIn: #UTC}"	"{DateAndTimeFactory nowIn: 'Pacific/Auckland'}"	"{DateAndTimeFactory nowIn: 'Australia/Sydney'}"	"{DateAndTimeFactory nowIn: 'Asia/Tokyo'}"	"{DateAndTimeFactory nowIn: 'Asia/Hong_Kong'}"	"{DateAndTimeFactory nowIn: 'Europe/Moscow'}"	"{DateAndTimeFactory nowIn: 'Asia/Jerusalem'}"	"{DateAndTimeFactory nowIn: 'Europe/Amsterdam'}"	"{DateAndTimeFactory nowIn: 'Europe/London'}"	"{DateAndTimeFactory nowIn: 'America/Sao_Paulo'}"	"{DateAndTimeFactory nowIn: 'America/Argentina/Buenos_Aires'}"	"{DateAndTimeFactory nowIn: 'America/New_York'}"	"{DateAndTimeFactory nowIn: 'America/Chicago'}"	"{DateAndTimeFactory nowIn: 'America/Denver'}"	"{DateAndTimeFactory nowIn: 'America/Los_Angeles'}"	"{DateAndTimeFactory nowIn: 'Pacific/Honolulu'}"</body><body package="Chronos-DateTimeInterval" selector="nowIn:as:">nowIn: aTimezone as: aCalendar	"{DateAndTimeFactory nowIn: #'America/Chicago' as: #Gregorian}"	"{(DateAndTimeFactory nowIn: ChronosTimezone alwaysDefault as: Julian) printStringUsing: ChronosPrintPolicy verbose}"	^(Calendar referencedBy: aCalendar) clock nowIn: aTimezone</body><body package="Chronos-DateTimeInterval" selector="nowToTheHour">nowToTheHour	"{Timepoint nowToTheHour}"	| now |	now := self nowToTheSecond.	^now subtractingHours: 0 minutes: now minute seconds: now second</body><body package="Chronos-DateTimeInterval" selector="nowToTheMinute">nowToTheMinute	"{Timepoint nowToTheMinute}"	| now |	now := self nowToTheSecond.	^now subtractingSeconds: now second</body><body package="Chronos-DateTimeInterval" selector="nowToTheSecond">nowToTheSecond		^AnsiStandardCalendarClock nowToTheSecond</body><body package="Chronos-DateTimeInterval" selector="nowToTheSecondAs:">nowToTheSecondAs: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock nowToTheSecond</body><body package="Chronos-DateTimeInterval" selector="nowToTheSecondIn:">nowToTheSecondIn: aTimezone	^AnsiStandardCalendarClock nowToTheSecondIn: aTimezone</body><body package="Chronos-DateTimeInterval" selector="nowToTheSecondIn:as:">nowToTheSecondIn: aTimezone as: aCalendar	"{DateAndTimeFactory nowToTheSecondIn: #'America/Chicago' as: #Gregorian}"	"{(DateAndTimeFactory nowToTheSecondIn: ChronosTimezone alwaysDefault as: Julian) printStringUsing: ChronosPrintPolicy verbose}"	^(Calendar referencedBy: aCalendar) clock nowToTheSecondIn: aTimezone</body><body package="Chronos-DateTimeInterval" selector="today">today	^AnsiStandardCalendarClock today</body><body package="Chronos-DateTimeInterval" selector="todayAs:">todayAs: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock today	"{DateAndTimeFactory todayAs: Gregorian}"	"{DateAndTimeFactory todayAs: #Gregorian}" 		"{DateAndTimeFactory todayAs: GregorianCalendar}" 		"{DateAndTimeFactory todayAs: Julian}" 	"{DateAndTimeFactory todayAs: #Julian}" 			"{DateAndTimeFactory todayAs: JulianCalendar}"				"{DateAndTimeFactory todayAs: #Bahai}" 			"{DateAndTimeFactory todayAs: BahaiCalendar}"	"{DateAndTimeFactory todayAs: #Coptic}" 			"{DateAndTimeFactory todayAs: CopticCalendar}"	"{DateAndTimeFactory todayAs: #Ethiopic}" 			"{DateAndTimeFactory todayAs: EthiopicCalendar}"	"{DateAndTimeFactory todayAs: #Hebrew}" 			"{DateAndTimeFactory todayAs: HebrewCalendar}"	"{DateAndTimeFactory todayAs: #Indian}" 			"{DateAndTimeFactory todayAs: IndianCalendar}"	"{DateAndTimeFactory todayAs: #'Islamic-Fatimid'}" 	"{DateAndTimeFactory todayAs: IslamicFatimidCalendar}"	"{DateAndTimeFactory todayAs: #Persian}" 			"{DateAndTimeFactory todayAs: PersianCalendar}"	"{DateAndTimeFactory todayAs: #Solarian}" 			"{DateAndTimeFactory todayAs: SolarianCalendar}"</body><body package="Chronos-DateTimeInterval" selector="todayAt:">todayAt: aTimeOfDay 	"Timepoint todayAt: TimeOfDay now"	^aTimeOfDay in: ChronosTimezone default</body><body package="Chronos-DateTimeInterval" selector="todayAt:in:">todayAt: aTimeOfDay in: timeZone	"Timepoint todayAt: TimeOfDay now in: (Duration hours: 5.5)"	^aTimeOfDay in: timeZone</body><body package="Chronos-DateTimeInterval" selector="todayIn:">todayIn: aTimezone	^AnsiStandardCalendarClock todayIn: aTimezone	"{DateAndTimeFactory todayIn: #UTC}"	"{DateAndTimeFactory todayIn: 'Pacific/Auckland'}"	"{DateAndTimeFactory todayIn: 'Australia/Sydney'}"	"{DateAndTimeFactory todayIn: 'Asia/Tokyo'}"	"{DateAndTimeFactory todayIn: 'Asia/Hong_Kong'}"	"{DateAndTimeFactory todayIn: 'Europe/Moscow'}"	"{DateAndTimeFactory todayIn: 'Asia/Jerusalem'}"	"{DateAndTimeFactory todayIn: 'Europe/Amsterdam'}"	"{DateAndTimeFactory todayIn: 'Europe/London'}"	"{DateAndTimeFactory todayIn: 'America/Sao_Paulo'}"	"{DateAndTimeFactory todayIn: 'America/Argentina/Buenos_Aires'}"	"{DateAndTimeFactory todayIn: 'America/New_York'}"	"{DateAndTimeFactory todayIn: 'America/Chicago'}"	"{DateAndTimeFactory todayIn: 'America/Denver'}"	"{DateAndTimeFactory todayIn: 'America/Los_Angeles'}"	"{DateAndTimeFactory todayIn: 'Pacific/Honolulu'}"</body><body package="Chronos-DateTimeInterval" selector="todayIn:as:">todayIn: aTimezone as: aCalendarOrCalendarReference	^(Calendar referencedBy: aCalendarOrCalendarReference) clock todayIn: aTimezone</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-UT-since epoch</category><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch:">utDaysSinceEpoch: days	"{DateAndTime utDaysSinceEpoch: 730118.5}"	^self basicNew		basicSetDaysSinceEpoch: days;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch:seconds:">utDaysSinceEpoch: days seconds: seconds	^self basicNew		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch:seconds:nanoseconds:">utDaysSinceEpoch: days seconds: seconds nanoseconds: n	^self basicNew		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch:seconds:nanoseconds:calendar:">utDaysSinceEpoch: days seconds: seconds nanoseconds: n calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch:seconds:nanoseconds:timeZone:">utDaysSinceEpoch: days seconds: seconds nanoseconds: n timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch:seconds:nanoseconds:timeZone:calendar:">utDaysSinceEpoch: days seconds: seconds nanoseconds: n timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch:timeZone:">utDaysSinceEpoch: days timeZone: timeZone	"{DateAndTime utDaysSinceEpoch: 730118.5 timeZone: Timezone universal}"	"{DateAndTime utDaysSinceEpoch: 730118.5 timeZone: 'America/Chicago'}"	^self basicNew		setTimeZone: timeZone;		basicSetDaysSinceEpoch: days;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceEpoch:">utNanosecondsSinceEpoch: n	^self basicNew		setNanosecondsSinceEpoch: n;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceEpoch:calendar:">utNanosecondsSinceEpoch: n calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceEpoch: n;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceEpoch:timeZone:">utNanosecondsSinceEpoch: n timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceEpoch: n;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceEpoch:timeZone:calendar:">utNanosecondsSinceEpoch: n timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceEpoch: n;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:">utSecondsSinceEpoch: s	^self basicNew		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:calendar:">utSecondsSinceEpoch: s calendar: calendar	^self basicNew		setCalendar: calendar;		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:nanoseconds:">utSecondsSinceEpoch: s nanoseconds: n	^self basicNew		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:nanoseconds:calendar:">utSecondsSinceEpoch: s nanoseconds: n calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:nanoseconds:timeZone:">utSecondsSinceEpoch: s nanoseconds: n timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:nanoseconds:timeZone:calendar:">utSecondsSinceEpoch: s nanoseconds: n timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:timeZone:">utSecondsSinceEpoch: s timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceEpoch:timeZone:calendar:">utSecondsSinceEpoch: s timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		basicSetSecondsSinceEpoch: s;		canonicalizeFromUT;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-local time-Julian Days</category><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:">julianDay: julianDay seconds: seconds	^self basicNew		setJulianDay: julianDay seconds: seconds nanoseconds: 0;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:nanoseconds:">julianDay: julianDay seconds: seconds nanoseconds: nanoseconds	^self basicNew		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:nanoseconds:calendar:">julianDay: julianDay seconds: seconds nanoseconds: nanoseconds calendar: calendar	^self basicNew		setCalendar: calendar;		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:nanoseconds:timeZone:">julianDay: julianDay seconds: seconds nanoseconds: nanoseconds timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:nanoseconds:timeZone:calendar:">julianDay: julianDay seconds: seconds nanoseconds: nanoseconds timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setJulianDay: julianDay seconds: seconds nanoseconds: nanoseconds;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDay:timeZone:">julianDay: julianDay timeZone: timeZone	"{(DateAndTimeFactory 		julianDay: 2452163.862800926d		timeZone: 'America/New_York') localePrintString}"	^self basicNew		setTimeZone: timeZone;		setJulianDay: julianDay;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDay:timeZone:calendar:">julianDay: julianDay timeZone: timeZone calendar: aCalendar	^self basicNew		setCalendar: aCalendar;		setTimeZone: timeZone;		setJulianDay: julianDay;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="julianDayNumber:timeZone:">julianDayNumber: julianDay timeZone: timeZone	"Should be true: {(Timepoint julianDayNumber: 2400001 timeZone: #UT) = (Timepoint julianDayNumber: 2400000.5 timeZone: #UT)}"	"Should be true: {(Timepoint julianDayNumber: 2400001 timeZone: #UT) &gt; (Timepoint julianDayNumber: 2400000 timeZone: #UT)}"	^self basicNew		setTimeZone: timeZone;		setJulianDayNumber: julianDay;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="nominalTZ">nominalTZ	nominalTZ == nil ifTrue: [nominalTZ := ChronosTimezone nominal].	^nominalTZ</body><body package="Chronos-DateTimeInterval" selector="universalTZ">universalTZ	universalTZ == nil ifTrue: [universalTZ := ChronosTimezone universal].	^universalTZ</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-local time-since epoch</category><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:">daysSinceEpoch: days seconds: seconds	^self basicNew		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:nanoseconds:">daysSinceEpoch: days seconds: seconds nanoseconds: n	^self basicNew		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:nanoseconds:calendar:">daysSinceEpoch: days seconds: seconds nanoseconds: n calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:nanoseconds:timeZone:">daysSinceEpoch: days seconds: seconds nanoseconds: n timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:nanoseconds:timeZone:calendar:">daysSinceEpoch: days seconds: seconds nanoseconds: n timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:timeZone:">daysSinceEpoch: days seconds: seconds timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:timeZone:">daysSinceEpoch: days timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:timeZone:calendar:">daysSinceEpoch: days timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		basicSetDaysSinceEpoch: days;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceEpoch:">nanosecondsSinceEpoch: n	^self basicNew		setNanosecondsSinceEpoch: n;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceEpoch:calendar:">nanosecondsSinceEpoch: n calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceEpoch: n;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceEpoch:timeZone:">nanosecondsSinceEpoch: n timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceEpoch: n;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceEpoch:timeZone:calendar:">nanosecondsSinceEpoch: n timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceEpoch: n;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:">secondsSinceEpoch: seconds	^self basicNew		basicSetSecondsSinceEpoch: seconds;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:calendar:">secondsSinceEpoch: s calendar: calendar	^self basicNew		setCalendar: calendar;		basicSetSecondsSinceEpoch: s;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:nanoseconds:">secondsSinceEpoch: s nanoseconds: n	^self basicNew		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:nanoseconds:calendar:">secondsSinceEpoch: s nanoseconds: n calendar: calendar	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:nanoseconds:timeZone:">secondsSinceEpoch: s nanoseconds: n timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:nanoseconds:timeZone:calendar:">secondsSinceEpoch: s nanoseconds: n timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:timeZone:">secondsSinceEpoch: s timeZone: timeZone	^self basicNew		setTimeZone: timeZone;		basicSetSecondsSinceEpoch: s;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:timeZone:calendar:">secondsSinceEpoch: s timeZone: timeZone calendar: calendar	^self basicNew		setCalendar: calendar;		setTimeZone: timeZone;		basicSetSecondsSinceEpoch: s;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-nominal time-since epoch</category><body package="Chronos-DateTimeInterval" selector="nominalDaysSinceEpoch:">nominalDaysSinceEpoch: days 	^self basicNew		basicSetDaysSinceEpoch: days;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalDaysSinceEpoch:calendar:">nominalDaysSinceEpoch: days calendar: calendar 	^self basicNew		setCalendar: calendar;		basicSetDaysSinceEpoch: days;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalDaysSinceEpoch:seconds:">nominalDaysSinceEpoch: days seconds: seconds 	^self basicNew		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalDaysSinceEpoch:seconds:nanoseconds:">nominalDaysSinceEpoch: days seconds: seconds nanoseconds: n 	^self basicNew		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalDaysSinceEpoch:seconds:nanoseconds:calendar:">nominalDaysSinceEpoch: days seconds: seconds nanoseconds: n calendar: calendar 	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceStartOfDay: seconds;		basicSetDaysSinceEpoch: days;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalNanosecondsSinceEpoch:">nominalNanosecondsSinceEpoch: n	^self basicNew		setNanosecondsSinceEpoch: n;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalNanosecondsSinceEpoch:calendar:">nominalNanosecondsSinceEpoch: n calendar: calendar 	^self basicNew		setCalendar: calendar;		setNanosecondsSinceEpoch: n;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalSecondsSinceEpoch:">nominalSecondsSinceEpoch: s 	^self basicNew		basicSetSecondsSinceEpoch: s;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalSecondsSinceEpoch:calendar:">nominalSecondsSinceEpoch: s calendar: calendar 	^self basicNew		setCalendar: calendar;		basicSetSecondsSinceEpoch: s;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalSecondsSinceEpoch:nanoseconds:">nominalSecondsSinceEpoch: s nanoseconds: n 	^self basicNew		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="nominalSecondsSinceEpoch:nanoseconds:calendar:">nominalSecondsSinceEpoch: s nanoseconds: n calendar: calendar 	^self basicNew		setCalendar: calendar;		setNanosecondsSinceSecond: n;		basicSetSecondsSinceEpoch: s;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>examples</category><body package="Chronos-DateTimeInterval" selector="inAllTimeZonesAndCalendars:">inAllTimeZonesAndCalendars: aDateAndTime	"INSPECT IT: 		{Timepoint 			inAllTimeZonesAndCalendars: 				(Timepoint 					year: 2001 					month: September 					day: 11 					hour: 8					minute: 42					second: 26					timeZone: #'America/New_York')}"	"INSPECT IT: 		{Timepoint 			inAllTimeZonesAndCalendars: 				(Timepoint 					year: 1941 					month: December 					day: 7 					hour: 7					minute: 55					second: 0					timeZone: #'Pacific/Honolulu')}"	| inAllTimezones map allCalendars printPolicy |	allCalendars := Calendar allRegisteredKeys asSortedCollection: [:a :b | a == #Gregorian ifTrue: [true] ifFalse: [b == #Gregorian ifTrue: [false] ifFalse: [a &lt; b]]].	inAllTimezones := aDateAndTime inAll: ChronosTimezone allCanonicalKeys asArray.	printPolicy := ChronosPrintPolicy rfc2822 apply: #(showEraNameAfterDate dateAndTimeSeparator: ' @ ' use12HourFormat hourPadChar: nil showTimeZoneAbbreviation).	map := Dictionary new.	inAllTimezones do: 		[:timepoint | 			| stream timeZone |			timeZone := timepoint timeZone.			stream := String new writeStream.			timeZone specifiesGeographicCoordinates				ifTrue: 					[stream						nextPutAll: 'Geographic coordinates: ';						print: timeZone geographicCoordinates;						cr].			stream 				nextPutAll: 'Julian Date: '.			ChronosFunction				printFractional: timepoint utJulianDate asDecimalOn: stream decimalPoint: $. precision: 9.			stream cr.			(timepoint asAll: allCalendars) 				do: [:each | 					each printOn: stream using: printPolicy.					stream 						nextPutAll: ' ['.					ChronosFunction						printFractional: each fractionalDaysSinceEpoch asDecimalOn: stream decimalPoint: $. precision: 3.					stream						nextPutAll: ' days since ';						nextPutAll: each calendar name;						nextPutAll: ' Epoch]';						cr].			map 				at: '[', timepoint timeZone zuluNotation, '] ', timeZone identityString				put: stream contents].	^map</body><body package="Chronos-DateTimeInterval" selector="nowInAll:">nowInAll: aCollectionOfTimeZones	"Timepoint nowInAll: Timepoint commonWorldTimezones"	^self utNow inAll: aCollectionOfTimeZones.</body><body package="Chronos-DateTimeInterval" selector="nowInAllCalendars">nowInAllCalendars	"Timepoint nowInAllCalendars"	"{Transcript cr.	Timepoint nowInAllCalendars do: 		[:each | Transcript cr; show: (each printStringUsing: #universal)]}"	^self now inAllCalendars</body><body package="Chronos-DateTimeInterval" selector="nowInAllTimeZones">nowInAllTimeZones	"INSPECT IT: {Timepoint nowInAllTimeZones}"	^self utNow inAllTimeZones</body><body package="Chronos-DateTimeInterval" selector="nowInAllTimeZonesAndCalendars">nowInAllTimeZonesAndCalendars	"INSPECT IT: {Timepoint nowInAllTimeZonesAndCalendars}"	^self utNow inAllTimeZonesAndCalendars</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation</category><body package="Chronos-DateTimeInterval" selector="fromNative:as:">fromNative: aNativeCalendricalCoordinate as: calendar	^(Calendar referencedBy: calendar) clock 		chronosDateAndTimeFromNativeCalendricalCoordinate: aNativeCalendricalCoordinate</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextDateAndTimeFrom: stream usingFactory: self</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>instance creation-ISO 8601</category><body package="Chronos-DateTimeInterval" selector="isoNominalYear:week:dayOfWeek:">isoNominalYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoNominalYear: 2006 week: 1 dayOfWeek: ISOMonday"	^self 		isoYear: isoYear		week: isoWeekOrdinal		dayOfWeek: isoDayOfWeekOrdinal		timeZone: ChronosTimezone nominal</body><body package="Chronos-DateTimeInterval" selector="isoNominalYear:week:dayOfWeek:hour:minute:second:">isoNominalYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoNominalYear: 2006 week: 1 dayOfWeek: ISOMonday"	^self basicNew		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		setHour: hour minute: minute second: second;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoNominalYear:week:dayOfWeek:hour:minute:second:nanosecond:">isoNominalYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoNominalYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30 nanosecond: 500000000 "	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoUTYear:week:dayOfWeek:">isoUTYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoUTYear: 2006 week: 1 dayOfWeek: ISOMonday"	^self basicNew		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoUTYear:week:dayOfWeek:hour:minute:second:">isoUTYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoUTYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30"	^self basicNew		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoUTYear:week:dayOfWeek:hour:minute:second:nanosecond:">isoUTYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoUTYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30 nanosecond: 500000000"	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoUTYear:week:dayOfWeek:hour:minute:second:nanosecond:timeZone:">isoUTYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond timeZone: timeZone	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoUTYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30 nanosecond: 500000000 timeZone: #UT"	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoUTYear:week:dayOfWeek:hour:minute:second:timeZone:">isoUTYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second timeZone: timeZone	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoUTYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30 timeZone: #UT"	^self basicNew		setTimeZone: timeZone;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		setHour: hour minute: minute second: second;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoUTYear:week:dayOfWeek:timeZone:">isoUTYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal timeZone: timeZone	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoUTYear: 2006 week: 1 dayOfWeek: ISOMonday timeZone: #UT"	^self basicNew		setTimeZone: timeZone;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoYear:week:dayOfWeek:hour:minute:second:">isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30"	^self basicNew		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoYear:week:dayOfWeek:hour:minute:second:nanosecond:">isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30 nanosecond: 500000000"	^self basicNew		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoYear:week:dayOfWeek:hour:minute:second:nanosecond:timeZone:">isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond timeZone: timeZone	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30 nanosecond: 500000000 timeZone: 'Asia/Rangoon'"	^self basicNew		setTimeZone: timeZone;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoYear:week:dayOfWeek:hour:minute:second:timeZone:">isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second timeZone: timeZone	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoYear: 2006 week: 1 dayOfWeek: ISOMonday hour: 12 minute: 30 second: 30 timeZone: 'Asia/Rangoon'"	^self basicNew		setTimeZone: timeZone;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		setHour: hour minute: minute second: second;		canonicalizeFromLocalTime;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="isoYear:week:dayOfWeek:timeZone:">isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal timeZone: timeZone	"According to IS0 8601 specification (i.e., ISO week ordinal 1 starts on Monday of the week containing the 4th day of the year according to the Gregorian calendar--which may be in the previous Gregorian year.)"	"Timepoint isoYear: 2006 week: 1 dayOfWeek: ISOMonday timeZone: 'Asia/Rangoon'"	^self basicNew		setTimeZone: timeZone;		setIsoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal;		canonicalizeFromLocalTime;		beImmutable</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>class initialization</category><body package="Chronos-DateTimeInterval" selector="initialize">initialize	"Timepoint initialize"	universalTZ := nil.	nominalTZ := nil.</body><body package="Chronos-DateTimeInterval" selector="invalidateTimezones">invalidateTimezones	"DateAndTimeFactory invalidateTimezones"	self allInstancesDo: [:each | [each invalidateTimezone] on: Error do: [:ex | ex return]]</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>accessing</category><body package="Chronos-Parsing" selector="defaultParser">defaultParser	^ChronosParser iso8601</body></methods><methods><class-id>Chronos.Timepoint class</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="fromArray:">fromArray: anArray	"Answer a new DateAndTime from the two-element array anArray, which must contain an ST-80 Date and an ST-80 Time."	"Timepoint fromArray:(Filename defaultDirectory dates at: #created)"	^self fromDate: (anArray at: 1) andTime: (anArray at: 2)</body><body package="Chronos-ST80 (and VW) Compatibility" selector="fromDate:andTime:">fromDate: st80Date andTime: st80TimeOfDay	"Answer a DateAndTIme initialized from &lt;st80Date&gt; and &lt;st80TimeOfDay&gt;."	"Timepoint fromDate: Date today andTime: Time now"	^self new fromDate: st80Date andTime: st80TimeOfDay</body><body package="Chronos-ST80 (and VW) Compatibility" selector="fromSeconds:">fromSeconds: seconds	"Answer a new DateAndTime from the number of seconds since 12:00 am, January 1, 1901."	"Timepoint fromSeconds: Timestamp now asSeconds"	^self new fromSeconds: seconds</body><body package="Chronos-ST80 (and VW) Compatibility" selector="zero">zero	"Timepoint zero"	"Timestamp zero"	^self new basicSetDaysSinceEpoch: -366</body></methods><methods><class-id>Passport.Pathname</class-id> <category>accessing</category><body package="Passport-Kernel" selector="componentAt:">componentAt: index	^(components at: index) copy</body><body package="Passport-Kernel" selector="componentCount">componentCount	^components size</body><body package="Passport-Kernel" selector="components">components	^components copy</body><body package="Passport-Kernel" selector="componentsFrom:to:">componentsFrom: firstIndex to: lastIndex 	| stream |	firstIndex &gt; lastIndex ifTrue: [^nil].	stream := Array new: lastIndex - firstIndex + 1.	self 		componentsFrom: firstIndex		to: lastIndex		do: [:component | stream nextPut: component].	^stream contents</body><body package="Passport-Kernel" selector="firstComponentIfNone:">firstComponentIfNone: ifNone	^components size = 0		ifTrue: [ifNone value]		ifFalse: [self componentAt: 1]</body><body package="Passport-Kernel" selector="indexOfComponent:ifAbsent:">indexOfComponent: aComponent ifAbsent: ifAbsent	^components indexOf: aComponent ifAbsent: ifAbsent</body><body package="Passport-Kernel" selector="lastComponentIfNone:">lastComponentIfNone: ifNone	^components size = 0		ifTrue: [ifNone value]		ifFalse: [self componentAt: components size]</body><body package="Passport-Kernel" selector="value">value	"Assuming the receiver represents a hierarchical key of a value in a namespace defined in the current image's environment, answer the value at that key.  If there is no such key in the environment at the specified path, raise an Exception."	"(Pathname fromString: 'Object') value"	"(Pathname fromString: 'Chronos/Timepoint') value"	"(Pathname fromString: 'Smalltalk/Array') value"	^self valueIfNone: [self signalError: 'Key not found']</body><body package="Passport-Kernel" selector="valueIfNone:">valueIfNone: ifNoneAction 	"Assuming the receiver represents a hierarchical key of a value in a namespace defined in the current image's environment, answer the value at that key. If there is no such key in the environment at the specified path, answer the result of evaluating &lt;ifNoneAction&gt;."	"(Pathname fromString: 'Object') valueIfNone: []"	"(Pathname fromString: 'Chronos/Timepoint' ) valueIfNone: []"	"(Pathname fromString: 'Smalltalk/Array') valueIfNone: []"	^self valueIn: EnvironmentFacade current globalNamespace  ifNone: ifNoneAction</body><body package="Passport-Kernel" selector="valueIn:">valueIn: namespace	"Assuming the receiver represents a hierarchical key of a value in a namespace defined in the current image's environment, answer the value at that key.  If there is no such key in the environment at the specified path, raise an Exception."	"(Pathname fromString: 'Object') value"	"(Pathname fromString: 'Chronos/Timepoint') value"	"(Pathname fromString: 'Smalltalk/Array') value"	^self valueIn: namespace ifNone: [self signalError: 'Key not found']</body><body package="Passport-Kernel" selector="valueIn:ifNone:">valueIn: namespace ifNone: ifNoneAction 	"Assuming the receiver represents a hierarchical key of a value in a namespace defined in the current image's environment, answer the value at that key. If there is no such key in the environment at the specified path, answer the result of evaluating &lt;ifNoneAction&gt;."	"(Pathname fromString: 'Object') valueIfNone: []"	"(Pathname fromString: 'Chronos/Timepoint' ) valueIfNone: []"	"(Pathname fromString: 'Smalltalk/Array') valueIfNone: []"	components size &lt; 1 ifTrue: [^ifNoneAction value].	^components inject: namespace		into: [:ns :key | ns at: key asSymbol ifAbsent: [^ifNoneAction value]]</body></methods><methods><class-id>Passport.Pathname</class-id> <category>path operations</category><body package="Passport-Kernel" selector=",">, aPathname	^[aPathname appendToPathname: self] 		on: MessageNotUnderstood		do: 			[:ex | 			aPathname isString 				ifTrue: [self appending: aPathname]				ifFalse: [self appendingAll: aPathname]]</body><body package="Passport-Kernel" selector="appending:">appending: aComponent	^self copy		append: aComponent;		beImmutable</body><body package="Passport-Kernel" selector="appendingAll:">appendingAll: aComponentArray	^self copy		appendAll: aComponentArray;		beImmutable</body><body package="Passport-Kernel" selector="appendingExtension:">appendingExtension: aString 	| suffix |	suffix := components size = 0 				ifTrue: [^self appending: aString]				ifFalse: [components last].	^(self copy)		setLastComponent: suffix , aString;		beImmutable</body><body package="Passport-Kernel" selector="appendingPathname:">appendingPathname: aPathname	^self copy		appendPathname: aPathname;		beImmutable</body><body package="Passport-Kernel" selector="from:to:">from: firstIndex to: lastIndex	^self copy		setComponents: (components copyFrom: firstIndex to: lastIndex);		beImmutable</body><body package="Passport-Kernel" selector="prefixTo:">prefixTo: lastIndex	^self from: 1 to: lastIndex</body><body package="Passport-Kernel" selector="removing:">removing: aComponent	^self copy		setComponents: (components copyWithout: aComponent);		beImmutable</body><body package="Passport-Kernel" selector="suffixFrom:">suffixFrom: firstIndex	^self from: firstIndex to: self componentCount</body><body package="Passport-Kernel" selector="withAllButFirst">withAllButFirst	| componentCount |	componentCount := self componentCount.	^componentCount &gt; 1 		ifTrue: [self suffixFrom: 2]		ifFalse: 			[componentCount &gt; 0 				ifTrue: 					[(self copy)						initialize;						beImmutable]				ifFalse: [self]]</body><body package="Passport-Kernel" selector="withAllButLast">withAllButLast	| componentCount |	componentCount := self componentCount.	^componentCount &gt; 1 		ifTrue: [self prefixTo: componentCount - 1]		ifFalse: 			[componentCount &gt; 0 				ifTrue: 					[(self copy)						initialize;						beImmutable]				ifFalse: [self]]</body><body package="Passport-Kernel" selector="withFirst">withFirst	^self componentCount &gt; 1 		ifTrue: 			[(self copy)				setComponents: (Array with: components first);				beImmutable]		ifFalse: [self]</body><body package="Passport-Kernel" selector="withLast">withLast	^self componentCount &gt; 1 		ifTrue: 			[(self copy)				setComponents: (Array with: components last);				beImmutable]		ifFalse: [self]</body><body package="Passport-Kernel" selector="withoutExtension:">withoutExtension: extensionSeparator 	^self 		usingSeparator: extensionSeparator		lastComponentAndExtenstionIndexInto: 			[:lastComponent :index | 			(self copy)				setLastComponent: (lastComponent copyFrom: 1 to: index - 1);				beImmutable]		ifNone: [self]</body></methods><methods><class-id>Passport.Pathname</class-id> <category>private</category><body package="Passport-Kernel" selector="appendToPathname:">appendToPathname: aPathname	^aPathname appendingPathname: self</body><body package="Passport-Kernel" selector="appendToResourcePath:">appendToResourcePath: aResourcePath	^aResourcePath appendingPathname: self</body><body package="Passport-Kernel" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	super postCopy.	components := components copy.</body><body package="Passport-Kernel" selector="usingSeparator:lastComponentAndExtenstionIndexInto:ifNone:">usingSeparator: extensionSeparator lastComponentAndExtenstionIndexInto: block2 ifNone: ifNone	| lastComponent index |	lastComponent := self lastComponentIfNone: [^ifNone value].	index := lastComponent lastIndexOf: extensionSeparator ifAbsent: [^ifNone value].	index &lt;= 1 ifTrue: [^ifNone value "It is best if filenames of the form 'foo' or '.foo' are considered to have no extension"].	^block2 value: lastComponent value: index</body></methods><methods><class-id>Passport.Pathname</class-id> <category>converting</category><body package="Passport-Kernel" selector="asArray">asArray	^components copy</body><body package="Passport-Kernel" selector="asPathname">asPathname	^self</body><body package="Passport-Kernel" selector="asResourcePath">asResourcePath	^ResourcePath pathname: self</body></methods><methods><class-id>Passport.Pathname</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="append:">append: aComponent	(UtilityFunction isNilOrEmpty: aComponent) ifTrue: [^self].	self assertMutability.	components := components copyWith: aComponent</body><body package="Passport-Kernel" selector="appendAll:">appendAll: aComponentArray	(UtilityFunction isNilOrEmpty: aComponentArray) ifTrue: [^self].	self assertMutability.	components := components, aComponentArray</body><body package="Passport-Kernel" selector="appendPathname:">appendPathname: aPathname 	| stream |	(UtilityFunction isNilOrEmpty: aPathname) ifTrue: [^self].	self assertMutability.	stream := (Array new: components size + aPathname componentCount) writeStream.	components do: [:each | stream nextPut: each].	aPathname componentsDo: [:each | stream nextPut: each].	components := stream contents</body><body package="Passport-Kernel" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	components := #()</body><body package="Passport-Kernel" selector="setComponents:">setComponents: aComponentArray	self assertMutability.	components := aComponentArray == nil ifTrue: [#()] ifFalse: [aComponentArray copy]</body><body package="Passport-Kernel" selector="setLastComponent:">setLastComponent: aComponent	self assertMutability.	components size &gt; 0		ifTrue: [components at: components size put: aComponent]		ifFalse: [self append: aComponent]</body></methods><methods><class-id>Passport.Pathname</class-id> <category>printing</category><body package="Passport-Kernel" selector="printOn:">printOn: stream	self printOn: stream usingSeparator: $/</body><body package="Passport-Kernel" selector="printOn:usingSeparator:">printOn: stream usingSeparator: separator 	^self printOn: stream usingSeparator: separator andTransformer: [:component | component asString]</body><body package="Passport-Kernel" selector="printOn:usingSeparator:andTransformer:">printOn: stream usingSeparator: separator andTransformer: block1	| componentCount |	componentCount := self componentCount.	componentCount &gt; 0 		ifTrue: 			[self 				componentsFrom: 1				to: componentCount - 1				do: 					[:component | 					stream nextPutAll: (block1 value: component).					stream nextPut: separator].			stream nextPutAll: (block1 value: (self componentAt: componentCount))]</body><body package="Passport-Kernel" selector="printStringUsingSeparator:">printStringUsingSeparator: separator	^self printStringUsingSeparator: separator andTransformer: [:component | component asString]</body><body package="Passport-Kernel" selector="printStringUsingSeparator:andTransformer:">printStringUsingSeparator: separator andTransformer: block1	| stream |	stream := (String new: 12) writeStream.	self printOn: stream usingSeparator: separator andTransformer: block1.	^stream contents</body></methods><methods><class-id>Passport.Pathname</class-id> <category>testing</category><body package="Passport-Kernel" selector="hasExtensionUsingSeparator:">hasExtensionUsingSeparator: extensionSeparator	^self 		usingSeparator: extensionSeparator		lastComponentAndExtenstionIndexInto: [:lastComponent :index | true]		ifNone: [false]</body><body package="Passport-Kernel" selector="includesComponent:">includesComponent: aComponent	^components includes:  aComponent</body><body package="Passport-Kernel" selector="isDefined">isDefined	"Assuming the receiver represents a hierarchical key of a value in a namespace defined in the current image's environment, answer whether or not the binding (variable, constant, value, thing) specified by the key is defined."	"(Pathname fromString: 'Object') isDefined"	"(Pathname fromString: 'Chronos/Timepoint') isDefined"	"(Pathname fromString: 'Smalltalk/Array') isDefined"	components size &lt; 1 ifTrue: [^false].	components inject: EnvironmentFacade current globalNamespace into: [:namespace :key | namespace at: key asSymbol ifAbsent: [^false]].	^true</body><body package="Passport-Kernel" selector="isEmpty">isEmpty	^components isEmpty</body></methods><methods><class-id>Passport.Pathname</class-id> <category>queries</category><body package="Passport-Kernel" selector="extensionUsingSeparator:ifNone:">extensionUsingSeparator: extensionSeparator ifNone: ifNone 	^self 		usingSeparator: extensionSeparator		lastComponentAndExtenstionIndexInto: 			[:lastComponent :index | 			lastComponent copyFrom: index + 1 to: lastComponent size]		ifNone: ifNone</body></methods><methods><class-id>Passport.Pathname</class-id> <category>enumerating</category><body package="Passport-Kernel" selector="componentsDo:">componentsDo: block1	components do: [:component | block1 value: component copy]</body><body package="Passport-Kernel" selector="componentsFrom:to:do:">componentsFrom: firstIndex to: lastIndex do: block1 	firstIndex to: lastIndex		do: [:index | block1 value: (self componentAt: index)]</body></methods><methods><class-id>Passport.Pathname</class-id> <category>comparing</category><body package="Passport-Kernel" selector="compareTo:">compareTo: aPathname	"Compare the value of the receiver to that of &lt;aPathname&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aPathname&gt; are the same.)"	self == aPathname ifTrue: [^0].	^[aPathname compareToPathname: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aPathname and: [ex message selector == #compareToPathname:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Passport-Kernel" selector="hash">hash	^components hash</body></methods><methods><class-id>Passport.Pathname</class-id> <category>private-comparing</category><body package="Passport-Kernel" selector="compareToPathname:">compareToPathname: aPathname	| limit thisComponentCount thatComponentCount |	self isEmpty		ifTrue: [^aPathname isEmpty ifTrue: [0] ifFalse: [1]]		ifFalse: [aPathname isEmpty ifTrue: [^-1]].	limit := (thisComponentCount := self componentCount) min: (thatComponentCount := aPathname componentCount).	1 to: limit do: [:index |		| thisComponent  thatComponent |		thisComponent := self componentAt: index.		thatComponent := aPathname componentAt: index.		thatComponent &gt; thisComponent ifTrue: [^1].		thatComponent &lt; thisComponent ifTrue: [^-1].	].	^thatComponentCount - thisComponentCount</body></methods><methods><class-id>Passport.Pathname class</class-id> <category>instance creation</category><body package="Passport-Kernel" selector="components:">components: anArray	^self new		setComponents: anArray;		beImmutable</body><body package="Passport-Kernel" selector="fromString:">fromString: aString 	^self readFrom: aString readStream</body><body package="Passport-Kernel" selector="fromString:separator:">fromString: aString separator: separator 	"{Pathname fromString: 'foo/bar/mitzvah' separator: $/}"	^self 		fromString: aString		separator: separator		transformer: nil</body><body package="Passport-Kernel" selector="fromString:separator:transformer:">fromString: aString separator: separator transformer: block1 	"{Pathname fromString: 'foo/bar/mitzvah' separator: $/ transformer: [:component | component asUppercase]}"	^self 		readFrom: aString readStream		separator: separator		transformer: block1</body><body package="Passport-Kernel" selector="readFrom:">readFrom: stream	"{Pathname readFrom: 'foo/bar/mitzvah' readStream}"	^self readFrom: stream separator: $/</body><body package="Passport-Kernel" selector="readFrom:separator:">readFrom: stream separator: separator 	"{Pathname readFrom: 'foo/bar/mitzvah' readStream separator: $/}"	^self readFrom: stream separator: separator transformer: nil</body><body package="Passport-Kernel" selector="readFrom:separator:transformer:">readFrom: stream separator: separator transformer: block1	"{Pathname readFrom: 'foo/bar/mitzvah' readStream separator: $/ transformer: [:component | component asUppercase]}"	^self components: (UtilityFunction componentsFromStream: stream separator: separator transformer: block1)</body></methods><methods><class-id>Passport.Pathname class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="empty">empty	Empty == nil ifTrue: [Empty := self new beImmutable].	^Empty</body></methods><methods><class-id>Passport.Pathname class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="initialize">initialize	Empty := nil</body></methods><methods><class-id>Chronos.CalendricalAnnualDate</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinalForYearOfType:">minDayOfYearOrdinalForYearOfType: yearTypeCode	^self maxDayOfYearOrdinalForYearOfType: yearTypeCode</body></methods><methods><class-id>Chronos.CalendricalAnnualDate</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processCalendricalAnnualDate: self</body></methods><methods><class-id>Chronos.CalendricalAnnualDate class</class-id> <category>instance creation-local time</category><body package="Chronos-Annual Dates" selector="today">today	^self basicNew		initializeFrom: AnsiStandardCalendarClock today;		beImmutable</body><body package="Chronos-Annual Dates" selector="todayAs:">todayAs: aCalendar	^self basicNew		initializeFrom: ((Calendar referencedBy: aCalendar) clock today);		beImmutable</body><body package="Chronos-Annual Dates" selector="todayIn:">todayIn: aTimezone	^self basicNew		initializeFrom: (AnsiStandardCalendarClock todayIn: aTimezone);		beImmutable</body><body package="Chronos-Annual Dates" selector="todayIn:as:">todayIn: aTimezone as: aCalendar	^self basicNew		initializeFrom: ((Calendar referencedBy: aCalendar) clock todayIn: aTimezone);		beImmutable</body></methods><methods><class-id>Chronos.ChronosEnvironment</class-id> <category>testing</category><body package="Chronos-Environment" selector="willRebindDateAndTimeIfAlreadyDefinedInGlobalNamespace">willRebindDateAndTimeIfAlreadyDefinedInGlobalNamespace	"Answer whether or not the the value of the 'DateAndTime' global may be changed by Chronos if it's already defined in the global namespace."	^(self class protectedGlobalVariables includes: #DateAndTime) not</body><body package="Chronos-Environment" selector="willRebindDurationIfAlreadyDefinedInGlobalNamespace">willRebindDurationIfAlreadyDefinedInGlobalNamespace	"Answer whether or not the the value of the 'Duration' global may be changed by Chronos if it's already defined in the global namespace."	^(self class protectedGlobalVariables includes: #Duration) not</body><body package="Chronos-Environment" selector="willRebindSystemClockIfAlreadyDefinedInGlobalNamespace">willRebindSystemClockIfAlreadyDefinedInGlobalNamespace	"Answer whether or not the the value of the 'SystemClock' global may be changed by Chronos if it's already defined in the global namespace."	^(self class protectedGlobalVariables includes: #SystemClock) not</body><body package="Chronos-Environment" selector="willRebindTimezoneIfAlreadyDefinedInGlobalNamespace">willRebindTimezoneIfAlreadyDefinedInGlobalNamespace	"Answer whether or not the the value of the 'Timezone' global may be changed by Chronos if it's already defined in the global namespace."	^(self class protectedGlobalVariables includes: #Timezone) not</body></methods><methods><class-id>Chronos.ChronosEnvironment</class-id> <category>shared variables bindings</category><body package="Chronos-Environment" selector="initializeCalendarConstants">initializeCalendarConstants	Calendar initializeCalendarConstants.</body><body package="Chronos-Environment" selector="initializeChronosSharedVariables">initializeChronosSharedVariables	self initializeFactoryBindings.	self initializeCalendarConstants.	self initializeDurationConstants.</body><body package="Chronos-Environment" selector="initializeDurationConstants">initializeDurationConstants	"ChronosEnvironment canonical initializeDurationConstants"	| namespace |	ScientificDuration initializeClassVariables.	CalendarDuration initializeClassVariables.	namespace := self chronosNamespace at: #ChronosDurationConstants.	EnvironmentFacade current 		defineVariable: #CalendarDayDuration		in: namespace		withValue: (CalendarDurationFactory days: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current		defineVariable: #ClockDayDuration		in: namespace		withValue: (DurationFactory days: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current		defineVariable: #CivilSecondDuration		in: namespace		withValue: (CivilDurationFactory seconds: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #HourDuration		in: namespace		withValue: (CivilDurationFactory hours: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #MinuteDuration		in: namespace		withValue: (CivilDurationFactory minutes: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #MonthDuration		in: namespace		withValue: (CalendarDurationFactory months: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #NanosecondDuration		in: namespace		withValue: (DurationFactory nanoseconds: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #SecondDuration		in: namespace		withValue: (DurationFactory seconds: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #WeekDuration		in: namespace		withValue: (CalendarDurationFactory weeks: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #YearDuration		in: namespace		withValue: (CalendarDurationFactory years: 1)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ZeroCalendarDuration		in: namespace		withValue: CalendarDurationFactory zero		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ZeroDuration		in: namespace		withValue: DurationFactory zero		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body><body package="Chronos-Environment" selector="initializeFactoryBindings">initializeFactoryBindings	| namespace |	namespace := self chronosNamespace at: #ChronosFactoryBindings.	EnvironmentFacade current		defineVariable: #CalendarDurationFactory		in: namespace		withValue: CalendarDuration		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #CivilDurationFactory		in: namespace		withValue: CivilDuration		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #DateAndTimeFactory		in: namespace		withValue: Timepoint		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #DateFactory		in: namespace		withValue: YearMonthDay		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #DayOfMonthFactory		in: namespace		withValue: DayOfMonth		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #DayOfYearFactory		in: namespace		withValue: DayOfYear		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #DurationFactory		in: namespace		withValue: ScientificDuration		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #SequenceFactory		in: namespace		withValue: OrderedCollection		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #TimeOfDayFactory		in: namespace		withValue: TimeOfDay		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #TimeperiodFactory		in: namespace		withValue: Timeperiod		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #WeekOfMonthDayOfWeekFactory		in: namespace		withValue: WeekOfMonthDayOfWeek		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body><body package="Chronos-Environment" selector="setAnsiStandardCalendar:">setAnsiStandardCalendar: aGregorianCalendar	EnvironmentFacade current 		defineVariable: #AnsiStandardCalendar		in:(self chronosNamespace at: #ChronosCalendarConstants)		withValue: (aGregorianCalendar == nil ifFalse: [aGregorianCalendar assertIsGregorian])		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body><body package="Chronos-Environment" selector="setAnsiStandardCalendarClock:">setAnsiStandardCalendarClock: aGregorianCalendarClock	aGregorianCalendarClock == nil ifFalse: [aGregorianCalendarClock calendar assertIsGregorian].	EnvironmentFacade current 		defineVariable: #AnsiStandardCalendarClock		in:(self chronosNamespace at: #ChronosCalendarConstants)		withValue: aGregorianCalendarClock		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body><body package="Chronos-Environment" selector="setGregorian:">setGregorian: aGregorianCalendar	EnvironmentFacade current 		defineVariable: #Gregorian		in:(self chronosNamespace at: #ChronosCalendarConstants)		withValue: (aGregorianCalendar == nil ifFalse: [aGregorianCalendar assertIsGregorian])		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body><body package="Chronos-Environment" selector="setJulian:">setJulian: aJulianCalendar	EnvironmentFacade current 		defineVariable: #Julian		in:(self chronosNamespace at: #ChronosCalendarConstants)		withValue: (aJulianCalendar == nil ifFalse: [aJulianCalendar assertIsJulian])		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body></methods><methods><class-id>Chronos.ChronosEnvironment</class-id> <category>installation/setup</category><body package="Chronos-Environment" selector="install">install	"ChronosEnvironment canonical install"	self class shouldSkipInstallation ifTrue: [^self].	self class preInstall; setInstallationCount.	ChronosSystemFacade current reportCommencementOfInitialChronosInstallation.	self initializeChronosSharedVariables.	self defineChronosGlobalsAndAliases.	TemporalCoordinate defineRangeConstraints.	ChronosLocale initializeDefaultLocaleInformation.	EnvironmentFacade current purgeUnusedBindingsFromUndeclaredNamespace.	self class incrementInstallationCount	.	self installSystemFacade</body><body package="Chronos-Environment" selector="installSystemFacade">installSystemFacade	ChronosSystemFacade current shouldSkipInstallation		ifTrue: [ChronosSystemFacade current reportInstallationSkipped]		ifFalse: 			[ChronosSystemFacade current instalIInitially.			ChronosSystemFacade current reportInitialChronosInstallationAsSuccessful]</body><body package="Chronos-Environment" selector="invalidateCalendarBindings">invalidateCalendarBindings	"ChronosEnvironment canonical invalidateCalendarBindings"	YearlyCalendar invalidateCalendarBindings.	CalendarClock invalidateCalendarBindings.	TemporalInterval invalidateCalendarBindings.	DateSpec invalidateCalendarBindings</body><body package="Chronos-Environment" selector="invalidateTimezones">invalidateTimezones	"ChronosEnvironment canonical invalidateTimezones"	AnnuallyRecurringTZPolicyFactory initialize.	TimeZonePolicyFactory initialize.	ChronosTimezone invalidate.	DateAndTimeFactory initialize.	TimeZoneLocalizationPolicy initialize.</body><body package="Chronos-Environment" selector="reinstall">reinstall	"Reinitialize Chronos, under the assumption that major changes have been made to the Chronos codebase. It would be wise to perform this operation after loading a new version of Chronos into an image in which a different version was already resident." 	"ChronosEnvironment canonical reinstall"	self class shouldSkipInstallation ifTrue: [^self].	self class shouldDoInstallationInsteadOfReinstallation ifTrue: [^self install].	self class incrementInstallationCount	.	self class shouldSkipReinstallation ifTrue: [^self].	self reportToConsole: 'New version installed. Reinitializing Chronos...'.	AnnualDate initialize.	ComputedAnnualDate initializeAll.	SemanticDatePolicy initialize.	ChronosLocale 		initialize; 		initializeDefaultLocaleInformation.	ChronosPrintPolicy initialize.	ChronosParser initialize.	Calendar invalidate.	self initializeChronosSharedVariables.	self defineChronosGlobalsAndAliases.	self invalidateCalendarBindings.	TemporalCoordinate defineRangeConstraints.		self  invalidateTimezones.	ChronosSystemFacade current 		showReportsWhile: [ChronosSystemFacade current install].	EnvironmentFacade current purgeUnusedBindingsFromUndeclaredNamespace.	[self		reportToConsole: 'Reinitialized: ', (DateAndTimeFactory now % #rfc2822v);		newLineToConsole] on: Error do: [:ex | ChronosSystemFacade current reportException: ex message: 'The following error occured during reinitialization: ']</body><body package="Chronos-Environment" selector="tzAdministrationalInstalled">tzAdministrationalInstalled	"The Chronos-Utilities module has been installed.  Take whatever action may be appropriate."	EnvironmentFacade current purgeUnusedBindingsFromUndeclaredNamespace</body></methods><methods><class-id>Chronos.ChronosEnvironment</class-id> <category>accessing</category><body package="Chronos-Environment" selector="chronosNamespace">chronosNamespace	^self class chronosNamespace</body><body package="Chronos-Environment" selector="copyrightNotice">copyrightNotice	^'NOTICE: All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2007 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html}).'</body><body package="Chronos-Environment" selector="globalNamespace">globalNamespace	^EnvironmentFacade current globalNamespace</body></methods><methods><class-id>Chronos.ChronosEnvironment</class-id> <category>initialize-release</category><body package="Chronos-Environment" selector="initialize">initialize	"Be default, do nothing."</body></methods><methods><class-id>Chronos.ChronosEnvironment</class-id> <category>global variable bindings</category><body package="Chronos-Environment" selector="defineChronosGlobalsAndAliases">defineChronosGlobalsAndAliases	"ChronosEnvironment canonical defineChronosGlobalsAndAliases"	self defineDateAndTimeInGlobalNamespace.	self defineDurationInGlobalNamespace.	self defineTimezoneInGlobalNamespace.</body><body package="Chronos-Environment" selector="defineDateAndTimeInGlobalNamespace">defineDateAndTimeInGlobalNamespace	"ChronosEnvironment canonical defineDateAndTimeInGlobalNamespace"	EnvironmentFacade current		defineVariable: #DateAndTime		in: self globalNamespace		withValue: Timepoint		constant: true		category: #'Chronos-Aliases'		rebindIfPresent: self willRebindDateAndTimeIfAlreadyDefinedInGlobalNamespace		onCollision: 			[self reportToConsole: 'Unable to define DateAndTime as a global alias for Timepoint--entry with the same name already present in the global namespace.'. 			EnvironmentFacade current				defineVariable: #DateAndTime				in: self chronosNamespace				withValue: Timepoint				constant: true				category: #'Chronos-Aliases'				rebindIfPresent: self chronosNamespace ~~ self globalNamespace				onCollision: []]</body><body package="Chronos-Environment" selector="defineDurationInGlobalNamespace">defineDurationInGlobalNamespace	"ChronosEnvironment canonical defineDurationInGlobalNamespace"	EnvironmentFacade current		defineVariable: #Duration		in: self globalNamespace		withValue: ScientificDuration		constant: true		category: #'Chronos-Aliases'		rebindIfPresent: self willRebindDurationIfAlreadyDefinedInGlobalNamespace		onCollision: 			[self reportToConsole: 'Unable to define Duration as a global alias for ScientificDuration--entry with the same name already present in the global namespace.'. 			EnvironmentFacade current				defineVariable: #Duration				in: self chronosNamespace				withValue: ScientificDuration				constant: true				category: #'Chronos-Aliases'				rebindIfPresent: self chronosNamespace ~~ self globalNamespace				onCollision: []].</body><body package="Chronos-Environment" selector="defineSystemClockInGlobalNamespace">defineSystemClockInGlobalNamespace	"ChronosEnvironment canonical defineSystemClockInGlobalNamespace"	EnvironmentFacade current		defineVariable: #SystemClock		in: self globalNamespace		withValue: ChronosSystemClock current		constant: false		category: #'Chronos-Globals'		rebindIfPresent: self willRebindSystemClockIfAlreadyDefinedInGlobalNamespace		onCollision: 			[EnvironmentFacade current				defineVariable: #SystemClock				in: self chronosNamespace				withValue: ChronosSystemClock current				constant: true				category: #'Chronos-Globals'				rebindIfPresent: self chronosNamespace ~~ self globalNamespace				onCollision: []].</body><body package="Chronos-Environment" selector="defineTimezoneInGlobalNamespace">defineTimezoneInGlobalNamespace	"ChronosEnvironment canonical defineTimezoneInGlobalNamespace"	EnvironmentFacade current 		defineVariable: #Timezone		in: self globalNamespace		withValue: ChronosTimezone		constant: true		category: #'Chronos-Aliases'		rebindIfPresent: self willRebindTimezoneIfAlreadyDefinedInGlobalNamespace		onCollision: 			[self reportToConsole: 'Unable to define Timezone as a global alias for ChronosTimezone--entry with the same name already present in the global namespace.'. 			EnvironmentFacade current				defineVariable: #Timezone				in: self chronosNamespace				withValue: ChronosTimezone				constant: true				category: #'Chronos-Aliases'				rebindIfPresent: self chronosNamespace ~~ self globalNamespace				onCollision: []].</body></methods><methods><class-id>Chronos.ChronosEnvironment class</class-id> <category>accessing</category><body package="Chronos-Environment" selector="appOrLibraryName">appOrLibraryName	^'Chronos'</body><body package="Chronos-Environment" selector="canonical">canonical	"Answer the canonical instance of the receiver--the one that is correct for the current Smalltalk environment."	"ChronosEnvironment canonical"	Canonical == nil ifTrue: [Canonical := self new].	^Canonical</body><body package="Chronos-Environment" selector="chronosNamespace">chronosNamespace	"Answer the namespace that contains the classes of the Chronos codebase."	^self globalNamespace</body><body package="Chronos-Environment" selector="chronosNamespaceName">chronosNamespaceName	"Answer the name of the namespace that contains the classes of the Chronos codebase."	^EnvironmentFacade current globalNamespaceName</body><body package="Chronos-Environment" selector="globalNamespace">globalNamespace	"Answer the namespace canonically (or most generally) used for the purpose of defining and accessing classes by the host Smalltalk implementation."	^EnvironmentFacade current globalNamespace</body><body package="Chronos-Environment" selector="globalNamespaceName">globalNamespaceName	"Answer the name of the namespace canonically (or most generally) used for the purpose of defining and accessing classes by the host Smalltalk implementation."	^EnvironmentFacade current globalNamespaceName</body><body package="Chronos-Environment" selector="platformClass">platformClass	PlatformClass == nil ifTrue: [self setPlatformClass].	^PlatformClass == nil ifTrue: [self] ifFalse: [PlatformClass]</body><body package="Chronos-Environment" selector="protectedGlobalVariables">protectedGlobalVariables	ProtectedGlobalVariables == nil		ifTrue: [self setProtectedGlobalVariables].	^ProtectedGlobalVariables</body><body package="Chronos-Environment" selector="standardChronosGlobalVariableNames">standardChronosGlobalVariableNames	"Answer a Collection of the names (as Symbols) of the global variables that Chronos would like to define and set to new values, if it is permitted to do so."	^#(DateAndTime #Duration #SystemClock #Timezone #ScaledDecimal)</body><body package="Chronos-Environment" selector="systemFacadeClass">systemFacadeClass	"Answer the concrete subclass of ChronosSystemFacade whose implementation is specific to the current Smalltalk platform and usage context."	| pc |	pc := self platformClass.	^(pc == nil or: [pc == ChronosEnvironment])		ifTrue: [self signal: Error message: 'Failure to resolve concrete ChronosSystemFacade subclass specifically implemented for use in this Smalltalk environment']		ifFalse: [pc systemFacadeClass]</body></methods><methods><class-id>Chronos.ChronosEnvironment class</class-id> <category>shared/global variable bindings</category><body package="Chronos-Environment" selector="defineChronosCalendarConstants">defineChronosCalendarConstants	| namespace | 	namespace := self chronosNamespace at: #ChronosCalendarConstants.	EnvironmentFacade current 		defineVariable: #AnsiStandardCalendar		in: namespace		withValue: nil		constant: true		category: #public		rebindIfPresent: false		onCollision: [].	EnvironmentFacade current 		defineVariable: #AnsiStandardCalendarClock		in: namespace		withValue: nil		constant: true		category: #public		rebindIfPresent: false		onCollision: [].	EnvironmentFacade current 		defineVariable: #Gregorian		in: namespace		withValue: nil		constant: true		category: #public		rebindIfPresent: false		onCollision: [].	EnvironmentFacade current 		defineVariable: #Julian		in: namespace		withValue: nil		constant: true		category: #public		rebindIfPresent: false		onCollision: [].</body><body package="Chronos-Environment" selector="defineChronosConstants">defineChronosConstants	| namespace |	namespace := self globalNamespace at: #ChronosConstants.	EnvironmentFacade current 		defineVariable: #MeridianKeys		in: namespace		withValue: #(#'ante-meridian' #'post-meridian')		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	self defineChronosConstantsNamespaceImports</body><body package="Chronos-Environment" selector="defineChronosDaysOfWeekConstants">defineChronosDaysOfWeekConstants	| namespace | 	namespace := self chronosNamespace at: #ChronosDaysOfWeekConstants.	"ANSI Smaltalk Values--must conform to ANSI Smalltalk Standard"	EnvironmentFacade current 		defineVariable: #ANSIDayOfWeekKeys		in: namespace		withValue: #(Sunday Monday Tuesday Wednesday Thursday Friday Saturday)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #Friday		in: namespace		withValue: 6		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #Monday		in: namespace		withValue: 2		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #Saturday		in: namespace		withValue: 7		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #Sunday		in: namespace		withValue: 1		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #Thursday		in: namespace		withValue: 5		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #Tuesday		in: namespace		withValue: 3		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #Wednesday		in: namespace		withValue: 4		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	"ISO 8601 Values--must conform to ISO 8601 international standard."	EnvironmentFacade current 		defineVariable: #ISODayOfWeekKeys		in: namespace		withValue: #(Monday Tuesday Wednesday Thursday Friday Saturday Sunday)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOFriday		in: namespace		withValue: 5		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOMonday		in: namespace		withValue: 1		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOSaturday		in: namespace		withValue: 6		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOSunday		in: namespace		withValue: 7		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOThursday		in: namespace		withValue: 4		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOTuesday		in: namespace		withValue: 2		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOWednesday		in: namespace		withValue: 3		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body><body package="Chronos-Environment" selector="defineChronosDurationConstants">defineChronosDurationConstants	| namespace | 	namespace := self chronosNamespace at: #ChronosDurationConstants.	#(CalendarDayDuration CivilSecondDuration ClockDayDuration HourDuration MinuteDuration MonthDuration NanosecondDuration SecondDuration WeekDuration YearDuration ZeroDuration ZeroCalendarDuration) do: 		[:key | 			EnvironmentFacade current 				defineVariable: key				in: namespace				withValue: nil				constant: true				category: #public				rebindIfPresent: false				onCollision: []].</body><body package="Chronos-Environment" selector="defineChronosFactoryBindings">defineChronosFactoryBindings	| namespace | 	namespace := self chronosNamespace at: #ChronosFactoryBindings.	#(CalendarDurationFactory CivilDurationFactory DateAndTimeFactory DateFactory DayOfMonthFactory DayOfYearFactory DurationFactory SequenceFactory TimeOfDayFactory TimeperiodFactory WeekOfMonthDayOfWeekFactory) do: 		[:key | 			EnvironmentFacade current 				defineVariable: key				in: namespace				withValue: nil				constant: true				category: #public				rebindIfPresent: false				onCollision: []].</body><body package="Chronos-Environment" selector="defineChronosGlobalsAndAliases">defineChronosGlobalsAndAliases	self standardChronosGlobalVariableNames do: [:key |		EnvironmentFacade current 			defineVariable: key			in: self globalNamespace			withValue: nil			constant: true			category: #'Chronos-Aliases'			rebindIfPresent: false			onCollision: []].</body><body package="Chronos-Environment" selector="defineChronosStandardMonthConstants">defineChronosStandardMonthConstants	| namespace | 	namespace := self chronosNamespace at: #ChronosStandardMonthConstants.	EnvironmentFacade current 		defineVariable: #April		in: namespace		withValue: 4		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #August		in: namespace		withValue: 8		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #December		in: namespace		withValue: 12		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #February		in: namespace		withValue: 2		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #ISOMonthKeys		in: namespace		withValue: #(January February March April May June July August September October November December)		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #January		in: namespace		withValue: 1		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #July		in: namespace		withValue: 7		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #June		in: namespace		withValue: 6		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #March		in: namespace		withValue: 3		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #May		in: namespace		withValue: 5		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #November		in: namespace		withValue: 11		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #October		in: namespace		withValue: 10		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #September		in: namespace		withValue: 9		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body><body package="Chronos-Environment" selector="defineChronosTemporalRatioConstants">defineChronosTemporalRatioConstants	| namespace | 	namespace := self chronosNamespace at: #ChronosTemporalRatioConstants.	EnvironmentFacade current 		defineVariable: #DaysPerWeek		in: namespace		withValue: 7		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #HoursPerDay		in: namespace		withValue: 24		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #MicrosecondsPerMillisecond		in: namespace		withValue: 1000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #MicrosecondsPerSecond		in: namespace		withValue: 1000000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #MillisecondsPerSecond		in: namespace		withValue: 1000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #MinutesPerDay		in: namespace		withValue: 1440		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #MinutesPerHour		in: namespace		withValue: 60		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #NanosecondsPerDay		in: namespace		withValue: 86400000000000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #NanosecondsPerHour		in: namespace		withValue: 3600000000000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #NanosecondsPerMicrosecond		in: namespace		withValue: 1000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #NanosecondsPerMillisecond		in: namespace		withValue: 1000000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #NanosecondsPerMinute		in: namespace		withValue: 60000000000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #NanosecondsPerSecond		in: namespace		withValue: 1000000000		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #SecondsPerDay		in: namespace		withValue: 86400		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #SecondsPerHour		in: namespace		withValue: 3600		constant: true		category: #public		rebindIfPresent: true		onCollision: [].	EnvironmentFacade current 		defineVariable: #SecondsPerMinute		in: namespace		withValue: 60		constant: true		category: #public		rebindIfPresent: true		onCollision: [].</body></methods><methods><class-id>Chronos.ChronosEnvironment class</class-id> <category>installation/setup</category><body package="Chronos-Environment" selector="defineChronosNamespaces">defineChronosNamespaces	self defineChronosNamespace.	self defineChronosTemporalRatioConstantsNamespace.	self defineChronosDaysOfWeekConstantsNamespace.	self defineChronosStandardMonthConstantsNamespace.	self defineChronosFactoryBindingsNamespace.	self defineChronosCalendarConstantsNamespace.	self defineChronosDurationConstantsNamespace.	self defineChronosConstantsNamespace.</body><body package="Chronos-Environment" selector="defineChronosSharedAndGlobalVariables">defineChronosSharedAndGlobalVariables	self defineChronosTemporalRatioConstants.	self defineChronosDaysOfWeekConstants.	self defineChronosStandardMonthConstants.	self defineChronosFactoryBindings.	self defineChronosCalendarConstants.	self defineChronosDurationConstants.	self defineChronosConstants.	self defineChronosGlobalsAndAliases</body><body package="Chronos-Environment" selector="preInstall">preInstall	(InstallationCount == nil or: [InstallationCount &gt;= 0]) ifTrue: [InstallationCount := 2].	self shouldSkipInstallation ifTrue: [^self].	self platformClass defineChronosNamespaces.	self platformClass defineChronosSharedAndGlobalVariables</body></methods><methods><class-id>Chronos.ChronosEnvironment class</class-id> <category>private</category><body package="Chronos-Environment" selector="doInstallationInsteadOfReinstallation">doInstallationInsteadOfReinstallation	InstallationCount := -1</body><body package="Chronos-Environment" selector="incrementInstallationCount">incrementInstallationCount	InstallationCount := self installationCount + 1</body><body package="Chronos-Environment" selector="installationCount">installationCount	InstallationCount == nil 		ifTrue: [InstallationCount := 2].	^InstallationCount</body><body package="Chronos-Environment" selector="setInstallationCount">setInstallationCount	InstallationCount := 0</body><body package="Chronos-Environment" selector="setPlatformClass">setPlatformClass	"Set the concrete subclass of the reciever whose implmentation is specific to the current Smalltalk platform and usage context."	"This version of the method assumes that any subclass of the receiver is competent to perform the function requested. If you're porting Chronos from one Smalltalk platform to another, this method must be subimplemented by all direct subclasses so that all (direct) subimplementations will correctly set the  PlatformClass to be the subclass of ChronosEnvironment appropriate for the particular version of the Smalltalk environment/platform into which Chronos finds itself being loaded when #setPlatformClass is sent to the receiver (or any direct subclass.)  The code to figure out which version of Squeak, or of Dolphin, or or VAST, or of ST/X (etc) on which the code is running is of course specific to each Smalltalk flavor.  Also, how many different versions of ChronosEnvironment may be needed in order to handle all the versions of a particular Smalltalk environment, and which specific subclass of ChronosEnvironment is optimal for each version, depends on the platform.  	As the person doing the port, how far into the past you wish to provide support is up to you.  Support for previous (or future) versions can always be added later."	self subclasses do: [:any | ^any setPlatformClass]</body><body package="Chronos-Environment" selector="setProtectedGlobalVariables">setProtectedGlobalVariables	"Set &lt;ProtectedGlobalVariables&gt; to be a Set containing the names (as Symbols) of any variables (e.g., class names) in the host Smalltalk's global namespace whose values should not be changed by Chronos.  The only required entries are the names of any classes (or other global variable names) that canonically exist in the host Smalltalk's global namespace AND that Chronos would (re)define/initialize if permitted.  	Note 1: Evaluate 'ChronosEnvironment platformClass standardChronosGlobalVariableNames' to get all global variable names whose values Chronos would like to define and set to new values unless the names of those variables are included in &lt;ProtectedGlobalVariables&gt;.	Note 2: Versions of Squeak with Brent Pinkney's Chronology library installed should set the value of &lt;ProtectedGlobalVariables&gt; to 'Set with: #DateAndTime with: #Duration'."	ProtectedGlobalVariables := Set with: #ScaledDecimal.</body><body package="Chronos-Environment" selector="shouldDoInstallationInsteadOfReinstallation">shouldDoInstallationInsteadOfReinstallation	^self installationCount = -1</body><body package="Chronos-Environment" selector="shouldSkipInstallation">shouldSkipInstallation	^ChronosEnvironment subclasses size = 0 or: 			[(self globalNamespace at: #ChronosInstallationFlag ifAbsent: [true]) 				= false]</body><body package="Chronos-Environment" selector="shouldSkipReinstallation">shouldSkipReinstallation	^self installationCount = 2</body></methods><methods><class-id>Chronos.ChronosEnvironment class</class-id> <category>instance creation</category><body package="Chronos-Environment" selector="new">new	^self platformClass basicNew initialize</body></methods><methods><class-id>Chronos.ChronosEnvironment class</class-id> <category>class initialization</category><body package="Chronos-Environment" selector="initialize">initialize	"ChronosEnvironment initialize."	NotAValue := Object new.	Canonical := nil.	PlatformClass := nil.	ProtectedGlobalVariables := nil.	self preInstall</body><body package="Chronos-Environment" selector="release">release	"The message #release must be sent to the current 'ChronosEnvironment platformClass' whenever Chronos is about to be removed from the system (image.)  It is the responsibility of subimplementors to ensure that this message is sent at the appropriate time."	self standardChronosGlobalVariableNames do: 			[:varName | 			(self protectedGlobalVariables includes: varName) 				ifFalse: [self globalNamespace removeKey: varName ifAbsent: []]].</body></methods><methods><class-id>Chronos.ChronosEnvironment class</class-id> <category>namespace operations</category><body package="Chronos-Environment" selector="defineChronosCalendarConstantsNamespace">defineChronosCalendarConstantsNamespace	"Define a namespace named ChronosCalendarConstants"	EnvironmentFacade current 		defineVariable: #ChronosCalendarConstants		in: self chronosNamespace		withValue: self newNamespace		constant: true		category: #'Chronos-Environment'		rebindIfPresent: false		onCollision: ["If already defined, then we'll just use it."]</body><body package="Chronos-Environment" selector="defineChronosConstantsNamespace">defineChronosConstantsNamespace	"Define a namespace named ChronosConstants"	EnvironmentFacade current 		defineVariable: #ChronosConstants		in: self globalNamespace		withValue: self newNamespace		constant: true		category:  #'Chronos-Environment'		rebindIfPresent: false		onCollision: ["If already defined, then we'll just use it."]</body><body package="Chronos-Environment" selector="defineChronosConstantsNamespaceImports">defineChronosConstantsNamespaceImports	"Cause the #ChronosConstants namespace to 'import' from all the other Chronos namespaces that contain constants and/or aliases (i.e., all of the other Chronos namespaces except for the #Chronos namespace.) Ideally, this should be done by means of dynamic delegation from the #ChronosConstants namespace to the other namespaces.  However, if necessary, it may also be achieved by copying the bindings from the other namespaces into the #ChronosConstants namespace, or even by duplicating the key-&gt;value entries."	| namespace | 	namespace := self globalNamespace at: #ChronosConstants.	EnvironmentFacade current		addImport: (Array with: self chronosNamespaceName with: #ChronosTemporalRatioConstants)		in: namespace private: false.	EnvironmentFacade current		addImport: (Array with: self chronosNamespaceName with: #ChronosDaysOfWeekConstants)		in: namespace private: false.	EnvironmentFacade current		addImport: (Array with: self chronosNamespaceName with: #ChronosStandardMonthConstants)		in: namespace private: false.	EnvironmentFacade current		addImport: (Array with: self chronosNamespaceName with: #ChronosFactoryBindings)		in: namespace private: false.	EnvironmentFacade current		addImport: (Array with: self chronosNamespaceName with: #ChronosCalendarConstants)		in: namespace private: false.	EnvironmentFacade current 		addImport: (Array with: self chronosNamespaceName with: #ChronosDurationConstants)		in: namespace private: false.</body><body package="Chronos-Environment" selector="defineChronosDaysOfWeekConstantsNamespace">defineChronosDaysOfWeekConstantsNamespace	"Define a namespace named ChronosDaysOfWeekConstants"	EnvironmentFacade current 		defineVariable: #ChronosDaysOfWeekConstants		in: self chronosNamespace		withValue: self newNamespace		constant: true		category: #'Chronos-Environment'		rebindIfPresent: false		onCollision: ["If already defined, then we'll just use it."]</body><body package="Chronos-Environment" selector="defineChronosDurationConstantsNamespace">defineChronosDurationConstantsNamespace	"Define a namespace named ChronosDurationConstants"	EnvironmentFacade current 		defineVariable: #ChronosDurationConstants		in: self chronosNamespace		withValue: self newNamespace		constant: true		category: #'Chronos-Environment'		rebindIfPresent: false		onCollision: ["If already defined, then we'll just use it."]</body><body package="Chronos-Environment" selector="defineChronosFactoryBindingsNamespace">defineChronosFactoryBindingsNamespace	"Define a namespace named ChronosFactoryBindings"	EnvironmentFacade current 		defineVariable: #ChronosFactoryBindings		in: self chronosNamespace		withValue: self newNamespace		constant: true		category: #'Chronos-Environment'		rebindIfPresent: false		onCollision: ["If already defined, then we'll just use it."]</body><body package="Chronos-Environment" selector="defineChronosNamespace">defineChronosNamespace	"Define a namespace named Chronos--if and only if the host Smalltalk implementation provides the necessary tools and facilities for defining, browsing and editing the classes of the Chronos Date/Time library in an indepedendent namespace named Chronos. Otherwise, do nothing.	Subclasses implemented for Smalltalk platforms that do provide sufficient system/tool support for multiple, independent namepaces, in which classes can natively reside without becoming invisible to the programming tools, should subimplment this method to define a namespace named 'Chronos'"</body><body package="Chronos-Environment" selector="defineChronosStandardMonthConstantsNamespace">defineChronosStandardMonthConstantsNamespace	"Define a namespace named ChronosStandardMonthConstants"	EnvironmentFacade current 		defineVariable: #ChronosStandardMonthConstants		in: self chronosNamespace		withValue: self newNamespace		constant: true		category: #'Chronos-Environment'		rebindIfPresent: false		onCollision: ["If already defined, then we'll just use it."]</body><body package="Chronos-Environment" selector="defineChronosTemporalRatioConstantsNamespace">defineChronosTemporalRatioConstantsNamespace	"Define a namespace named ChronosTemporalRatioConstants"	EnvironmentFacade current 		defineVariable: #ChronosTemporalRatioConstants		in: self chronosNamespace		withValue: self newNamespace		constant: true		category: #'Chronos-Environment'		rebindIfPresent: false		onCollision: ["If already defined, then we'll just use it."]</body><body package="Chronos-Environment" selector="newNamespace">newNamespace	^Dictionary new</body></methods><methods><class-id>Chronos.ClassicVWChronosEnvironment class</class-id> <category>accessing</category><body package="Chronos-Environment-VW" selector="systemFacadeClass">systemFacadeClass	"Answer the concrete subclass of ChronosSystemFacade whose implementation is specific to the current Smalltalk platform and usage context."	| versionNumber |	versionNumber := EnvironmentFacade current versionNumber.	^versionNumber &gt;= 70 		ifTrue: [VWSystemFacade]		ifFalse: 			[versionNumber &gt;= 50 				ifTrue: [VWv5iSystemFacade]				ifFalse: [VWClassicSystemFacade]]</body></methods><methods><class-id>Chronos.ClassicVWChronosEnvironment class</class-id> <category>initialize-release</category><body package="Chronos-Environment-VW" selector="removeFromSystem">removeFromSystem	"Forget the receiver, and all of its subclasses, from the receiver's Namespace. Any existing instances will refer to an obsolete version of the receiver."	self == self platformClass ifTrue: [self release].	super removeFromSystem</body><body package="Chronos-Environment-VW" selector="removeFromSystem:">removeFromSystem: loggingLevel		"Forget the receiver, and all of its subclasses, from the receiver's Namespace. Any existing instances will refer to an obsolete version of the receiver."	self == self platformClass ifTrue: [self release].	super removeFromSystem: loggingLevel</body></methods><methods><class-id>Chronos.ClassicVWChronosEnvironment class</class-id> <category>private</category><body package="Chronos-Environment-VW" selector="setPlatformClass">setPlatformClass	"Set the concrete subclass of the reciever whose implmentation is specific to the current Smalltalk platform and usage context."	"This version of the method is VisualsWorks-specific. If you're porting Chronos from VisualWorks to some other Smalltalk platform, this method must be rewritten so that it sets PlatformClass to be the correct subclass of ChronosEnvironment for the particular version of the Smalltalk environment/platform into which Chronos finds itself being loaded when this method is invoked.  The code to figure out which version of Squeak, or of Dolphin, or or VAST, or of ST/X (etc) on which the code is running is of course specific to each Smalltalk flavor.  Also, how many different versions of ChronosEnvironment may be needed in order to handle all the versions of a particular Smalltalk environment, and which specific subclass of ChronosEnvironment is optimal for each version, depends on the platform.  	As the person doing the port, how far into the past you wish to provide support is up to you.  Support for previous (or future) versions can always be added later."	PlatformClass := EnvironmentFacade current versionNumber &gt;= 50 ifTrue: [VWChronosEnvironment] ifFalse: [ClassicVWChronosEnvironment].</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransitionFactory</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="maxDaysFromStartOfYearUntilTransitionForYearOfType:">maxDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^self subclassResponsibility</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="minDaysFromStartOfYearUntilTransitionForYearOfType:">minDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^self subclassResponsibility</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="relativity">relativity	^relativity</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionSecondsSinceStartOfDay">transitionSecondsSinceStartOfDay	^transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransitionFactory</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isSpecifiedAsLocalTime">isSpecifiedAsLocalTime	^relativity == #nominal</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isSpecifiedAsStandardTime">isSpecifiedAsStandardTime	^relativity == #standard</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isSpecifiedAsUT">isSpecifiedAsUT	^relativity == #universal</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="specifiesIntraYearTransition">specifiesIntraYearTransition	^true</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransitionFactory</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	relativity := #nominal.	transitionSecondsSinceStartOfDay := 0</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self 		setTransitionSecondsSinceStartOfDay: (literalArray at: 6) asNumber		relativity: (literalArray at: 5)</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="setTransitionSecondsSinceStartOfDay:relativity:">setTransitionSecondsSinceStartOfDay: seconds relativity: aRelativitySymbol	self assertMutability.	transitionSecondsSinceStartOfDay := seconds.	relativity := aRelativitySymbol asSymbol.</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransitionFactory</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self relativity; 		nextPut: self transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransitionFactory</class-id> <category>queries</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDayOfWeekInYear:">transitionDayOfWeekInYear: year	^self subclassResponsibility</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursAfter:">transitionOccursAfter: aDateAndTimeSpec	^self subclassResponsibility</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnOrAfter:">transitionOccursOnOrAfter: aDateAndTimeSpec	^self subclassResponsibility</body></methods><methods><class-id>Chronos.IntraYearTimeZoneTransitionFactory</class-id> <category>printing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeOn:">encodeOn: stream	super encodeOn: stream.	stream		nextPut: $:;		nextPutAll: relativity;		nextPut: $:;		print: transitionSecondsSinceStartOfDay.</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="printTimeOfDayOn:">printTimeOfDayOn: stream	stream		nextPutAll: ' transitionSecondsSinceStartOfDay=';		print: transitionSecondsSinceStartOfDay;		nextPutAll: ' relativity=';		print: relativity</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut: self transitionDayOfYear</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>printing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeOn:">encodeOn: stream	super encodeOn: stream.	stream 		nextPut: $:;		print: transitionDayOfYear.</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="printOn:">printOn: stream	super printOn: stream.	stream		nextPutAll: ' transitionDayOfYear=';		print: transitionDayOfYear.	self printTimeOfDayOn: stream.</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="maxDaysFromStartOfYearUntilTransitionForYearOfType:">maxDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^transitionDayOfYear - 1</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="minDaysFromStartOfYearUntilTransitionForYearOfType:">minDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^transitionDayOfYear - 1</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="semanticKey">semanticKey		"Answer a value that identifies the conceptual type of the receiver."	^#UntilAnnualDayOfYearTimeZoneTransition</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDayOfYear">transitionDayOfYear	^transitionDayOfYear</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="typeKey">typeKey	^#'Until-Day-Of-Year-Transition'</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>queries</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year 	^self isSpecifiedAsLocalTime 		ifTrue: 			[DateAndTimeFactory 				year: year				day: transitionDayOfYear				seconds: transitionSecondsSinceStartOfDay				nanoseconds: 0				timeZone: self offsetFromUT asTimezone]		ifFalse: 			[self isSpecifiedAsStandardTime 				ifTrue: 					[DateAndTimeFactory 						year: year						day: transitionDayOfYear						seconds: transitionSecondsSinceStartOfDay						nanoseconds: 0						timeZone: self stdTimeOffsetFromUT asTimezone]				ifFalse: 					[DateAndTimeFactory 						utYear: year						day: transitionDayOfYear						seconds: transitionSecondsSinceStartOfDay						nanoseconds: 0						timeZone: self offsetFromUT asTimezone]]</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDayOfWeekInYear:">transitionDayOfWeekInYear: year	^(DateFactory year: year day: transitionDayOfYear) dayOfWeek</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursAfter:">transitionOccursAfter: aDateAndTimeSpec	| diff |	aDateAndTimeSpec == nil ifTrue: [^false].	diff := transitionDayOfYear - aDateAndTimeSpec dayOfYearOrdinal.	diff &gt; 0 ifTrue: [^true].	diff &lt; 0 ifTrue: [^false].	^transitionSecondsSinceStartOfDay &gt; aDateAndTimeSpec secondsSinceStartOfDay</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnFirstDayOfYear:">transitionOccursOnFirstDayOfYear: year	^transitionDayOfYear = 1</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnLastDayOfYear:">transitionOccursOnLastDayOfYear: year	^transitionDayOfYear = (Gregorian daysInYear: year)</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnOrAfter:">transitionOccursOnOrAfter: aDateAndTimeSpec	| diff |	aDateAndTimeSpec == nil ifTrue: [^false].	diff := transitionDayOfYear - aDateAndTimeSpec dayOfYearOrdinal.	diff &gt; 0 ifTrue: [^true].	diff &lt; 0 ifTrue: [^false].	^transitionSecondsSinceStartOfDay &gt;= aDateAndTimeSpec secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="specifiesSingleTransition">specifiesSingleTransition	^true</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self setTransitionDayOfYear: (literalArray at: 7) asNumber</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="setTransitionDayOfYear:">setTransitionDayOfYear: dayOfYearOrdinal	self assertMutability.	transitionDayOfYear := dayOfYearOrdinal.</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>converting</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="asPolicyFor:">asPolicyFor: anInterYearTimeZonePolicy 	^UntilAnnualDayOfYearTimeZoneTransition 		for: anInterYearTimeZonePolicy		offsetSeconds: offsetSecondsFromUT		stdTimeOffsetSeconds: stdTimeOffsetSecondsFromUT		commonAbbreviation: self commonAbbreviation		transitionDayOfYear: transitionDayOfYear		transitionSecondsSinceStartOfDay: transitionSecondsSinceStartOfDay		relativity: relativity</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory</class-id> <category>processing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	^aTimezoneProcessor processUntilAnnualDayOfYearTimeZoneTransition: self</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:transitionDayOfYear:transitionSecondsSinceStartOfDay:relativity:">offsetSeconds: secondsFromUTC stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol transitionDayOfYear: dayOfYearOrdinal transitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol 	^(self new)		setOffsetSeconds: secondsFromUTC  stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol;		setTransitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol;		setTransitionDayOfYear: dayOfYearOrdinal;		beImmutable</body></methods><methods><class-id>Chronos.UntilAnnualDayOfYearTimeZoneTransitionFactory class</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isConcrete">isConcrete	^true</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>API-Nouns</category><body package="Chronos-Localization" selector="pluralNounAtSemanticKey:">pluralNounAtSemanticKey: semanticKey	^self pluralNounAtSemanticKey: semanticKey ifAbsent: [self properNameAtSemanticKey: semanticKey]</body><body package="Chronos-Localization" selector="pluralNounAtSemanticKey:ifAbsent:">pluralNounAtSemanticKey: semanticKey ifAbsent: ifAbsent	^self class englishPluralNouns at: semanticKey ifAbsent: ifAbsent</body><body package="Chronos-Localization" selector="singularNounAtSemanticKey:">singularNounAtSemanticKey: semanticKey	^self singularNounAtSemanticKey: semanticKey ifAbsent: [self properNameAtSemanticKey: semanticKey]</body><body package="Chronos-Localization" selector="singularNounAtSemanticKey:ifAbsent:">singularNounAtSemanticKey: semanticKey ifAbsent: ifAbsent	^self class englishSingularNouns at: semanticKey ifAbsent: ifAbsent</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>API-Abbreviations</category><body package="Chronos-Localization" selector="abbreviationAtSemanticKey:">abbreviationAtSemanticKey: semanticKey 	^self 		abbreviationAtSemanticKey: semanticKey		ifAbsent: [self properNameAtSemanticKey: semanticKey]</body><body package="Chronos-Localization" selector="abbreviationAtSemanticKey:ifAbsent:">abbreviationAtSemanticKey: semanticKey ifAbsent: ifAbsent	^self class englishAbbreviations at: semanticKey ifAbsent: ifAbsent</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>API-Characters/Punctuation</category><body package="Chronos-Localization" selector="calendarDurationDayHourSeparator">calendarDurationDayHourSeparator	^self characterAtSemanticKey: #calendarDurationDayHourSeparator</body><body package="Chronos-Localization" selector="calendarDurationElementSeparator">calendarDurationElementSeparator	^self characterAtSemanticKey: #calendarDurationElementSeparator</body><body package="Chronos-Localization" selector="calendarDurationPadChar">calendarDurationPadChar	^self characterAtSemanticKey: #calendarDurationPad</body><body package="Chronos-Localization" selector="characterAtSemanticKey:">characterAtSemanticKey: semanticKey	^self characterAtSemanticKey: semanticKey ifAbsent: [self signalError: 'No character mapped to ', semanticKey printString]</body><body package="Chronos-Localization" selector="characterAtSemanticKey:ifAbsent:">characterAtSemanticKey: semanticKey ifAbsent: ifAbsent	^self class rootSemanticCharacters at: semanticKey ifAbsent: ifAbsent</body><body package="Chronos-Localization" selector="currencySymbol">currencySymbol	^self characterAtSemanticKey: #currencySymbol</body><body package="Chronos-Localization" selector="dateAndTimeSeparator">dateAndTimeSeparator	^self characterAtSemanticKey: #dateAndTimeSeparator</body><body package="Chronos-Localization" selector="dayOfMonthPadChar">dayOfMonthPadChar	^self characterAtSemanticKey: #dayOfMonthPad</body><body package="Chronos-Localization" selector="dayOfMonthYearSeparator">dayOfMonthYearSeparator	^self characterAtSemanticKey: #dayOfMonthYearSeparator</body><body package="Chronos-Localization" selector="decimalPointChar">decimalPointChar	^self characterAtSemanticKey: #decimalPoint</body><body package="Chronos-Localization" selector="durationDayHourSeparator">durationDayHourSeparator	^self characterAtSemanticKey: #durationDayHourSeparator</body><body package="Chronos-Localization" selector="durationElementSeparator">durationElementSeparator	^self characterAtSemanticKey: #durationElementSeparator</body><body package="Chronos-Localization" selector="durationPadChar">durationPadChar	^self characterAtSemanticKey: #durationPad</body><body package="Chronos-Localization" selector="hourMinuteSecondSeparator">hourMinuteSecondSeparator	^self characterAtSemanticKey: #hourMinuteSecondSeparator</body><body package="Chronos-Localization" selector="hourPadChar">hourPadChar	^self characterAtSemanticKey: #hourPad</body><body package="Chronos-Localization" selector="monthDayOfMonthSeparator">monthDayOfMonthSeparator	^self characterAtSemanticKey: #monthDayOfMonthSeparator</body><body package="Chronos-Localization" selector="monthPadChar">monthPadChar	^self characterAtSemanticKey: #monthPad</body><body package="Chronos-Localization" selector="thousandsSeparator">thousandsSeparator	^self characterAtSemanticKey: #thousandsSeparator</body><body package="Chronos-Localization" selector="timeOfDayPrefix">timeOfDayPrefix	^self characterAtSemanticKey: #timeOfDayPrefix ifAbsent: []</body><body package="Chronos-Localization" selector="timeZoneElementSeparator">timeZoneElementSeparator	^self characterAtSemanticKey: #timeZoneElementSeparator</body><body package="Chronos-Localization" selector="timeZoneSeparator">timeZoneSeparator	^self characterAtSemanticKey: #timeZoneSeparator</body><body package="Chronos-Localization" selector="yearMonthSeparator">yearMonthSeparator	^self characterAtSemanticKey: #yearMonthSeparator</body><body package="Chronos-Localization" selector="yearPadChar">yearPadChar	^self characterAtSemanticKey: #yearPad</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>API-Notational Policies</category><body package="Chronos-Localization" selector="calendarDurationElementNamePolicy">calendarDurationElementNamePolicy	^self notationalPolicyAt: #calendarDurationElementNamePolicy</body><body package="Chronos-Localization" selector="calendarDurationElementZeroValuePolicy">calendarDurationElementZeroValuePolicy	^self notationalPolicyAt: #calendarDurationElementZeroValuePolicy</body><body package="Chronos-Localization" selector="dateAndTimeOrder">dateAndTimeOrder	^self notationalPolicyAt: #dateAndTimeOrder ifAbsent: [#useDateBeforeTimeOrder]</body><body package="Chronos-Localization" selector="datePolicy">datePolicy	^self notationalPolicyAt: #datePolicy</body><body package="Chronos-Localization" selector="dayOfWeekPolicy">dayOfWeekPolicy	^self notationalPolicyAt: #dayOfWeekPolicy</body><body package="Chronos-Localization" selector="durationElementNamePolicy">durationElementNamePolicy	^self notationalPolicyAt: #durationElementNamePolicy</body><body package="Chronos-Localization" selector="durationElementZeroValuePolicy">durationElementZeroValuePolicy	^self notationalPolicyAt: #durationElementZeroValuePolicy</body><body package="Chronos-Localization" selector="eraPolicy">eraPolicy	^self notationalPolicyAt: #eraPolicy</body><body package="Chronos-Localization" selector="hourPolicy">hourPolicy	^self notationalPolicyAt: #hourPolicy</body><body package="Chronos-Localization" selector="monthPolicy">monthPolicy	^self notationalPolicyAt: #monthPolicy</body><body package="Chronos-Localization" selector="notationalPolicyAt:">notationalPolicyAt: policyKey	^self notationalPolicyAt: policyKey ifAbsent: [self signalError:  'No notational policy mapped to ', policyKey printString]</body><body package="Chronos-Localization" selector="notationalPolicyAt:ifAbsent:">notationalPolicyAt: policyKey ifAbsent: ifAbsent	^self class rootNotationalPolicies at: policyKey ifAbsent: ifAbsent</body><body package="Chronos-Localization" selector="timeOfDayPolicy">timeOfDayPolicy	^self notationalPolicyAt: #timeOfDayPolicy</body><body package="Chronos-Localization" selector="timeOfDaySubsecondPolicy">timeOfDaySubsecondPolicy	^self notationalPolicyAt: #timeOfDaySubsecondPolicy</body><body package="Chronos-Localization" selector="timeZonePolicy">timeZonePolicy	^self notationalPolicyAt: #timeZonePolicy</body><body package="Chronos-Localization" selector="yearPolicy">yearPolicy	^self notationalPolicyAt: #yearPolicy</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>testing</category><body package="Chronos-Localization" selector="isDefault">isDefault	^self == Default</body><body package="Chronos-Localization" selector="isRoot">isRoot	^registrationKey == #'root_ROOT'</body><body package="Chronos-Localization" selector="isSystem">isSystem	^self == System</body><body package="Chronos-Localization" selector="isUnitedStates">isUnitedStates	^self == US</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>private</category><body package="Chronos-Localization" selector="bindToTemporalPrintPolicy">bindToTemporalPrintPolicy	temporalPrintPolicy := self temporalPrintPolicy.	temporalPrintPolicy canConformToLocale 		ifTrue: 			[temporalPrintPolicy := temporalPrintPolicy asMutable.			temporalPrintPolicy confomToLocale: self].	temporalPrintPolicy beImmutable</body><body package="Chronos-Localization" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self languageCode;		nextPut: self countryCode	"For ChronosLocale itself (as opposed to any subclasses,) the &lt;timeZoneLocalizationPolicy&gt; &lt;temporalPrintPolicy&gt; are not stored because they should be rebound upon decoding based on the language and country codes."</body><body package="Chronos-Localization" selector="setKeyFromLanguageAndCountryCodes">setKeyFromLanguageAndCountryCodes	registrationKey := 		self class 			localeKeyFromLanguageCode: languageCode			countryCode: countryCode</body><body package="Chronos-Localization" selector="setLanguageAndCountryCodeFromKey">setLanguageAndCountryCodeFromKey	registrationKey == nil ifTrue: [^self].	self class		fromLocaleKey: registrationKey 		setLanuageCodeAndCountryCodeInto: 			[:lCode :cCode | 				languageCode := lCode.				countryCode := cCode]</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>accessing</category><body package="Chronos-Localization" selector="countryCode">countryCode	^countryCode</body><body package="Chronos-Localization" selector="languageCode">languageCode	^languageCode</body><body package="Chronos-Localization" selector="semanticDatePolicy">semanticDatePolicy	^SemanticDatePolicy 		at: self semanticDatePolicyKey		ifAbsent: [SemanticDatePolicy default]</body><body package="Chronos-Localization" selector="semanticDatePolicyKey">semanticDatePolicyKey	^self registrationKey</body><body package="Chronos-Localization" selector="standardCalendarRegistrationKey">standardCalendarRegistrationKey	^Calendar ansiStandard registrationKey</body><body package="Chronos-Localization" selector="temporalPrintPolicy">temporalPrintPolicy	^temporalPrintPolicy == nil 		ifTrue: 			[(self delegateIfNone: [^ChronosPrintPolicy newConfigurable]) 				temporalPrintPolicy]		ifFalse: [temporalPrintPolicy]</body><body package="Chronos-Localization" selector="timeZoneLocalizationPolicy">timeZoneLocalizationPolicy	^timeZoneLocalizationPolicy == nil 		ifTrue: 			[TimeZoneLocalizationPolicy 				at: self countryCode				ifAbsent: [TimeZoneLocalizationPolicy default]]		ifFalse: [timeZoneLocalizationPolicy]</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>initialize-release</category><body package="Chronos-Localization" selector="beDefault">beDefault	"(ChronosLocale at: #de_DE) beDefault"	"(ChronosLocale at: #en_AU) beDefault"	"(ChronosLocale at: #en_UK) beDefault"	"(ChronosLocale at: #en_US) beDefault"	"(ChronosLocale at: #es_ES) beDefault"	"(ChronosLocale at: #fr_CA) beDefault"	"(ChronosLocale at: #fr_FR) beDefault"	self == System 		ifTrue: [Default := nil]		ifFalse: [Default := self]</body><body package="Chronos-Localization" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	self canonicalizeIdentity.	self canonicalizeState.</body><body package="Chronos-Localization" selector="canonicalizeIdentity">canonicalizeIdentity	registrationKey == nil ifTrue: [self setKeyFromLanguageAndCountryCodes].	(languageCode == nil or: [countryCode == nil]) 		ifTrue: [self setLanguageAndCountryCodeFromKey].</body><body package="Chronos-Localization" selector="canonicalizeState">canonicalizeState	self bindToTemporalPrintPolicy.</body><body package="Chronos-Localization" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self setLanguageCode: (literalArray at: 3) countryCode: (literalArray at: 4).	"For ChronosLocale itself (as opposed to any subclasses,) the &lt;timeZoneLocalizationPolicy&gt; &lt;temporalPrintPolicy&gt; are not stored because they should be rebound upon decoding based on the language and country codes."</body><body package="Chronos-Localization" selector="setLanguageCode:countryCode:">setLanguageCode: langCode countryCode: country	self assertMutability.	languageCode := langCode == nil ifFalse: [langCode asSymbol].	countryCode := country == nil ifFalse: [country asSymbol].</body></methods><methods><class-id>Chronos.ChronosLocale</class-id> <category>API-Proper Names</category><body package="Chronos-Localization" selector="properNameAtSemanticKey:">properNameAtSemanticKey: semanticKey	^self properNameAtSemanticKey: semanticKey ifAbsent: [semanticKey]</body><body package="Chronos-Localization" selector="properNameAtSemanticKey:ifAbsent:">properNameAtSemanticKey: semanticKey ifAbsent: ifAbsent	^self class englishProperNames at: semanticKey ifAbsent: ifAbsent</body></methods><methods><class-id>Chronos.ChronosLocale class</class-id> <category>private</category><body package="Chronos-Localization" selector="englishAbbreviations">englishAbbreviations	EnglishAbbreviationsBySemanticKey == nil ifTrue: [self initializeEnglishAbbreviationsBySemanticKey].	^EnglishAbbreviationsBySemanticKey</body><body package="Chronos-Localization" selector="englishNotationalPolicies">englishNotationalPolicies	EnglishNotationalPolicies == nil ifTrue: [self initializeEnglishNotationalPolicies].	^EnglishNotationalPolicies</body><body package="Chronos-Localization" selector="englishPluralNouns">englishPluralNouns	EnglishPluralNounsBySemanticKey == nil ifTrue: [self initializeEnglishPluralNounsBySemanticKey].	^EnglishPluralNounsBySemanticKey</body><body package="Chronos-Localization" selector="englishProperNames">englishProperNames	EnglishProperNamesBySemanticKey == nil ifTrue: [self initializeEnglishProperNamesBySemanticKey].	^EnglishProperNamesBySemanticKey</body><body package="Chronos-Localization" selector="englishSemanticCharacters">englishSemanticCharacters	EnglishSemanticCharacters == nil ifTrue: [self initializeEnglishSemanticCharacters].	^EnglishSemanticCharacters</body><body package="Chronos-Localization" selector="englishSingularNouns">englishSingularNouns	EnglishSingularNounsBySemanticKey == nil ifTrue: [self initializeEnglishSingularNounsBySemanticKey].	^EnglishSingularNounsBySemanticKey</body><body package="Chronos-Localization" selector="findOrCreateLocaleAt:">findOrCreateLocaleAt: localeKey	localeKey == #'root_ROOT' ifTrue: [^ChronosLocale root].	localeKey == #C ifTrue: [^ChronosLocale english].	localeKey == #en ifTrue: [^ChronosLocale english].	localeKey == #'en_US' ifTrue: [^ChronosLocale unitedStates].	^(ChronosSystemFacade current findOrCreateChronosLocaleAt: localeKey) forceRegistration</body><body package="Chronos-Localization" selector="newEnglishLocale">newEnglishLocale	^ConfigurableChronosLocale new		setDelegate: self root;		setKey: #en;		setStandardCalendarRegistrationKey: GregorianCalendar registrationKey;		setCharacters: self englishSemanticCharacters;		setNotationalPolicies: self englishNotationalPolicies;		setProperNames: self englishProperNames;		setAbbreviations: self englishAbbreviations;		setSingularNouns: self englishSingularNouns pluralNouns: self englishPluralNouns</body><body package="Chronos-Localization" selector="newRootLocale">newRootLocale	^ConfigurableChronosLocale new		setKey: #'root_ROOT';		setStandardCalendarRegistrationKey: GregorianCalendar registrationKey;		setCharacters: self rootSemanticCharacters;		setNotationalPolicies: self rootNotationalPolicies;		setProperNames: self englishProperNames;		setAbbreviations: self englishAbbreviations;		setSingularNouns: self englishSingularNouns pluralNouns: self englishPluralNouns</body><body package="Chronos-Localization" selector="newUSLocale">newUSLocale	^ConfigurableChronosLocale new		setDelegate: self english;		setKey: #'en_US';		setStandardCalendarRegistrationKey: GregorianCalendar registrationKey;		setCharacters: self usEnglishSemanticCharacters;		setNotationalPolicies: self usEnglishNotationalPolicies;		setProperNames: self englishProperNames;		setAbbreviations: self englishAbbreviations;		setSingularNouns: self englishSingularNouns pluralNouns: self englishPluralNouns</body><body package="Chronos-Localization" selector="rootNotationalPolicies">rootNotationalPolicies	RootNotationalPolicies == nil ifTrue: [self initializeRootNotationalPolicies].	^RootNotationalPolicies</body><body package="Chronos-Localization" selector="rootSemanticCharacters">rootSemanticCharacters	RootSemanticCharacters == nil ifTrue: [self initializeRootSemanticCharacters].	^RootSemanticCharacters</body><body package="Chronos-Localization" selector="usEnglishNotationalPolicies">usEnglishNotationalPolicies	USEnglishNotationalPolicies == nil ifTrue: [self initializeUSEnglishNotationalPolicies].	^USEnglishNotationalPolicies</body><body package="Chronos-Localization" selector="usEnglishSemanticCharacters">usEnglishSemanticCharacters	USEnglishSemanticCharacters == nil ifTrue: [self initializeUSEnglishSemanticCharacters].	^USEnglishSemanticCharacters</body></methods><methods><class-id>Chronos.ChronosLocale class</class-id> <category>accessing</category><body package="Chronos-Localization" selector="default">default	"ChronosLocale default"	Default == nil ifTrue: [^self system].	^Default</body><body package="Chronos-Localization" selector="english">english	"ChronosLocale english"	English == nil 		ifTrue: 			[English := self at: #en ifAbsent: [self newEnglishLocale forceRegistration]].	^English</body><body package="Chronos-Localization" selector="handleUnregistered:">handleUnregistered: localeKey	^self findOrCreateLocaleAt: localeKey</body><body package="Chronos-Localization" selector="root">root	"ChronosLocale root"	Root == nil 		ifTrue: [Root := self at: #'root_ROOT' ifAbsent: [self newRootLocale forceRegistration]].	^Root</body><body package="Chronos-Localization" selector="system">system	"ChronosLocale system"	System == nil ifTrue: [self invalidateSystemLocale].	^System</body><body package="Chronos-Localization" selector="unitedStates">unitedStates	"ChronosLocale unitedStates"	US == nil 		ifTrue: [US := self at: #'en_US' ifAbsent: [self newUSLocale forceRegistration]].	^US</body></methods><methods><class-id>Chronos.ChronosLocale class</class-id> <category>class initialization</category><body package="Chronos-Localization" selector="initialize">initialize	"ChronosLocale initialize" 	self basicInitializeAll.		Root := nil.	English := nil.	US := nil.	System := nil.	Default := nil.</body><body package="Chronos-Localization" selector="initializeDefaultLocaleInformation">initializeDefaultLocaleInformation	"ChronosLocale initializeDefaultLocaleInformation"	self initializeRootSemanticCharacters.	self initializeRootNotationalPolicies.	self initializeEnglishSemanticCharacters.	self initializeEnglishNotationalPolicies.	self initializeEnglishProperNamesBySemanticKey.	self initializeEnglishAbbreviationsBySemanticKey.	self initializeEnglishSingularNounsBySemanticKey.	self initializeEnglishPluralNounsBySemanticKey.	self initializeUSEnglishSemanticCharacters.	self initializeUSEnglishNotationalPolicies.</body><body package="Chronos-Localization" selector="initializeEnglishAbbreviationsBySemanticKey">initializeEnglishAbbreviationsBySemanticKey	"ChronosLocale initializeEnglishAbbreviationsBySemanticKey"	EnglishAbbreviationsBySemanticKey := Dictionary new.	EnglishAbbreviationsBySemanticKey		at: #January put: #Jan;		at: #February put: #Feb;		at: #March put: #Mar;		at: #April put: #Apr;		at: #May put: #May;		at: #June put: #Jun;		at: #July put: #Jul;		at: #August put: #Aug;		at: #September put: #Sep;		at: #October put: #Oct;		at: #November put: #Nov;		at: #December put: #Dec;		at: #Monday put: #Mon;		at: #Tuesday put: #Tue;		at: #Wednesday put: #Wed;		at: #Thursday put: #Thu;		at: #Friday put: #Fri;		at: #Saturday put: #Sat;		at: #Sunday put: #Sun;		at: #'ante-meridian' put: #am;		at: #'post-meridian' put: #pm.</body><body package="Chronos-Localization" selector="initializeEnglishNotationalPolicies">initializeEnglishNotationalPolicies	"ChronosLocale initializeEnglishNotationalPolicies"	"Policy key								Valid policy values (one from the set)	#dateAndTimeOrder					-- #(#useDateBeforeTimeOrder #useTimeBeforeDateOrder)	#datePolicy								-- #(#useYearMonthDayOrder #useYearDayMonthOrder #useMonthDayYearOrder #useDayMonthYearOrder #useOrdinalDate												#useISOWeekOfYearDayOfWeek #showDateAsJulianDay #showDateAsGregorianDay #showDateAsDaysSinceEpoch)	#monthPolicy							-- #(#useNumericMonthDesignator #useMonthOrdinal #useMonthName #useMonthAbbreviation)	#yearPolicy								-- #(#useFullDigitYears #useTwoDigitYears #hideYears)	#dayOfWeekPolicy						-- #(#hideDayOfWeek #showDayOfWeekName #showDayOfWeekAbbreviation)	#eraPolicy								-- #(#hideEraName #showEraName)	#timeOfDayPolicy						-- #(#hideTimeOfDay #showTimeOfDay)	#hourPolicy								-- #(#use12HourFormat #user24Hour4Format)	#timeOfDaySubsecondPolicy			-- #(#hideSubsecondFraction #showSubsecondFraction)	#timeZonePolicy						-- #(#hideTimeZone #showTimeZoneAbbreviation #showTimeZoneName #showTimeZoneOffset #showTimeZoneVerbosely)	#durationElementNamePolicy			-- #(#hideNamesOfDurationElements #showNamesOfDurationElements)	#calendarDurationElementNamePolicy	-- #(#hideNamesOfCalendarDurationElements #showNamesOfCalendarDurationElements)	#durationElementZeroValuePolicy		-- #(#hideZeroValuedDurationElements #showZeroValuedDurationElements)	#durationElementZeroValuePolicy		-- #(#hideZeroValuedCalendarDurationElements #showZeroValuedCalendarDurationElements)"	EnglishNotationalPolicies := Dictionary new.	EnglishNotationalPolicies		at: #dateAndTimeOrder put: #useDateBeforeTimeOrder;		at: #datePolicy put: #useDayMonthYearOrder;		at: #monthPolicy put: #useMonthName;				at: #yearPolicy put: #useFullDigitYears;		at: #dayOfWeekPolicy put: #hideDayOfWeek;		at: #eraPolicy put: #hideEraName;		at: #timeOfDayPolicy put: #showTimeOfDay;		at: #hourPolicy put: #use12HourFormat;		at: #timeOfDaySubsecondPolicy put: #hideSubsecondFraction;		at: #timeZonePolicy put: #showTimeZoneAbbreviation;		at: #durationElementNamePolicy put: #showNamesOfDurationElements;				at: #calendarDurationElementNamePolicy put: #showNamesOfCalendarDurationElements;				at: #durationElementZeroValuePolicy put: #hideZeroValuedDurationElements;		at: #calendarDurationElementZeroValuePolicy put: #hideZeroValuedCalendarDurationElements</body><body package="Chronos-Localization" selector="initializeEnglishPluralNounsBySemanticKey">initializeEnglishPluralNounsBySemanticKey	"ChronosLocale initializeEnglishPluralNounsBySemanticKey"	EnglishPluralNounsBySemanticKey := Dictionary new.	EnglishPluralNounsBySemanticKey 		at: #year put: #'years';		at: #month put: #'months';		at: #week put: #'weeks';		at: #weekOfYear put: #'weeks of year';		at: #weekOfMonth put: #'weeks of month';		at: #day put: #'days';		at: #dayOfYear put: #'days of year';		at: #dayOfMonth put: #'days of month';		at: #dayOfWeek put: #'days of week';		at: #hour put: #'hours';		at: #minute put: #'minutes';		at: #second put: #'seconds';		at: #millisecond put: #'milliseconds';		at: #microsecond put: #'microseconds';		at: #nanosecond put: '#nanoseconds';		at: #tick put: #'ticks'. "clock ticks"</body><body package="Chronos-Localization" selector="initializeEnglishProperNamesBySemanticKey">initializeEnglishProperNamesBySemanticKey	"ChronosLocale initializeEnglishProperNamesBySemanticKey"	EnglishProperNamesBySemanticKey := Dictionary new.	EnglishProperNamesBySemanticKey		at: #system put: 'System';		at: #default put: 'Default';		at: #Universal put: 'Universal Time';		at: #nominal put: 'Nominal Time';		at: #alwaysSystem put: 'Dynamic Local Time (System)';		at: #alwaysDefault put: 'Dynamic Local Time (User)';		at: #January put: #January;		at: #February put: #February;		at: #March put: #March;		at: #April put: #April;		at: #May put: #May;		at: #June put: #June;		at: #July put: #July;		at: #August put: #August;		at: #September put: #September;		at: #October put: #October;		at: #November put: #November;		at: #December put: #December;		at: #Month1 put: #'FirstMonth';		at: #Month2 put: #'SecondMonth';		at: #Month3 put: #'ThirdMonth';		at: #Month4 put: #'FourthMonth';		at: #Month5 put: #'FifthMonth';		at: #Month6 put: #'SixthMonth';		at: #Month7 put: #'SeventhMonth';		at: #Month8 put: #'EighthMonth';		at: #Month9 put: #'NinthMonth';		at: #Month10 put: #'TenthMonth';		at: #Month11 put: #'EleventhMonth';		at: #Month12 put: #'TwelfthMonth';		at: #Monday put: #Monday;		at: #Tuesday put: #Tuesday;		at: #Wednesday put: #Wednesday;		at: #Thursday put: #Thursday;		at: #Friday put: #Friday;		at: #Saturday put: #Saturday;		at: #Sunday put: #Sunday;		at: #'ante-meridian' put: #am;		at: #'post-meridian' put: #pm;		at: #Bahai put: #Bahai;		at: #'Bahai-era-postEpoch' put: #BE; "Bahai Era"		at: #'Bahai-era-preEpoch' put: #BE;		at: #Chinese put: #Chinese;		at: #'Chinese-era-postEpoch' put: #AS; "Anno Sinae (Year of the Chinese)"		at: #'Chinese-era-preEpoch' put: #AS;		at: #Coptic put: #Coptic;		at: #'Coptic-era-postEpoch' put: #AM;	"Anno Martyrum (Year of the Martyrs)"		at: #'Coptic-era-preEpoch' put: #AM;		at: #Ethiopic put: #Ethiopic;		at: #'Ethiopic-era-postEpoch' put: #ZH; "Zemene Haddis" "Alternatively: 'Amete Mihret'--not used here to avoid confusion with both the Coptic and Hebrew era abbreviations"		at: #'Ethiopic-era-preEpoch' put: #ZB; "Zemene Bluy"		at: #Greogian put: #Greogian;		at: #Hebrew put: #Hebrew;		at: #'Hebrew-era-postEpoch' put: #AM;	"Anno Mundi (Year of the World)"		at: #'Hebrew-era-preEpoch' put: #AM;		at: #'ImperialJulian-era-postEpoch' put: #AUC;	"Ab Urbe Condita (From the Founding of the City)"		at: #'ImperialJulian-era-preEpoch' put: #AUC;		at: #Indian put: #'Indian Civil';		at: #'Indian-era-postEpoch' put: #AS;	"Anno Sakidae (Saka Era)"		at: #'Indian-era-preEpoch' put: #AS;		at: #'Islamic-Fatimid' put: #'Islamic (Fatimid)';		at: #'Islamic-Fatimid-era-postEpoch' put: #AH;	"Anno Hegirae (Year of the Hijra)"		at: #'Islamic-Fatimid-era-preEpoch' put: #AH;		at: #Julian put: #Julian;		at: #'Julian-Imperial' put: #'Julian (Imperial)';		at: #Persian put: #Persian;		at: #'Persian-era-postEpoch' put: #AP;	"Anno Persico (Persian Year)"		at: #'Persian-era-preEpoch' put: #AP;		at: #Solarian put: #Solarian;		at: #'Solarian-era-postEpoch' put: #SY;	"Solarian Year"		at: #'Solarian-era-preEpoch' put: #SY;		at: #'Christian-era-postEpoch' put: #AD;	"Anno Domini (Year of the Lord)"		at: #'Christian-era-preEpoch' put: #BC	"Before Christ (not in Latin, because the term was coined in English by the Venerable Bede)"	"Note on the Era Names used for the Julian and Gregorian Calendars:	For the Gregorian and Julian calendars, we use the formally and historically correct 'AD' and 'BC' era designators, instead of the revisionist 'CE' and 'BCE' designators.  	The reasons for this choice:		1) The majority of the general world population continues to prefer the usage of 'AD'/'BC'--and many are not even familiar with the 'CE'/'BCE' designations.		2) The specification of the Gregorian calendar rightfully resides with its inventor: The Roman Catholic Church.  No changes to the specification of the Gregorian calendar have been authorized by the Pope since the introduction of the calendar.  Therefore, 'AD' and 'BC' are still formally correct--and 'CE'/'BCE' are not.		3) The principle of reciprocity requires that each culture respect the standard conventions and usages of all other cultures, provided this does not involve the violation of rights.  Since Jews (for example) have no right to not be offended by whatever name Christians choose to use for the eras of their calendar (just as Christians, Hindus, Muslims and atheists have no right to not be offended by the implications of the phrase 'anno mundi,') Christians have the right to name the eras of their calendar whatever they wish, and other cultures are required by the principle of reciprocity to respect it.  Just because the names of certain cities in Thailand can be easily taken as vulgar words/phrases in English does not give English speakers the right to dictate to Thais what they call their cities.  By the same principle, no one has the right to dictate to Christians what they call their calendar eras--and any attempt to do so is both ill-mannered and offensive.		It must also be mentioned that the stated reason by Jews for their unwillingness to use the designation 'anno domini'--namely, that they do not believe that Jesus is their 'lord'--is inconsistent and hypocritical.  No one disputes their disbelief, nor their right to disbelieve (certainly not I--I'm an atheist.)  However, Jews also do not believe that Yahshuah is 'ha Mashiahh' (that is, that Jesus is 'the Christ', both 'Mashiahh' and 'Christ' mean 'Annointed One,' a term with special significance in both the Hebrew and Christian scriptures.)  Consequently, to be logically consistent, Jews should also be unwilling to use the label 'Christian' in reference to the (self-proclaimed) disciples of Jesus, or to use the term 'Christ' to refer to the central figure of the Christian religion, since they emphatically do not believe this person to have been the Annointed One, nor that those called Christians are in fact the disciples of 'the real' Annointed One (who is yet to come, according to Jewish belief.)  Therefore, failure by Jews to avoid all reference to the term 'Christ,'   in all its forms (including 'Christian Era,') is thus blatantly and inarguably hypocritical, and renders their objections to 'anno domini' doubly offensive.		Of course, Christians also have no right to force others to use their calendar (or to follow their naming conventions.)  Consequently, each individual is free to use whatever calendar and/or era names he/she thinks best. Nevertheless, as a general purpose tool, Chronos best serves all users by following common/standard usage."</body><body package="Chronos-Localization" selector="initializeEnglishSemanticCharacters">initializeEnglishSemanticCharacters	"ChronosLocale initializeEnglishSemanticCharacters"	EnglishSemanticCharacters := Dictionary new.	EnglishSemanticCharacters		at: #decimalPoint put: $.;		at: #thousandsSeparator put: $,;		at: #yearMonthSeparator put: $ ; "covers either year/month or month/year"		at: #monthDayOfMonthSeparator put: $ ; "covers either month/dayOfMonth or dayOfMonth/month"		at: #dayOfMonthYearSeparator put: $ ; "covers either dayOfMonth/year or year/dayOfMonth"		at: #yearPad put: nil; "pad character for year--nil means don't pad"		at: #monthPad put: nil; "pad character for month--nil means don't pad"		at: #dayOfMonthPad put: nil; "pad character for dayOfMonth--nil means don't pad" 		"Note: dayOfYear is always zero-padded; DaysSinceEpoch and Julian Day Numbers are never padded."		at: #dateAndTimeSeparator put: '  ';		at: #timeOfDayPrefix put: nil; "A prefix to be always prepended in front of a time-of-day. Nil means no prefix at all."		at: #hourMinuteSecondSeparator put: $:;		at: #timeZoneSeparator put: $ ;		at: #timeZoneElementSeparator put: nil;		at: #hourPad put: nil; "pad character for hour (nil means don't pad)--minute and second fields always zero-padded"		at: #durationElementSeparator put: $ ;		at: #calendarDurationElementSeparator put: $ ;		at: #durationPad put: nil; "pad character for all scientific (ANSI) durations (nil means don't pad)"		at: #calendarDurationPad put: nil; "pad character for calendar (ISO) durations (nil means don't pad)"		at: #durationDayHourSeparator put: $ ;		at: #calendarDurationDayHourSeparator put: $ .				"Note: Any separator 'character' may be a String instead."</body><body package="Chronos-Localization" selector="initializeEnglishSingularNounsBySemanticKey">initializeEnglishSingularNounsBySemanticKey	"ChronosLocale initializeEnglishSingularNounsBySemanticKey"	EnglishSingularNounsBySemanticKey := Dictionary new.	EnglishSingularNounsBySemanticKey 		at: #year put: #year;		at: #month put: #month;		at: #week put: #week;		at: #weekOfYear put: #'week of year';		at: #weekOfMonth put: #'week of month';		at: #day put: #day;		at: #dayOfYear put: #'day of year';		at: #dayOfMonth put: #'day of month';		at: #dayOfWeek put: #'day of week';		at: #hour put: #'hour';		at: #minute put: #'minute';		at: #second put: #'second';		at: #millisecond put: #'millisecond';		at: #microsecond put: #'microsecond';		at: #nanosecond put: #'nanosecond';		at: #tick put: #'tick'."clock tick"</body><body package="Chronos-Localization" selector="initializeRootNotationalPolicies">initializeRootNotationalPolicies	"Set values that best reflect international standards/conventions, and avoid names in any particular language."	"{ChronosLocale initializeRootNotationalPolicies}"	"Policy key								Valid policy values (one from the set)	#dateAndTimeOrder					-- #(#useDateBeforeTimeOrder #useTimeBeforeDateOrder)	#datePolicy								-- #(#useYearMonthDayOrder #useYearDayMonthOrder #useMonthDayYearOrder #useDayMonthYearOrder #useOrdinalDate												#useISOWeekOfYearDayOfWeek #showDateAsJulianDay #showDateAsGregorianDay #showDateAsDaysSinceEpoch)	#monthPolicy							-- #(#useNumericMonthDesignator #useMonthOrdinal #useMonthName #useMonthAbbreviation)	#yearPolicy								-- #(#useFullDigitYears #useTwoDigitYears #hideYears)	#dayOfWeekPolicy						-- #(#hideDayOfWeek #showDayOfWeekName #showDayOfWeekAbbreviation)	#eraPolicy								-- #(#hideEraName #showEraName)	#timeOfDayPolicy						-- #(#hideTimeOfDay #showTimeOfDay)	#hourPolicy								-- #(#use12HourFormat #user24Hour4Format)	#timeOfDaySubsecondPolicy			-- #(#hideSubsecondFraction #showSubsecondFraction)	#timeZonePolicy						-- #(#hideTimeZone #showTimeZoneAbbreviation #showTimeZoneName #showTimeZoneOffset #showTimeZoneVerbosely)	#durationElementNamePolicy			-- #(#hideNamesOfDurationElements #showNamesOfDurationElements)	#calendarDurationElementNamePolicy	-- #(#hideNamesOfCalendarDurationElements #showNamesOfCalendarDurationElements)	#durationElementZeroValuePolicy		-- #(#hideZeroValuedDurationElements #showZeroValuedDurationElements)	#durationElementZeroValuePolicy		-- #(#hideZeroValuedCalendarDurationElements #showZeroValuedCalendarDurationElements)"	RootNotationalPolicies := Dictionary new.	RootNotationalPolicies		at: #dateAndTimeOrder put: #useDateBeforeTimeOrder;		at: #datePolicy put: #useYearMonthDayOrder;		at: #monthPolicy put: #useNumericMonthDesignator;				at: #yearPolicy put: #useFullDigitYears;		at: #dayOfWeekPolicy put: #hideDayOfWeek;		at: #eraPolicy put: #hideEraName;		at: #timeOfDayPolicy put: #showTimeOfDay;		at: #hourPolicy put: #use12HourFormat;		at: #timeOfDaySubsecondPolicy put: #hideSubsecondFraction;		at: #timeZonePolicy put: #showTimeZoneAbbreviation;		at: #durationElementNamePolicy put: #hideNamesOfDurationElements;				at: #calendarDurationElementNamePolicy put: #hideNamesOfCalendarDurationElements;				at: #durationElementZeroValuePolicy put: #showZeroValuedDurationElements;		at: #calendarDurationElementZeroValuePolicy put: #hideZeroValuedCalendarDurationElements</body><body package="Chronos-Localization" selector="initializeRootSemanticCharacters">initializeRootSemanticCharacters	"Set values that best reflect international standards and conventions."	"{ChronosLocale initializeRootSemanticCharacters}"	RootSemanticCharacters := Dictionary new.	RootSemanticCharacters		at: #currencySymbol put: (EnvironmentFacade current euroCurrencyCharIfNone: [$$]);		at: #decimalPoint put: $,;		at: #thousandsSeparator put: $.;		at: #yearMonthSeparator put: $-; "covers either year/month or month/year"		at: #monthDayOfMonthSeparator put: $-; "covers either month/dayOfMonth or dayOfMonth/month"		at: #dayOfMonthYearSeparator put: $-; "covers either dayOfMonth/year or year/dayOfMonth"		at: #yearPad put: $0; "pad character for year--nil means don't pad"		at: #monthPad put: $0; "pad character for month--nil means don't pad"		at: #dayOfMonthPad put: $0; "pad character for dayOfMonth--nil means don't pad" 		"Note: dayOfYear is always zero-padded; DaysSinceEpoch and Julian Day Numbers are never padded."		at: #dateAndTimeSeparator put: '  '; "Two spaces"		at: #timeOfDayPrefix put: nil; "A prefix to be always prepended in front of a time-of-day. Nil means no prefix at all."		at: #hourMinuteSecondSeparator put: $:;		at: #hourPad put: $0; "pad character for hour (nil means don't pad)--minute and second fields always zero-padded"		at: #timeZoneSeparator put: $ ;		at: #timeZoneElementSeparator put: nil;		at: #durationElementSeparator put: $:;		at: #calendarDurationElementSeparator put: nil;		at: #durationPad put: $0; "pad character for all scientific (ANSI) durations (nil means don't pad)"		at: #calendarDurationPad put: nil; "pad character for calendar (ISO) durations (nil means don't pad)"		at: #durationDayHourSeparator put: $T;		at: #calendarDurationDayHourSeparator put: $T.				"Note: Any separator 'character' may be a String instead."</body><body package="Chronos-Localization" selector="initializeUSEnglishNotationalPolicies">initializeUSEnglishNotationalPolicies	"ChronosLocale initializeUSEnglishNotationalPolicies"	"Policy key								Valid policy values (one from the set)	#dateAndTimeOrder					-- #(#useDateBeforeTimeOrder #useTimeBeforeDateOrder)	#datePolicy								-- #(#useYearMonthDayOrder #useYearDayMonthOrder #useMonthDayYearOrder #useDayMonthYearOrder #useOrdinalDate												#useISOWeekOfYearDayOfWeek #showDateAsJulianDay #showDateAsGregorianDay #showDateAsDaysSinceEpoch)	#monthPolicy							-- #(#useNumericMonthDesignator #useMonthOrdinal #useMonthName #useMonthAbbreviation)	#yearPolicy								-- #(#useFullDigitYears #useTwoDigitYears #hideYears)	#dayOfWeekPolicy						-- #(#hideDayOfWeek #showDayOfWeekName #showDayOfWeekAbbreviation)	#eraPolicy								-- #(#hideEraName #showEraName)	#timeOfDayPolicy						-- #(#hideTimeOfDay #showTimeOfDay)	#hourPolicy								-- #(#use12HourFormat #user24Hour4Format)	#timeOfDaySubsecondPolicy			-- #(#hideSubsecondFraction #showSubsecondFraction)	#timeZonePolicy						-- #(#hideTimeZone #showTimeZoneAbbreviation #showTimeZoneName #showTimeZoneOffset #showTimeZoneVerbosely)	#durationElementNamePolicy			-- #(#hideNamesOfDurationElements #showNamesOfDurationElements)	#calendarDurationElementNamePolicy	-- #(#hideNamesOfCalendarDurationElements #showNamesOfCalendarDurationElements)	#durationElementZeroValuePolicy		-- #(#hideZeroValuedDurationElements #showZeroValuedDurationElements)	#durationElementZeroValuePolicy		-- #(#hideZeroValuedCalendarDurationElements #showZeroValuedCalendarDurationElements)"	USEnglishNotationalPolicies := Dictionary new.	USEnglishNotationalPolicies		at: #dateAndTimeOrder put: #useDateBeforeTimeOrder;		at: #datePolicy put: #useMonthDayYearOrder;		at: #monthPolicy put: #useMonthName;				at: #yearPolicy put: #useFullDigitYears;		at: #dayOfWeekPolicy put: #hideDayOfWeek;		at: #eraPolicy put: #hideEraName;		at: #timeOfDayPolicy put: #showTimeOfDay;		at: #hourPolicy put: #use12HourFormat;		at: #timeOfDaySubsecondPolicy put: #hideSubsecondFraction;		at: #timeZonePolicy put: #showTimeZoneAbbreviation;		at: #durationElementNamePolicy put: #showNamesOfDurationElements;				at: #calendarDurationElementNamePolicy put: #showNamesOfCalendarDurationElements;				at: #durationElementZeroValuePolicy put: #hideZeroValuedDurationElements;		at: #calendarDurationElementZeroValuePolicy put: #hideZeroValuedCalendarDurationElements</body><body package="Chronos-Localization" selector="initializeUSEnglishSemanticCharacters">initializeUSEnglishSemanticCharacters	"ChronosLocale initializeUSEnglishSemanticCharacters"	USEnglishSemanticCharacters := Dictionary new.	USEnglishSemanticCharacters		at: #decimalPoint put: $.;		at: #thousandsSeparator put: $,;		at: #currencySymbol put: $$;		at: #yearMonthSeparator put: $/; "covers either year/month or month/year"		at: #monthDayOfMonthSeparator put: $ ; "covers either month/dayOfMonth or dayOfMonth/month"		at: #dayOfMonthYearSeparator put: ', '; "covers either dayOfMonth/year or year/dayOfMonth"		at: #yearPad put: nil; "pad character for year--nil means don't pad"		at: #monthPad put: nil; "pad character for month--nil means don't pad"		at: #dayOfMonthPad put: nil; "pad character for dayOfMonth--nil means don't pad" 		"Note: dayOfYear is always zero-padded; DaysSinceEpoch and Julian Day Numbers are never padded."		at: #dateAndTimeSeparator put: '  ';		at: #timeOfDayPrefix put: nil; "A prefix to be always prepended in front of a time-of-day. Nil means no prefix at all."		at: #hourMinuteSecondSeparator put: $:;		at: #hourPad put: nil; "pad character for hour (nil means don't pad)--minute and second fields always zero-padded"		at: #timeZoneSeparator put: $ ;		at: #timeZoneElementSeparator put: nil;		at: #durationElementSeparator put: $ ;		at: #calendarDurationElementSeparator put: $ ;		at: #durationPad put: nil; "pad character for all scientific (ANSI) durations (nil means don't pad)"		at: #calendarDurationPad put: nil; "pad character for calendar (ISO) durations (nil means don't pad)"		at: #durationDayHourSeparator put: $ ;		at: #calendarDurationDayHourSeparator put: $ .				"Note: Any separator 'character' may be a String instead."</body><body package="Chronos-Localization" selector="invalidateSystemLocale">invalidateSystemLocale	"ChronosLocale invalidateSystemLocale"	System := self findOrCreateLocaleAt: ChronosSystemFacade current systemLocaleKey.</body></methods><methods><class-id>Chronos.ChronosLocale class</class-id> <category>utility</category><body package="Chronos-Localization" selector="fromLocaleKey:setLanuageCodeAndCountryCodeInto:">fromLocaleKey: chronosLocaleKey setLanuageCodeAndCountryCodeInto: block2	| key underscoreIndex languageCode countryCode countryCodeTerminatorIndex |	key := chronosLocaleKey asString.	underscoreIndex := key indexOf: $_.	underscoreIndex = 0 		ifTrue: [^block2 value: key asSymbol value: nil]		ifFalse: [languageCode := (key copyFrom: 1 to: underscoreIndex - 1) asSymbol].	countryCodeTerminatorIndex := underscoreIndex + 1.	[countryCodeTerminatorIndex &lt;= key size and: [(key at: countryCodeTerminatorIndex) isLetter]] 		whileTrue: [countryCodeTerminatorIndex := countryCodeTerminatorIndex + 1].	countryCode := (key copyFrom: underscoreIndex + 1 to: countryCodeTerminatorIndex - 1) asSymbol.	^block2		value: languageCode		value: countryCode</body><body package="Chronos-Localization" selector="localeKeyFromLanguageCode:countryCode:">localeKeyFromLanguageCode: language countryCode: countryCode 	| stream languageCode |	languageCode := language == nil ifTrue: [^#root] ifFalse: [language].	stream := (String new: 15) writeStream.	stream nextPutAll: languageCode.	countryCode == nil 		ifFalse: 			[stream				nextPut: $_;				nextPutAll: countryCode].	^stream contents asSymbol</body></methods><methods><class-id>Chronos.DynamicCalendarDay</class-id> <category>arithmetic</category><body package="Chronos-Calendars-Irregular" selector="addingDays:">addingDays: count	"Answer the CalendarDay in the receiver's year type whose day-of-year ordinal is computed by adding &lt;count&gt; to the receiver's day-of-year ordinal. If the resulting day-of-year ordinal is not valid, answer nil."	^count &gt; 0		ifTrue: [containingPeriod nextDayInYearAfter: self count: count - 1]				ifFalse: 			[count &lt; 0				ifTrue: [self subtractingDays: count negated]				ifFalse: [self]]</body><body package="Chronos-Calendars-Irregular" selector="subtractingDays:">subtractingDays: count	"Answer the CalendarDay in the receiver's year type whose day-of-year ordinal is computed by subtracting &lt;count&gt; from the receiver's day-of-year ordinal. If the resulting day-of-year ordinal is not valid, answer nil."	^count &gt; 0		ifTrue: [containingPeriod prevDayInYearBefore: self count: count - 1]				ifFalse: 			[count &lt; 0				ifTrue: [self addingDays: count negated]				ifFalse: [self]]</body></methods><methods><class-id>Chronos.DynamicCalendarDay</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Irregular" selector="setDayOfMonthOrdinal:dayOfYearOrdinal:">setDayOfMonthOrdinal: dayOfMonth dayOfYearOrdinal: dayOfYear	"Initialize the receiver as a CalendarDay representing the &lt;dayOfMonth&gt; day of a month, and the &lt;dayOfYear&gt;th day of the year. Fail if the receiver is not mutable."	self assertMutability.	dayOfMonthOrdinal := dayOfMonth.	dayOfYearOrdinal := dayOfYear.</body></methods><methods><class-id>Chronos.DynamicCalendarDay class</class-id> <category>instance creation</category><body package="Chronos-Calendars-Irregular" selector="newInMonth:dayOfMonthOrdinal:dayOfYearOrdinal:">newInMonth: monthlyCalendar dayOfMonthOrdinal: dayOfMonth dayOfYearOrdinal: dayOfYear	"Answer an instance of the receiver initalized as a CalendarDay of the month represented by &lt;monthlyCalendar&gt; (an instance of MonthlyCalendar,) with &lt;dayOfMonth&gt; as the its day-of-month ordinal and with &lt;dayOfYear&gt; as its day-of-year ordinal."	^self new		setDayOfMonthOrdinal: dayOfMonth dayOfYearOrdinal: dayOfYear;		setMonthlyCalendar: monthlyCalendar;		beImmutable;		yourself</body></methods><methods><class-id>Chronos.MillisecondSystemClock</class-id> <category>API-conversion</category><body package="Chronos-System" selector="microsecondsFromTicks:">microsecondsFromTicks: ticks	^ticks * MicrosecondsPerMillisecond</body><body package="Chronos-System" selector="millisecondsFromTicks:">millisecondsFromTicks: ticks	^ticks</body><body package="Chronos-System" selector="nanosecondsFromTicks:">nanosecondsFromTicks: ticks	^ChronosFunction times1000000: ticks</body><body package="Chronos-System" selector="nanosecondsSinceSecondFromTicks:">nanosecondsSinceSecondFromTicks: ticks	"MillisecondSystemClock new nanosecondsSinceSecondFromTicks: 1200"	^ticks \\ ticksPerSecond * 1000000</body><body package="Chronos-System" selector="secondsFromTicks:">secondsFromTicks: ticks	^ChronosFunction times1000: ticks</body><body package="Chronos-System" selector="ticksFromMicroseconds:">ticksFromMicroseconds: microseconds 	^microseconds // MicrosecondsPerMillisecond</body><body package="Chronos-System" selector="ticksFromMilliseconds:">ticksFromMilliseconds: milliseconds	^milliseconds</body><body package="Chronos-System" selector="ticksFromNanososeconds:">ticksFromNanososeconds: nanoseconds 	^nanoseconds // NanosecondsPerMillisecond</body><body package="Chronos-System" selector="ticksFromSeconds:">ticksFromSeconds: seconds	^seconds * MillisecondsPerSecond</body></methods><methods><class-id>Chronos.MillisecondSystemClock</class-id> <category>API-timing</category><body package="Chronos-System" selector="ticksNowSinceSystemClockEpoch">ticksNowSinceSystemClockEpoch	"Answer the number of clock ticks since the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0)) up to the current moment. Do not adjust for timezone offset, just answer the raw value provided by the platform system clock (for many Smalltallk implementations, the platform system clock is a software device provided by the virtual machine, and can be accessed via primtive message send.)"	"The default implementation uses the network time service as defined by RFC-868, which provides the number of seconds since 1900-01-01T00:00:00 UTC"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.MillisecondSystemClock</class-id> <category>accessing</category><body package="Chronos-System" selector="tickResolutionName">tickResolutionName	"Answer a Symbol that identifies a time unit whose duration is that of the receiver's tick resolution."	^#millisecond</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>initialize-release</category><body package="Chronos-Localization" selector="canonicalizeState">canonicalizeState	delegate == nil 		ifTrue: 			[self isRoot ifFalse: [self setDelegate: Root]].	super canonicalizeState.	semanticDatePolicyKey == nil ifTrue: [self setSemanticDatePolicyKey: self registrationKey]</body><body package="Chronos-Localization" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	temporalPrintPolicy := ChronosPrintPolicy referencedBy: (literalArray at: 6) decodeAsLiteralArray.	self 		setTimeZoneLocalizationPolicy: (literalArray at: 5) decodeAsLiteralArray;		setDelegate:  (literalArray at: 7);		setStandardCalendarRegistrationKey: (literalArray at: 8);		setSemanticDatePolicyKey: (literalArray at: 9);		setNotationalPolicies: (ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 10));		setCharacters: (ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 11));		setProperNames: (ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 12));		setAbbreviations: (ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 13));		setSingularNouns: (ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 14)) pluralNouns: (ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 15))</body><body package="Chronos-Localization" selector="setAbbreviations:">setAbbreviations: aDictionary	self assertMutability.	abbreviations := aDictionary</body><body package="Chronos-Localization" selector="setCharacters:">setCharacters: aDictionary	self assertMutability.	characters := aDictionary</body><body package="Chronos-Localization" selector="setDelegate:">setDelegate: aChronosLocaleOrReference 	self assertMutability.	delegate := aChronosLocaleOrReference == nil 				ifFalse: [ChronosLocale referencedBy: aChronosLocaleOrReference]</body><body package="Chronos-Localization" selector="setNotationalPolicies:">setNotationalPolicies: aDictionary	self assertMutability.	notationalPolicies := aDictionary</body><body package="Chronos-Localization" selector="setProperNames:">setProperNames: aDictionary	self assertMutability.	properNames := aDictionary</body><body package="Chronos-Localization" selector="setSemanticDatePolicyKey:">setSemanticDatePolicyKey: aSymbol	self assertMutability.	semanticDatePolicyKey  := aSymbol == nil ifFalse: [aSymbol asSymbol]</body><body package="Chronos-Localization" selector="setSingularNouns:pluralNouns:">setSingularNouns: singularDictionary pluralNouns: pluralDictionary	self assertMutability.	singularNouns := singularDictionary.	pluralNouns := pluralDictionary</body><body package="Chronos-Localization" selector="setStandardCalendarRegistrationKey:">setStandardCalendarRegistrationKey: aSymbol	self assertMutability.	standardCalendarRegistrationKey := aSymbol == nil ifFalse: [aSymbol asSymbol]</body><body package="Chronos-Localization" selector="setTimeZoneLocalizationPolicy:">setTimeZoneLocalizationPolicy: aTimeZoneLocalizationPolicy	self assertMutability.	timeZoneLocalizationPolicy := TimeZoneLocalizationPolicy referencedBy: aTimeZoneLocalizationPolicy.</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>accessing</category><body package="Chronos-Localization" selector="delegateIfNone:">delegateIfNone: ifNone 	^delegate == nil 		ifTrue: 			[self isRoot 				ifTrue: [ifNone value]				ifFalse: 					[self isDefault 						ifTrue: [ChronosLocale system]						ifFalse: 							[self isSystem 								ifTrue: [ChronosLocale root]								ifFalse: [ChronosLocale default]]]]		ifFalse: [delegate]</body><body package="Chronos-Localization" selector="semanticDatePolicyKey">semanticDatePolicyKey	^semanticDatePolicyKey == nil 		ifTrue: [(self delegateIfNone: [^self registrationKey]) semanticDatePolicyKey]		ifFalse: [semanticDatePolicyKey]</body><body package="Chronos-Localization" selector="standardCalendarRegistrationKey">standardCalendarRegistrationKey	^standardCalendarRegistrationKey == nil		ifTrue: [(self delegateIfNone: [^super standardCalendarRegistrationKey]) standardCalendarRegistrationKey]		ifFalse: [standardCalendarRegistrationKey]</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>API-Notational Policies</category><body package="Chronos-Localization" selector="notationalPolicyAt:ifAbsent:">notationalPolicyAt: policyKey ifAbsent: ifAbsent	^notationalPolicies == nil 		ifTrue: 			[(self delegateIfNone: [^ifAbsent value]) 				notationalPolicyAt: policyKey				ifAbsent: ifAbsent]		ifFalse: 			[notationalPolicies 				at: policyKey				ifAbsent: 					[(self delegateIfNone: [^ifAbsent value]) 						notationalPolicyAt: policyKey						ifAbsent: ifAbsent]]</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>API-Abbreviations</category><body package="Chronos-Localization" selector="abbreviationAtSemanticKey:ifAbsent:">abbreviationAtSemanticKey: semanticKey ifAbsent: ifAbsent 	^abbreviations == nil 		ifTrue: 			[(self delegateIfNone: [^ifAbsent value]) 				abbreviationAtSemanticKey: semanticKey				ifAbsent: ifAbsent]		ifFalse: 			[abbreviations 				at: semanticKey				ifAbsent: 					[(self delegateIfNone: [^ifAbsent value]) 						abbreviationAtSemanticKey: semanticKey						ifAbsent: ifAbsent]]</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>API-Nouns</category><body package="Chronos-Localization" selector="pluralNounAtSemanticKey:ifAbsent:">pluralNounAtSemanticKey: semanticKey ifAbsent: ifAbsent 	^pluralNouns == nil 		ifTrue: 			[(self delegateIfNone: [^ifAbsent value]) 				pluralNounAtSemanticKey: semanticKey				ifAbsent: ifAbsent]		ifFalse: 			[pluralNouns 				at: semanticKey				ifAbsent: 					[(self delegateIfNone: [^ifAbsent value]) 						pluralNounAtSemanticKey: semanticKey						ifAbsent: ifAbsent]]</body><body package="Chronos-Localization" selector="singularNounAtSemanticKey:ifAbsent:">singularNounAtSemanticKey: semanticKey ifAbsent: ifAbsent 	^singularNouns == nil 		ifTrue: 			[(self delegateIfNone: [^ifAbsent value]) 				singularNounAtSemanticKey: semanticKey				ifAbsent: ifAbsent]		ifFalse: 			[singularNouns 				at: semanticKey				ifAbsent: 					[(self delegateIfNone: [^ifAbsent value]) 						singularNounAtSemanticKey: semanticKey						ifAbsent: ifAbsent]]</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>API-Characters/Punctuation</category><body package="Chronos-Localization" selector="characterAtSemanticKey:ifAbsent:">characterAtSemanticKey: semanticKey ifAbsent: ifAbsent 	^characters == nil 		ifTrue: 			[(self delegateIfNone: [^ifAbsent value]) 				characterAtSemanticKey: semanticKey				ifAbsent: ifAbsent]		ifFalse: 			[characters 				at: semanticKey				ifAbsent: 					[(self delegateIfNone: [^ifAbsent value]) 						characterAtSemanticKey: semanticKey						ifAbsent: ifAbsent]]</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>private</category><body package="Chronos-Localization" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: timeZoneLocalizationPolicy registrationKey;		nextPut: self temporalPrintPolicy registrationKey;		nextPut: (delegate == nil ifFalse: [delegate registrationKey]);		nextPut: standardCalendarRegistrationKey;		nextPut: semanticDatePolicyKey;		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: notationalPolicies);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: characters);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: properNames);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: abbreviations);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: singularNouns);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: pluralNouns)</body><body package="Chronos-Localization" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	super postCopy.	notationalPolicies := notationalPolicies copy.	characters := characters copy.	properNames := properNames copy.	abbreviations := abbreviations copy.	singularNouns := singularNouns copy.	pluralNouns := pluralNouns copy.</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale</class-id> <category>API-Proper Names</category><body package="Chronos-Localization" selector="properNameAtSemanticKey:ifAbsent:">properNameAtSemanticKey: semanticKey ifAbsent: ifAbsent 	^properNames == nil 		ifTrue: 			[(self delegateIfNone: [^ifAbsent value]) 				properNameAtSemanticKey: semanticKey				ifAbsent: ifAbsent]		ifFalse: 			[properNames 				at: semanticKey				ifAbsent: 					[(self delegateIfNone: [^ifAbsent value]) 						properNameAtSemanticKey: semanticKey						ifAbsent: ifAbsent]]</body></methods><methods><class-id>Chronos.ConfigurableChronosLocale class</class-id> <category>private</category><body package="Chronos-Localization" selector="newRegistry">newRegistry	^self superclass registry</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>printing</category><body package="Chronos-Duration" selector="defaultPrintPolicy">defaultPrintPolicy	^ChronosPrintPolicy iso8601</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	"If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy default (or ChronosPrintPolicy ansiStandard or ChronosPrintPolicy iso8601,) then the receiver's printString will be formatted as required by the ISO 8601 Standard."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printCivilDuration: self on: stream</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>testing</category><body package="Chronos-Duration" selector="calendarPeriodsAreZero">calendarPeriodsAreZero	"Answer whether the components of the receiver's duration vector that represent calendrical periods (years, months, days) all have the value zero."	^days = 0 and: [months = 0 and: [years = 0]]</body><body package="Chronos-Duration" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^days = 1 and: [months = 0 and: [years = 0]]</body><body package="Chronos-Duration" selector="isMonthDuration">isMonthDuration	"Answer whether the receiver's temporal extent is one month."	^months = 1 and: [days = 0 and: [years = 0]]</body><body package="Chronos-Duration" selector="isYearDuration">isYearDuration	"Answer whether the receiver's temporal extent is one year."	^years = 1 and: [days = 0 and: [months = 0]]</body><body package="Chronos-Duration" selector="isZero">isZero	"Answer the whether the receiver represents a zero-length temporal extent."	^self nonCalendarPeriodsAreZero and: [self calendarPeriodsAreZero]</body><body package="Chronos-Duration" selector="negative">negative	"Answer whether the receiver represents a temporal extent whose magnitude is negative."	"Specified and required by the ANSI-Smalltalk Standard."	self yearsAndMonthsMustBeZeroOrNegative.	^days negative and: [self nonCalendarPeriodsNegative]</body><body package="Chronos-Duration" selector="positive">positive	"Answer whether the receiver represents a temporal extent whose magnitude is positive (or zero.)"	"Specified and required by the ANSI-Smalltalk Standard."	self yearsAndMonthsMustBeZeroOrPositive.	^days positive and: [self nonCalendarPeriodsPositive]</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>initialize-release</category><body package="Chronos-Duration" selector="addDays:">addDays: addedDays	self assertMutability.	days := days + addedDays.</body><body package="Chronos-Duration" selector="addMonths:">addMonths: addedMonths	self assertMutability.	months := months + addedMonths.</body><body package="Chronos-Duration" selector="addYears:">addYears: addedYears	self assertMutability.	years := years + addedYears.</body><body package="Chronos-Duration" selector="addYears:months:">addYears: addedYears months: addedMonths	self assertMutability.	years := years + addedYears.	months := months + addedMonths.</body><body package="Chronos-Duration" selector="addYears:months:days:">addYears: addedYears months: addedMonths days: addedDays	self assertMutability.	years := years + addedYears.	months := months + addedMonths.	days := days + addedDays.</body><body package="Chronos-Duration" selector="beAbsolute">beAbsolute	"Make the receiver's temporal extent be the absolute value of its current temporal extent. Fail if the receiver is immutable."	super beAbsolute.	years := years abs.	months := months abs.	days := days abs.</body><body package="Chronos-Duration" selector="beNegated">beNegated	"Make the receiver's temporal extent be the additive inverse ('negated value') of its current temporal extent. Fail if the receiver is immutable."	super beNegated.	years := years negated.	months := months negated.	days := days negated.</body><body package="Chronos-Duration" selector="beToYear:month:day:fromYear:month:day:calendar:">beToYear: toYear month: toMonth day: toDay fromYear: fromYear month: fromMonth day: fromDay calendar: calendar	"Make the receiver represent a calendrical duration vector that specifies the number of years, months and days between two points-in-time (both designated in terms of the specified &lt;calendar&gt;,) such that the calendrical duration vector is in 'normal form.'  The two points-in-time are the 'to-moment' and the 'from-moment.'  The 'to-moment' is specified by the parameters &lt;toYear&gt;, &lt;toMonth&gt;, and &lt;toDay&gt; (a day of the &lt;toMonth&gt;).   The 'from-moment' is specified by the parameters &lt;fromYear&gt;, &lt;fromMonth&gt; and &lt;fromDay&gt; (a day of the &lt;fromMonth&gt;). As a result of the execution of this method, the receiver must represent the temporal extent since the 'from-moment' up to the 'to-moment,' assuming that there are always 86400 seconds in a day.	The constraints that a calendrical duration vector must satisfy in order to be in normal form are as follows:			1. If the number of years of the duration vector are positive, then the number of months must be positive or zero. If the number of years of the duration vector are negative, then the number of months must be negative or zero. This constraint does not apply when the number of years are zero.		2. If either the number of years and/or of the number of months of the duration vector are positive, then the number of days must be positive or zero. If either the number of years and/or of the number of months of the duration vector are negative, then the number of days must be negative or zero. This constraint does not apply when the number of years and months are both zero.	NOTE: The message semantics are non-commutative."	"{CalendarDuration new		beToYear: 2004 month: 2 day: 29		fromYear: 2004 month: 4 day: 1		calendar: Gregorian}  P-1M-1D"	"{CalendarDuration new		beToYear: 2004 month: 4 day: 1		fromYear: 2004 month: 2 day: 29		calendar: Gregorian }  P1M3D"	"{CalendarDuration new		beToYear: 2004 month: 3 day: 15		fromYear: 2004 month: 2 day: 16		calendar: Gregorian}  P28D"	"{CalendarDuration new		beToYear: 2004 month: 4 day: 15		fromYear: 2004 month: 2 day: 16		calendar: Gregorian}  P1M30D"	"{CalendarDuration new		beToYear: 2005 month: 3 day: 15		fromYear: 2004 month: 3 day: 16		calendar: Gregorian}  P11M27D"	"{CalendarDuration new		beToYear: 2005 month: 3 day: 6		fromYear: 1905 month: 3 day: 16		calendar: Gregorian}  P99Y11M18D"	"{CalendarDuration new		beToYear: 2005 month: 1 day: 1		fromYear: 2004 month: 11 day: 30		calendar: Gregorian}  P1M2D"	"{CalendarDuration new		beToYear: 2004 month: 12 day: 1		fromYear: 1999 month: 8 day: 20		calendar: Gregorian}  P5Y3M11D"	"{CalendarDuration new		beToYear: 2004 month: 8 day: 20		fromYear: 1999 month: 12 day: 1		calendar: Gregorian}  P4Y8M19D"	| yearNumberingPolicy year month monthsInYear daysInMonth |	yearNumberingPolicy := calendar yearNumberingPolicy.	self		setYears: (yearNumberingPolicy ordinalFromCanonical: toYear) - (yearNumberingPolicy ordinalFromCanonical: fromYear) months: toMonth - fromMonth;		setDays: toDay - fromDay.	monthsInYear := nil.	years &gt; 0 		ifTrue: 			[months &gt;= 0 				ifFalse: 					[years := years - 1.					months := months + (monthsInYear := calendar monthsInYear: fromYear)].			days &gt;= 0 				ifFalse: 					[months := months - 1.					months &lt; 0 						ifTrue: 							[years := years - 1.							monthsInYear == nil 								ifTrue: [monthsInYear := calendar monthsInYear: fromYear].							months := monthsInYear + months].					year := toYear.					month := toMonth - 1.					month &lt; 1 						ifTrue: 							[year := year - 1.							monthsInYear == nil 								ifTrue: [monthsInYear := calendar monthsInYear: fromYear].							month := monthsInYear].					daysInMonth := calendar daysInMonth: month inYear: year.					fromDay &gt; daysInMonth ifTrue: [daysInMonth := calendar daysInMonth: toMonth inYear: toYear].					days := days + daysInMonth]]		ifFalse: 			[years &lt; 0 				ifTrue: 					[months &lt;= 0 						ifFalse: 							[years := years + 1.							months := months - (monthsInYear := calendar monthsInYear: toYear)].					days &lt;= 0 						ifFalse: 							[months := months + 1.							months &gt; -1 								ifTrue: 									[years := years + 1.									monthsInYear == nil 										ifTrue: [monthsInYear := calendar monthsInYear: toYear].									months := months - monthsInYear].							year := toYear.							month := toMonth.							month &lt; 1 								ifTrue: 									[year := year + 1.									monthsInYear == nil 										ifTrue: [monthsInYear := calendar monthsInYear: toYear].									month := monthsInYear].							days := days - (calendar daysInMonth: month inYear: year)]]				ifFalse: 					[months &gt; 0 						ifTrue: 							[days &gt;= 0 								ifFalse: 									[months := months - 1.									year := toYear.									month := toMonth - 1.									month &lt; 1 										ifTrue: 											[year := year - 1.											month := calendar monthsInYear: fromYear].									daysInMonth := calendar daysInMonth: month inYear: year.									fromDay &gt; daysInMonth ifTrue: [daysInMonth := calendar daysInMonth: toMonth inYear: toYear].									days := days + daysInMonth]]						ifFalse: 							[months &lt; 0 								ifTrue: 									[days &lt;= 0 										ifFalse: 											[months := months + 1.											days := days - (calendar daysInMonth: toMonth inYear: toYear)]]]]]</body><body package="Chronos-Duration" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	self assertMutability.	days == nil ifTrue: [days := 0].	months == nil ifTrue: [months := 0].	years == nil ifTrue: [years := 0].</body><body package="Chronos-Duration" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	days := 0.	months := 0.	years := 0</body><body package="Chronos-Duration" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self		setYears: (literalArray at: 2) asNumber months: (literalArray at: 3) asNumber;		setDays: (literalArray at: 4) asNumber</body><body package="Chronos-Duration" selector="setDays:">setDays: d 	"Set the component of the receiver's duration vector that represents its temporal extent in days to the value &lt;d&gt;. Fail if the receiver is not mutable."	self assertMutability.	days := d</body><body package="Chronos-Duration" selector="setYears:months:">setYears: y months: m	"Set the component of the receiver's duration vector that represents its temporal extent in years to the value &lt;y&gt;, and set the component of the receiver's duration vector that represents its temporal extent in months to the value &lt;m&gt;. Fail if the receiver is not mutable."	self assertMutability.	months := m.	years := y</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>arithmetic</category><body package="Chronos-Duration" selector="*">* aNumber	"{(CalendarDuration years: 1 months: 1 days:1) * 4}"	aNumber = 1 ifTrue: [^self].	^self copy		setYears: years * aNumber months: months * aNumber;		setDays: days * aNumber;		beImmutable</body><body package="Chronos-Duration" selector="+">+ aDurationOrTemporalCoordinate	"{((CalendarDuration years: 1 months: -3 days: 5) + (CalendarDuration days: 7))}"	"{(CalendarDuration days: 7) - YearMonthDay today}"	^aDurationOrTemporalCoordinate addedToCalendarDuration: self</body><body package="Chronos-Duration" selector="-">- aDurationOrTemporalCoordinate	"{((CalendarDuration years: 1 months: -3 days: 5) - (CalendarDuration years: 2 months: -7 days: 7))}"	"{(CalendarDuration days: 7) - YearMonthDay today}"	^aDurationOrTemporalCoordinate subtractedFromCalendarDuration: self</body><body package="Chronos-Duration" selector="/">/ aNumber	"{(CalendarDuration years: 4 months: 8 days:16) / 4}"	aNumber = 1 ifTrue: [^self].	^self copy 		setYears: years // aNumber months: months // aNumber;		setDays: days // aNumber;		beImmutable</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>accessing</category><body package="Chronos-Duration" selector="days">days	"Answer the integer number of days (truncated towards zero) represented by the receiver, independent of the number of years, months or seconds it may represent."	"Specified and required by the ANSI-Smalltalk Standard."	^days</body><body package="Chronos-Duration" selector="months">months	"Answer the integer number of months (truncated towards zero) represented by the receiver, independent of the number of years or seconds it may represent."	^months</body><body package="Chronos-Duration" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^CalendarDayDuration</body><body package="Chronos-Duration" selector="years">years	"Answer the integer number of years (truncated towards zero) represented by the receiver, independent of the number of months or seconds it may represent."	^years</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>private-arithmetic</category><body package="Chronos-Duration" selector="addedToCalendarDuration:">addedToCalendarDuration: aCalendarDuration 	^aCalendarDuration 		addingYears: years		months: months		days: days</body><body package="Chronos-Duration" selector="addedToCivilDuration:">addedToCivilDuration: aCivilDuration 	^aCivilDuration 		addingYears: years		months: months		days: days</body><body package="Chronos-Duration" selector="addedToDuration:">addedToDuration: aDuration 	^aDuration isZero 		ifTrue: [self]		ifFalse: 			[(self asSubDayMutable)				addSeconds: aDuration asSeconds nanoseconds: aDuration nanosecondsSinceSecond;				beImmutable]</body><body package="Chronos-Duration" selector="addedToTemporalInterval:">addedToTemporalInterval: aTemporalInterval	^aTemporalInterval 		addingYears: years		months: months		days: days</body><body package="Chronos-Duration" selector="subtractedFromCalendarDuration:">subtractedFromCalendarDuration: aCalendarDuration 	^aCalendarDuration 		subtractingYears: years		months: months		days: days</body><body package="Chronos-Duration" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aCivilDuration 	^aCivilDuration 		subtractingYears: years		months: months		days: days</body><body package="Chronos-Duration" selector="subtractedFromDuration:">subtractedFromDuration: aDuration 	^aDuration isZero 		ifTrue: [self negated]		ifFalse: 			[aDuration nonCalendarPeriodsAreZero 				ifTrue: 					[self class 						years: years negated						months: months negated						days: days negated]				ifFalse: 					[self class 						years: years negated						months: months negated						days: days negated						seconds: aDuration asSeconds						nanoseconds: aDuration nanosecondsSinceSecond]]</body><body package="Chronos-Duration" selector="subtractedFromTemporalInterval:">subtractedFromTemporalInterval: aTemporalInterval 	^aTemporalInterval		subtractingYears: years		months: months		days: days</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>converting</category><body package="Chronos-Duration" selector="asCalendarDuration">asCalendarDuration	^self</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>comparing</category><body package="Chronos-Duration" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	self == aMagnitude ifTrue: [^true].	^[aMagnitude isEqualToCalendarDuration: self]		on: MessageNotUnderstood		do: [:ex | 			(ex receiver == aMagnitude and: [ex message selector == #isEqualToCalendarDuration:])				ifTrue: [ex return: false]				ifFalse: [ex pass]]</body><body package="Chronos-Duration" selector="hash">hash	^(months + years + days) hash</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>private</category><body package="Chronos-Duration" selector="asCivilSubDayMutable">asCivilSubDayMutable	^self class civilDurationFactory new		setYears: years months: months;		setDays: days</body><body package="Chronos-Duration" selector="asSubDayMutable">asSubDayMutable	^self class civilDurationFactory new		setYears: years months: months;		setDays: days</body><body package="Chronos-Duration" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: years;		nextPut: months;		nextPut: days</body></methods><methods><class-id>Chronos.CalendarDuration</class-id> <category>private-comparing</category><body package="Chronos-Duration" selector="isEqualToCalendarDuration:">isEqualToCalendarDuration: aCalendarDuration	^years = aCalendarDuration years and: [months = aCalendarDuration months and: [days = aCalendarDuration days]]</body><body package="Chronos-Duration" selector="isEqualToCivilDuration:">isEqualToCivilDuration: aCivilDuration 	^aCivilDuration nonCalendarPeriodsAreZero 		and: [self isEqualToCalendarDuration: aCivilDuration]</body></methods><methods><class-id>Chronos.CalendarDuration class</class-id> <category>accessing</category><body package="Chronos-Duration" selector="zero">zero	"Answer a CalendarDuration that represents a temporal extent of zero."	"CalendarDuration zero"	^Zero</body></methods><methods><class-id>Chronos.CalendarDuration class</class-id> <category>instance creation</category><body package="Chronos-Duration" selector="days:hours:minutes:seconds:">days: d hours: h minutes: m seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;d&gt; days, &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds."	"Specified and required by the ANSI-Smalltalk Standard."	^self civilDurationFactory days: d hours: h minutes: m seconds: s</body><body package="Chronos-Duration" selector="days:hours:minutes:seconds:nanoseconds:">days: d hours: h minutes: m seconds: s nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;d&gt; days, &lt;h&gt; hours, &lt;m&gt; minutes, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{Timepoint now + (ScientificDuration days: 182 hours: 24 minutes: 10 seconds: -59 nanoseconds: -1)}"	"{Timepoint now + (CivilDuration days: 182 hours: 24 minutes: 10 seconds: -59 nanoseconds: -1)}"	^self civilDurationFactory days: d hours: h minutes: m seconds: s nanoseconds: n</body><body package="Chronos-Duration" selector="hours:">hours: h 	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours."	^self civilDurationFactory hours: h</body><body package="Chronos-Duration" selector="hours:minutes:seconds:">hours: h minutes: m seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds."	^self civilDurationFactory hours: h minutes: m seconds: s</body><body package="Chronos-Duration" selector="hours:minutes:seconds:nanoseconds:">hours: h minutes: m seconds: s nanoseconds: n 	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours, &lt;m&gt; minutes, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	^self civilDurationFactory 		hours: h		minutes: m		seconds: s		nanoseconds: n</body><body package="Chronos-Duration" selector="microseconds:">microseconds: microseconds	"Answer an immutable durational value representing a temporal extent of &lt;microseconds&gt; microseconds."	^self civilDurationFactory microseconds: microseconds</body><body package="Chronos-Duration" selector="milliseconds:">milliseconds: milliseconds	"Answer an immutable durational value representing a temporal extent of &lt;milliseconds&gt; milliseconds."	^self civilDurationFactory milliseconds: milliseconds</body><body package="Chronos-Duration" selector="minutes:">minutes: m	"Answer an immutable durational value representing a temporal extent of &lt;m&gt; minutes."	^self civilDurationFactory minutes: m</body><body package="Chronos-Duration" selector="months:">months: m	"Answer an immutable CalendarDuration representing a temporal extent of &lt;m&gt; months."	"{Timepoint now + (CalendarDuration months: 360)}"	"{Timepoint now - (CalendarDuration months: -360)}"	^self years: 0 months: m</body><body package="Chronos-Duration" selector="nanoseconds:">nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;n&gt; nanoseconds."	^self civilDurationFactory nanoseconds: n</body><body package="Chronos-Duration" selector="quarters:">quarters: q	"Answer an immutable CalendarDuration representing a temporal extent of &lt;q&gt; quarters."	"{Timepoint now + (CalendarDuration quarters: 120)}"	"{Timepoint now - (CalendarDuration quarters: -120)}"	^self years: 0 months: q * 3</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextCalendarDurationFrom: stream usingFactory: self</body><body package="Chronos-Duration" selector="seconds:">seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;s&gt; seconds."	"Specified and required by the ANSI-Smalltalk Standard."	^self civilDurationFactory seconds: s</body><body package="Chronos-Duration" selector="seconds:nanoseconds:">seconds: s nanoseconds: n 	"Answer an immutable durational value representing a temporal extent of &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	^self civilDurationFactory seconds: s nanoseconds: n</body><body package="Chronos-Duration" selector="years:">years: y	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years."	"{Timepoint now + (CalendarDuration years: 30)}"	"{Timepoint now - (CalendarDuration years: -30)}"	^self years: y months: 0</body><body package="Chronos-Duration" selector="years:months:">years: y months: m	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years and &lt;m&gt; months."	"{Timepoint now + (CalendarDuration years: 1 months: -6)}"	"{Timepoint now + (CalendarDuration years: -2 months: 18)}"	^self years: y months: m days: 0</body><body package="Chronos-Duration" selector="years:months:days:">years: y months: m days: d	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years, &lt;m&gt; months and &lt;d&gt; days."	"{Timepoint now + (CalendarDuration years: 1 months: -6 days: 1/2)}"	"{Timepoint now + (CalendarDuration years: -2 months: 18 days: 1/2)}"	^self new		setYears: y months: m;		setDays: d;		beImmutable</body><body package="Chronos-Duration" selector="years:months:days:hours:minutes:seconds:">years: y months: months days: d hours: h minutes: minutes seconds: s	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years, &lt;months&gt; months, &lt;d&gt; days, &lt;h&gt; hours &lt;minutes&gt; minutes and &lt;s&gt; seconds."	"{Timepoint now + (CivilDuration years: 1 months: 1 days: 1 hours: 1 minutes: 1 seconds: 1)}"	"{Timepoint now + (CivilDuration years: 1 months: -1 days: 1 hours: -1 minutes: 1 seconds: -1)}"	^self civilDurationFactory years: y months: months days: d hours: h minutes: minutes seconds: s</body><body package="Chronos-Duration" selector="years:months:days:hours:minutes:seconds:nanoseconds:">years: y months: months days: d hours: h minutes: minutes seconds: s nanoseconds: n 	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years, &lt;months&gt; months, &lt;d&gt; days, &lt;h&gt; hours &lt;minutes&gt; minutes, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{Timepoint now + (CivilDuration years: 1 months: 1 days: 1 hours: 1 minutes: 1 seconds: 1 nanoseconds: 1000000001)}"	"{Timepoint now + (CivilDuration years: -1 months: 1 days: -1 hours: 1 minutes: -1 seconds: 1 nanoseconds: -1000000001)}"	^self civilDurationFactory 		years: y		months: months		days: d		hours: h		minutes: minutes		seconds: s		nanoseconds: n</body><body package="Chronos-Duration" selector="years:months:days:seconds:nanoseconds:">years: y months: months days: d seconds: s nanoseconds: n	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years, &lt;months&gt; months, &lt;d&gt; days, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{Timepoint now + (CivilDuration years: -1 months: 6 days: 6 seconds: 6 nanoseconds: 1000000001)}"	"{Timepoint now + (CivilDuration years: 1 months: -6 days: 6 seconds: -6 nanoseconds: 1000000001)}"	^self civilDurationFactory years: y months: months days: d seconds: s nanoseconds: n</body></methods><methods><class-id>Chronos.CalendarDuration class</class-id> <category>class initialization</category><body package="Chronos-Duration" selector="initializeClassVariables">initializeClassVariables	"CalendarDuration initializeClassVariables"	Zero := self new beImmutable</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>converting</category><body package="Chronos-Duration" selector="asCalendarDuration">asCalendarDuration	^self class calendarDurationFactory  		years: years		months: months		days: self asDays</body><body package="Chronos-Duration" selector="asCivilDuration">asCivilDuration	^self</body><body package="Chronos-Duration" selector="asFractionalDays">asFractionalDays	"Answer the number of days (including any fractional part) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.)."	self yearsAndMonthsMustBeZero.	^ScaledDecimal 		numerator: self asNanoseconds 		denominator: SecondsPerDay * NanosecondsPerSecond 		scale: 9</body><body package="Chronos-Duration" selector="asNanoseconds">asNanoseconds	"Answer the integer number of nanoseconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each time period (days, hours, minutes.).."	^nanosecondsSinceSecond + super asNanoseconds</body><body package="Chronos-Duration" selector="asSeconds">asSeconds	"Answer the integer number of seconds (truncated towards zero) represented by the receiver's temporal extent, independent of the number of years and/or months it may represent, and assuming an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^super asSeconds + self secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>accessing</category><body package="Chronos-Duration" selector="hours">hours	"Answer the integer number of hours-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in hours after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^hours</body><body package="Chronos-Duration" selector="minutes">minutes	"Answer the integer number of minutes-since-the-hour (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in minutes after subtracting from its temporal extent integer number of hours (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^minutes</body><body package="Chronos-Duration" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	"Answer the integer number of nanoseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in nanoseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^NanosecondDuration</body><body package="Chronos-Duration" selector="seconds">seconds	"Answer the integer number of seconds-since-the-minute (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of minutes (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^seconds</body><body package="Chronos-Duration" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	"Answer the integer number of seconds-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.) Assume an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^(hours * SecondsPerHour) + (minutes * SecondsPerMinute) + seconds</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>private</category><body package="Chronos-Duration" selector="asCivilSubDayMutable">asCivilSubDayMutable	^self copy</body><body package="Chronos-Duration" selector="asSubDayMutable">asSubDayMutable	^self copy</body><body package="Chronos-Duration" selector="canonicalizeHoursSinceDayMagnitude">canonicalizeHoursSinceDayMagnitude	"The receiver is about to made immutable.  Therefore, if the absolute value of hours is greater than or equal to the number of hours in an day, propagate its excess magnitude upward. Fail if the receiver is not mutable."	self assertMutability.	hours abs &gt;= HoursPerDay		ifTrue: 			[days := days +  (hours quo: HoursPerDay).			hours := hours rem: HoursPerDay].</body><body package="Chronos-Duration" selector="canonicalizeHoursSinceDayPolarity">canonicalizeHoursSinceDayPolarity	self canonicalizeHoursSinceDayPolarity: (days = 0 ifTrue: [months = 0 ifTrue: [years] ifFalse: [months]] ifFalse: [days])</body><body package="Chronos-Duration" selector="canonicalizeHoursSinceDayPolarity:">canonicalizeHoursSinceDayPolarity: polarity	polarity &gt; 0 		ifTrue: 			[hours &lt; 0 				ifTrue: 					[days := days - 1.					hours := hours + HoursPerDay.					self canonicalizeMinutesSinceHourPolarity: (hours = 0 ifTrue: [polarity] ifFalse: [hours])]				ifFalse: 					[self canonicalizeMinutesSinceHourPolarity: 						(hours = 0 							ifTrue: [polarity]							ifFalse: [hours])]]		ifFalse: 			[polarity &lt; 0 				ifTrue: 					[hours &gt; 0 						ifTrue: 							[days := days + 1.							hours := hours - HoursPerDay.							self canonicalizeMinutesSinceHourPolarity: (hours = 0 ifTrue: [polarity] ifFalse: [hours])]						ifFalse: 							[self canonicalizeMinutesSinceHourPolarity: 								(hours = 0 									ifTrue: [polarity]									ifFalse: [hours])]]				ifFalse: [self canonicalizeMinutesSinceHourPolarity: (hours = 0 ifTrue: [polarity] ifFalse: [hours])]]</body><body package="Chronos-Duration" selector="canonicalizeMinutesSinceHourMagnitude">canonicalizeMinutesSinceHourMagnitude	"The receiver is about to made immutable.  Therefore, if the absolute value of minutes is greater than or equal to the number of minutes in an hour, propagate its excess magnitude upward. Fail if the receiver is not mutable."	self assertMutability.	minutes abs &gt;= MinutesPerHour 		ifTrue: 			[hours := hours + (minutes quo: MinutesPerHour).			minutes := minutes rem: MinutesPerHour].	self canonicalizeHoursSinceDayMagnitude</body><body package="Chronos-Duration" selector="canonicalizeMinutesSinceHourPolarity:">canonicalizeMinutesSinceHourPolarity: polarity 	polarity &gt; 0 		ifTrue: 			[minutes &lt; 0 				ifTrue: 					[hours := hours - 1.					minutes := minutes + MinutesPerHour.					self canonicalizeSecondsSinceMinutePolarity: minutes]				ifFalse: 					[self canonicalizeSecondsSinceMinutePolarity: 						(minutes = 0 							ifTrue: [hours = 0 ifTrue: [days] ifFalse: [hours]]							ifFalse: [minutes])]]		ifFalse: 			[polarity &lt; 0 				ifTrue: 					[minutes &gt; 0 						ifTrue: 							[hours := hours + 1.							minutes := minutes - MinutesPerHour.							self canonicalizeSecondsSinceMinutePolarity: minutes]						ifFalse: 							[self canonicalizeSecondsSinceMinutePolarity: 								(minutes = 0 									ifTrue: [hours = 0 ifTrue: [days] ifFalse: [hours]]									ifFalse: [minutes])]]				ifFalse: [self canonicalizeSecondsSinceMinutePolarity: minutes]]</body><body package="Chronos-Duration" selector="canonicalizeNanosecondsSinceSecondMagnitude">canonicalizeNanosecondsSinceSecondMagnitude	"The receiver is about to made immutable.  Therefore, if the absolute value of nanosecondsSinceSecond is greater than or equal to the number of nanoseconds in a second, propagate its excess magnitude upward. Fail if the receiver is not mutable."	self assertMutability.	nanosecondsSinceSecond abs &gt;= NanosecondsPerSecond		ifTrue: 			[seconds := seconds + ((nanosecondsSinceSecond bitShift: -9) quo: 1953125).			nanosecondsSinceSecond := nanosecondsSinceSecond rem: NanosecondsPerSecond].	self canonicalizeSecondsSinceMinuteMagnitude</body><body package="Chronos-Duration" selector="canonicalizeNanosecondsSinceSecondPolarity:">canonicalizeNanosecondsSinceSecondPolarity: polarity 	polarity &gt; 0 		ifTrue: 			[nanosecondsSinceSecond &lt; 0 				ifTrue: 					[seconds := seconds - 1.					nanosecondsSinceSecond := nanosecondsSinceSecond + NanosecondsPerSecond]]		ifFalse: 			[polarity &lt; 0 				ifTrue: 					[nanosecondsSinceSecond &gt; 0 						ifTrue: 							[seconds := seconds + 1.							nanosecondsSinceSecond := nanosecondsSinceSecond - NanosecondsPerSecond]]]</body><body package="Chronos-Duration" selector="canonicalizeSecondsSinceMinuteMagnitude">canonicalizeSecondsSinceMinuteMagnitude	"The receiver is about to made immutable.  Therefore, if the absolute value of seconds is greater than or equal to the number of seconds in a minute, propagate its excess magnitude upward. Fail if the receiver is not mutable."	self assertMutability.	seconds abs &gt;= SecondsPerMinute 		ifTrue: 			[minutes := minutes + (seconds quo: SecondsPerMinute).			seconds := seconds rem: SecondsPerMinute].	self canonicalizeMinutesSinceHourMagnitude</body><body package="Chronos-Duration" selector="canonicalizeSecondsSinceMinutePolarity:">canonicalizeSecondsSinceMinutePolarity: polarity 	polarity &gt; 0 		ifTrue: 			[seconds &lt; 0 				ifTrue: 					[minutes := minutes - 1.					seconds := seconds + SecondsPerMinute.					self canonicalizeNanosecondsSinceSecondPolarity: seconds]				ifFalse: 					[self canonicalizeNanosecondsSinceSecondPolarity: 						(seconds = 0 							ifTrue: 								[minutes = 0 									ifTrue: [hours = 0 ifTrue: [days] ifFalse: [hours]]									ifFalse: [minutes]]							ifFalse: [seconds])]]		ifFalse: 			[polarity &lt; 0 				ifTrue: 					[seconds &gt; 0 						ifTrue: 							[minutes := minutes + 1.							seconds := seconds - SecondsPerMinute.							self canonicalizeNanosecondsSinceSecondPolarity: seconds]						ifFalse: 							[self canonicalizeNanosecondsSinceSecondPolarity: 								(seconds = 0 									ifTrue: 										[minutes = 0 											ifTrue: [hours = 0 ifTrue: [days] ifFalse: [hours]]											ifFalse: [minutes]]									ifFalse: [seconds])]]				ifFalse: [self canonicalizeNanosecondsSinceSecondPolarity: seconds]]</body><body package="Chronos-Duration" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: hours;		nextPut: minutes;		nextPut: seconds;		nextPut: nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>initialize-release</category><body package="Chronos-Duration" selector="addHours:">addHours: addedHours	self assertMutability.	hours := hours + addedHours.</body><body package="Chronos-Duration" selector="addHours:minutes:">addHours: addedHours minutes: addedMinutes	self assertMutability.	minutes := minutes + addedMinutes.	hours := hours + addedHours.</body><body package="Chronos-Duration" selector="addHours:minutes:seconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds	self assertMutability.	seconds := seconds + addedSeconds.	minutes := minutes + addedMinutes.	hours := hours + addedHours.</body><body package="Chronos-Duration" selector="addHours:minutes:seconds:nanoseconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds	self assertMutability.	nanosecondsSinceSecond := nanosecondsSinceSecond + addedNanoseconds.	seconds := seconds + addedSeconds.	minutes := minutes + addedMinutes.	hours := hours + addedHours.</body><body package="Chronos-Duration" selector="addMinutes:">addMinutes: addedMinutes	self assertMutability.	minutes := minutes + addedMinutes.</body><body package="Chronos-Duration" selector="addSeconds:">addSeconds: addedSeconds	self assertMutability.	seconds := seconds + addedSeconds.</body><body package="Chronos-Duration" selector="addSeconds:nanoseconds:">addSeconds: addedSeconds nanoseconds: addedNanoseconds	self assertMutability.	nanosecondsSinceSecond := nanosecondsSinceSecond + addedNanoseconds rounded.	seconds := seconds + addedSeconds.</body><body package="Chronos-Duration" selector="beAbsolute">beAbsolute	"Make the receiver's temporal extent be the absolute value of its current temporal extent. Fail if the receiver is immutable."	super beAbsolute.	hours := hours abs.	minutes := minutes abs.	seconds := seconds abs.	nanosecondsSinceSecond := nanosecondsSinceSecond abs.</body><body package="Chronos-Duration" selector="beNegated">beNegated	"Make the receiver's temporal extent be the additive inverse ('negated value') of its current temporal extent. Fail if the receiver is immutable."	super beNegated.	hours := hours negated.	minutes := minutes negated.	seconds := seconds negated.	nanosecondsSinceSecond := nanosecondsSinceSecond negated.</body><body package="Chronos-Duration" selector="beToYear:month:day:second:nanosecond:fromYear:month:day:second:nanosecond:calendar:">beToYear: toYear month: toMonth day: toDay second: toSecond nanosecond: toNanosecond fromYear: fromYear month: fromMonth day: fromDay second: fromSecond nanosecond: fromNanosecond calendar: calendar 	"Make the receiver represent a civil duration vector that specifies the number of years, months, days and seconds (including any fractional seconds) between two points-in-time (both designated in terms of the specified &lt;calendar&gt;,) such that the civil duration vector is in 'normal form.'  The two points-in-time are the 'to-moment' and the 'from-moment.'  The 'to-moment' is specified by the parameters &lt;toYear&gt;, &lt;toMonth&gt;, &lt;toDay&gt; (a day of the &lt;toMonth&gt;) and &lt;toSecond&gt; (a second of the day) and &lt;toNanosecond&gt;.   The 'from-moment' is specified by the parameters &lt;fromYear&gt;, &lt;fromMonth&gt;, &lt;fromDay&gt; (a day of the &lt;fromMonth&gt;) and &lt;fromSecond&gt; (a second of the day) and &lt;fromNanosecond&gt;. As a result of the execution of this method, the receiver must represent the temporal extent since the 'from-moment' up to the 'to-moment,' assuming that there are always 86400 seconds in a day.	The constraints that a civil duration vector must satisfy in order to be in normal form are as follows:			1. If the number of years of the duration vector are positive, then the number of months must be positive or zero. If the number of years of the duration vector are negative, then the number of months must be negative or zero. This constraint does not apply when the number of years are zero.		2. If either the number of years and/or of the number of months of the duration vector are positive, then the number of days must be positive or zero. If either the number of years and/or of the number of months of the duration vector are negative, then the number of days must be negative or zero. This constraint does not apply when the number of years and months are both zero.		3. If any of a) the number of years, b) the number of months, or c) the number of days of the duration vector are positive, then the number of seconds/nanoseconds must be positive or zero. If any of a) the number of years, b) the number of months, or c) the number of days of the duration vector are negative, then the number of seconds/nanoseconds must be negative or zero.  This constraint does not apply when the number of years, months and days are all zero.	NOTE: The message semantics are non-commutative."	"{CivilDuration new		beToYear: 2004 month: 2 day: 29 second: 0 nanosecond: 0		fromYear: 2004 month: 4 day: 1 second: 0 nanosecond: 0		calendar: Gregorian}  P-1M-1D"	"{CivilDuration new		beToYear: 2004 month: 4 day: 1  second: 0 nanosecond: 0		fromYear: 2004 month: 2 day: 29 second: 0 nanosecond: 0		calendar: Gregorian }  P1M3D"	"{CivilDuration new		beToYear: 2004 month: 3 day: 15  second: 0 nanosecond: 0		fromYear: 2004 month: 2 day: 16 second: 0 nanosecond: 0		calendar: Gregorian}  P28D"	"{CivilDuration new		beToYear: 2004 month: 4 day: 15  second: 0 nanosecond: 0		fromYear: 2004 month: 2 day: 16 second: 0 nanosecond: 0		calendar: Gregorian}  P1M30D"	"{CivilDuration new		beToYear: 2005 month: 3 day: 15  second: 0 nanosecond: 0		fromYear: 2004 month: 3 day: 16 second: 0 nanosecond: 0		calendar: Gregorian}  P11M27D"	"{CivilDuration new		beToYear: 2005 month: 3 day: 6  second: 0 nanosecond: 0		fromYear: 1905 month: 3 day: 16 second: 0 nanosecond: 0		calendar: Gregorian}  P99Y11M18D"	"{CivilDuration new		beToYear: 2005 month: 1 day: 1  second: 0 nanosecond: 0		fromYear: 2004 month: 11 day: 30 second: 0 nanosecond: 0		calendar: Gregorian}  P1M2D"	"{CivilDuration new		beToYear: 2004 month: 12 day: 1  second: 0 nanosecond: 0		fromYear: 1999 month: 8 day: 20 second: 0 nanosecond: 0		calendar: Gregorian}  P5Y3M11D"	"{CivilDuration new		beToYear: 2004 month: 8 day: 20  second: 0 nanosecond: 0		fromYear: 1999 month: 12 day: 1 second: 0 nanosecond: 0		calendar: Gregorian}  P4Y8M19D"	self 		beToYear: toYear		month: toMonth		day: toDay		fromYear: fromYear		month: fromMonth		day: fromDay		calendar: calendar.	self setSeconds: toSecond - fromSecond nanoseconds: toNanosecond - fromNanosecond.</body><body package="Chronos-Duration" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	super canonicalize.		nanosecondsSinceSecond == nil ifTrue: [nanosecondsSinceSecond := 0].	seconds == nil ifTrue: [seconds := 0].	minutes == nil ifTrue: [minutes := 0].	hours == nil ifTrue: [hours := 0].	days isInteger		ifFalse: 			[| int fractionalPart |			int := days truncated.			fractionalPart := days - int.			days := int.			hours := hours + (fractionalPart * HoursPerDay)].	hours isInteger		ifFalse:			[| int fractionalPart |			int := hours truncated.			fractionalPart := hours - int.			hours := int.			minutes := minutes + (fractionalPart * MinutesPerHour)].	minutes isInteger		ifFalse:			[| int fractionalPart |			int := minutes truncated.			fractionalPart := minutes - int.			minutes := int.			seconds := seconds + (fractionalPart * SecondsPerMinute)].	seconds isInteger		ifFalse:			[| int fractionalPart |			int := seconds truncated.			fractionalPart := seconds - int.			seconds := int.			nanosecondsSinceSecond := nanosecondsSinceSecond + (fractionalPart * NanosecondsPerSecond) truncated].	self canonicalizeNanosecondsSinceSecondMagnitude.	self canonicalizeHoursSinceDayPolarity.</body><body package="Chronos-Duration" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	hours := 0.	minutes := 0.	seconds := 0.	nanosecondsSinceSecond := 0</body><body package="Chronos-Duration" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self 		setHours: (literalArray at: 5) asNumber		minutes: (literalArray at: 6) asNumber		seconds: (literalArray at: 7) asNumber		nanoseconds: (literalArray at: 8) asNumber</body><body package="Chronos-Duration" selector="setDays:hours:minutes:seconds:">setDays: d hours: h minutes: m seconds: s	"Set the component of the receiver's duration vector that represents its temporal extent in days to the value &lt;d&gt;, and set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds to the value (&lt;h&gt; * 3600) + (&lt;m&gt; * 60) + &lt;s&gt; (and if both days and sub-days are represented by the same vector component, set the value of that component to the sum of the specified day and sub-day extents.) Fail if the receiver is not mutable."	self assertMutability.	days := d.	hours := h.	minutes := m.	seconds := s.</body><body package="Chronos-Duration" selector="setDays:hours:minutes:seconds:nanoseconds:">setDays: d hours: h minutes: m seconds: s nanoseconds: n	"Set the component of the receiver's duration vector that represents its temporal extent in days to the value &lt;d&gt;, and set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds to the value (&lt;h&gt; * 3600) + (&lt;m&gt; * 60) + &lt;s&gt;, and set the component of the receiver's duration vector that represents its temporal extent in nanoseconds to the value &lt;n&gt; (and if both days and sub-days are represented by the same vector component, set the value of that component to the sum of the specified day and sub-day extents.) Fail if the receiver is not mutable."	self assertMutability.	days := d.	hours := h.	minutes := m.	seconds := s.	nanosecondsSinceSecond := n rounded</body><body package="Chronos-Duration" selector="setDays:seconds:nanoseconds:">setDays: d seconds: s nanoseconds: n	"Set the component of the receiver's duration vector that represents its temporal extent in days to the value &lt;d&gt;, set the component of the receiver's duration vector that represents its temporal extent in seconds to the value &lt;s&gt;, and set the component of the receiver's duration vector that represents its temporal extent in nanoseconds to the value &lt;n&gt;. Fail if the receiver is not mutable."	self assertMutability.	days := d.	seconds := s.	nanosecondsSinceSecond := n rounded</body><body package="Chronos-Duration" selector="setHours:">setHours: h	"Set the component of the receiver's duration vector that represents its temporal extent in hours to the value &lt;h&gt;. Fail if the receiver is not mutable."	self assertMutability.	hours := h</body><body package="Chronos-Duration" selector="setHours:minutes:seconds:">setHours: h minutes: m seconds: s 	"Set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds. Fail if the receiver is not mutable."	self assertMutability.	hours := h.	minutes := m.	seconds := s.</body><body package="Chronos-Duration" selector="setHours:minutes:seconds:nanoseconds:">setHours: h minutes: m seconds: s nanoseconds: n	"Set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds. Fail if the receiver is not mutable."	self assertMutability.	hours := h.	minutes := m.	seconds := s.	nanosecondsSinceSecond := n rounded</body><body package="Chronos-Duration" selector="setMinutes:">setMinutes: m	"Set the component of the receiver's duration vector that represents its temporal extent in minutes to the value &lt;m&gt;. Fail if the receiver is not mutable."	self assertMutability.	minutes := m</body><body package="Chronos-Duration" selector="setNanoseconds:">setNanoseconds: n	"Set the component of the receiver's duration vector that represents its temporal extent in nanoseconds to the value &lt;n&gt;. Fail if the receiver is not mutable."	self assertMutability.	nanosecondsSinceSecond := n rounded</body><body package="Chronos-Duration" selector="setSeconds:">setSeconds: s	"Set the component of the receiver's duration vector that represents its temporal extent in seconds to the value &lt;s&gt;. Fail if the receiver is not mutable."	self assertMutability.	seconds := s.</body><body package="Chronos-Duration" selector="setSeconds:nanoseconds:">setSeconds: s nanoseconds: n	"Set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;s&gt; seconds and &lt;n&gt; nanoseconds. Fail if the receiver is not mutable."	self assertMutability.	seconds := s.	nanosecondsSinceSecond := n rounded</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>private-arithmetic</category><body package="Chronos-Duration" selector="addedToCalendarDuration:">addedToCalendarDuration: aCalendarDuration 	^self nonCalendarPeriodsAreZero 		ifTrue: 			[aCalendarDuration 				addingYears: years				months: months				days: days]		ifFalse: 			[aCalendarDuration 				addingYears: years				months: months				days: days				hours: hours				minutes: minutes				seconds: seconds				nanoseconds: nanosecondsSinceSecond]</body><body package="Chronos-Duration" selector="addedToCivilDuration:">addedToCivilDuration: aCivilDuration 	^aCivilDuration 		addingYears: years		months: months		days: days		hours: hours		minutes: minutes		seconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="addedToDuration:">addedToDuration: aDuration 	^self calendarPeriodsAreZero 		ifTrue: [aDuration addingHours: hours minutes: minutes seconds: seconds nanoseconds: nanosecondsSinceSecond]		ifFalse: 			[self class 				years: years				months: months				days: days				seconds: aDuration asSeconds + seconds				nanoseconds: aDuration nanosecondsSinceSecond + nanosecondsSinceSecond]</body><body package="Chronos-Duration" selector="addedToTemporalInterval:">addedToTemporalInterval: aTemporalInterval 	^aTemporalInterval 		addingYears: years		months: months		days: days		hours: hours		minutes: minutes		seconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="subtractedFromCalendarDuration:">subtractedFromCalendarDuration: aCalendarDuration 	^self nonCalendarPeriodsAreZero 		ifTrue: 			[aCalendarDuration 				subtractingYears: years				months: months				days: days]		ifFalse: 			[aCalendarDuration 				subtractingYears: years				months: months				days: days				hours: hours				minutes: minutes				seconds: seconds				nanoseconds: nanosecondsSinceSecond]</body><body package="Chronos-Duration" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aCivilDuration 	^aCivilDuration 		subtractingYears: years		months: months		days: days		hours: hours		minutes: minutes		seconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="subtractedFromDuration:">subtractedFromDuration: aDuration 	^self calendarPeriodsAreZero 		ifTrue: [aDuration subtractingHours: hours minutes: minutes seconds: seconds nanoseconds: nanosecondsSinceSecond]		ifFalse: 			[self class 				years: years negated				months: months negated				days: days negated				seconds: aDuration asSeconds - seconds				nanoseconds: aDuration nanosecondsSinceSecond - nanosecondsSinceSecond]</body><body package="Chronos-Duration" selector="subtractedFromTemporalInterval:">subtractedFromTemporalInterval: aTemporalInterval 	^aTemporalInterval 		subtractingYears: years		months: months		days: days		hours: hours		minutes: minutes		seconds: seconds		nanoseconds: nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>comparing</category><body package="Chronos-Duration" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	self == aMagnitude ifTrue: [^true].	^[aMagnitude isEqualToCivilDuration: self]		on: MessageNotUnderstood		do: [:ex | 			(ex receiver == aMagnitude and: [ex message selector == #isEqualToCivilDuration:])				ifTrue: [ex return: false]				ifFalse: [ex pass]]</body><body package="Chronos-Duration" selector="hash">hash	^super hash + (hours + minutes + seconds + nanosecondsSinceSecond) hash</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>testing</category><body package="Chronos-Duration" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^self nonCalendarPeriodsAreZero and: [super isDayDuration]</body><body package="Chronos-Duration" selector="isHourDuration">isHourDuration	"Answer whether the receiver's temporal extent is one hour."	^hours = 1 and: [self calendarPeriodsAreZero and: [minutes = 0 and: [seconds = 0 and: [self subsecondsAreZero]]]]</body><body package="Chronos-Duration" selector="isMinuteDuration">isMinuteDuration	"Answer whether the receiver's temporal extent is one minute."	^minutes = 1 and: [self calendarPeriodsAreZero and: [hours = 0 and: [seconds = 0 and: [self subsecondsAreZero]]]]</body><body package="Chronos-Duration" selector="isMonthDuration">isMonthDuration	"Answer whether the receiver's temporal extent is one month."	^self nonCalendarPeriodsAreZero and: [super isMonthDuration]</body><body package="Chronos-Duration" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^nanosecondsSinceSecond = 1 and: [self calendarPeriodsAreZero]</body><body package="Chronos-Duration" selector="isSecondDuration">isSecondDuration	"Answer whether the receiver's temporal extent is one second."	^seconds = 1 and: [self calendarPeriodsAreZero and: [hours = 0 and: [minutes = 0 and: [self subsecondsAreZero]]]]</body><body package="Chronos-Duration" selector="isYearDuration">isYearDuration	"Answer whether the receiver's temporal extent is one year."	^self nonCalendarPeriodsAreZero and: [super isYearDuration]</body><body package="Chronos-Duration" selector="nonCalendarPeriodsAreZero">nonCalendarPeriodsAreZero	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is zero."	^hours isZero and: [minutes isZero and: [seconds isZero and: [nanosecondsSinceSecond isZero]]]</body><body package="Chronos-Duration" selector="nonCalendarPeriodsPositive">nonCalendarPeriodsPositive	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is positive."	hours &gt; 0 ifTrue: [^true].	hours &lt; 0 ifTrue: [^false].	minutes &gt; 0 ifTrue: [^true].	minutes &lt; 0 ifTrue: [^false].	seconds &gt; 0 ifTrue: [^true].	seconds &lt; 0 ifTrue: [^false].	^nanosecondsSinceSecond positive</body><body package="Chronos-Duration" selector="subsecondsAreZero">subsecondsAreZero	"Answer whether the sub-second temporal extent (seconds/nanoseconds) of the receiver is zero."	^nanosecondsSinceSecond = 0</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>arithmetic</category><body package="Chronos-Duration" selector="*">* aNumber	"{(CivilDuration years: 1 months: 1 days:1 hours: 7 minutes: 16 seconds: 16) * 4}"	aNumber = 1 ifTrue: [^self].	^self copy		setYears: years * aNumber months: months * aNumber;		setDays: days * aNumber hours: hours * aNumber minutes: minutes * aNumber seconds: seconds * aNumber nanoseconds: nanosecondsSinceSecond * aNumber;		beImmutable</body><body package="Chronos-Duration" selector="+">+ aDurationOrTemporalCoordinate	"{((CivialDuration years: 1 months: -3 days: 5) + (CivialDuration days: 7 hours: 4 minutes: 0 seconds: 52))}"	"{(CivialDuration days: 7 hours: 4 minutes: 0 seconds: 52) - YearMonthDay today}"	^aDurationOrTemporalCoordinate addedToCivilDuration: self</body><body package="Chronos-Duration" selector="-">- aDurationOrTemporalCoordinate	"{((CivilDuration years: 1 months: -3 days: 5) - (CivilDuration years: 2 months: -7 days: 7 hours: 4 minutes: 0 seconds: 52))}"	"{(CivilDuration days: 7 hours: 4 minutes: 0 seconds: 52) - YearMonthDay today}"	^aDurationOrTemporalCoordinate subtractedFromCivilDuration: self</body><body package="Chronos-Duration" selector="/">/ aNumber	"{(CivilDuration years: 4 months: 8 days:16) / 4}"	aNumber = 1 ifTrue: [^self].	^self copy 		setYears: years // aNumber months: months // aNumber;		setFractionalSeconds: self asFractionalSeconds / aNumber;		beImmutable</body></methods><methods><class-id>Chronos.CivilDuration</class-id> <category>private-comparing</category><body package="Chronos-Duration" selector="isEqualToCalendarDuration:">isEqualToCalendarDuration: aCalendarDuration	^self nonCalendarPeriodsAreZero and: [super isEqualToCalendarDuration: aCalendarDuration]</body><body package="Chronos-Duration" selector="isEqualToCivilDuration:">isEqualToCivilDuration: aCivilDuration 	(super isEqualToCalendarDuration: aCivilDuration) ifFalse: [^false].	^hours = aCivilDuration hours and: 			[minutes = aCivilDuration minutes and: 					[seconds = aCivilDuration seconds 						and: [nanosecondsSinceSecond = aCivilDuration nanosecondsSinceSecond]]]</body></methods><methods><class-id>Chronos.CivilDuration class</class-id> <category>instance creation</category><body package="Chronos-Duration" selector="days:hours:minutes:seconds:">days: d hours: h minutes: m seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;d&gt; days, &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds."	"Specified and required by the ANSI-Smalltalk Standard."	"{Timepoint now + (ScientificDuration days: 182 hours: 24 minutes: 10 seconds: -59)}"	"{Timepoint now + (CivilDuration days: 182 hours: 24 minutes: 10 seconds: -59)}"	^self new		setDays: d hours: h minutes: m seconds: s;		beImmutable</body><body package="Chronos-Duration" selector="days:hours:minutes:seconds:nanoseconds:">days: d hours: h minutes: m seconds: s nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;d&gt; days, &lt;h&gt; hours, &lt;m&gt; minutes, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{Timepoint now + (ScientificDuration days: 182 hours: 24 minutes: 10 seconds: -59 nanoseconds: -1)}"	"{Timepoint now + (CivilDuration days: 182 hours: 24 minutes: 10 seconds: -59 nanoseconds: -1)}"	^self new		setDays: d hours: h minutes: m seconds: s nanoseconds: n;		beImmutable</body><body package="Chronos-Duration" selector="hours:">hours: h	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours."	"{(CivilDuration hours: -8) asTimezone}"	^self new		setHours: h;		beImmutable</body><body package="Chronos-Duration" selector="hours:minutes:seconds:">hours: h minutes: m seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds."	"{CivilDuration hours: 1.5 minutes: 1.5 seconds: 1.5}"	^self new		setHours: h minutes: m seconds: s;		beImmutable</body><body package="Chronos-Duration" selector="hours:minutes:seconds:nanoseconds:">hours: h minutes: m seconds: s nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours, &lt;m&gt; minutes, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{CivilDuration hours: 1.5 minutes: 1.5 seconds: 1.5}"	^self new		setHours: h minutes: m seconds: s nanoseconds: n;		beImmutable</body><body package="Chronos-Duration" selector="microseconds:">microseconds: microseconds	"Answer an immutable durational value representing a temporal extent of &lt;microseconds&gt; microseconds."	"{CivilDuration microseconds: 1.5}"	"{(CivilDuration microseconds: (AnsiStandardCalendarClock now microsecondsSinceEpoch)) asDateAndTime}"	^microseconds isInteger		ifTrue: [self nanoseconds: ((microseconds * 125) bitShift: 3)]		ifFalse: [self seconds: microseconds / MicrosecondsPerSecond]</body><body package="Chronos-Duration" selector="milliseconds:">milliseconds: milliseconds	"Answer an immutable durational value representing a temporal extent of &lt;milliseconds&gt; milliseconds."	"{CivilDuration milliseconds: 1.5}"	"{(CivilDuration milliseconds: (AnsiStandardCalendarClock now millisecondsSinceEpoch)) asDateAndTime}"	^milliseconds isInteger		ifTrue: [self nanoseconds: ((milliseconds * 15625) bitShift: 6)]		ifFalse: [self seconds: milliseconds / MillisecondsPerSecond]</body><body package="Chronos-Duration" selector="minutes:">minutes: m	"Answer an immutable durational value representing a temporal extent of &lt;m&gt; minutes."	"{CivilDuration minutes: 1.5}"	^self new		setMinutes: m;		beImmutable</body><body package="Chronos-Duration" selector="nanoseconds:">nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;n&gt; nanoseconds."	"{CivilDuration nanoseconds: -1000000001}"	"{CivilDuration seconds: -1 nanoseconds: 1}"	"{(CivilDuration nanoseconds: (AnsiStandardCalendarClock now nanosecondsSinceEpoch))}"	^self new		setNanoseconds: n;		beImmutable</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextCivilDurationFrom: stream usingFactory: self</body><body package="Chronos-Duration" selector="seconds:">seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;s&gt; seconds."	"Specified and required by the ANSI-Smalltalk Standard."	"{CivilDuration seconds: SecondsPerDay negated + 1}"	"{(CivilDuration seconds: (AnsiStandardCalendarClock now fractionalSecondsSinceEpoch))}"	^self new		setSeconds: s;		beImmutable</body><body package="Chronos-Duration" selector="seconds:nanoseconds:">seconds: s nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{CivilDuration seconds: 1 nanoseconds: 1}"	"{CivilDuration seconds: 1 nanoseconds: -1}"	"{CivilDuration seconds: -1 nanoseconds: 1}"	"{CivilDuration seconds: -1 nanoseconds: -1}"	^self new		setSeconds: s nanoseconds: n;		beImmutable</body><body package="Chronos-Duration" selector="years:months:days:hours:minutes:seconds:">years: y months: months days: d hours: h minutes: minutes seconds: s	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years, &lt;months&gt; months, &lt;d&gt; days, &lt;h&gt; hours &lt;minutes&gt; minutes and &lt;s&gt; seconds."	"{Timepoint now + (CivilDuration years: 1 months: 1 days: 1 hours: 1 minutes: 1 seconds: 1)}"	"{Timepoint now + (CivilDuration years: 1 months: -1 days: 1 hours: -1 minutes: 1 seconds: -1)}"	^self new		setYears: y months: months;		setDays: d hours: h minutes: minutes seconds: s;		beImmutable</body><body package="Chronos-Duration" selector="years:months:days:hours:minutes:seconds:nanoseconds:">years: y months: months days: d hours: h minutes: minutes seconds: s nanoseconds: n	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years, &lt;months&gt; months, &lt;d&gt; days, &lt;h&gt; hours &lt;minutes&gt; minutes, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{Timepoint now + (CivilDuration years: 1 months: 1 days: 1 hours: 1 minutes: 1 seconds: 1 nanoseconds: 1000000001)}"	"{Timepoint now + (CivilDuration years: -1 months: 1 days: -1 hours: 1 minutes: -1 seconds: 1 nanoseconds: -1000000001)}"	^self new		setYears: y months: months;		setDays: d hours: h minutes: minutes seconds: s nanoseconds: n;		beImmutable</body><body package="Chronos-Duration" selector="years:months:days:seconds:nanoseconds:">years: y months: months days: d seconds: s nanoseconds: n	"Answer an immutable CalendarDuration representing a temporal extent of &lt;y&gt; years, &lt;months&gt; months, &lt;d&gt; days, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{Timepoint now + (CivilDuration years: -1 months: 6 days: 6 seconds: 6 nanoseconds: 1000000001)}"	"{Timepoint now + (CivilDuration years: 1 months: -6 days: 6 seconds: -6 nanoseconds: 1000000001)}"	^self new		setYears: y months: months;		setDays: d seconds: s nanoseconds: n;		beImmutable</body></methods><methods><class-id>Chronos.VWv5iSystemFacade</class-id> <category>instance creation</category><body package="Chronos-System-VW" selector="newDelayFromDuration:">newDelayFromDuration: aDuration	^Delay forMilliseconds: aDuration asMilliseconds</body><body package="Chronos-System-VW" selector="newSystemClock">newSystemClock	^VWClassicSystemClock new</body></methods><methods><class-id>Chronos.VWv5iSystemFacade</class-id> <category>private-system timezone</category><body package="Chronos-System-VW" selector="dayOfWeekKeyFromVWTimeZone:">dayOfWeekKeyFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 6</body><body package="Chronos-System-VW" selector="dstDeltaSecondsFromVWTimeZone:">dstDeltaSecondsFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 5</body><body package="Chronos-System-VW" selector="initializeVWTimeZone:toStdTimeOffset:dstDelta:firstTransitionHourOfDay:secondTransitionHourOfDay:firstTransitionMaxDayOfYearOrdinal:secondTransitionMaxDayOfYearOrdinal:dayOfWeekKey:">initializeVWTimeZone: key toStdTimeOffset: stdTimeOffsetHoursFromUT dstDelta: dstOffsetHours firstTransitionHourOfDay: firstTransitionHourOfDay secondTransitionHourOfDay: secondTransitionHourOfDay firstTransitionMaxDayOfYearOrdinal: firstTransitionMaxDayOfYearOrdinal secondTransitionMaxDayOfYearOrdinal: secondTransitionMaxDayOfYearOrdinal dayOfWeekKey: dayOfWeekKey	TimeZone setDefaultTimeZone: 		(TimeZone 			timeDifference: stdTimeOffsetHoursFromUT			DST: dstOffsetHours at: firstTransitionHourOfDay			from: firstTransitionMaxDayOfYearOrdinal			to: secondTransitionMaxDayOfYearOrdinal			startDay: dayOfWeekKey)</body><body package="Chronos-System-VW" selector="secondsSinceStartOfDayAtSecondOffsetTansitionFromVWTimeZone:">secondsSinceStartOfDayAtSecondOffsetTansitionFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 4</body></methods><methods><class-id>Chronos.VWClassicSystemFacade</class-id> <category>private-system timezone</category><body package="Chronos-System-VW" selector="stdTimeOffsetSecondsFromVWTimeZone:">stdTimeOffsetSecondsFromVWTimeZone: aVWTimeZone	^aVWTimeZone instVarAt: 1</body></methods><methods><class-id>Chronos.VWv7xSystemClock</class-id> <category>calendar clock binding</category><body package="Chronos-System-VW" selector="secondsFromGregorianEpochUpToSystemClockEpoch">secondsFromGregorianEpochUpToSystemClockEpoch	"Answer the number of seconds from the Epoch date/time of the Proleptic Gregorian Calendar (i.e., January 1, 1 AD  00:00:00 Proleptic Gregorian) up to the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0).  For most Smalltallk implementations, the platform system clock is a software device provided by the virtual machine.  On most operating systems, the system clock's zero point will be 00:00:00 UT of the first day of some Gregorian year.  However, some platforms (e.g., Microsoft Windows) use a zero point that is 00:00:00 (midnight) LOCAL TIME.  Do not adjust the encapsulated clock's tick count from UT to local time, nor from local time to UT.  If the encapsulated clock reports ticks relative to UT, then #secondsFromGregorianEpochUpToSystemClockEpoch should answer the number of seconds since midnight UT of the clock's epoch date, and the instance method #isRelativeToUT should answer true. However, if the encapsulated clock reports ticks relative to local time, then #secondsFromGregorianEpochUpToSystemClockEpoch should answer the number of seconds since midnight local time of the clock's epoch date, and the instance method #isRelativeToUT should answer false.	See the comment for the same method in ChronosSystemClock for help in porting to other systems, or for help in converting to/from foreign system clocks."	"^Calendar gregorian secondsSinceEpochUpToYear: 1901" ^59958144000</body></methods><methods><class-id>Chronos.VWv7xSystemClock</class-id> <category>API-timing</category><body package="Chronos-System-VW" selector="ticksNowSinceSystemClockEpoch">ticksNowSinceSystemClockEpoch	"Answer the number of clock ticks since the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0)) up to the current moment. Do not adjust for timezone offset, just answer the raw value provided by the platform system clock (for many Smalltallk implementations, the platform system clock is a software device provided by the virtual machine, and can be accessed via primtive message send.)"		"{| clock |	clock := VWv7xSystemClock new.	DateAndTimeFactory		utSecondsSinceEpoch: (clock secondsFromGregorianEpochUpToSystemClockEpoch + (clock secondsFromTicks: clock ticksNowSinceSystemClockEpoch))		timeZone: Timezone default}" 	&lt;primitive: 351 errorCode: _ec&gt;	^self primitiveFailed	"^Time microsecondClock - (Duration hours: 8) asMicroseconds" "Fantasy time can be useful for testing/debugging"</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isBound">isBound	"Answer whether the receiver is a bound time zone. A bound time zone is one that defines a single offset/abbreviation tuple, and that conforms to the `BOUND TIMEZONE API` (as defined in the class comment of ChronosTimezone.)"	^false</body><body package="Chronos-TimeZones" selector="keyIsGlobal">keyIsGlobal	"Answer whether the receiver's identifying key is a globally well-known value."	^key notNil and: [self namespaceKey ~~ #nonGlobal]</body><body package="Chronos-TimeZones" selector="specifiesAbbreviation">specifiesAbbreviation	^self specifiesCommonAbbreviation or: [(ChronosLocale default abbreviationAtSemanticKey: self key ifAbsent: [nil]) ~~ nil]</body><body package="Chronos-TimeZones" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^self policy specifiesCommonAbbreviation</body><body package="Chronos-TimeZones" selector="specifiesDefaultName">specifiesDefaultName	^self policy specifiesDefaultName</body><body package="Chronos-TimeZones" selector="specifiesGeographicCoordinates">specifiesGeographicCoordinates	^self policy specifiesGeographicCoordinates</body><body package="Chronos-TimeZones" selector="specifiesName">specifiesName	^self specifiesDefaultName or: [(ChronosLocale default properNameAtSemanticKey: self key ifAbsent: [nil]) ~~ nil]</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="beUniversal">beUniversal	self assertMutability.	self setNamespaceKey: #canonicalRepository key: ChronosTimezone universal key policy: nil.</body><body package="Chronos-TimeZones" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	policy == nil		ifTrue: [self bindPolicy]		ifFalse: [policy := policy asImmutable].	self register</body><body package="Chronos-TimeZones" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	namespaceKey := #nonGlobal.	key := #system.</body><body package="Chronos-TimeZones" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	| keyOrFactory nsKey policyFactory |	keyOrFactory := literalArray at: 2.	nsKey := literalArray at: 3.	keyOrFactory isSymbol 		ifTrue: [self setNamespaceKey: nsKey key: keyOrFactory]		ifFalse: 			[policyFactory := keyOrFactory decodeAsLiteralArray.			self setNamespaceKey: nsKey key: policyFactory key.			policy := policyFactory asPolicyFor: self]</body><body package="Chronos-TimeZones" selector="invalidatePolicy">invalidatePolicy	self keyIsGlobal 		ifTrue: 			[policy release.			policy := nil]</body><body package="Chronos-TimeZones" selector="register">register	| old |	old := self class registry at: key ifAbsentPut: [self].	old == self 		ifFalse: 			["The only obvious reason it should ever be necessary to register one VariableOffsetTimezone in place of another is because their classes are different (and so have different behavior.)  However, the invariant that there is only one VariableOffsetTimezone instance with a given key must be maintained."			self class registry at: key put: self.			DateAndTimeFactory invalidateTimezones]</body><body package="Chronos-TimeZones" selector="release">release	super release.	Registry == nil ifFalse: [Registry removeKey: self key ifAbsent: []].	self invalidatePolicy</body><body package="Chronos-TimeZones" selector="setNamespaceKey:">setNamespaceKey: aTZNamespaceKey	self assertMutability.	namespaceKey := aTZNamespaceKey == nil ifFalse: [aTZNamespaceKey asSymbol].</body><body package="Chronos-TimeZones" selector="setNamespaceKey:key:">setNamespaceKey: aTZNamespaceKey key: aTimeZoneKey 	| tzKey |	self setNamespaceKey: aTZNamespaceKey.	tzKey := aTimeZoneKey asSymbol.	(#(#alwaysSystem #alwaysDefault #nominal) includes: tzKey) 		ifTrue: [self signalError: 'The key ', tzKey printString, ' is not legal for a ', self class name, '.'].	key := tzKey</body><body package="Chronos-TimeZones" selector="setNamespaceKey:key:policy:">setNamespaceKey: aTZNamespaceKey key: aKey policy: aPolicy	self setNamespaceKey: aTZNamespaceKey key: aKey.	policy := aPolicy.</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="aliasingKeys">aliasingKeys	^self policy aliasingKeys</body><body package="Chronos-TimeZones" selector="canonicalKey">canonicalKey	^self policy registrationKey</body><body package="Chronos-TimeZones" selector="defaultAnnualPolicy">defaultAnnualPolicy	"Answer the AnnuallyRecurringTZPolicy that specifies the time zone rules that are in effect during the current year."	^(self policy effectiveRuleInYear: AnsiStandardCalendarClock thisYear ifNone: [self policy ]) annualPolicy</body><body package="Chronos-TimeZones" selector="geographicCoordinates">geographicCoordinates	^self policy geographicCoordinates</body><body package="Chronos-TimeZones" selector="key">key	"Answer the key that identifies the receiver."	^key</body><body package="Chronos-TimeZones" selector="name">name	^self nameIfNone: [self key]</body><body package="Chronos-TimeZones" selector="nameIfNone:">nameIfNone: noneBlock 	| defaultName |	defaultName := key == #system ifTrue: [self defaultNameIfNone: []].	^defaultName == nil 		ifTrue: 			[ChronosLocale default properNameAtSemanticKey: self key				ifAbsent: [self defaultNameIfNone: noneBlock]]		ifFalse: [defaultName]</body><body package="Chronos-TimeZones" selector="namespaceKey">namespaceKey	namespaceKey == nil ifTrue: [self invalidateNamespaceKey].	^namespaceKey</body><body package="Chronos-TimeZones" selector="policy">policy	"Answer the TimeZonePolicy that specifies the ruleset of the time zone represented by the instance.  The ruleset of a time zone specifies for all time values, from the infinite past to the infinite future, the (possibly varying) time zone offsets and abbreviations that apply to points-in-time within the territorial domain of the time zone. Note, however, that the `policy` (time zone ruleset) can be changed retroactively--and this is rather likely to happen for times in the future (but can also happen to times in the past.)"	policy == nil ifTrue: [self bindPolicy].	^policy</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>private</category><body package="Chronos-TimeZones" selector="bindPolicy">bindPolicy	policy := self resolvePolicy.	policy == nil ifTrue: [^self].	policy := policy asImmutable</body><body package="Chronos-TimeZones" selector="defaultName">defaultName	^self defaultNameIfNone: [self key]</body><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneBlock 	^self policy specifiesDefaultName 		ifTrue: [self policy defaultName]		ifFalse: [noneBlock value]</body><body package="Chronos-TimeZones" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut: self namespaceKey</body><body package="Chronos-TimeZones" selector="invalidateNamespaceKey">invalidateNamespaceKey	namespaceKey == nil 		ifTrue: 			[(key ~~ #system 				and: [TimeZonePolicyFactory timezoneKeyIsGloballyDefined: key]) 					ifTrue: [namespaceKey := #canonicalRepository]					ifFalse: [namespaceKey := #nonGlobal]]</body><body package="Chronos-TimeZones" selector="keyIsAlias">keyIsAlias	^self key ~~ self policy registrationKey</body><body package="Chronos-TimeZones" selector="literalArrayEncodingOfKey">literalArrayEncodingOfKey	^self keyIsGlobal 		ifTrue: [self key]		ifFalse: [self policy asPolicyFactory literalArrayEncoding]</body><body package="Chronos-TimeZones" selector="policyClass">policyClass	^TimeZonePolicy</body><body package="Chronos-TimeZones" selector="resolvePolicy">resolvePolicy	self keyIsGlobal ifFalse: [^policy].	^self policyClass 		for: self		ifNone: 			[policy == nil 				ifTrue: [self class signalInaccessibleTimeZonePolicyAt: key]				ifFalse: [policy]]</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>queries</category><body package="Chronos-TimeZones" selector="annualPolicyForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in local time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UTC for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day in local time (without any need to consider standard versus daylight saving time.)"	^self policy		searchBackwardForAnnualPolicyAtLocalYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones" selector="annualPolicyForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">annualPolicyForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"On the date specified in Universal Time, answer the annually-recurring time zone policy then in effect (i.e, the one whose bound time zone answers the correct value for the specified date in response to the message #offsetFromUT).	If it is necessary for the receiver to also know the time-of-day in order to determine the correct annual policy, the receiver will invoke the secondsSinceStartOfDayFunction (a BlockClosure) in order to resolve the seconds-since-start-day to be used in determining the timezone binding. If required, the secondsSinceStartOfDayFunction callback will be invoked with a single argument, which will be the offset seconds from UT for local standard time--if necessary, the sender should use this value to compute the answered seconds-since-start-day as UT (without any need to consider standard versus daylight saving time.)"	^self policy 		searchBackwardForAnnualPolicyAtUTYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones" selector="bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in the local time defined by the receiver.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in local (`wall clock`) time as defined by the receiver."	^(self 		annualPolicyForLocalYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) binding</body><body package="Chronos-TimeZones" selector="bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in Universal Time.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in Universal Time."	^(self 		annualPolicyForUTYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction) binding</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>private-comparing</category><body package="Chronos-TimeZones" selector="isEqualToTimezone:">isEqualToTimezone: aTimezone 	^(self keyIsGlobal 		and: [aTimezone keyIsGlobal])		ifTrue: [key == aTimezone key]		ifFalse: [self == aTimezone]</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="canonical">canonical	"Answer the canonical instance of the receiver's class whose value is equivalent to that of the receiver's."	^self class registry at: key		ifAbsent: 			[self				invalidatePolicy;				register]</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processVariableOffsetTimezone: self</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>printing</category><body package="Chronos-TimeZones" selector="printPolicyOn:">printPolicyOn: stream 	stream 		cr; tab;		nextPutAll: 'policy=';		cr; tab; tab.	self policy printOn: stream</body></methods><methods><class-id>Chronos.VariableOffsetTimezone</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="convertGMT:do:">convertGMT: utSecondsSinceST80Epoch do: block2 	"[1000000 timesRepeat: [ChronosTimezone default convertGMT: Time secondClock do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun"	"[1000000 timesRepeat: [TimeZone default convertGMT: Time secondClock do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun"	"(Timezone at: 'America/Los_Angeles') convertGMT: Time secondClock do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]"	"(Timezone at: 'Australia/Adelaide') convertGMT: Time secondClock do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]"	^ChronosFunction 		daysAndSecondsSinceStartOfDayFromSeconds: utSecondsSinceST80Epoch		into: [:daysSinceEpoch :secondsSinceStartOfDay | 				| dateSpec boundTZ seconds date | 				dateSpec := Gregorian dateSpecFromDaysSinceEpoch: daysSinceEpoch + 693960.				boundTZ := self bindingForUTYear: dateSpec year dayOfYear: dateSpec dayOfYear secondsSinceStartOfDayFunction: [:offsetSecondsFromUT | secondsSinceStartOfDay].				seconds := secondsSinceStartOfDay + boundTZ offsetSecondsFromUT.				date :=					seconds &lt; 0						ifTrue: 							[seconds := seconds + SecondsPerDay.							dateSpec addingDays: -1 setYearAndCalendarDayInto: [:y :cd | Date newDay: cd dayOfYear year: y]]						ifFalse: 							[seconds &gt;= SecondsPerDay								ifTrue: 									[seconds := seconds - SecondsPerDay.									dateSpec addingDays: 1 setYearAndCalendarDayInto: [:y :cd | Date newDay: cd dayOfYear year: y]]								ifFalse: [Date newDay: dateSpec dayOfYear year: dateSpec year]].				block2 value: date value: seconds]</body><body package="Chronos-ST80 (and VW) Compatibility" selector="convertToGMT:do:">convertToGMT: localSecondsSinceST80Epoch do: block2	"[1000000 timesRepeat: [ChronosTimezone default convertToGMT: Timepoint now asSeconds do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun"	"[1000000 timesRepeat: [TimeZone default convertToGMT: Timestamp now asSeconds do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]]] durationToRun"	"(Timezone at: 'America/Los_Angeles') convertToGMT: Timepoint now asSeconds do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]"	"(Timezone at: 'Australia/Adelaide') convertToGMT: Timepoint now asSeconds do: [:date :seconds | Array with: date with: (Time fromSeconds: seconds)]"	^ChronosFunction 		daysAndSecondsSinceStartOfDayFromSeconds: localSecondsSinceST80Epoch		into: [:daysSinceEpoch :secondsSinceStartOfDay | 				| dateSpec boundTZ seconds date | 				dateSpec := Gregorian dateSpecFromDaysSinceEpoch: daysSinceEpoch + 693960.				boundTZ := self bindingForLocalYear: dateSpec year dayOfYear: dateSpec dayOfYear secondsSinceStartOfDayFunction: [:offsetSecondsFromUT | secondsSinceStartOfDay].				seconds := secondsSinceStartOfDay - boundTZ offsetSecondsFromUT.				date :=					seconds &lt; 0						ifTrue: 							[seconds := seconds + SecondsPerDay.							dateSpec addingDays: -1 setYearAndCalendarDayInto: [:y :cd | Date newDay: cd dayOfYear year: y]]						ifFalse: 							[seconds &gt;= SecondsPerDay								ifTrue: 									[seconds := seconds - SecondsPerDay.									dateSpec addingDays: 1 setYearAndCalendarDayInto: [:y :cd | Date newDay: cd dayOfYear year: y]]								ifFalse: [Date newDay: dateSpec dayOfYear year: dateSpec year]].				block2 value: date value: seconds]</body></methods><methods><class-id>Chronos.VariableOffsetTimezone class</class-id> <category>class initialization</category><body package="Chronos-TimeZones" selector="initialize">initialize	"VariableOffsetTimezone initialize."	Registry := nil</body><body package="Chronos-TimeZones" selector="invalidate">invalidate	"VariableOffsetTimezone invalidate."	Registry == nil 		ifFalse: 			[Registry values do: [:each | each == nil ifFalse: [each invalidatePolicy]]].	self invalidateTimezonePolicies.	self setRegistry.</body><body package="Chronos-TimeZones" selector="invalidateTimezonePolicies">invalidateTimezonePolicies	"Update the TimeZonePolicies of all non-transient instances of the receiver from the persistent specifications of their rulesets stored in the external Chronos time-zones repository."	"VariableOffsetTimezone invalidateTimezonePolicies"	self invalidateOffsetFlyweights.	self invalidateBoundDynamicFlyweights.	self allInstancesDo: [:each | each invalidatePolicy].</body></methods><methods><class-id>Chronos.VariableOffsetTimezone class</class-id> <category>private</category><body package="Chronos-TimeZones" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	| keyOrSpec |	keyOrSpec := literalArray at: 2.	^keyOrSpec isString 		ifTrue: [self at: keyOrSpec]		ifFalse: 			[(self new)				initializeFromLiteralArray: literalArray;				beImmutable]</body><body package="Chronos-TimeZones" selector="initializeRegistry">initializeRegistry	"VariableOffsetTimezone initializeRegistry"	Registry := EnvironmentFacade current newWeakDictionary.</body><body package="Chronos-TimeZones" selector="registry">registry	"VariableOffsetTimezone registry"	Registry == nil ifTrue: [self setRegistry].	^Registry</body><body package="Chronos-TimeZones" selector="setRegistry">setRegistry	"VariableOffsetTimezone setRegistry"	Registry == nil ifTrue: [self initializeRegistry].	Registry		at: NominalTime registrationKey put: ChronosTimezone nominal;		at: AlwaysSystemTZ registrationKey put: ChronosTimezone alwaysSystem;		at: AlwaysDefaultTZ registrationKey put: ChronosTimezone alwaysDefault;		at: #'Universal Time' put: ChronosTimezone universal; 	"Formally-correct identifying key of the international standard reference zero-offset timezone"		at: #Universal put: ChronosTimezone universal; 			"An alias for 'Universal Time' used by the Olson Timezone Database."		at: #UT put: ChronosTimezone universal;					"Formally-correct abbreviation for the Universal Time timzone"		at: #Z put: ChronosTimezone universal;						"ISO 8601 abbreviation for the Universal Time timzone"		at: #z put: ChronosTimezone universal;						"Alternate ISO 8601 abbreviation for the Universal Time timzone"		at: #Zulu put: ChronosTimezone universal;					"Military standard identifier for the Universal Time timzone"		at: #GMT put: ChronosTimezone universal; 				"Technically wrong since 1928, but it's still widely used as a synonym for UT.																				Note, however, that GMT is also the abbreviation for a variety of timezones in the																				vicinity of the Prime Meridian (e.g., Britain, West Africa) whose offset from UTC is 0 seconds 																				in the winter, but +3600 seconds in the summer."		at: #UTC put: ChronosTimezone universal					"UTC is quite commonly misused as the abbreviation of the Universal Time timezone (including by the official specification of the ANSI-Smalltalk Standard,) and also therefore (for consistency with ANSI Smalltalk) by the Chronos Date/Time library"</body><body package="Chronos-TimeZones" selector="signalInaccessibleTimeZonePolicyAt:">signalInaccessibleTimeZonePolicyAt: aTimeZoneKey 	^self 		signalError: 'The resource that defines the ruleset for the ' , self name 				, ' identified by ' , aTimeZoneKey printString 				, ' is not accessible.'</body></methods><methods><class-id>Chronos.VariableOffsetTimezone class</class-id> <category>validation</category><body package="Chronos-TimeZones" selector="assertValidityOfTimezoneKey:">assertValidityOfTimezoneKey: aTimeZoneKey 	"Assert that &lt;aTimeZoneKey&gt; is the key of a time zone persistently stored in the Chronos time-zones repository (to which this execution environment is attached.) If it is, do nothing. If it is not, raise an Exception."	((#(#default #system) includes: aTimeZoneKey) or: [self registry includesKey: aTimeZoneKey])		ifFalse: [TimeZonePolicyFactory assertValidityOfTimezoneKey: aTimeZoneKey]</body></methods><methods><class-id>Chronos.VariableOffsetTimezone class</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="at:">at: aTimeZoneKey 	"Answer the VariableOffsetTimezone whose key is &lt;aChronosTimeZoneKey&gt;.  If there is no VariableOffsetTimezone with the specified key, signal an exception."	"{(VariableOffsetTimezone at: #Universal) now}"	"{(VariableOffsetTimezone at: #'America/New_York') now}"	"{(VariableOffsetTimezone at: #'America/Detroit') now}"	"{(VariableOffsetTimezone at: #alwaysDefault) now}"	"{(VariableOffsetTimezone at: #alwaysSystem) now}"	"{VariableOffsetTimezone at: #NOSUCHKEY}"	^self at: aTimeZoneKey ifAbsent: [self signalInaccessibleTimeZonePolicyAt: aTimeZoneKey]</body><body package="Chronos-TimeZones" selector="at:ifAbsent:">at: aTimeZoneKey ifAbsent: ifAbsentBlock 	"Answer the VariableOffsetTimezone whose key is &lt;aChronosTimeZoneKey&gt;.  If there is no VariableOffsetTimezone with the specified key, answer the result of evaluating &lt;absentAction&gt;."	"{VariableOffsetTimezone at: #Universal ifAbsent: [#NoSuchTimeZone]}"	"{VariableOffsetTimezone at: #system ifAbsent: [#NoSuchTimeZone]}"	"{VariableOffsetTimezone at: #default ifAbsent: [#NoSuchTimeZone]}"	"{VariableOffsetTimezone at: #alwaysSystem ifAbsent: [#NoSuchTimeZone]}"	"{VariableOffsetTimezone at: #alwaysDefault ifAbsent: [#NoSuchTimeZone]}"	"{VariableOffsetTimezone at: #nominal ifAbsent: [#NoSuchTimeZone]}"	"{VariableOffsetTimezone at: #NOSUCHKEY ifAbsent: [#NoSuchTimeZone]}"	| tzKey tz |	tzKey := aTimeZoneKey asSymbol.	tzKey == #system ifTrue: [^self system].	tzKey == #default ifTrue: [^self default].	tz := self registry at: tzKey ifAbsent: [0].	^(tz == nil or: [tz = 0])		ifTrue: 			[[(self new)				setNamespaceKey: #canonicalRepository key: tzKey;				beImmutable] 					on: Error					do: [:ex | ex return: ifAbsentBlock value]]		ifFalse: [tz]</body></methods><methods><class-id>Chronos.VariableOffsetTimezone class</class-id> <category>instance creation</category><body package="Chronos-TimeZones" selector="key:name:initialOffset:withAbbreviation:until:at:relativity:thenOffset:withAbbreviation:until:at:relativity:">key: aKey name: aStringOrSymbol initialOffset: offset1FromUT withAbbreviation: abbreviation1 until: annualTransitionDate1 at: timeOfDay1 relativity: relativity1 thenOffset: offset2FromUT withAbbreviation: abbreviation2 until: annualTransitionDate2 at: timeOfDay2 relativity: relativity2 	"Answer a new VariableOffsetTimezone with one inter-year ruleset consisting of two intra-year offset/abbreviation transitions that repeat annually. The answered instance's single inter-year ruleset with two intra-year annual transitions will apply every year, from the infinite past to the infinite future. The answered instance will have the specfied &lt;key&gt; and &lt;name&gt; (Symbols or Strings; the keys #alwaysSystem, #alwaysDefault and #nominal are not allowed.)  The name may nil, in which case the answered instance's name will be its key.	From the beginning of the year until the first offset/abbreviation transition, the answered instance's offset from UT will be &lt;offset1FromUT&gt; (a Duration) and its abbreviation will be &lt;abbreviation1&gt; (a Symbol.)  The first transtion will occur on &lt;annualTransitionDate1&gt; (an AnnualDate) at &lt;timeOfDay1&gt; (a TimeOfDay).  If &lt;relativity1&gt; == #nominal, then the specified date and time of the first transition reflect local `wall clock` time as defined by the answered instance.   If &lt;relativity1&gt; == #standard, then the specified date and time of the first transition reflect local `standard time` as defined by the answered instance (i.e., without DST.)  If &lt;relativity1&gt; == #universal, then the specified date and time reflect the Universal Time when the first transition occurs.	From the first offset/abbreviation transition until the second offset/abbreviation transition,  the answered instance's offset from UT will be &lt;offset2FromUT&gt; (a Duration) and its abbreviation will be &lt;abbreviation2&gt; (a Symbol.)  The second transtion will occur on &lt;annualTransitionDate2&gt; (an AnnualDate) at &lt;timeOfDay2&gt; (a TimeOfDay).  If &lt;relativity2&gt; == #nominal, then the specified date and time of the second transition reflect local `wall clock` time as defined by the answered instance.   If &lt;relativity2&gt; == #standard, then the specified date and time of the second transition reflect local `standard time`  as defined by the answered instance (i.e., without DST.)  If &lt;relativity2&gt; == #universal, then the specified date and time reflect the Universal Time when the second transition occurs.	After the second offset/abbreviation transition and until the end of the year,  the answered instance's offset from UT will again be &lt;offset1FromUT&gt; (a Duration) and its abbreviation will again be &lt;abbreviation2&gt; (a Symbol.) 	HOWEVER, the parameters may be supplied in inverted order: If &lt;annualTransitionDate1&gt; occurs later in the year than &lt;annualTransitionDate2&gt;, then the role of &lt;offset1FromUT&gt; is swapped with that of &lt;offset2FromUT&gt;, the role of &lt;abbreviation1&gt; is swapped with that of &lt;abbreviation2&gt;, the role of &lt;annualTransitionDate1&gt; is swapped with that of &lt;annualTransitionDate2&gt;, the role of &lt;timeOfDay1&gt; is swapped with that of &lt;timeOfDay2&gt; and the role of &lt;relativity1&gt; is swapped with that of &lt;relativity2&gt;.	NOTE: Although it is of course possible to create a VariableOffsetTimezone with more than one inter-year ruleset, that is best done using factory objects, such as those implemented by TimeZonePolicySequenceFactory, TimeZonePolicyElementFactory and AnnuallyRecurringTZPolicyFactory (and its subclasses.) One may also `open-code` a TimeZonePolicy object graph directly, as is done in the implementation of this method, but that is not recommended in complex cases."	"{(VariableOffsetTimezone		key: #myOwnPrivateTimeZone name: #NorthernHemispereInvertedOrder		initialOffset: (Duration hours: -7) withAbbreviation: #WDT 			until: (WeekOfMonthDayOfWeek month: 11 week: 0 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #nominal		thenOffset: (Duration hours: -8)  withAbbreviation: #WST  			until: (WeekOfMonthDayOfWeek month: 3 week: 1 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #standard) 				nowToTheSecond printStringUsing: #verbose}"	"{(VariableOffsetTimezone		key: #someoneElsesPrivateTimeZone name: #SouthernHemisphereNormalOrder		initialOffset: (Duration hours: 10) withAbbreviation: #WADT 			until: (WeekOfMonthDayOfWeek month: 4 week: 0 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #universal		thenOffset: (Duration hours: 9)  withAbbreviation: #WAST  			until: (WeekOfMonthDayOfWeek month: 9 week: 1 dayOfWeek: Sunday) at: (TimeOfDay hour: 2 minute: 0 second: 0) relativity: #universal)				nowToTheSecond literalArrayEncoding decodeAsLiteralArray printStringUsing: #verbose}"	| instance policy minOffset annualPolicy |	instance := self new.	policy := TimeZonePolicy newFor: instance.	policy setDefaultName: aStringOrSymbol.	instance 		setNamespaceKey: #nonGlobal key: aKey		policy: policy.	minOffset := offset1FromUT min: offset2FromUT.	annualPolicy := 		(UntilAnnualDateTimeZoneTransition 			for: policy			offsetSeconds: offset1FromUT asSeconds			stdTimeOffsetSeconds: minOffset asSeconds			commonAbbreviation: abbreviation1			annualDate: annualTransitionDate1			transitionSecondsSinceStartOfDay: timeOfDay1 secondsSinceStartOfDay			relativity: relativity1) 				asListSortedInCanonicalOrderByTransitionTimeAdding: 					(UntilAnnualDateTimeZoneTransition 						for: policy						offsetSeconds: offset2FromUT asSeconds						stdTimeOffsetSeconds: minOffset asSeconds						commonAbbreviation: abbreviation2						annualDate: annualTransitionDate2						transitionSecondsSinceStartOfDay: timeOfDay2 secondsSinceStartOfDay						relativity: relativity2).	annualPolicy := 		annualPolicy 			asListSortedInCanonicalOrderByTransitionTimeAdding: 				(UntilEndOfYearTimeZoneTransition 					for: policy					offsetSeconds: annualPolicy offsetSecondsFromUT					stdTimeOffsetSeconds: minOffset asSeconds					commonAbbreviation: annualPolicy commonAbbreviation).	policy 		setEffectiveYear: nil;		setAnnualPolicy: annualPolicy.	^instance beImmutable</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="&lt;&lt;">&lt;&lt; aChronosTimezone 	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but convert the date and time-of-day as though the receiver represented a date and time in the current default time zone (i.e,. preserve date and time-of-day in Universal Time as though the receiver represented a date and time in the current default time zone.)	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is the same as that of the receiver (i.e,, preserve local date and local time-of-day, don't preserve date or time-of-day in Universal Time.)"	^self asNominalDateAndTime &lt;&lt; aChronosTimezone</body><body package="Chronos-DateTimeInterval" selector="&gt;&gt;">&gt;&gt; aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	^self asDateAndTimeIn: aChronosTimezone</body><body package="Chronos-DateTimeInterval" selector="as:">as: otherCalendar 	"Answer the result of converting the receiver into a calendrical coordinate whose Calendar is &lt;otherCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history)."	"{(DateAndTimeSpec 		year: 1941 		month: 12 		day: 7 		secondsSinceStartOfDay: (7 * 3600) + (55 * 60) 		nanosecond: 0 calendar: Calendar gregorian) as: Julian}"	| newCalendar |	newCalendar := Calendar referencedBy: otherCalendar.	self calendar == newCalendar ifTrue: [^self copy].	^(self copy)		setSecondsSinceEpoch: 			(newCalendar 				secondsSinceEpochFromForeignSecondsSinceEpoch: self secondsSinceEpoch				convertingFrom: self calendar)		calendar: newCalendar</body><body package="Chronos-DateTimeInterval" selector="asCalendricalCoordinate">asCalendricalCoordinate	"Answer the conversion of the receiver into its equivalent value implemented as a CalendricalCoordinate.  If the receiver is already a CalendricalCoordinate, answer the receiver."	^self asNominalDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asNative">asNative	"Answer the native system's 'Timestamp' analog (or 'Date' analog, if no Timestamp analog is available) that semantically corresponds as closely as possible to the receiver."	"{(DateAndTimeSpec year: 1941 month: 12 day: 7 calendar: Calendar gregorian) asNative}"	^self calendar clock nativeCalendricalCoordinateFromChronosDateAndTime: self</body><body package="Chronos-DateTimeInterval" selector="dateAndTimeSpec">dateAndTimeSpec	^self</body><body package="Chronos-DateTimeInterval" selector="dateSpec">dateSpec	^DateSpec 		year: self year		calendarDay: self calendarDay</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="hour">hour	^hour</body><body package="Chronos-DateTimeInterval" selector="hoursSinceMidnight">hoursSinceMidnight	^self timeOfDayClockStartsAtMidnight		ifTrue: [hour]		ifFalse: [self secondsSinceMidnight // SecondsPerHour]</body><body package="Chronos-DateTimeInterval" selector="hoursSinceStartOfDay">hoursSinceStartOfDay 	^self timeOfDayClockStartsAtStartOfDay		ifTrue: [hour]		ifFalse: [self secondsSinceStartOfDay // SecondsPerHour]</body><body package="Chronos-DateTimeInterval" selector="julianDay">julianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs. However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered."	^self calendar julianDayFromSecondsSinceEpoch: self secondsSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="minute">minute	^minute</body><body package="Chronos-DateTimeInterval" selector="minutesSinceMidnight">minutesSinceMidnight	^self timeOfDayClockStartsAtMidnight		ifTrue: [hour * MinutesPerHour + minute]		ifFalse: [self secondsSinceMidnight // SecondsPerMinute]</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfDay">minutesSinceStartOfDay 	^self timeOfDayClockStartsAtStartOfDay		ifTrue: [hour * MinutesPerHour + minute]		ifFalse: [self secondsSinceStartOfDay // SecondsPerMinute]</body><body package="Chronos-DateTimeInterval" selector="minutesSinceStartOfTimeOfDayClock">minutesSinceStartOfTimeOfDayClock	^hour * MinutesPerHour + minute</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceSecond">nanosecondsSinceSecond		^nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="second">second	^second</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	^(hour * SecondsPerHour) + (minute * SecondsPerMinute) + second</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="initialize">initialize	hour := 0.	minute := 0.	second := 0.		nanosecondsSinceSecond := 0.</body><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self 		setHour: (literalArray at: 4) asNumber minute: (literalArray at: 5) asNumber second: (literalArray at: 6) asNumber;		setNanosecondsSinceSecond: (literalArray at: 7) asNumber</body><body package="Chronos-DateTimeInterval" selector="setDaysSinceEpoch:calendar:">setDaysSinceEpoch: daysSinceEpoch calendar: calendar 	super setDaysSinceEpoch: daysSinceEpoch calendar: calendar.	daysSinceEpoch isInteger 		ifFalse: 			[self setSecondsSinceStartOfDay: (daysSinceEpoch - daysSinceEpoch truncated) * self secondsInDay].</body><body package="Chronos-DateTimeInterval" selector="setFractionalSecondsSinceEpoch:calendar:">setFractionalSecondsSinceEpoch: seconds calendar: calendar	| iSeconds subseconds |	iSeconds := seconds truncated.	subseconds := seconds - iSeconds.	self 		setNanosecondsSinceSecond: subseconds * NanosecondsPerSecond;		setSecondsSinceEpoch: iSeconds calendar: calendar</body><body package="Chronos-DateTimeInterval" selector="setHour:minute:second:">setHour: h minute: m second: s 	hour := h.	minute := m.	second := s</body><body package="Chronos-DateTimeInterval" selector="setJulianDay:calendar:">setJulianDay: julianDay calendar: calendar	self setSecondsSinceEpoch: (calendar secondsSinceEpochFromJulianDay: julianDay) calendar: calendar</body><body package="Chronos-DateTimeInterval" selector="setNanosecondsSinceSecond:">setNanosecondsSinceSecond: nanosseconds	nanosecondsSinceSecond := nanosseconds truncated</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceEpoch:calendar:">setSecondsSinceEpoch: seconds calendar: calendar	| secondsDiv128 secondsMod128 |	seconds isInteger ifFalse: [^self setFractionalSecondsSinceEpoch: seconds calendar: calendar].	secondsDiv128 := seconds bitShift: -7. "Bit shifting is faster than LargeInteger math."	secondsMod128 := seconds bitAnd: 127.	self setDaysSinceEpoch: secondsDiv128 // 675 calendar: calendar. "128 * 675 = 86400"		self setSecondsSinceStartOfDay: (secondsMod128 + (secondsDiv128 \\ 675 bitShift: 7)). "seconds \\ 128 + (seconds // 128 \\ 675 * 128)"</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceMidnight:">setSecondsSinceMidnight: secondsSinceMidnight 	| seconds |	secondsSinceMidnight isInteger 		ifTrue: [seconds := secondsSinceMidnight]		ifFalse: 			[seconds := secondsSinceMidnight truncated.			self setNanosecondsSinceSecond: (secondsSinceMidnight - seconds) * NanosecondsPerSecond].	self setTimeOfDayFromSeconds: 		(self timeOfDayClockStartsAtMidnight 			ifTrue: [seconds]			ifFalse: [self calendar secondsSinceStartOfDayFromSecondsSinceMidnight: seconds])</body><body package="Chronos-DateTimeInterval" selector="setSecondsSinceStartOfDay:">setSecondsSinceStartOfDay: secondsSinceStartOfDay 	| seconds |	secondsSinceStartOfDay isInteger 		ifTrue: [seconds := secondsSinceStartOfDay]		ifFalse: 			[seconds := secondsSinceStartOfDay truncated.			self				setNanosecondsSinceSecond: (secondsSinceStartOfDay - seconds) * NanosecondsPerSecond].		self setTimeOfDayFromSeconds: 			(self timeOfDayClockStartsAtStartOfDay 				ifTrue: [seconds]				ifFalse: [self calendar secondsSinceMidnightFromSecondsSinceStartOfDay: seconds])</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:">hourMinuteSecondDo: block3 	^block3		value: hour		value: minute		value: second</body><body package="Chronos-DateTimeInterval" selector="hourMinuteSecondDo:hour24Format:">hourMinuteSecondDo: block3 hour24Format: hour24	^block3		value: (hour24 ifTrue: [hour] ifFalse: [self hour12])		value: minute		value: second</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToDateAndTime: self] 			on: MessageNotUnderstood 			do: [:ex | 				((ex receiver == aCalendrical) and: [#compareToDateAndTime: == ex message selector])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isAtStartOfDay">isAtStartOfDay	^nanosecondsSinceSecond = 0 		and: [second = 0 and: [minute = 0 and: [hour = 0]]]</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>private-comparing</category><body package="Chronos-DateTimeInterval" selector="compareToDate:">compareToDate: aDate	^(aDate compareToDateAndTime: self) negated</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self calendarRegistrationKey;		nextPut: self daysSinceEpoch;		nextPut: self hour;		nextPut: self minute;		nextPut: self second;		nextPut: self nanosecondsSinceSecond.</body><body package="Chronos-DateTimeInterval" selector="setTimeOfDayFromSeconds:">setTimeOfDayFromSeconds: secondsSinceStartOfTimeOfDayClock	| seconds |	seconds := 		(secondsSinceStartOfTimeOfDayClock abs &lt;= self secondsInDay 			ifTrue: 				[secondsSinceStartOfTimeOfDayClock positive ifTrue: [secondsSinceStartOfTimeOfDayClock] ifFalse: [self secondsInDay + secondsSinceStartOfTimeOfDayClock]]			ifFalse: [secondsSinceStartOfTimeOfDayClock \\ self secondsInDay]).	hour := seconds // SecondsPerHour.	seconds := seconds \\ SecondsPerHour.	minute := seconds // SecondsPerMinute.	second := seconds \\ SecondsPerMinute.	(hour == 24 and: [minute ==  0 and: [second == 0]])		ifTrue:			[hour := 23.			minute := 59.			second := 60]</body></methods><methods><class-id>Chronos.DateAndTimeSpec</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	"If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy default (or ChronosPrintPolicy ansiStandard or ChronosPrintPolicy iso8601,) then the receiver's printString will be formatted as required by both the ANSI-Smalltalk and the ISO 8601 Standards--except that no timezone information will be included, since the receiver is not bound to any timezone."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printDateAndTime: self on: stream</body></methods><methods><class-id>Chronos.DateAndTimeSpec class</class-id> <category>instance creation</category><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:">daysSinceEpoch: days seconds: seconds	^self basicNew		setDaysSinceEpoch: days calendar: AnsiStandardCalendar;		setNanosecondsSinceSecond: 0;		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:calendar:">daysSinceEpoch: days seconds: seconds calendar: calendar	^self basicNew		setDaysSinceEpoch: days calendar: (Calendar referencedBy: calendar)	;		setNanosecondsSinceSecond: 0;		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:nanoseconds:">daysSinceEpoch: days seconds: seconds nanoseconds: n	^self basicNew		setDaysSinceEpoch: days calendar: AnsiStandardCalendar;		setNanosecondsSinceSecond: n;		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch:seconds:nanoseconds:calendar:">daysSinceEpoch: days seconds: seconds nanoseconds: n calendar: calendar	^self basicNew		setDaysSinceEpoch: days calendar: (Calendar referencedBy: calendar)	;		setNanosecondsSinceSecond: n;		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:">julianDay: julianDay seconds: seconds	^(self new)		setJulianDay: julianDay calendar: AnsiStandardCalendar;		setSecondsSinceStartOfDay: seconds.</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:calendar:">julianDay: julianDay seconds: seconds calendar: calendar	^(self new)		setJulianDay: julianDay calendar: (Calendar referencedBy: calendar);		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:nanoseconds:">julianDay: julianDay seconds: seconds nanoseconds: nanoseconds	^(self new)		setJulianDay: julianDay calendar: AnsiStandardCalendar;		setNanosecondsSinceSecond: nanoseconds;		setSecondsSinceStartOfDay: seconds.</body><body package="Chronos-DateTimeInterval" selector="julianDay:seconds:nanoseconds:calendar:">julianDay: julianDay seconds: seconds nanoseconds: nanoseconds calendar: calendar 	^(self new)		setJulianDay: julianDay calendar: (Calendar referencedBy: calendar);		setNanosecondsSinceSecond: nanoseconds;		setSecondsSinceStartOfDay: seconds.</body><body package="Chronos-DateTimeInterval" selector="new">new	^self basicNew initialize</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:">secondsSinceEpoch: s 	^self new		setSecondsSinceEpoch: s calendar: AnsiStandardCalendar</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:calendar:">secondsSinceEpoch: s calendar: calendar	^self new		setSecondsSinceEpoch: s calendar: (Calendar referencedBy: calendar)</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:nanoseconds:">secondsSinceEpoch: s nanoseconds: n 	^self basicNew		setSecondsSinceEpoch: s calendar: AnsiStandardCalendar;		setNanosecondsSinceSecond: n</body><body package="Chronos-DateTimeInterval" selector="secondsSinceEpoch:nanoseconds:calendar:">secondsSinceEpoch: s nanoseconds: n calendar: calendar	^self basicNew		setNanosecondsSinceSecond: n;		setSecondsSinceEpoch: s calendar: (Calendar referencedBy: calendar)</body><body package="Chronos-DateTimeInterval" selector="year:calendarDay:seconds:">year: y calendarDay: cd seconds: seconds	"{DateAndTimeSpec 		year: 1941 		calendarDay: (Gregorian calendarDayFromMonth: 12 day: 7 inYear: 1941) 		seconds: 28500.5d}"	^self new		setYear: y calendarDay: cd;		setSecondsSinceStartOfDay: seconds.</body><body package="Chronos-DateTimeInterval" selector="year:calendarDay:seconds:nanoseconds:">year: y calendarDay: cd seconds: seconds nanoseconds: nanosecondsSinceSecond 	"{DateAndTimeSpec 		year: 1941 		calendarDay: (Gregorian calendarDayFromMonth: 12 day: 7 inYear: 1941) 		seconds: 28500		nanoseconds: 0}"	^self new		setYear: y calendarDay: cd;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:">year: y day: d seconds: secondsSinceStartOfDay 	"{DateAndTimeSpec 		year: 1941 		day:  341		seconds:  28500.5d}"	^self new		setYear: y dayOfYearOrdinal: d calendar: AnsiStandardCalendar;		setSecondsSinceStartOfDay: secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:calendar:">year: y day: d seconds: secondsSinceStartOfDay calendar: calendar 	"{DateAndTimeSpec 		year: 1941 		day:  341		seconds:  28500.5d		calendar: Calendar gregorian}"	^self new		setYear: y dayOfYearOrdinal: d calendar: (Calendar referencedBy: calendar);		setSecondsSinceStartOfDay: secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:nanoseconds:">year: y day: d seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond 	"{DateAndTimeSpec 		year: 1941 		day:  341		seconds:  (7 * 3600) + (55 * 60)		nanoseconds: 0}"	^self basicNew		setYear: y dayOfYearOrdinal: d calendar: AnsiStandardCalendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setSecondsSinceStartOfDay: secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="year:day:seconds:nanoseconds:calendar:">year: y day: d seconds: secondsSinceStartOfDay nanoseconds: nanosecondsSinceSecond calendar: calendar 	"{DateAndTimeSpec 		year: 1941 		day:  341		seconds:  (7 * 3600) + (55 * 60)		nanoseconds: 0		calendar: Calendar gregorian}"	^self basicNew	setYear: y dayOfYearOrdinal: d calendar: (Calendar referencedBy: calendar);		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setSecondsSinceStartOfDay: secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second 	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		hour: 7		minute: 55		second: 0.5d}"	^self new		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth calendar: AnsiStandardCalendar;		setHour: hour minute: minute second: second</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:calendar:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second calendar: calendar	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		hour: 7		minute: 55		second: 0.5d		calendar: Calendar gregorian}"	^self new		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth calendar: (Calendar referencedBy: calendar);		setHour: hour minute: minute second: second</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:nanosecond:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond 	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		hour: 7		minute: 55		second: 0		nanosecond: 0}"	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth calendar: AnsiStandardCalendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second</body><body package="Chronos-DateTimeInterval" selector="year:month:day:hour:minute:second:nanosecond:calendar:">year: year month: month day: dayOfMonth hour: hour minute: minute second: second nanosecond: nanosecondsSinceSecond calendar: calendar	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		hour: 7		minute: 55		second: 0		nanosecond: 0		calendar: Calendar gregorian}"	^self basicNew		setYear: year monthOrdinal: month dayOfMonthOrdinal: dayOfMonth calendar: (Calendar referencedBy: calendar);		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setHour: hour minute: minute second: second</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:">year: y month: m day: d seconds: seconds 	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		seconds: 28500.5d}"	^self new		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: AnsiStandardCalendar;		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:calendar:">year: y month: m day: d  seconds: seconds calendar: calendar 	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		seconds: 28500.5d		calendar: Calendar gregorian}"	^self new		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: (Calendar referencedBy: calendar);		setSecondsSinceStartOfDay: seconds</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:nanoseconds:">year: y month: m day: d seconds: seconds nanoseconds: nanosecondsSinceSecond 	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		seconds: (7 * 3600) + (55 * 60) 		nanoseconds: 0}"	^self basicNew		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: AnsiStandardCalendar;		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setSecondsSinceStartOfDay: seconds.</body><body package="Chronos-DateTimeInterval" selector="year:month:day:seconds:nanoseconds:calendar:">year: y month: m day: d  seconds: seconds nanoseconds: nanosecondsSinceSecond calendar: calendar 	"{DateAndTimeSpec 		year: 1941 		month: 12		day: 7		seconds: (7 * 3600) + (55 * 60) 		nanoseconds: 0		calendar: Calendar gregorian}"	^self basicNew		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: (Calendar referencedBy: calendar);		setNanosecondsSinceSecond: nanosecondsSinceSecond;		setSecondsSinceStartOfDay: seconds</body></methods><methods><class-id>Chronos.MonthOfYear</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="dayOfYearOrdinalOfDayOfMonth:inYearOfType:">dayOfYearOrdinalOfDayOfMonth: dayOfMonthOrdinal inYearOfType: yearTypeCode 	| month daysUpToMonth |	month := 		self 			eitherMonthOrdinalDo: 				[:mOrdinal | 				mOrdinal &gt; 0 					ifTrue: [mOrdinal]					ifFalse: [(self calendar monthsInYearForYearTypeCode: yearTypeCode) + mOrdinal]]			orMonthkeyDo: 				[:mKey | 				self resolveMonthOrdinalFromMonthKey: mKey forYearTypeCode: yearTypeCode].	daysUpToMonth := (self calendar yearlyCalendarForYearTypeCode: yearTypeCode) 				daysUpToMonth: month.	^(dayOfMonthOrdinal &gt; 0 		ifTrue: [daysUpToMonth]		ifFalse: [daysUpToMonth + (self calendar daysInMonth: month forYearTypeCode: yearTypeCode)]) + dayOfMonthOrdinal</body><body package="Chronos-Annual Dates" selector="daysInMonthInYear:">daysInMonthInYear: year 	^self eitherMonthOrdinalDo: 			[:mOrdinal | 			| yearTypeCode |			yearTypeCode := self calendar typeCodeOfYear: year.			self calendar 				daysInMonth: 					(mOrdinal &gt; 0 						ifTrue: [mOrdinal]						ifFalse: [(self calendar monthsInYearForYearTypeCode: yearTypeCode) + mOrdinal])				forYearTypeCode:yearTypeCode]		orMonthkeyDo: 			[:mKey | 			(self calendar yearlyCalendarFor: year) daysInMonthWithKey: mKey ifAbsent: []]</body><body package="Chronos-Annual Dates" selector="eitherMonthOrdinalDo:orMonthkeyDo:">eitherMonthOrdinalDo: block1a orMonthkeyDo: block1b	"If the receiver's month ordinal is unambigously specified, evaluate &lt;block1a&gt; with the receiver's month ordinal. Otherwise, evaluate &lt;block1b&gt; with the semantic key that identifies the receiver's month."	^self isMonthOrdinalResolvable		ifTrue: [block1a value: self monthOrdinal]		ifFalse: [block1b value: self monthKey]</body><body package="Chronos-Annual Dates" selector="forLocale:monthAbbreviationIfResolvable:ifNot:">forLocale: aChronosLocale monthAbbreviationIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the abbreviation of the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self 		monthKeyIfResolvable: [:mKey | resolvable value: ((ChronosLocale referencedBy: aChronosLocale) abbreviationAtSemanticKey: mKey)] 		ifNot: notResolvable</body><body package="Chronos-Annual Dates" selector="forLocale:monthNameIfResolvable:ifNot:">forLocale: aChronosLocale monthNameIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the name of the receiver's month (as specified by &lt;aChronosLocale&gt;) as the sole argument. However, if the nameKkey of the receiver's month is not unambigously resolvable, then evaluate &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self 		monthKeyIfResolvable: [:mKey | resolvable value: ((ChronosLocale referencedBy: aChronosLocale) properNameAtSemanticKey: mKey)]		ifNot: notResolvable</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinal">maxDayOfYearOrdinal 	maxDayOfYearOrdinal == nil ifTrue: [maxDayOfYearOrdinal := self computeMaxDayOfYearOrdinal].	^maxDayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="maximumDayOfYearOrdinalOfDayOfMonth:">maximumDayOfYearOrdinalOfDayOfMonth: dayOfMonthOrdinal	^(self 		eitherMonthOrdinalDo: 			[:mOrdinal | 			self calendar 				maximumDayOfYearOrdinalForMonth: 					(mOrdinal &gt; 0 						ifTrue: [mOrdinal]						ifFalse: [self calendar maxMonthsPerYear + mOrdinal])				day: dayOfMonthOrdinal]		orMonthkeyDo: 			[:mKey | 			self calendar 				maximumDayOfYearOrdinalForMonthWithKey: mKey 				day: dayOfMonthOrdinal])</body><body package="Chronos-Annual Dates" selector="maximumDaysPerMonth">maximumDaysPerMonth	^self eitherMonthOrdinalDo: 			[:mOrdinal | 			mOrdinal &gt; 0 				ifTrue: [self calendar maximumDaysInMonth: mOrdinal]				ifFalse: 					[(self calendar minMonthsPerYear to: self calendar maxMonthsPerYear) inject: 0						into: [:max :monthsPerYear | max max: (self calendar maximumDaysInMonth: mOrdinal + monthsPerYear)]]]		orMonthkeyDo: [:mKey | self calendar maximumDaysInMonthWithKey: mKey]</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinal">minDayOfYearOrdinal 	minDayOfYearOrdinal == nil ifTrue: [minDayOfYearOrdinal := self computeMinDayOfYearOrdinal].	^minDayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="minimumDayOfYearOrdinalOfDayOfMonth:">minimumDayOfYearOrdinalOfDayOfMonth: dayOfMonthOrdinal	^(self 		eitherMonthOrdinalDo: 			[:mOrdinal | 			self calendar 				minimumDayOfYearOrdinalForMonth: 					(mOrdinal &gt; 0 						ifTrue: [mOrdinal]						ifFalse: [mOrdinal + self calendar minMonthsPerYear])				day: dayOfMonthOrdinal]		orMonthkeyDo: 			[:mKey | 			self calendar 				minimumDayOfYearOrdinalForMonthWithKey: mKey 				day: dayOfMonthOrdinal])</body><body package="Chronos-Annual Dates" selector="minimumDaysPerMonth">minimumDaysPerMonth	^self eitherMonthOrdinalDo: 			[:mOrdinal | 			mOrdinal &gt; 0 				ifTrue: [self calendar minimumDaysInMonth: mOrdinal]				ifFalse: 					[(self calendar minMonthsPerYear to: self calendar maxMonthsPerYear) 						inject: self calendar maxDaysPerMonth						into: [:min :monthsPerYear | min min: (self calendar minimumDaysInMonth: mOrdinal + monthsPerYear )]]]		orMonthkeyDo: [:mKey | self calendar minimumDaysInMonthWithKey: mKey]</body><body package="Chronos-Annual Dates" selector="monthKeyIfResolvable:ifNot:">monthKeyIfResolvable: resolvable ifNot: notResolvable	"Evaluate &lt;resolvable&gt; with the key that semantically identifies the receiver's month as the sole argument. However, if the month's semantic key is not unambiguously resolvable, answer the result of evaluationg &lt;notResolvable&gt;. Answer the result of the evaluated block."	^self isMonthKeyResolvable		ifTrue: [resolvable value: self monthKey]		ifFalse: [notResolvable value]</body><body package="Chronos-Annual Dates" selector="monthKeyInYear:">monthKeyInYear: year	^monthKey == nil		ifTrue: 			[| mKey |			mKey := self resolveMonthKeyFromMonthOrdinalForYearTypeCode: (self calendar typeCodeOfYear: year).			self isMonthKeyInvariant				ifTrue: [monthKey := mKey].			mKey]		ifFalse: [monthKey]</body><body package="Chronos-Annual Dates" selector="monthOrdinalIfResolvable:ifNot:">monthOrdinalIfResolvable: resolvable ifNot: notResolvable	^self isMonthOrdinalResolvable		ifTrue: [resolvable value: self monthOrdinal]		ifFalse: [notResolvable value]</body><body package="Chronos-Annual Dates" selector="monthOrdinalInYear:">monthOrdinalInYear: year 	^monthOrdinal == nil 		ifTrue: [self monthOrdinalForYearTypeCode: (self calendar typeCodeOfYear: year)]		ifFalse: 			[monthOrdinal &gt; 0 				ifTrue: [monthOrdinal]				ifFalse: [(self calendar monthsInYear: year) + monthOrdinal]]</body><body package="Chronos-Annual Dates" selector="monthsSinceStartOfYearInYear:">monthsSinceStartOfYearInYear: year 	^monthOrdinal == nil 		ifTrue: [super monthsSinceStartOfYearInYear: year]		ifFalse: [(self monthOrdinalInYear: year) - 1]</body><body package="Chronos-Annual Dates" selector="numericMonthDesignatorInYear:">numericMonthDesignatorInYear: year 	| ytc |	ytc := self calendar typeCodeOfYear: year.	^self calendar numericMonthDesignatorFromMonthOrdinal: ((self monthOrdinalForYearTypeCode: ytc))		forYearTypeCode: ytc</body></methods><methods><class-id>Chronos.MonthOfYear</class-id> <category>initialize-release</category><body package="Chronos-Annual Dates" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	super canonicalize.	self canonicalizeMonthOrdinal.	maxDayOfYearOrdinal := self computeMaxDayOfYearOrdinal.	minDayOfYearOrdinal := self computeMinDayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	monthOrdinal := 1.	monthKey := nil</body><body package="Chronos-Annual Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	| month |	super initializeFromLiteralArray: literalArray.	month := literalArray at: 3.	month isString 		ifTrue: 			[month first isDigit 				ifTrue: [self setMonthOrdinal: month asNumber]				ifFalse: [self setMonthKey: month]]		ifFalse: [self setMonthOrdinal: month]</body><body package="Chronos-Annual Dates" selector="setMonthKey:">setMonthKey: aMonthKey	"A &lt;aMonthKey&gt; is a Symbol that specifies the name of a month, regardless of the monthOrdinal that may pertain in different years (some calendrical systems assign a different monthOrdinal to months with the same name in different years.)"	self assertMutability.	monthKey := aMonthKey asSymbol.	monthOrdinal := nil</body><body package="Chronos-Annual Dates" selector="setMonthOrdinal:">setMonthOrdinal: month	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year.  	Note: In some calendrical systems, months with the same ordinal may have different names (and semantics) in different years."	self assertMutability.	monthOrdinal := month.	monthKey := nil</body></methods><methods><class-id>Chronos.MonthOfYear</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="canonicalizeMonthOrdinal">canonicalizeMonthOrdinal	monthOrdinal == nil ifTrue: [^self].	self calendar isMonthsPerYearInvariant ifFalse: [^self].	monthOrdinal &lt;= 0		ifTrue: [monthOrdinal := monthOrdinal + self calendar maxMonthsPerYear]</body><body package="Chronos-Annual Dates" selector="computeMaxDayOfYearOrdinal">computeMaxDayOfYearOrdinal 	^self maximumDayOfYearOrdinalOfDayOfMonth: self maximumDaysPerMonth</body><body package="Chronos-Annual Dates" selector="computeMinDayOfYearOrdinal">computeMinDayOfYearOrdinal 	^self minimumDayOfYearOrdinalOfDayOfMonth: 1</body><body package="Chronos-Annual Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut: 		(monthKey == nil 			ifTrue: [self monthOrdinal]			ifFalse: [self monthKey])</body><body package="Chronos-Annual Dates" selector="monthOrdinalForYearTypeCode:">monthOrdinalForYearTypeCode: yearTypeCode 	^monthOrdinal == nil 		ifTrue: 			[| mOrdinal |			mOrdinal := self 						resolveMonthOrdinalFromMonthKeyForYearTypeCode: yearTypeCode.			self isMonthOrdinalInvariant ifTrue: [monthOrdinal := mOrdinal].			mOrdinal]		ifFalse: 			[monthOrdinal &gt; 0 				ifTrue: [monthOrdinal]				ifFalse: [(self calendar monthsInYearForYearTypeCode: yearTypeCode) + monthOrdinal]]</body><body package="Chronos-Annual Dates" selector="resolveMonthKeyFromMonthOrdinalForYearTypeCode:">resolveMonthKeyFromMonthOrdinalForYearTypeCode: yearTypeCode 	^self 		resolveMonthKeyFromMonthOrdinal: 			(monthOrdinal &gt; 0 				ifTrue: [monthOrdinal]				ifFalse: [(self calendar monthsInYearForYearTypeCode: yearTypeCode) + monthOrdinal])		forYearTypeCode: yearTypeCode</body><body package="Chronos-Annual Dates" selector="resolveMonthOrdinalFromMonthKeyForYearTypeCode:">resolveMonthOrdinalFromMonthKeyForYearTypeCode: yearTypeCode	^self resolveMonthOrdinalFromMonthKey: monthKey forYearTypeCode: yearTypeCode</body></methods><methods><class-id>Chronos.MonthOfYear</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isMonthKeyInvariant">isMonthKeyInvariant	^monthKey == nil		ifTrue: [self calendar doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey]		ifFalse: [true]</body><body package="Chronos-Annual Dates" selector="isMonthKeyResolvable">isMonthKeyResolvable	^monthKey notNil or: [self calendar doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey]</body><body package="Chronos-Annual Dates" selector="isMonthOrdinalInvariant">isMonthOrdinalInvariant	^monthOrdinal == nil		ifTrue: [self calendar doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey]		ifFalse: [monthOrdinal &gt; 0]</body><body package="Chronos-Annual Dates" selector="isMonthOrdinalResolvable">isMonthOrdinalResolvable	^monthOrdinal notNil or: [self calendar doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey]</body></methods><methods><class-id>Chronos.MonthOfYear</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="identifiersDo:">identifiersDo: block2	super identifiersDo: block2.	monthKey == nil 		ifTrue: [block2 value: #monthOrdinal value: self monthOrdinal]		ifFalse: [block2 value: #monthKey value: self monthKey].</body><body package="Chronos-Annual Dates" selector="month">month	^self monthOrdinal</body><body package="Chronos-Annual Dates" selector="monthKey">monthKey	^(monthKey == nil and: [self calendar doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey])		ifTrue: 			[| mKey |			mKey := self resolveMonthKeyFromMonthOrdinalForYearTypeCode: RegularCalendar standardYearTypeCode.			self isMonthKeyInvariant				ifTrue: [monthKey := mKey].			mKey]		ifFalse: [monthKey]</body><body package="Chronos-Annual Dates" selector="monthOrdinal">monthOrdinal	^(monthOrdinal == nil and: [self calendar doMonthOrdinalsAlwaysCorrespondToTheSameMonthKey])		ifTrue: 			[| mOrdinal |			mOrdinal := self resolveMonthOrdinalFromMonthKeyForYearTypeCode: RegularCalendar standardYearTypeCode.			self isMonthOrdinalInvariant ifTrue: [monthOrdinal := mOrdinal].			mOrdinal]		ifFalse: [monthOrdinal]</body><body package="Chronos-Annual Dates" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^MonthDuration</body></methods><methods><class-id>Chronos.MonthOfYear</class-id> <category>comparing</category><body package="Chronos-Annual Dates" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToMonth: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aCalendrical and: [ex message selector == #compareToMonth:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-Annual Dates" selector="hash">hash	^((monthOrdinal == nil ifTrue: [monthKey] ifFalse: [monthOrdinal])) hash</body></methods><methods><class-id>Chronos.MonthOfYear</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processMonthOfYear: self</body></methods><methods><class-id>Chronos.MonthOfYear class</class-id> <category>constants</category><body package="Chronos-Annual Dates" selector="lastMonthOfYear">lastMonthOfYear	^0</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>initialize-release</category><body package="Chronos-Annual Dates" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	super canonicalize.	dayOfWeekOrdinal := ((dayOfWeekOrdinal - 1) \\ DaysPerWeek) + 1.</body><body package="Chronos-Annual Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.		minDayOfMonthCardinal := 0.	maxDayOfMonthCardinal := 6.	dayOfWeekOrdinal := 1.	daysOffset := 0 "days"</body><body package="Chronos-Annual Dates" selector="initializeFrom:">initializeFrom: aCalendricalCoordinate 	self		basicSetCalendar: aCalendricalCoordinate calendar;		setMonthOrdinal: aCalendricalCoordinate monthOrdinal;		setWeekOfMonthOrdinal: aCalendricalCoordinate weekOfMonthOrdinal dayOfWeekOrdinal: aCalendricalCoordinate dayOfWeek;		setDaysOffset: 0</body><body package="Chronos-Annual Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self 		setMinDayOfMonthOrdinal: (literalArray at: 4) asNumber		dayOfWeekOrdinal: (literalArray at: 5) asNumber;		setDaysOffset: (literalArray at: 6) asNumber</body><body package="Chronos-Annual Dates" selector="setDaysOffset:">setDaysOffset: days	self assertMutability.	daysOffset := days == nil ifTrue: [0] ifFalse: [days]</body><body package="Chronos-Annual Dates" selector="setMinDayOfMonthOrdinal:dayOfWeekOrdinal:">setMinDayOfMonthOrdinal: minDayOfMonthOrdinal dayOfWeekOrdinal: d	"If &lt;minDayOfMonthOrdinal&gt; is greater than 0, then it is interpreted as &lt;minDayOfMonthOrdinal - 1&gt; days from the first day of the month.	If &lt;minDayOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonthOrdinal&gt; days from the last day of the month."	self assertMutability.	dayOfWeekOrdinal := d.	minDayOfMonthCardinal := minDayOfMonthOrdinal - 1.	maxDayOfMonthCardinal := minDayOfMonthCardinal + DaysPerWeek - 1</body><body package="Chronos-Annual Dates" selector="setOffset:">setOffset: aDurationWhoseYearsMonthsAndSubdaysWillBeIgnoredOrElseDaysAsInteger	"Set my offset in days.  I accept either integers or Durations--solely to avoid having too many instance creation messages, one each for integer offsets and Duration offsets."	self setDaysOffset: 			(aDurationWhoseYearsMonthsAndSubdaysWillBeIgnoredOrElseDaysAsInteger respondsToArithmetic				ifTrue: [aDurationWhoseYearsMonthsAndSubdaysWillBeIgnoredOrElseDaysAsInteger]				ifFalse: [aDurationWhoseYearsMonthsAndSubdaysWillBeIgnoredOrElseDaysAsInteger days])</body><body package="Chronos-Annual Dates" selector="setWeekOfMonthOrdinal:dayOfWeekOrdinal:">setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: d	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	self setMinDayOfMonthOrdinal: weekOfMonthOrdinal - 1 * DaysPerWeek + 1 dayOfWeekOrdinal: d</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="ansiDayOfWeekOrdinal">ansiDayOfWeekOrdinal	^self calendar 		ansiDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: dayOfWeekOrdinal</body><body package="Chronos-Annual Dates" selector="dayOfWeek">dayOfWeek	^dayOfWeekOrdinal</body><body package="Chronos-Annual Dates" selector="dayOfWeekKey">dayOfWeekKey	^ANSIDayOfWeekKeys at: dayOfWeekOrdinal</body><body package="Chronos-Annual Dates" selector="daysOffset">daysOffset	"Needed for 'Day after Thanksgiving' (for example)"	^daysOffset</body><body package="Chronos-Annual Dates" selector="daysOffset:">daysOffset: daysAsInteger	^self isMutable 		ifTrue: [self setDaysOffset: daysAsInteger]		ifFalse: 			[(self copy)				setDaysOffset: daysAsInteger;				beImmutable]</body><body package="Chronos-Annual Dates" selector="identifiersDo:">identifiersDo: block2	super identifiersDo: block2.	block2 value: #minDayOfMonthOrdinal value: self minDayOfMonthOrdinal.	block2 value: #dayOfWeek value: self dayOfWeek.	block2 value: #daysOffset value: daysOffset</body><body package="Chronos-Annual Dates" selector="isoDayOfWeekOrdinal">isoDayOfWeekOrdinal	^self calendar 		isoDayOfWeekOrdinalFromCanonicalDayOfWeekOrdinal: dayOfWeekOrdinal</body><body package="Chronos-Annual Dates" selector="maxDayOfMonthOrdinal">maxDayOfMonthOrdinal	^maxDayOfMonthCardinal + 1</body><body package="Chronos-Annual Dates" selector="minDayOfMonthOrdinal">minDayOfMonthOrdinal	^minDayOfMonthCardinal + 1</body><body package="Chronos-Annual Dates" selector="offset">offset	^self class durationFactory days: self daysOffset</body><body package="Chronos-Annual Dates" selector="offset:">offset: aDuration	^self copy		setOffset: aDuration;		beImmutable</body><body package="Chronos-Annual Dates" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^CalendarDayDuration</body><body package="Chronos-Annual Dates" selector="weeksSinceStartOfMonth">weeksSinceStartOfMonth	"Answer the CARDINAL number of the week of the month in which the day represented by the receiver occurs.  The first seven days of the month are in the week whose CARDINAL number is zero."	^minDayOfMonthCardinal // DaysPerWeek</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>comparing</category><body package="Chronos-Annual Dates" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToWeekOfMonthDayOfWeek: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aCalendrical and: [ex message selector == #compareToWeekOfMonthDayOfWeek:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-Annual Dates" selector="hash">hash	^(super hash + minDayOfMonthCardinal + dayOfWeekOrdinal) hash</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="computeMaxDayOfYearOrdinal">computeMaxDayOfYearOrdinal	"maxDayOfYearOrdinal is used for comparisons, but not for computing the calendarDay in a given year--so it's OK to add in the daysOffset."	^(minDayOfMonthCardinal &gt;= 0 		ifTrue: [self maximumDayOfYearOrdinalOfDayOfMonth: maxDayOfMonthCardinal + 1]		ifFalse: [self maximumDayOfYearOrdinalOfDayOfMonth: self maximumDaysPerMonth + maxDayOfMonthCardinal + 1]) + daysOffset</body><body package="Chronos-Annual Dates" selector="computeMinDayOfYearOrdinal">computeMinDayOfYearOrdinal 	"minDayOfYearOrdinal is used for comparisons, but not for computing the calendarDay in a given year--so it's OK to add in the daysOffset."	^(minDayOfMonthCardinal &gt;= 0 		ifTrue: [self minimumDayOfYearOrdinalOfDayOfMonth: minDayOfMonthCardinal + 1]		ifFalse: [self minimumDayOfYearOrdinalOfDayOfMonth: self minimumDaysPerMonth + minDayOfMonthCardinal + 1]) + daysOffset</body><body package="Chronos-Annual Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut:  self minDayOfMonthOrdinal;		nextPut: self dayOfWeek;		nextPut: self daysOffset</body><body package="Chronos-Annual Dates" selector="value:value:">value: aYear value: aCalendarDay	| date |	date := YearMonthDay year: aYear calendarDay: aCalendarDay.	self 		setMonthOrdinal: date month;		setWeekOfMonthOrdinal: date weekOfMonthOrdinal dayOfWeekOrdinal: date dayOfWeek</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isDayOfWeekInvariant">isDayOfWeekInvariant	^true</body><body package="Chronos-Annual Dates" selector="isWeekOfMonthInvariant">isWeekOfMonthInvariant	^true</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="calendarDayInYear:">calendarDayInYear: year 	"Fundamental algorithm for determining the starting and ending days of Daylight Savings Time, and of course also for many Holidays, such as Thanksgiving."	| daysUpToYear yearTypeCode yearlyCalendar monthNumber daysUpToMonth cardinalEpochDayNumberOfFirstDayOfMonth dayOfMonth  cd |	daysUpToYear := self calendar daysSinceEpochUpToYear: year.	yearTypeCode := self calendar typeCodeOfYear: year.	yearlyCalendar := self calendar yearlyCalendarForYearTypeCode: yearTypeCode.	monthNumber := self monthOrdinalForYearTypeCode: yearTypeCode.	daysUpToMonth := yearlyCalendar daysUpToMonth: monthNumber.	cardinalEpochDayNumberOfFirstDayOfMonth := daysUpToYear + daysUpToMonth.	minDayOfMonthCardinal &lt; 0 		ifTrue: 			[| daysInMonth cardinalEpochDayNumberOfFirstDayOfNextMonth maxDayOfWeekOrdinal  delta |			daysInMonth := yearlyCalendar daysInMonthAt: monthNumber.			cardinalEpochDayNumberOfFirstDayOfNextMonth := cardinalEpochDayNumberOfFirstDayOfMonth + daysInMonth.			maxDayOfWeekOrdinal := self calendar dayOfWeekOrdinalFromDaysSinceEpoch: cardinalEpochDayNumberOfFirstDayOfNextMonth + maxDayOfMonthCardinal.			delta := maxDayOfWeekOrdinal - dayOfWeekOrdinal.			delta &lt; 0 ifTrue: [delta := DaysPerWeek + delta].			dayOfMonth := daysInMonth - delta]		ifFalse: 			[| minDayOfWeekOrdinal delta |			minDayOfWeekOrdinal := self calendar dayOfWeekOrdinalFromDaysSinceEpoch: cardinalEpochDayNumberOfFirstDayOfMonth + minDayOfMonthCardinal.			delta := dayOfWeekOrdinal - minDayOfWeekOrdinal.			delta &lt; 0 ifTrue: [delta := DaysPerWeek + delta].			dayOfMonth := minDayOfMonthCardinal + 1 + delta].	cd := yearlyCalendar dayAt: daysUpToMonth + dayOfMonth + daysOffset. 	^cd == nil 		ifTrue: [(self calendar dateSpecFromDaysSinceEpoch: cardinalEpochDayNumberOfFirstDayOfMonth + daysOffset + dayOfMonth - 1) calendarDay]		ifFalse: [cd]</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinalForYearOfType:">maxDayOfYearOrdinalForYearOfType: yearTypeCode 	^self dayOfYearOrdinalOfDayOfMonth: maxDayOfMonthCardinal + 1 inYearOfType: yearTypeCode</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinalForYearOfType:">minDayOfYearOrdinalForYearOfType: yearTypeCode	^self dayOfYearOrdinalOfDayOfMonth: minDayOfMonthCardinal + 1 inYearOfType: yearTypeCode</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>converting</category><body package="Chronos-Annual Dates" selector="asWeekOfMonthDayOfWeek">asWeekOfMonthDayOfWeek	^self</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processWeekOfMonthDayOfWeek: self</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printWeekOfMonthDayOfWeek: self on: stream</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek class</class-id> <category>instance creation</category><body package="Chronos-Annual Dates" selector="month:minDayOfMonth:dayOfWeek:">month: monthOrdinal minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setMonthOrdinal: monthOrdinal;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:minDayOfMonth:dayOfWeek:calendar:">month: monthOrdinal minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal calendar: calendar	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setCalendar: calendar;		setMonthOrdinal: monthOrdinal;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:minDayOfMonth:dayOfWeek:offset:">month: monthOrdinal minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal offset: days	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self basicNew		setOffset: days;		setMonthOrdinal: monthOrdinal;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:minDayOfMonth:dayOfWeek:offset:calendar:">month: monthOrdinal minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal offset: days calendar: calendar	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self basicNew		setCalendar: calendar;		setOffset: days;		setMonthOrdinal: monthOrdinal;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:week:dayOfWeek:">month: monthOrdinal week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setMonthOrdinal: monthOrdinal;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:week:dayOfWeek:calendar:">month: monthOrdinal week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal calendar: calendar	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setCalendar: calendar;		setMonthOrdinal: monthOrdinal;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:week:dayOfWeek:offset:">month: monthOrdinal week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal offset: daysOffset	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setMonthOrdinal: monthOrdinal;		setOffset: daysOffset;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:week:dayOfWeek:offset:calendar:">month: monthOrdinal week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal offset: days calendar: calendar	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self basicNew		setCalendar: calendar;		setOffset: days;		setMonthOrdinal: monthOrdinal;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:minDayOfMonth:dayOfWeek:">monthKey: monthKey minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setMonthKey: monthKey;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:minDayOfMonth:dayOfWeek:calendar:">monthKey: monthKey minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal calendar: calendar	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setCalendar: calendar;		setMonthKey: monthKey;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:minDayOfMonth:dayOfWeek:offset:">monthKey: monthKey minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal offset: days	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setOffset: days;		setMonthKey: monthKey;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:minDayOfMonth:dayOfWeek:offset:calendar:">monthKey: monthKey minDayOfMonth: minDayOfMonth dayOfWeek: dayOfWeekOrdinal offset: days calendar: calendar	"If &lt;minDayOfMonth:&gt; &lt;= 0, then it is interpreted as &lt;minDayOfMonth:&gt; days from the last day of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self basicNew		setCalendar: calendar;		setOffset: days;		setMonthKey: monthKey;		setMinDayOfMonthOrdinal: minDayOfMonth dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:week:dayOfWeek:">monthKey: monthKey week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setMonthKey: monthKey;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:week:dayOfWeek:calendar:">monthKey: monthKey week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal calendar: calendar	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setCalendar: calendar;		setMonthKey: monthKey;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:week:dayOfWeek:offset:">monthKey: monthKey week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal offset: days	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self new		setOffset: days;		setMonthKey: monthKey;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:week:dayOfWeek:offset:calendar:">monthKey: monthKey week: weekOfMonthOrdinal dayOfWeek: dayOfWeekOrdinal offset: days calendar: calendar	"If &lt;weekOfMonthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;weekOfMonthOrdinal&gt; weeks from the last week of the month.	If &lt;dayOfWeekOrdinal&gt; &lt;= 0, then it is interpreted as &lt;dayOfWeekOrdinal&gt; days from the last day of the week."	^self basicNew		setCalendar: calendar;		setOffset: days;		setMonthKey: monthKey;		setWeekOfMonthOrdinal: weekOfMonthOrdinal dayOfWeekOrdinal: dayOfWeekOrdinal;		beImmutable;		yourself</body></methods><methods><class-id>Chronos.WeekOfMonthDayOfWeek class</class-id> <category>constants</category><body package="Chronos-Annual Dates" selector="lastDayOfWeek">lastDayOfWeek	^0</body><body package="Chronos-Annual Dates" selector="lastWeekOfMonth">lastWeekOfMonth	^0</body></methods><methods><class-id>Chronos.VWChronosEnvironment class</class-id> <category>namespace operations</category><body package="Chronos-Environment-VW" selector="defineChronosCalendarConstantsNamespace">defineChronosCalendarConstantsNamespace	"Define a namespace named ChronosCalendarConstants"	self chronosNamespace defineNameSpace: #ChronosCalendarConstants		private: false		imports: '				Chronos.*				private Smalltalk.*				'		category: 'Chronos-Environment-VisualWorks'</body><body package="Chronos-Environment-VW" selector="defineChronosConstantsNamespace">defineChronosConstantsNamespace	"Define a namespace named ChronosConstants"	self globalNamespace defineNameSpace: #ChronosConstants		private: false		imports: '				Chronos.ChronosTemporalRatioConstants.*				Chronos.ChronosDaysOfWeekConstants.*				Chronos.ChronosStandardMonthConstants.*				Chronos.ChronosFactoryBindings.*				Chronos.ChronosCalendarConstants.*				Chronos.ChronosDurationConstants.*			'		category: 'Chronos-Environment-VisualWorks'</body><body package="Chronos-Environment-VW" selector="defineChronosConstantsNamespaceImports">defineChronosConstantsNamespaceImports	"Cause the #ChronosConstants namespace to 'import' from all the other Chronos namespaces that contain constants and/or aliases (i.e., all of the other Chronos namespaces except for the #Chronos namespace.) Ideally, this should be done by means of dynamic delegation from the #ChronosConstants namespace to the other namespaces.  However, if necessary, it may also be achieved by copying the bindings from the other namespaces into the #ChronosConstants namespace, or even by duplicating the key-&gt;value entries."	"NO-OP, because this was achieved by listing namespace imports in the declaration of the ChronosContansts namespace."</body><body package="Chronos-Environment-VW" selector="defineChronosDaysOfWeekConstantsNamespace">defineChronosDaysOfWeekConstantsNamespace	"Define a namespace named ChronosDaysOfWeekConstants"	self chronosNamespace defineNameSpace: #ChronosDaysOfWeekConstants		private: false		imports: '				private Smalltalk.*				'		category: 'Chronos-Environment-VisualWorks'</body><body package="Chronos-Environment-VW" selector="defineChronosDurationConstantsNamespace">defineChronosDurationConstantsNamespace	"Define a namespace named ChronosDurationConstants"	self chronosNamespace defineNameSpace: #ChronosDurationConstants		private: false		imports: '				Chronos.TemporalRatioConstants.*				Chronos.ChronosFactoryBindings.*				private Smalltalk.*			'		category: 'Chronos-Environment-VisualWorks'</body><body package="Chronos-Environment-VW" selector="defineChronosFactoryBindingsNamespace">defineChronosFactoryBindingsNamespace	"Define a namespace named ChronosFactoryBindings"	self chronosNamespace defineNameSpace: #ChronosFactoryBindings		private: false		imports: '				Chronos.*				private Smalltalk.*				'		category: 'Chronos-Environment-VisualWorks'</body><body package="Chronos-Environment-VW" selector="defineChronosNamespace">defineChronosNamespace	"Define a namespace named Chronos--if and only if the host Smalltalk implementation provides the necessary tools and facilities for defining, browsing and editing the classes of the Chronos Date/Time library in an indepedendent namespace named Chronos. Otherwise, do nothing."	Smalltalk defineNameSpace: #Chronos		private: false		imports: '				ChronosContants.*				private Smalltalk.*				'		category: 'Chronos-Environment-VisualWorks'</body><body package="Chronos-Environment-VW" selector="defineChronosStandardMonthConstantsNamespace">defineChronosStandardMonthConstantsNamespace	"Define a namespace named ChronosStandardMonthConstants"	self chronosNamespace defineNameSpace: #ChronosStandardMonthConstants		private: false		imports: '				private Smalltalk.*				'		category: 'Chronos-Environment-VisualWorks'</body><body package="Chronos-Environment-VW" selector="defineChronosTemporalRatioConstantsNamespace">defineChronosTemporalRatioConstantsNamespace	"Define a namespace named ChronosTemporalRatioConstants"	self chronosNamespace defineNameSpace: #ChronosTemporalRatioConstants		private: false		imports: '				private Smalltalk.*				'		category: 'Chronos-Environment-VisualWorks'</body></methods><methods><class-id>Chronos.VWChronosEnvironment class</class-id> <category>accessing</category><body package="Chronos-Environment-VW" selector="chronosNamespace">chronosNamespace	"Answer the namespace that contains the classes of the Chronos codebase."	^self globalNamespace at: #Chronos</body><body package="Chronos-Environment-VW" selector="chronosNamespaceName">chronosNamespaceName	"Answer the name of the namespace that contains the classes of the Chronos codebase."	^#Chronos</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="initialize">initialize	defaultBroker := self class.	references := IdentityDictionary new.	aliases := IdentityDictionary new.</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>private</category><body package="Passport-Kernel" selector="aliasMap">aliasMap	^aliases</body><body package="Passport-Kernel" selector="newReference:">newReference: key	^self newReference: key mediator: self defaultBroker</body><body package="Passport-Kernel" selector="newReference:mediator:">newReference: key mediator: mediator	^mediator newReferenceTo: key</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>accessing</category><body package="Passport-Kernel" selector="aResourceBroker:">aResourceBroker: aResourceBroker	defaultBroker := aResourceBroker</body><body package="Passport-Kernel" selector="alias:as:">alias: canonicalKey as: aliasingKey 	| reference |	canonicalKey = aliasingKey 		ifFalse: [(aliases at: canonicalKey ifAbsentPut: [IdentitySet new]) add: aliasingKey].	^(self referenceAt: aliasingKey		ifNone: 			[reference := self newReference: canonicalKey.			^references at: aliasingKey put: reference]) 				key: canonicalKey</body><body package="Passport-Kernel" selector="aliasedKeys">aliasedKeys	^aliases keys</body><body package="Passport-Kernel" selector="aliasingKeys">aliasingKeys	| aliasingKeys |	aliasingKeys := IdentitySet new.	aliases do: [:set | aliasingKeys addAll: set].	^aliasingKeys</body><body package="Passport-Kernel" selector="aliasingKeysOf:">aliasingKeysOf: canonicalKey	^(aliases at: canonicalKey ifAbsent: [^IdentitySet new]) copy</body><body package="Passport-Kernel" selector="at:">at: aKey	^self at: aKey ifAbsent: [self signalError: 'Key not found: ', aKey printString]</body><body package="Passport-Kernel" selector="at:ifAbsent:">at: aKey ifAbsent: ifAbsent 	| reference value | 	^(self 		referenceAt: aKey		ifNone: 			[reference := self newReference: aKey.			value := reference valueIfNone: [^ifAbsent value].			self at: aKey putReference: reference.			^value]) valueIfNone: ifAbsent</body><body package="Passport-Kernel" selector="at:ifAbsentPut:">at: aKey ifAbsentPut: valueBlock 	| reference canonicalKey aliasingKeys |	reference := self referenceAt: aKey ifNone: [^(self referenceAt: aKey) value: valueBlock value].	canonicalKey := reference key.	^reference valueIfNoneThenAt: aKey		put: 			[aKey = canonicalKey 				ifFalse: 					[aliasingKeys := aliases at: canonicalKey ifAbsent: [].					aliasingKeys == nil ifFalse: [aliasingKeys remove: aKey]].			valueBlock value]</body><body package="Passport-Kernel" selector="at:put:">at: aKey put: aValue	| reference canonicalKey  |	reference := self referenceAt: aKey.	canonicalKey := reference key.	aKey = canonicalKey		ifTrue: [reference value: aValue]		ifFalse: 			[reference key: aKey value: aValue.			(aliases at: canonicalKey ifAbsent: [^aValue]) remove: aKey].	^aValue</body><body package="Passport-Kernel" selector="canonicalKeyAt:ifNone:">canonicalKeyAt: aKey ifNone: ifNone	^(self referenceAt: aKey ifNone: [^ifNone value]) key</body><body package="Passport-Kernel" selector="canonicalKeys">canonicalKeys	| canonicalKeys |	canonicalKeys := self keys.	aliases do: [:set | set do: [:aliasingKey | canonicalKeys remove: aliasingKey ifAbsent: []]].	^canonicalKeys</body><body package="Passport-Kernel" selector="defaultBroker">defaultBroker	^defaultBroker</body><body package="Passport-Kernel" selector="defaultBroker:">defaultBroker: aResourceBroker	defaultBroker := aResourceBroker</body><body package="Passport-Kernel" selector="define:">define: aKey 	^self referenceAt: aKey</body><body package="Passport-Kernel" selector="keys">keys	^references keys</body><body package="Passport-Kernel" selector="removeAliasesOf:">removeAliasesOf: canonicalKey 	| aliasingKeys |	aliasingKeys := aliases at: canonicalKey ifAbsent: [].	aliasingKeys == nil		ifFalse: [aliasingKeys do: [:alias | self removeKey: alias ifAbsent: []]].	aliases removeKey: canonicalKey ifAbsent: []</body><body package="Passport-Kernel" selector="size">size	^references size</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>accessing-references</category><body package="Passport-Kernel" selector="at:putReference:">at: aKey putReference: aResourceReference	| canonicalKey |	canonicalKey := aResourceReference key.	aKey = canonicalKey ifFalse: [(aliases at: canonicalKey ifAbsentPut: [IdentitySet new]) add: aKey].	^references at: aKey put: aResourceReference</body><body package="Passport-Kernel" selector="referenceAt:">referenceAt: key	^references at: key ifAbsentPut: [self newReference: key]</body><body package="Passport-Kernel" selector="referenceAt:ifNone:">referenceAt: key ifNone: ifNone	^references at: key ifAbsent: ifNone</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>removing</category><body package="Passport-Kernel" selector="removeKey:">removeKey: aKey 	^self removeKey: aKey ifAbsent: [self signalError: 'Key not found: ', aKey printString]</body><body package="Passport-Kernel" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: ifNone 	| reference canonicalKey value |	reference := self referenceAt: key ifNone: [^ifNone value].	references removeKey: key.	canonicalKey := reference key.	^key = canonicalKey 		ifTrue: 			[value := reference removeIfAbsent: [].			self removeAliasesOf: key.			value]		ifFalse: 			[(aliases at: canonicalKey ifAbsent: [^nil]) remove: key.			nil].</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>actions</category><body package="Passport-Kernel" selector="writeAliasesOn:">writeAliasesOn: stream 	aliases keysAndValuesDo: 			[:key :aliasSet | 			stream				nextPutAll: key;				nextPut: $:.			aliasSet do: 					[:alias | 					stream						space;						nextPutAll: alias].			stream cr]</body><body package="Passport-Kernel" selector="writeCanonicalKeysOn:">writeCanonicalKeysOn: stream 	self canonicalKeys asSortedCollection 		do: [:key | stream nextPutAll: key; cr]</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>enumerating</category><body package="Passport-Kernel" selector="do:">do: block1 	self referencesDo: [:reference | block1 value: reference value]</body><body package="Passport-Kernel" selector="keysAndReferencesDo:">keysAndReferencesDo: block2 	references keysAndValuesDo: block2</body><body package="Passport-Kernel" selector="keysAndValuesDo:">keysAndValuesDo: block2 	self keysAndReferencesDo: [:key :reference | block2 value: key value: reference value]</body><body package="Passport-Kernel" selector="keysDo:">keysDo: block1 	references keysDo: block1</body><body package="Passport-Kernel" selector="referencesDo:">referencesDo: block1 	references do: block1</body></methods><methods><class-id>Passport.ExternalResourceRepository</class-id> <category>testing</category><body package="Passport-Kernel" selector="includesKey:">includesKey: key	| reference |	reference := self referenceAt: key ifNone: [^false].	^reference valueIsDefined</body></methods><methods><class-id>Passport.ExternalResourceRepository class</class-id> <category>private</category><body package="Passport-Kernel" selector="newReferenceTo:">newReferenceTo: key 	^LocalResourceReference new key: key</body></methods><methods><class-id>Passport.ExternalResourceRepository class</class-id> <category>instance creation</category><body package="Passport-Kernel" selector="defaultBroker:">defaultBroker: aResourceBroker 	^self new defaultBroker: aResourceBroker</body></methods><methods><class-id>Chronos.EthiopicCalendar</class-id> <category>API-unification</category><body package="Chronos-Calendars-Regular" selector="secondsSinceMidnightFromSecondsSinceStartOfDay:">secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay	"Answer the number of seconds-since-start-of-day relative to midnight represented by the argument, &lt;secondsSinceStartOfDay&gt;, where the argument is specified relative to the receiver's canonical start-of-day (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since midnight clock time that corresponds to the number of seconds since the receiver's canonical start-of-day clock time, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for time systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Julian Day time system, the canonical start-of-day is Noon."	^secondsSinceStartOfDay + 21600</body><body package="Chronos-Calendars-Regular" selector="secondsSinceStartOfDayFromSecondsSinceMidnight:">secondsSinceStartOfDayFromSecondsSinceMidnight: secondsSinceMidnight	"Answer the number of seconds-since-start-of-day relative to the receiver's canonical start-of-day represented by the argument, &lt;secondsSinceMidnight&gt;, where the argument is specified relative to midnight (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since the receiver's canonical start-of-day clock time that corresponds to the number of seconds since midnight, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for calendar systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Hebrew calendar, the canonical start-of-day is 6pm."	^secondsSinceMidnight + 64800</body></methods><methods><class-id>Chronos.EthiopicCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1724220 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.EthiopicCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the calendrical system implemented by the receiver coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^true</body></methods><methods><class-id>Chronos.EthiopicCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Maskaram 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Teqemt 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Khedar 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Takhsas 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ter	 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Yakatit 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Magabit	 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Miyazya	 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Genbot 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sane					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Hamle 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nahase 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey: #Paguemen	daysPerMonth: 6 occursEveryYear: true leapDayOrdinals: #(6)).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #Maskaram 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Teqemt 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Khedar 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Takhsas 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Ter	 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Yakatit 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Magabit	 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Miyazya	 			daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Genbot 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Sane					daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Hamle 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #Nahase 				daysPerMonth: 30 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey: #Paguemen	daysPerMonth: 5 occursEveryYear: true leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.EthiopicCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Ethiopic</body></methods><methods><class-id>Chronos.EthiopicCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"EthiopicCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Chronos.UTCalendarClock</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicTodayIn:">basicTodayIn: aTimezone	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the timezone implemented by &lt;aTimezone&gt; (which must be an instance of a concrete subclass of ChronosTimezone,) and with invariant-to-UT semantics." 	^(self		mutableDateAndTimeAtStartOfDayFromUTSecondsSinceSystemClockEpoch: systemClock secondsNowSinceSystemClockEpoch		timeZone: aTimezone) beImmutable</body><body package="Chronos-Calendars-Foundation" selector="mutableDateTodayIn:">mutableDateTodayIn: aTimezone 	"Answer a date value representing today's date, in the receiver's calendar, and relative to the timezone implemented by &lt;aTimezone&gt; (which must be an instance of a concrete subclass of ChronosTimezone.)"	^self 		mutableDateFromUTSecondsSinceSystemClockEpoch: systemClock secondsNowSinceSystemClockEpoch		timeZone: aTimezone</body><body package="Chronos-Calendars-Foundation" selector="nowIn:includeNanoseconds:">nowIn: aTimezone includeNanoseconds: includeNanoseconds 	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the  timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;, and with invariant-to-UT semantics. If &lt;includeNanoseconds&gt; is true, include the number of nanoseconds-since-the-second in the answered DateAndTime; otherwise, have the answered DateAndTime specify zero nanoseconds-since-the-second (so that the current date and time is reported only to the latest second.)"	| ticksNow secondsNow nanosecondsSinceSecond |	ticksNow := systemClock ticksNowSinceSystemClockEpoch.	nanosecondsSinceSecond := includeNanoseconds 				ifTrue: [systemClock nanosecondsSinceSecondFromTicks: ticksNow]				ifFalse: [0].	secondsNow := systemClock secondsFromTicks: ticksNow.	^(calendar isGregorian 		ifTrue: 			[self 				mutableDateAndTimeFromUTSecondsSinceGregorianEpoch: secondsNow + secondsFromGregorianEpochUpToSystemClockEpoch				nanoseconds: nanosecondsSinceSecond				timeZone: aTimezone]		ifFalse: 			[self 				mutableDateAndTimeFromUTSecondsSinceSystemClockEpoch: secondsNow				nanoseconds: nanosecondsSinceSecond				timeZone: aTimezone]) 			beImmutable</body><body package="Chronos-Calendars-Foundation" selector="timeOfDayNowIn:includeNanoseconds:">timeOfDayNowIn: aTimezone includeNanoseconds: includeNanoseconds 	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the timezone specified by the value of &lt;aTimezoneOrTimezoneReference&gt;. If &lt;includeNanoseconds&gt; is true, include the number of nanoseconds-since-the-second in the answered time-of-day value; otherwise, have the answered time-of-day value specify zero nanoseconds-since-the-second (so that the current date and time is reported only to the latest second.)"	"{Calendar gregorian clock timeOfDayNowIn: #'Pacific/Honolulu'}"	"{Calendar julian clock timeOfDayNowIn: #'Pacific/Honolulu'}"	| ticksNow gregorianSecondsNow nanosecondsSinceSecond |	ticksNow := systemClock ticksNowSinceSystemClockEpoch.	nanosecondsSinceSecond := 		includeNanoseconds 			ifTrue: [systemClock nanosecondsSinceSecondFromTicks: ticksNow]			ifFalse: [0].	gregorianSecondsNow := (systemClock secondsFromTicks: ticksNow) + secondsFromGregorianEpochUpToSystemClockEpoch.	^(self 		mutableTimeOfDayFromUTSecondsSinceGregorianEpoch: gregorianSecondsNow 		nanoseconds: nanosecondsSinceSecond 		timeZone: aTimezone) beImmutable</body></methods><methods><class-id>Chronos.UTCalendarClock</class-id> <category>API-Current Dates &amp; Times</category><body package="Chronos-Calendars-Foundation" selector="utNow">utNow	"Answer a DateAndTime (a point-in-time value) representing the current date and time, in the receiver's calendar, relative to the UT timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock utNow}"	"{Calendar julian clock utNow}"	| ticksNow |	ticksNow := systemClock ticksNowSinceSystemClockEpoch.	^DateAndTimeFactory basicNew		basicSetCalendar: calendar;		basicSetTimeZone: ChronosTimezone universal;		setNanosecondsSinceSecond: (systemClock nanosecondsSinceSecondFromTicks: ticksNow);		basicSetSecondsSinceEpoch: (systemClock secondsFromTicks: ticksNow) + secondsFromCalendarEpochUpToSystemClockEpoch;		canonicalizeFromUT;		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="utTimeOfDayNow">utTimeOfDayNow	"Answer a time-of-day value representing the current time-of-day, in the receiver's calendar, and relative to the UT timezone."	"{Calendar gregorian clock utTimeOfDayNow}"	"{Calendar julian clock utTimeOfDayNow}"	| ticksNow |	ticksNow := systemClock ticksNowSinceSystemClockEpoch.	^TimeOfDayFactory basicNew		setNanosecondsSinceSecond: (systemClock nanosecondsSinceSecondFromTicks: ticksNow);		setSecondsSinceStartOfDay: ((systemClock secondsFromTicks: ticksNow)) "\\ SecondsPerDay";		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="utToday">utToday	"Answer a DateAndTime (a point-in-time value) representing the first moment of today's date, in the receiver's calendar, relative to the UT timezone, and with invariant-to-UT semantics."	"{Calendar gregorian clock utToday}"	"{Calendar julian clock utToday}"	| seconds secondsDiv128 daysSinceEpoch |	seconds := (systemClock secondsFromTicks: systemClock ticksNowSinceSystemClockEpoch) + secondsFromCalendarEpochUpToSystemClockEpoch.	secondsDiv128 := seconds bitShift: -7. "Bit shifting is faster than LargeInteger math."	daysSinceEpoch := secondsDiv128 // 675. "128 * 675 = 86400"	^DateAndTimeFactory basicNew		basicSetCalendar: calendar;		basicSetTimeZone: ChronosTimezone universal;		setNanosecondsSinceSecond: 0;		basicSetSecondsSinceStartOfDay: 0;		basicSetDaysSinceEpoch: daysSinceEpoch;		canonicalizeFromUT;		beImmutable</body></methods><methods><class-id>Passport.VWAbstractFileUrlFacade</class-id> <category>testing</category><body package="Passport-Kernel-VW" selector="syntaxPermitsUserCredentials">syntaxPermitsUserCredentials	^true</body></methods><methods><class-id>Passport.VWAbstractFileUrlFacade</class-id> <category>directory services</category><body package="Passport-Kernel-VW" selector="deleteResource:">deleteResource: operand	"Delete the resource (e.g., a file) named/identified by &lt;operand&gt;. If the resource named/identified by &lt;operand&gt; does not exist, raise an exception."	operand delete</body><body package="Passport-Kernel-VW" selector="makeDirectory:">makeDirectory: operand	"Create a directory named &lt;operand&gt;. If the resource named/identified by &lt;operand&gt; already exists, raise an exception. A 'directory'  is a resource that serves as a namespace containing other resources."	operand makeDirectory</body><body package="Passport-Kernel-VW" selector="resourceExists:">resourceExists: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; exists"	^[operand exists] on: Error do: [:ex | ex return: false]</body><body package="Passport-Kernel-VW" selector="resourceIsDirectory:">resourceIsDirectory: operand	"Answer whether the resource (e.g., a file) named/identified by &lt;operand&gt; is a directory.  A resource is a directory if it acts as a namespace containing other resources."	^operand isDirectory</body><body package="Passport-Kernel-VW" selector="sizeOfResource:">sizeOfResource: operand	"Answer the size (in bytes) of the resource (e.g., a file) named/identified by &lt;operand&gt;"	^operand fileSize</body></methods><methods><class-id>Passport.VWAbstractFileUrlFacade</class-id> <category>stream creation</category><body package="Passport-Kernel-VW" selector="newExternalWriteStream:mode:check:type:">newExternalWriteStream: operand mode: mode check: enforceExistentialConstraint type: fileType	^fileType == #text 		ifTrue: [operand writeStream]		ifFalse: [operand binaryWriteStream]</body></methods><methods><class-id>Chronos.ISO8601PrintPolicy</class-id> <category>printing-time zones</category><body package="Chronos-Printing" selector="printTimeZoneZeroOffsetWithPrefix:elementSeparator:on:">printTimeZoneZeroOffsetWithPrefix: prefix elementSeparator: elementSeparator on: stream 	stream nextPut: $Z</body></methods><methods><class-id>Chronos.ISO8601PrintPolicy</class-id> <category>accessing--punctuation characters</category><body package="Chronos-Printing" selector="durationDayHourSeparator">durationDayHourSeparator	^$T</body><body package="Chronos-Printing" selector="durationElementSeparator">durationElementSeparator	^nil</body><body package="Chronos-Printing" selector="durationPadChar">durationPadChar	^nil</body></methods><methods><class-id>Chronos.ISO8601PrintPolicy</class-id> <category>testing</category><body package="Chronos-Printing" selector="suppressesZeroValuedDurationElements">suppressesZeroValuedDurationElements	^true</body></methods><methods><class-id>Chronos.ISO8601PrintPolicy</class-id> <category>printing-durations</category><body package="Chronos-Printing" selector="printDuration:on:">printDuration: aDuration on: stream	stream nextPut: $P.	self 		printDurationElementsFromSeconds: aDuration asSeconds		nanoseconds: aDuration nanosecondsSinceSecond		isPrefixed: false		dayHourSeparator: self durationDayHourSeparator		hmsSeparator: self durationElementSeparator		padWith: self durationPadChar		appendElementNames: self showsNamesOfDurationElements		suppressZeroValuedElements: self suppressesZeroValuedDurationElements		on: stream</body><body package="Chronos-Printing" selector="printZeroDurationPadWith:appendElementNames:on:">printZeroDurationPadWith: padChar appendElementNames: showNames on: stream 	ChronosFunction  		print: 0		paddedWith: padChar		to: 2		on: stream.	stream nextPut: $S</body></methods><methods><class-id>Chronos.ISO8601PrintPolicy class</class-id> <category>accessing</category><body package="Chronos-Printing" selector="default">default	^ChronosPrintPolicy iso8601</body></methods><methods><class-id>Chronos.ISO8601PrintPolicy class</class-id> <category>private</category><body package="Chronos-Printing" selector="newRegistry">newRegistry	^self superclass registry</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>enumerating</category><body package="Chronos-Semantic Dates" selector="semanticDaysOfWeekDo:">semanticDaysOfWeekDo: block2 	"SemanticDatePolicy unitedStates semanticDaysOfWeekDo: [:semanticKey :ansiDayOfWeekOrdinal | Transcript cr; show: semanticKey printString; show: ' | '; show: ansiDayOfWeekOrdinal printString]"	1 to: dayOfWeekSemanticKeys size		do: 			[:dayOfWeek | 			| semanticKeySet |			semanticKeySet := dayOfWeekSemanticKeys at: dayOfWeek.			semanticKeySet == nil ifFalse: [semanticKeySet do: [:semanticKey | block2 value: semanticKey value: dayOfWeek]]]</body><body package="Chronos-Semantic Dates" selector="semanticDaysOfWeekFrom:through:do:">semanticDaysOfWeekFrom: minDateOriginal through: maxDateOriginal do: block2 	"{Transcript cr.	SemanticDatePolicy default 		semanticDaysOfWeekFrom: YearMonthDay today 		through: (YearMonthDay today addingMonths: 3) 		do: [:semanticKey :date | Transcript cr; show: (date printStringUsing: #rfc2822)]}"	| minDate maxDate |	minDate := minDateOriginal as: effectiveYearCalendar.	maxDate := maxDateOriginal as: effectiveYearCalendar.	self semanticDaysOfWeekDo: 			[:semanticKey :ansiDayOfWeekOrdinal | 			| delta startDate endDate |			delta := minDate ansiDayOfWeekOrdinal - ansiDayOfWeekOrdinal.			delta &gt; 0 ifTrue: [delta := delta - DaysPerWeek].			startDate := minDate subtractingDays: delta.			delta := ansiDayOfWeekOrdinal - maxDate ansiDayOfWeekOrdinal.			delta &gt; 0 ifTrue: [delta := delta - DaysPerWeek].			endDate := maxDate addingDays: delta.			startDate &lt;= endDate 				ifTrue: 					[startDate 						through: endDate						every: 1						weeksDo: [:date | block2 value: semanticKey value: date]]]</body><body package="Chronos-Semantic Dates" selector="semanticDaysOfWeekInYear:do:">semanticDaysOfWeekInYear: year do: block2 	self semanticDaysOfWeekDo: 			[:semanticKey :ansiDayOfWeekOrdinal | 			| startDate |			startDate := 				(WeekOfMonthDayOfWeekFactory 					month: 1					week: 1					dayOfWeek: ansiDayOfWeekOrdinal					calendar: effectiveYearCalendar) inYear: year.			startDate 				through: (DateFactory year: startDate year day: startDate daysInYear calendar: effectiveYearCalendar)				every: 1 weeksDo: [:date | block2 value: semanticKey value: date]].</body><body package="Chronos-Semantic Dates" selector="semanticKeysFor:detect:ifNone:">semanticKeysFor: aDate detect: predicate ifNone: ifNone	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 1985 month: January day: 21) detect: [:semanticKey | true] ifNone: [#normalDay]}"	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2004 month: December day: 31) detect: [:semanticKey | true] ifNone: [#normalDay]}"	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2005 month: January day: 1) detect: [:semanticKey | true] ifNone: [#normalDay]}"	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2005 month: January day: 2) detect: [:semanticKey | true] ifNone: [#normalDay]}"	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2005 month: December day: 26) detect: [:semanticKey | true] ifNone: [#normalDay]}"	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2005 month: December day: 31) detect: [:semanticKey | true] ifNone: [#normalDay]}"	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2006 month: January day: 1) detect: [:semanticKey | true] ifNone: [#normalDay]}"	"{SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2006 month: January day: 2) detect: [:semanticKey | true] ifNone: [#normalDay]}"	self semanticKeysFor: aDate do: [:semanticKey | (predicate value: semanticKey) ifTrue: [^semanticKey]].	^ifNone value</body><body package="Chronos-Semantic Dates" selector="semanticKeysFor:do:">semanticKeysFor: aDate do: block1	"{| set |	set := Set new.	SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 1985 month: January day: 20) do: [:semanticKey | set add: semanticKey].	set}"	"{| set |	set := Set new.	SemanticDatePolicy unitedStates semanticKeysFor: (DateFactory year: 2004 month: December day: 31) do: [:semanticKey | set add: semanticKey].	set} Note: This example answers both NewYearsDay AND NewYearsEve, because the observance rule for NewYearsDay adjusts observance to Friday when the nominal date is a Saturday."	self forEachSemanticAnnualEventOccurringOn: aDate do: [:semanticKey :date | block1 value: semanticKey].	self forEachSemanticUniqueEventOccurringOn: aDate do: [:semanticKey :date | block1 value: semanticKey].	self forEachSemanticWeeklyEventOccurringOnTheDayOfWeekOf: aDate do: [:semanticKey :date | block1 value: semanticKey].</body><body package="Chronos-Semantic Dates" selector="semanticUniqueDatesDo:">semanticUniqueDatesDo: block2	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy nyse semanticUniqueDatesDo:[:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	semanticUniqueDates do: [:set | set do: [:association | block2 value: association key value: association value]]</body><body package="Chronos-Semantic Dates" selector="semanticUniqueDatesFrom:through:do:">semanticUniqueDatesFrom: minDate through: maxDate do: block2 	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy nyse 		semanticUniqueDatesFrom: (YearMonthDay year: 1969 month: July day: 1) through: (YearMonthDay year: 1977 month: October day: 15)		do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	minDate daysSinceUnificationEpoch to: maxDate daysSinceUnificationEpoch		do: 			[:daysSinceUnificationEpoch | 			| set |			set := semanticUniqueDates at: daysSinceUnificationEpoch ifAbsent: [].			set == nil 				ifFalse: 					[set do: [:association | block2 value: association key value: association value]]]</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>enumerating-rules</category><body package="Chronos-Semantic Dates" selector="semanticAnnualDateRulesDo:">semanticAnnualDateRulesDo: block1 	"Evaluate &lt;block1 value: semanticAnnualDateRule&gt; for all SemanticAnnualDateRules registered with the receiver. 	Note: The sender should be prepared to handle more than one SemanticAnnualDateRule with the same semanticKey (but each with a different effectiveYear.)"	semanticAnnualDates 		do: [:rule | rule withSelfAndAllRightwardLinksDo: block1]</body><body package="Chronos-Semantic Dates" selector="semanticAnnualDateRulesEffectiveInYear:detect:ifNone:">semanticAnnualDateRulesEffectiveInYear: year detect: predicate ifNone: ifNone 	semanticAnnualDates do: 			[:rule | 			| effectiveRule |			effectiveRule := rule effectiveRuleInYear: year ifNone: [].			effectiveRule == nil 				ifFalse: [(predicate value: effectiveRule) ifTrue: [^effectiveRule]]].	^ifNone value</body><body package="Chronos-Semantic Dates" selector="semanticAnnualDateRulesEffectiveInYear:do:">semanticAnnualDateRulesEffectiveInYear: year do: block1 	"Evaluate &lt;block1 value: semanticAnnualDate&gt; (for each SemanticAnnualDateRule registered with the receiver) that was in effect in the given &lt;year.&gt;"	semanticAnnualDates do: 			[:rule | 			| effectiveRule |			effectiveRule := rule effectiveRuleInYear: year ifNone: [].			effectiveRule == nil ifFalse: [block1 value: effectiveRule]]</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>initialize-release</category><body package="Chronos-Semantic Dates" selector="addSemanticAnnualDateRule:">addSemanticAnnualDateRule: aSemanticAnnualDateRule 	"There can only be one SemanticAnnualDate with the same key and effectiveYear.  Subsequent registrations of the same key/effectiveYear override any previous registrations."	| currentRule |	self assertMutability.	currentRule := 		semanticAnnualDates 				at: aSemanticAnnualDateRule key				ifAbsent: 					[^semanticAnnualDates at: aSemanticAnnualDateRule key						put: aSemanticAnnualDateRule beImmutable].	semanticAnnualDates 		at: aSemanticAnnualDateRule key		put: (currentRule asListSortedInCanonicalOrderByTransitionTimeAdding: aSemanticAnnualDateRule) beImmutable</body><body package="Chronos-Semantic Dates" selector="at:putUniqueDate:">at: semanticKey putUniqueDate: uniqueDate	| canonicalDate |	self assertMutability.	canonicalDate := uniqueDate asDate.	(semanticUniqueDates at: canonicalDate daysSinceUnificationEpoch ifAbsentPut: [Set new]) add: semanticKey-&gt;canonicalDate</body><body package="Chronos-Semantic Dates" selector="beDefault">beDefault	Default := self</body><body package="Chronos-Semantic Dates" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	effectiveYearCalendar == nil 		ifTrue: [effectiveYearCalendar := AnsiStandardCalendar]</body><body package="Chronos-Semantic Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable." 	super initialize.	effectiveYearCalendar := AnsiStandardCalendar.	dayOfWeekSemanticKeys := ChronosFunction ansiValueOfArrayLiteral: #(nil nil nil nil nil nil nil).	semanticAnnualDates := IdentityDictionary new.	semanticUniqueDates := Dictionary new.</body><body package="Chronos-Semantic Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self 			setEffectiveYearCalendar: (literalArray at: 3);		setDayOfWeekSemanticKeys: (literalArray at: 4).	semanticAnnualDates := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 5).	semanticUniqueDates := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 6)</body><body package="Chronos-Semantic Dates" selector="setDayOfWeekSemanticKeys:">setDayOfWeekSemanticKeys: anArrayOfSymbols	self assertMutability.	dayOfWeekSemanticKeys := ChronosFunction ansiValueOfArrayLiteral: anArrayOfSymbols.</body><body package="Chronos-Semantic Dates" selector="setEffectiveYearCalendar:">setEffectiveYearCalendar: aCalendar	self assertMutability.	effectiveYearCalendar := Calendar referencedBy: aCalendar.</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>accessing</category><body package="Chronos-Semantic Dates" selector="dayOfWeekSemanticKeys">dayOfWeekSemanticKeys	^dayOfWeekSemanticKeys copy</body><body package="Chronos-Semantic Dates" selector="effectiveYearCalendar">effectiveYearCalendar	^effectiveYearCalendar</body><body package="Chronos-Semantic Dates" selector="semanticAnnualDateRuleAt:effectiveInYear:ifNone:">semanticAnnualDateRuleAt: semanticKey effectiveInYear: aYear ifNone: ifNone 	"(SemanticDatePolicy unitedStates semanticAnnualDateRuleAt: #NewYearsEve effectiveInYear: 2005 ifNone: []) 		observedDateInYear: 2005 ifNone: []"	^(semanticAnnualDates at: semanticKey ifAbsent: [^ifNone value]) 		effectiveRuleInYear: aYear		ifNone: ifNone</body><body package="Chronos-Semantic Dates" selector="semanticUniqueDates">semanticUniqueDates	^semanticUniqueDates</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>queries</category><body package="Chronos-Semantic Dates" selector="forEachSemanticAnnualEventOccurringOn:do:">forEachSemanticAnnualEventOccurringOn: aDate do: annualSemanticDateAction 	| dateInCalendar duplicates  |	dateInCalendar := aDate as: effectiveYearCalendar.	duplicates := IdentitySet new.	self semanticAnnualDateRulesEffectiveInYear: dateInCalendar year		do: 			[:rule | 			(duplicates includes: rule key) 				ifFalse: 					[(rule occursOn: dateInCalendar) 						ifTrue: [annualSemanticDateAction value: rule key value: aDate].					duplicates add: rule key]].</body><body package="Chronos-Semantic Dates" selector="forEachSemanticUniqueEventOccurringOn:do:">forEachSemanticUniqueEventOccurringOn: aDate do: semanticUniqueDateAction 	| mappingSet  |	mappingSet := semanticUniqueDates at: aDate daysSinceUnificationEpoch ifAbsent: [^nil].	mappingSet do: [:association | semanticUniqueDateAction value: association key value: association value].</body><body package="Chronos-Semantic Dates" selector="forEachSemanticWeeklyEventOccurringOnTheDayOfWeekOf:do:">forEachSemanticWeeklyEventOccurringOnTheDayOfWeekOf: aDate do: dayOfWeekSemanticAction 	^dayOfWeekSemanticKeys == nil 		ifFalse: 			[| semanticKeySet |			semanticKeySet := dayOfWeekSemanticKeys at: aDate ansiDayOfWeekOrdinal.			semanticKeySet == nil ifFalse: [semanticKeySet do: [:semanticKey | dayOfWeekSemanticAction value: semanticKey value: aDate]]]</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>enumerating-nominal dates</category><body package="Chronos-Semantic Dates" selector="nominalAnnualEventOccurenceDatesFrom:through:do:">nominalAnnualEventOccurenceDatesFrom: minDateOriginal through: maxDateOriginal do: block2 	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy unitedStates 		nominalAnnualEventOccurenceDatesFrom: (YearMonthDay year: 2006 month: 4 day: 1) 		through: (YearMonthDay year: 2007 month: 9 day: 30) 		do: [:semanticKey :date | list add: date-&gt;semanticKey].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab; show: assoc value]}" 	| minDate maxDate year maxYear |	minDate := minDateOriginal as: effectiveYearCalendar.	maxDate := maxDateOriginal as: effectiveYearCalendar.	year := minDate year.	maxYear := maxDate year.	year = maxYear 		ifTrue: 			[self 				nominalAnnualEventOccurenceDatesInYear: year				do: 					[:semanticKey :date | 					(date &gt;= minDate and: [date &lt;= maxDate]) 						ifTrue: [block2 value: semanticKey value: date]]]		ifFalse: 			[year &gt; maxYear ifTrue: [^self].			self 				nominalAnnualEventOccurenceDatesInYear: year				do: [:semanticKey :date | date &gt;= minDate ifTrue: [block2 value: semanticKey value: date]].			year + 1 to: maxYear - 1 do: 				[:y | self nominalAnnualEventOccurenceDatesInYear: y do: block2].			self 				nominalAnnualEventOccurenceDatesInYear: maxYear				do: [:semanticKey :date | date &lt;= maxDate ifTrue: [block2 value: semanticKey value: date]]]</body><body package="Chronos-Semantic Dates" selector="nominalAnnualEventOccurenceDatesInYear:do:">nominalAnnualEventOccurenceDatesInYear: year do: block2 	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy default nominalAnnualEventOccurenceDatesInYear: 2005 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}" 	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy nyse nominalAnnualEventOccurenceDatesInYear: 2005 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	self semanticAnnualDateRulesEffectiveInYear: year		do: [:rule | (rule occursInYear: year) ifTrue: [block2 value: rule key value: (rule nominalDateInYear: year)]]</body><body package="Chronos-Semantic Dates" selector="nominalEventOccurenceDatesFrom:through:do:">nominalEventOccurenceDatesFrom: minDateOriginal through: maxDateOriginal do: block2 	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy default nominalEventOccurenceDatesInYear: 2005 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy nyse nominalEventOccurenceDatesInYear: 2004 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy nyse nominalEventOccurenceDatesInYear: 2006 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	| minDate maxDate |	minDate := minDateOriginal as: effectiveYearCalendar.	maxDate := maxDateOriginal as: effectiveYearCalendar.	self semanticDaysOfWeekFrom: minDate through: maxDate do: block2.	self nominalAnnualEventOccurenceDatesFrom: minDate through: maxDate do: block2.	self 		semanticUniqueDatesFrom: minDate		through: maxDate		do: block2</body><body package="Chronos-Semantic Dates" selector="nominalEventOccurenceDatesInYear:do:">nominalEventOccurenceDatesInYear: year do: block2 	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy default nominalEventOccurenceDatesInYear: 2005 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy nyse nominalEventOccurenceDatesInYear: 2004 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a value &lt; b value].	SemanticDatePolicy nyse nominalEventOccurenceDatesInYear: 2006 do: [:semanticKey :date | list add: semanticKey-&gt;date].	Transcript cr.	list do: [:assoc | Transcript cr; show: (assoc value printStringUsing: #rfc2822); show: ':'; tab; show: assoc key]}"	self semanticDaysOfWeekInYear: year do: block2.	self nominalAnnualEventOccurenceDatesInYear: year do: block2.	self 		semanticUniqueDatesFrom: (DateFactory year: year day: 1 calendar: effectiveYearCalendar)		through: (DateFactory year: year day: (effectiveYearCalendar daysInYear: year) calendar: effectiveYearCalendar)		do: block2</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>enumerating-observed dates</category><body package="Chronos-Semantic Dates" selector="observedAnnualEventOccurenceDatesFrom:through:do:">observedAnnualEventOccurenceDatesFrom: minDateOriginal through: maxDateOriginal do: block3 	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy unitedStates 		observedAnnualEventOccurenceDatesFrom: (YearMonthDay year: 2006 month: 4 day: 1) 		through: (YearMonthDay year: 2007 month: 9 day: 30) 		do: [:semanticKey :date :observanceType | list add: date-&gt;(Array with: semanticKey with: observanceType)].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}" 	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse 		observedAnnualEventOccurenceDatesFrom: (YearMonthDay year: 1969 month: 4 day: 1) 		through: (YearMonthDay year: 1973 month: 9 day: 30) 		do: [:semanticKey :date :observanceType | list add: date-&gt;(Array with: semanticKey with: observanceType)].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}" 	| minDate maxDate year maxYear |	minDate := minDateOriginal as: effectiveYearCalendar.	maxDate := maxDateOriginal as: effectiveYearCalendar.	year := minDate year.	maxYear := maxDate year.	year = maxYear 		ifTrue: 			[self 				observedAnnualEventOccurenceDatesInYear: year				do: 					[:semanticKey :date :observanceType | 					(date &gt;= minDate and: [date &lt;= maxDate]) 						ifTrue: [block3 value: semanticKey value: date value: observanceType]]]		ifFalse: 			[year &gt; maxYear ifTrue: [^self].			self 				observedAnnualEventOccurenceDatesInYear: year				do: [:semanticKey :date :observanceType | date &gt;= minDate ifTrue: [block3 value: semanticKey value: date value: observanceType]].			year + 1 to: maxYear - 1 do: 				[:y | self observedAnnualEventOccurenceDatesInYear: y do: block3].			self 				observedAnnualEventOccurenceDatesInYear: maxYear				do: [:semanticKey :date :observanceType | date &lt;= maxDate ifTrue: [block3 value: semanticKey value: date value: observanceType]]]</body><body package="Chronos-Semantic Dates" selector="observedAnnualEventOccurenceDatesInYear:do:">observedAnnualEventOccurenceDatesInYear: year do: block3 	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy default observedAnnualEventOccurenceDatesInYear: 2004 do: 		[:semanticKey :date :observanceType | list add: date-&gt;(Array with: semanticKey with: observanceType)].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse observedAnnualEventOccurenceDatesInYear: 2004 do: 		[:semanticKey :date :observanceType | list add: date-&gt;(Array with: semanticKey with: observanceType)].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse observedAnnualEventOccurenceDatesInYear: 2006 do: 		[:semanticKey :date :observanceType | list add: date-&gt;(Array with: semanticKey with: observanceType)].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ': '; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	self semanticAnnualDateRulesEffectiveInYear: year		do: 			[:rule | 			(rule occursInYear: year) 				ifTrue: 					[rule 						observanceDateAndTypeInYear: year						into: [:date :observanceType | block3 value: rule key value: date value: observanceType]						ifNone: []]]</body><body package="Chronos-Semantic Dates" selector="observedEventOccurenceDatesFrom:through:do:">observedEventOccurenceDatesFrom: minDateOriginal through: maxDateOriginal do: block3 	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse 		observedEventOccurenceDatesFrom: (YearMonthDay year: 2000 month: 1 day: 14) 		through: (YearMonthDay year: 2006 month: 1 day: 12) 		do: [:semanticKey :date :observanceType | semanticKey == #weekend ifFalse: [list add: date-&gt;(Array with: semanticKey with: observanceType)]].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}" 	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse 		observedEventOccurenceDatesFrom: (YearMonthDay year: 1969 month: 4 day: 1) 		through: (YearMonthDay year: 1973 month: 9 day: 30) 		do: [:semanticKey :date :observanceType | semanticKey == #weekend ifFalse: [list add: date-&gt;(Array with: semanticKey with: observanceType)].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]]}" 	| minDate maxDate |	minDate := minDateOriginal as: effectiveYearCalendar.	maxDate := maxDateOriginal as: effectiveYearCalendar.	self semanticDaysOfWeekFrom: minDate through: maxDate do: [:semanticKey :date | block3 value: semanticKey value: date value: #nominal].	self observedAnnualEventOccurenceDatesFrom: minDate through: maxDate do: block3.	self 		semanticUniqueDatesFrom: minDate		through: maxDate		do: [:semanticKey :date | block3 value: semanticKey value: date value: #nominal]</body><body package="Chronos-Semantic Dates" selector="observedEventOccurenceDatesInYear:do:">observedEventOccurenceDatesInYear: year do: block3 	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy default observedEventOccurenceDatesInYear: 2004 do: 		[:semanticKey :date :observanceType | semanticKey == #weekend ifFalse: [list add: date-&gt;(Array with: semanticKey with: observanceType)]].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse observedEventOccurenceDatesInYear: 2001 do: 		[:semanticKey :date :observanceType | semanticKey == #weekend ifFalse: [list add: date-&gt;(Array with: semanticKey with: observanceType)]].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse observedEventOccurenceDatesInYear: 1969 do: 		[:semanticKey :date :observanceType | semanticKey == #weekend ifFalse: [list add: date-&gt;(Array with: semanticKey with: observanceType)]].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse observedEventOccurenceDatesInYear: 1933 do: 		[:semanticKey :date :observanceType | semanticKey == #weekend ifFalse: [list add: date-&gt;(Array with: semanticKey with: observanceType)]].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	"{| list |	list := SortedCollection sortBlock: [:a :b | a key &lt; b key].	SemanticDatePolicy nyse observedEventOccurenceDatesInYear: 1914 do: 		[:semanticKey :date :observanceType | semanticKey == #weekend ifFalse: [list add: date-&gt;(Array with: semanticKey with: observanceType)]].	Transcript cr.	list do: [:assoc | 		Transcript cr; show: (assoc key printStringUsing: #rfc2822); show: ':'; tab. 		assoc value do: [:key | 			key == #nominal 				ifFalse: 					[key == #observed 						ifTrue: 							[Transcript show: ' ('; show: key; show: ')'] 						ifFalse: [Transcript show: key]]]]}"	self semanticDaysOfWeekInYear: year do: [:semanticKey :date | block3 value: semanticKey value: date value: #nominal].	self observedAnnualEventOccurenceDatesInYear: year do: block3.	self 		semanticUniqueDatesFrom: (DateFactory year: year day: 1 calendar: effectiveYearCalendar)		through: (DateFactory year: year day: (effectiveYearCalendar daysInYear: year) calendar: effectiveYearCalendar)		do: [:semanticKey :date | block3 value: semanticKey value: date value: #nominal]</body></methods><methods><class-id>Chronos.SemanticDatePolicy</class-id> <category>private</category><body package="Chronos-Semantic Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: effectiveYearCalendar registrationKey;		nextPut: dayOfWeekSemanticKeys;		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: semanticAnnualDates);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: semanticUniqueDates)</body><body package="Chronos-Semantic Dates" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	super postCopy.	dayOfWeekSemanticKeys := dayOfWeekSemanticKeys copy.	semanticAnnualDates := semanticAnnualDates copy.	semanticUniqueDates := semanticUniqueDates copy.</body></methods><methods><class-id>Chronos.SemanticDatePolicy class</class-id> <category>accessing</category><body package="Chronos-Semantic Dates" selector="default">default	Default == nil ifTrue: [^self unitedStates].	^Default</body><body package="Chronos-Semantic Dates" selector="defaultDayOfWeekSemanticKeys">defaultDayOfWeekSemanticKeys	^#(#(weekend) nil nil nil nil nil #(weekend)) "Indexed by ANSI day-of-week ordinals (Sunday=1, Saturday=7)"</body><body package="Chronos-Semantic Dates" selector="nyse">nyse	"SemanticDatePolicy nyse"	NYSEHolidays == nil 		ifTrue: 			[NYSEHolidays := self newNYSEHolidays.			NYSEHolidays registerAs: #NYSE ifPresent: []].	^NYSEHolidays</body><body package="Chronos-Semantic Dates" selector="unitedStates">unitedStates	"SemanticDatePolicy unitedStates"	USDefault == nil 		ifTrue: 			[USDefault := self newUSDefault.			(self at: ChronosLocale unitedStates registrationKey ifAbsent: []) release.			USDefault registerAs: ChronosLocale unitedStates registrationKey ifPresent: []].	^USDefault</body><body package="Chronos-Semantic Dates" selector="usFederalHolidaySemanticKeys">usFederalHolidaySemanticKeys	"Well-known (standard, canonical in the context of Chronos) semantic keys of the semantic dates of United States Federal holidays (as of the time this was written or last updated.)  Although these are all holidays for the US Federal government, they may not be holidays for your employer, your bank, your school or your community (for example, you may not live in the United States, or you may work for a hospital that never closes.)"	"SemanticDatePolicy usFederalHolidaySemanticKeys"	USFederalHolidaySemanticKeys == nil 		ifTrue: 			[| set |			set := Set new.			set 				addAll: #(#NewYearsDay #MartinLutherKingDay #InaugurationDay #WashingtonsBirthday #MemorialDay #IndependenceDay #LaborDay #ColumbusDay #VeteransDay #Thanksgiving #Christmas).			USFederalHolidaySemanticKeys := set].	^USFederalHolidaySemanticKeys</body></methods><methods><class-id>Chronos.SemanticDatePolicy class</class-id> <category>utilities/services</category><body package="Chronos-Semantic Dates" selector="registerAnnuallyRecurringNYSEHolidaysIn:">registerAnnuallyRecurringNYSEHolidaysIn: aSemanticDatePolicy	| nonWeekendObservanceRule nonWeekendNonEndOfMonthObservanceRule semanticAnnualDate newYearsDay thanksgiving christmas |	nonWeekendObservanceRule := SemanticDateObservanceRule dayOfWeekPolicy: #(0 -1 0 0 0 1 0).	"If a Date is a Monday and the previous Sunday is a semantic day, then impute that Monday as virtually the same semantic day; if a Date is a Friday and the following Saturday is a semantic day, then impute that Friday as virtually the same semantic day; otherwise, don't impute any virtual semantic days."	nonWeekendNonEndOfMonthObservanceRule := SemanticDateObservanceRule dayOfWeekPolicy: #(0 -1 0 0 0 1 0) dayOfMonthConstraints: #observedOnlyIfNominal.	newYearsDay := 		SemanticAnnualDateRule 			semanticKey: #NewYearsDay 			effectiveYear: 1792 			nominalAnnualDate: AnnualDate gregorianNewYear 			observanceRule: nonWeekendNonEndOfMonthObservanceRule.	"The first day of the year is typically a holiday in most cultures--and that has been so for a very long time.  The effective year used here is the year that the Gregorian Calendar became the official calendar of the British Empire.  Before 1753, New Year's day would have been determined according to the Julian Calendar in the American Colonies."	aSemanticDatePolicy addSemanticAnnualDateRule: newYearsDay. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #MartinLutherKingDay      "Honoring Dr. Martin Luther King--actual birthday January 15"			effectiveYear: 1998			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: January week: 3 dayOfWeek: Monday)			observanceRule: nil. "Martin Luther King Day always occurs on the same day of the week."	"Established as a Federal legal holiday by Act of Congress in 1983 (signed into law by President Reagan in a Rose Garden ceremony in that year,) but was not observed until 1986-Jan-20."		aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #LincolnsBirthday 			effectiveYear: 1896 "First formal observance by US Congress"			nominalAnnualDate: (DayOfMonthFactory month: February day: 12)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1954 dayOfWeekPolicy: #(0 -1 0 0 0 1 0)).	"Normal business day in most of the United States, although it has been (and still is) a legal holiday in some States."	"A NYSE holiday from 1896 through 1953 (I have confirmed this by looking through a dataset I have containing daily bars of the open, close, high and low prices for the DJIA back to 1900.)"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #WashingtonsBirthday 			effectiveYear: 1796 			nominalAnnualDate: (DayOfMonthFactory month: February day: 22)			observanceRule: nonWeekendObservanceRule. "Before 1968, the day of week was variable."	"Washington’s Birthday was celebrated publicly for the first time in 1796, the last year of his presidency.  Washington's Birthday became a US Federal Holiday in 1885. 	Note that Washington was born in 1732--at a time when the Julian Calendar was the official calendar in his home jurisdiction (in fact, throughought the American Colonies, which didn't switch to the Gregorian Calendar until 1752.)  The date of his birth in the Julian Calendar was {(DateFactory year: 1732 month: February day: 22 calendar: Calendar gregorian) asJulian localePrintString} = February 11, 1732 [Julian]."		aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #WashingtonsBirthday 			effectiveYear: 1971 			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: February week: 3 dayOfWeek: Monday)			observanceRule: nil. "Since 1971, President's Day always occurs on the same day of the week."	"Set as the third Monday in February by Act of Congress in 1968 (effective 1971.)"		"As of 2004, Washington's Birthday is still the official name of this holiday, in spite of the fact that it usually doesn't actually fall on his birthday."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #GoodFriday 			effectiveYear: 1792			nominalAnnualDate: (GregorianEaster daysOffset: -2) 			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1898).	"The NYSE has closed for Good Friday every year except in 1898, 1906 and 1907."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #GoodFriday 			effectiveYear: 1899			nominalAnnualDate: (GregorianEaster daysOffset: -2) 			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1906).	"The NYSE has closed for Good Friday every year except in 1898, 1906 and 1907."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #GoodFriday 			effectiveYear: 1908			nominalAnnualDate: (GregorianEaster daysOffset: -2) 			observanceRule: nil.	"The NYSE has closed for Good Friday every year except in 1898, 1906 and 1907."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #MemorialDay 			effectiveYear: 1873 			nominalAnnualDate: (DayOfMonthFactory month: May day: 30)			observanceRule: nonWeekendObservanceRule.	"Established as a Federal legal holiday (affecting Federal employees only) by Act of Congress. In 1888, Congress added all persons in the District of Columbia to the affected group."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #MemorialDay 			effectiveYear: 1971 			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: May week: WeekOfMonthDayOfWeekFactory lastWeekOfMonth dayOfWeek: Monday)			observanceRule: nil. "Since 1971, Memorial Day always occurs on the same day of the week."	"Date rule of Memorial Day changed by Act of Congress in 1968 (effective 1971.)"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #FlagDay 			effectiveYear: 1916 "Established by Presidential Proclamation (Woodrow Wilson.)"			nominalAnnualDate: (DayOfMonthFactory month: June day: 14)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1954 dayOfWeekPolicy: #(0 -1 0 0 0 1 0)).	"A NYSE holiday through 1953 (I have confirmed this by looking through a dataset I have containing daily bars of the open, close, high and low prices for the DJIA back to 1900.)"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #IndependenceDay 			effectiveYear: 1792 			nominalAnnualDate: (DayOfMonthFactory month: July day: 4)			observanceRule: nonWeekendObservanceRule.	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #LaborDay 			effectiveYear: 1887 			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: September week: 1 dayOfWeek: Monday)			observanceRule: nil. "Labor Day always occurs on the same day of the week."	"First observed in New York State in 1882 (where the NYSE operates.) Established as a Federal legal holiday by Act of Congress in 1894."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ColumbusDay			effectiveYear: 1909			nominalAnnualDate: (DayOfMonthFactory month: October day: 12)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1954 dayOfWeekPolicy: #(0 -1 0 0 0 1 0)).	"Made a legal holiday by New York State in 1909. Established as a Federal legal holiday by President Roosevelt."	"A NYSE holiday through 1953 (I have confirmed this by looking through a dataset I have containing daily bars of the open, close, high and low prices for the DJIA back to 1900.)"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ElectionDay 			effectiveYear: 1792 "Second US Presidential Election under the 1789 Constitution, but the first year of operation of NYSE."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: 1 dayOfWeek: Tuesday)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1969). 			"Occurred every year through 1968. This trading holiday was discontinued as of 1984"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ElectionDay 			effectiveYear: 1972 "Second US Presidential Election under the 1789 Constitution, but the first year of operation of NYSE."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: 1 dayOfWeek: Tuesday)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 4 expirationYear: 1984). 			"From 1972 through 1980, only observed for Presidential elections. This trading holiday was discontinued as of 1984"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #VeteransDay "Formerly 'Armistice Day'--corresponds to 'Remembrance Day' in British Commonwealth countries (same date, congruent semantics.)"			effectiveYear: 1918			nominalAnnualDate: (DayOfMonthFactory month: November day: 11)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1919 dayOfWeekPolicy: #(0 -1 0 0 0 1 0)).	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #VeteransDay "Formerly 'Armistice Day'--corresponds to 'Remembrance Day' in British Commonwealth countries (same date, congruent semantics.)"			effectiveYear: 1921			nominalAnnualDate: (DayOfMonthFactory month: November day: 11)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1922 dayOfWeekPolicy: #(0 -1 0 0 0 1 0)).	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #VeteransDay "Formerly 'Armistice Day'--corresponds to 'Remembrance Day' in British Commonwealth countries (same date, congruent semantics.)"			effectiveYear: 1934			nominalAnnualDate: (DayOfMonthFactory month: November day: 11)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 0 expirationYear: 1954 dayOfWeekPolicy: #(0 -1 0 0 0 1 0)).	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	thanksgiving := 		SemanticAnnualDateRule 			semanticKey: #Thanksgiving 			effectiveYear: 1863 "Lincoln's Thanksgiving Rule."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: WeekOfMonthDayOfWeekFactory lastWeekOfMonth dayOfWeek: Thursday)			observanceRule: nil. "Thanksgiving always occurs on the same day of the week."	"Before 1941, the status of Thanksgiving as a legal and/or 'traditional' holiday, and the date of its observance, varied widely within the United States. However, the most common date of observance before 1941 was the **last** Thursday in November (as opposed to the modern rule, which is the **fourth** Thursday.)"	aSemanticDatePolicy addSemanticAnnualDateRule: thanksgiving.  	thanksgiving := 		SemanticAnnualDateRule 			semanticKey: #Thanksgiving 			effectiveYear: 1941 "Roosevelt's Thanksgiving Rule."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: 4 dayOfWeek: Thursday)			observanceRule: nil. "Thanksgiving always occurs on the same day of the week."	"Established as a Federal legal holiday by Act of Congress in 1941."	aSemanticDatePolicy addSemanticAnnualDateRule: thanksgiving.  	christmas := 		SemanticAnnualDateRule 			semanticKey: #Christmas 			effectiveYear: 1792 			nominalAnnualDate: (DayOfMonthFactory month: December day: 25) 			observanceRule: nonWeekendObservanceRule.	"Effective year based on the fact that the Gregorian Calendar became the official calendar of the British Empire in 1752."	aSemanticDatePolicy addSemanticAnnualDateRule: christmas.</body><body package="Chronos-Semantic Dates" selector="registerDefaultUSAnnualSemanticDaysIn:">registerDefaultUSAnnualSemanticDaysIn: aSemanticDatePolicy	"Add a set of well-known (standard, canonical in the context of Chronos) annual semantic dates commonly recognized in the United States to a &lt;aSemanticDatePolicy&gt;. Many of them, but by no means all of them, are United States Federal holidays (as of the time this was written or last updated.)  Holidays for the US Federal government may not be holidays for your employer, your bank, your school or your community (for example, you may not live in the United States, or your job may require that you work on days that are holidays for most other people.)  More importantly, semantic dates are not necessarily holidays to anyone at all.  A semantic date could be someone's birthday, wedding anniversary, tax filing day or annual medical checkup date--whatever dates have special semantic siginificance to someone in some use case (different use cases and/or 'users,' where 'users' might mean individuals, companies, stock exchanges or entire nations, should probably have their own instances of SemanticDatePolicy.) Consequently, whether or not the set of semantic days herein defined is 'complete' is not defined in the absolute sense.  A 'complete' set can only be defined in the context of a particular use case and user base.  	This method's purpose is to provide a set of semantic dates for the United States all of which will be of some siginififcance to most residents of the the UnitedStates (purposely including a few that are not usually non-business days, to emphasize the point that semantic dates are not necessarily non-business days,) and also to provide an example of configuring a SemanticDatePolicy.  For identifying non-business days, the suggested approach is to define and use one or more Sets (for different years, different users, different stock exchanges, etc.) of the semantic keys of those semantic-dates that are non-business days for whatever individual(s), company(ies), organization(s), community(ies) or nation(s) that matter in your use case(s), and perhaps to also define your own SemanticDatePolicy(ies) that reflect the dates and rules needed in your use case(s)."	| nonWeekendObservanceRule inaugurationDayObservanceRule semanticAnnualDate newYearsDay thanksgiving christmas |	nonWeekendObservanceRule := SemanticDateObservanceRule dayOfWeekPolicy: #(0 -1 0 0 0 1 0).	"If a Date is a Monday and the previous Sunday is a semantic day, then impute that Monday as virtually the same semantic day; if a Date is a Friday and the following Saturday is a semantic day, then impute that Friday as virtually the same semantic day; otherwise, don't impute any virtual semantic days."	inaugurationDayObservanceRule := SemanticDateObservanceRule yearBase: 1 period: 4 dayOfWeekPolicy: #(0 -1 0 0 0 0 0). 	"Shift observance to Monday if nominally occurs on Sunday"	newYearsDay := 		SemanticAnnualDateRule 			semanticKey: #NewYearsDay 			effectiveYear: -46 "Start of Julian Calendar."			nominalAnnualDate: (AnnualDate newYearsDayInCalendar: Julian)			observanceRule: nil.	"The first day of the year is typically a holiday in most cultures--and that has been so for a very long time.  The effective year used here is the year that the Gregorian Calendar became the official calendar of the British Empire.  Before 1753, New Year's day would have been determined according to the Julian Calendar in the American Colonies."	aSemanticDatePolicy addSemanticAnnualDateRule: newYearsDay. 	semanticAnnualDate := 		DerivedSemanticAnnualDateRule 			semanticKey: #NewYearsEve			effectiveYear: -46  "Start of Julian Calendar."			derivedFromNominalDateOf: newYearsDay dateTransformer: (SimpleDateTransformer delta: (CalendarDurationFactory years: 1 months: 0 days: -1)).	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	newYearsDay := 		SemanticAnnualDateRule 			semanticKey: #NewYearsDay 			effectiveYear: 1753 			nominalAnnualDate: AnnualDate gregorianNewYear 			observanceRule: nonWeekendObservanceRule.	"The first day of the year is typically a holiday in most cultures--and that has been so for a very long time.  The effective year used here is the year that the Gregorian Calendar became the official calendar of the British Empire.  Before 1753, New Year's day would have been determined according to the Julian Calendar in the American Colonies."	aSemanticDatePolicy addSemanticAnnualDateRule: newYearsDay. 	semanticAnnualDate := 		DerivedSemanticAnnualDateRule 			semanticKey: #NewYearsEve			effectiveYear: 1752 			derivedFromNominalDateOf: newYearsDay dateTransformer: (SimpleDateTransformer delta: (CalendarDurationFactory years: 1 months: 0 days: -1)).	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #JacksonDay      "Celebrates the Battle of New Orleans in 1815 when the United States forces commanded by 													Andrew Jackson defeated the British. This was the last battle of the War of 1812, and was 													actually fought two weeks after the peace treaty was signed (the treaty of Ghent.) Also known 													as Old Hickory's Day and Battle of New Orleans Day."			effectiveYear: 1829					"Became a National Holiday after Jackson became President in 1828."			nominalAnnualDate: (DayOfMonthFactory month: January day: 8)			observanceRule: nil. "Ceased to be observed as holiday after the Civil War--and it was never shifted from the weekend to a weekday."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #InaugurationDay			effectiveYear: 1789			nominalAnnualDate: (DayOfMonthFactory month: March day: 4)			observanceRule: inaugurationDayObservanceRule. "Shift observance to Monday if nominally occurs on Sunday"	"US Federal Holiday."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #InaugurationDay			effectiveYear: 1933 			nominalAnnualDate: (DayOfMonthFactory month: January day: 20)			observanceRule: inaugurationDayObservanceRule. "Shift observance to Monday if nominally occurs on Sunday"	"US Federal Holiday--date changed by Consitutional Ammendment."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #MartinLutherKingDay      "Honoring Dr. Martin Luther King--actual birthday January 15"			effectiveYear: 1986			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: January week: 3 dayOfWeek: Monday)			observanceRule: nil. "Martin Luther King Day always occurs on the same day of the week."	"Established as a Federal legal holiday by Act of Congress in 1983 (signed into law by President Reagan in a Rose Garden ceremony in that year,) but was not observed until 1986-Jan-20."		aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #GroundhogDay 			effectiveYear: 1841 "Earliest attested observance."			nominalAnnualDate: (DayOfMonthFactory month: February day: 2)			observanceRule: nil.	"Normal business day."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #LincolnsBirthday 			effectiveYear: 1866 "First formal observance by US Congress"			nominalAnnualDate: (DayOfMonthFactory month: February day: 12)			observanceRule: nil.	"Normal business day in most of the United States, although it has been a legal holiday in some States."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ValentinesDay 			effectiveYear: 1753 "Gregorian Calendar conversion in English-speaking North America."			nominalAnnualDate: (DayOfMonthFactory month: February day: 14)			observanceRule: nil.	"Normal business day."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #WashingtonsBirthday			effectiveYear: 1796 			nominalAnnualDate: (DayOfMonthFactory month: February day: 22)			observanceRule: nonWeekendObservanceRule. "Before 1968, the day of week was variable."	"Washington’s Birthday was celebrated publicly for the first time in 1796, the last year of his presidency.  Washington's Birthday became a US Federal Holiday in 1885. 	Note that Washington was born in 1732--at a time when the Julian Calendar was the official calendar in his home jurisdiction (in fact, throughought the American Colonies, which didn't switch to the Gregorian Calendar until 1752.)  The date of his birth in the Julian Calendar was {(DateFactory year: 1732 month: February day: 22 calendar: Calendar gregorian) asJulian localePrintString} = February 11, 1732 [Julian]."		aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #WashingtonsBirthday 			effectiveYear: 1971 			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: February week: 3 dayOfWeek: Monday)			observanceRule: nil. "Since 1971, President's Day always occurs on the same day of the week."	"Set as the third Monday in February by Act of Congress in 1968 (effective 1971.)"		"As of 2004, Washington's Birthday is still the official name of this holiday, in spite of the fact that it usually doesn't actually fall on his birthday."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #StPatricksDay 			effectiveYear: 1753 "Gregorian Calendar conversion in English-speaking North America."			nominalAnnualDate: (DayOfMonthFactory month: March day: 17)			observanceRule: nil.	"Normal business day."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #Easter 			effectiveYear: 325			nominalAnnualDate: JulianEaster canonical			observanceRule: nil. 	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #Easter 			effectiveYear: 1753			nominalAnnualDate: GregorianEaster canonical			observanceRule: nil. 	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #GoodFriday 			effectiveYear: 1753			nominalAnnualDate: (GregorianEaster daysOffset: -2) 			observanceRule: nil. 	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #AprilFoolsDay 			effectiveYear: 1753 "Gregorian Calendar conversion in English-speaking North America."			nominalAnnualDate: (DayOfMonthFactory month: April day: 1)			observanceRule: nil.	"Normal business day (although one does need to adopt a skeptical attitude...)"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #EarthDay 			effectiveYear: 1970 			nominalAnnualDate: (DayOfMonthFactory month: April day: 22)			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #AdministrativeAssistantsDay "Secretaries' Day" 			effectiveYear: 1955 			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: April minDayOfMonth: 24 dayOfWeek: Saturday offset: -3)				"Wednesday before last Saturday of April."			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ArborDay			effectiveYear: 1872			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: April minDayOfMonth: 24 dayOfWeek: Friday)				"Last Friday of April--however, the date rule varies by locale, see http://www.arborday.org/ for more information."			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #MothersDay			effectiveYear: 1914 "By Presidential Proclamation, although it was widely celebrated in most of the US by 1911."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: May minDayOfMonth: 8 dayOfWeek: Sunday)				"Second Sunday of May."			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #MemorialDay 			effectiveYear: 1887 			nominalAnnualDate: (DayOfMonthFactory month: May day: 30)			observanceRule: nonWeekendObservanceRule.	"Established as a Federal legal holiday (affecting Federal employees only) by Act of Congress. In 1888, Congress added all persons in the District of Columbia to the affected group."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #MemorialDay 			effectiveYear: 1971 			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: May week: WeekOfMonthDayOfWeekFactory lastWeekOfMonth dayOfWeek: Monday)			observanceRule: nil. "Since 1971, Memorial Day always occurs on the same day of the week."	"Date rule of Memorial Day changed by Act of Congress in 1968 (effective 1971.)"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #FlagDay 			effectiveYear: 1916 "Established by Presidential Proclamation (Woodrow Wilson.)"			nominalAnnualDate: (DayOfMonthFactory month: June day: 14)			observanceRule: nil.	"Normal business day."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #FathersDay			effectiveYear: 1966 "By Presidential Proclamation, although it was widely celebrated in most of the US well before then."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: June minDayOfMonth: 15 dayOfWeek: Sunday)				"Third Sunday of June."			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #IndependenceDay 			effectiveYear: 1781 			nominalAnnualDate: (DayOfMonthFactory month: July day: 4)			observanceRule: nonWeekendObservanceRule.	"Recognized by Massachussets as a legal holiday in 1781. 	In 1870, the U.S. Congress made July 4 an unpaid holiday for federal employees.	Established as a Federal legal holiday (with pay) by Act of Congress in 1941."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ParentsDay			effectiveYear: 1994 "By Resolution of Congress."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: July minDayOfMonth: 22 dayOfWeek: Sunday)				"Fourth Sunday of July."			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #LaborDay 			effectiveYear: 1894 			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: September week: 1 dayOfWeek: Monday)			observanceRule: nil. "Labor Day always occurs on the same day of the week."	"Established as a Federal legal holiday by Act of Congress in 1894."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #GrandParentsDay			effectiveYear: 1978 "By Presidential Proclamation."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: September minDayOfMonth: 1 dayOfWeek: Monday offset: 6)				"Sunday after First Monday of September."			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ColumbusDay			effectiveYear: 1937			nominalAnnualDate: (DayOfMonthFactory month: October day: 12)			observanceRule: nonWeekendObservanceRule.	"Established as a Federal legal holiday by President Roosevelt."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ColumbusDay			effectiveYear: 1971			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: October week: 2 dayOfWeek: Monday)			observanceRule: nil. "Columbus Day now always occurs on the same day of the week."	"Established as a Federal legal holiday by Act of Congress."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #UnitedNationsDay			effectiveYear: 1947 "By Resolution of the UN General Assembly."			nominalAnnualDate: (DayOfMonthFactory month: October day: 24)			observanceRule: nil.	"Normal business day"	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #Halloween "Also known as 'All Hallows Eve,' 'Samhain,'  'All Hallowtide,' and 'The Feast of the Dead'"			effectiveYear: 1			nominalAnnualDate: (DayOfMonthFactory month: October day: 31 calendar: Julian)			observanceRule: nil. "Although Halloween may occur on any day of the week, it is usually not imputed to a different day (because it's almost always a business day regardless of the day of the week.)"	"Not a legal holiday, nor is it generally a non-business day.  The effective year is the epoch year of the Modern Julian Calendar."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #Halloween "Also known as 'All Hallows Eve,' 'Samhain,'  'All Hallowtide,' and 'The Feast of the Dead'"			effectiveYear: 1752			nominalAnnualDate: (DayOfMonthFactory month: October day: 31)			observanceRule: nil. "Although Halloween may occur on any day of the week, it is usually not imputed to a different day (because it's almost always a business day regardless of the day of the week.)"	"Not a legal holiday, nor is it generally a non-business day.  The effective date is that of the Gregorian Calendar."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #VeteransDay "Formerly 'Armistice Day'--corresponds to 'Remembrance Day' in British Commonwealth countries (same date, congruent semantics.)"			effectiveYear: 1938			nominalAnnualDate: (DayOfMonthFactory month: November day: 11)			observanceRule: nonWeekendObservanceRule.	"Established as a Federal legal holiday by Act of Congress."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	aSemanticDatePolicy at: #ElectionDay putUniqueDate: (DateSpec year: 1789 month: 1 day: 7). "First US Presidential Election under the 1789 Constitution."	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #ElectionDay 			effectiveYear: 1792 "Second US Presidential Election under the 1789 Constitution."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: 1 dayOfWeek: Tuesday)			observanceRule: (SemanticDateObservanceRule yearBase: 0 period: 4). 			"Election Day occurs in years evenly divisible by 4. However, it's not a non-business day, although there have been proposals to make it one."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	thanksgiving := 		SemanticAnnualDateRule 			semanticKey: #Thanksgiving 			effectiveYear: 1863 "Lincoln's Thanksgiving Rule."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: WeekOfMonthDayOfWeekFactory lastWeekOfMonth dayOfWeek: Thursday)			observanceRule: nil. "Thanksgiving always occurs on the same day of the week."	"Before 1941, the status of Thanksgiving as a legal and/or 'traditional' holiday, and the date of its observance, varied widely within the United States. However, the most common date of observance before 1941 was the **last** Thursday in November (as opposed to the modern rule, which is the **fourth** Thursday.)"	aSemanticDatePolicy addSemanticAnnualDateRule: thanksgiving.  	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #DayAfterThanksgiving 			effectiveYear: 1863 "Lincoln's Thanksgiving Rule."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: WeekOfMonthDayOfWeekFactory lastWeekOfMonth dayOfWeek: Thursday offset: 1)			observanceRule: nil. "The Day After Thanksgiving always occurs on the same day of the week."	"Not a legal holiday--but often a non-business day. Effective year taken from that of Thanksgiving."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	thanksgiving := 		SemanticAnnualDateRule 			semanticKey: #Thanksgiving 			effectiveYear: 1941 "Roosevelt's Thanksgiving Rule."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: 4 dayOfWeek: Thursday)			observanceRule: nil. "Thanksgiving always occurs on the same day of the week."	"Established as a Federal legal holiday by Act of Congress in 1941."	aSemanticDatePolicy addSemanticAnnualDateRule: thanksgiving.  	semanticAnnualDate := 		SemanticAnnualDateRule 			semanticKey: #DayAfterThanksgiving 			effectiveYear: 1941 "Roosevelt's Thanksgiving Rule."			nominalAnnualDate: (WeekOfMonthDayOfWeekFactory month: November week: 4 dayOfWeek: Thursday offset: 1)			observanceRule: nil. "The Day After Thanksgiving always occurs on the same day of the week."	"Not a legal holiday--but more often than not a non-business day in the modern era. Effective year taken from that of Thanksgiving."	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate. 	christmas := 		SemanticAnnualDateRule 			semanticKey: #Christmas 			effectiveYear: 340			nominalAnnualDate: (DayOfMonthFactory month: December day: 25 calendar: Julian) 			observanceRule: nil.	"Effective year based on the fact that Christmas was first declared a legal holiday by Emperor Constantine's Declaration in 340 A.D. It's a reasonably safe assumption that Christmas was a non-business day in most parts of the western world since 340 A.D--although before 1752 in the British Empire (which at the time included what is now the United States,) it would have been celebrated on Dec 25 in the Julian Calendar, which would be a different day than Dec 25 in the Gregorian Calendar."	aSemanticDatePolicy addSemanticAnnualDateRule: christmas.	semanticAnnualDate := 		DerivedSemanticAnnualDateRule 			semanticKey: #ChristmasEve 			effectiveYear: 340 			dayBeforeNominalDayOf: christmas. 	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate.		christmas := 		SemanticAnnualDateRule 			semanticKey: #Christmas 			effectiveYear: 1752 			nominalAnnualDate: (DayOfMonthFactory month: December day: 25) 			observanceRule: nonWeekendObservanceRule.	"Effective year based on the fact that the Gregorian Calendar became the official calendar of the British Empire in 1752."	aSemanticDatePolicy addSemanticAnnualDateRule: christmas.	semanticAnnualDate := 		DerivedSemanticAnnualDateRule 			semanticKey: #ChristmasEve 			effectiveYear: 1752 			dayBeforeNominalDayOf: christmas. 	aSemanticDatePolicy addSemanticAnnualDateRule: semanticAnnualDate.</body><body package="Chronos-Semantic Dates" selector="registerNYSEHolidaysIn:">registerNYSEHolidaysIn: aSemanticDatePolicy	self registerAnnuallyRecurringNYSEHolidaysIn: aSemanticDatePolicy.	self registerUniqueNYSEHolidaysIn: aSemanticDatePolicy</body><body package="Chronos-Semantic Dates" selector="registerUniqueNYSEHolidaysIn:">registerUniqueNYSEHolidaysIn: aSemanticDatePolicy	aSemanticDatePolicy 		at: #'DayOfMourning-GeraldFord' putUniqueDate: (DateSpec year: 2007 month: January day: 2);		at: #'PresidentialFuneral-RonaldReagan' putUniqueDate: (DateSpec year: 2004 month: June day: 11);		at: #WorldTradeCenterEvent putUniqueDate: (DateSpec year: 2001 month: September day: 14);				at: #WorldTradeCenterEvent putUniqueDate: (DateSpec year: 2001 month: September day: 13);		at: #WorldTradeCenterEvent putUniqueDate: (DateSpec year: 2001 month: September day: 12);		at: #WorldTradeCenterEvent putUniqueDate: (DateSpec year: 2001 month: September day: 11);		at: #'PresidentialFuneral-RichardNixon' putUniqueDate: (DateSpec year: 1994 month: April day: 27);		at: #'Weather-HurricaneGloria' putUniqueDate: (DateSpec year: 1985 month: September day: 27);		at: #NewYorkCityBlackout putUniqueDate: (DateSpec year: 1977 month: July day: 14);		at: #'PresidentialFuneral-LyndonJohnson' putUniqueDate: (DateSpec year: 1973 month: January day: 25);		at: #'PresidentialFuneral-HarryTruman' putUniqueDate: (DateSpec year: 1972 month: December day: 28);		at: #FirstLunarLanding putUniqueDate: (DateSpec year: 1969 month: July day: 21);		at: #'PresidentialFuneral-DwightEisenhower' putUniqueDate: (DateSpec year: 1969 month: March day: 31);		at: #'Weather-Snow' putUniqueDate: (DateSpec year: 1969 month: February day: 10).	((DateFactory year: 1968 month: June day: 12) to: (DateFactory year: 1969 day: 1))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #PaperCrisis putUniqueDate: day start].	aSemanticDatePolicy 		at: #DayAfterIndependenceDay putUniqueDate: (DateSpec year: 1968 month: July day: 5);		at: #'DayOfMourning-MartinLutherKing' putUniqueDate: (DateSpec year: 1968 month: April day: 9);		at: #LincolnsBirthday putUniqueDate: (DateSpec year: 1968 month: February day: 12);		at: #'PresidentialFuneral-JohnKennedy' putUniqueDate: (DateSpec year: 1963 month: November day: 25);		at: #DayBeforeDecorationDay putUniqueDate: (DateSpec year: 1961 month: May day: 29);		at: #DayAfterChrismas putUniqueDate: (DateSpec year: 1958 month: December day: 26);		at: #ChristmasEve putUniqueDate: (DateSpec year: 1956 month: December day: 24);		at: #ChristmasEve putUniqueDate: (DateSpec year: 1954 month: December day: 24).	"From 1873 until 1952, there was a 2-hour trading session (10am to Noon) on Saturdays--except over the summer. But the exchange had no fixed rule for the start or end of the 'over-the-summer Saturday holdiay' period."	((DateFactory year: 1952 month: May day: 31) to: (DateFactory year: 1952 month: September day: 28))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	((DateFactory year: 1951 month: June day: 2) to: (DateFactory year: 1951 month: September day: 30))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	aSemanticDatePolicy 		at: #'Saturday-Before-ChristmasEve' putUniqueDate: (DateSpec year: 1950 month: December day: 12).	((DateFactory year: 1950 month: June day: 3) to: (DateFactory year: 1950 month: October day: 1))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	aSemanticDatePolicy 		at: #ChristmasEve putUniqueDate: (DateSpec year: 1949 month: December day: 24).	((DateFactory year: 1949 month: May day: 28) to: (DateFactory year: 1949 month: September day: 25))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	aSemanticDatePolicy 		at: #'Weather-SevereConditions' putUniqueDate: (DateSpec year: 1948 month: January day: 3).	((DateFactory year: 1948 month: May day: 29) to: (DateFactory year: 1948 month: September day: 26))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	((DateFactory year: 1947 month: May day: 31) to: (DateFactory year: 1947 month: September day: 28))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	((DateFactory year: 1946 month: June day: 1) to: (DateFactory year: 1946 month: September day: 29))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	aSemanticDatePolicy 		at: #RailroadStrike putUniqueDate: (DateSpec year: 1946 month: May day: 25);		at: #'Saturday-After-WashingtonsBirthday' putUniqueDate: (DateSpec year: 1946 month: February day: 23);		at: #ChristmasEve putUniqueDate: (DateSpec year: 1945 month: December day: 24);		at: #NavyDay putUniqueDate: (DateSpec year: 1945 month: October day: 27);		at: #'Saturday-After-ColumbusDay' putUniqueDate: (DateSpec year: 1945 month: October day: 13);		at: #VictoryOverJapanDay putUniqueDate: (DateSpec year: 1945 month: August day: 16);		at: #VictoryOverJapanDay putUniqueDate: (DateSpec year: 1945 month: August day: 15).	((DateFactory year: 1945 month: July day: 7) to: (DateFactory year: 1945 month: September day: 2))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].		aSemanticDatePolicy 		at: #'DayOfMourning-FranklinRoosevelt' putUniqueDate: (DateSpec year: 1945 month: April day: 14).	((DateFactory year: 1944 month: August day: 19) to: (DateFactory year: 1944 month: September day: 3))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	aSemanticDatePolicy 		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1937 month: July day: 3);		at: #'Saturday-Before-DecorationDay' putUniqueDate: (DateSpec year: 1937 month: May day: 29);		at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1936 month: December day: 26).	((DateFactory year: 1933 month: July day: 29) to: (DateFactory year: 1933 month: September day: 4))		every: DaysPerWeek		daysDo: [:day | aSemanticDatePolicy at: #'Saturday-Summertime' putUniqueDate: day start].	((DateFactory year: 1933 month: March day: 6) to: (DateFactory year: 1933 month: March day: 14)) 		every: 1		daysDo: [:day | | date | 			"FDRs unfortunate attempt to cure the Great Depression.  History shows that the government decides to act at about the same time that the trend reverses back up on its own. The same phenomenon is visible in the behavior of the typical investor, who finaly capitulates and sells his positions at the bottom of the market. 'Buy when the blood is running in the streets.' -- Nathan Rothschild"			date := day start.			date dayOfWeek = Sunday				ifFalse: [aSemanticDatePolicy at: #NationalBankingHoliday putUniqueDate: date]].	aSemanticDatePolicy 		at: #StateBankingHoliday putUniqueDate: (DateSpec year: 1933 month: March day: 4);		at: #'PresidentialFuneral-CalvinCoolidge' putUniqueDate: (DateSpec year: 1933 month: January day: 7);		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1932 month: July day: 2);		at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1931 month: December day: 26);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1931 month: September day: 5);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1930 month: August day: 30);		at: #'Saturday-After-IndependenceDay' putUniqueDate: (DateSpec year: 1930 month: July day: 5);		at: #'Saturday-After-DecorationDay' putUniqueDate: (DateSpec year: 1930 month: May day: 31);		at: #'Saturday-After-DecorationDay' putUniqueDate: (DateSpec year: 1930 month: May day: 31);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1930 month: April day: 19);		at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1930 month: November day: 29);	"No computers back then. And of course, the market was crashing..."		at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1929 month: November day: 30);			at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1929 month: November day: 23);			at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1929 month: November day: 16);			at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1929 month: November day: 9);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1929 month: November day: 2);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1929 month: November day: 1);				at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1929 month: August day: 31);				at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1929 month: March day: 30);				at: #'Saturday-After-WashingtonsBirthday' putUniqueDate: (DateSpec year: 1929 month: February day: 23);				at: #'Saturday-After-WashingtonsBirthday' putUniqueDate: (DateSpec year: 1929 month: February day: 23);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1929 month: February day: 9);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1928 month: November day: 24);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1928 month: May day: 26);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1928 month: May day: 19);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1928 month: May day: 12);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1928 month: May day: 5);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1928 month: April day: 21);				at: #ClericalBacklogRelief putUniqueDate: (DateSpec year: 1928 month: April day: 7);				at: #'Parade-CharlesLindbergh' putUniqueDate: (DateSpec year: 1927 month: June day: 13);				at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1926 month: September day: 4);				at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1926 month: July day: 3);				at: #'Saturday-Before-DecorationDay' putUniqueDate: (DateSpec year: 1926 month: May day: 29);				at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1925 month: December day: 26);				at: #'Saturday-After-DecorationDay' putUniqueDate: (DateSpec year: 1924 month: May day: 31);				at: #'PresidentialFuneral-WarrenHarding' putUniqueDate: (DateSpec year: 1923 month: August day: 10);				at: #'PresidentialDeath-WarrenHarding' putUniqueDate: (DateSpec year: 1923 month: August day: 3);				at: #'Saturday-Before-Christmas' putUniqueDate: (DateSpec year: 1922 month: December day: 23);				at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1921 month: September day: 3);		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1921 month: July day: 2);				at: #'Saturday-Before-DecorationDay' putUniqueDate: (DateSpec year: 1921 month: May day: 28);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1920 month: September day: 4);		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1920 month: July day: 3);		at: #RelocationOfBrokerageFirmOffices putUniqueDate: (DateSpec year: 1920 month: May day: 1);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1920 month: April day: 3);		at: #ReturnOfGeneralJohnPershing putUniqueDate: (DateSpec year: 1919 month: September day: 10);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1919 month: August day: 30);		at: #'Saturday-After-DecorationDay' putUniqueDate: (DateSpec year: 1919 month: May day: 31);		at: #'Saturday-After-DecorationDay' putUniqueDate: (DateSpec year: 1919 month: May day: 31);		at: #'Parade-77thDivision' putUniqueDate: (DateSpec year: 1919 month: May day: 6);		at: #HomecomingOf27thDivision putUniqueDate: (DateSpec year: 1919 month: March day: 25);		at: #DraftRegistrationDay putUniqueDate: (DateSpec year: 1918 month: September day: 12);		at: #HeatlessDay putUniqueDate: (DateSpec year: 1918 month: February day: 11);	"Was it just too cold, was the heating system broken, or were they trying to conserve energy during wartime? Don't know, but it could have been due to any of the preceding reasons."		at: #HeatlessDay putUniqueDate: (DateSpec year: 1918 month: February day: 4);		at: #HeatlessDay putUniqueDate: (DateSpec year: 1918 month: January day: 28);		at: #'Saturday-After-ColumbusDay' putUniqueDate: (DateSpec year: 1917 month: October day: 13);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1917 month: September day: 1);		at: #'Weather-HeatDay' putUniqueDate: (DateSpec year: 1917 month: August day: 4);		"Too hot, one assumes.  No air conditioning back then."		at: #DraftRegistrationDay putUniqueDate: (DateSpec year: 1917 month: June day: 5);		at: #'Saturday-Before-NewYearsDay' putUniqueDate: (DateSpec year: 1916 month: December day: 30).	((DateFactory year: 1914 month: July day: 31) to: (DateFactory year: 1914 month: December day: 13)) 		every: 1		daysDo: [:day | | date | 			date := day start.			date dayOfWeek = Sunday				ifFalse: [aSemanticDatePolicy at: #WorldWar1 putUniqueDate: date]].	aSemanticDatePolicy 		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1913 month: August day: 30);		at: #'Saturday-After-IndependenceDay' putUniqueDate: (DateSpec year: 1913 month: July day: 5);				at: #'Saturday-After-DecorationDay' putUniqueDate: (DateSpec year: 1913 month: May day: 31);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1913 month: March day: 22);		at: #'PresidentialFuneral-JamesSherman' putUniqueDate: (DateSpec year: 1912 month: November day: 2);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1912 month: August day: 31);		at: #'Saturday-Before-Christmas' putUniqueDate: (DateSpec year: 1911 month: December day: 23);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1911 month: September day: 2);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1911 month: April day: 15);		at: #'Saturday-Before-Christmas' putUniqueDate: (DateSpec year: 1910 month: December day: 24);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1910 month: September day: 3);		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1910 month: July day: 2);		at: #'Saturday-Before-DecorationDay' putUniqueDate: (DateSpec year: 1910 month: May day: 28);		at: #ReceptionDayOfHudsonFultonCelebration putUniqueDate: (DateSpec year: 1909 month: September day: 25);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1909 month: September day: 4);		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1909 month: July day: 3);		at: #'Saturday-Before-DecorationDay' putUniqueDate: (DateSpec year: 1909 month: May day: 29);		at: #'Saturday-Before-DecorationDay' putUniqueDate: (DateSpec year: 1909 month: May day: 29);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1909 month: April day: 10);		at: #'Saturday-After-LincolnsBirthday' putUniqueDate: (DateSpec year: 1909 month: February day: 13);		at: #'Saturday-After-LincolnsBirthday' putUniqueDate: (DateSpec year: 1909 month: February day: 13);		at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1908 month: December day: 26);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1908 month: September day: 5);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1908 month: September day: 5);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1908 month: April day: 18);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1907 month: August day: 31);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1907 month: March day: 30);		at: #'Saturday-After-WashingtonsBirthday' putUniqueDate: (DateSpec year: 1907 month: February day: 23);				at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1905 month: April day: 22);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1905 month: April day: 22);		at: #'Saturday-Before-Christmas' putUniqueDate: (DateSpec year: 1904 month: December day: 24);				at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1904 month: September day: 3);				at: #'Saturday-Before-IndepedenceDay' putUniqueDate: (DateSpec year: 1904 month: July day: 2);		at: #'Saturday-Before-DecorationDay' putUniqueDate: (DateSpec year: 1904 month: May day: 28);		at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1903 month: December day: 26);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1903 month: September day: 5);		at: #NewNYSEBuildingOpened putUniqueDate: (DateSpec year: 1903 month: April day: 22);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1903 month: April day: 11);		at: #'Saturday-Before-WashingtonsBirthday' putUniqueDate: (DateSpec year: 1903 month: February day: 21);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1902 month: August day: 30);		at: #CoronationOfKingEdwardVII putUniqueDate: (DateSpec year: 1902 month: August day: 9);		at: #'Saturday-After-IndepedenceDay' putUniqueDate: (DateSpec year: 1902 month: July day: 5);		at: #'Saturday-After-DecorationDay' putUniqueDate: (DateSpec year: 1902 month: May day: 31);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1902 month: March day: 29);		at: #'PresidentialFuneral-WilliamMcKinley' putUniqueDate: (DateSpec year: 1901 month: September day: 19);		at: #'PresidentialAssassination-WilliamMcKinley' putUniqueDate: (DateSpec year: 1901 month: September day: 14);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1901 month: August day: 31);		at: #DayAfterIndepedenceDay putUniqueDate: (DateSpec year: 1901 month: July day: 5); "Interesting..."		at: #'Saturday-After-IndepedenceDay' putUniqueDate: (DateSpec year: 1901 month: July day: 6);		at: #EnlargementOfTemporaryQuartersInProduceExchange putUniqueDate: (DateSpec year: 1901 month: May day: 11); "See below"		at: #MoveToTemporaryQuartersInProduceExchange putUniqueDate: (DateSpec year: 1901 month: April day: 27); "See above"		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1901 month: April day: 6);		at: #FuneralOfQueenVictoria putUniqueDate: (DateSpec year: 1901 month: February day: 2);		at: #ChristmasEve putUniqueDate: (DateSpec year: 1900 month: December day: 24);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1900 month: September day: 1);		at: #'Saturday-After-GoodFriday' putUniqueDate: (DateSpec year: 1900 month: April day: 14);		at: #'VicePresidentialFuneral-GarretHobart' putUniqueDate: (DateSpec year: 1899 month: November day: 25);		at: #'AdmiralDeweyCelebration' putUniqueDate: (DateSpec year: 1899 month: September day: 30);		at: #'AdmiralDeweyCelebration' putUniqueDate: (DateSpec year: 1899 month: September day: 29);		at: #DayBeforeIndependenceDay putUniqueDate: (DateSpec year: 1899 month: July day: 3);		at: #DayBeforeDecorationDay putUniqueDate: (DateSpec year: 1899 month: May day: 29);		at: #'Saturday-Before-LincolnsBirthday' putUniqueDate: (DateSpec year: 1899 month: February day: 11);		at: #'Saturday-Before-Christmas' putUniqueDate: (DateSpec year: 1898 month: December day: 24);		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1898 month: September day: 3);		at: #WelcomeOfNavalCommanders putUniqueDate: (DateSpec year: 1898 month: August day: 20);		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1898 month: July day: 2);		at: #CharterDay putUniqueDate: (DateSpec year: 1898 month: May day: 4);		at: #'PresidentialBirthday-UlyssesGrant' putUniqueDate: (DateSpec year: 1897 month: April day: 27); "The cultural differences between then and now really begin to show here."		at: #'PresidentialBirthday-UlyssesGrant' putUniqueDate: (DateSpec year: 1897 month: April day: 27); 		at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1896 month: December day: 26);		at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1896 month: December day: 26);		at: #ColumbianCelebration putUniqueDate: (DateSpec year: 1893 month: April day: 27);		at: #ColumbianCelebration putUniqueDate: (DateSpec year: 1893 month: April day: 27);		at: #ColumbianCelebration putUniqueDate: (DateSpec year: 1892 month: October day: 22);		at: #ColumbianCelebration putUniqueDate: (DateSpec year: 1892 month: October day: 21);		at: #ColumbianCelebration putUniqueDate: (DateSpec year: 1892 month: October day: 12);		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1892 month: July day: 2);		at: #'Saturday-After-Christmas' putUniqueDate: (DateSpec year: 1891 month: December day: 26);		at: #'Saturday-After-IndependenceDay' putUniqueDate: (DateSpec year: 1890 month: July day: 5);		at: #CentennialCelebrationOfWashingtonsInauguration putUniqueDate: (DateSpec year: 1889 month: May day: 1);		at: #CentennialCelebrationOfWashingtonsInauguration putUniqueDate: (DateSpec year: 1889 month: April day: 30);		at: #CentennialCelebrationOfWashingtonsInauguration putUniqueDate: (DateSpec year: 1889 month: April day: 29);		at: #DayAfterThanksgiving putUniqueDate: (DateSpec year: 1888 month: November day: 30); "Note this differs from the modern rule for Thanksgiving."		at: #'Saturday-Before-LaborDay' putUniqueDate: (DateSpec year: 1888 month: September day: 1); 		at: #'Weather-Blizzard' putUniqueDate: (DateSpec year: 1888 month: March day: 13); 		at: #'Saturday-Before-Christmas' putUniqueDate: (DateSpec year: 1887 month: December day: 24); 		at: #'Saturday-Before-IndependenceDay' putUniqueDate: (DateSpec year: 1887 month: July day: 2); 		at: #'PresidentialFuneral-UlyssesGrant' putUniqueDate: (DateSpec year: 1885 month: August day: 8).	"Data before 1885 is not available."</body></methods><methods><class-id>Chronos.SemanticDatePolicy class</class-id> <category>private</category><body package="Chronos-Semantic Dates" selector="newNYSEHolidays">newNYSEHolidays	| sdp |	sdp := SemanticDatePolicy new.	sdp setDayOfWeekSemanticKeys: self defaultDayOfWeekSemanticKeys.	self registerNYSEHolidaysIn: sdp.	^sdp</body><body package="Chronos-Semantic Dates" selector="newRegistry">newRegistry	^IdentityDictionary new</body><body package="Chronos-Semantic Dates" selector="newUSDefault">newUSDefault	| sdp |	sdp := SemanticDatePolicy new.	sdp setDayOfWeekSemanticKeys: self defaultDayOfWeekSemanticKeys.	self registerDefaultUSAnnualSemanticDaysIn: sdp.	^sdp</body></methods><methods><class-id>Chronos.SemanticDatePolicy class</class-id> <category>class initialization</category><body package="Chronos-Semantic Dates" selector="initialize">initialize	"SemanticDatePolicy initialize." 	self basicInitializeAll.		USDefault := nil.	NYSEHolidays := nil.	Default := nil.	USFederalHolidaySemanticKeys := nil</body></methods><methods><class-id>Chronos.SemanticDatePolicy class</class-id> <category>examples</category><body package="Chronos-Semantic Dates" selector="nyseTradingDayCountFrom:through:">nyseTradingDayCountFrom: minDate through: maxDate 	"{[1000 timesRepeat: 		[SemanticDatePolicy 			nyseTradingDayCountFrom: (YearMonthDay year: 2000 month: January day: 14) 			through: (YearMonthDay year: 2006 month: January day: 11)]] durationToRun}"	"{[1000 timesRepeat: 		[SemanticDatePolicy 			nyseTradingDayCountFrom: (YearMonthDay year: 2005 month: December day: 9) 			through: (YearMonthDay year: 2006 month: February day: 1)]] durationToRun}"	"{[1000 timesRepeat: 		[SemanticDatePolicy 			nyseTradingDayCountFrom: (YearMonthDay year: 2003 month: March day: 12) 			through: (YearMonthDay year: 2006 month: January day: 12)]] durationToRun}"	"There are no trading days in the following interval, since 2005-12-31 is a Saturay, 2006-01-01 is both a Sunday and New Year's Day, and 2006-01-02 (a Monday) is the day on which New Year's Day is officially observed by the NYSE:	{SemanticDatePolicy 		nyseTradingDayCountFrom: (YearMonthDay year: 2005 month: December day: 31) 		through: (YearMonthDay year: 2006 month: January day: 2)}"	| closureCount |	minDate &gt; maxDate ifTrue: [^0].	closureCount := 0.	SemanticDatePolicy nyse 		observedEventOccurenceDatesFrom: minDate		through: maxDate		do: 			[:semanticKey :date :observanceType | 			semanticKey == #weekend 				ifTrue: 					[(date year between: 1873 and: 1952) 						ifTrue: [date dayOfWeek = Sunday ifTrue: [closureCount := closureCount + 1]]						ifFalse: [closureCount := closureCount + 1]]				ifFalse: [closureCount := closureCount + 1]].	^(minDate daysUntil: maxDate) + 1  - closureCount</body><body package="Chronos-Semantic Dates" selector="usFederalBusinessDayCountFrom:through:">usFederalBusinessDayCountFrom: minDate through: maxDate 	"{[1000 timesRepeat: 		[SemanticDatePolicy 			usFederalBusinessDayCountFrom: (YearMonthDay year: 2001 month: January day: 20) 			through: (YearMonthDay year: 2009 month: January day: 20)]] durationToRun}"	"{[1000 timesRepeat: 		[SemanticDatePolicy 			usFederalBusinessDayCountFrom: (YearMonthDay year: 2006 month: December day: 31) 			through: (YearMonthDay year: 2006 month: January day: 1)]] durationToRun}"	| holidayCount |	minDate &gt; maxDate ifTrue: [^0].	holidayCount := 0.	SemanticDatePolicy unitedStates		observedEventOccurenceDatesFrom: minDate		through: maxDate		do: 			[:semanticKey :date :observanceType | 			semanticKey == #weekend 				ifTrue: [holidayCount := holidayCount + 1]				ifFalse: [(SemanticDatePolicy usFederalHolidaySemanticKeys includes: semanticKey) ifTrue: [holidayCount := holidayCount + 1]]].	^(minDate daysUntil: maxDate) + 1  - holidayCount</body></methods><methods><class-id>Passport.ReversibleTransformer</class-id> <category>transformation</category><body package="Passport-Kernel" selector="applyTo:">applyTo: aDate	^self subclassResponsibility</body><body package="Passport-Kernel" selector="inverseApplyTo:">inverseApplyTo: aDate	^self subclassResponsibility</body></methods><methods><class-id>Passport.VWHttpsUrlFacade</class-id> <category>accessing</category><body package="Passport-Kernel-VW" selector="protocol">protocol	^#https</body></methods><methods><class-id>Chronos.SimpleDateTransformer</class-id> <category>initialize-release</category><body package="Chronos-Duration" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	calendarDelta := CalendarDurationFactory zero</body><body package="Chronos-Duration" selector="setCalendarDelta:">setCalendarDelta: aCalendarDuration	self assertMutability.	calendarDelta := aCalendarDuration == nil ifTrue: [CalendarDurationFactory zero] ifFalse: [aCalendarDuration asCalendarDuration]</body></methods><methods><class-id>Chronos.SimpleDateTransformer</class-id> <category>accessing</category><body package="Chronos-Duration" selector="calendarDelta">calendarDelta	^calendarDelta</body></methods><methods><class-id>Chronos.SimpleDateTransformer</class-id> <category>transformation</category><body package="Chronos-Duration" selector="applyTo:">applyTo: aDate	^aDate + calendarDelta</body><body package="Chronos-Duration" selector="inverseApplyTo:">inverseApplyTo: aDate	^aDate - calendarDelta</body></methods><methods><class-id>Chronos.SimpleDateTransformer class</class-id> <category>instance creation</category><body package="Chronos-Duration" selector="delta:">delta: aCalendarDuration 	^(self basicNew)		setCalendarDelta: aCalendarDuration;		beImmutable</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>converting</category><body package="Passport-Kernel" selector="asAbsolute">asAbsolute	"Answer the conversion of the receiver into an absolute ResourcePath"	"{ResourcePath defaultDirectory asAbsolute}"	"{ResourcePath currentDirectory asAbsolute}"	"{(ResourcePath fromString: 'foo') asAbsolute}"	^self isAbsolute 		ifTrue: [self]		ifFalse: 			[| defaultDirectory |			defaultDirectory := self class defaultDirectory.			self isRemote 				ifTrue: 					[^(self copy)						setNamespace: defaultDirectory namespace;						setPathname: defaultDirectory pathname , pathname;						beImmutable]				ifFalse: 					[pathname isEmpty 						ifTrue: [defaultDirectory]						ifFalse: [defaultDirectory , pathname]]]</body><body package="Passport-Kernel" selector="asAuthority">asAuthority	^(self copy)		initializeNonAuthorityValues;		beImmutable</body><body package="Passport-Kernel" selector="asInvariant">asInvariant	^self copy beInvariant beImmutable</body><body package="Passport-Kernel" selector="asLocal">asLocal	^self withHostname: #localhost</body><body package="Passport-Kernel" selector="asNative">asNative	"Answer the conversion of the receiver into whatever object/value would canonically be used by the host Smalltalk implementation to name/identify the same external/persistent/remote resource as does the receiver."	^self resourcePathFacade constructNativeResourceIDFromResourcePath: self</body><body package="Passport-Kernel" selector="asOperand">asOperand	"Answer the conversion of the receiver into whatever object/value the receiver's ResourcePathFacade expects as an operand for service calls."	^self resourcePathFacade operandFromResourcePath: self</body><body package="Passport-Kernel" selector="asPathname">asPathname	"Answer the conversion of the receiver into a Pathname."	^self pathname</body><body package="Passport-Kernel" selector="asPlatform">asPlatform	^self withProtocol: #platform</body><body package="Passport-Kernel" selector="asRelative">asRelative	^self copy beRelative beImmutable</body><body package="Passport-Kernel" selector="asResourcePath">asResourcePath	^self</body><body package="Passport-Kernel" selector="asRoot">asRoot	"Answer the conversion of the receiver into an absolute ResourcePath that names, identifies or implies the same root volume, drive, device, directory or naming-context as does the receiver, but that only names/identifies said root volume, drive, device, directory or naming-context, without any suffix."	"{ResourcePath defaultDirectory asRoot}"	"{ResourcePath currentDirectory asRoot}"	| pathless |	pathless := 		(self copy)			initializePostPathValues;			initializePathname.	^pathless isAbsolute ifTrue: [pathless beImmutable] ifFalse: [pathless prefix asRoot]</body><body package="Passport-Kernel" selector="asString">asString	^self asNative asString</body><body package="Passport-Kernel" selector="withContext:">withContext: aResourcePathContext	"Answer a copy of the receiver whose protocol is &lt;protocolSymbol&gt;."	context == aResourcePathContext ifTrue: [^self].	^(self copy)		setResourcePathContext: aResourcePathContext;		beImmutable</body><body package="Passport-Kernel" selector="withHostname:">withHostname: aHostname 	"Answer a copy of the receiver whose hostname is &lt;aHostname&gt;."	hostname = ((UtilityFunction isNilOrEmpty: aHostname) ifFalse: [aHostname]) ifTrue: [^self].	^(self copy)		setHostname: aHostname;		beImmutable</body><body package="Passport-Kernel" selector="withHostname:namespace:">withHostname: aHostname namespace: aNamespace 	"Answer a copy of the receiver whose hostname is &lt;aHostname&gt; and whose namespace is &lt;aNamespace&gt;."	(hostname = ((UtilityFunction isNilOrEmpty: aHostname) ifFalse: [aHostname]) and: [namespace = ((UtilityFunction isNilOrEmpty: aNamespace) ifFalse: [aNamespace])]) ifTrue: [^self].	^(self copy)		setHostname: aHostname;		setNamespace: aNamespace;		beImmutable</body><body package="Passport-Kernel" selector="withHostname:port:">withHostname: aHostname port: portNumber 	"Answer a copy of the receiver whose hostname is &lt;aHostname&gt; and whose port is &lt;portNumber&gt;."	(hostname = ((UtilityFunction isNilOrEmpty: aHostname) ifFalse: [aHostname]) and: [port = portNumber]) ifTrue: [^self].	^(self copy)		setHostname: aHostname;		setPort: portNumber;		beImmutable</body><body package="Passport-Kernel" selector="withNamespace:">withNamespace: aNamespace 	"Answer a copy of the receiver whose namespace is &lt;aNamespace&gt;."	namespace = ((UtilityFunction isNilOrEmpty: aNamespace) ifFalse: [aNamespace]) ifTrue: [^self].	^(self copy)		setNamespace: aNamespace;		beImmutable</body><body package="Passport-Kernel" selector="withNamespace:pathname:">withNamespace: aNamespace pathname: aPathname	(namespace = ((UtilityFunction isNilOrEmpty: aNamespace) ifFalse: [aNamespace]) and: [pathname = aPathname]) ifTrue: [^self].	^(self copy)		setNamespace: aNamespace;		setPathname: aPathname;		beImmutable</body><body package="Passport-Kernel" selector="withPathname:">withPathname: aPathname 	"Answer a copy of the receiver whose pathname is &lt;aPathname&gt;."	pathname = aPathname ifTrue: [^self].	^(self copy)		setPathname: aPathname;		beImmutable</body><body package="Passport-Kernel" selector="withPort:">withPort: portNumber	"Answer a copy of the receiver whose port is &lt;portNumber&gt;."	port = portNumber ifTrue: [^self].	^(self copy)		setPort: portNumber;		beImmutable</body><body package="Passport-Kernel" selector="withProtocol:">withProtocol: protocolSymbol	"Answer a copy of the receiver whose protocol is &lt;protocolSymbol&gt;."	protocol = protocolSymbol ifTrue: [^self].	^(self copy)		setProtocol: protocolSymbol;		beImmutable</body><body package="Passport-Kernel" selector="withUser:password:">withUser: userName password: psswd	(user = ((UtilityFunction isNilOrEmpty: userName) ifFalse: [userName]) and: [password = ((UtilityFunction isNilOrEmpty: psswd) ifFalse: [psswd])]) ifTrue: [^self].	^(self copy)		setUser: userName;		setPassword: psswd;		beImmutable</body><body package="Passport-Kernel" selector="withoutFragment">withoutFragment	^self hasFragment 		ifTrue: 			[(self copy)				setFragment: nil;				beImmutable]		ifFalse: [self]</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>path operations</category><body package="Passport-Kernel" selector=",">, aSuffix	"Answer a new ResourcePath constructed by appending &lt;aSuffix&gt; to the receiver. The value of &lt;aSuffix&gt; may be a String, an Array of String, or an instance of Pathname." 	^[aSuffix appendToResourcePath: self] 		on: MessageNotUnderstood		do: 			[:ex | 			aSuffix isString 				ifTrue: [self appending: aSuffix]				ifFalse: [self appendingAll: aSuffix]]</body><body package="Passport-Kernel" selector="appending:">appending: aString	"Answer a new ResourcePath constructed by appending &lt;aString&gt; to the receiver as the last component of its path."	^self copy		append: aString;		beImmutable</body><body package="Passport-Kernel" selector="appendingAll:">appendingAll: anArrayOfStrings	"Answer a new ResourcePath constructed by appending &lt;anArrayOfStrings&gt; to the receiver."	^self copy		appendAll: anArrayOfStrings;		beImmutable</body><body package="Passport-Kernel" selector="appendingExtension:">appendingExtension: aString	"Answer a new ResourcePath constructed by appending &lt;aString&gt; as an extension to the last component of the receiver's path."	^self copy		setPathname: (pathname appendingExtension: (String with: self extensionSeparator), aString);		beImmutable</body><body package="Passport-Kernel" selector="appendingPathname:">appendingPathname: aPathname 	"Answer a new ResourcePath constructed by appending &lt;aPathname&gt; to the receiver."	^(self copy)		appendPathname: aPathname;		beImmutable</body><body package="Passport-Kernel" selector="prefix">prefix	"Answer a ResourcePath that is the prefix of the receiver--constructed by removing the last component of the receiver's path."	| stream ns facade |	^pathname isEmpty 		ifTrue: 			[facade := self resourcePathFacade.			ns := self namespace.			ns size &gt; 1 				ifTrue: 					[(ns occurrencesOf: self separator) &gt; 1 						ifTrue: 							[stream := ns readStream.							(self copy)								setNamespace: 									((stream peekFor: self separator) 										ifTrue: [facade rootDirectoryMetavalueString]										ifFalse: [stream upTo: self separator]);								setPathname: ((Pathname readFrom: stream separator: self separator) appendingPathname: pathname)]						ifFalse: [self]]				ifFalse: [self]]		ifFalse: 			[(self copy)				setPathname: pathname withAllButLast;				beImmutable]</body><body package="Passport-Kernel" selector="suffix">suffix	"Answer a ResourcePath that is the suffix of the receiver--constructed by removing all but the last component of the receiver's path."	^pathname isEmpty 		ifTrue: 			[| ns |			ns := self namespace.			(ns includes: self separator) 				ifTrue: 					[(self class fromString: ns) suffix]				ifFalse: [self]]		ifFalse: 			[(ResourcePath new)				setPathname: pathname withLast;				beImmutable]</body><body package="Passport-Kernel" selector="suffixString">suffixString	"Answer a String that corresponds to the last component of the receiver's path."	^pathname lastComponentIfNone: 			[| ns |			ns := self basicNamespace.			(ns notNil and: [ns includes: self separator]) 				ifTrue: [(self class fromString: ns) suffixString]				ifFalse: [self asString]]</body><body package="Passport-Kernel" selector="withoutExtension">withoutExtension	"Answer a ResourcePath constructed by removing an extension from the final component of the receiver's path."	^(self copy)		setPathname: (pathname withoutExtension: self extensionSeparator);		beImmutable</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="addQueryAssociation:">addQueryAssociation: anAssociation 	self assertMutability.	query == nil 		ifTrue: [query := Array with: anAssociation]		ifFalse: [query := query copyWith: anAssociation]</body><body package="Passport-Kernel" selector="append:">append: aComponent	self assertMutability.	pathname := pathname, (Pathname fromString: aComponent separator: self separator)</body><body package="Passport-Kernel" selector="appendAll:">appendAll: aComponentArray 	self assertMutability.	pathname := pathname copy.	aComponentArray 		do: [:each | pathname appendPathname: (Pathname fromString: each separator: self separator)]</body><body package="Passport-Kernel" selector="appendPathname:">appendPathname: aPathname	self assertMutability.	pathname := pathname copy.	pathname appendPathname: aPathname</body><body package="Passport-Kernel" selector="beAbsolute">beAbsolute	self assertMutability.	namespace == nil ifTrue: [namespace := self defaultNamespace].</body><body package="Passport-Kernel" selector="beInvariant">beInvariant	| facade |	self assertMutability.	context == nil ifTrue: [context := ResourcePathContext platformDefault].	protocol == nil ifTrue: [protocol := self defaultProtocol].	facade := self resourcePathFacade.	facade syntaxPermitsUserCredentials 		ifTrue: 			[user == nil ifTrue: [user := self defaultUser].			password == nil ifTrue: [password := self defaultPassword]].	hostname == nil ifTrue: [hostname := self defaultHostname].	facade syntaxPermitsPort 		ifTrue: [port == nil ifTrue: [port := self defaultPort]].	self beAbsolute</body><body package="Passport-Kernel" selector="beRelative">beRelative	self assertMutability.	hostname := #localhost.	namespace := nil</body><body package="Passport-Kernel" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	| stream facade |	self assertMutability.	namespace == nil 		ifFalse: 			[facade := self resourcePathFacade.			namespace size &gt; 1 				ifTrue: 					[(namespace occurrencesOf: self separator) &gt; 1 						ifTrue: 							[stream := namespace readStream.							(stream peekFor: self separator)								ifTrue: [namespace := facade rootDirectoryMetavalueString]								ifFalse: [namespace := stream upTo: self separator].							pathname := (Pathname readFrom: stream separator: self separator) appendingPathname: pathname]]				ifFalse: 					[namespace = facade defaultRootDirectoryString 						ifTrue: [namespace := facade rootDirectoryMetavalueString]]].	pathname beImmutable</body><body package="Passport-Kernel" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	self initializeAuthorityValues.	self initializeNonAuthorityValues</body><body package="Passport-Kernel" selector="initializeAuthorityValues">initializeAuthorityValues	self assertMutability.	hostname := nil.	port := nil.	user := nil.	password := nil.</body><body package="Passport-Kernel" selector="initializeNamespaceAndPathname">initializeNamespaceAndPathname	self assertMutability.	namespace := nil.	self initializePathname.</body><body package="Passport-Kernel" selector="initializeNonAuthorityValues">initializeNonAuthorityValues	self assertMutability.	self initializeNamespaceAndPathname.	self initializePostPathValues</body><body package="Passport-Kernel" selector="initializePathname">initializePathname	self assertMutability.	pathname := Pathname empty.</body><body package="Passport-Kernel" selector="initializePostPathValues">initializePostPathValues	self assertMutability.	query := nil.	fragment := nil.</body><body package="Passport-Kernel" selector="setComponents:">setComponents: anArrayOfStrings	self setPathname: (Pathname components: anArrayOfStrings)</body><body package="Passport-Kernel" selector="setFragment:">setFragment: aStringOrNil	self assertMutability.	fragment := (UtilityFunction isNilOrEmpty: aStringOrNil) ifFalse: [aStringOrNil].</body><body package="Passport-Kernel" selector="setHostname:">setHostname: nilOrAnInternetHostnameString	"See #hostname"	self assertMutability.	hostname := (UtilityFunction isNilOrEmpty: nilOrAnInternetHostnameString) ifFalse: [nilOrAnInternetHostnameString asSymbol] "without any URI prefix"</body><body package="Passport-Kernel" selector="setNamespace:">setNamespace: nilOrAStringSpecifyingTheRootVolumeOrDeviceName 	"See #namespace"	self assertMutability.	namespace := 		(UtilityFunction isNilOrEmpty: nilOrAStringSpecifyingTheRootVolumeOrDeviceName)			ifFalse: 				[nilOrAStringSpecifyingTheRootVolumeOrDeviceName = self resourcePathFacade currentDirectoryMetavalueString 					ifFalse: [nilOrAStringSpecifyingTheRootVolumeOrDeviceName]]</body><body package="Passport-Kernel" selector="setPassword:">setPassword: aString	self assertMutability.	password := (UtilityFunction isNilOrEmpty: aString) ifFalse: [aString]</body><body package="Passport-Kernel" selector="setPathname:">setPathname: aPathame	self assertMutability.	pathname := aPathame == nil ifTrue: [Pathname empty] ifFalse: [aPathame]</body><body package="Passport-Kernel" selector="setPort:">setPort: portNumber	self assertMutability.	port := portNumber</body><body package="Passport-Kernel" selector="setProtocol:">setProtocol: protocolSymbol	self assertMutability.	protocol := protocolSymbol</body><body package="Passport-Kernel" selector="setResourcePathContext:">setResourcePathContext: aResourcePathContext 	self assertMutability.	context := 		aResourcePathContext == nil 			ifFalse: [aResourcePathContext isPlatformDefault ifFalse: [aResourcePathContext]]</body><body package="Passport-Kernel" selector="setUser:">setUser: aString	self assertMutability.	user := (UtilityFunction isNilOrEmpty: aString) ifFalse: [aString]</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>stream creation</category><body package="Passport-Kernel" selector="appendStream">appendStream	"Semantics defined by ANSI Smalltalk standard for external streams."	^self writeStreamWithMode: #append</body><body package="Passport-Kernel" selector="newWriteStream">newWriteStream	"Semantics defined by ANSI Smalltalk standard for external streams."	^self writeStreamWithMode: #truncate check: false</body><body package="Passport-Kernel" selector="readStream">readStream	"Semantics defined by ANSI Smalltalk standard for external streams."	^self readStreamWithType: #text</body><body package="Passport-Kernel" selector="readStreamWithType:">readStreamWithType: ansiTypeSymbol	"Semantics defined by ANSI Smalltalk standard for external streams."	^self resourcePathFacade newExternalReadStream: self asOperand type: ansiTypeSymbol</body><body package="Passport-Kernel" selector="withNewWriteStreamDo:">withNewWriteStreamDo: block1	| stream |	stream := self newWriteStream.	^[block1 value: stream] ensure: [stream close]</body><body package="Passport-Kernel" selector="withReadStreamDo:">withReadStreamDo: block1	| stream |	stream := self readStream.	^[block1 value: stream] ensure: [stream close]</body><body package="Passport-Kernel" selector="withWriteStreamDo:">withWriteStreamDo: block1	| stream |	stream := self writeStream.	^[block1 value: stream] ensure: [stream close]</body><body package="Passport-Kernel" selector="writeStream">writeStream	"Semantics defined by ANSI Smalltalk standard for external streams."	^self writeStreamWithMode: #create</body><body package="Passport-Kernel" selector="writeStreamWithMode:">writeStreamWithMode: ansiModeSymbol	"Semantics defined by ANSI Smalltalk standard for external streams."	^self writeStreamWithMode: ansiModeSymbol check: false</body><body package="Passport-Kernel" selector="writeStreamWithMode:check:">writeStreamWithMode: ansiModeSymbol check: enforceExistentialConstraint	"Semantics defined by ANSI Smalltalk standard for external streams."	^self writeStreamWithMode: ansiModeSymbol check: enforceExistentialConstraint type: #text</body><body package="Passport-Kernel" selector="writeStreamWithMode:check:type:">writeStreamWithMode: ansiModeSymbol check: enforceExistentialConstraint type: ansiTypeSymbol 	"Semantics defined by ANSI Smalltalk standard for external streams."	^self resourcePathFacade 		newExternalWriteStream: self asOperand		mode: ansiModeSymbol		check: enforceExistentialConstraint		type: ansiTypeSymbol</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>testing</category><body package="Passport-Kernel" selector="exists">exists	"Answer true if the resource named by the receiver exists.  Otherwise, answer false."	^self resourcePathFacade resourceExists: self asOperand</body><body package="Passport-Kernel" selector="hasDefaultPort">hasDefaultPort	^self port = (ResourcePathContext defaultPortAt: self protocol)</body><body package="Passport-Kernel" selector="hasExtension">hasExtension	"Answer true if the final component of the receiver's path has an extension. Otherwise, answer false."	^self hasExtensionUsingSeparator: self extensionSeparator</body><body package="Passport-Kernel" selector="hasExtensionUsingSeparator:">hasExtensionUsingSeparator: extensionSeparator	"Answer true if the final component of the receiver's path has an extension--using the &lt;extensionSeparator&gt; character to separate the extension suffix from the base prefix. Otherwise, answer false."	^pathname hasExtensionUsingSeparator: extensionSeparator</body><body package="Passport-Kernel" selector="hasFragment">hasFragment	^fragment notNil</body><body package="Passport-Kernel" selector="hasQuery">hasQuery	^query notNil</body><body package="Passport-Kernel" selector="isAbsolute">isAbsolute	"Answer true if the receiver's path is absolute. Otherwise, answer false."	^self specifiesNamespace</body><body package="Passport-Kernel" selector="isCurrentDirectory">isCurrentDirectory	"Answer true if the receiver is a proxy that dynamically refers to the path of the current directory. Otherwise, answer false."	^self isRelative and: [pathname isEmpty]</body><body package="Passport-Kernel" selector="isDirectory">isDirectory	"Answer true if the receiver names a directory (a resource that functions as a namespece containing other named resources.) Otherwise, answer false."	^pathname isEmpty or: [self resourcePathFacade resourceIsDirectory: self asOperand]</body><body package="Passport-Kernel" selector="isLocal">isLocal	"Answer true if the receiver names a resource located on the local host. Otherwise, answer false."	^self hostname == #localhost</body><body package="Passport-Kernel" selector="isRelative">isRelative	"Answer true if the receiver's path is relative to the current directory. Otherwise, answer false."	^self isAbsolute not</body><body package="Passport-Kernel" selector="isRemote">isRemote	"Answer true if the receiver names a resource located on a remote host. Otherwise, answer false."	^self isLocal not</body><body package="Passport-Kernel" selector="isRoot">isRoot	"Answer true if the receiver names a root directory or namespace. Otherwise, answer false."	^self isAbsolute and: [pathname isEmpty]</body><body package="Passport-Kernel" selector="pathnameIsEmpty">pathnameIsEmpty	^pathname isEmpty</body><body package="Passport-Kernel" selector="specifiesNamespace">specifiesNamespace	^namespace notNil or: 			[context == nil 				ifTrue: [false]				ifFalse: [self resourcePathContext specifiesDefaultNamespaceAt: self protocol]]</body><body package="Passport-Kernel" selector="specifiesNonDefaultPort">specifiesNonDefaultPort	^(port notNil and: [port &gt;= 0]) and: [port ~= (context == nil ifTrue: [ResourcePathContext] ifFalse: [self resourcePathContext]) defaultPortAt: self protocol]</body><body package="Passport-Kernel" selector="specifiesPassword">specifiesPassword	^password notNil or: [context notNil and: [self resourcePathContext hasDefaultPassword]]</body><body package="Passport-Kernel" selector="specifiesUser">specifiesUser	^user notNil or: [context notNil and: [self resourcePathContext hasDefaultUser]]</body><body package="Passport-Kernel" selector="specifiesUserCredentials">specifiesUserCredentials	^self specifiesUser or: [self specifiesPassword]</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>enumerating</category><body package="Passport-Kernel" selector="queryKeysAndValuesDo:">queryKeysAndValuesDo: block2 	query == nil ifTrue: [^self].	query 		do: [:association | block2 value: association key copy value: association value copy]</body><body package="Passport-Kernel" selector="withPrefixesFromRootAndThenWithSelfDo:">withPrefixesFromRootAndThenWithSelfDo: block1 	"Evaluate &lt;block1&gt; with each prefix of the receiver as the argument, such that each prefix is a ResourcePath representing the complete path from the receiver's root to that prefix, starting with the ResourcePath of the receiver's root component and ending with the receiver itself."	"ResourcePath defaultDirectory withPrefixesFromRootAndThenWithSelfDo: [:each | Transcript cr; show: each printString]"	| prefix |	prefix := self prefix.	prefix == self ifFalse: [prefix withPrefixesFromRootAndThenWithSelfDo: block1 ].	block1 value: self</body><body package="Passport-Kernel" selector="withSelfAndThenWithPrefixesUpToRootDo:">withSelfAndThenWithPrefixesUpToRootDo: block1 	"Evaluate &lt;block1&gt; with each prefix of the receiver as the argument, such that each prefix is a ResourcePath representing the complete path from the receiver's root to that prefix, starting with the receiver itself and ending with the ResourcePath of the receiver's root component."	"ResourcePath defaultDirectory withSelfAndThenWithPrefixesUpToRootDo: [:each | Transcript cr; show: each printString]"	| next prev |	prev := nil.	next := self.	[next == prev] whileFalse: 			[prev := next.			next := next prefix.			block1 value: prev]</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>accessing</category><body package="Passport-Kernel" selector="extensionSeparator">extensionSeparator	^self resourcePathFacade fileExtensionSeparator</body><body package="Passport-Kernel" selector="fragment">fragment	^fragment == nil ifTrue: [''] ifFalse: [fragment copy]</body><body package="Passport-Kernel" selector="hostname">hostname	"Answer a Symbol representing the internet hostname of the internet node on which the file referenced by the receiver resides. By default, answer #localhost"	^hostname == nil ifTrue: [self defaultHostname] ifFalse: [hostname]</body><body package="Passport-Kernel" selector="namespace">namespace	"Answer a String that identifies the full absolute pathname of the root namespace in which the file referenced by the receiver resides.  If the receiver is a relative file reference, then the answered value should specify (as a native filesystem String) the full absolute pathname of the current default directory/folder. In any case, the answered String must start with (and need contain no more than) the root directory of the default volume/device (e.g., '/' on a Unix system, 'C:\' on a Windows system, 'someDriveName:' on a Macintosh.)"		| stream |	stream := (String new: (namespace == nil ifTrue: [1] ifFalse: [namespace size + 1])) writeStream.	self resourcePathFacade basicPrintNamespaceOf: self isPrefixed: false on: stream.	^stream contents</body><body package="Passport-Kernel" selector="password">password	^password == nil ifTrue: [self defaultPassword] ifFalse: [password copy]</body><body package="Passport-Kernel" selector="pathname">pathname	^pathname</body><body package="Passport-Kernel" selector="port">port	^port == nil ifTrue: [self defaultPort] ifFalse: [port]</body><body package="Passport-Kernel" selector="protocol">protocol	^protocol == nil ifTrue: [self defaultProtocol] ifFalse: [protocol]</body><body package="Passport-Kernel" selector="queryCount">queryCount	^query == nil ifTrue: [0] ifFalse: [query size]</body><body package="Passport-Kernel" selector="resourcePathContext">resourcePathContext	^context == nil 		ifTrue: [self defaultResourcePathContext]		ifFalse: [context]</body><body package="Passport-Kernel" selector="resourcePathFacade">resourcePathFacade	^self resourcePathContext facadeAt: self protocol</body><body package="Passport-Kernel" selector="separator">separator	^self resourcePathFacade pathnameSeparator</body><body package="Passport-Kernel" selector="user">user	^user == nil ifTrue: [self defaultUser] ifFalse: [user copy]</body><body package="Passport-Kernel" selector="value">value	"Answer the contents of the resource referenced by the receiver. Fail if the referenced resource is a directory, does not exist or is not accessible."	| writeStream |	writeStream := (String new: 4096) writeStream.	self withReadStreamDo: 			[:readStream | 			[readStream atEnd] whileFalse: [writeStream nextPut: readStream next]].	^writeStream contents</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>utilities</category><body package="Passport-Kernel" selector="setNonDefaultSpecifiedAttributesAsDefaultsInContext:">setNonDefaultSpecifiedAttributesAsDefaultsInContext: aResourcePathContext	| stream |	protocol == nil ifFalse: [aResourcePathContext defaultProtocol: self protocol].	user == nil ifFalse: [aResourcePathContext defaultPassword: self password].	password == nil ifFalse: [aResourcePathContext defaultHostnameAt: self protocol put: self hostname].	hostname == nil ifFalse: [aResourcePathContext defaultHostnameAt: self protocol put: hostname].	self specifiesNonDefaultPort ifTrue: [aResourcePathContext defaultPortAt: self protocol put: self port].	stream := (String new: 32) writeStream.	self printNamespaceAndPathnameOn: stream.	aResourcePathContext defaultNamspaceAt: self protocol put: stream contents.</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>file queries</category><body package="Passport-Kernel" selector="contents">contents	"Answer an Array of the ResourcePaths of all the resources contained by the directory (or namespace) named by the receiver. Fail if the receiver does not name an existing directory or namespace."	| stream |	stream := (Array new: 10) writeStream.	self contentsDo: [:rp | stream nextPut: rp].	^stream contents</body><body package="Passport-Kernel" selector="contentsDo:">contentsDo: block1	"Evaluate &lt;block1&gt; with the ResourcePath of each resource contained by the directory (or namespace) named by the receiver. Fail if the receiver does not name an existing directory or namespace."	^self resourcePathFacade withResourcePathsOfResourcesInDirectory: self asOperand do: block1</body><body package="Passport-Kernel" selector="extensionIfNone:">extensionIfNone: ifNone	"Answer, as a String, the extension that is the suffix of the final component of the receiver. Such extensions are often used to distinguish the type of date contained in a resource.  Commonly used extensions include '.txt' and '.jpg'."	^self extensionUsingSeparator: self extensionSeparator ifNone: ifNone</body><body package="Passport-Kernel" selector="extensionUsingSeparator:ifNone:">extensionUsingSeparator: extensionSeparator ifNone: ifNone	"Answer, as a String, the extension that is the suffix of the final component of the receiver. Such extensions are often used to distinguish the type of date contained in a resource.  Commonly used extensions include '.txt' and '.jpg'. Use &lt;extensionSeparator&gt; to distinguish the extension suffix from the base name prefix."	^pathname extensionUsingSeparator: extensionSeparator ifNone: ifNone</body><body package="Passport-Kernel" selector="resourceSize">resourceSize	"Answer the size in bytes of the resource named by the receiver."	^self resourcePathFacade sizeOfResource: self asOperand</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>private</category><body package="Passport-Kernel" selector="appendToPathname:">appendToPathname: aPathname	^aPathname appendingPathname: self pathname</body><body package="Passport-Kernel" selector="appendToResourcePath:">appendToResourcePath: aResourcePath	^aResourcePath appendingPathname: self pathname</body><body package="Passport-Kernel" selector="basicNamespace">basicNamespace	^namespace copy</body><body package="Passport-Kernel" selector="defaultHostname">defaultHostname	^context == nil 		ifTrue: [#localhost]		ifFalse: [self resourcePathContext defaultHostnameAt: self protocol]</body><body package="Passport-Kernel" selector="defaultNamespace">defaultNamespace	^self resourcePathFacade defaultNamespace</body><body package="Passport-Kernel" selector="defaultPassword">defaultPassword	^context == nil 		ifTrue: ['']		ifFalse: [self resourcePathContext defaultPassword]</body><body package="Passport-Kernel" selector="defaultPort">defaultPort	^(context == nil 		ifTrue: [ResourcePathContext]		ifFalse: [self resourcePathContext]) defaultPortAt: self protocol</body><body package="Passport-Kernel" selector="defaultProtocol">defaultProtocol	^context == nil 		ifTrue: [#platform]		ifFalse: [self resourcePathContext defaultProtocol]</body><body package="Passport-Kernel" selector="defaultResourcePathContext">defaultResourcePathContext	^(protocol == nil or: [protocol == #platform]) 		ifTrue: [ResourcePathContext platformDefault]		ifFalse: [ResourcePathContext default]</body><body package="Passport-Kernel" selector="defaultUser">defaultUser	^context == nil 		ifTrue: ['']		ifFalse: [self resourcePathContext defaultUser]</body><body package="Passport-Kernel" selector="printNamespaceAndPathnameOn:">printNamespaceAndPathnameOn: stream 	namespace == nil 		ifFalse: 			[self resourcePathFacade basicPrintNamespaceOf: self isPrefixed: false on: stream].	pathname printOn: stream usingSeparator: self separator</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>comparing</category><body package="Passport-Kernel" selector="compareTo:">compareTo: aPath	"Compare the value of the receiver to that of &lt;aPath&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aPath&gt; are the same.)"	self == aPath ifTrue: [^0].	^[aPath compareToResourcePath: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aPath and: [ex message selector == #compareToResourcePath:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Passport-Kernel" selector="hash">hash	^pathname hash</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>printing</category><body package="Passport-Kernel" selector="printOn:">printOn: stream	self resourcePathFacade print: self on: stream</body><body package="Passport-Kernel" selector="queryString">queryString	| stream |	self hasQuery ifFalse: [^''].	stream := (String new: 32) writeStream.	self resourcePathFacade printQueryOf: self on: stream.	^stream contents</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>private-testing</category><body package="Passport-Kernel" selector="basicSpecifiesHostname">basicSpecifiesHostname	^hostname notNil</body><body package="Passport-Kernel" selector="basicSpecifiesNamespace">basicSpecifiesNamespace	^namespace notNil</body><body package="Passport-Kernel" selector="basicSpecifiesPassword">basicSpecifiesPassword	^password notNil</body><body package="Passport-Kernel" selector="basicSpecifiesPort">basicSpecifiesPort	^port notNil and: [port &gt;= 0]</body><body package="Passport-Kernel" selector="basicSpecifiesUser">basicSpecifiesUser	^user notNil</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>file operations</category><body package="Passport-Kernel" selector="copyTo:">copyTo: aDestination 	"Copy the contents of the resource named by the receiver so that the resource named by &lt;aDestination&gt; will have the same contents."	^self 		resourcePathFacade copyResource: self asOperand		to: aDestination asOperand</body><body package="Passport-Kernel" selector="delete">delete	"Delete the resource named by the receiver."	self resourcePathFacade deleteResource: self asOperand</body><body package="Passport-Kernel" selector="makeDirectory">makeDirectory	"Create a resource directory at the path specified by the receiver."	self withPrefixesFromRootAndThenWithSelfDo: 			[:path | 			(path isRoot or: [path exists])				ifFalse: [self resourcePathFacade makeDirectory: path asOperand]]</body><body package="Passport-Kernel" selector="moveTo:">moveTo: aDestination	"Relocate the resource named by the receiver so that it's path will be that specified by &lt;aDestination&gt;."	^self resourcePathFacade moveResource: self asOperand to: aDestination asOperand</body><body package="Passport-Kernel" selector="renameTo:">renameTo: newName	"Change the name of the receiver to be &lt;newName&gt; (&lt;newName&gt; is a ResourcePath)."	self resourcePathFacade renameResource: self asOperand to: newName asOperand</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>private-comparing</category><body package="Passport-Kernel" selector="compareToResourcePath:">compareToResourcePath: otherPath 	| diff thisQS thatQS facade thisQueryCount thatQueryCount |	otherPath protocol &gt; self protocol ifTrue: [^1].	otherPath protocol &lt; self protocol ifTrue: [^-1].	facade := self resourcePathFacade.	facade syntaxPermitsUserCredentials 		ifTrue: 			[otherPath basicSpecifiesUser 				ifTrue: 					[self basicSpecifiesUser ifFalse: [^1].					otherPath user &gt; self user ifTrue: [^1].					otherPath user &lt; self user ifTrue: [^-1]]				ifFalse: [self basicSpecifiesUser ifTrue: [^-1]].			otherPath basicSpecifiesPassword 				ifTrue: 					[self basicSpecifiesPassword ifFalse: [^1].					otherPath password &gt; self password ifTrue: [^1].					otherPath password &lt; self password ifTrue: [^-1]]				ifFalse: [self basicSpecifiesPassword ifTrue: [^-1]]].	facade syntaxPermitsHostname 		ifTrue: 			[otherPath basicSpecifiesHostname 				ifTrue: 					[self basicSpecifiesHostname ifFalse: [^1].					otherPath hostname &gt; self hostname ifTrue: [^1].					otherPath hostname &lt; self hostname ifTrue: [^-1]]				ifFalse: [self basicSpecifiesHostname ifTrue: [^-1]]].	facade syntaxPermitsPort 		ifTrue: 			[otherPath basicSpecifiesPort 				ifTrue: 					[self basicSpecifiesPort ifFalse: [^1].					otherPath port &gt; self port ifTrue: [^1].					otherPath port &lt; self port ifTrue: [^-1]]				ifFalse: [self basicSpecifiesPort ifTrue: [^-1]]].	otherPath basicSpecifiesNamespace 		ifTrue: 			[self basicSpecifiesNamespace ifFalse: [^1].			otherPath namespace &gt; self namespace ifTrue: [^1].			otherPath namespace &lt; self namespace ifTrue: [^-1]]		ifFalse: [self basicSpecifiesNamespace ifTrue: [^-1]].	diff := otherPath pathname compareTo: self pathname.	diff = 0 ifFalse: [^diff].	facade syntaxPermitsQueryString 		ifTrue: 			[otherPath hasQuery 				ifTrue: [self hasQuery ifFalse: [^1]]				ifFalse: [self hasQuery ifTrue: [^-1]].			thisQueryCount := self queryCount.			thatQueryCount := otherPath queryCount.			thatQueryCount &gt; thisQueryCount ifTrue: [^1].			thatQueryCount &lt; thisQueryCount ifTrue: [^-1].			thisQS := self queryString.			thatQS := otherPath queryString.			thatQS &gt; thisQS ifTrue: [^1].			thatQS &lt; thisQS ifTrue: [^-1]].	facade syntaxPermitsFragment 		ifTrue: 			[otherPath hasFragment 				ifTrue: [self hasFragment ifFalse: [^1]]				ifFalse: [self hasFragment ifTrue: [^-1]].			otherPath fragment &gt; self fragment ifTrue: [^1].			otherPath fragment &lt; self fragment ifTrue: [^-1]].	^0</body></methods><methods><class-id>Passport.ResourcePath</class-id> <category>deprecated</category><body package="Passport-Kernel" selector="fileSize">fileSize	"Answer the size in bytes of the resource named by the receiver."	^self resourcePathFacade sizeOfResource: self asOperand</body></methods><methods><class-id>Passport.ResourcePath class</class-id> <category>instance creation</category><body package="Passport-Kernel" selector="components:">components: anArrayOfStringsOrSymbols	^self new		setComponents: anArrayOfStringsOrSymbols;		beImmutable</body><body package="Passport-Kernel" selector="context:">context: aResourcePathContext	^self new		setResourcePathContext: aResourcePathContext;	beImmutable</body><body package="Passport-Kernel" selector="context:components:">context: aResourcePathContext components: anArrayOfStringsOrSymbols 	^self 		context: aResourcePathContext		pathname: (Pathname components: anArrayOfStringsOrSymbols)</body><body package="Passport-Kernel" selector="context:pathname:">context: aResourcePathContext pathname: pathname	^self new		setResourcePathContext: aResourcePathContext;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="context:protocol:components:">context: aResourcePathContext protocol: protocol components: anArrayOfStringsOrSymbols 	^self 		context: aResourcePathContext		protocol: protocol		pathname: (Pathname components: anArrayOfStringsOrSymbols)</body><body package="Passport-Kernel" selector="context:protocol:hostname:namespace:components:">context: aResourcePathContext protocol: protocol hostname: hostname namespace: namespace components: anArrayOfStringsOrSymbols 	^self 		context: aResourcePathContext		protocol: protocol		hostname: hostname		namespace: namespace		pathname: (Pathname components: anArrayOfStringsOrSymbols)</body><body package="Passport-Kernel" selector="context:protocol:hostname:namespace:pathname:">context: aResourcePathContext protocol: protocol hostname: hostname namespace: namespace pathname: pathname 	^(self basicNew)		setResourcePathContext: aResourcePathContext;		setProtocol: protocol;		setHostname: hostname;		setNamespace: namespace;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="context:protocol:hostname:port:components:">context: aResourcePathContext protocol: protocol hostname: hostname port: portNumber components: anArrayOfStringsOrSymbols	^self 		context: aResourcePathContext		protocol: protocol		hostname: hostname		port: portNumber		pathname: (Pathname components: anArrayOfStringsOrSymbols)</body><body package="Passport-Kernel" selector="context:protocol:hostname:port:pathname:">context: aResourcePathContext protocol: protocol hostname: hostname port: portNumber pathname: pathname 	^(self basicNew)		setResourcePathContext: aResourcePathContext;		setProtocol: protocol;		setHostname: hostname;		setPort: portNumber;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="context:protocol:namespace:">context: aResourcePathContext protocol: protocol namespace: namespace	^self new		setResourcePathContext: aResourcePathContext;		setProtocol: protocol;		setNamespace: namespace;		beImmutable</body><body package="Passport-Kernel" selector="context:protocol:namespace:components:">context: aResourcePathContext protocol: protocol namespace: namespace components: anArrayOfStringsOrSymbols 	^self 		context: aResourcePathContext		protocol: protocol		namespace: namespace		pathname: (Pathname components: anArrayOfStringsOrSymbols)</body><body package="Passport-Kernel" selector="context:protocol:namespace:pathname:">context: aResourcePathContext protocol: protocol namespace: namespace pathname: pathname	^self new		setResourcePathContext: aResourcePathContext;		setProtocol: protocol;		setNamespace: namespace;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="context:protocol:pathname:">context: aResourcePathContext protocol: protocol pathname: pathname	^self new		setResourcePathContext: aResourcePathContext;		setProtocol: protocol;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="context:protocol:user:password:hostname:port:pathname:">context: aResourcePathContext protocol: protocol user: userString password: passwordString hostname: hostname port: portNumber pathname: pathname 	^(self basicNew)		setResourcePathContext: aResourcePathContext;		setProtocol: protocol;		setUser: userString;		setPassword: passwordString;		setHostname: hostname;		setPort: portNumber;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="hostname:namespace:components:">hostname: hostname namespace: namespace components: anArrayOfStringsOrSymbols	^self 		hostname: hostname		namespace: namespace		pathname: (Pathname components: anArrayOfStringsOrSymbols)</body><body package="Passport-Kernel" selector="hostname:namespace:pathname:">hostname: hostname namespace: namespace pathname: pathname	^self basicNew		setHostname: hostname;		setNamespace: namespace;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="namespace:">namespace: namespace	^self new		setNamespace: namespace;		beImmutable</body><body package="Passport-Kernel" selector="namespace:components:">namespace: namespace components: anArrayOfStringsOrSymbols 	^self 		namespace: namespace		pathname: (Pathname components: anArrayOfStringsOrSymbols)</body><body package="Passport-Kernel" selector="namespace:pathname:">namespace: namespace pathname: pathname	^self new		setNamespace: namespace;		setPathname: pathname;		beImmutable</body><body package="Passport-Kernel" selector="pathname:">pathname: pathname	^self new		setPathname: pathname;		beImmutable</body></methods><methods><class-id>Passport.ResourcePath class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="currentDirectory">currentDirectory	"ResourcePath currentDirectory"	^self new</body><body package="Passport-Kernel" selector="defaultDirectory">defaultDirectory	"ResourcePath defaultDirectory"	^self fromString: self defaultResourcePathFacade defaultDirectoryPathnameString</body><body package="Passport-Kernel" selector="defaultResourcePathContext">defaultResourcePathContext	^ResourcePathContext platformDefault</body><body package="Passport-Kernel" selector="defaultResourcePathFacade">defaultResourcePathFacade	^self defaultResourcePathContext defaultFacade</body></methods><methods><class-id>Passport.ResourcePath class</class-id> <category>parsing</category><body package="Passport-Kernel" selector="from:defaultProtocol:protocolAndSuffixStreamInto:">from: stream defaultProtocol: defaultProtocol protocolAndSuffixStreamInto: block2	"ResourcePath from: 'xy' readStream defaultProtocol: #platform protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	"ResourcePath from: 'xyz' readStream defaultProtocol: #http protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	"ResourcePath from: 'foo:bar' readStream defaultProtocol: #file protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	"ResourcePath from: 'foo:bar' readStream defaultProtocol: #http protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	"ResourcePath from: '//foo/bar' readStream defaultProtocol: #https protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	"ResourcePath from: 'http://foo/bar' readStream defaultProtocol: #file protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	"ResourcePath from: 'ldap://foo/bar' readStream defaultProtocol: #http protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	"ResourcePath from: 'junk://foo/bar' readStream defaultProtocol: #file protocolAndSuffixStreamInto: [:protocol :suffixStream | Array with: protocol with: suffixStream upToEnd]"	| startPosition protocolIndex protocol |	startPosition := stream position.	protocol := UtilityFunction 					nextFrom: stream 					while: [:ch | ch isLetter] 					minChars: 3 					maxChars: 5 					onUnexpectedEOD: [:prefix :ch :position | stream skip: startPosition - position. ^block2 value: defaultProtocol value: stream].	((stream peekFor: $:) and: [(protocolIndex := #('file' 'http' 'https' 'ftp' 'ldap') indexOf: protocol ifAbsent: [0]) &gt; 0])		ifFalse: [stream skip: startPosition - stream position. ^block2 value: defaultProtocol value: stream].	^block2 value: (#(#file #http #https #ftp #ldap) at: protocolIndex) value: stream</body><body package="Passport-Kernel" selector="fromString:">fromString: aStringNamingAResource 	"{ResourcePath fromString: ResourcePath defaultResourcePathFacade defaultDirectoryPathnameString}"	^self readFrom: aStringNamingAResource readStream</body><body package="Passport-Kernel" selector="fromString:withContext:">fromString: aStringNamingAResource withContext: aResourcePathContext 	"{ResourcePath fromString: '/foo/bar/baz?q=who+goes+there&amp;context=http#boink' withContext: (ResourcePathContext new defaultProtocol: #http)}"	^self 		readFrom: aStringNamingAResource readStream		withContext: aResourcePathContext</body><body package="Passport-Kernel" selector="readFrom:">readFrom: stream 	^self readFrom: stream withContext: self defaultResourcePathContext</body><body package="Passport-Kernel" selector="readFrom:withContext:">readFrom: stream withContext: aResourcePathContext 	| context |	context := aResourcePathContext == nil ifTrue: [self defaultResourcePathContext] ifFalse: [aResourcePathContext].	^self 		from: stream		defaultProtocol: context defaultProtocol		protocolAndSuffixStreamInto: 			[:protocol :suffixStream | (context facadeAt: protocol) constructResourcePathFromStream: suffixStream]</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>accessing</category><body package="Chronos-Parsing" selector="calendar">calendar	^calendar</body><body package="Chronos-Parsing" selector="defaultCalendarDurationFactory">defaultCalendarDurationFactory	^CalendarDurationFactory</body><body package="Chronos-Parsing" selector="defaultCivilDurationFactory">defaultCivilDurationFactory	^CivilDurationFactory</body><body package="Chronos-Parsing" selector="defaultDateAndTimeFactory">defaultDateAndTimeFactory	^DateAndTimeFactory</body><body package="Chronos-Parsing" selector="defaultDateFactory">defaultDateFactory	^DateFactory</body><body package="Chronos-Parsing" selector="defaultDurationFactory">defaultDurationFactory	^DurationFactory</body><body package="Chronos-Parsing" selector="defaultTimeOfDayFactory">defaultTimeOfDayFactory	^TimeOfDayFactory</body><body package="Chronos-Parsing" selector="defaultTimeZone">defaultTimeZone	^defaultTimeZone == nil 		ifTrue: [ChronosTimezone default]		ifFalse: [defaultTimeZone]</body><body package="Chronos-Parsing" selector="defaultTimeperiodFactory">defaultTimeperiodFactory	^TimeperiodFactory</body><body package="Chronos-Parsing" selector="locale">locale	^locale</body><body package="Chronos-Parsing" selector="maxMonthNameSize">maxMonthNameSize	^maxMonthNameSize</body><body package="Chronos-Parsing" selector="minMonthNameSize">minMonthNameSize	^minMonthNameSize</body><body package="Chronos-Parsing" selector="monthAbbreviations">monthAbbreviations	^monthNameKeysByMonthAbbreviation keys</body><body package="Chronos-Parsing" selector="monthNameKeys">monthNameKeys	^monthNameKeysByMonthName values</body><body package="Chronos-Parsing" selector="monthNames">monthNames	^monthNameKeysByMonthName keys</body><body package="Chronos-Parsing" selector="twoDigitYearBackwardBias">twoDigitYearBackwardBias	^twoDigitYearBackwardBias</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>initialize-release</category><body package="Chronos-Parsing" selector="beDefault">beDefault	self beImmutable.	Default := self</body><body package="Chronos-Parsing" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	super canonicalize.	timeZoneSeparators == nil ifTrue: [timeZoneSeparators := self constructTimeZoneSeparators].	locale == nil ifTrue: [locale := ChronosLocale default].	self bindMonthNamesAndAbbreviations.	self bindDayOfWeekNamesAndAbbreviations.	self bindMeridianNames</body><body package="Chronos-Parsing" selector="initialize">initialize 	self assertMutability.	timeZoneSeparators := self constructTimeZoneSeparators.	calendar := AnsiStandardCalendar.	locale := nil.	defaultTimeZone := ChronosTimezone nominal.	twoDigitYearBackwardBias := nil.	self interpretMonthNumberAsOrdinal.</body><body package="Chronos-Parsing" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	"ChronosParser iso8601 literalArrayEncoding decodeAsLiteralArray"	super initializeFromLiteralArray: literalArray.	self 		setCalendar: (literalArray at: 3);		setLocale: (literalArray at: 4) decodeAsLiteralArray;		setDefaultTimeZone: (literalArray at: 5) decodeAsLiteralArray;		setTwoDigitYearBackwardBias: (literalArray at: 6).	monthNameKeysByMonthName := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 7).	monthNameKeysByMonthAbbreviation := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 8).	minMonthNameSize := literalArray at: 9.	maxMonthNameSize := literalArray at: 10.	monthNumberInterpretationPolicy := literalArray at: 11.	dayOfWeekKeysByName := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 12).	dayOfWeekKeysByAbbreviation := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 13).	minDayOfWeekNameSize := literalArray at: 14.	maxDayOfWeekNameSize := literalArray at: 15.	meridianNames := literalArray at: 16.	meridianNameCharSet := Set withAll: (literalArray at: 17) .	minMeridianNameSize := literalArray at: 18.	maxMeridianNameSize := literalArray at: 19.</body><body package="Chronos-Parsing" selector="setCalendar:">setCalendar: aCalendar 	self assertMutability.	calendar := Calendar referencedBy: aCalendar</body><body package="Chronos-Parsing" selector="setDefaultTimeZone:">setDefaultTimeZone: timeZone 	self assertMutability.	defaultTimeZone := timeZone == nil ifFalse: [ChronosTimezone referencedBy: timeZone]</body><body package="Chronos-Parsing" selector="setLocale:">setLocale: aLocale 	self assertMutability.	locale := ChronosLocale referencedBy: aLocale</body><body package="Chronos-Parsing" selector="setTwoDigitYearBackwardBias:">setTwoDigitYearBackwardBias: anInteger 	self assertMutability.	twoDigitYearBackwardBias := anInteger</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>error handling</category><body package="Chronos-Parsing" selector="handleDayOfWeek:inconsistentWithThatOf:">handleDayOfWeek: dayOfWeeKey inconsistentWithThatOf: aDate 	| actualDayOfWeekKey |	actualDayOfWeekKey := aDate dayOfWeekKey.	^self 		signalError: 'The specified day of week, ' 				, (self locale properNameAtSemanticKey: dayOfWeeKey) 					, ', is not consistent wth that of the specified date, ' 					, (aDate printStringForLocale: self locale),					' (which occurs on a ', (self locale properNameAtSemanticKey: actualDayOfWeekKey), ')'</body><body package="Chronos-Parsing" selector="handleInvalidDayOfMonth:digitCount:problemKey:">handleInvalidDayOfMonth: dayOfMonth digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid day-of-month: ', dayOfMonth printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidDays:digitCount:problemKey:">handleInvalidDays: days digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid days: ', days printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidHour:digitCount:problemKey:">handleInvalidHour: hour digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid hour: ', hour printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidIsoDayOfWeek:digitCount:problemKey:">handleInvalidIsoDayOfWeek: dayOfWeek digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid day-of-week: ', dayOfWeek printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidMinute:digitCount:problemKey:">handleInvalidMinute: minute digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid minute: ', minute printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidMonth:problemKey:">handleInvalidMonth: month problemKey: problemKey	^self signalError: 'Invalid month: ', month printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidMonths:digitCount:problemKey:">handleInvalidMonths: months digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid months: ', months printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidSecond:digitCount:problemKey:">handleInvalidSecond: second digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid second: ', second printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidYear:digitCount:problemKey:">handleInvalidYear: year digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid year: ', year printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleInvalidYears:digitCount:problemKey:">handleInvalidYears: years digitCount: digitCount problemKey: problemKey	^self signalError: 'Invalid years: ', years printString, ' problem:', problemKey</body><body package="Chronos-Parsing" selector="handleUnexpectedCharacter:for:">handleUnexpectedCharacter: char for: format	^self signalError: 'Unexpected/inalid character: ', (String with: char), ' in ', format</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>private</category><body package="Chronos-Parsing" selector="basicNewDateAndTimeUsing:isoYear:week:dayOfWeek:hour:minute:second:timeZone:">basicNewDateAndTimeUsing: dateAndTimeFactory isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second timeZone: timeZone 	^(dateAndTimeFactory 		isoYear: (self canonicalYearFromYear: isoYear)		week: isoWeekOrdinal		dayOfWeek: isoDayOfWeekOrdinal		hour: (hour == nil ifTrue: [0] ifFalse: [hour])		minute: (minute == nil ifTrue: [0] ifFalse: [minute])		second: (second == nil ifTrue: [0] ifFalse: [second])		timeZone: timeZone) as: calendar</body><body package="Chronos-Parsing" selector="basicNewDateAndTimeUsing:year:day:hour:minute:second:timeZone:">basicNewDateAndTimeUsing: dateAndTimeFactory year: year day: day hour: hour minute: minute second: second timeZone: timeZone 	^dateAndTimeFactory 		year: year		day: day		hour: hour		minute: minute		second: second		timeZone: timeZone		calendar: calendar</body><body package="Chronos-Parsing" selector="basicNewDateAndTimeUsing:year:month:day:hour:minute:second:timeZone:">basicNewDateAndTimeUsing: dateAndTimeFactory year: year month: month day: day hour: hour minute: minute second: second timeZone: timeZone 	^dateAndTimeFactory 		year: year		month: month		day: day		hour: hour		minute: minute		second: second		timeZone: timeZone		calendar: calendar</body><body package="Chronos-Parsing" selector="basicNewDateUsing:isoYear:week:dayOfWeek:">basicNewDateUsing: dateFactory isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal	^(dateFactory 		isoYear: (self canonicalYearFromYear: isoYear)		week: isoWeekOrdinal		dayOfWeek: isoDayOfWeekOrdinal) as: calendar</body><body package="Chronos-Parsing" selector="basicNewDateUsing:year:day:">basicNewDateUsing: dateFactory year: year day: day	^dateFactory 		year: year		day: day		calendar: calendar</body><body package="Chronos-Parsing" selector="basicNewDateUsing:year:month:day:">basicNewDateUsing: dateFactory year: year month: month day: day	^dateFactory 		year: year		month: month		day: day		calendar: calendar</body><body package="Chronos-Parsing" selector="bindDayOfWeekNamesAndAbbreviations">bindDayOfWeekNamesAndAbbreviations	dayOfWeekKeysByName := Dictionary new.	dayOfWeekKeysByAbbreviation := Dictionary new.	minDayOfWeekNameSize := 99999999.	maxDayOfWeekNameSize := 0.		ANSIDayOfWeekKeys do: 			[:dayOfWeekKey | 			| name abbreviation |			name := (locale properNameAtSemanticKey: dayOfWeekKey) asUppercase.			abbreviation := (locale abbreviationAtSemanticKey: dayOfWeekKey) asUppercase.			dayOfWeekKeysByName at: name put: dayOfWeekKey.			dayOfWeekKeysByAbbreviation at: abbreviation put: dayOfWeekKey.			minDayOfWeekNameSize := minDayOfWeekNameSize 						min: (name size min: abbreviation size).			maxDayOfWeekNameSize := maxDayOfWeekNameSize 						max: (name size max: abbreviation size)]</body><body package="Chronos-Parsing" selector="bindMeridianNames">bindMeridianNames	meridianNames := MeridianKeys collect: [:semanticKey | (self locale properNameAtSemanticKey: semanticKey) asUppercase asSymbol].	meridianNameCharSet := Set new.	minMeridianNameSize := 999.	maxMeridianNameSize := 0.	meridianNames do: [:name | 		meridianNameCharSet addAll: name; addAll: name asLowercase.		minMeridianNameSize := minMeridianNameSize min: name size.		maxMeridianNameSize := maxMeridianNameSize max: name size].</body><body package="Chronos-Parsing" selector="bindMonthNamesAndAbbreviations">bindMonthNamesAndAbbreviations	monthNameKeysByMonthName := Dictionary new.	monthNameKeysByMonthAbbreviation := Dictionary new.	minMonthNameSize := 99999999.	maxMonthNameSize := 0.		calendar monthNameKeysDo: 			[:monthNameKey | 			| name abbreviation |			name := (locale properNameAtSemanticKey: monthNameKey) asUppercase.			abbreviation := (locale abbreviationAtSemanticKey: monthNameKey) asUppercase.			monthNameKeysByMonthName at: name put: monthNameKey.			monthNameKeysByMonthAbbreviation at: abbreviation put: monthNameKey.			minMonthNameSize := minMonthNameSize 						min: (name size min: abbreviation size).			maxMonthNameSize := maxMonthNameSize 						max: (name size max: abbreviation size)]</body><body package="Chronos-Parsing" selector="constructTimeZoneSeparators">constructTimeZoneSeparators	^Array		with: $-		with: $+		with: Character cr		with: Character lf</body><body package="Chronos-Parsing" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	"ChronosParser iso8601 literalArrayEncoding"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: calendar registrationKey;		nextPut: locale literalArrayEncoding;		nextPut: defaultTimeZone literalArrayEncoding;		nextPut: twoDigitYearBackwardBias;		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: monthNameKeysByMonthName);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: monthNameKeysByMonthAbbreviation);		nextPut: minMonthNameSize;		nextPut: maxMonthNameSize;		nextPut: monthNumberInterpretationPolicy;		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: dayOfWeekKeysByName);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: dayOfWeekKeysByAbbreviation);		nextPut: minDayOfWeekNameSize;		nextPut: maxDayOfWeekNameSize;		nextPut: meridianNames;		nextPut: meridianNameCharSet asArray;		nextPut: minMeridianNameSize;		nextPut: maxMeridianNameSize</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>configuration-dates</category><body package="Chronos-Parsing" selector="interpretMonthNumberAsNumericDesignator">interpretMonthNumberAsNumericDesignator	self assertMutability.	monthNumberInterpretationPolicy := #canonicalMonthFromNumericMonthDesignator:inYear:.</body><body package="Chronos-Parsing" selector="interpretMonthNumberAsOrdinal">interpretMonthNumberAsOrdinal	self assertMutability.	monthNumberInterpretationPolicy := #canonicalMonthFromMonthOrdinal:inYear:.</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>API-date/time/duration/period instantiation</category><body package="Chronos-Parsing" selector="newCalendarDurationUsing:years:months:days:">newCalendarDurationUsing: calendarDurationFactory years: years months: months days: days 	^calendarDurationFactory 		years: years		months: months		days: days</body><body package="Chronos-Parsing" selector="newCivilDurationUsing:years:months:days:hours:minutes:seconds:">newCivilDurationUsing: civilDurationFactory years: years months: months days: days hours: hours minutes: minutes seconds: seconds 	^(hours = 0 and: [minutes = 0 and: [seconds = 0]]) 		ifTrue: 			[self 				newCalendarDurationUsing: civilDurationFactory calendarDurationFactory				years: years				months: months				days: days]		ifFalse: 			[civilDurationFactory 				years: years				months: months				days: days				hours: hours				minutes: minutes				seconds: seconds]</body><body package="Chronos-Parsing" selector="newDateAndTimeUsing:isoYear:week:dayOfWeek:hour:minute:second:timeZone:">newDateAndTimeUsing: dateAndTimeFactory isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal hour: hour minute: minute second: second timeZone: timeZone 	isoWeekOrdinal == nil 		ifTrue: 			[^self 				newDateUsing: dateAndTimeFactory dateFactory				year: isoYear				day: nil				timeZone: timeZone].	^isoDayOfWeekOrdinal == nil 		ifTrue: 			[isoYear == nil				ifTrue:					[self 						newTimeOfDayUsing: dateAndTimeFactory timeOfDayFactory						hour: hour						minute: minute						second: second]				ifFalse:					[self 						newDateUsing: dateAndTimeFactory dateFactory						isoYear: isoYear						week: isoWeekOrdinal						dayOfWeek: isoDayOfWeekOrdinal						timeZone: timeZone]]		ifFalse: 			[hour == nil 				ifTrue: 					[self 						newDateUsing: dateAndTimeFactory dateFactory 						isoYear: isoYear 						week: isoWeekOrdinal						dayOfWeek: isoDayOfWeekOrdinal 						timeZone: timeZone]				ifFalse: 					[| canonicalYear |					canonicalYear := self canonicalYearFromYear: isoYear.					minute == nil						ifTrue: 							[self 								newTimeperiodUsing: dateAndTimeFactory timeperiodFactory								from: 									(self 										basicNewDateAndTimeUsing: dateAndTimeFactory 										isoYear: canonicalYear										week: isoWeekOrdinal										dayOfWeek: isoDayOfWeekOrdinal										hour: hour										minute: 0										second: 0										timeZone: timeZone)								duration: (dateAndTimeFactory civilDurationFactory hours: 1)]						ifFalse:							[second == nil								ifTrue:									[self 										newTimeperiodUsing: dateAndTimeFactory timeperiodFactory										from: 											(self 												basicNewDateAndTimeUsing: dateAndTimeFactory												isoYear: canonicalYear												week: isoWeekOrdinal												dayOfWeek: isoDayOfWeekOrdinal												hour: hour												minute: minute												second: 0												timeZone: timeZone)										duration: (dateAndTimeFactory civilDurationFactory minutes: 1)]								ifFalse:									[self 										basicNewDateAndTimeUsing: dateAndTimeFactory 										isoYear: canonicalYear										week: isoWeekOrdinal										dayOfWeek: isoDayOfWeekOrdinal										hour: hour										minute: minute										second: second										timeZone: timeZone]]]]</body><body package="Chronos-Parsing" selector="newDateAndTimeUsing:year:day:hour:minute:second:timeZone:">newDateAndTimeUsing: dateAndTimeFactory year: year day: day hour: hour minute: minute second: second timeZone: timeZone 	^day == nil 		ifTrue: 			[year == nil				ifTrue:					[self 						newTimeOfDayUsing: dateAndTimeFactory timeOfDayFactory						hour: hour						minute: minute						second: second]				ifFalse:					[self 						newDateUsing: dateAndTimeFactory dateFactory						year: year						day: day						timeZone: timeZone]]		ifFalse: 			[hour == nil 				ifTrue: 					[self 						newDateUsing: dateAndTimeFactory dateFactory 						year: year 						day: day 						timeZone: timeZone]				ifFalse: 					[| canonicalYear |					canonicalYear := self canonicalYearFromYear: year.					minute == nil						ifTrue: 							[self 								newTimeperiodUsing: dateAndTimeFactory timeperiodFactory								from: 									(self 										basicNewDateAndTimeUsing: dateAndTimeFactory 										year: canonicalYear										day: day										hour: hour										minute: 0										second: 0										timeZone: timeZone)								duration: (dateAndTimeFactory civilDurationFactory hours: 1)]						ifFalse:							[second == nil								ifTrue:									[self 										newTimeperiodUsing: dateAndTimeFactory timeperiodFactory										from: 											(self 												basicNewDateAndTimeUsing: dateAndTimeFactory												year: canonicalYear												day: day												hour: hour												minute: minute												second: 0												timeZone: timeZone)										duration: (dateAndTimeFactory civilDurationFactory minutes: 1)]								ifFalse:									[self 										basicNewDateAndTimeUsing: dateAndTimeFactory 										year: canonicalYear										day: day										hour: hour										minute: minute										second: second										timeZone: timeZone]]]]</body><body package="Chronos-Parsing" selector="newDateAndTimeUsing:year:month:day:hour:minute:second:timeZone:">newDateAndTimeUsing: dateAndTimeFactory year: year month: month day: day hour: hour minute: minute second: second timeZone: timeZone 	^month == nil 		ifTrue: 			[self 				newDateAndTimeUsing: dateAndTimeFactory 				year: year 				day: day 				hour: hour 				minute: minute 				second: second 				timeZone: timeZone]		ifFalse: 			[(month isSymbol or: [month &gt;= 0]) 				ifTrue: 					[day == nil						ifTrue:							[self 								newDateUsing: dateAndTimeFactory dateFactory								year: year								month: month								day: day								timeZone: timeZone]						ifFalse:							[hour == nil								ifTrue:									[self 										newDateUsing: dateAndTimeFactory dateFactory										year: year										month: month										day: day										timeZone: timeZone]								ifFalse:									[| canonicalYear canonicalMonth |									canonicalYear := self canonicalYearFromYear: year.									canonicalMonth := self canonicalMonthFromMonth: month year: canonicalYear.									minute == nil										ifTrue:											[self												newTimeperiodUsing: dateAndTimeFactory timeperiodFactory												from: 													(self														basicNewDateAndTimeUsing: dateAndTimeFactory														year:  canonicalYear														month: canonicalMonth														day: day														hour: hour														minute: 0														second: 0														timeZone: timeZone)												duration: (dateAndTimeFactory civilDurationFactory hours: 1)]										ifFalse:											[second == nil												ifTrue:													[self														newTimeperiodUsing: dateAndTimeFactory timeperiodFactory														from: 															(self																basicNewDateAndTimeUsing: dateAndTimeFactory																year:  canonicalYear																month: canonicalMonth																day: day																hour: hour																minute: minute																second: 0																timeZone: timeZone)														duration: (dateAndTimeFactory civilDurationFactory minutes: 1)]												ifFalse:													[self														basicNewDateAndTimeUsing: dateAndTimeFactory 														year: canonicalYear														month: canonicalMonth														day: day														hour: hour														minute: minute														second: second														timeZone: timeZone]]]]]				ifFalse: 					[self 						newDateAndTimeUsing: dateAndTimeFactory						isoYear: year						week: month abs						dayOfWeek: day						hour: hour						minute: minute						second: second						timeZone: timeZone]]</body><body package="Chronos-Parsing" selector="newDateUsing:isoYear:week:dayOfWeek:timeZone:">newDateUsing: dateFactory isoYear: isoYear week: isoWeekOrdinal dayOfWeek: isoDayOfWeekOrdinal timeZone: timeZone 	isoWeekOrdinal == nil 		ifTrue: 			[^self 				newDateUsing: dateFactory				year: isoYear				day: nil				timeZone: timeZone].	^isoDayOfWeekOrdinal == nil		ifTrue:			[| canonicalYear |			canonicalYear := self canonicalYearFromYear: isoYear.			self 				newTimeperiodUsing: dateFactory timeperiodFactory				from: 					(timeZone isInvariantToNominalTime 						ifTrue:							[self 								basicNewDateUsing: dateFactory 								isoYear: canonicalYear								week: isoWeekOrdinal								dayOfWeek: 1]						ifFalse:							[self 								basicNewDateAndTimeUsing: dateFactory dateAndTimeFactory								isoYear: canonicalYear								week: isoWeekOrdinal								dayOfWeek: 1								hour: 0								minute: 0								second: 0								timeZone: timeZone])				duration: (dateFactory calendarDurationFactory weeks: 1)]		ifFalse:			[timeZone isInvariantToNominalTime 				ifTrue: 					[self basicNewDateUsing: dateFactory 						isoYear: (self canonicalYearFromYear: isoYear)						week: isoWeekOrdinal						dayOfWeek: isoDayOfWeekOrdinal]				ifFalse: 					[self 						newTimeperiodUsing: dateFactory timeperiodFactory						from: 							(self basicNewDateUsing: dateFactory 								isoYear: (self canonicalYearFromYear: isoYear)								week: isoWeekOrdinal								dayOfWeek: isoDayOfWeekOrdinal)						duration: (dateFactory calendarDurationFactory days: 1)]]</body><body package="Chronos-Parsing" selector="newDateUsing:year:day:timeZone:">newDateUsing: dateFactory year: year day: day timeZone: timeZone 	| canonicalYear |	canonicalYear := self canonicalYearFromYear: year.	^day == nil		ifTrue:			[self 				newTimeperiodUsing: dateFactory timeperiodFactory				from: 					(timeZone isInvariantToNominalTime						ifTrue:							[self								basicNewDateUsing: dateFactory								year: canonicalYear								day: 1]						ifFalse:							[self								basicNewDateAndTimeUsing: dateFactory dateAndTimeFactory								year: canonicalYear								day: 1								hour: 0								minute: 0								second: 0								timeZone: timeZone])				duration: (dateFactory calendarDurationFactory years: 1)]		ifFalse:			[timeZone isInvariantToNominalTime				ifTrue: 					[self 						basicNewDateUsing: dateFactory 						year: canonicalYear						day: day]				ifFalse: 					[self 						newTimeperiodUsing: dateFactory timeperiodFactory						from: 							(self								basicNewDateAndTimeUsing: dateFactory dateAndTimeFactory								year: canonicalYear								day: day								hour: 0								minute: 0								second: 0								timeZone: timeZone)						duration: (dateFactory calendarDurationFactory days: 1)]]</body><body package="Chronos-Parsing" selector="newDateUsing:year:month:day:timeZone:">newDateUsing: dateFactory year: year month: month day: day timeZone: timeZone 	month == nil 		ifTrue: 			[^self 				newDateUsing: dateFactory				year: year				day: day				timeZone: timeZone].	^(month isSymbol or: [month &gt;= 0]) 		ifTrue: 			[| canonicalYear canonicalMonth |			canonicalYear := self canonicalYearFromYear: year.			canonicalMonth := self canonicalMonthFromMonth: month year: canonicalYear.			day == nil				ifTrue:					[self 						newTimeperiodUsing: dateFactory timeperiodFactory						from: 							(timeZone isInvariantToNominalTime								ifTrue:									[self										basicNewDateUsing: dateFactory										year: canonicalYear										month: canonicalMonth										day: 1]								ifFalse:									[self										basicNewDateAndTimeUsing: dateFactory dateAndTimeFactory										year: canonicalYear										month: canonicalMonth										day: 1										hour: 0										minute: 0										second: 0										timeZone: timeZone])						duration: (dateFactory calendarDurationFactory months: 1)]				ifFalse:					[timeZone isInvariantToNominalTime						ifTrue: 							[self 								basicNewDateUsing: dateFactory 								year: canonicalYear								month: canonicalMonth								day: day]						ifFalse: 							[self 								newTimeperiodUsing: dateFactory timeperiodFactory								from: 									(self										basicNewDateAndTimeUsing: dateFactory dateAndTimeFactory										year: canonicalYear										month: canonicalMonth										day: day										hour: 0										minute: 0										second: 0										timeZone: timeZone)								duration: (dateFactory calendarDurationFactory days: 1)]]]		ifFalse: 			[self 				newDateUsing: dateFactory				isoYear: year				week: month abs				dayOfWeek: day				timeZone: timeZone]</body><body package="Chronos-Parsing" selector="newDurationUsing:days:hours:minutes:seconds:">newDurationUsing: durationFactory days: days hours: hours minutes: minutes seconds: seconds 	^durationFactory 		days: days		hours: hours		minutes: minutes		seconds: seconds</body><body package="Chronos-Parsing" selector="newTimeOfDayUsing:hour:minute:second:">newTimeOfDayUsing: timeOfDayFactory hour: hour minute: minute second: second 	^minute == nil 		ifTrue: 			[self				newTimeperiodUsing: timeOfDayFactory timeperiodFactory 				from: 					(timeOfDayFactory 						hour: hour						minute: 0						second: 0) 				duration: (timeOfDayFactory civilDurationFactory hours: 1)]		ifFalse: 			[second == nil 				ifTrue: 					[self						newTimeperiodUsing: timeOfDayFactory timeperiodFactory 						from: 							(timeOfDayFactory 								hour: hour								minute: minute								second: 0) 						duration: (timeOfDayFactory civilDurationFactory minutes: 1)]				ifFalse: 					[timeOfDayFactory 						hour: hour						minute: minute						second: second]]</body><body package="Chronos-Parsing" selector="newTimeperiodUsing:from:duration:">newTimeperiodUsing: timePeriodFactory from: startingPoint duration: duration 	^timePeriodFactory from: startingPoint duration: duration</body><body package="Chronos-Parsing" selector="newTimeperiodUsing:from:to:">newTimeperiodUsing: timePeriodFactory from: startingPoint to: limitMoment 	^timePeriodFactory from: startingPoint to: limitMoment</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>API-parsing</category><body package="Chronos-Parsing" selector="nextCalendarDurationFrom:">nextCalendarDurationFrom: stream 	"ChronosParser default nextCalendarDurationFrom: 'P48Y8M27D' readStream"	"ChronosParser default nextCalendarDurationFrom: 'P48Y8M27DT18H16M55.062077S' readStream"	"ChronosParser default nextCalendarDurationFrom: 'PT18H16M55.062077S' readStream"	"ChronosParser default nextCalendarDurationFrom: 'P48Y8M' readStream"	"ChronosParser default nextCalendarDurationFrom: 'P48Y' readStream"	"ChronosParser default nextCalendarDurationFrom: 'P18M' readStream"	"ChronosParser default nextCalendarDurationFrom: 'P180D' readStream"	"ChronosParser default nextCalendarDurationFrom: 'P2006-12-31' readStream"	"ChronosParser default nextCalendarDurationFrom: 'P2006-12-31T12:05:19.4224562' readStream"	"ChronosParser default nextCalendarDurationFrom: 'PT12:05:19.4224562' readStream"	^self nextCalendarDurationFrom: stream usingFactory: self defaultCivilDurationFactory</body><body package="Chronos-Parsing" selector="nextCalendarDurationFrom:usingFactory:">nextCalendarDurationFrom: stream usingFactory: calendarDurationFactory 	^self subclassResponsibility</body><body package="Chronos-Parsing" selector="nextCivilDurationFrom:">nextCivilDurationFrom: stream 	"ChronosParser default nextCivilDurationFrom: 'P48Y8M27D' readStream"	"ChronosParser default nextCivilDurationFrom: 'P48Y8M27DT18H16M55.062077S' readStream"	"ChronosParser default nextCivilDurationFrom: 'PT18H16M55.062077S' readStream"	"ChronosParser default nextCivilDurationFrom: 'P18H16M55.062077S' readStream"	"ChronosParser default nextCivilDurationFrom: 'PT18H16M' readStream"	"ChronosParser default nextCivilDurationFrom: 'PT18H' readStream"	"ChronosParser default nextCivilDurationFrom: 'P18.5H' readStream"	"ChronosParser default nextCivilDurationFrom: 'PT16.5M' readStream"	"ChronosParser default nextCivilDurationFrom: 'PT55.062077S' readStream"	"ChronosParser default nextCivilDurationFrom: 'P18H' readStream"	"ChronosParser default nextCivilDurationFrom: 'P55.062077S' readStream"	"ChronosParser default nextCivilDurationFrom: 'P48Y8M' readStream"	"ChronosParser default nextCivilDurationFrom: 'P48Y' readStream"	"ChronosParser default nextCivilDurationFrom: 'P18M' readStream"	"ChronosParser default nextCivilDurationFrom: 'PT18M' readStream"	"ChronosParser default nextCivilDurationFrom: 'P180D' readStream"	"ChronosParser default nextCivilDurationFrom: 'P2006-12-31' readStream"	"ChronosParser default nextCivilDurationFrom: 'P2006-12-31T12:05:19.4224562' readStream"	"ChronosParser default nextCivilDurationFrom: 'PT12:05:19.4224562' readStream"	"ChronosParser default nextCivilDurationFrom: 'P12:05:19.4224562' readStream"	^self nextCivilDurationFrom: stream usingFactory: self defaultCivilDurationFactory</body><body package="Chronos-Parsing" selector="nextCivilDurationFrom:usingFactory:">nextCivilDurationFrom: stream usingFactory: civilDurationFactory 	^self subclassResponsibility</body><body package="Chronos-Parsing" selector="nextDateAndTimeFrom:">nextDateAndTimeFrom: stream 	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-Feb-29' readStream"	"ChronosParser ansiStandard nextDateAndTimeFrom: '2004-Feb-29' readStream"	"ChronosParser default nextDateAndTimeFrom: '2004-Feb-29' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-02-29' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '20040229' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-060' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004060' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-W09-7' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004W097' readStream"	^self 		nextDateAndTimeFrom: stream		usingFactory: self defaultDateAndTimeFactory</body><body package="Chronos-Parsing" selector="nextDateAndTimeFrom:usingFactory:">nextDateAndTimeFrom: stream usingFactory: dateAndTimeFactory 	^self subclassResponsibility</body><body package="Chronos-Parsing" selector="nextDateFrom:">nextDateFrom: stream 	"ChronosParser default nextDateFrom: '2004-Feb-29' readStream"	"ChronosParser iso8601 nextDateFrom: '20040229' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-060' readStream"	"ChronosParser iso8601 nextDateFrom: '2004060' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-W09-7' readStream"	"ChronosParser iso8601 nextDateFrom: '2004W097' readStream"	^self nextDateFrom: stream usingFactory: self defaultDateFactory</body><body package="Chronos-Parsing" selector="nextDateFrom:usingFactory:">nextDateFrom: stream usingFactory: dateFactory 	^self subclassResponsibility</body><body package="Chronos-Parsing" selector="nextDurationFrom:">nextDurationFrom: stream 	"ChronosParser default nextDurationFrom: '1:23:59:59' readStream"	"ChronosParser default nextDurationFrom: '00:00:00:00.000000001' readStream"	"ChronosParser default nextDurationFrom: '-00:00:00:00.000000001' readStream"	"ChronosParser default nextDurationFrom: '-365:23:59:59' readStream"	"ChronosParser default nextDurationFrom: '1:23:59:60' readStream" "invalid"	^self nextDurationFrom: stream usingFactory: self defaultDurationFactory</body><body package="Chronos-Parsing" selector="nextDurationFrom:usingFactory:">nextDurationFrom: stream usingFactory: durationFactory 	^self subclassResponsibility</body><body package="Chronos-Parsing" selector="nextDurationalFrom:">nextDurationalFrom: stream 	ChronosFunction skipSeparators: stream.	^stream peek = $P		ifTrue: [self nextCivilDurationFrom: stream]		ifFalse: [self nextDurationFrom: stream]</body><body package="Chronos-Parsing" selector="nextTimeOfDayFrom:">nextTimeOfDayFrom: stream 	"ChronosParser default nextTimeOfDayFrom: '23:59:60' readStream"	"ChronosParser default nextTimeOfDayFrom: 'T00:00:00.000000001' readStream"	"ChronosParser default nextTimeOfDayFrom: '23:59:61' readStream"	^self nextTimeOfDayFrom: stream usingFactory: self defaultTimeOfDayFactory</body><body package="Chronos-Parsing" selector="nextTimeOfDayFrom:usingFactory:">nextTimeOfDayFrom: stream usingFactory: timeOfDayFactory 	^self subclassResponsibility</body><body package="Chronos-Parsing" selector="nextTimeperiodFrom:">nextTimeperiodFrom: stream 	"{ChronosParser default nextTimeperiodFrom: '2007-07-01/P1Y6M15D' readStream}	{ChronosParser default nextTimeperiodFrom: '2002-03-01/2003-05-11' readStream}	{ChronosParser default nextTimeperiodFrom: '2002-03-01T13:00:00Z/2003-05-11T15:30:00Z' readStream}	{ChronosParser default nextTimeperiodFrom: '2002-03-01/P1Y2M10DT2H30M' readStream}	{ChronosParser default nextTimeperiodFrom: '2002-03-01T13:00:00Z/P1Y2M10DT2H30M' readStream}	{ChronosParser default nextTimeperiodFrom: 'P1Y2M10DT2H30M/2003-05-11' readStream}	{ChronosParser default nextTimeperiodFrom: 'P1Y2M10DT2H30M/2003-05-11T15:30:00Z' readStream}	{ChronosParser default nextTimeperiodFrom: '2002-03-01/182:12:30:30.5' readStream}"	^self nextTimeperiodFrom: stream usingFactory: self defaultTimeperiodFactory</body><body package="Chronos-Parsing" selector="nextTimeperiodFrom:usingFactory:">nextTimeperiodFrom: stream usingFactory: timeperiodFactory 	^self subclassResponsibility</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>API-utility</category><body package="Chronos-Parsing" selector="canonicalMonthFromMonth:year:">canonicalMonthFromMonth: month year: year 	^month isInteger 		ifTrue: [self canonicalMonthFromMonthNumber: month inYear: year]		ifFalse: [self canonicalMonthFromMonthNameKey: month inYear: year]</body><body package="Chronos-Parsing" selector="canonicalMonthFromMonthNameKey:inYear:">canonicalMonthFromMonthNameKey: monthNameKey inYear: year 	^calendar 		monthOrdinalForMonthWithKey: (calendar monthKeyAtMonthNameKey: monthNameKey)		inYear: year</body><body package="Chronos-Parsing" selector="canonicalMonthFromMonthNumber:inYear:">canonicalMonthFromMonthNumber: monthNumber inYear: year 	^self 		perform: monthNumberInterpretationPolicy		with: monthNumber		with: year</body><body package="Chronos-Parsing" selector="canonicalMonthFromMonthOrdinal:inYear:">canonicalMonthFromMonthOrdinal: monthOrdinal inYear: year	^monthOrdinal</body><body package="Chronos-Parsing" selector="canonicalMonthFromNumericMonthDesignator:inYear:">canonicalMonthFromNumericMonthDesignator: numericMonthDesignator inYear: year	^calendar monthOrdinalFromNumericMonthDesignator: numericMonthDesignator inYear: year</body><body package="Chronos-Parsing" selector="canonicalYearFromYear:">canonicalYearFromYear: year 	^twoDigitYearBackwardBias == nil 		ifTrue: [calendar fullYearFromTwoDigitYear: year]		ifFalse: 			[calendar 				fullYearFromTwoDigitYear: year				backwardBias: twoDigitYearBackwardBias]</body><body package="Chronos-Parsing" selector="timeZoneWithNameOrAbbreviation:ifNone:">timeZoneWithNameOrAbbreviation: timeZoneNameOrAbbreviation ifNone: ifNoneBlock 	(ChronosFunction isNilOrEmpty: timeZoneNameOrAbbreviation) 		ifTrue: [^ifNoneBlock value].	timeZoneNameOrAbbreviation = 'T' ifTrue: [^ifNoneBlock value].	^ChronosTimezone at: timeZoneNameOrAbbreviation		ifAbsent: 			[timeZoneNameOrAbbreviation size &lt; 3 				ifTrue: [ifNoneBlock value]				ifFalse: 					[ChronosTimezone 						atAbbreviation: timeZoneNameOrAbbreviation						inLocale: self locale						dstPreferred: true						ifAbsent: [ifNoneBlock value]]]</body></methods><methods><class-id>Chronos.ChronosParser</class-id> <category>parsing-utility</category><body package="Chronos-Parsing" selector="parseOptionalTokenFrom:prefixPredicate:tokenPredicate:minChars:maxChars:acceptancePredicate:">parseOptionalTokenFrom: stream prefixPredicate: prefixPredicate tokenPredicate: tokenPredicate minChars: minChars maxChars: maxChars acceptancePredicate: acceptancePredicate 	"{| stream token |	stream := '   Wednesday, ' readStream .	token := ChronosParser default 				parseOptionalTokenFrom: stream				prefixPredicate: [:ch | ch isSeparator] 				tokenPredicate: [:ch :count | ch isAlphabetic] 				minChars: 1 				maxChars: 80 				acceptancePredicate: [:dayOfWeekName | ANSIDayOfWeekKeys includes: dayOfWeekName asSymbol].	Array with: token with: stream upToEnd}"	"{| stream token |	stream := '   March 17' readStream .	token := ChronosParser default 				parseOptionalTokenFrom: stream				prefixPredicate: [:ch | ch isSeparator] 				tokenPredicate: [:ch :count | ch isAlphabetic] 				minChars: 1 				maxChars: 80 				acceptancePredicate: [:dayOfWeekName | ANSIDayOfWeekKeys includes: dayOfWeekName asSymbol].	Array with: token with: stream upToEnd}"	| startPosition token count |	startPosition := stream position.	ChronosFunction skipOver: stream while: prefixPredicate.	stream atEnd 		ifTrue: 			[stream skip: startPosition - stream position.			^false-&gt;nil].	count := 0.	token := ChronosFunction 				nextFrom: stream				while: 					[:ch | 					count := count + 1.					tokenPredicate value: ch value: count]				minChars: minChars				maxChars: maxChars				onUnexpectedEOD: 					[:prefix :ch :position | 					stream skip: startPosition - stream position.					^false -&gt; prefix].	^(acceptancePredicate value: token) 		ifTrue: [true -&gt; token]		ifFalse: 			[stream skip: startPosition - stream position.			false -&gt; token]</body></methods><methods><class-id>Chronos.ChronosParser class</class-id> <category>instance creation</category><body package="Chronos-Parsing" selector="calendar:">calendar: aChronosCalendar	^(self new)		setCalendar: aChronosCalendar</body><body package="Chronos-Parsing" selector="defaultTimeZone:">defaultTimeZone: aChronosTimezone	^(self new)		setDefaultTimeZone: aChronosTimezone</body><body package="Chronos-Parsing" selector="defaultTimeZone:twoDigitYearBackwardBias:">defaultTimeZone: aChronosTimezone twoDigitYearBackwardBias: yearBias	^(self new)		setDefaultTimeZone: aChronosTimezone;		setTwoDigitYearBackwardBias: yearBias.</body><body package="Chronos-Parsing" selector="locale:">locale: aChronosLocale	"(ChronosParser locale: #fr_FR) canonicalize"	^(self new)		setLocale: aChronosLocale</body><body package="Chronos-Parsing" selector="locale:calendar:">locale: aChronosLocale calendar: aChronosCalendar	^(self new)		setLocale: aChronosLocale;		setCalendar: aChronosCalendar</body><body package="Chronos-Parsing" selector="locale:defaultTimeZone:">locale: aChronosLocale defaultTimeZone: aChronosTimezone	^(self new)		setLocale: aChronosLocale;		setDefaultTimeZone: aChronosTimezone</body><body package="Chronos-Parsing" selector="locale:defaultTimeZone:calendar:">locale: aChronosLocale defaultTimeZone: aChronosTimezone calendar: aChronosCalendar	^(self new)		setLocale: aChronosLocale;		setDefaultTimeZone: aChronosTimezone;		setCalendar: aChronosCalendar</body><body package="Chronos-Parsing" selector="locale:defaultTimeZone:calendar:twoDigitYearBackwardBias:">locale: aChronosLocale defaultTimeZone: aChronosTimezone calendar: aChronosCalendar twoDigitYearBackwardBias: yearBias	^(self new)		setLocale: aChronosLocale;		setDefaultTimeZone: aChronosTimezone;		setCalendar: aChronosCalendar;		setTwoDigitYearBackwardBias: yearBias.</body><body package="Chronos-Parsing" selector="newConfigurable">newConfigurable	^ConfigurableChronosParser new</body><body package="Chronos-Parsing" selector="twoDigitYearBackwardBias:">twoDigitYearBackwardBias: yearBias	^(self new)		setTwoDigitYearBackwardBias: yearBias.</body></methods><methods><class-id>Chronos.ChronosParser class</class-id> <category>specifications</category><body package="Chronos-Parsing" selector="specificationAt:ifAbsent:">specificationAt: key ifAbsent: ifAbsent	^self specRegistry at: key ifAbsent: ifAbsent</body><body package="Chronos-Parsing" selector="specificationAt:put:">specificationAt: key put: aPrintPolicySpec	self specRegistry at: key put: aPrintPolicySpec</body></methods><methods><class-id>Chronos.ChronosParser class</class-id> <category>accessing</category><body package="Chronos-Parsing" selector="ansiStandard">ansiStandard	"ChronosParser ansiStandard nextDateAndTimeFrom: '1776-07-04' readStream"	ANSIStandard == nil 		ifTrue: 			[ANSIStandard := 				(self newConfigurable)					setKey: #ansiStandard;					setCalendar: Gregorian;					setLocale: ChronosLocale english;					forceRegistration].	^ANSIStandard</body><body package="Chronos-Parsing" selector="at:ifAbsent:">at: key ifAbsent: notFound 	| policy |	key == #default  ifTrue: [^self default].	key == #iso8601 ifTrue: [^self iso8601].	key == #ansiStandard ifTrue: [^self ansiStandard].	policy := self registry at: key ifAbsent: [0].	^(policy == nil or: [policy = 0])		ifTrue: 			[(self applying: (self specificationAt: key ifAbsent: [^notFound value]))				setKey: key; forceRegistration]		ifFalse: [policy]</body><body package="Chronos-Parsing" selector="default">default	"ChronosParser default nextDateAndTimeFrom: '1776-07-04' readStream"	Default == nil ifTrue: [self newConfigurable beDefault].	^Default</body><body package="Chronos-Parsing" selector="dmy">dmy	"ChronosParser dmy nextDateFrom: '4 July 1776' readStream"	^self at: #dmy</body><body package="Chronos-Parsing" selector="iso8601">iso8601	"ChronosParser iso8601 nextDateAndTimeFrom: '1776-07-04' readStream"	ISO8601 == nil 		ifTrue: 			[ISO8601 := 				(self newConfigurable)					setKey: #iso8601;					setCalendar: Gregorian;					setLocale: ChronosLocale english;					forceRegistration].	^ISO8601</body><body package="Chronos-Parsing" selector="mdy">mdy	"ChronosParser mdy nextDateFrom: 'July 4, 1776' readStream"	"ChronosParser mdy nextDateAndTimeFrom: 'July 4, 1776 at 3:30 pm' readStream"	"ChronosParser mdy nextDateAndTimeFrom: '7/4/1776 @ 15:30 -0452 pm' readStream"	"ChronosParser mdy nextDateAndTimeFrom: '07041776 1530-0452 pm' readStream"	"ChronosParser mdy nextDateAndTimeFrom: '07041776 America/New_York' readStream"	"ChronosParser mdy nextDateAndTimeFrom: '07041776 EST' readStream"	"ChronosParser mdy nextDateAndTimeFrom: '07041776 -05:00' readStream"	^self at: #mdy</body><body package="Chronos-Parsing" selector="referencedBy:">referencedBy: aChronosParsOrChronosParsKeyOrChronosParserSpec 	"Answer the value referenced by &lt;aChronosParsOrChronosParsKeyOrChronosParserSpec&gt;. If the value is a key, answer the value bound to the key. If the value is a sequenceable collection, answer the result of creating an instance of ChronosParse and then sending it the messages that are the elements of the sequenceable collection.  Otherwise, answer aChronosParsOrChronosParsKeyOrChronosParserSpec itself."	^aChronosParsOrChronosParsKeyOrChronosParserSpec 		isString 			ifTrue: [super referencedBy: aChronosParsOrChronosParsKeyOrChronosParserSpec]			ifFalse: 				[aChronosParsOrChronosParsKeyOrChronosParserSpec 					isSequenceable 						ifTrue: 							[(self applying: aChronosParsOrChronosParsKeyOrChronosParserSpec) beImmutable]						ifFalse: 							[super referencedBy: aChronosParsOrChronosParsKeyOrChronosParserSpec]]</body><body package="Chronos-Parsing" selector="rfc2822">rfc2822	"ChronosParser rfc2822 nextDateAndTimeFrom: 'Thursday, 04 Jul 1776 12:00:00 -0500' readStream"	"ChronosParser rfc2822 nextDateAndTimeFrom: '4 JUL 76 12:00:00 EDT' readStream"	^self at: #rfc2822</body><body package="Chronos-Parsing" selector="ymd">ymd	"ChronosParser ymd nextDateFrom: '1776-07-04' readStream"	^self at: #ymd</body></methods><methods><class-id>Chronos.ChronosParser class</class-id> <category>private</category><body package="Chronos-Parsing" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	| key |	key := literalArray at: 2.	^ChronosParser		at: key		ifAbsent: 			[(self new)				initializeFromLiteralArray: literalArray;				beImmutable]</body><body package="Chronos-Parsing" selector="setSpecRegistry">setSpecRegistry	SpecRegistry := IdentityDictionary new.</body><body package="Chronos-Parsing" selector="specRegistry">specRegistry	SpecRegistry == nil ifTrue: [self setSpecRegistry].	^SpecRegistry</body></methods><methods><class-id>Chronos.ChronosParser class</class-id> <category>class initialization</category><body package="Chronos-Parsing" selector="initialize">initialize	"ChronosParser initialize" 	self basicInitializeAll.	Default := nil.	ANSIStandard := nil.	ISO8601 := nil.	self initializeSpecifications</body><body package="Chronos-Parsing" selector="initializeSpecifications">initializeSpecifications	"ChronosParser initializeSpecifications"	self setSpecRegistry.	self 		specificationAt: #ymd		put: #(#expectYMD).	self 		specificationAt: #dmy		put: #(#expectDMY).	self 		specificationAt: #mdy		put: #(#expectMDY).	self 		specificationAt: #rfc2822		put: #(#expectDayOfWeekName #expectDMY setCalendar: #Gregorian setLocale: #en).</body></methods><methods><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id> <category>initialize-release</category><body package="Chronos-Semantic Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self setKey: (literalArray at: 4).	super initializeFromLiteralArray: literalArray.</body><body package="Chronos-Semantic Dates" selector="setKey:">setKey: aSymbol	self assertMutability.	key := aSymbol</body><body package="Chronos-Semantic Dates" selector="setRightLink:">setRightLink: aSemnaticAnnualDateRule	"Set &lt;aSemnaticAnnualDateRule&gt; as the next rule `to the right` in the receiver's chain of  SemnaticAnnualDateRules."	aSemnaticAnnualDateRule == nil 		ifFalse: 			[key == aSemnaticAnnualDateRule key 				ifFalse: [self signalError: 'All the rules in a SemanticAnnualDateRule rule chain must have the same key']].	super setRightLink: aSemnaticAnnualDateRule</body></methods><methods><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id> <category>queries</category><body package="Chronos-Semantic Dates" selector="nominalDateInYear:">nominalDateInYear: aYear	^self subclassResponsibility</body><body package="Chronos-Semantic Dates" selector="nominallyOccursOn:">nominallyOccursOn: aDate 	^self subclassResponsibility</body><body package="Chronos-Semantic Dates" selector="observanceDateAndTypeInYear:into:ifNone:">observanceDateAndTypeInYear: aYear into: block2 ifNone: ifNoneBlock	^self subclassResponsibility</body><body package="Chronos-Semantic Dates" selector="observanceTypeFor:">observanceTypeFor: aDate 	^self subclassResponsibility</body><body package="Chronos-Semantic Dates" selector="occursInYear:">occursInYear: aYear	^self subclassResponsibility</body><body package="Chronos-Semantic Dates" selector="occursOn:">occursOn: aDate 	^self subclassResponsibility</body></methods><methods><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id> <category>accessing</category><body package="Chronos-Semantic Dates" selector="calendar">calendar	^self subclassResponsibility</body><body package="Chronos-Semantic Dates" selector="key">key	^key</body></methods><methods><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id> <category>testing</category><body package="Chronos-Semantic Dates" selector="isDerived">isDerived	^false</body></methods><methods><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id> <category>comparing</category><body package="Chronos-Semantic Dates" selector="=">= otherTemporalRule 	"Answer whether the receiver is equal to the argument."	self == otherTemporalRule ifTrue: [^true].	^self comparisonClassIdentifier 		= otherTemporalRule comparisonClassIdentifier and: 				[(self compareTo: otherTemporalRule) = 0 and: [key == otherTemporalRule key]]</body><body package="Chronos-Semantic Dates" selector="hash">hash	^key hash</body></methods><methods><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id> <category>printing</category><body package="Chronos-Semantic Dates" selector="printOn:">printOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."	super printOn: aStream.	aStream		nextPut: $(;		print: key;		nextPut: $)</body></methods><methods><class-id>Chronos.AbstractSemanticAnnualDateRule</class-id> <category>private</category><body package="Chronos-Semantic Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut: key</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>initialize-release</category><body package="Chronos-DateTimeInterval" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	start == nil ifTrue: [start := self defaultStart].		duration == nil ifTrue: [duration := self defaultDuration].</body><body package="Chronos-DateTimeInterval" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setStart: (literalArray at: 2) decodeAsLiteralArray		duration: (literalArray at: 3) decodeAsLiteralArray</body><body package="Chronos-DateTimeInterval" selector="invalidateCalendar">invalidateCalendar	start invalidateCalendar</body><body package="Chronos-DateTimeInterval" selector="setDuration:">setDuration: temporalExtent 	"Initialize the receiver so that it represents a right-closed, left-open temporal interval whose starting point-in-time is its current starting point-in-time and whose open temporal extent is &lt;temporalExtent&gt; (a Durational instance.) Fail if the receiver is not mutable."	self assertMutability.	duration := temporalExtent</body><body package="Chronos-DateTimeInterval" selector="setLimit:">setLimit: limitMoment	"Initialize the receiver so that it represents a right-closed, left-open temporal interval whose starting point-in-time is its current starting point-in-time and whose right end-point (its limit value) is &lt;limitMoment&gt;. Set the temporal extent of the receiver (its 'duration') to be a temporal extent  computed by subtracting the receiver's initial moment (it's starting point-in-time) from the specified &lt;limitMoment&gt;. Fail if the receiver is not mutable." 	self assertMutability.	duration := limitMoment durationSince: self start</body><body package="Chronos-DateTimeInterval" selector="setStart:">setStart: aStart	"Initialize the receiver so that it represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is its current temporal extent (its 'duration.') Fail if the receiver is not mutable."	self assertMutability.	start := aStart.</body><body package="Chronos-DateTimeInterval" selector="setStart:duration:">setStart: initialMoment duration: temporalExtent 	"Initialize the receiver so that it represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is &lt;temporalExtent&gt; (a Durational instance.) Fail if the receiver is not mutable."	self assertMutability.	start := initialMoment.	duration := temporalExtent</body><body package="Chronos-DateTimeInterval" selector="setStart:limit:">setStart: initialMoment limit: limitMoment	"Initialize the receiver so that it represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose right end-point (its limit value) is &lt;limitMoment&gt;. Set the temporal extent of the receiver (its `duration`) to be a temporal extent computed by subtracting the &lt;initialMoment&gt; from the &lt;limitMoment&gt;. Fail if the receiver is not mutable."	self assertMutability.	start := initialMoment.	duration :=  limitMoment durationSince: initialMoment</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>accessing</category><body package="Chronos-DateTimeInterval" selector="calendar">calendar	"Answer the Calendar that implements the calendrical system associated with the receiver."	^start calendar</body><body package="Chronos-DateTimeInterval" selector="calendarDay">calendarDay	^start calendarDay</body><body package="Chronos-DateTimeInterval" selector="daysSinceEpoch">daysSinceEpoch	^start daysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="duration">duration	"Answer a Duration whose value represents the receiver's temporal extent."	^duration</body><body package="Chronos-DateTimeInterval" selector="julianDay">julianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs (local time.) However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered (also local time.)"	^start julianDay</body><body package="Chronos-DateTimeInterval" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	^start nanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^NanosecondDuration</body><body package="Chronos-DateTimeInterval" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	^start secondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="start">start	"Answer the point-in-time value that is the initial moment of the receiver's temporal interval (which is included in the interval.)"	^start</body><body package="Chronos-DateTimeInterval" selector="timeZone">timeZone	"Answer the bound Timezone that has the correct offsetFromUT for the date and time represented by the receiver." 		^start timeZone</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>arithmetic</category><body package="Chronos-DateTimeInterval" selector="addingDays:">addingDays: days	days = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self copy)		setStart: (self start addingDays: days);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:">addingHours: hours	hours = 0 ifTrue: [^self isMutable ifTrue: [self asMutableTimeOfDay] ifFalse: [self]].	^(self copy)		setStart: (self start addingHours: hours);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:">addingHours: hours minutes: minutes	minutes = 0 ifTrue: [^self addingHours: hours].	^(self copy)		setStart: (self start addingHours: hours minutes: minutes);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:seconds:">addingHours: hours minutes: minutes seconds: seconds	seconds = 0 ifTrue: [^self addingHours: hours minutes: minutes].	^(self copy)		setStart: (self start addingHours: hours minutes: minutes seconds: seconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingHours:minutes:seconds:nanoseconds:">addingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	nanoseconds = 0 ifTrue: [^self addingHours: hours minutes: minutes seconds: seconds].	^(self copy)		setStart: (self start addingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingMinutes:">addingMinutes: minutes	minutes = 0 ifTrue: [^self isMutable ifTrue: [self asMutableTimeOfDay] ifFalse: [self]].	^(self copy)		setStart: (self start addingMinutes: minutes);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingMonths:">addingMonths: months	months = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self copy)		setStart: (self start addingMonths: months);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingSeconds:">addingSeconds: seconds	seconds = 0 ifTrue: [^self isMutable ifTrue: [self asMutableTimeOfDay] ifFalse: [self]].	^(self copy)		setStart: (self start addingSeconds: seconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingSeconds:nanoseconds:">addingSeconds: seconds nanoseconds: nanoseconds 	nanoseconds = 0 ifTrue: [^self addingSeconds: seconds].	^(self copy)		setStart: (self start addingSeconds: seconds nanoseconds: nanoseconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:">addingYears: years	years = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self copy)		setStart: (self start addingYears: years);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:">addingYears: years months: months	months = 0 ifTrue: [^self addingYears: years].	^(self copy)		setStart: (self start addingYears: years months: months);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:">addingYears: years months: months days: days	days = 0 ifTrue: [^self addingYears: years months: months].	^(self copy)		setStart: (self start addingYears: years months: months days: days);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:hours:minutes:seconds:nanoseconds:">addingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	^(self copy)		setStart: (self start addingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="addingYears:months:days:seconds:nanoseconds:">addingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds 	^(self copy)		setStart: (self start addingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="daysSince:">daysSince: aCalendricalCoordinate	^start daysSince: aCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="daysUntil:">daysUntil: aCalendricalCoordinate	^start daysUntil: aCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="durationSince:">durationSince: aCalendricalCoordinate	^start durationSince: aCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="durationUntil:">durationUntil: aCalendricalCoordinate	^start durationUntil: aCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="subtractingDays:">subtractingDays: days	days = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self copy)		setStart: (self start subtractingDays: days);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:">subtractingHours: hours	hours = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTime] ifFalse: [self]].	^(self copy)		setStart: (self start subtractingHours: hours);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:">subtractingHours: hours minutes: minutes	minutes = 0 ifTrue: [^self subtractingHours: hours].	^(self copy)		setStart: (self start subtractingHours: hours minutes: minutes);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:seconds:">subtractingHours: hours minutes: minutes seconds: seconds	seconds = 0 ifTrue: [^self subtractingHours: hours minutes: minutes].	^(self copy)		setStart: (self start subtractingHours: hours minutes: minutes seconds: seconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingHours:minutes:seconds:nanoseconds:">subtractingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	nanoseconds = 0 ifTrue: [^self subtractingHours: hours minutes: minutes seconds: seconds].	^(self copy)		setStart: (self start subtractingHours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingMinutes:">subtractingMinutes: minutes	minutes = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTime] ifFalse: [self]].	^(self copy)		setStart: (self start subtractingMinutes: minutes);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingMonths:">subtractingMonths: months	months = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self copy)		setStart: (self start subtractingMonths: months);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingSeconds:">subtractingSeconds: seconds	seconds = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDateAndTime] ifFalse: [self]].	^(self copy)		setStart: (self start subtractingSeconds: seconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingSeconds:nanoseconds:">subtractingSeconds: seconds nanoseconds: nanoseconds	nanoseconds = 0 ifTrue: [^self subtractingSeconds: seconds].	^(self copy)		setStart: (self start subtractingSeconds: seconds nanoseconds: nanoseconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:">subtractingYears: years	years = 0 ifTrue: [^self isMutable ifTrue: [self asMutableDate] ifFalse: [self]].	^(self copy)		setStart: (self start subtractingYears: years);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:">subtractingYears: years months: months	months = 0 ifTrue: [^self subtractingYears: years].	^(self copy)		setStart: (self start subtractingYears: years months: months);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:">subtractingYears: years months: months days: days	days = 0 ifTrue: [^self subtractingYears: years months: months].	^(self copy)		setStart: (self start subtractingYears: years months: months days: days);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:hours:minutes:seconds:nanoseconds:">subtractingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds 	days = 0 ifTrue: [^self subtractingYears: years months: months].	^(self copy)		setStart: (self start subtractingYears: years months: months days: days hours: hours minutes: minutes seconds: seconds nanoseconds: nanoseconds);		beImmutable</body><body package="Chronos-DateTimeInterval" selector="subtractingYears:months:days:seconds:nanoseconds:">subtractingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds	^(self copy)		setStart: (self start subtractingYears: years months: months days: days seconds: seconds nanoseconds: nanoseconds);		beImmutable</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>private-arithmetic</category><body package="Chronos-DateTimeInterval" selector="daysSinceDate:">daysSinceDate: aDate	^start daysSinceDate: aDate</body><body package="Chronos-DateTimeInterval" selector="daysSinceDateAndTime:">daysSinceDateAndTime: aDateAndTime	^start daysSinceDateAndTime: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="daysUntilDate:">daysUntilDate: aDate	^start daysUntilDate: aDate</body><body package="Chronos-DateTimeInterval" selector="daysUntilDateAndTime:">daysUntilDateAndTime: aDateAndTime	^start daysUntilDateAndTime: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="durationSinceDateAndTime:">durationSinceDateAndTime: aDateAndTime	^start durationSinceDateAndTime: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="durationUntilDateAndTime:">durationUntilDateAndTime: aDateAndTime	^start durationUntilDateAndTime: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aDuration	^start subtractedFromCivilDuration: aDuration</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>converting</category><body package="Chronos-DateTimeInterval" selector="&lt;&lt;">&lt;&lt; timeZone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but convert the date and time-of-day as though the receiver represented a date and time in the current default time zone (i.e,. preserve date and time-of-day in Universal Time as though the receiver represented a date and time in the current default time zone.)	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is the same as that of the receiver (i.e,, preserve local date and local time-of-day, don't preserve date or time-of-day in Universal Time.)"	| newStart |	newStart := start &lt;&lt; timeZone.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="&gt;&gt;">&gt;&gt; aChronosTimezone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	| newStart |	newStart := start &gt;&gt; aChronosTimezone.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asCalendarDurationSinceEpoch">asCalendarDurationSinceEpoch	^start asCalendarDurationSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="asCivilDurationSinceEpoch">asCivilDurationSinceEpoch	^start asCivilDurationSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="asDate">asDate	"Answer the conversion of the receiver into a date-valued CalendricalCoordinate that represents the same date as does the receiver.  If the receiver is already a date-valued CalendricalCoordinate, answer the receiver.  A date-valued CalendricalCoordinate is one that specifies a date without specifying a particular time-of-day nor a particular timezone (i.e., it has nominal time semantics, and its quantum of resolution is 1 calendar day.)"	^start asDate</body><body package="Chronos-DateTimeInterval" selector="asDateAndTime">asDateAndTime	"Answer the conversion of the receiver into a DateAndTime value that represents the same point-in-time as does the receiver.  If the receiver is already a DateAndTime value, answer the receiver.  A DateAndTime value is a CalendricalCoordinate that specifies a point-in-time, with a quantum of resolution no larger than one second, with behavior/semantics that is invariant to UT, and that conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol. See the class comment of Timepoint for further clarification."	^start asDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asDateAndTimeIn:">asDateAndTimeIn: aChronosTimezone	"Timepoint now asDateAndTimeIn: 'Pacific/Kiritimati'"	"TimeOfDay now asDateAndTimeIn: 'Pacific/Kiritimati'"	"YearMonthDay today asDateAndTimeIn: 'Pacific/Kiritimati'"	"GregorianEaster canonical asDateAndTimeIn: 'Pacific/Kiritimati'"	"(Timeperiod hourStartingAt: Timepoint now) asDateAndTimeIn: 'Pacific/Kiritimati'"	^start asDateAndTimeIn: aChronosTimezone</body><body package="Chronos-DateTimeInterval" selector="asDays">asDays	"Answer the number of days spanned by the receiver."	"{(Timeperiod 		startingAt: (YearMonthDay year: 2004 month: 10 day: 30)		duration: (CalendarDuration days: 4)) asDays}"	^start daysUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asHours">asHours	"Answer the number of hours spanned by the receiver."	"The following examples illustrate both the results of sending the #hours message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 timeZone: 'America/Vancouver')		duration: (ScientificDuration hours: 4)) asHours}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 timeZone: 'America/Vancouver')		duration: (ScientificDuration hours: 2)) asHours}"	^start hoursUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asInvariantToNominalTime">asInvariantToNominalTime	"Answer a value equivalent to that of the receiver in all respects, except that its semantics/behavior is invariant to nominal time.  If the receiver is already nominal-time invariant, answer the receiver. See the class comment of Timepoint for further clarification."	| newStart |	newStart := start asInvariantToNominalTime.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asInvariantToUT">asInvariantToUT	"Answer a value equivalent to that of the receiver in all respects, except that it has UT-invariant behavior/semantics.  If the receiver is already invariant-to-UT, answer the receiver. See the class comment of Timepoint for further clarification."	| newStart |	newStart := start asInvariantToUT.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asLocal">asLocal	| newStart |	newStart := start asLocal.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asMicroseconds">asMicroseconds	"Answer the number of microseconds spanned by the receiver."	"The following examples illustrate both the results of sending the #seconds message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 hour: 1 minute: 59 second: 55 timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asMicroseconds}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 59 second: 55  timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asMicroseconds}"	^start microsecondsUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asMilliseconds">asMilliseconds	"Answer the number of milliseconds spanned by the receiver."	"The following examples illustrate both the results of sending the #seconds message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 hour: 1 minute: 59 second: 55 timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asMilliseconds}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 59 second: 55  timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asMilliseconds}"	^start millisecondsUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asMinutes">asMinutes	"Answer the number of minutes spanned by the receiver."	"The following examples illustrate both the results of sending the #minutes message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 hour: 1 minute: 50 second: 0 timeZone: 'America/Vancouver')		duration: (ScientificDuration minutes: 20)) asMinutes}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 55 second: 0  timeZone: 'America/Vancouver')		duration: (ScientificDuration minutes: 10)) asMinutes}"	^start minutesUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asMonths">asMonths	"Answer the number of months spanned by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration years: 1)) asMonths}"	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration years: 1 months: -2 days: 15)) asMonths}"	"{(Timeperiod 		startingAt: HebrewCalendar clock dateToday		duration: (CalendarDuration years: 2 months: -2 days: 15)) asMonths}"	^start monthsUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asNanoseconds">asNanoseconds	"Answer the number of nanoseconds spanned by the receiver."	"The following examples illustrate both the results of sending the #seconds message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 hour: 1 minute: 59 second: 55 timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asNanoseconds}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 59 second: 55  timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asNanoseconds}"	^start nanosecondsUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asNominalDateAndTime">asNominalDateAndTime	"Answer the conversion of the receiver into a nominal-time-invariant DateAndTime value that represents the same local point-in-time as does the receiver.  If the receiver is already a nominal-time-invariant DateAndTime value, answer the receiver.  A nominal-time-invariant DateAndTime value is a CalendricalCoordinate that nominally specifies a point-in-time without reference to any particular timezone, and has a quantum of resolution no larger than one second. A nominal-time-invariant DateAndTime value conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol EXCEPT that its behavior/semantics is invariant to nominal time, as opposed to being UT invariant. See the class comment of Timepoint for further clarification."	^start asNominalDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asQuarters">asQuarters	"Answer the number of quarters spanned by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration years: 1)) asQuarters}"	^start quartersUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asSeconds">asSeconds	"Answer the number of seconds spanned by the receiver."	"The following examples illustrate both the results of sending the #seconds message, and also the effects of the transition to and from Daylight Saving Time/Summer Time:"	"{(Timeperiod 		startingAt: (Timepoint year: 2004 month: 10 day: 31 hour: 1 minute: 59 second: 55 timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asSeconds}"	"{(Timeperiod 		startingAt: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 59 second: 55  timeZone: 'America/Vancouver')		duration: (ScientificDuration seconds: 10)) asSeconds}"	^start secondsUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asTimeperiodStartingAt:">asTimeperiodStartingAt: initialMoment	"Answer a Timeperiod whose starting value is &lt;initialMoment&gt; (a CalendricalCoordinate) and whose duration is the receiver's temporal extent."	^(self copy)		setStart: initialMoment;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="asUT">asUT		^self in: ChronosTimezone universal</body><body package="Chronos-DateTimeInterval" selector="asUTC">asUTC	"Specified and required by the ANSI-Smalltalk Standard."	^self asUT</body><body package="Chronos-DateTimeInterval" selector="asWeeks">asWeeks	"Answer the number of weeks spanned by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration months: 1)) asWeeks}"	^start weeksUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="asYears">asYears	"Answer the number of years spanned by the receiver."	"{(Timeperiod 		startingAt: YearMonthDay today		duration: (CalendarDuration years: 4)) asYears}"	^start yearsUntil: self limit</body><body package="Chronos-DateTimeInterval" selector="dateSpec">dateSpec	^start dateSpec</body><body package="Chronos-DateTimeInterval" selector="inCanonicalCalendar">inCanonicalCalendar	| canonical |	canonical := start inCanonicalCalendar.	start == canonical ifTrue: [^self].	^(self copy)		setStart: canonical;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="through:">through: finalMoment 	"Answer a Timeperiod whose starting point-in-time is the receiver and whose temporal extent is the duration computed by subtracting the receiver from &lt;finalMoment&gt; (a TemporalCoordinate) and then adding the resolution quantum of &lt;finalMoment&gt;. The result is a Timeperiod representing the closed interval [self, finalMoment]."	^(self copy)		setLimit: finalMoment + finalMoment resolutionQuantum;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="to:">to: limitValue	"Answer a Timeperiod whose starting point-in-time is the same as the receiver's and whose temporal extent is the duration computed by subtracting the receiver's starting point-in-time from &lt;limitValue&gt; (a CalendricalCoordinate.)"	^(self copy)		setLimit: limitValue;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="withDuration:">withDuration: aDuration	"Answer a Timeperiod whose starting point-in-time is the same as the receiver's and whose temporal extent is &lt;aDuration&gt; (a Durational instance.)"	^(self copy)		setDuration: aDuration;		beImmutable</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>testing</category><body package="Chronos-DateTimeInterval" selector="isAtStartOfDay">isAtStartOfDay	^start isAtStartOfDay</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfHour">isAtStartOfHour	^start isAtStartOfHour</body><body package="Chronos-DateTimeInterval" selector="isAtStartOfMinute">isAtStartOfMinute	^start isAtStartOfMinute</body><body package="Chronos-DateTimeInterval" selector="isBoundToTimeZone">isBoundToTimeZone	^start isBoundToTimeZone</body><body package="Chronos-DateTimeInterval" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^self duration isDayDuration</body><body package="Chronos-DateTimeInterval" selector="isHourDuration">isHourDuration	"Answer whether the receiver's temporal extent is one hour."	^self duration isHourDuration</body><body package="Chronos-DateTimeInterval" selector="isInvariantToNominalTime">isInvariantToNominalTime	"Answer true if the receiver always represents an invariant nominal local time ('3 pm local time') in whatever Timezone to which it may be bound. Otherwise, answer false."	^start isInvariantToNominalTime</body><body package="Chronos-DateTimeInterval" selector="isInvariantToUT">isInvariantToUT	"Answer true if the receiver always represents an invariant nominal UT time ('3 pm UT') in whatever Timezone to which it may be bound. Otherwise, answer false."	^start isInvariantToUT</body><body package="Chronos-DateTimeInterval" selector="isMinuteDuration">isMinuteDuration	"Answer whether the receiver's temporal extent is one minute."	^self duration isMinuteDuration</body><body package="Chronos-DateTimeInterval" selector="isMonthDuration">isMonthDuration	"Answer whether the receiver's temporal extent is one month."	^self duration isMonthDuration</body><body package="Chronos-DateTimeInterval" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^self duration isNanosecondDuration</body><body package="Chronos-DateTimeInterval" selector="isSecondDuration">isSecondDuration	"Answer whether the receiver's temporal extent is one second."	^self duration isSecondDuration</body><body package="Chronos-DateTimeInterval" selector="isYearDuration">isYearDuration	"Answer whether the receiver's temporal extent is one year."	^self duration isYearDuration</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>private</category><body package="Chronos-DateTimeInterval" selector="asMutableDate">asMutableDate	^start asMutableDate</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTime">asMutableDateAndTime	^start asMutableDateAndTime</body><body package="Chronos-DateTimeInterval" selector="asMutableDateAndTimeInvariantToUT">asMutableDateAndTimeInvariantToUT	^start asMutableDateAndTimeInvariantToUT</body><body package="Chronos-DateTimeInterval" selector="asMutableTimeOfDay">asMutableTimeOfDay	^start asMutableTimeOfDay</body><body package="Chronos-DateTimeInterval" selector="basicDaysSinceEpoch">basicDaysSinceEpoch	^start basicDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="defaultDuration">defaultDuration	^ZeroDuration</body><body package="Chronos-DateTimeInterval" selector="defaultStart">defaultStart	^self class dateAndTimeFactory nominalNow</body><body package="Chronos-DateTimeInterval" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self start literalArrayEncoding;		nextPut: self duration literalArrayEncoding</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>queries</category><body package="Chronos-DateTimeInterval" selector="@">@ timeOfDay	"{Timeperiod currentMonth @ (TimeOfDay hour: 12 minute: 0 second: 0)}"	| newStart |	newStart := start  @ timeOfDay.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="atStartOfDay">atStartOfDay	| atStartOfDay |	atStartOfDay := start atStartOfDay.	start == atStartOfDay ifTrue: [^self].	^(self copy)		setStart: atStartOfDay;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="atTimeOfDay:">atTimeOfDay: aTimeOfDay	"Timeperiod today atTimeOfDay: TimeOfDay now"	| newStart |	newStart := start atTimeOfDay: aTimeOfDay.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="atTimeOfDay:in:">atTimeOfDay: aTimeOfDay in: timeZone	"Timeperiod today atTimeOfDay: TimeOfDay now in: 'Pacific/Honolulu'"	| newStart |	newStart := start atTimeOfDay: aTimeOfDay in: timeZone.	start == newStart ifTrue: [^self].	^(self copy)		setStart: newStart;		beImmutable</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>private-comparing</category><body package="Chronos-DateTimeInterval" selector="compareToCalendricalCoordinate:">compareToCalendricalCoordinate: aCalendricalCoordinate	^self compareToTemporalCoordinate: aCalendricalCoordinate</body><body package="Chronos-DateTimeInterval" selector="compareToDate:">compareToDate: aDate	^self compareToTemporalCoordinate: aDate</body><body package="Chronos-DateTimeInterval" selector="compareToDateAndTime:">compareToDateAndTime: aDateAndTime	^self compareToTemporalCoordinate: aDateAndTime</body><body package="Chronos-DateTimeInterval" selector="compareToTemporalCoordinate:">compareToTemporalCoordinate: aTemporalCoordinate	|  nextStart |	nextStart := self limit.	^nextStart &gt;= start 		ifTrue: 			[aTemporalCoordinate &lt; start 				ifTrue: [-1]				ifFalse: [aTemporalCoordinate &gt;= nextStart ifTrue: [1] ifFalse: [0]]]		ifFalse: 			[aTemporalCoordinate &gt; start 				ifTrue: [1]				ifFalse: [aTemporalCoordinate &lt;= nextStart ifTrue: [-1] ifFalse: [0]]]</body><body package="Chronos-DateTimeInterval" selector="compareToTimeperiod:">compareToTimeperiod: aTimeperiod 	| diff thisStart thisNextStart thatStart thatNextStart |	thisStart := self start.	thisNextStart := self limit.	thatStart := aTimeperiod start.	thatNextStart := aTimeperiod limit.	^thisNextStart &gt;= thisStart 		ifTrue: 			[thatNextStart &gt;= thatStart 				ifTrue: 					[diff := thatStart compareTo: thisStart.					diff = 0 ifFalse: [^diff].					thatNextStart compareTo: thisNextStart]				ifFalse: 					[diff := thatNextStart + thatNextStart resolutionQuantum compareTo: thisStart.					diff = 0 ifFalse: [^diff].					thatStart compareTo: thisNextStart - thisNextStart resolutionQuantum]]		ifFalse: 			[thatNextStart &gt;= thatStart 				ifTrue: 					[diff := thatStart compareTo: thisNextStart + thisNextStart resolutionQuantum.					diff = 0 ifFalse: [^diff].					thatNextStart - thatNextStart resolutionQuantum compareTo: thisStart]				ifFalse: 					[diff := thatNextStart compareTo: thisNextStart.					diff = 0 ifFalse: [^diff].					thatStart compareTo: thisStart]]</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>INTER-period-stream protocol</category><body package="Chronos-DateTimeInterval" selector="next">next	"Answer a Timeperiod whose starting point-in-time is the receiver's limit value (end-point,) and whose temporal extent (duration) is the same as the receiver's.  See the class comment for the definition of these terms."	"{Timeperiod currentHour next}"	"{Timeperiod today next}"	"{Timeperiod currentWeek next}"	"{Timeperiod currentMonth next}"	"{Timeperiod currentYear next}"	^self class from: self limit duration: self duration</body><body package="Chronos-DateTimeInterval" selector="prev">prev	"Answer a Timeperiod whose starting point-in-time is computed by subtracting the receiver's temporal extent (duration) from its starting point-in-time, and whose temporal extent (duration) is the same as the receiver's.  See the class comment for the definition of these terms."	"{Timeperiod currentHour prev}"	"{Timeperiod today prev}"	"{Timeperiod currentWeek prev}"	"{Timeperiod currentMonth prev}"	"{Timeperiod currentYear prev}"	^self class from: self start - self duration duration: self duration</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>accessing-UT</category><body package="Chronos-DateTimeInterval" selector="utDaysSinceEpoch">utDaysSinceEpoch	^start utDaysSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="utJulianDay">utJulianDay	"Answers the Julian Day Number of the Julian Day in which the the point-in-time represented by the receiver occurs (Universal Time.) However, if the receiver's interval spans across the transition from one Julian Day to the next, then the Julian Day Number of the first Julian Day that starts at Noon within the interval of time represented by the receiver is answered (also Universal Time.)"	^start utJulianDay</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceEpoch">utNanosecondsSinceEpoch	^start utNanosecondsSinceEpoch</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceSecond">utNanosecondsSinceSecond	^start utNanosecondsSinceSecond</body><body package="Chronos-DateTimeInterval" selector="utNanosecondsSinceStartOfDay">utNanosecondsSinceStartOfDay	^start utNanosecondsSinceStartOfDay</body><body package="Chronos-DateTimeInterval" selector="utSecondsSinceStartOfDay">utSecondsSinceStartOfDay	^start utSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>accessing-multivalued</category><body package="Chronos-DateTimeInterval" selector="yearAndCalendarDayDo:">yearAndCalendarDayDo: block2 	^start yearAndCalendarDayDo: block2</body><body package="Chronos-DateTimeInterval" selector="yearMonthDayDo:">yearMonthDayDo: block3 	"Evaluate &lt;block3&gt; with the calendar year number, month ordinal and day-of-month ordinal of the day represented by the receiver as the first, second and third arguments (respectively.) If the receiver is not bound to a particular year, use nil as the value of the year."	^start yearMonthDayDo: block3</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>deprecated</category><body package="Chronos-DateTimeInterval" selector="upTo:">upTo: limitValue	"Deprecated. See #to:"	^self to: limitValue</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>private-time zone operations</category><body package="Chronos-DateTimeInterval" selector="basicTimeZone">basicTimeZone	^start basicTimeZone</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>comparing</category><body package="Chronos-DateTimeInterval" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToTimeperiod: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aCalendrical and: [ex message selector == #compareToTimeperiod:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.Timeperiod</class-id> <category>printing</category><body package="Chronos-Printing" selector="defaultPrintPolicy">defaultPrintPolicy	^ChronosPrintPolicy iso8601</body><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	"If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy default (or ChronosPrintPolicy ansiStandard or ChronosPrintPolicy iso8601,) then the receiver's printString will be formatted as required by the ISO 8601 Standard."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printTimeperiod: self on: stream</body></methods><methods><class-id>Chronos.Timeperiod class</class-id> <category>instance creation-current periods</category><body package="Chronos-DateTimeInterval" selector="currentHour">currentHour	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is the initial moment of the current hour (a DateAndTime instance bound to current default timezone and the Gregorian Calendar) and whose open temporal extent is one hour. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod currentHour}"	^self hourStartingAt: self dateAndTimeFactory nowToTheHour</body><body package="Chronos-DateTimeInterval" selector="currentMinute">currentMinute	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is the initial moment of the current minute (a DateAndTime instance bound to current default timezone and the Gregorian Calendar) and whose open temporal extent is one minute. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod currentMinute}"	^self minuteStartingAt: self dateAndTimeFactory nowToTheMinute</body><body package="Chronos-DateTimeInterval" selector="currentMonth">currentMonth	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is the first day of the current month (a YearMonthDay instance bound to the Gregorian Calendar) and whose open temporal extent is one month. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod currentMonth}"	^self monthStartingAt: self dateFactory atFirstDayOfMonth</body><body package="Chronos-DateTimeInterval" selector="currentSecond">currentSecond	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is the initial moment of the current second (a DateAndTime instance bound to current default timezone and the Gregorian Calendar) and whose open temporal extent is one second. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod currentSecond}"	^self secondStartingAt: self dateAndTimeFactory nowToTheSecond</body><body package="Chronos-DateTimeInterval" selector="currentWeek">currentWeek 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is the first day of the current week (a YearMonthDay instance bound to the Gregorian Calendar) and whose open temporal extent is one week (7 days.) The first day of the week is considered to be Sunday. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod currentWeek}"	^self weekStartingAt: self dateFactory atFirstDayOfWeek</body><body package="Chronos-DateTimeInterval" selector="currentYear">currentYear	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is the first day of the current year (a YearMonthDay instance bound to the Gregorian Calendar) and whose open temporal extent is one year. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod currentYear}"	"{(Timeperiod currentYear quarterPeriods at: 4) last}"	^self yearStartingAt: self dateFactory atFirstDayOfYear</body><body package="Chronos-DateTimeInterval" selector="nowIn:as:duration:">nowIn: aChronosTimezoneOrTimezoneReference as: aCalendarOrCalendarReference duration: aDurational 	"{Timeperiod nowIn: 'Pacific/Kiritimati' as: #Julian duration: MinuteDuration}"	"{Timeperiod nowIn: #system as: #Gregorian duration: CalendarDayDuration}"	"{Timeperiod nowIn: #nominal as: #Gregorian duration: CivilSecondDuration}"	"{Timeperiod nowIn: 'Asia/Jerusalem' as: #Hebrew duration: WeekDuration}"	"{Timeperiod nowIn: 'Asia/Calcutta' as: #Indian duration: (ScientificDuration milliseconds: 1)}"	"{Timeperiod nowIn: 'Asia/Tehran' as: #Persian duration: HourDuration}"	^self 		from: 			(self dateAndTimeFactory 				nowIn: aChronosTimezoneOrTimezoneReference				as: aCalendarOrCalendarReference)		duration: aDurational</body><body package="Chronos-DateTimeInterval" selector="nowIn:duration:">nowIn: aChronosTimezoneOrTimezoneReference duration: aDurational 	"{Timeperiod nowIn: 'Pacific/Kiritimati' duration: MinuteDuration}"	"{Timeperiod nowIn: #system duration: CalendarDayDuration}"	"{Timeperiod nowIn: #nominal duration: CivilSecondDuration}"	"{Timeperiod nowIn: 'Asia/Jerusalem' duration: WeekDuration}"	"{Timeperiod nowIn: 'Asia/Calcutta' duration: (ScientificDuration milliseconds: 1)}"	"{Timeperiod nowIn: 'Asia/Tehran' duration: HourDuration}"	^self nowIn: aChronosTimezoneOrTimezoneReference as: AnsiStandardCalendar duration: aDurational</body><body package="Chronos-DateTimeInterval" selector="nowWithDuration:">nowWithDuration: aDurational 	"{Timeperiod nowWithDuration: MinuteDuration}"	"{Timeperiod nowWithDuration: CalendarDayDuration}"	"{Timeperiod nowWithDuration: CivilSecondDuration}"	"{Timeperiod nowWithDuration: WeekDuration}"	"{Timeperiod nowWithDuration: (ScientificDuration milliseconds: 1)}"	"{Timeperiod nowWithDuration: HourDuration}"	^self nowIn: ChronosTimezone default duration: aDurational</body><body package="Chronos-DateTimeInterval" selector="today">today 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is today (a YearMonthDay instance bound to the Gregorian Calendar) and whose open temporal extent is one day. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod today}"	"{Timeperiod today next: 30}"	^self dayStartingAt: self dateFactory today</body><body package="Chronos-DateTimeInterval" selector="todayAs:">todayAs: aCalendarOrCalendarReference	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is today (a YearMonthDay instance bound to the calendar implemented or referenced by &lt;aCalendarOrCalendarReference&gt;) and whose open temporal extent is one day. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod todayAs: #Hebrew}"	^self dayStartingAt: (self dateFactory todayAs: aCalendarOrCalendarReference)</body><body package="Chronos-DateTimeInterval" selector="todayIn:">todayIn: aTimeZoneOrTimeZoneReference	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is today in the timezone referenced by &lt;aTimeZoneOrTimeZoneReference&gt; (the starting point-in-time will be a YearMonthDay instance bound to the Gregorian Calendar) and whose open temporal extent is one day. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod todayIn: 'Asia/Calcutta'}"	"{Timeperiod todayIn: #default}"	"{Timeperiod todayIn: #nominal}"	| tz |	tz := ChronosTimezone referencedBy: aTimeZoneOrTimeZoneReference.	^self dayStartingAt: ((tz isInvariantToNominalTime ifTrue: [self dateFactory] ifFalse: [self dateAndTimeFactory]) todayIn: tz)</body><body package="Chronos-DateTimeInterval" selector="todayIn:as:">todayIn: aTimeZoneOrTimeZoneReference as: aCalendarOrCalendarReference	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is today in the timezone referenced by &lt;aTimeZoneOrTimeZoneReference&gt; (the starting point-in-time will be a YearMonthDay instance bound to the calendar implemented or referenced by &lt;aCalendarOrCalendarReference&gt;) and whose open temporal extent is one day. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod todayIn: 'Asia/Calcutta' as: #Indian}"	"{Timeperiod todayIn: #default as: #Indian}"	"{Timeperiod todayIn: #nominal as: #Indian}"	| tz |	tz := ChronosTimezone referencedBy: aTimeZoneOrTimeZoneReference.	^self dayStartingAt: ((tz isInvariantToNominalTime ifTrue: [self dateFactory] ifFalse: [self dateAndTimeFactory]) todayIn: tz as: aCalendarOrCalendarReference)</body></methods><methods><class-id>Chronos.Timeperiod class</class-id> <category>instance creation</category><body package="Chronos-DateTimeInterval" selector="duration:through:">duration: temporalExtent through: finalMoment	"Answer a new Timeperiod that represents a closed temporal interval whose starting point-in-time is &lt;finalMoment - temporalExtent + finalMoment resolutionQuantum&gt; (where &lt;finalMoment&gt; is a TemporalCoordinate) and whose open temporal extent is &lt;temporalExtent&gt; (a Durational instance.) A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod		duration: (CalendarDuration years: 100) 		to: (YearMonthDay year: 2001 day: 1)}"	"{(Timeperiod		duration: (ScientificDuration hours: 2) 		to: (Timepoint year: 2005 month: 4 day: 3 hour: 4 minute: 0 second: 0)) hourPeriods}"	^self new		setStart: finalMoment - temporalExtent + finalMoment resolutionQuantum duration: temporalExtent;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="duration:to:">duration: temporalExtent to: limitMoment	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;limitMoment - temporalExtent&gt; (where &lt;last&gt; is a TemporalCoordinate) and whose open temporal extent is &lt;temporalExtent&gt; (a Durational instance.) A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod		duration: (CalendarDuration years: 100) 		to: (YearMonthDay year: 1901 day: 1)}"	"{(Timeperiod		duration: (ScientificDuration hours: 2) 		to: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 0 second: 0)) hourPeriods}"	^self new		setStart: limitMoment - temporalExtent duration: temporalExtent;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="endpoint:endpoint:">endpoint: endpoint1 endpoint: endpoint2	"{Timeperiod 		endpoint: (YearMonthDay year: 1901 day: 1)		endpoint: (YearMonthDay year: 2001 day: 1)}"	"{Timeperiod 		endpoint: (YearMonthDay year: 2001 day: 1)		endpoint: (YearMonthDay year: 1901 day: 1)}"	^endpoint1 &lt;= endpoint2		ifTrue: [self from: endpoint1 to: endpoint2]		ifFalse: [self from: endpoint2 to: endpoint1]</body><body package="Chronos-DateTimeInterval" selector="from:duration:">from: initialMoment duration: temporalExtent	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is &lt;temporalExtent&gt; (a Durational instance.) A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod 		from: (YearMonthDay year: 1901 day: 1)		duration: (CalendarDuration years: 100)}"	"{(Timeperiod 		from: (Timepoint year: 2005 month: 4 day: 3 hour: 1 minute: 0 second: 0)		duration: (ScientificDuration hours: 2)) hourPeriods}"	^self new		setStart: initialMoment duration: temporalExtent;		beImmutable</body><body package="Chronos-DateTimeInterval" selector="from:through:">from: initialMoment through: finalMoment	"Answer a new Timeperiod that represents a closed temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose right end-point (its final value) is &lt;finalMoment&gt;. A closed temporal interval includes both its initial moment (left end-point) and also its right end-point. The temporal extent of the answered instance will be the ScientificDuration computed by subtracting the &lt;initialMoment&gt; from the &lt;limitMoment&gt;, and then adding the resolution quantum of &lt;finalMoment&gt;."	"{Timeperiod 		from: (YearMonthDay year: 1901 day: 1)		through: (YearMonthDay year: 2000 day: 366)}"	"{Timeperiod 		from: (YearMonthDay year: 2001 day: 1)		through: (YearMonthDay year: 1901 day: 1)}"	^self from: initialMoment to: finalMoment + finalMoment resolutionQuantum</body><body package="Chronos-DateTimeInterval" selector="from:to:">from: initialMoment to: limitMoment	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose right end-point (its limit value) is &lt;limitMoment&gt;. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point. The temporal extent of the answered instance will be the ScientificDuration computed by subtracting the &lt;initialMoment&gt; from the &lt;limitMoment&gt;."	"{Timeperiod 		from: (YearMonthDay year: 1901 day: 1)		to: (YearMonthDay year: 2001 day: 1)}"	"{Timeperiod 		from: (YearMonthDay year: 2001 day: 1)		to: (YearMonthDay year: 1901 day: 1)}"	^self new		setStart: initialMoment limit: limitMoment;		beImmutable</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextTimeperiodFrom: stream usingFactory: self</body></methods><methods><class-id>Chronos.Timeperiod class</class-id> <category>instance creation-common periods</category><body package="Chronos-DateTimeInterval" selector="dayStartingAt:">dayStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one calendar day. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod dayStartingAt: Gregorian clock now}"	^self from: initialMoment duration: CalendarDayDuration</body><body package="Chronos-DateTimeInterval" selector="hourStartingAt:">hourStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one hour. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod hourStartingAt: Gregorian clock now}"	^self from: initialMoment duration: HourDuration</body><body package="Chronos-DateTimeInterval" selector="minuteStartingAt:">minuteStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one minute. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod minuteStartingAt: Gregorian clock now}"	^self from: initialMoment duration: MinuteDuration</body><body package="Chronos-DateTimeInterval" selector="monthStartingAt:">monthStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one month. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod monthStartingAt: YearMonthDay today}"	^self from: initialMoment duration: MonthDuration</body><body package="Chronos-DateTimeInterval" selector="quarterStartingAt:">quarterStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one quarter (three months.) A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod quarterStartingAt: YearMonthDay today}"	^self from: initialMoment duration: MonthDuration * 3</body><body package="Chronos-DateTimeInterval" selector="secondStartingAt:">secondStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one second. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"Timeperiod secondStartingAt: Gregorian clock now"	^self from: initialMoment duration: CivilSecondDuration</body><body package="Chronos-DateTimeInterval" selector="weekStartingAt:">weekStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one week (7 calendar days.) A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod weekStartingAt: YearMonthDay today}"	^self from: initialMoment duration: WeekDuration</body><body package="Chronos-DateTimeInterval" selector="yearStartingAt:">yearStartingAt: initialMoment 	"Answer a new Timeperiod that represents a right-closed, left-open temporal interval whose starting point-in-time is &lt;initialMoment&gt; (a TemporalCoordinate, such as a YearMonthDay, TimeOfDay or Timepoint instance) and whose open temporal extent is one year. A left-closed, right-open temporal interval includes its initial moment (left end-point) but does not include its right end-point (defined as the moment computed by adding the temporal extent to the initial moment.)"	"{Timeperiod yearStartingAt: YearMonthDay today}"	^self from: initialMoment duration: YearDuration</body></methods><methods><class-id>Chronos.Timeperiod class</class-id> <category>deprecated</category><body package="Chronos-DateTimeInterval" selector="startingAt:duration:">startingAt: initialMoment duration: temporalExtent	"Deprecated. See #from:duration:"	^self from: initialMoment duration: temporalExtent</body><body package="Chronos-DateTimeInterval" selector="startingAt:upTo:">startingAt: initialMoment upTo: limitMoment	"Deprecated. See #from:to:"	^self from: initialMoment to: limitMoment</body></methods><methods><class-id>Chronos.ChronosInstaller class</class-id> <category>class initialization</category><body package="Chronos-Installation" selector="initialize">initialize	ChronosEnvironment canonical install</body><body package="Chronos-Installation" selector="postLoad:">postLoad: aParcel	"Allow additional process of a Parcel after loading. This method works	with the matching method preSave:, to handle additional processing	before writing a Parcel. The typical operation to do here is to retrieve	named objects from aParcel (the objects that were saved by preSave:)."	ChronosEnvironment doInstallationInsteadOfReinstallation</body></methods><methods><class-id>Chronos.NanosecondSystemClock</class-id> <category>API-conversion</category><body package="Chronos-System" selector="microsecondsFromTicks:">microsecondsFromTicks: ticks	^ChronosFunction times1000: ticks</body><body package="Chronos-System" selector="millisecondsFromTicks:">millisecondsFromTicks: ticks	^ticks // NanosecondsPerMillisecond</body><body package="Chronos-System" selector="nanosecondsFromTicks:">nanosecondsFromTicks: ticks	^ticks</body><body package="Chronos-System" selector="nanosecondsSinceSecondFromTicks:">nanosecondsSinceSecondFromTicks: ticks	^ticks \\ ticksPerSecond</body><body package="Chronos-System" selector="secondsFromTicks:">secondsFromTicks: ticks	^ChronosFunction divBy1000000000: ticks	"{[1000000 timesRepeat: [(33554431 bitShift: -9) // 1953125]] durationToRun}	{[1000000 timesRepeat: [33554431 // 1000000000]] durationToRun}	{[1000000 timesRepeat: [33554431 // NanosecondsPerSecond]] durationToRun}	{[1000000 timesRepeat: [(33554431 // 1953125) bitShift: -9]] durationToRun}"</body><body package="Chronos-System" selector="ticksFromMicroseconds:">ticksFromMicroseconds: microseconds	^microseconds * NanosecondsPerMicrosecond</body><body package="Chronos-System" selector="ticksFromMilliseconds:">ticksFromMilliseconds: milliseconds	^milliseconds * NanosecondsPerMillisecond</body><body package="Chronos-System" selector="ticksFromNanososeconds:">ticksFromNanososeconds: nanoseconds	^nanoseconds</body><body package="Chronos-System" selector="ticksFromSeconds:">ticksFromSeconds: seconds	^seconds  * NanosecondsPerSecond	"{[1000000 timesRepeat: [33554431  * NanosecondsPerSecond]] durationToRun}	{[1000000 timesRepeat: [((33554431 bitShift: 9) * 1953125)]] durationToRun}	{[1000000 timesRepeat: [((33554431 * 1953125) bitShift: 9)]] durationToRun}			{33554431  * NanosecondsPerSecond}	{((33554431 bitShift: 9) * 1953125)}	{((33554431 * 1953125) bitShift: 9)}"</body></methods><methods><class-id>Chronos.NanosecondSystemClock</class-id> <category>accessing</category><body package="Chronos-System" selector="tickResolutionName">tickResolutionName	"Answer a Symbol that identifies a time unit whose duration is that of the receiver's tick resolution."	^#nanosecond</body></methods><methods><class-id>Chronos.NanosecondSystemClock</class-id> <category>API-timing</category><body package="Chronos-System" selector="ticksNowSinceSystemClockEpoch">ticksNowSinceSystemClockEpoch	"Answer the number of clock ticks since the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0)) up to the current moment. Do not adjust for timezone offset, just answer the raw value provided by the platform system clock (for many Smalltallk implementations, the platform system clock is a software device provided by the virtual machine, and can be accessed via primtive message send.)"	"The default implementation uses the network time service as defined by RFC-868, which provides the number of seconds since 1900-01-01T00:00:00 UTC"	^self subclassResponsibility</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="isAnsiStandard">isAnsiStandard	"If the calendrical system implemented by the receiver conforms in all respects to the requirements of the ANSI Smalltalk standard with respect to the behavior of DateAndTime instances, answer true.  Otherwise, answer false.  Specifically: Answer true if and only if the receiver implements the proleptic Gregorian Calendar using astronomical (pure ordinal) year numbering."	^true</body><body package="Chronos-Calendars-Regular" selector="isGregorian">isGregorian	"If the receiver implements the Gregorian Calendar, answer true. Otherwise, answer false."	^true</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Regular" selector="register">register	super register.	ChronosEnvironment canonical		setGregorian: self;		setAnsiStandardCalendar: self</body><body package="Chronos-Calendars-Regular" selector="release">release	super release.	self == Gregorian 		ifTrue: 			[(ChronosEnvironment canonical)				setGregorian: nil;				setAnsiStandardCalendar: nil;				setAnsiStandardCalendarClock: nil]</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^calendarYear \\ 4 == 0 		ifTrue: [calendarYear \\ 100 == 0 					ifTrue: [calendarYear \\ 400 == 0 								ifTrue: [2] 								ifFalse: [1]] 					ifFalse: [2]]		ifFalse: [1]</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="basicNewCalendarClock">basicNewCalendarClock	"Answer a new CalendarClock for use by the receiver as its canonical CalendarClock."	^ChronosSystemClock current newGregorianCalendarClock</body><body package="Chronos-Calendars-Regular" selector="bindToClock">bindToClock	"Perforn any necessary configuration or set up so that the receiver's &lt;clock&gt; can properly operate as the receiver's canonocal CalendarClock."	super bindToClock.	ChronosEnvironment canonical setAnsiStandardCalendarClock: self clock</body><body package="Chronos-Calendars-Regular" selector="bindToSystem">bindToSystem	"Make the receiver and other sytem objects collaborate with each other, as required by the overall system architecture."	Gregorian == nil ifTrue: [self register].	super bindToSystem</body><body package="Chronos-Calendars-Regular" selector="computeSecondsFromEpochUpToGregorianStart">computeSecondsFromEpochUpToGregorianStart	^(self 		daysSinceEpochUpToMonth: 10		day: 15		inYear: 1582)  * SecondsPerDay</body><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^1721425 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>API-validation</category><body package="Chronos-Calendars-Regular" selector="assertIsGregorian">assertIsGregorian	"If the calendrical system implemented by the receiver is not the Gregorian calendar, signal an Exception."	"Yup, that's me--so do nothing."</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"days-in-four-year-cycle=1461; days-in-century=36524; days-in-four-centuries=146097; days-in-20 centuries=730485 "	| quadCentury century quadYear year days yearTypeCode |	quadCentury := daysSinceEpoch // 146097.	days := daysSinceEpoch \\ 146097.	century := days // 36524.	days := days \\ 36524.	(days == 0 and: [century == 4]) 		ifTrue: 			["Handle the 36524th cardinal day--a leap day"			century := century - 1.			days := 36524].	quadYear := days // 1461.	days := days \\ 1461.	year := days // 365.	days := days \\ 365.	(days == 0 and: [year == 4]) 		ifTrue: 			["Handle the 365th cardinal day--a leap day"			year := year - 1.			days := 365].	yearTypeCode := 		year == 3 "Last year in 4-year cycle"			ifTrue: 				[quadYear = 24 "last 4-year cycle in century"					ifTrue: 						[century = 3 "last century in 4-century cycle" 							ifTrue: [2] ifFalse: [1]]					ifFalse: [2]]			ifFalse: [1].	^yearMonthDaySpecOrBlock2		value: (year + (quadCentury * 400) + (century * 100) + (quadYear * 4))  + 1		value: ((yearlyCalendars at: yearTypeCode) basicDayAt: days + 1)</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>API-InterCalendar</category><body package="Chronos-Calendars-Regular" selector="gregorianDateSpecFromDaysSinceEpoch:">gregorianDateSpecFromDaysSinceEpoch: daysSinceEpoch 		"Answer an instance of DateSpec that specifies a Gregorian year/month/day that is daysSinceEpoch days since my Epoch."	^self dateSpecFromDaysSinceEpoch: daysSinceEpoch</body></methods><methods><class-id>Chronos.GregorianCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToMonth:day:inYear:">daysSinceEpochUpToMonth: monthOrdinal day: dayOfMonthOrdinal  inYear: calendarYear	"Answer the number of days since the receiver's epoch up to (but not including) the &lt;dayOfMonthOrdinal&gt;th day of the &lt;monthOrdinal&gt;th month of the given &lt;calendarYear&gt;.  By definition, the answer when &lt;calendarYear&gt; = 1 (assuming positve years are ordinal numbers,) &lt;monthOrdinal&gt; = 1 and &lt;dayOfMonthOrdinal&gt; = 1 must be zero."	^self class daysSinceEpochUpToMonth: monthOrdinal day: dayOfMonthOrdinal  inYear: calendarYear</body><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	^self class daysSinceEpochUpToYear: calendarYear</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:day:forYearTypeCode:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^self class daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal forYearTypeCode: yearTypeCode</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonth:day:inYear:">daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear 	"Answer the number of days from the start of the year up to the given month/day. 	For example, the number of days from January 1 up to January 1 is 0 (assuming January 1 is the first day of the year.)"	^self class daysUpToMonth: monthOrdinal day: dayOfMonthOrdinal inYear: calendarYear</body></methods><methods><class-id>Chronos.GregorianCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="leapDayCorrectionForYear:month:">leapDayCorrectionForYear: year month: month                 ^month &gt; 2                 ifTrue: [(year \\ 4 = 0 and: [year \\ 100 ~= 0 or: [year \\ 400 = 0]]) ifTrue: [1] ifFalse: [2]]                 ifFalse: [0]</body><body package="Chronos-Calendars-Regular" selector="shouldIgnorePostLoad">shouldIgnorePostLoad	^true</body></methods><methods><class-id>Chronos.GregorianCalendar class</class-id> <category>functional verification</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYearVerifier">daysSinceEpochUpToYearVerifier	"GregorianCalendar daysSinceEpochUpToYearVerifier value: Calendar gregorian"	^[:calendar | 	((((((calendar daysSinceEpochUpToYear: 1) = 0)			and: [((calendar daysSinceEpochUpToYear: 0) = -366)				and: [((calendar daysSinceEpochUpToYear: 4) = 1095)					and: [((GregorianCalendar daysSinceEpochUpToYear: -3) = -1461)						and: [(calendar daysSinceEpochUpToYear: 5) = 1461]]]])		and: [((calendar daysSinceEpochUpToYear: 101) = 36524)				and: [((calendar daysSinceEpochUpToYear: 100) = 36159)					and: [((calendar daysSinceEpochUpToYear: 104) = 37619)						and: [((calendar daysSinceEpochUpToYear: 97) = 35064)							and: [(calendar daysSinceEpochUpToYear: 105) = 37985]]]]])		and: [((calendar daysSinceEpochUpToYear: -99 ) = -36525)				and: [((calendar daysSinceEpochUpToYear: -100) = -36890)					and: [((calendar daysSinceEpochUpToYear: -96) = -35430)						and: [((calendar daysSinceEpochUpToYear: -103) = -37985)							and: [(calendar daysSinceEpochUpToYear: -95) = -35064]]]]])		and: [((calendar daysSinceEpochUpToYear: 401) = 146097)				and: [((calendar daysSinceEpochUpToYear: 400) = 145731)					and: [((calendar daysSinceEpochUpToYear: 404) = 147192)						and: [((calendar daysSinceEpochUpToYear: 397) = 144636)							and: [(calendar daysSinceEpochUpToYear: 405) = 147558]]]]])		and: [((calendar daysSinceEpochUpToYear: -399 ) = -146097)				and: [((calendar daysSinceEpochUpToYear: -400) =  -146463)					and: [((calendar daysSinceEpochUpToYear: -396) = -145002)						and: [((calendar daysSinceEpochUpToYear: -403) =  -147558)							and: [(calendar daysSinceEpochUpToYear: -395) =  -144636]]]]]]</body><body package="Chronos-Calendars-Regular" selector="daysUpToMonthDayInYearVerifier">daysUpToMonthDayInYearVerifier	"GregorianCalendar daysUpToMonthDayInYearVerifier value: Calendar gregorian"	^[:calendar |		((((((calendar daysUpToMonth: 2 day: 29 inYear: 2000) = 59)		and: [(calendar daysUpToMonth: 3 day: 1 inYear: 2000) = 60])		and: [(calendar daysUpToMonth: 3 day: 1 inYear: 1900) = 59])		and: [(calendar daysUpToMonth: 12 day: 31 inYear: 1900) = 364])		and: [(calendar daysUpToMonth: 12 day: 31 inYear: 2000) = 365])		and: [super daysUpToMonthDayInYearVerifier value: calendar canonical]]</body><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpochSetYearAndCalendarDayIntoVerifier">forDaysSinceEpochSetYearAndCalendarDayIntoVerifier	"GregorianCalendar forDaysSinceEpochSetYearAndCalendarDayIntoVerifier value: Calendar gregorian"	^[:calendar | 	| passes |	passes := true.	(calendar forDaysSinceEpoch: 577735		setYearAndCalendarDayInto: 			[:year :calendarDay | 			passes := passes 						and: [year = 1582 and: [calendarDay month = 10 and: [calendarDay dayOfMonth = 15]]]]) 			and: 				[calendar forDaysSinceEpoch: -1721426					setYearAndCalendarDayInto: 						[:year :calendarDay | 						passes := passes 									and: [year = -4713 and: [calendarDay month = 11 and: [calendarDay dayOfMonth = 24]]]]].		passes and: [super forDaysSinceEpochSetYearAndCalendarDayIntoVerifier value: calendar]]</body></methods><methods><class-id>Chronos.GregorianCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Gregorian</body></methods><methods><class-id>Chronos.GregorianCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"GregorianCalendar initialize"	self basicInitialize.</body></methods><methods><class-id>Chronos.GregorianCalendar class</class-id> <category>fundamental algorithms</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"VERIFICATION (should evaluate to true): {GregorianCalendar daysSinceEpochUpToYearVerifier value: self}"	| cardinalYear |	cardinalYear := calendarYear - 1.	^ cardinalYear * 365 		+ (cardinalYear // 4) 		- (cardinalYear // 100) 		+ (cardinalYear // 400)</body><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^calendarYear \\ 4 == 0 		ifTrue: [calendarYear \\ 100 == 0 					ifTrue: [calendarYear \\ 400 == 0 								ifTrue: [2] 								ifFalse: [1]] 					ifFalse: [2]]		ifFalse: [1]</body></methods><methods><class-id>Passport.ExternalResourceReference</class-id> <category>accessing</category><body package="Passport-Kernel" selector="broker">broker	^broker</body><body package="Passport-Kernel" selector="broker:">broker: aResourceBroker	broker := aResourceBroker</body><body package="Passport-Kernel" selector="key:value:">key: aKey value: aValue	key := aKey.	^broker at: key put: aValue</body><body package="Passport-Kernel" selector="removeIfAbsent:">removeIfAbsent: ifAbsent	^broker removeKey: self key ifAbsent: ifAbsent</body><body package="Passport-Kernel" selector="value">value	^self valueIfNone: []</body><body package="Passport-Kernel" selector="value:">value: aValue	^broker at: self key put: aValue</body><body package="Passport-Kernel" selector="valueIfNone:">valueIfNone: ifNone	^broker at: self key ifAbsent: ifNone</body><body package="Passport-Kernel" selector="valueIfNonePut:">valueIfNonePut: valueBlock	^broker at: self key ifAbsentPut: valueBlock</body><body package="Passport-Kernel" selector="valueIfNoneThenAt:put:">valueIfNoneThenAt: writeKey put: valueBlock 	^broker 		at: key		ifAbsentThenAt: writeKey		put: 			[key := writeKey.			valueBlock value]</body></methods><methods><class-id>Passport.ExternalResourceReference</class-id> <category>testing</category><body package="Passport-Kernel" selector="valueIsDefined">valueIsDefined	^broker includesKey: self key</body></methods><methods><class-id>Chronos.DerivedSemanticAnnualDateRule</class-id> <category>queries</category><body package="Chronos-Semantic Dates" selector="nominalDateInYear:">nominalDateInYear: aYear	^dateTransformer applyTo: (baseRule nominalDateInYear: aYear)</body><body package="Chronos-Semantic Dates" selector="nominallyOccursOn:">nominallyOccursOn: aDate 	^baseRule nominallyOccursOn: (dateTransformer inverseApplyTo: aDate)</body><body package="Chronos-Semantic Dates" selector="observanceDateAndTypeInYear:into:ifNone:">observanceDateAndTypeInYear: aYear into: block2 ifNone: ifNoneBlock 	^derivationIsNominal 		ifTrue: [block2 value: (self nominalDateInYear: aYear) value: #nominal]		ifFalse: 			[baseRule 				observanceDateAndTypeInYear: aYear				into: 					[:baseObservedDate :observanceType | 					| observedDate |					observedDate := dateTransformer applyTo: baseObservedDate.					observedDate year = aYear 						ifTrue: [block2 value: observedDate value: observanceType]						ifFalse: [ifNoneBlock value]]				ifNone: [ifNoneBlock value]]</body><body package="Chronos-Semantic Dates" selector="observanceTypeFor:">observanceTypeFor: aDate 	^derivationIsNominal 		ifTrue: 			[| observanceType |			observanceType := baseRule observanceTypeFor: (dateTransformer inverseApplyTo: aDate).			observanceType == #observed ifTrue:[#none] ifFalse: [observanceType]]		ifFalse: [baseRule observanceTypeFor: (dateTransformer inverseApplyTo: aDate)]</body><body package="Chronos-Semantic Dates" selector="occursInYear:">occursInYear: aYear	^baseRule occursInYear: aYear</body><body package="Chronos-Semantic Dates" selector="occursOn:">occursOn: aDate 	^derivationIsNominal		ifTrue: [baseRule nominallyOccursOn: (dateTransformer inverseApplyTo: aDate)]		ifFalse: [baseRule occursOn: (dateTransformer inverseApplyTo: aDate)]</body></methods><methods><class-id>Chronos.DerivedSemanticAnnualDateRule</class-id> <category>initialize-release</category><body package="Chronos-Semantic Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	self setDerivationAsFromNominalDateOfBaseRule.	self setDateTransformer: (SimpleDateTransformer delta: (CalendarDuration days: -1))</body><body package="Chronos-Semantic Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	| selector |	super initializeFromLiteralArray: literalArray.	selector := (literalArray at: 6) asSymbol.	self perform: selector.	self 		setBaseRule: (literalArray at: 5) decodeAsLiteralArray;		setDateTransformer: (literalArray at: 7) decodeAsLiteralArray</body><body package="Chronos-Semantic Dates" selector="setBaseRule:">setBaseRule: aSemanticAnnualDateRule	"Set the receiver's base SemanticAnnualDateRule."	self assertMutability.	baseRule := aSemanticAnnualDateRule</body><body package="Chronos-Semantic Dates" selector="setDateTransformer:">setDateTransformer: aDateTransformer	self assertMutability.	dateTransformer := aDateTransformer</body><body package="Chronos-Semantic Dates" selector="setDerivationAsFromNominalDateOfBaseRule">setDerivationAsFromNominalDateOfBaseRule	self assertMutability.	derivationIsNominal := true.</body><body package="Chronos-Semantic Dates" selector="setDerivationAsFromObservedDateOfBaseRule">setDerivationAsFromObservedDateOfBaseRule	self assertMutability.	derivationIsNominal := false.</body></methods><methods><class-id>Chronos.DerivedSemanticAnnualDateRule</class-id> <category>accessing</category><body package="Chronos-Semantic Dates" selector="baseRule">baseRule	^baseRule</body><body package="Chronos-Semantic Dates" selector="calendar">calendar	^baseRule calendar</body><body package="Chronos-Semantic Dates" selector="dateTransformer">dateTransformer	^dateTransformer</body></methods><methods><class-id>Chronos.DerivedSemanticAnnualDateRule</class-id> <category>private</category><body package="Chronos-Semantic Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream		nextPut: baseRule literalArrayEncoding;		nextPut: (derivationIsNominal ifTrue: [#setDerivationAsFromNominalDateOfBaseRule] ifFalse: [#setDerivationAsFromObservedDateOfBaseRule]);		nextPut: self dateTransformer literalArrayEncoding</body></methods><methods><class-id>Chronos.DerivedSemanticAnnualDateRule</class-id> <category>testing</category><body package="Chronos-Semantic Dates" selector="isDerivationFromNominalDateOfBaseRule">isDerivationFromNominalDateOfBaseRule	^derivationIsNominal</body><body package="Chronos-Semantic Dates" selector="isDerived">isDerived	^true</body></methods><methods><class-id>Chronos.DerivedSemanticAnnualDateRule class</class-id> <category>instance creation</category><body package="Chronos-Semantic Dates" selector="semanticKey:effectiveYear:dayAfterNominalDayOf:">semanticKey: semanticKey effectiveYear: effectiveYear dayAfterNominalDayOf: aBaseRule 	^self 		semanticKey: semanticKey		effectiveYear: effectiveYear		derivedFromNominalDateOf: aBaseRule		dateTransformer: (SimpleDateTransformer delta: 1 days)</body><body package="Chronos-Semantic Dates" selector="semanticKey:effectiveYear:dayAfterObservedDayOf:">semanticKey: semanticKey effectiveYear: effectiveYear dayAfterObservedDayOf: aBaseRule 	^self 		semanticKey: semanticKey		effectiveYear: effectiveYear		derivedFromObservedDateOf: aBaseRule		dateTransformer: (SimpleDateTransformer delta: 1 days)</body><body package="Chronos-Semantic Dates" selector="semanticKey:effectiveYear:dayBeforeNominalDayOf:">semanticKey: semanticKey effectiveYear: effectiveYear dayBeforeNominalDayOf: aBaseRule 	^(self new)		setKey: semanticKey;		setEffectiveYear: effectiveYear;		setBaseRule: aBaseRule</body><body package="Chronos-Semantic Dates" selector="semanticKey:effectiveYear:dayBeforeObservedDateOf:">semanticKey: semanticKey effectiveYear: effectiveYear dayBeforeObservedDateOf: aBaseRule 	^(self basicNew)		setKey: semanticKey;		setEffectiveYear: effectiveYear;		setBaseRule: aBaseRule;		setDerivationAsFromObservedDateOfBaseRule</body><body package="Chronos-Semantic Dates" selector="semanticKey:effectiveYear:derivedFromNominalDateOf:dateTransformer:">semanticKey: semanticKey effectiveYear: effectiveYear derivedFromNominalDateOf: aBaseRule dateTransformer: aDateTransformer	^(self basicNew)		setKey: semanticKey;		setEffectiveYear: effectiveYear;		setBaseRule: aBaseRule;		setDateTransformer: aDateTransformer;		setDerivationAsFromNominalDateOfBaseRule</body><body package="Chronos-Semantic Dates" selector="semanticKey:effectiveYear:derivedFromObservedDateOf:dateTransformer:">semanticKey: semanticKey effectiveYear: effectiveYear derivedFromObservedDateOf: aBaseRule dateTransformer: aDateTransformer	^(self basicNew)		setKey: semanticKey;		setEffectiveYear: effectiveYear;		setBaseRule: aBaseRule;		setDateTransformer: aDateTransformer;		setDerivationAsFromObservedDateOfBaseRule</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="beDefault">beDefault	"Set the receiver's root timezone as the default time zone. If the receiver's root timezone is the system time zone, cause the default time zone to virtually shadow the system time zone, so that whenever the system time zone is set to a different value, the default time zone is also set to the same new value."	self canonical beDefault</body><body package="Chronos-TimeZones" selector="beSystem">beSystem	"Set the receiver's root timezone as the system time zone. This operation may or may not affect the host Smalltalk environment and/or the host operating system. See the class of the current ChronosSystemFacade singleton to determine the behavior in the current environment and platform."	self canonical beSystem</body><body package="Chronos-TimeZones" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	key := (literalArray at: 2) asSymbol.</body><body package="Chronos-TimeZones" selector="release">release 	| registrationKey subRegistry |	super release.	key == nil ifTrue: [^self].	registrationKey := self class bindingRegistryKeyForTimeZoneKey: key commonAbbreviation: self commonAbbreviation.	subRegistry := self class offsetRegistry at: registrationKey ifAbsent: [^self].	^subRegistry removeKey: (self offsetDeltaSeconds * SecondsPerDay) + self offsetSecondsFromUT ifAbsent: [^self]</body><body package="Chronos-TimeZones" selector="setKey:offsetSeconds:commonAbbreviation:">setKey: aTZKey offsetSeconds: seconds commonAbbreviation: aSymbol	"Set the receiver's time zone key to be &lt;aTZKey&gt;; 	set the receiver's offset from UT to be the specified number of &lt;seconds&gt;;. 	set the receiver's common abbreviation to be &lt;aSymbol&gt;.	Fail if the receiver is not mutable."	self setOffsetFromUT: (self class offsetFromSeconds: seconds) commonAbbreviation: aSymbol.	key := aTZKey.</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processStandardTime: self</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="abbreviation">abbreviation	"Answer the abbreviation for the timezone represented by the receiver--according to the default locale if possible."	^ChronosLocale default abbreviationAtSemanticKey: self key ifAbsent: [self commonAbbreviation]</body><body package="Chronos-TimeZones" selector="aliasingKeys">aliasingKeys	^self root aliasingKeys</body><body package="Chronos-TimeZones" selector="canonicalKey">canonicalKey	^self root canonicalKey</body><body package="Chronos-TimeZones" selector="defaultAnnualPolicy">defaultAnnualPolicy	"Answer the AnnuallyRecurringTZPolicy that specifies the time zone rules that are in effect during the current year."	^self root defaultAnnualPolicy</body><body package="Chronos-TimeZones" selector="geographicCoordinates">geographicCoordinates	^self root geographicCoordinates</body><body package="Chronos-TimeZones" selector="key">key	"Answer the key that identifies the receiver."	^key</body><body package="Chronos-TimeZones" selector="name">name	^self nameIfNone: [self key]</body><body package="Chronos-TimeZones" selector="nameIfNone:">nameIfNone: noneBlock	^self root nameIfNone: [self defaultNameIfNone: noneBlock]</body><body package="Chronos-TimeZones" selector="namespaceKey">namespaceKey	^#dynamic</body><body package="Chronos-TimeZones" selector="policy">policy	"Answer the TimeZonePolicy that specifies the ruleset of the time zone represented by the instance.  The ruleset of a time zone specifies for all time values, from the infinite past to the infinite future, the (possibly varying) time zone offsets and abbreviations that apply to points-in-time within the territorial domain of the time zone. Note, however, that the `policy` (time zone ruleset) can be changed retroactively--and this is rather likely to happen for times in the future (but can also happen to times in the past.)"	^self root policy</body><body package="Chronos-TimeZones" selector="root">root	^self class at: key</body><body package="Chronos-TimeZones" selector="timeType">timeType	^#standard</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="asStatic">asStatic	^ChronosTimezone 		offset: self offsetFromUT		name: self name		commonAbbreviation: commonAbbreviation</body><body package="Chronos-TimeZones" selector="asUnbound">asUnbound	"Answer the unbound time zone that specifies the full diachronic ruleset of the time zone represented by the receiver."	^self root</body><body package="Chronos-TimeZones" selector="canonical">canonical	"Answer the canonical instance of the receiver's root time zone."	^self root canonical</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="hasSubsecondOffset">hasSubsecondOffset	"Answer whether the receiver has fractional seconds of offset."	^false</body><body package="Chronos-TimeZones" selector="isProxyOrStatic">isProxyOrStatic	"Answer whether the receiver is either a proxy time zone or a static time zone."	^false</body><body package="Chronos-TimeZones" selector="isStandardTime">isStandardTime	"Answer whether or not the offset from UT specified by the receiver defines the `standard time` of the time zone represented by the receiver (as opposed to `daylight saving time`, `summer time`, `war time`, 'three-year-long-year-round energy-saving-during-a-crisis time', etc)."	^true</body><body package="Chronos-TimeZones" selector="isStatic">isStatic	"Answer whether or not the timezone policy (key, offset, name and abbreviation) of the timezone represented by the receiver is invariant, constant and never subject to change or revision.  If the receiver's timezone policy is dynamically redefinable, answer false."	^false</body><body package="Chronos-TimeZones" selector="isUniversalTime">isUniversalTime	"Anwser whether the receiver has all the properties and behaviors of the international reference zero-offset time zone.	[Note: Universal Time is intrinsically static--unlike the receiver."	^false</body><body package="Chronos-TimeZones" selector="keyIsGlobal">keyIsGlobal	"Answer whether the receiver's identifying key is a globally well-known value."	^key ~~ #system 		and: [TimeZonePolicyFactory timezoneKeyIsGloballyDefined: key]</body><body package="Chronos-TimeZones" selector="specifiesAbbreviation">specifiesAbbreviation	^self specifiesCommonAbbreviation or: [(ChronosLocale default abbreviationAtSemanticKey: self key ifAbsent: [nil]) ~~ nil]</body><body package="Chronos-TimeZones" selector="specifiesGeographicCoordinates">specifiesGeographicCoordinates	^self root specifiesGeographicCoordinates</body><body package="Chronos-TimeZones" selector="specifiesName">specifiesName	^super specifiesName or: [self root specifiesName]</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-TimeZones" selector="canonicalizeFromLocal:">canonicalizeFromLocal: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time in the local time defined by the receiver, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use Universal Time coordinates instead of local time coordinates.)"	^aDateAndTime canonicalizeFromLocal: self offsetSecondsFromUT nanoseconds: 0</body><body package="Chronos-TimeZones" selector="canonicalizeFromUT:">canonicalizeFromUT: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time using Universal Time coordinates, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use coordinates in the local time defined by the receiver instead of using Universal Time coordinates.)"	^aDateAndTime canonicalizeFromUT: self offsetSecondsFromUT nanoseconds: 0</body><body package="Chronos-TimeZones" selector="netSecondsAfterAddingOffsetFromUTToSeconds:nanosecondsSinceSecond:">netSecondsAfterAddingOffsetFromUTToSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from adding the receiver's offset from UT to the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	"Note: Chronos `bound, dynamic` time zones, such as instances of StandardTime or NonStandardTime, are not allowed to have offsets from UT that have fractional seconds."	^seconds + offsetFromUT asSeconds</body><body package="Chronos-TimeZones" selector="netSecondsAfterSubtractingOffsetFromUTFromSeconds:nanosecondsSinceSecond:">netSecondsAfterSubtractingOffsetFromUTFromSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from subtracting the receiver's offset from UT from the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	"Note: Chronos `bound, dynamic` time zones, such as instances of StandardTime or NonStandardTime, are not allowed to have offsets from UT that have fractional seconds."	^seconds - offsetFromUT asSeconds</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>queries</category><body package="Chronos-TimeZones" selector="bindingForLocalYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForLocalYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in the local time defined by the receiver.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in local (`wall clock`) time as defined by the receiver."	^self root 		bindingForLocalYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body><body package="Chronos-TimeZones" selector="bindingForUTYear:dayOfYear:secondsSinceStartOfDayFunction:">bindingForUTYear: year dayOfYear: dayOfYear secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction 	"Answer the bound time zone whose offset/abbreviation tuple is correct for the specified &lt;year&gt; and &lt;dayOfYear&gt; ordinal (both in Universal Time.)  If the seconds-since-start-of-day value is needed to resolve the bound timezone, the &lt;secondsSinceStartOfDayFunction&gt; block will be invoked with a single argument whose value is an offset from UT in seconds.  When invoked, the block must answer the number of seconds since start-of-day, using the &lt;offsetSecondsFromUT&gt; passed in as the argument to the block to convert to/from UT if necessary. The answered seconds-since-start-of-day should be in Universal Time."	^self root  		bindingForUTYear: year		dayOfYear: dayOfYear		secondsSinceStartOfDayFunction: secondsSinceStartOfDayFunction</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>private-comparing</category><body package="Chronos-TimeZones" selector="isEqualToTimezone:">isEqualToTimezone: aTimezone 	self class == aTimezone class ifFalse: [^false].	^self key == aTimezone key and: [self offsetFromUT = aTimezone offsetFromUT]</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>private</category><body package="Chronos-TimeZones" selector="defaultName">defaultName	^self defaultNameIfNone: [self key]</body><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneBlock	^name == nil		ifTrue: [self root nameIfNone: noneBlock]  		ifFalse: [name]</body><body package="Chronos-TimeZones" selector="keyIsAlias">keyIsAlias	^self root keyIsAlias</body><body package="Chronos-TimeZones" selector="literalArrayEncodingOfKey">literalArrayEncodingOfKey	^key</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>printing</category><body package="Chronos-TimeZones" selector="printKeyOn:">printKeyOn: stream	stream nextPutAll: self key</body></methods><methods><class-id>Chronos.StandardTime</class-id> <category>ST-80/VW compatibility</category><body package="Chronos-ST80 (and VW) Compatibility" selector="convertGMT:do:">convertGMT: utSecondsSinceST80Epoch do: block2 	^self root convertGMT: utSecondsSinceST80Epoch do: block2</body><body package="Chronos-ST80 (and VW) Compatibility" selector="convertToGMT:do:">convertToGMT: localSecondsSinceST80Epoch do: block2 	^self root convertToGMT: localSecondsSinceST80Epoch do: block2</body></methods><methods><class-id>Chronos.GeographicCoordinateSpec</class-id> <category>accessing</category><body package="Chronos-Foundation" selector="degreesOfLattitude">degreesOfLattitude	^degreesOfLattitude rounded</body><body package="Chronos-Foundation" selector="degreesOfLongitude">degreesOfLongitude	^degreesOfLongitude rounded</body><body package="Chronos-Foundation" selector="fractionalDegreesOfLattitude">fractionalDegreesOfLattitude	^degreesOfLattitude</body><body package="Chronos-Foundation" selector="fractionalDegreesOfLongitude">fractionalDegreesOfLongitude	^degreesOfLongitude</body><body package="Chronos-Foundation" selector="minutesOfLattitude">minutesOfLattitude	^(degreesOfLattitude * 60) rounded rem: 60</body><body package="Chronos-Foundation" selector="minutesOfLongitude">minutesOfLongitude	^(degreesOfLongitude * 60) rounded rem: 60</body><body package="Chronos-Foundation" selector="secondsOfLattitude">secondsOfLattitude	^(degreesOfLattitude * 3600) rounded rem: 60</body><body package="Chronos-Foundation" selector="secondsOfLongitude">secondsOfLongitude	^(degreesOfLongitude * 3600) rounded rem: 60</body></methods><methods><class-id>Chronos.GeographicCoordinateSpec</class-id> <category>private</category><body package="Chronos-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream		nextPut: degreesOfLattitude;		nextPut: degreesOfLongitude</body></methods><methods><class-id>Chronos.GeographicCoordinateSpec</class-id> <category>initialize-release</category><body package="Chronos-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	self assertMutability.	degreesOfLattitude := 0.	degreesOfLongitude := 0.</body><body package="Chronos-Foundation" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setDegreesOfLattitude: (literalArray at: 2);		setDegreesOfLongitude: (literalArray at: 3)</body><body package="Chronos-Foundation" selector="setDegreesOfLattitude:">setDegreesOfLattitude: degrees	self assertMutability.	degreesOfLattitude := degrees</body><body package="Chronos-Foundation" selector="setDegreesOfLongitude:">setDegreesOfLongitude: degrees	self assertMutability.	degreesOfLongitude := degrees</body><body package="Chronos-Foundation" selector="setLattitudeDegrees:minutes:seconds:">setLattitudeDegrees: degrees minutes: minutes seconds: seconds	self setDegreesOfLattitude: degrees + (minutes / 60) + (seconds / 3600)</body><body package="Chronos-Foundation" selector="setLongitudeDegrees:minutes:seconds:">setLongitudeDegrees: degrees minutes: minutes seconds: seconds	self setDegreesOfLongitude: degrees + (minutes / 60) + (seconds / 3600)</body></methods><methods><class-id>Chronos.GeographicCoordinateSpec</class-id> <category>printing</category><body package="Chronos-Foundation" selector="printOn:">printOn: stream	"Per ISO 6709"	stream nextPut: (degreesOfLattitude positive ifTrue: [$+] ifFalse: [$-]).	ChronosFunction 		print: self degreesOfLattitude abs paddedWith: $0 to: 2 on: stream; 		print: self minutesOfLattitude abs paddedWith: $0 to: 2 on: stream; 		print: self secondsOfLattitude abs paddedWith: $0 to: 2 on: stream.	stream nextPut: (degreesOfLongitude positive ifTrue: [$+] ifFalse: [$-]).	ChronosFunction 		print: self degreesOfLongitude abs paddedWith: $0 to: 3 on: stream; 		print: self minutesOfLongitude abs paddedWith: $0 to: 2 on: stream; 		print: self secondsOfLongitude abs paddedWith: $0 to: 2 on: stream.</body></methods><methods><class-id>Chronos.GeographicCoordinateSpec class</class-id> <category>private</category><body package="Chronos-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body></methods><methods><class-id>Chronos.GeographicCoordinateSpec class</class-id> <category>instance creation</category><body package="Chronos-Foundation" selector="degreesOfLattitude:longitude:">degreesOfLattitude: lattitude longitude: longitude 	^(self new)		setDegreesOfLattitude: lattitude;		setDegreesOfLongitude: longitude;		beImmutable</body><body package="Chronos-Foundation" selector="lattitudeDegrees:minutes:seconds:longitudeDegrees:minutes:seconds:">lattitudeDegrees: latDegrees minutes: latMinutes seconds: latSeconds longitudeDegrees: lonDegrees minutes: lonMinutes seconds: lonSeconds 	^(self new)		setLattitudeDegrees: latDegrees			minutes: latMinutes			seconds: latSeconds;		setLongitudeDegrees: lonDegrees			minutes: lonMinutes			seconds: lonSeconds;		beImmutable</body><body package="Chronos-Foundation" selector="readFrom:">readFrom: stream 	"Create an instance based on the contents of stream."	"Expects IS0 6709 format:		{GeographicCoordinateSpec readFromString: '+340308-1181434'}"	| ch latPolarity latDegrees latMinutes latSeconds lonPolarity lonDegrees lonMinutes lonSeconds |	ChronosFunction skipSeparators: stream.	((latPolarity := #($- $+) indexOf: stream next ifAbsent: [0]) &gt; 0)		ifFalse: [^self signalError: 'Lattitude must begin with either + or -'].	latPolarity := #(-1 1) at: latPolarity.	latDegrees := 		ChronosFunction 			nextUnsignedIntegerFrom: stream			minDigits: 2			maxDigits: 2			acceptancePredicate: [:int :digitCount | true]			handleRejection: 					[:value :digitCount :rejectionReason | 					^self signalError: 'Degress of lattitude must have exactly and only two digits, and must be &lt;= 90'].	latMinutes := 		ChronosFunction 			nextUnsignedIntegerFrom: stream			minDigits: 2			maxDigits: 2			acceptancePredicate: [:int :digitCount | int &lt;= 90]			handleRejection: 					[:value :digitCount :rejectionReason | 					^self signalError: 'Minutes of lattitude must have exactly and only two digits, and must be &lt; 60'].	ch := stream peek.	((lonPolarity := #($- $+) indexOf: ch ifAbsent: [0]) &gt; 0)		ifTrue: 			[stream next.			latSeconds := 0]		ifFalse: 			[latSeconds := 				ChronosFunction 					nextUnsignedIntegerFrom: stream					minDigits: 2					maxDigits: 2					acceptancePredicate: [:int :digitCount | int &lt; 60]					handleRejection: 							[:value :digitCount :rejectionReason | 							^self signalError: 'Seconds of lattitude must have either two digits or none at all, and if present must be &lt; 60'].			((lonPolarity := #($- $+) indexOf: stream next ifAbsent: [0]) &gt; 0)				ifFalse: [^self signalError: 'Longitude must begin with either + or -']].	lonPolarity := #(-1 1) at: lonPolarity.	lonDegrees := 		ChronosFunction 			nextUnsignedIntegerFrom: stream			minDigits: 3			maxDigits: 3			acceptancePredicate: [:int :digitCount | int &lt;= 180]			handleRejection: 					[:value :digitCount :rejectionReason | 					^self signalError: 'Degress of longitude must have exactly and only three digits, and must be &lt;= 180'].	lonMinutes := 		ChronosFunction 			nextUnsignedIntegerFrom: stream			minDigits: 2			maxDigits: 2			acceptancePredicate: [:int :digitCount | int &lt; 60]			handleRejection: 					[:value :digitCount :rejectionReason | 					^self signalError: 'Minutes of longitude must have exactly and only two digits, and must be &lt; 60'].	lonSeconds := 		ChronosFunction 			nextUnsignedIntegerFrom: stream			minDigits: 0			maxDigits: 2			acceptancePredicate: [:int :digitCount | digitCount ~= 1 and: [int &lt; 60]]			handleRejection: 					[:value :digitCount :rejectionReason | 					^self signalError: 'Seconds of lattitude must have either two digits or none at all, and if present must be &lt; 60'].	^self 		lattitudeDegrees: latDegrees * latPolarity		minutes: latMinutes * latPolarity		seconds: latSeconds * latPolarity		longitudeDegrees: lonDegrees * lonPolarity		minutes: lonMinutes * lonPolarity		seconds: lonSeconds * lonPolarity</body></methods><methods><class-id>Chronos.IrregularCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Irregular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^calendarYear "For the typical Astronomical Calendar, every year is its own type code, since there is no finite set of year types."</body></methods><methods><class-id>Chronos.OrdinalNumberingPolicy</class-id> <category>API-conversion</category><body package="Chronos-Foundation" selector="canonicalFromCardinal:">canonicalFromCardinal: cardinal	^cardinal + 1</body><body package="Chronos-Foundation" selector="canonicalFromOrdinal:">canonicalFromOrdinal: ordinal	^ordinal</body><body package="Chronos-Foundation" selector="canonicalFromZerolessOrdinal:">canonicalFromZerolessOrdinal: zerolessOrdinal	^zerolessOrdinal &gt; 0 		ifTrue: [zerolessOrdinal]		ifFalse: [zerolessOrdinal &lt; 0 ifTrue: [zerolessOrdinal + 1] ifFalse: [self signalZeroInvalid]]</body><body package="Chronos-Foundation" selector="cardinalFromCanonical:">cardinalFromCanonical: canonical	^canonical - 1</body><body package="Chronos-Foundation" selector="ordinalFromCanonical:">ordinalFromCanonical: canonical	^canonical</body><body package="Chronos-Foundation" selector="zerolessOrdinalFromCanonical:">zerolessOrdinalFromCanonical: canonical	^canonical &gt; 0		ifTrue: [canonical]		ifFalse: [canonical - 1]</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>API-parsing</category><body package="Chronos-Parsing" selector="nextCalendarDurationFrom:usingFactory:">nextCalendarDurationFrom: stream usingFactory: calendarDurationFactory 	^self parseCalendarDurationFrom: stream		into: 			[:years :months :days | 			self 				newCalendarDurationUsing: calendarDurationFactory				years: years				months: months				days: days]</body><body package="Chronos-Parsing" selector="nextCivilDurationFrom:usingFactory:">nextCivilDurationFrom: stream usingFactory: civilDurationFactory 	^self parseCivilDurationFrom: stream		into:  			[:years :months :days :hours :minutes :seconds | 			self 				newCivilDurationUsing: civilDurationFactory				years: years				months: months				days: days				hours: hours 				minutes: minutes				seconds: seconds]</body><body package="Chronos-Parsing" selector="nextDateAndTimeFrom:usingFactory:">nextDateAndTimeFrom: stream usingFactory: dateAndTimeFactory 	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-Feb-29' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-02-29T13:30' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-060T13:30' readStream"	"ChronosParser ansiStandard nextDateAndTimeFrom: '2004-Feb-29 -0500' readStream"	"ChronosParser default nextDateAndTimeFrom: '2004-Feb-29' readStream"	"(ChronosParser applying: #(expectDayOfWeekName expectMDY setLocale: #'en_US')) beImmutable 		nextDateAndTimeFrom: 'Sunday, Feb 29 2004 5:30 pm PST' readStream"	"(ChronosParser applying: #(expectDayOfWeekName expectMDY setLocale: #'en_US')) beImmutable 		nextDateAndTimeFrom: 'Wed, Feb 29 2004' readStream"	"(ChronosParser applying: #(expectDayOfWeekName expectMDY setLocale: #'en_US')) beImmutable 		nextDateAndTimeFrom: 'Wednesday, Feb 29 2006 5:30 pm PST' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '20040229' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004060' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004-W09-7' readStream"	"ChronosParser iso8601 nextDateAndTimeFrom: '2004W097' readStream"	| dateAndTime dayOfWeeKey argArray |	dayOfWeeKey := expectDayOfWeekName ifTrue: [self parseDayOfWeekKeyFrom: stream ifNone: []].	argArray := Array new: 7.	self parseDateAndTimeFrom: stream into: argArray.	dateAndTime := 		self 			newDateAndTimeUsing: dateAndTimeFactory			year: (argArray at: 1)			month: (argArray at: 2)			day: (argArray at: 3)			hour: (argArray at: 5)			minute: (argArray at: 6)			second: (argArray at: 7)			timeZone: (argArray at: 4).	dayOfWeeKey == nil 		ifFalse: 			[dateAndTime dayOfWeekKey = dayOfWeeKey 				ifFalse: [self handleDayOfWeek: dayOfWeeKey inconsistentWithThatOf: dateAndTime]].	^dateAndTime</body><body package="Chronos-Parsing" selector="nextDateFrom:usingFactory:">nextDateFrom: stream usingFactory: dateFactory 	"ChronosParser default nextDateFrom: '2004-Feb-29' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-02-29' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-02-29-08:00' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-02-29 -0800' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-02-29 EST' readStream"	"ChronosParser iso8601 nextDateFrom: '20040229' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-060' readStream"	"ChronosParser iso8601 nextDateFrom: '2004-W09-7' readStream"	"ChronosParser iso8601 nextDateFrom: '2004W097' readStream"	"(ChronosParser applying: #(expectDayOfWeekName expectMDY)) beImmutable nextDateFrom: 'Sunday, Feb 29 2004' readStream"	"(ChronosParser applying: #(expectDayOfWeekName expectMDY)) beImmutable nextDateFrom: 'Wed, Feb 29 2004' readStream"	| dayOfWeeKey argArray date |	dayOfWeeKey := expectDayOfWeekName ifTrue: [self parseDayOfWeekKeyFrom: stream ifNone: []].	argArray := Array new: 4.	self 		parseDateFrom: stream		into: argArray.	date := 		self 			newDateUsing: dateFactory			year: (argArray at: 1)			month: (argArray at: 2)			day: (argArray at: 3)			timeZone: (argArray at: 4).	dayOfWeeKey == nil 		ifFalse: 			[date dayOfWeekKey = dayOfWeeKey 				ifFalse: [self handleDayOfWeek: dayOfWeeKey inconsistentWithThatOf: date]].	^date</body><body package="Chronos-Parsing" selector="nextDurationFrom:usingFactory:">nextDurationFrom: stream usingFactory: durationFactory 	^self parseDurationFrom: stream		into: 			[:days :hours :minutes :seconds | 			self 				newDurationUsing: durationFactory				days: days				hours: hours				minutes: minutes				seconds: seconds]</body><body package="Chronos-Parsing" selector="nextTimeOfDayFrom:usingFactory:">nextTimeOfDayFrom: stream usingFactory: timeOfDayFactory 	"ChronosParser default nextTimeOfDayFrom: '23:59:60' readStream"	"ChronosParser default nextTimeOfDayFrom: 'T00:00:00.000000001' readStream"	"ChronosParser default nextTimeOfDayFrom: '23:59:61' readStream"	^self parseTimeOfDayFrom: stream		into: 			[:hour :minute :second | 			self 				newTimeOfDayUsing: timeOfDayFactory				hour: hour				minute: minute				second: second]</body><body package="Chronos-Parsing" selector="nextTimeperiodFrom:usingFactory:">nextTimeperiodFrom: stream usingFactory: timeperiodFactory 	^self 		parseTimeperiodFrom: stream		startAndDurationInto: 			[:start :duration | 			self 				newTimeperiodUsing: timeperiodFactory				from: start				duration: duration]		startAndEndInto: 			[:start :end | 			self 				newTimeperiodUsing: timeperiodFactory				from: start				to: end]</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>initialize-release</category><body package="Chronos-Parsing" selector="initialize">initialize	super initialize.	self expectYMD.	self expectDateThenTime.	self doNotExpectDayOfWeekName.</body><body package="Chronos-Parsing" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	"ChronosParser iso8601 literalArrayEncoding decodeAsLiteralArray"	super initializeFromLiteralArray: literalArray.	expectDayOfWeekName := literalArray at: 20.	dateSyntax := literalArray at: 21.	dateAndTimeSyntax := literalArray at: 22.</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>configuration-dates</category><body package="Chronos-Parsing" selector="doNotExpectDayOfWeekName">doNotExpectDayOfWeekName	self assertMutability.	expectDayOfWeekName := false</body><body package="Chronos-Parsing" selector="expectDMY">expectDMY	self assertMutability.	dateSyntax := #parseDayMonthYearFrom:into:</body><body package="Chronos-Parsing" selector="expectDayOfWeekName">expectDayOfWeekName	self assertMutability.	expectDayOfWeekName := true</body><body package="Chronos-Parsing" selector="expectMDY">expectMDY	self assertMutability.	dateSyntax := #parseMonthDayYearFrom:into:</body><body package="Chronos-Parsing" selector="expectYDM">expectYDM	self assertMutability.	dateSyntax := #parseYearDayMonthFrom:into:</body><body package="Chronos-Parsing" selector="expectYMD">expectYMD	self assertMutability.	dateSyntax := #parseYearMonthDayFrom:into:</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>private</category><body package="Chronos-Parsing" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	"ChronosParser iso8601 literalArrayEncoding"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: expectDayOfWeekName;		nextPut: dateSyntax;		nextPut: dateAndTimeSyntax</body><body package="Chronos-Parsing" selector="parseCalendarDurationFrom:into:handleUnexpected:">parseCalendarDurationFrom: stream into: block3 handleUnexpected: unexpectedAction	| evaluator minIndex action years months days polarity |	ChronosFunction skipSeparators: stream.	stream atEnd ifTrue: [^nil].		years := 0.	months := 0.	days := 0.	polarity := 1.	action := Array new: 4.	action 		at: 1 put: [:value | minIndex := 2. years := value];		at: 2 put: [:value | minIndex := 3. months := value];		at: 3 put: [:value | minIndex := 4. days := value * 7];		at: 4 put: [:value | minIndex := nil. days := value].	minIndex := 1.	evaluator := 		[:value | 			| discriminant index | 			stream atEnd ifTrue: [self handleUnexpectedCharacter: nil for: 'CalendarDuration/CivilDuration'].			discriminant := stream next.			(minIndex = 1 and: [discriminant = $-])				ifTrue: 					[years := value.					action := nil. "Now we know the alternative 'combined' syntax is being used, so the element values cannot be negative, and the semantics of each element are determined by position, not by a discriminating tag that follows each element."					evaluator := 						[:value2 | 							months := value2.							(stream peekFor: $-) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'CalendarDuration/CivilDuration'].							evaluator := [:value3 | days := value3. minIndex := nil]]]				ifFalse:					[index := 						#($Y $M $W $D) 							indexOf: discriminant 							ifAbsent: 								[^unexpectedAction value: (Array with: years with: months with: days) value: value * polarity value: discriminant].					index &lt; minIndex ifTrue: [self handleUnexpectedCharacter: discriminant for: 'CalendarDuration/CivilDuration'].					(action at: index) value: value]].	(stream peekFor: $P) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'CalendarDuration/CivilDuration'].	[stream atEnd or: [(stream peekFor: $T) or: [minIndex == nil]]]		whileFalse:			[| value |			action == nil 				ifFalse: "Initially, we assume the alternative 'combined' syntax is not being used, so the element values might be negative."					[(stream peekFor: $-)						ifTrue: [polarity := -1]						ifFalse: [polarity := 1]].			value := UtilityFunction 						nextScaledDecimalFrom: stream  						minDigits: 1 maxDigits: nil						maxValue: nil 						handleRejection: [:vvv :digitCount :rejectionReason | 							self signalError: 'Invalid civil duration element: ', vvv printString, ' problem:', rejectionReason].			evaluator value: value * polarity].	^block3 value: years value: months value: days</body><body package="Chronos-Parsing" selector="parseCivilDurationFrom:years:months:days:value:discriminant:into:">parseCivilDurationFrom: stream years: years months: months days: days value: value discriminant: discriminant into: block6	| evaluator combinedSyntax minIndex action hours minutes seconds polarity args |	hours := 0.	minutes := 0.	seconds := 0.	polarity := 1.	action := Array new: 3.	action 		at: 1 put: [:v | minIndex := 2. hours := v];		at: 2 put: [:v | minIndex := 3. minutes := v ];		at: 3 put: [:v | minIndex := nil. seconds := v].	minIndex := 1.	combinedSyntax :=		[:v | hours := v.			action := nil. "Now we know the alternative 'combined' syntax is being used, so the element values cannot be negative, and the semantics of each element are determined by position, not by a discriminating tag that follows each element."			evaluator := 				[:value2 | 					minutes := value2.					(stream peekFor: $:) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'CivilDuration'].					evaluator := [:value3 | seconds := value3. minIndex := nil]]].	evaluator := 		[:v | 			| tag index | 			stream atEnd ifTrue: [self handleUnexpectedCharacter: nil for: 'CivilDuration'].			tag := stream next.			(minIndex = 1 and: [tag = $:])				ifTrue: [combinedSyntax value: v]				ifFalse:					[index := 						#($H $M $S) 							indexOf: tag 							ifAbsent: [self handleUnexpectedCharacter: tag for: 'CivilDuration'].					index &lt; minIndex ifTrue: [self handleUnexpectedCharacter: tag for: 'CivilDuration'].					(action at: index) value: v]].	value == nil 		ifFalse: 			[| index |			index := 				#($H $M $S $:) 					indexOf: discriminant 					ifAbsent: [self handleUnexpectedCharacter: discriminant for: 'CivilDuration'].			index &lt;= 3 				ifTrue: [(action at: index) value: value]				ifFalse: [combinedSyntax value: value]].	[stream atEnd or: [minIndex == nil]]		whileFalse:			[| v |			action == nil 				ifFalse: "Initially, we assume the alternative 'combined' syntax is not being used, so the element values might be negative."					[(stream peekFor: $-)						ifTrue: [polarity := -1]						ifFalse: [polarity := 1]].			v := UtilityFunction 					nextScaledDecimalFrom: stream  					minDigits: 1 maxDigits: nil					maxValue: nil 					handleRejection: [:vvv :digitCount :rejectionReason | 						minIndex &gt; 1							ifFalse: [self signalError: 'Invalid civil duration element: ', vvv printString, ' problem:', rejectionReason]].			v == nil				ifTrue: [minIndex := nil]				ifFalse: [evaluator value: v * polarity]].	args := Array new: 6.	args 		at: 1 put: years;		at: 2 put: months;		at: 3 put: days;		at: 4 put: hours;		at: 5 put: minutes;		at: 6 put: seconds.	^block6 valueWithArguments: args</body><body package="Chronos-Parsing" selector="parseScaledDecimalFrom:minDigits:maxDigits:maxValue:handleRejection:">parseScaledDecimalFrom: stream minDigits: minDigits maxDigits: maxDigits maxValue: maxValue handleRejection: handleRejection	"ConfigurableChronosParser new parseScaledDecimalFrom: '59' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '60' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '05' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '0' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '00.123' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '01.999999999' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '60.999999999' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '00.x' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: '61' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ConfigurableChronosParser new parseScaledDecimalFrom: 'x7' readStream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	| second |	second := 		ChronosFunction 			nextUnsignedIntegerFrom: stream			minDigits: minDigits			maxDigits: maxDigits			acceptancePredicate: [:int :digitCount | maxValue == nil or: [int &lt;= maxValue]]			handleRejection: [:value :count :rejectionReason | ^handleRejection value: value value: count value: rejectionReason].	((stream peekFor: $.) or: [stream peekFor: $,]) 		ifTrue: 			[| subSeconds |			subSeconds := 				ChronosFunction 					nextFrom: stream					while: [:ch | ch isDigit]					minChars: 0					maxChars: 99999999					onUnexpectedEOD: [:prefix :ch :position | ^handleRejection value: prefix value: 0 value: #notAnInteger].			subSeconds size &gt; 0 				ifTrue: 					[| scale denominator |					scale := subSeconds size.					denominator := 10 raisedToInteger: scale.					second := (ScaledDecimal  numerator: second * denominator + (Integer readFrom: subSeconds readStream) denominator: denominator scale: scale)]].	^second</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>configuration-dateAndTime</category><body package="Chronos-Parsing" selector="expectDateThenTime">expectDateThenTime	self assertMutability.	dateAndTimeSyntax := #parseDateThenTimeFrom:into:</body><body package="Chronos-Parsing" selector="expectTimeThenDate">expectTimeThenDate	self assertMutability.	dateAndTimeSyntax := #parseTimeThenDateFrom:into:</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-dates-elements</category><body package="Chronos-Parsing" selector="parseDayOfMonthFrom:maxDigits:handleRejection:">parseDayOfMonthFrom: stream maxDigits: maxDigits handleRejection: handleRejection	"ChronosParser default parseDayOfMonthFrom: '31' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseDayOfMonthFrom: '5' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseDayOfMonthFrom: '0' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseDayOfMonthFrom: '32' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseDayOfMonthFrom: '1997' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseDayOfMonthFrom: '31121997' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseDayOfMonthFrom: 'x7' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	^ChronosFunction 		nextUnsignedIntegerFrom: stream		minDigits: 1 		maxDigits: maxDigits		acceptancePredicate: 			[:int :digitCount | 				digitCount &lt; 3]		handleRejection: 			[:value :digitCount :rejectionReason | 				((#(#streamAtEnd notAnInteger) includes: rejectionReason) or: [digitCount &lt;= maxDigits and: [digitCount = 4]])					ifTrue: [handleRejection value: value value: digitCount value: rejectionReason]					ifFalse:						[stream skip: 2.						value // (10 raisedToInteger: digitCount - 2)]]</body><body package="Chronos-Parsing" selector="parseDayOfWeekKeyFrom:ifNone:">parseDayOfWeekKeyFrom: stream ifNone: noneBlock 	"ChronosParser default 		parseDayOfWeekKeyFrom: ' Monday, May' readStream ifNone: []"	"ChronosParser default 		parseDayOfWeekKeyFrom: ' May 30, 1932' readStream ifNone: []"	| dowResult dayOfWeekKey |	stream atEnd ifTrue: [^noneBlock value].	dowResult := 		self 			parseOptionalTokenFrom: stream			prefixPredicate: [:ch | ch isSeparator]			tokenPredicate: 				[:ch :count | ch isLetter]			minChars: minDayOfWeekNameSize			maxChars: maxDayOfWeekNameSize			acceptancePredicate: 				[:name | | canonicalNameForm |				canonicalNameForm := name asUppercase.				(dayOfWeekKey := dayOfWeekKeysByAbbreviation at: canonicalNameForm					ifAbsent: [dayOfWeekKeysByName at: canonicalNameForm ifAbsent: []]) notNil].	^dowResult key 		ifTrue: [dayOfWeekKey]		ifFalse: [noneBlock value]</body><body package="Chronos-Parsing" selector="parseIsoDayOfWeekFrom:handleRejection:">parseIsoDayOfWeekFrom: stream handleRejection: handleRejection	"ChronosParser new parseIsoDayOfWeekFrom: '1' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoDayOfWeekFrom: '5' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoDayOfWeekFrom: '7' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoDayOfWeekFrom: '53' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoDayOfWeekFrom: 'x7' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	^ChronosFunction 		nextUnsignedIntegerFrom: stream		minDigits: 1		maxDigits: 2		acceptancePredicate: [:int :digitCount | digitCount &lt; 2]		handleRejection: handleRejection</body><body package="Chronos-Parsing" selector="parseIsoWeekOfYearFrom:handleRejection:">parseIsoWeekOfYearFrom: stream handleRejection: handleRejection 	"ChronosParser new parseIsoWeekOfYearFrom: '23' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoWeekOfYearFrom: '5' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoWeekOfYearFrom: '0' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoWeekOfYearFrom: '532' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	"ChronosParser new parseIsoWeekOfYearFrom: 'x7' readStream handleRejection: [:value :digitCount :problem | problem-&gt;(Array with: value with: digitCount)]"	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	^(stream peekFor: $W) 		ifTrue: 			[ChronosFunction 				nextUnsignedIntegerFrom: stream				minDigits: 2				maxDigits: 2				acceptancePredicate: [:int :digitCount | true]				handleRejection: handleRejection]		ifFalse: [handleRejection value: nil value: 0 value: #syntaxInvalid ]</body><body package="Chronos-Parsing" selector="parseMonthFrom:maxDigits:handleRejection:">parseMonthFrom: stream maxDigits: maxDigits handleRejection: handleRejection	"ChronosParser rfc2822 parseMonthFrom: '12' readStream maxDigits: 2 handleRejection: [:month :count :problem | month-&gt;problem]"	"ChronosParser rfc2822 parseMonthFrom: 'Aug' readStream maxDigits: 2 handleRejection: [:month :count :problem | month-&gt;problem]"	"ChronosParser rfc2822 parseMonthFrom: '5' readStream maxDigits: 2 handleRejection: [:month :problem | month-&gt;problem]"	"ChronosParser rfc2822 parseMonthFrom: 'January' readStream maxDigits: 2 handleRejection: [:month :count :problem | month-&gt;problem]"	"ChronosParser rfc2822 parseMonthFrom: '0' readStream maxDigits: 2 handleRejection: [:month :count :problem | month-&gt;problem]"	"ChronosParser rfc2822 parseMonthFrom: '24' readStream maxDigits: 2 handleRejection: [:month :count :problem | month-&gt;problem]"	"ChronosParser rfc2822 parseMonthFrom: '1224' readStream maxDigits: 2 handleRejection: [:month :count :problem | month-&gt;problem]"	"ChronosParser rfc2822 parseMonthFrom: 'x7' readStream maxDigits: 2 handleRejection: [:month :count :problem | month-&gt;problem]"	| monthNumber |	monthNumber :=		self 			parseMonthNumberFrom: stream			maxDigits: maxDigits 			handleRejection:				[:value :digitCount :rejectionReason | 				^rejectionReason == #notAnInteger					ifTrue: 						[(self 							parseMonthNameKeyByNameOrAbbreviationFrom: stream 							handleRejection: handleRejection)]					ifFalse: 						[(digitCount &lt;= maxDigits)							ifTrue: 								[digitCount &gt; 4									ifTrue: 										[stream skip: 2.										value // (10 raisedTo: digitCount - 2)]									ifFalse: [handleRejection value: value value: digitCount value: rejectionReason]]							ifFalse: [handleRejection value: value value: digitCount value: rejectionReason]]].	^monthNumber</body><body package="Chronos-Parsing" selector="parseMonthNameKeyByNameOrAbbreviationFrom:handleRejection:">parseMonthNameKeyByNameOrAbbreviationFrom: stream handleRejection: handleRejection	"ChronosParser rfc2822 parseMonthNameKeyByNameOrAbbreviationFrom: 'Aug' readStream 		handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser rfc2822 parseMonthNameKeyByNameOrAbbreviationFrom: 'September' readStream 		handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser rfc2822 parseMonthNameKeyByNameOrAbbreviationFrom: 'Ju' readStream 		handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser rfc2822 parseMonthNameKeyByNameOrAbbreviationFrom: 'abcdefjhijkl' readStream 		handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser rfc2822 parseMonthNameKeyByNameOrAbbreviationFrom: '12' readStream 		handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	| nameOrAbbreviation canonicalNameForm|	nameOrAbbreviation := 		self 			parseMonthNameOrAbbreviationFrom: stream			unexpectedEODAction: [:prefix :ch :count | ^handleRejection value: prefix value: count value: #unknownMonthName].	canonicalNameForm := nameOrAbbreviation asUppercase.	^monthNameKeysByMonthAbbreviation 		at: canonicalNameForm		ifAbsent: [monthNameKeysByMonthName at: canonicalNameForm ifAbsent: [handleRejection value: nameOrAbbreviation value: nameOrAbbreviation size value: #unknownMonthName]]</body><body package="Chronos-Parsing" selector="parseMonthNameOrAbbreviationFrom:unexpectedEODAction:">parseMonthNameOrAbbreviationFrom: stream unexpectedEODAction: unexpectedEODAction 	"ChronosParser rfc2822 parseMonthNameOrAbbreviationFrom: 'Aug 12' readStream unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser rfc2822 parseMonthNameOrAbbreviationFrom: 'September 15' readStream unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser rfc2822 parseMonthNameOrAbbreviationFrom: 'Adar Rishon ' readStream unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser rfc2822 parseMonthNameOrAbbreviationFrom: 'Ju ' readStream unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser rfc2822 parseMonthNameOrAbbreviationFrom: 'abcdefjhijkl ' readStream unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser rfc2822 parseMonthNameOrAbbreviationFrom: '12 ' readStream unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	| name component appendSpace |	appendSpace := false.	name :=  (String new: 9) writeStream.	[component := 			ChronosFunction 				nextFrom: stream				while: [:ch | ch isLetter]				minChars: minMonthNameSize				maxChars: maxMonthNameSize				onUnexpectedEOD: 					[:prefix :ch :position | 						^name position &gt; 0 							ifTrue: [name contents] 							ifFalse: [unexpectedEODAction value: prefix value: ch value: position]].	appendSpace ifTrue: [name space].	name nextPutAll: component.	stream atEnd ifTrue: [false] ifFalse: [stream peek isSeparator]] 			whileTrue: 				[appendSpace := true.				ChronosFunction skipSeparators: stream].	^name contents</body><body package="Chronos-Parsing" selector="parseMonthNumberFrom:maxDigits:handleRejection:">parseMonthNumberFrom: stream maxDigits: maxDigits handleRejection: handleRejection	"ChronosParser default parseMonthNumberFrom: '12' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseMonthNumberFrom: '5' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseMonthNumberFrom: '0' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseMonthNumberFrom: '24' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseMonthNumberFrom: 'x7' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	^ChronosFunction 		nextUnsignedIntegerFrom: stream		minDigits: 1 		maxDigits: maxDigits		acceptancePredicate: 			[:int :digitCount | 			digitCount &lt; 3]		handleRejection: handleRejection</body><body package="Chronos-Parsing" selector="parseYearFrom:handleRejection:">parseYearFrom: stream handleRejection: handleRejection 	"ChronosParser default parseYearFrom: '2006' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser default parseYearFrom: '-86' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	| isNegative year |	ChronosFunction skipSeparators: stream.	isNegative := stream peekFor: $-.	year := ChronosFunction 				nextUnsignedIntegerFrom: stream				minDigits: 1				maxDigits: 4				acceptancePredicate: [:int :digitCount | true]				handleRejection: [:value :digitCount :rejectionReason | ^handleRejection value: value value: digitCount value: rejectionReason].	^isNegative ifTrue: [year negated] ifFalse: [year]</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-timeOfDay-elements</category><body package="Chronos-Parsing" selector="parseHourOfDayFrom:handleRejection:">parseHourOfDayFrom: stream handleRejection: handleRejection	"ChronosParser new parseHourOfDayFrom: '23' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseHourOfDayFrom: '5' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseHourOfDayFrom: '0' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseHourOfDayFrom: '32' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseHourOfDayFrom: 'x7' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	^ChronosFunction 		nextUnsignedIntegerFrom: stream		minDigits: 1		maxDigits: 2		acceptancePredicate: [:int :digitCount | true]		handleRejection: handleRejection</body><body package="Chronos-Parsing" selector="parseMeridianKeyFrom:ifNone:">parseMeridianKeyFrom: stream ifNone: noneBlock 	"| stream result |	stream := ' pm-0800' readStream.	result := ChronosParser default 				parseMeridianKeyFrom: stream ifNone: [#notAMeridianName].	Array with: result with: stream upToEnd"	"ChronosParser default 		parseMeridianKeyFrom: ' AM PST' readStream ifNone: [#notAMeridianName]"	"| stream result |	stream := ' EST' readStream.	result := ChronosParser default 				parseMeridianKeyFrom: stream ifNone: [#notAMeridianName].	Array with: result with: stream upToEnd"	"ChronosParser default 		parseMeridianKeyFrom: ' America/Chicago' readStream ifNone: [#notAMeridianName]"	| meridianResult meridianIndex endedByNonAlpha |	stream atEnd ifTrue: [^noneBlock value].	endedByNonAlpha := true.	meridianResult := 		self 			parseOptionalTokenFrom: stream			prefixPredicate: [:ch | ch isSeparator]			tokenPredicate: 				[:ch :count | count &lt;= maxMeridianNameSize ifTrue: [meridianNameCharSet includes: ch] ifFalse: [endedByNonAlpha := ch isLetter not. false]]			minChars: minMeridianNameSize			maxChars: maxMeridianNameSize + 1			acceptancePredicate: 				[:name | | canonicalNameForm |				endedByNonAlpha					ifTrue:						[canonicalNameForm := name asUppercase asSymbol.						meridianIndex := meridianNames indexOf: canonicalNameForm ifAbsent: [0].						meridianIndex &gt; 0]					ifFalse: [false]].	^meridianResult key 		ifTrue: [MeridianKeys at: meridianIndex]		ifFalse: [noneBlock value]</body><body package="Chronos-Parsing" selector="parseMinuteOfHourFrom:handleRejection:">parseMinuteOfHourFrom: stream handleRejection: handleRejection	"ChronosParser new parseMinuteOfHourFrom: '59' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseMinuteOfHourFrom: '05' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseMinuteOfHourFrom: '0' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseMinuteOfHourFrom: '60' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	"ChronosParser new parseMinuteOfHourFrom: 'x7' readStream handleRejection: [:value :digitCount :rejectionReason | rejectionReason -&gt; (Array with: value with: digitCount)]"	^ChronosFunction 		nextUnsignedIntegerFrom: stream		minDigits: 2		maxDigits: 2		acceptancePredicate: [:int :digitCount | true]		handleRejection: handleRejection</body><body package="Chronos-Parsing" selector="parseSecondOfMinuteFrom:handleRejection:">parseSecondOfMinuteFrom: stream handleRejection: handleRejection	^UtilityFunction nextScaledDecimalFrom: stream minDigits: 2 maxDigits: 2 maxValue: 60 handleRejection: handleRejection</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-durations</category><body package="Chronos-Parsing" selector="parseCalendarDurationFrom:into:">parseCalendarDurationFrom: stream into: block3 	^self 		parseCalendarDurationFrom: stream		into: block3		handleUnexpected: 			[:ymdArray :value :ch | 				self 					handleUnexpectedCharacter: ch					for: 'CalendarDuration/CivilDuration']</body><body package="Chronos-Parsing" selector="parseCivilDurationFrom:into:">parseCivilDurationFrom: stream into: block6 	^self 		parseCalendarDurationFrom: stream		into: [:years :months :days | 				self 					parseCivilDurationFrom: stream					years: years					months: months					days: days					value: nil					discriminant: nil					into: block6]		handleUnexpected: 			[:ymdArray :value :discriminant | 				self 					parseCivilDurationFrom: stream					years: (ymdArray at: 1)					months: (ymdArray at: 2)					days: (ymdArray at: 3)					value: value					discriminant: discriminant					into: block6]</body><body package="Chronos-Parsing" selector="parseDurationFrom:into:">parseDurationFrom: stream into: block4 	| days hours minutes seconds polarity duration |	ChronosFunction skipOver: stream		until: [:ch | ch isAlphaNumeric or: [#($- $+) includes: ch]].	stream atEnd ifTrue: [^nil].		polarity := (stream peekFor: $-) ifTrue: [-1] ifFalse: [1].	days := UtilityFunction 				nextScaledDecimalFrom: stream 				minDigits: 1 maxDigits: nil				maxValue: nil 				handleRejection: [:value :digitCount :rejectionReason | 					self 						handleInvalidDays: value						digitCount: digitCount						problemKey: rejectionReason].	(stream peekFor: $:) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'Duration'].	hours := UtilityFunction 					nextScaledDecimalFrom: stream 					minDigits: 2 maxDigits: 2					maxValue: 23 					handleRejection: [:value :digitCount :rejectionReason | 						self 							handleInvalidHour: value							digitCount: digitCount							problemKey: rejectionReason].	(stream peekFor: $:) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'Duration'].	minutes := UtilityFunction 					nextScaledDecimalFrom: stream 					minDigits: 2 maxDigits: 2					maxValue: 59 					handleRejection: [:value :digitCount :rejectionReason | 						self 							handleInvalidMinute: value							digitCount: digitCount							problemKey: rejectionReason].	(stream peekFor: $:) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'Duration'].	seconds := UtilityFunction 					nextScaledDecimalFrom: stream 					minDigits: 2 maxDigits: 2					maxValue: 59 					handleRejection: [:value :digitCount :rejectionReason | 						self 							handleInvalidSecond: value							digitCount: digitCount							problemKey: rejectionReason].	duration := block4 valueWithArguments: (Array with: days with: hours with: minutes with: seconds).	^polarity &gt; 0 ifTrue: [duration] ifFalse: [duration negated]</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-time zone</category><body package="Chronos-Parsing" selector="parseTimeZoneFrom:ifNone:">parseTimeZoneFrom: stream ifNone: noneBlock	"ChronosParser default 		parseTimeZoneFrom: '+05:30' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: 'Australia/Adelaide' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: '-08:00' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: 'PST' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: 'EDT' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: '+01' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: '+10:45:30.5' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: '+0300' readStream ifNone: []"	"ChronosParser default 		parseTimeZoneFrom: ' am Don''t be late!' readStream ifNone: []"	| offset zoneResult zone |	ChronosFunction skipSeparators: stream.	stream atEnd ifTrue: [^noneBlock value].	offset := 		self 			parseTimeZoneOffsetFrom: stream			unexpectedEODAction: 				[:prefix :ch :position | 					(ChronosFunction isNilOrEmpty: prefix) 						ifFalse: [^noneBlock value]].	offset == nil ifFalse: [^offset asTimezone].	zoneResult := 		self 			parseOptionalTokenFrom: stream			prefixPredicate: [:ch | ch isSeparator] 			tokenPredicate: [:ch :count | count &lt;= 3 ifTrue: [ch isLetter] ifFalse: [(#($/ $_) includes: ch) or: [ch isLetter]]] 			minChars: 1 			maxChars: 80 			acceptancePredicate: [:name | (zone := self timeZoneWithNameOrAbbreviation: name ifNone: []) notNil].	^zoneResult key		ifTrue: [zone]		ifFalse: [noneBlock value]</body><body package="Chronos-Parsing" selector="parseTimeZoneOffsetFrom:unexpectedEODAction:">parseTimeZoneOffsetFrom: stream unexpectedEODAction: unexpectedEODAction 	"ChronosParser default 		parseTimeZoneOffsetFrom: '+05:30' readStream 		unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser default 		parseTimeZoneOffsetFrom: '-08:00' readStream 		unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser default 		parseTimeZoneOffsetFrom: '+01' readStream 		unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser default 		parseTimeZoneOffsetFrom: '+10:45:30.5' readStream 		unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	"ChronosParser default 		parseTimeZoneOffsetFrom: '+0300' readStream 		unexpectedEODAction: [:prefix :ch :position | prefix-&gt;(Array with: ch with: position)]"	| polarity hours minutes seconds |	(#($- $+) includes: (polarity := stream peek)) 		ifFalse: [^unexpectedEODAction value: nil value: polarity value: stream position].	stream next.	polarity := polarity = $+ ifTrue: [1] ifFalse: [-1].	hours := self parseHourOfDayFrom: stream handleRejection: [:value :digitCount :rejectionReason | self handleInvalidHour: value digitCount: digitCount problemKey: rejectionReason].	stream peekFor: $:.	minutes := 		self parseMinuteOfHourFrom: stream 			handleRejection: [:value :digitCount :rejectionReason | 						digitCount = 0 ifTrue: [0] ifFalse: [self handleInvalidMinute: value digitCount: digitCount problemKey: rejectionReason]].	stream peekFor: $:.	seconds := 		self parseSecondOfMinuteFrom: stream			handleRejection: [:value :digitCount :rejectionReason | 						digitCount = 0 ifTrue: [0] ifFalse: [self handleInvalidSecond: value digitCount: digitCount problemKey: rejectionReason]].	^self 		newDurationUsing: self defaultDurationFactory 		days: 0		hours: hours * polarity		minutes: minutes * polarity		seconds: seconds * polarity</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-timeperiods</category><body package="Chronos-Parsing" selector="parseTimeperiodFrom:startAndDurationInto:startAndEndInto:">parseTimeperiodFrom: stream startAndDurationInto: startWithDuration startAndEndInto: startToEnd	| start duration end |	ChronosFunction skipSeparators: stream.	stream atEnd ifTrue: [^nil].	^stream peek = $P		ifTrue: 			[duration := self nextCivilDurationFrom: stream.			(stream peekFor: $/) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'Timeperiod separator'].			end := self nextDateAndTimeFrom: stream.				startWithDuration value: end - duration value: duration]		ifFalse: 			[start := self nextDateAndTimeFrom: stream.			(stream peekFor: $/) ifFalse: [self handleUnexpectedCharacter: stream peek for: 'Timeperiod separator'].			(stream peek = $P)				ifTrue: [startWithDuration value: start value: (self nextCivilDurationFrom: stream)]				ifFalse: 					[| mark |					mark := stream position.					ChronosFunction skipOver: stream while: [:ch | ch isDigit].					stream peek = $: "Check for ANSI-Smalltalk Duration syntax"						ifTrue:							["It's probably an ANSI-Smalltalk Duration"							stream skip: mark - stream position.							startWithDuration value: start value: (self nextDurationFrom: stream)]						ifFalse: 							["It's NOT an ANSI-Smalltalk Duration, so it must be a DateAndTime"							stream skip: mark - stream position.							startToEnd value: start value: (self nextDateAndTimeFrom: stream)]]].</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-timeOfDay</category><body package="Chronos-Parsing" selector="parseTimeOfDayFrom:into:">parseTimeOfDayFrom: stream into: block3 	"ChronosParser default parseTimeOfDayFrom: '23:59:60 CST' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '235960-06:00' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '23:59+0530' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '11:59 am' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '11:59 PM' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '11:59pm-0400' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '23:59 AM' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]" "Code assumes there is no meridian name if hour &gt; 12"	"ChronosParser default parseTimeOfDayFrom: '23:59 PM' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]" "Code assumes there is no meridian name if hour &gt; 12"	"ChronosParser default parseTimeOfDayFrom: '12:59 am' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]" 	"ChronosParser default parseTimeOfDayFrom: '24:00' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]" 	"ChronosParser default parseTimeOfDayFrom: '23h59 Europe/Paris' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '23:7x' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	"ChronosParser default parseTimeOfDayFrom: '23:59:0 ' readStream into: [:hour :minute :second | Array with: hour with: minute with: second]"	| hour minute second count meridianKey |	ChronosFunction skipOver: stream		until: [:ch | ch isAlphaNumeric or: [#($- $+) includes: ch]].	stream atEnd ifTrue: [^nil].		(#($T $t) includes: stream peek) ifTrue: [stream next].	hour := self parseHourOfDayFrom: stream				handleRejection: 					[:value :digitCount :rejectionReason | 					self 						handleInvalidHour: value						digitCount: digitCount						problemKey: rejectionReason].	count := 0.	ChronosFunction skipOver: stream		while: 			[:ch | 			count := count + 1.			count &lt; 2 and: [#($: $h $H $.) includes: ch]].	minute := self parseMinuteOfHourFrom: stream				handleRejection: 					[:value :digitCount :rejectionReason | 					digitCount = 0 						ifFalse: 							[self 								handleInvalidMinute: value								digitCount: digitCount								problemKey: rejectionReason]].	count := 0.	ChronosFunction skipOver: stream		while: 			[:ch | 			count := count + 1.			count &lt; 2 and: [#($: $m $M $.) includes: ch]].	second := self parseSecondOfMinuteFrom: stream				handleRejection: 					[:value :digitCount :rejectionReason | 					digitCount = 0 						ifFalse: 							[self 								handleInvalidSecond: value								digitCount: digitCount								problemKey: rejectionReason]].	hour &lt;= 12 		ifTrue: [meridianKey := self parseMeridianKeyFrom: stream ifNone: []].	^block3 		value: (meridianKey == #'post-meridian' 				ifTrue: [hour &lt; 12 ifTrue: [hour + 12] ifFalse: [hour]]				ifFalse: 					[meridianKey == #'ante-meridian' 						ifTrue: [hour &lt; 12 ifTrue: [hour] ifFalse: [0]]						ifFalse: [hour]])		value: minute		value: second</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-dateAndTime</category><body package="Chronos-Parsing" selector="parseDateAndTimeFrom:into:">parseDateAndTimeFrom: stream into: ymdTzhmsArray 	^self 		perform: dateAndTimeSyntax		with: stream		with: ymdTzhmsArray</body><body package="Chronos-Parsing" selector="parseDateThenTimeFrom:into:">parseDateThenTimeFrom: stream into: ymdTzhmsArray 	"ChronosParser default 		parseDateThenTimeFrom: Timepoint now printString readStream		into: (Array new: 7)"	"ChronosParser default 		parseDateThenTimeFrom: '1970-01-01T00:00:00 UTC' readStream		into: (Array new: 7)"	"ChronosParser default 		parseDateThenTimeFrom: '1970-01-01T00:00:00Z' readStream		into: (Array new: 7)"	"ChronosParser default 		parseDateThenTimeFrom: '2006-02-12T18:15:33.333+05:30' readStream		into: (Array new: 7)"	"ChronosParser default 		parseDateThenTimeFrom: '2006-02-12T18:15:33.333 EST' readStream		into: (Array new: 7)"	"ChronosParser default 		parseDateThenTimeFrom: '2004-02-29 was a leap day...' readStream		into: (Array new: 7)"	"ChronosParser default 		parseDateThenTimeFrom: '2004-02-29-0700' readStream		into: (Array new: 7)"	| count resetPosition endOfData tz |	self parseDateFrom: stream into: ymdTzhmsArray.	stream atEnd ifTrue: [^ymdTzhmsArray].	stream peek = $/ ifTrue: [^ymdTzhmsArray].	tz := ymdTzhmsArray at: 4.	tz isInvariantToNominalTime ifFalse: [^ymdTzhmsArray].	count := 0.	resetPosition := stream position.	endOfData := false.	ChronosFunction 		skipOver: stream 		until: [:ch | 				ch isLetter ifTrue: [count := count + 1]. 				endOfData := count &gt; 2. 				endOfData or: [ch isDigit or: [timeZoneSeparators includes: ch]]].	endOfData ifTrue: [stream skip: resetPosition - stream position].	ChronosFunction skipSeparators: stream.	stream atEnd ifTrue: [^ymdTzhmsArray].	(stream peek isDigit)		ifTrue:  [self parseTimeOfDayFrom: stream into: [:hour :minute :second | ymdTzhmsArray at: 5 put: hour; at: 6 put: minute; at: 7 put: second]].	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric or: [timeZoneSeparators includes: ch]].	stream atEnd ifTrue: [^ymdTzhmsArray].	ymdTzhmsArray		at: 4		put: (self parseTimeZoneFrom: stream ifNone: [self defaultTimeZone]).	^ymdTzhmsArray</body><body package="Chronos-Parsing" selector="parseTimeThenDateFrom:into:">parseTimeThenDateFrom: stream into: ymdTzhmsArray	"ChronosParser default 		parseTimeThenDateFrom: (Timepoint now % #(useTimeBeforeDateOrder dateAndTimeSeparator: ' @ ')) readStream		into: (Array new: 7)"	"ChronosParser default 		parseTimeThenDateFrom: '00:00:00 1970-01-01 UTC' readStream		into: (Array new: 7)"	"ChronosParser default 		parseTimeThenDateFrom: 'T00:00:00 1970-01-01Z' readStream		into: (Array new: 7)"	"ChronosParser default 		parseTimeThenDateFrom: '18:15:33.333 2006-02-12+05:30' readStream		into: (Array new: 7)"	"ChronosParser default 		parseTimeThenDateFrom: '18:15:33.333//2006-02-12 EST' readStream		into: (Array new: 7)"	"ChronosParser default 		parseTimeThenDateFrom: '10:00 2004-02-29 scheduled arrival' readStream		into: (Array new: 7)"	| endOfData |	self parseTimeOfDayFrom: stream into:  [:hour :minute :second |  ymdTzhmsArray at: 5 put: hour; at: 6 put: minute; at: 7 put: second].	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	endOfData := stream atEnd.	endOfData ifFalse: [self  parseDateFrom: stream into: ymdTzhmsArray].	^ymdTzhmsArray</body></methods><methods><class-id>Chronos.ConfigurableChronosParser</class-id> <category>parsing-dates</category><body package="Chronos-Parsing" selector="parseDateFrom:into:">parseDateFrom: stream into: ymdTzArray	ymdTzArray at: 4 put: ChronosTimezone nominal.	self 		perform: dateSyntax		with: stream		with: ymdTzArray.	stream atEnd ifTrue: [^ymdTzArray].	stream peek = $/ ifTrue: [^ymdTzArray].	ymdTzArray at: 4 put: (self parseTimeZoneFrom: stream ifNone: [^ymdTzArray]).	^ymdTzArray</body><body package="Chronos-Parsing" selector="parseDayMonthYearFrom:into:">parseDayMonthYearFrom: stream into: ymdTzArray 	"ChronosParser default parseDayMonthYearFrom: '29 February 2008' readStream into: (Array new: 4)"	"ChronosParser default parseDayMonthYearFrom: '1.2.96' readStream into: (Array new: 4)"	"ChronosParser default parseDayMonthYearFrom: '29021987' readStream into: (Array new: 4)"	"ChronosParser default parseDayMonthYearFrom: '1987-02-29' readStream into: (Array new: 4)"	"ChronosParser default parseDayMonthYearFrom: 'Aug 6, 1945' readStream into: (Array new: 4)"	| year monthSpec day |	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	stream atEnd ifTrue: [^nil].		day := self 				parseDayOfMonthFrom: stream				maxDigits: 8				handleRejection: 					[:value :digitCount :rejectionReason | 					digitCount = 4 ifTrue: [^self parseYearMonthDayFrom: stream into: ymdTzArray ].					rejectionReason == #notAnInteger 						ifTrue: [^self parseMonthDayYearFrom: stream into: ymdTzArray]						ifFalse: [self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]].	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	monthSpec := self parseMonthFrom: stream maxDigits: 2 handleRejection: [:month :count :problem | self handleInvalidMonth: month problemKey: problem].	ChronosFunction skipOver: stream until: [:ch | ch isDigit].	year := self 				parseYearFrom: stream				handleRejection: [:value :digitCount :rejectionReason | self handleInvalidYear: value digitCount: digitCount problemKey: rejectionReason].	ymdTzArray 		at: 1 put: year;		at: 2 put: monthSpec;		at: 3 put: day.	^ymdTzArray</body><body package="Chronos-Parsing" selector="parseMonthDayYearFrom:into:">parseMonthDayYearFrom: stream into: ymdTzArray	"ChronosParser default parseMonthDayYearFrom: '2/29/2008' readStream into: (Array new: 4)"	"ChronosParser default parseMonthDayYearFrom: '02291987' readStream into: (Array new: 4)"	"ChronosParser default parseDayMonthYearFrom: '1987-02-29' readStream into: (Array new: 4)"	"ChronosParser default parseMonthDayYearFrom: 'Feb2996' readStream into: (Array new: 4)"	"ChronosParser default parseMonthDayYearFrom: 'Aug 6, 1945' readStream into: (Array new: 4)"	"ChronosParser default parseMonthDayYearFrom: '6 Aug 1945' readStream into: (Array new: 4)"	| year monthSpec day |	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	stream atEnd ifTrue: [^nil].		monthSpec := 		self 			parseMonthFrom: stream 			maxDigits: 8 			handleRejection: [:month :count :problem | count = 4 ifTrue: [^self parseYearMonthDayFrom: stream into: ymdTzArray] ifFalse: [self handleInvalidMonth: month problemKey: problem]].	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	day := self 			parseDayOfMonthFrom: stream			maxDigits: 2			handleRejection: 				[:value :digitCount :rejectionReason | 				digitCount &gt; 0 					ifTrue:  [self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]					ifFalse: 						[rejectionReason == #notAnInteger 							ifTrue: 								[monthSpec isInteger									ifTrue: 										[| dayOfMonth | 										dayOfMonth := monthSpec.										monthSpec := self parseMonthFrom: stream maxDigits: 2 handleRejection: [:month :count :problem | self handleInvalidMonth: month problem: problem].										dayOfMonth]									ifFalse: [self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]]							ifFalse:  [self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]]].	ChronosFunction skipOver: stream until: [:ch | ch isDigit].	year := self 				parseYearFrom: stream 				handleRejection: [:value :digitCount :rejectionReason | self handleInvalidYear: value digitCount: digitCount problemKey: rejectionReason].	ymdTzArray 		at: 1 put: year;		at: 2 put: monthSpec;		at: 3 put: day.	^ymdTzArray</body><body package="Chronos-Parsing" selector="parseYearDayMonthFrom:into:">parseYearDayMonthFrom: stream into: ymdTzArray 	"ChronosParser default parseYearDayMonthFrom: '2008, 29 February' readStream into: (Array new: 4)"	"ChronosParser default parseYearDayMonthFrom: '19872902' readStream into: (Array new: 4)"	"ChronosParser default parseYearDayMonthFrom: '19870229' readStream into: (Array new: 4)"	"ChronosParser default parseYearDayMonthFrom: '96-2902' readStream into: (Array new: 4)"	"ChronosParser default parseYearDayMonthFrom: 'Aug 6, 1945' readStream into: (Array new: 4) "	"ChronosParser default parseYearDayMonthFrom: '1945 Aug 6' readStream into: (Array new: 4)"	| year monthSpec day month |	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	stream atEnd ifTrue: [^nil].		year := self 				parseYearFrom: stream 				handleRejection: 					[:value :digitCount :rejectionReason |					rejectionReason == #notAnInteger 						ifTrue: [^self parseMonthDayYearFrom: stream into: ymdTzArray]						ifFalse: [self handleInvalidYear: value digitCount: digitCount problemKey: rejectionReason]].	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	day := self 			parseDayOfMonthFrom: stream			maxDigits: 2			handleRejection: 				[:value :digitCount :rejectionReason | 				rejectionReason == #notAnInteger 					ifTrue: 						[monthSpec := self parseMonthFrom: stream maxDigits: 2 handleRejection: [:m :count :problem | self handleInvalidMonth: m problemKey: problem].						ChronosFunction skipOver: stream until: [:ch2 | ch2 isDigit].						self 							parseDayOfMonthFrom: stream							maxDigits: 2							handleRejection: [:value2 :digitCounts :rejectionReasons | self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]]					ifFalse:  [self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]].	monthSpec == nil		ifTrue: 			[ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].			monthSpec := 				self 					parseMonthFrom: stream 					maxDigits: 4 					handleRejection: [:m :count :problem | 						(problem == #notAccepted and: [year between: 1 and: calendar maxDaysPerMonth])							ifTrue: 								[month := year.								year := m.								month &gt; calendar maxMonthsPerYear									ifTrue: 											[| swap |										swap := month. 										month := day.										day := swap]. 								monthSpec := month]							ifFalse: [self handleInvalidMonth: m problemKey: problem]]].	month := monthSpec.	month isInteger		ifTrue: 			[(month &gt; calendar maxMonthsPerYear)				ifTrue: 					[month &lt;= calendar maxDaysPerMonth						ifTrue: 							[monthSpec := day.							day := month]]].	ymdTzArray 		at: 1 put: year;		at: 2 put: monthSpec;		at: 3 put: day.	^ymdTzArray</body><body package="Chronos-Parsing" selector="parseYearMonthDayFrom:into:">parseYearMonthDayFrom: stream into: ymdTzArray	"ChronosParser default parseYearMonthDayFrom: '2008-02-29' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '19870229' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '2/14/1987' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '2/12/1987' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '96Feb29' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: 'Aug 6, 1945' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '1945-218' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '1945218' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '1945W32-1' readStream into: (Array new: 4)"	"ChronosParser default parseYearMonthDayFrom: '1945W321' readStream into: (Array new: 4)"	| year monthSpec day isIsoYearWeekDayOfWeek isoWeekOfYear |	ChronosFunction skipOver: stream until: [:ch | ch isAlphaNumeric].	stream atEnd ifTrue: [^nil].		year := self 				parseYearFrom: stream 				handleRejection: 					[:value :digitCount :rejectionReason |					rejectionReason == #notAnInteger 						ifTrue: [^self parseMonthDayYearFrom: stream into: ymdTzArray] 						ifFalse: [self handleInvalidYear: value digitCount: digitCount problemKey: rejectionReason]].	isIsoYearWeekDayOfWeek := true.	isoWeekOfYear := self parseIsoWeekOfYearFrom: stream handleRejection: [:value :digitCount :problem | isIsoYearWeekDayOfWeek := false].	isIsoYearWeekDayOfWeek		ifTrue: 			[monthSpec := isoWeekOfYear negated.			day := 				self 					parseIsoDayOfWeekFrom: stream 					handleRejection: [:value :digitCount :problem | self handleInvalidIsoDayOfWeek: value digitCount: digitCount problemKey: problem]]		ifFalse:			[monthSpec := 				self 					parseMonthFrom: stream 					maxDigits: 4 					handleRejection: 						[:month :count :problem | 							month isInteger								ifTrue: 									[count = 3										ifTrue: 											[day := month.											stream skip: 3.											nil]										ifFalse: 											[stream skip: 4.											day := month \\ 100.											month // 100]]								ifFalse: [problem == #streamAtEnd ifFalse: [self handleInvalidMonth: month problemKey: problem]]].			day == nil				ifTrue: 					[ChronosFunction skipOver: stream until: [:ch | ch isDigit].					day := 						self 							parseDayOfMonthFrom: stream							maxDigits: 4							handleRejection: 								[:value :digitCount :rejectionReason | 								| dayOfMonth | 								digitCount &gt; 0 									ifTrue:  										[(year between: 1 and: calendar maxDaysPerMonth)											ifTrue: 												[| month |												month := monthSpec.												month isInteger 													ifTrue: 														[year &gt; calendar maxMonthsPerYear															ifTrue: [dayOfMonth := year]															ifFalse: 																[month &gt; calendar maxMonthsPerYear																	ifTrue: 																		[dayOfMonth := month.																		monthSpec := year]																	ifFalse: [dayOfMonth := year]]]													ifFalse: [dayOfMonth := year].												stream skip: digitCount.												year := value.												dayOfMonth]											ifFalse: [self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]]									ifFalse: 										[(rejectionReason == #notAnInteger and: [monthSpec value isInteger])											ifTrue: 												[dayOfMonth := monthSpec value.												monthSpec := 													self 														parseMonthFrom: stream 														maxDigits: 2 														handleRejection: [:month :count :problem | self handleInvalidMonth: month problemKey: problem].														dayOfMonth]											"ifFalse:  [self handleInvalidDayOfMonth: value digitCount: digitCount problemKey: rejectionReason]"]]]].	ymdTzArray 		at: 1 put: year;		at: 2 put: monthSpec;		at: 3 put: day.	^ymdTzArray</body></methods><methods><class-id>Chronos.ConfigurableChronosParser class</class-id> <category>private</category><body package="Chronos-Parsing" selector="newRegistry">newRegistry	^self superclass registry</body></methods><methods><class-id>Chronos.GregorianEaster</class-id> <category>private-initialize-release</category><body package="Chronos-Annual Dates" selector="basicSetCalendar:">basicSetCalendar: aCalendar	self shouldNotImplement</body></methods><methods><class-id>Chronos.GregorianEaster</class-id> <category>initialize-release</category><body package="Chronos-Annual Dates" selector="setCalendar:">setCalendar: aCalendar 	self shouldNotImplement</body></methods><methods><class-id>Chronos.GregorianEaster</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isDayOfWeekInvariant">isDayOfWeekInvariant	^true</body></methods><methods><class-id>Chronos.GregorianEaster</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="calendarDayInYear:">calendarDayInYear: year 	"Mathematically valid for any year--HOWEVER, no one used the Easter rule that this algorithm implements before 1583, and after 4099 at the latest, it is highly likely that the rule will have been changed."	"{GregorianEaster canonical inYear: 2006}"	| modulus19 century yearInCentury cycleIndex centuryInCycle leapYearsThisCentury yearsSinceLastLeapYear lunarCorrection paschalFullMoon pfmAdjustment daysFromPFMToEasterSunday daysSinceMarch22 month day calendarDay |	modulus19 := year \\ 19.	century := year // 100.	yearInCentury := year \\ 100.	cycleIndex := century // 4.	centuryInCycle := century \\ 4.	leapYearsThisCentury := yearInCentury // 4.	yearsSinceLastLeapYear := yearInCentury \\ 4.	lunarCorrection := 8 * century + 13 // 25. "8 days per 2500 years."	paschalFullMoon := 19 * modulus19 + century - cycleIndex - lunarCorrection + 15 \\ 30.	pfmAdjustment := modulus19 + (11 * paschalFullMoon) // 319.	daysFromPFMToEasterSunday := (2 * centuryInCycle) + (2 * leapYearsThisCentury) - yearsSinceLastLeapYear  - paschalFullMoon + pfmAdjustment + 32 \\ 7.	daysSinceMarch22 := paschalFullMoon - pfmAdjustment + daysFromPFMToEasterSunday.	month :=  daysSinceMarch22 + 90 // 25.	day := daysSinceMarch22 + 19 + month \\ 32.	calendarDay := 		self calendar 			calendarDayFromMonth: month			day: day			inYear: year.	^self daysOffset = 0		ifTrue: [calendarDay]		ifFalse: 			[calendarDay 				startingWithYear: year				addingDays: daysOffset				setYearAndCalendarDayInto: [:y :cd | cd]]</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinal">maxDayOfYearOrdinal	^116 + self daysOffset</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinalForYearOfType:">maxDayOfYearOrdinalForYearOfType: yearTypeCode	^(yearTypeCode = 1 ifTrue: [115] ifFalse: [116]) + self daysOffset</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinal">minDayOfYearOrdinal	^80 + self daysOffset</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinalForYearOfType:">minDayOfYearOrdinalForYearOfType: yearTypeCode	^(yearTypeCode = 1 ifTrue: [80] ifFalse: [81]) + self daysOffset</body></methods><methods><class-id>Chronos.GregorianEaster</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processGregorianEaster: self</body></methods><methods><class-id>Passport.VWEnvironmentFacade class</class-id> <category>mutability</category><body package="Passport-Kernel-VW" selector="makeImmutable:">makeImmutable: anObject	"Make the argument immutable.  Answer the argument--NOT A COPY!. If the host Smalltalk environment doesn't support immutable objects, then just answer the argument as-is."	anObject isImmutable: true.	^anObject</body><body package="Passport-Kernel-VW" selector="makeMutable:">makeMutable: anObject	"Make the argument mutable.  Answer the argument--NOT A COPY!. If the host Smalltalk environment doesn't support immutable objects, then just answer the argument as-is."	anObject isImmutable: false.	^anObject</body></methods><methods><class-id>Passport.VWEnvironmentFacade class</class-id> <category>queries</category><body package="Passport-Kernel-VW" selector="resourcePathToImageDirectory">resourcePathToImageDirectory	"Answer a ResoucePath to the directory that contains the VisualWorks image."	"{EnvironmentFacade current resourcePathToImageDirectory}"	^ResourcePath fromString: ObjectMemory imageDirectory asResolvedString</body></methods><methods><class-id>Chronos.ZerolessOrdinalNumberingPolicy</class-id> <category>API-conversion</category><body package="Chronos-Foundation" selector="canonicalFromCardinal:">canonicalFromCardinal: cardinal	^cardinal &gt;= 0		ifTrue: [cardinal + 1]		ifFalse: [cardinal]</body><body package="Chronos-Foundation" selector="canonicalFromOrdinal:">canonicalFromOrdinal: ordinal	^ordinal &gt; 0		ifTrue: [ordinal]		ifFalse: [ordinal - 1]</body><body package="Chronos-Foundation" selector="canonicalFromZerolessOrdinal:">canonicalFromZerolessOrdinal: zerolessOrdinal	^zerolessOrdinal</body><body package="Chronos-Foundation" selector="cardinalFromCanonical:">cardinalFromCanonical: canonical	^canonical &gt; 0		ifTrue: [canonical - 1]		ifFalse: [canonical &lt; 0 ifTrue: [canonical] ifFalse: [self signalZeroInvalid]]</body><body package="Chronos-Foundation" selector="ordinalFromCanonical:">ordinalFromCanonical: canonical	^canonical &gt; 0		ifTrue: [canonical]		ifFalse: [canonical &lt; 0 ifTrue: [canonical + 1] ifFalse: [self signalZeroInvalid]]</body><body package="Chronos-Foundation" selector="zerolessOrdinalFromCanonical:">zerolessOrdinalFromCanonical: canonical	^canonical</body></methods><methods><class-id>Chronos.ZerolessOrdinalNumberingPolicy</class-id> <category>API-validation</category><body package="Chronos-Foundation" selector="satisfiesZeroConstraint:">satisfiesZeroConstraint: aValue	^aValue == nil		ifTrue: [false]		ifFalse: [aValue ~= 0]</body></methods><methods><class-id>Chronos.ZerolessOrdinalNumberingPolicy</class-id> <category>testing</category><body package="Chronos-Foundation" selector="isZeroValid">isZeroValid	^false</body></methods><methods><class-id>Chronos.BahaiCalendar</class-id> <category>API-unification</category><body package="Chronos-Calendars-Regular" selector="secondsSinceMidnightFromSecondsSinceStartOfDay:">secondsSinceMidnightFromSecondsSinceStartOfDay: secondsSinceStartOfDay	"Answer the number of seconds-since-start-of-day relative to midnight represented by the argument, &lt;secondsSinceStartOfDay&gt;, where the argument is specified relative to the receiver's canonical start-of-day (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since midnight clock time that corresponds to the number of seconds since the receiver's canonical start-of-day clock time, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for time systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Julian Day time system, the canonical start-of-day is Noon."	^secondsSinceStartOfDay + 64800</body><body package="Chronos-Calendars-Regular" selector="secondsSinceStartOfDayFromSecondsSinceMidnight:">secondsSinceStartOfDayFromSecondsSinceMidnight: secondsSinceMidnight	"Answer the number of seconds-since-start-of-day relative to the receiver's canonical start-of-day represented by the argument, &lt;secondsSinceMidnight&gt;, where the argument is specified relative to midnight (without respect to timezone translation or leap seconds.)  In other words, answer the number of seconds since the receiver's canonical start-of-day clock time that corresponds to the number of seconds since midnight, assuming that daylight savings time is not in effect in either case, and that no leap seconds occur during the day.	The translation enabled by the value this method returns is intended to account for calendar systems whose canoncial start-of-day is not midnight local time, but some other time of day.  For example, in the Hebrew calendar, the canonical start-of-day is 6pm."	^secondsSinceMidnight + 21600</body></methods><methods><class-id>Chronos.BahaiCalendar</class-id> <category>API-queries-years</category><body package="Chronos-Calendars-Regular" selector="typeCodeOfYear:">typeCodeOfYear: calendarYear	"Answer the year type code of the given &lt;calendarYear&gt;."	^calendarYear \\ 4 == 0 		ifTrue: [calendarYear \\ 100 == 0 					ifTrue: [calendarYear \\ 400 == 0 								ifTrue: [2] 								ifFalse: [1]] 					ifFalse: [2]]		ifFalse: [1]</body></methods><methods><class-id>Chronos.BahaiCalendar</class-id> <category>API-Date Deconstruction</category><body package="Chronos-Calendars-Regular" selector="daysSinceEpochUpToYear:">daysSinceEpochUpToYear: calendarYear 	"Answer the count of days since the Epoch day (start of day) up to (but NOT including) the first day of the specified year."	"BahaiCalendar canonical daysSinceEpochUpToYear: 5"	| cardinalYear |	cardinalYear := calendarYear - 1.	^ cardinalYear * 365 		+ (cardinalYear // 4) 		- (cardinalYear // 100) 		+ (cardinalYear // 400)</body></methods><methods><class-id>Chronos.BahaiCalendar</class-id> <category>API-Date Construction</category><body package="Chronos-Calendars-Regular" selector="forDaysSinceEpoch:setYearAndCalendarDayInto:">forDaysSinceEpoch: daysSinceEpoch setYearAndCalendarDayInto: yearMonthDaySpecOrBlock2	"For a year and CalendarDay that is daysSinceEpoch days since my Epoch, send #value:value: to &lt;yearAndCalendarDaySpecOrBlock2&gt;, with the year as the first argument and the CalendarDay as the second argument."	"days-in-four-year-cycle=1461; days-in-century=36524; days-in-four-centuries=146097; days-in-20 centuries=730485 "	| quadCentury century quadYear year days yearTypeCode |	quadCentury := daysSinceEpoch // 146097.	days := daysSinceEpoch \\ 146097.	century := days // 36524.	days := days \\ 36524.	(days == 0 and: [century == 4]) 		ifTrue: 			["Handle the 36524th cardinal day--a leap day"			century := century - 1.			days := 36524].	quadYear := days // 1461.	days := days \\ 1461.	year := days // 365.	days := days \\ 365.	(days == 0 and: [year == 4]) 		ifTrue: 			["Handle the 365th cardinal day--a leap day"			year := year - 1.			days := 365].	yearTypeCode := 		year == 3 "Last year in 4-year cycle"			ifTrue: 				[quadYear = 24 "last 4-year cycle in century"					ifTrue: 						[century = 3 "last century in 4-century cycle" 							ifTrue: [2] ifFalse: [1]]					ifFalse: [2]]			ifFalse: [1].	^yearMonthDaySpecOrBlock2		value: (year + (quadCentury * 400) + (century * 100) + (quadYear * 4))  + 1		value: ((yearlyCalendars at: yearTypeCode) basicDayAt: days + 1)</body></methods><methods><class-id>Chronos.BahaiCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="computeSecondsSinceJulianDayEpochUpToEpoch">computeSecondsSinceJulianDayEpochUpToEpoch	"Compute and answer the number of seconds since the initial moment of Julian Day Number 0 up to the initial moment of the epoch day of the receiver's calendrical system."	"Julian Day 0 starts at Noon Jan/1 4713 B.C. (zeroless ordinal year) in the Julian Calendar.	Julian Day 0 starts at Noon Nov/24 -4713 (pure ordinal year) in the proleptic Gregorian Calendar."	^2394646 * SecondsPerDay +  self secondsSinceStartOfJulianDayAtStartOfDay</body></methods><methods><class-id>Chronos.BahaiCalendar</class-id> <category>API-testing</category><body package="Chronos-Calendars-Regular" selector="midnightIsStartOfDay">midnightIsStartOfDay	"Answer true if the calendrical system represented by the receiver starts each day at local midnight."	^false</body><body package="Chronos-Calendars-Regular" selector="timeOfDayClockStartsAtStartOfDay">timeOfDayClockStartsAtStartOfDay	"Answer true if the zero-point of the time-of-day clock canonically used by the principal users of the calendrical system implemented by the receiver coincides with the start-of-day moment.  Note that some cultures represent time-of-day as a count of time since midnight, in spite of the fact that, in their calendrical system, midnight is not the moment at which one day transitions to the next day."	^false</body></methods><methods><class-id>Chronos.BahaiCalendar class</class-id> <category>private</category><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForLeapYear">newMonthlyCalendarSpecsForLeapYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a leap (non-standard) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a leap year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #'Bahá' 						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Jalál' 						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Jamál'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'''Azamat' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Núr'							daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Rahmat' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Kalimát' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Kamál'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Asmá'''						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'''Izzat'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Mashíyyat'					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'''Ilm'							daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Qudrat'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Qawl' 						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Masá''il' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Sharaf'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Sultán'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Mulk'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey: #'Ayyám-i-Há' 	daysPerMonth: 5 occursEveryYear: true leapDayOrdinals: #(5));		nextPut: (MonthlyCalendarSpec newWithKey: #'''Alá' 						daysPerMonth: 19 leapDayOrdinals: #()).	^specs contents</body><body package="Chronos-Calendars-Regular" selector="newMonthlyCalendarSpecsForStandardYear">newMonthlyCalendarSpecsForStandardYear	"Construct and answer an Array of MonthlyCalendarSpecs specifying the month structure of a standard (non-leap) year in the calendrical system implemented by instances of the receiver. There must be a MonthlyCalendarSpec in the Array for each month of a standard year.  The index of each MonthlyCalendarSpec in the Array becomes the month ordinal of the month specified by that MonthlyCalendarSpec."	| specs |	specs := Array new writeStream.	specs 		nextPut: (MonthlyCalendarSpec newWithKey: #'Bahá' 						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Jalál' 						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Jamál'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'''Azamat' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Núr'							daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Rahmat' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Kalimát' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Kamál'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Asmá'''						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'''Izzat'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Mashíyyat'					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'''Ilm'							daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Qudrat'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Qawl' 						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Masá''il' 					daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Sharaf'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Sultán'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'Mulk'						daysPerMonth: 19 leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newIntercalaryWithKey: #'Ayyám-i-Há' 	daysPerMonth: 5 occursEveryYear: true leapDayOrdinals: #());		nextPut: (MonthlyCalendarSpec newWithKey: #'''Alá' 						daysPerMonth: 19 leapDayOrdinals: #()).	^specs contents</body></methods><methods><class-id>Chronos.BahaiCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Regular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Bahai</body></methods><methods><class-id>Chronos.BahaiCalendar class</class-id> <category>functional verification</category><body package="Chronos-Calendars-Regular" selector="minVerificationYearCardinal">minVerificationYearCardinal	^0</body></methods><methods><class-id>Chronos.BahaiCalendar class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Regular" selector="initialize">initialize	"BahaiCalendar initialize."	self basicInitialize.</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy</class-id> <category>initialize-release</category><body package="Chronos-Localization" selector="addZoneWithKey:abbreviation:offsetSecondsFromUT:stdTimeOffsetSecondsFromUT:">addZoneWithKey: tzKey abbreviation: abbreviation offsetSecondsFromUT: offsetSecondsFromUT stdTimeOffsetSecondsFromUT: stdTimeOffsetSecondsFromUT 	| offsetArray abbreviationMap offsetArraySet |	self assertMutability.	offsetArray := Array with: offsetSecondsFromUT with: stdTimeOffsetSecondsFromUT.	abbreviationMap := zoneMap at: tzKey ifAbsentPut: [Dictionary new].	offsetArraySet := (abbreviationMap at: abbreviation ifAbsent: [Set new]) asSet.	offsetArraySet add: offsetArray.	abbreviationMap at: abbreviation put: offsetArraySet asArray</body><body package="Chronos-Localization" selector="beDefault">beDefault	self == ChronosLocale default timeZoneLocalizationPolicy		ifTrue: [Default := nil]		ifFalse: [Default := self]</body><body package="Chronos-Localization" selector="bindCommonTzAbbreviation:withDSTPreferredTo:withDSTNotPreferredTo:">bindCommonTzAbbreviation: commonTzAbbreviation withDSTPreferredTo: dstObservingTimeZoneKeyIfAvailable withDSTNotPreferredTo: dstNonObservingTimeZoneKeyIfAvailable 	self assertMutability.	defaultTimeZoneKeysByCommonAbbreviation at: commonTzAbbreviation asSymbol		put: (Array with: dstObservingTimeZoneKeyIfAvailable asSymbol				with: dstNonObservingTimeZoneKeyIfAvailable asSymbol)</body><body package="Chronos-Localization" selector="bindStandardTimeOffsetFromUT:withDSTPreferredTo:withDSTNotPreferredTo:">bindStandardTimeOffsetFromUT: offsetSecondsFromUT withDSTPreferredTo: dstObservingTimeZoneKeyIfAvailable withDSTNotPreferredTo: dstNonObservingTimeZoneKeyIfAvailable 	self assertMutability.	defaultTimeZoneKeysByStandardTimeOffsetFromUT 		at: offsetSecondsFromUT asInteger		put: (Array with: dstObservingTimeZoneKeyIfAvailable asSymbol				with: dstNonObservingTimeZoneKeyIfAvailable asSymbol)</body><body package="Chronos-Localization" selector="computeDefaultMappings">computeDefaultMappings	| offsetMap stdTimeAbbreviationMap dstAbbreviationMap |	(ChronosFunction isNilOrEmpty: zoneMap) ifTrue: [^nil].	offsetMap := Dictionary new.	stdTimeAbbreviationMap := IdentityDictionary new.	dstAbbreviationMap := IdentityDictionary new.	zoneMap 		keysAndValuesDo: 			[:tzKey :abbreviationMap | 			abbreviationMap keysAndValuesDo: 				[:commonAbbreviation :offsetArrayArray | 				| offsetSeconds stdTimeOffsetSeconds |				offsetArrayArray do: 					[:offsetArray | 					offsetSeconds := offsetArray at: 1.					stdTimeOffsetSeconds := offsetArray at: 2.					(offsetMap at: stdTimeOffsetSeconds ifAbsentPut: [Set new]) add: tzKey.					(stdTimeOffsetSeconds = offsetSeconds 						ifTrue: [stdTimeAbbreviationMap]						ifFalse: [dstAbbreviationMap]) at: tzKey							put: commonAbbreviation]]].	self initializeDefaultMappings.	offsetMap keysAndValuesDo: [:stdTimeOffsetSeconds :zoneKeys | 		| zoneKeyStream dstPreferred dstNotPreferred selectionMask |		zoneKeyStream := zoneKeys asArray readStream.		selectionMask := 3.		[zoneKeyStream atEnd or: [selectionMask = 0]] 			whileFalse: 				[| zoneKey stdTimeAbbreviation dstAbbreviation |				zoneKey := zoneKeyStream next.				stdTimeAbbreviation := stdTimeAbbreviationMap at: zoneKey ifAbsent: [].				dstAbbreviation := dstAbbreviationMap at: zoneKey ifAbsent: [].				dstAbbreviation == nil					ifTrue: 						[dstNotPreferred := Array with: zoneKey with: stdTimeAbbreviation.						selectionMask := selectionMask bitXor: 2]					ifFalse: 						[stdTimeAbbreviation == nil							ifTrue: [dstNotPreferred :=  Array with: zoneKey with: dstAbbreviation]							ifFalse: 								[dstPreferred := Array with: zoneKey with: stdTimeAbbreviation with: dstAbbreviation.								selectionMask := selectionMask bitXor: 1]]].		dstNotPreferred == nil ifTrue: [dstNotPreferred :=  dstPreferred].		dstPreferred == nil ifTrue: [dstPreferred := dstNotPreferred].		self 			bindStandardTimeOffsetFromUT: stdTimeOffsetSeconds			withDSTPreferredTo: dstPreferred first			withDSTNotPreferredTo: dstNotPreferred first.		self 			bindCommonTzAbbreviation: (dstPreferred at: 2)			withDSTPreferredTo: dstPreferred first			withDSTNotPreferredTo: dstNotPreferred first.		dstPreferred size &gt; 2			ifTrue: 				[self 					bindCommonTzAbbreviation: (dstPreferred at: 3)					withDSTPreferredTo: dstPreferred first					withDSTNotPreferredTo: dstPreferred first]]</body><body package="Chronos-Localization" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	self initializeZoneMap.	self initializeDefaultMappings.</body><body package="Chronos-Localization" selector="initializeDefaultMappings">initializeDefaultMappings	self assertMutability.	defaultTimeZoneKeysByCommonAbbreviation := IdentityDictionary new.	defaultTimeZoneKeysByStandardTimeOffsetFromUT := Dictionary new.</body><body package="Chronos-Localization" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	| array |	super initializeFromLiteralArray: literalArray.	defaultTimeZoneKeysByStandardTimeOffsetFromUT := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 3).	defaultTimeZoneKeysByCommonAbbreviation := ChronosFunction decodeDictionaryFromLiteralArray: (literalArray at: 4).	zoneMap := IdentityDictionary new.	5 to: literalArray size		do: 			[:index | 			array := literalArray at: index.			zoneMap at: (array at: 1) asSymbol				put: (ChronosFunction decodeDictionaryFromLiteralArray: (array at: 2))]</body><body package="Chronos-Localization" selector="initializeZoneMap">initializeZoneMap	self assertMutability.	zoneMap := IdentityDictionary new.</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy</class-id> <category>private</category><body package="Chronos-Localization" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: defaultTimeZoneKeysByStandardTimeOffsetFromUT);		nextPut: (ChronosFunction encodeDictionaryAsLiteralArray: defaultTimeZoneKeysByCommonAbbreviation).	zoneMap keysAndValuesDo: 			[:tzKey :abbreviationMap | 			stream nextPut: 				(Array 					with: tzKey					with: (ChronosFunction encodeDictionaryAsLiteralArray: abbreviationMap))]</body><body package="Chronos-Localization" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	super postCopy.	defaultTimeZoneKeysByCommonAbbreviation := defaultTimeZoneKeysByCommonAbbreviation copy.	defaultTimeZoneKeysByStandardTimeOffsetFromUT := defaultTimeZoneKeysByStandardTimeOffsetFromUT copy.</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy</class-id> <category>testing</category><body package="Chronos-Localization" selector="definesDefaultMappings">definesDefaultMappings	^((ChronosFunction isNilOrEmpty: defaultTimeZoneKeysByCommonAbbreviation) 		or: [ChronosFunction isNilOrEmpty: defaultTimeZoneKeysByStandardTimeOffsetFromUT]) not</body><body package="Chronos-Localization" selector="isRoot">isRoot	^self == Root</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy</class-id> <category>printing</category><body package="Chronos-Localization" selector="encodeDefaultMappingsOn:">encodeDefaultMappingsOn: stream	defaultTimeZoneKeysByStandardTimeOffsetFromUT keysAndValuesDo: 		[:offsetSeconds :array |			stream 				cr; tab;				print: offsetSeconds;				space;				nextPutAll: array first;				space;				nextPutAll: array last].	defaultTimeZoneKeysByCommonAbbreviation keysAndValuesDo: 		[:abbreviation :array |			stream 				cr; tab;				nextPutAll: abbreviation;				space;				nextPutAll: array first;				space;				nextPutAll: array last].	stream nextPut: $!.</body><body package="Chronos-Localization" selector="encodeOn:">encodeOn: stream	| position |	stream cr.	position := stream position.	stream		nextPutAll: registrationKey;		nextPut: $:.	self encodeDefaultMappingsOn: stream.	self encodeZoneMapOn: stream.	^position</body><body package="Chronos-Localization" selector="encodeZoneMapOn:">encodeZoneMapOn: stream	stream cr.	(ChronosFunction isNilOrEmpty: zoneMap) ifTrue: [^nil].	zoneMap 		keysAndValuesDo: 			[:tzKey :abbreviationMap | 			stream cr; nextPutAll: tzKey; nextPut: $:.			abbreviationMap keysAndValuesDo: 				[:commonAbbreviation :offsetArrayArray | 				stream cr; tab: 1; nextPut: $@; nextPutAll: commonAbbreviation.				offsetArrayArray do: [:offsetArray | stream tab; nextPut: $|; print: offsetArray first; space; print: offsetArray last]]].	stream nextPut: $!.</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy</class-id> <category>queries</category><body package="Chronos-Localization" selector="abbreviationToTimeZoneKeyMap:">abbreviationToTimeZoneKeyMap: dstPreferred	| map |	map := Dictionary new.	dstPreferred		ifTrue: [defaultTimeZoneKeysByCommonAbbreviation keysAndValuesDo: [:key :array | map at: key put: array first]]		ifFalse: [defaultTimeZoneKeysByCommonAbbreviation keysAndValuesDo: [:key :array | map at: key put: array last]].	^map</body><body package="Chronos-Localization" selector="defaultTimeZoneKeyForStandardTimeOffsetSecondsFromUT:dstPreferred:ifAbsent:">defaultTimeZoneKeyForStandardTimeOffsetSecondsFromUT: offsetSecondsFromUT dstPreferred: dstPreferred ifAbsent: ifAbsent 	| array default |	array := defaultTimeZoneKeysByStandardTimeOffsetFromUT 				at: offsetSecondsFromUT				ifAbsent: 					[^self isRoot 						ifTrue: [ifAbsent value]						ifFalse: 							[default := self class default.							(self == default ifTrue: [self class root ] ifFalse: [default])								defaultTimeZoneKeyForStandardTimeOffsetSecondsFromUT: offsetSecondsFromUT								dstPreferred: dstPreferred								ifAbsent: ifAbsent]].	^dstPreferred ifTrue: [array at: 1] ifFalse: [array at: 2]</body><body package="Chronos-Localization" selector="defaultTimeZoneKeyWithCommonAbbreviation:dstPreferred:ifAbsent:">defaultTimeZoneKeyWithCommonAbbreviation: commonTzAbbreviation dstPreferred: dstPreferred ifAbsent: ifAbsent 	| array default |	array := defaultTimeZoneKeysByCommonAbbreviation 				at: commonTzAbbreviation asSymbol				ifAbsent: 					[^self isRoot 						ifTrue: [ifAbsent value]						ifFalse: 							[default := self class default.							(self registrationKey == default registrationKey ifTrue: [self class root ] ifFalse: [default])								defaultTimeZoneKeyWithCommonAbbreviation: commonTzAbbreviation								dstPreferred: dstPreferred								ifAbsent: ifAbsent]].	^dstPreferred ifTrue: [array at: 1] ifFalse: [array at: 2]</body><body package="Chronos-Localization" selector="standardTimeOffsetSecondsToTimeZoneKeyMap:">standardTimeOffsetSecondsToTimeZoneKeyMap: dstPreferred	| map |	map := Dictionary new.	dstPreferred		ifTrue: [defaultTimeZoneKeysByStandardTimeOffsetFromUT keysAndValuesDo: [:key :array | map at: key put: array first]]		ifFalse: [defaultTimeZoneKeysByStandardTimeOffsetFromUT keysAndValuesDo: [:key :array | map at: key put: array last]].	^map</body><body package="Chronos-Localization" selector="zoneBindingsAt:ifAbsent:">zoneBindingsAt: olsonKey ifAbsent: ifAbsent 	"TimeZoneLocalizationPolicy unitedStates zoneBindingsAt: #'America/Los_Angeles' ifAbsent: []"	| map bindings |	map := zoneMap at: olsonKey ifAbsent: [^ifAbsent value].	bindings := (Array new: 2) writeStream.	map keysAndValuesDo: 			[:abbreviation :value | 				value do: 					[:offsetArray | 					bindings nextPut: 						(ChronosTimezone 							newBindingForKey: olsonKey							offsetSecondsFromUT: offsetArray first							stdTimeOffsetSecondsFromUT: offsetArray last							commonAbbreviation: abbreviation)]].	^bindings contents</body><body package="Chronos-Localization" selector="zoneKeys">zoneKeys	^zoneMap keys</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy</class-id> <category>enumerating</category><body package="Chronos-Localization" selector="zonesDo:">zonesDo: block1 	"{| zones |	zones := SortedCollection sortBlock: [:a :b | a offsetFromUT &lt; b offsetFromUT].	(TimeZoneLocalizationPolicy at: #RU) zonesDo: [:zone | zones add: zone].	zones do: [:zone | Transcript cr; show: zone printString]}"	"{| zones |	zones := SortedCollection sortBlock: [:a :b | a offsetFromUT &lt; b offsetFromUT].	(TimeZoneLocalizationPolicy at: #CA) zonesDo: [:zone | zones add: zone].	zones do: [:zone | Transcript cr; show: zone printString]}"	"{| zones |	zones := SortedCollection sortBlock: [:a :b | a offsetFromUT &lt; b offsetFromUT].	(TimeZoneLocalizationPolicy at: #AU) zonesDo: [:zone | zones add: zone].	zones do: [:zone | Transcript cr; show: zone printString]}"	"{| zones |	zones := SortedCollection sortBlock: [:a :b | a offsetFromUT &lt; b offsetFromUT].	(TimeZoneLocalizationPolicy at: #US) zonesDo: [:zone | zones add: zone].	zones do: [:zone | Transcript cr; show: zone printString]}"	(ChronosFunction isNilOrEmpty: zoneMap) ifTrue: [^nil].	zoneMap keysAndValuesDo: 			[:tzKey :abbreviationMap | 			abbreviationMap keysAndValuesDo: 					[:abbreviation :offsetArrayArray | 					offsetArrayArray do: 							[:offsetArray | 							block1 value: 								(ChronosTimezone 									newBindingForKey: tzKey									offsetSecondsFromUT: offsetArray first									stdTimeOffsetSecondsFromUT: offsetArray last									commonAbbreviation: abbreviation)]]]</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy</class-id> <category>accessing</category><body package="Chronos-Localization" selector="defaultCountryName">defaultCountryName	"TimeZoneLocalizationPolicy unitedStates defaultCountryName"	"(TimeZoneLocalizationPolicy at: #RU) defaultCountryName"	"(TimeZoneLocalizationPolicy at: #FR) defaultCountryName"	^self class defaultCountryNameAt: self key ifAbsent: [self key]</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy class</class-id> <category>private</category><body package="Chronos-Localization" selector="defineAllUniqueAbbreviationsIn:">defineAllUniqueAbbreviationsIn: policy		"All completely unique abbreviations, as generated by the following code:		{TimeZonePolicySequenceFactory keysByAbbreviation keysAndValuesDo: [:key :value | 			value size = 1				ifTrue:					[| tzKey |					tzKey := value asArray first.					Transcript						cr; tab; tab;						show: 'bindCommonTzAbbreviation: ';						show: '''';						show: key;						show: '''';						show: ' withDSTPreferredTo: #';						show: '''';						show: tzKey;						show: '''';						show: ' withDSTNotPreferredTo: #';						show: '''';						show: tzKey;						show: '''';						show: ';']]}"	policy		bindCommonTzAbbreviation: 'CXT' withDSTPreferredTo: #'Indian/Christmas' withDSTNotPreferredTo: #'Indian/Christmas';		bindCommonTzAbbreviation: 'LKT' withDSTPreferredTo: #'Asia/Colombo' withDSTNotPreferredTo: #'Asia/Colombo';		bindCommonTzAbbreviation: 'GYT' withDSTPreferredTo: #'America/Guyana' withDSTNotPreferredTo: #'America/Guyana';		bindCommonTzAbbreviation: 'GALT' withDSTPreferredTo: #'Pacific/Galapagos' withDSTNotPreferredTo: #'Pacific/Galapagos';		bindCommonTzAbbreviation: 'GFT' withDSTPreferredTo: #'America/Cayenne' withDSTNotPreferredTo: #'America/Cayenne';		bindCommonTzAbbreviation: 'FKT' withDSTPreferredTo: #'Atlantic/Stanley' withDSTNotPreferredTo: #'Atlantic/Stanley';		bindCommonTzAbbreviation: 'HOVT' withDSTPreferredTo: #'Asia/Hovd' withDSTNotPreferredTo: #'Asia/Hovd';		bindCommonTzAbbreviation: 'GMT+2' withDSTPreferredTo: #'Etc/GMT+2' withDSTNotPreferredTo: #'Etc/GMT+2';		bindCommonTzAbbreviation: 'SBT' withDSTPreferredTo: #'Pacific/Guadalcanal' withDSTNotPreferredTo: #'Pacific/Guadalcanal';		bindCommonTzAbbreviation: 'GMT-3' withDSTPreferredTo: #'Etc/GMT-3' withDSTNotPreferredTo: #'Etc/GMT-3';		bindCommonTzAbbreviation: 'GMT-8' withDSTPreferredTo: #'Etc/GMT-8' withDSTNotPreferredTo: #'Etc/GMT-8';		bindCommonTzAbbreviation: 'VUT' withDSTPreferredTo: #'Pacific/Efate' withDSTNotPreferredTo: #'Pacific/Efate';		bindCommonTzAbbreviation: 'GMT+5' withDSTPreferredTo: #'Etc/GMT+5' withDSTNotPreferredTo: #'Etc/GMT+5';		bindCommonTzAbbreviation: 'MAWT' withDSTPreferredTo: #'Antarctica/Mawson' withDSTNotPreferredTo: #'Antarctica/Mawson';		bindCommonTzAbbreviation: 'MEST' withDSTPreferredTo: #'MET' withDSTNotPreferredTo: #'MET';		bindCommonTzAbbreviation: 'GMT-13' withDSTPreferredTo: #'Etc/GMT-13' withDSTNotPreferredTo: #'Etc/GMT-13';		bindCommonTzAbbreviation: 'QYZT' withDSTPreferredTo: #'Asia/Qyzylorda' withDSTNotPreferredTo: #'Asia/Qyzylorda';		bindCommonTzAbbreviation: 'GMT+8' withDSTPreferredTo: #'Etc/GMT+8' withDSTNotPreferredTo: #'Etc/GMT+8';		bindCommonTzAbbreviation: 'PYT' withDSTPreferredTo: #'America/Asuncion' withDSTNotPreferredTo: #'America/Asuncion';		bindCommonTzAbbreviation: 'AZT' withDSTPreferredTo: #'Asia/Baku' withDSTNotPreferredTo: #'Asia/Baku';		bindCommonTzAbbreviation: 'SAKT' withDSTPreferredTo: #'Asia/Sakhalin' withDSTNotPreferredTo: #'Asia/Sakhalin';		bindCommonTzAbbreviation: 'ECT' withDSTPreferredTo: #'America/Guayaquil' withDSTNotPreferredTo: #'America/Guayaquil';		bindCommonTzAbbreviation: 'PETT' withDSTPreferredTo: #'Asia/Kamchatka' withDSTNotPreferredTo: #'Asia/Kamchatka';		bindCommonTzAbbreviation: 'GMT+12' withDSTPreferredTo: #'Etc/GMT+12' withDSTNotPreferredTo: #'Etc/GMT+12';		bindCommonTzAbbreviation: 'FKST' withDSTPreferredTo: #'Atlantic/Stanley' withDSTNotPreferredTo: #'Atlantic/Stanley';		bindCommonTzAbbreviation: 'GMT+9' withDSTPreferredTo: #'Etc/GMT+9' withDSTNotPreferredTo: #'Etc/GMT+9';		bindCommonTzAbbreviation: 'WAKT' withDSTPreferredTo: #'Pacific/Wake' withDSTNotPreferredTo: #'Pacific/Wake';		bindCommonTzAbbreviation: 'GET' withDSTPreferredTo: #'Asia/Tbilisi' withDSTNotPreferredTo: #'Asia/Tbilisi';		bindCommonTzAbbreviation: 'ORAT' withDSTPreferredTo: #'Asia/Oral' withDSTNotPreferredTo: #'Asia/Oral';		bindCommonTzAbbreviation: 'KOST' withDSTPreferredTo: #'Pacific/Kosrae' withDSTNotPreferredTo: #'Pacific/Kosrae';		bindCommonTzAbbreviation: 'IRKT' withDSTPreferredTo: #'Asia/Irkutsk' withDSTNotPreferredTo: #'Asia/Irkutsk';		bindCommonTzAbbreviation: 'CHOST' withDSTPreferredTo: #'Asia/Choibalsan' withDSTNotPreferredTo: #'Asia/Choibalsan';		bindCommonTzAbbreviation: 'SAKST' withDSTPreferredTo: #'Asia/Sakhalin' withDSTNotPreferredTo: #'Asia/Sakhalin';		bindCommonTzAbbreviation: 'VOST' withDSTPreferredTo: #'Antarctica/Vostok' withDSTNotPreferredTo: #'Antarctica/Vostok';		bindCommonTzAbbreviation: 'GMT+10' withDSTPreferredTo: #'Etc/GMT+10' withDSTNotPreferredTo: #'Etc/GMT+10';		bindCommonTzAbbreviation: 'GMT-10' withDSTPreferredTo: #'Etc/GMT-10' withDSTNotPreferredTo: #'Etc/GMT-10';		bindCommonTzAbbreviation: 'FJT' withDSTPreferredTo: #'Pacific/Fiji' withDSTNotPreferredTo: #'Pacific/Fiji';		bindCommonTzAbbreviation: 'MAGST' withDSTPreferredTo: #'Asia/Magadan' withDSTNotPreferredTo: #'Asia/Magadan';		bindCommonTzAbbreviation: 'NPT' withDSTPreferredTo: #'Asia/Katmandu' withDSTNotPreferredTo: #'Asia/Katmandu';		bindCommonTzAbbreviation: 'MMT' withDSTPreferredTo: #'Asia/Rangoon' withDSTNotPreferredTo: #'Asia/Rangoon';		bindCommonTzAbbreviation: 'PGT' withDSTPreferredTo: #'Pacific/Port_Moresby' withDSTNotPreferredTo: #'Pacific/Port_Moresby';		bindCommonTzAbbreviation: 'TJT' withDSTPreferredTo: #'Asia/Dushanbe' withDSTNotPreferredTo: #'Asia/Dushanbe';		bindCommonTzAbbreviation: 'WGT' withDSTPreferredTo: #'America/Godthab' withDSTNotPreferredTo: #'America/Godthab';		bindCommonTzAbbreviation: 'MET' withDSTPreferredTo: #'MET' withDSTNotPreferredTo: #'MET';		bindCommonTzAbbreviation: 'OMST' withDSTPreferredTo: #'Asia/Omsk' withDSTNotPreferredTo: #'Asia/Omsk';		bindCommonTzAbbreviation: 'WGST' withDSTPreferredTo: #'America/Godthab' withDSTNotPreferredTo: #'America/Godthab';		bindCommonTzAbbreviation: 'YAKST' withDSTPreferredTo: #'Asia/Yakutsk' withDSTNotPreferredTo: #'Asia/Yakutsk';		bindCommonTzAbbreviation: 'VLAT' withDSTPreferredTo: #'Asia/Vladivostok' withDSTNotPreferredTo: #'Asia/Vladivostok';		bindCommonTzAbbreviation: 'PWT' withDSTPreferredTo: #'Pacific/Palau' withDSTNotPreferredTo: #'Pacific/Palau';		bindCommonTzAbbreviation: 'GMT-4' withDSTPreferredTo: #'Etc/GMT-4' withDSTNotPreferredTo: #'Etc/GMT-4';		bindCommonTzAbbreviation: 'WAST' withDSTPreferredTo: #'Africa/Windhoek' withDSTNotPreferredTo: #'Africa/Windhoek';		bindCommonTzAbbreviation: 'NOVT' withDSTPreferredTo: #'Asia/Novosibirsk' withDSTNotPreferredTo: #'Asia/Novosibirsk';		bindCommonTzAbbreviation: 'GMT+3' withDSTPreferredTo: #'Etc/GMT+3' withDSTNotPreferredTo: #'Etc/GMT+3';		bindCommonTzAbbreviation: 'DAVT' withDSTPreferredTo: #'Antarctica/Davis' withDSTNotPreferredTo: #'Antarctica/Davis';		bindCommonTzAbbreviation: 'PHT' withDSTPreferredTo: #'Asia/Manila' withDSTNotPreferredTo: #'Asia/Manila';		bindCommonTzAbbreviation: 'ALMT' withDSTPreferredTo: #'Asia/Almaty' withDSTNotPreferredTo: #'Asia/Almaty';		bindCommonTzAbbreviation: 'EIT' withDSTPreferredTo: #'Asia/Jayapura' withDSTNotPreferredTo: #'Asia/Jayapura';		bindCommonTzAbbreviation: 'TKT' withDSTPreferredTo: #'Pacific/Fakaofo' withDSTNotPreferredTo: #'Pacific/Fakaofo';		bindCommonTzAbbreviation: 'GILT' withDSTPreferredTo: #'Pacific/Tarawa' withDSTNotPreferredTo: #'Pacific/Tarawa';		bindCommonTzAbbreviation: 'PHOT' withDSTPreferredTo: #'Pacific/Enderbury' withDSTNotPreferredTo: #'Pacific/Enderbury';		bindCommonTzAbbreviation: 'MVT' withDSTPreferredTo: #'Indian/Maldives' withDSTNotPreferredTo: #'Indian/Maldives';		bindCommonTzAbbreviation: 'GMT+11' withDSTPreferredTo: #'Etc/GMT+11' withDSTNotPreferredTo: #'Etc/GMT+11';		bindCommonTzAbbreviation: 'NFT' withDSTPreferredTo: #'Pacific/Norfolk' withDSTNotPreferredTo: #'Pacific/Norfolk';		bindCommonTzAbbreviation: 'GMT-7' withDSTPreferredTo: #'Etc/GMT-7' withDSTNotPreferredTo: #'Etc/GMT-7';		bindCommonTzAbbreviation: 'GMT+1' withDSTPreferredTo: #'Etc/GMT+1' withDSTNotPreferredTo: #'Etc/GMT+1';		bindCommonTzAbbreviation: 'GMT+4' withDSTPreferredTo: #'Etc/GMT+4' withDSTNotPreferredTo: #'Etc/GMT+4';		bindCommonTzAbbreviation: 'LINT' withDSTPreferredTo: #'Pacific/Kiritimati' withDSTNotPreferredTo: #'Pacific/Kiritimati';		bindCommonTzAbbreviation: 'CHOT' withDSTPreferredTo: #'Asia/Choibalsan' withDSTNotPreferredTo: #'Asia/Choibalsan';		bindCommonTzAbbreviation: 'KRAT' withDSTPreferredTo: #'Asia/Krasnoyarsk' withDSTNotPreferredTo: #'Asia/Krasnoyarsk';		bindCommonTzAbbreviation: 'HOVST' withDSTPreferredTo: #'Asia/Hovd' withDSTNotPreferredTo: #'Asia/Hovd';		bindCommonTzAbbreviation: 'KGT' withDSTPreferredTo: #'Asia/Bishkek' withDSTNotPreferredTo: #'Asia/Bishkek';		bindCommonTzAbbreviation: 'CKT' withDSTPreferredTo: #'Pacific/Rarotonga' withDSTNotPreferredTo: #'Pacific/Rarotonga';		bindCommonTzAbbreviation: 'EGT' withDSTPreferredTo: #'America/Scoresbysund' withDSTNotPreferredTo: #'America/Scoresbysund';		bindCommonTzAbbreviation: 'GMT-12' withDSTPreferredTo: #'Etc/GMT-12' withDSTNotPreferredTo: #'Etc/GMT-12';		bindCommonTzAbbreviation: 'TRUT' withDSTPreferredTo: #'Pacific/Truk' withDSTNotPreferredTo: #'Pacific/Truk';		bindCommonTzAbbreviation: 'UYT' withDSTPreferredTo: #'America/Montevideo' withDSTNotPreferredTo: #'America/Montevideo';		bindCommonTzAbbreviation: 'GMT-6' withDSTPreferredTo: #'Etc/GMT-6' withDSTNotPreferredTo: #'Etc/GMT-6';		bindCommonTzAbbreviation: 'BOT' withDSTPreferredTo: #'America/La_Paz' withDSTNotPreferredTo: #'America/La_Paz';		bindCommonTzAbbreviation: 'RET' withDSTPreferredTo: #'Indian/Reunion' withDSTNotPreferredTo: #'Indian/Reunion';		bindCommonTzAbbreviation: 'TFT' withDSTPreferredTo: #'Indian/Kerguelen' withDSTNotPreferredTo: #'Indian/Kerguelen';		bindCommonTzAbbreviation: 'KGST' withDSTPreferredTo: #'Asia/Bishkek' withDSTNotPreferredTo: #'Asia/Bishkek';		bindCommonTzAbbreviation: 'GMT-11' withDSTPreferredTo: #'Etc/GMT-11' withDSTNotPreferredTo: #'Etc/GMT-11';		bindCommonTzAbbreviation: 'ANAT' withDSTPreferredTo: #'Asia/Anadyr' withDSTNotPreferredTo: #'Asia/Anadyr';		bindCommonTzAbbreviation: 'TOT' withDSTPreferredTo: #'Pacific/Tongatapu' withDSTNotPreferredTo: #'Pacific/Tongatapu';		bindCommonTzAbbreviation: 'PET' withDSTPreferredTo: #'America/Lima' withDSTNotPreferredTo: #'America/Lima';		bindCommonTzAbbreviation: 'SAMT' withDSTPreferredTo: #'Europe/Samara' withDSTNotPreferredTo: #'Europe/Samara';		bindCommonTzAbbreviation: 'MART' withDSTPreferredTo: #'Pacific/Marquesas' withDSTNotPreferredTo: #'Pacific/Marquesas';		bindCommonTzAbbreviation: 'YEKT' withDSTPreferredTo: #'Asia/Yekaterinburg' withDSTNotPreferredTo: #'Asia/Yekaterinburg';		bindCommonTzAbbreviation: 'GMT+7' withDSTPreferredTo: #'Etc/GMT+7' withDSTNotPreferredTo: #'Etc/GMT+7';		bindCommonTzAbbreviation: 'YAKT' withDSTPreferredTo: #'Asia/Yakutsk' withDSTNotPreferredTo: #'Asia/Yakutsk';		bindCommonTzAbbreviation: 'ROTT' withDSTPreferredTo: #'Antarctica/Rothera' withDSTNotPreferredTo: #'Antarctica/Rothera';		bindCommonTzAbbreviation: 'PMST' withDSTPreferredTo: #'America/Miquelon' withDSTNotPreferredTo: #'America/Miquelon';		bindCommonTzAbbreviation: 'PETST' withDSTPreferredTo: #'Asia/Kamchatka' withDSTNotPreferredTo: #'Asia/Kamchatka';		bindCommonTzAbbreviation: 'CVT' withDSTPreferredTo: #'Atlantic/Cape_Verde' withDSTNotPreferredTo: #'Atlantic/Cape_Verde';		bindCommonTzAbbreviation: 'MUT' withDSTPreferredTo: #'Indian/Mauritius' withDSTNotPreferredTo: #'Indian/Mauritius';		bindCommonTzAbbreviation: 'COT' withDSTPreferredTo: #'America/Bogota' withDSTNotPreferredTo: #'America/Bogota';		bindCommonTzAbbreviation: 'ANAST' withDSTPreferredTo: #'Asia/Anadyr' withDSTNotPreferredTo: #'Asia/Anadyr';		bindCommonTzAbbreviation: 'GMT-5' withDSTPreferredTo: #'Etc/GMT-5' withDSTNotPreferredTo: #'Etc/GMT-5';		bindCommonTzAbbreviation: 'SYOT' withDSTPreferredTo: #'Antarctica/Syowa' withDSTNotPreferredTo: #'Antarctica/Syowa';		bindCommonTzAbbreviation: 'VET' withDSTPreferredTo: #'America/Caracas' withDSTNotPreferredTo: #'America/Caracas';		bindCommonTzAbbreviation: 'PMDT' withDSTPreferredTo: #'America/Miquelon' withDSTNotPreferredTo: #'America/Miquelon';		bindCommonTzAbbreviation: 'KRAST' withDSTPreferredTo: #'Asia/Krasnoyarsk' withDSTNotPreferredTo: #'Asia/Krasnoyarsk';		bindCommonTzAbbreviation: 'SRT' withDSTPreferredTo: #'America/Paramaribo' withDSTNotPreferredTo: #'America/Paramaribo';		bindCommonTzAbbreviation: 'AZST' withDSTPreferredTo: #'Asia/Baku' withDSTNotPreferredTo: #'Asia/Baku';		bindCommonTzAbbreviation: 'PYST' withDSTPreferredTo: #'America/Asuncion' withDSTNotPreferredTo: #'America/Asuncion';		bindCommonTzAbbreviation: 'WFT' withDSTPreferredTo: #'Pacific/Wallis' withDSTNotPreferredTo: #'Pacific/Wallis';		bindCommonTzAbbreviation: 'GMT-14' withDSTPreferredTo: #'Etc/GMT-14' withDSTNotPreferredTo: #'Etc/GMT-14';		bindCommonTzAbbreviation: 'MAGT' withDSTPreferredTo: #'Asia/Magadan' withDSTNotPreferredTo: #'Asia/Magadan';		bindCommonTzAbbreviation: 'CCT' withDSTPreferredTo: #'Indian/Cocos' withDSTNotPreferredTo: #'Indian/Cocos';		bindCommonTzAbbreviation: 'YAPT' withDSTPreferredTo: #'Pacific/Yap' withDSTNotPreferredTo: #'Pacific/Yap';		bindCommonTzAbbreviation: 'EGST' withDSTPreferredTo: #'America/Scoresbysund' withDSTNotPreferredTo: #'America/Scoresbysund';		bindCommonTzAbbreviation: 'IRKST' withDSTPreferredTo: #'Asia/Irkutsk' withDSTNotPreferredTo: #'Asia/Irkutsk';		bindCommonTzAbbreviation: 'NRT' withDSTPreferredTo: #'Pacific/Nauru' withDSTNotPreferredTo: #'Pacific/Nauru';		bindCommonTzAbbreviation: 'GMT-2' withDSTPreferredTo: #'Etc/GMT-2' withDSTNotPreferredTo: #'Etc/GMT-2';		bindCommonTzAbbreviation: 'DDUT' withDSTPreferredTo: #'Antarctica/DumontDUrville' withDSTNotPreferredTo: #'Antarctica/DumontDUrville';		bindCommonTzAbbreviation: 'VLAST' withDSTPreferredTo: #'Asia/Vladivostok' withDSTNotPreferredTo: #'Asia/Vladivostok';		bindCommonTzAbbreviation: 'GMT+6' withDSTPreferredTo: #'Etc/GMT+6' withDSTNotPreferredTo: #'Etc/GMT+6';		bindCommonTzAbbreviation: 'AZOST' withDSTPreferredTo: #'Atlantic/Azores' withDSTNotPreferredTo: #'Atlantic/Azores';		bindCommonTzAbbreviation: 'YEKST' withDSTPreferredTo: #'Asia/Yekaterinburg' withDSTNotPreferredTo: #'Asia/Yekaterinburg';		bindCommonTzAbbreviation: 'BNT' withDSTPreferredTo: #'Asia/Brunei' withDSTNotPreferredTo: #'Asia/Brunei';		bindCommonTzAbbreviation: 'NUT' withDSTPreferredTo: #'Pacific/Niue' withDSTNotPreferredTo: #'Pacific/Niue';		bindCommonTzAbbreviation: 'AFT' withDSTPreferredTo: #'Asia/Kabul' withDSTNotPreferredTo: #'Asia/Kabul';		bindCommonTzAbbreviation: 'PONT' withDSTPreferredTo: #'Pacific/Ponape' withDSTNotPreferredTo: #'Pacific/Ponape';		bindCommonTzAbbreviation: 'OMSST' withDSTPreferredTo: #'Asia/Omsk' withDSTNotPreferredTo: #'Asia/Omsk';		bindCommonTzAbbreviation: 'PKT' withDSTPreferredTo: #'Asia/Karachi' withDSTNotPreferredTo: #'Asia/Karachi';		bindCommonTzAbbreviation: 'TAHT' withDSTPreferredTo: #'Pacific/Tahiti' withDSTNotPreferredTo: #'Pacific/Tahiti';		bindCommonTzAbbreviation: 'SAMST' withDSTPreferredTo: #'Europe/Samara' withDSTNotPreferredTo: #'Europe/Samara';		bindCommonTzAbbreviation: 'TPT' withDSTPreferredTo: #'Asia/Dili' withDSTNotPreferredTo: #'Asia/Dili';		bindCommonTzAbbreviation: 'IOT' withDSTPreferredTo: #'Indian/Chagos' withDSTNotPreferredTo: #'Indian/Chagos';		bindCommonTzAbbreviation: 'SCT' withDSTPreferredTo: #'Indian/Mahe' withDSTNotPreferredTo: #'Indian/Mahe';		bindCommonTzAbbreviation: 'TVT' withDSTPreferredTo: #'Pacific/Funafuti' withDSTNotPreferredTo: #'Pacific/Funafuti';		bindCommonTzAbbreviation: 'NOVST' withDSTPreferredTo: #'Asia/Novosibirsk' withDSTNotPreferredTo: #'Asia/Novosibirsk';		bindCommonTzAbbreviation: 'NCT' withDSTPreferredTo: #'Pacific/Noumea' withDSTNotPreferredTo: #'Pacific/Noumea';		bindCommonTzAbbreviation: 'GEST' withDSTPreferredTo: #'Asia/Tbilisi' withDSTNotPreferredTo: #'Asia/Tbilisi';		bindCommonTzAbbreviation: 'GMT-1' withDSTPreferredTo: #'Etc/GMT-1' withDSTNotPreferredTo: #'Etc/GMT-1';		bindCommonTzAbbreviation: 'AZOT' withDSTPreferredTo: #'Atlantic/Azores' withDSTNotPreferredTo: #'Atlantic/Azores';		bindCommonTzAbbreviation: 'GMT-9' withDSTPreferredTo: #'Etc/GMT-9' withDSTNotPreferredTo: #'Etc/GMT-9'</body><body package="Chronos-Localization" selector="newRoot">newRoot	| policy |	policy := self new.	policy		setKey: #Root;		bindStandardTimeOffsetFromUT: -11 * SecondsPerHour withDSTPreferredTo: #'Pacific/Apia' withDSTNotPreferredTo: #'Pacific/Apia';		bindStandardTimeOffsetFromUT: -10 * SecondsPerHour withDSTPreferredTo: #'America/Atka' withDSTNotPreferredTo: #'Pacific/Tahiti';		bindStandardTimeOffsetFromUT: ((-9 * SecondsPerHour) + (-30 * SecondsPerMinute)) withDSTPreferredTo: #'Pacific/Marquesas' withDSTNotPreferredTo: #'Pacific/Marquesas';		bindStandardTimeOffsetFromUT: -9 * SecondsPerHour withDSTPreferredTo: #'America/Yakutat' withDSTNotPreferredTo: #'Pacific/Gambier';		bindStandardTimeOffsetFromUT: -8 * SecondsPerHour withDSTPreferredTo: #'America/Vancouver' withDSTNotPreferredTo: #'Pacific/Pitcairn';		bindStandardTimeOffsetFromUT: -7 * SecondsPerHour withDSTPreferredTo: #'America/Edmonton' withDSTNotPreferredTo: #'America/Dawson_Creek';		bindStandardTimeOffsetFromUT: -6 * SecondsPerHour withDSTPreferredTo: #'America/Mexico_City' withDSTNotPreferredTo: #'America/Regina';		bindStandardTimeOffsetFromUT: -5 * SecondsPerHour withDSTPreferredTo: #'America/Toronto' withDSTNotPreferredTo: #'America/Bogota';		bindStandardTimeOffsetFromUT: -4 * SecondsPerHour withDSTPreferredTo: #'America/Santiago' withDSTNotPreferredTo: #'America/Caracas';		bindStandardTimeOffsetFromUT: -3 * SecondsPerHour withDSTPreferredTo: #'America/Sao_Paulo' withDSTNotPreferredTo: #'America/Argentina/Buenos_Aires';		bindStandardTimeOffsetFromUT: -2 * SecondsPerHour withDSTPreferredTo: #'America/Noronha' withDSTNotPreferredTo: #'America/Noronha';		bindStandardTimeOffsetFromUT: -1 * SecondsPerHour withDSTPreferredTo: #'Atlantic/Cape_Verde' withDSTNotPreferredTo: #'Atlantic/Cape_Verde';		bindStandardTimeOffsetFromUT: 0 * SecondsPerHour withDSTPreferredTo: #'Europe/London' withDSTNotPreferredTo: #Universal;		bindStandardTimeOffsetFromUT: 1 * SecondsPerHour withDSTPreferredTo: #'Europe/Berlin' withDSTNotPreferredTo: #'Africa/Lagos';		bindStandardTimeOffsetFromUT: 2 * SecondsPerHour withDSTPreferredTo: #'Europe/Istanbul' withDSTNotPreferredTo: #'Africa/Johannesburg';		bindStandardTimeOffsetFromUT: 3 * SecondsPerHour withDSTPreferredTo: #'Europe/Moscow' withDSTNotPreferredTo: #'Africa/Addis_Ababa';		bindStandardTimeOffsetFromUT: 4 * SecondsPerHour withDSTPreferredTo: #'Asia/Baku' withDSTNotPreferredTo: #'Asia/Dubai';		bindStandardTimeOffsetFromUT: ((4 * SecondsPerHour) + (30 * SecondsPerMinute)) withDSTPreferredTo: #'Asia/Kabul' withDSTNotPreferredTo: #'Asia/Kabul';		bindStandardTimeOffsetFromUT: 5 * SecondsPerHour withDSTPreferredTo: #'Asia/Bishkek' withDSTNotPreferredTo: #'Asia/Karachi';		bindStandardTimeOffsetFromUT: ((5 * SecondsPerHour) + (30 * SecondsPerMinute)) withDSTPreferredTo: #'Asia/Calcutta' withDSTNotPreferredTo: #'Asia/Calcutta';		bindStandardTimeOffsetFromUT: ((5 * SecondsPerHour) + (45 * SecondsPerMinute)) withDSTPreferredTo: #'Asia/Katmandu' withDSTNotPreferredTo: #'Asia/Katmandu';		bindStandardTimeOffsetFromUT: 6 * SecondsPerHour withDSTPreferredTo: #'Asia/Novosibirsk' withDSTNotPreferredTo: #'Asia/Colombo';		bindStandardTimeOffsetFromUT: ((6 * SecondsPerHour) + (30 * SecondsPerMinute)) withDSTPreferredTo: #'Asia/Rangoon' withDSTNotPreferredTo: #'Asia/Rangoon';		bindStandardTimeOffsetFromUT: 7 * SecondsPerHour withDSTPreferredTo: #'Asia/Hovd' withDSTNotPreferredTo: #'Asia/Bangkok';		bindStandardTimeOffsetFromUT: 8 * SecondsPerHour withDSTPreferredTo: #'Asia/Irkutsk' withDSTNotPreferredTo: #'Asia/Hong_Kong';		bindStandardTimeOffsetFromUT: 9 * SecondsPerHour withDSTPreferredTo: #'Asia/Yakutsk' withDSTNotPreferredTo: #'Asia/Tokyo';		bindStandardTimeOffsetFromUT: ((9 * SecondsPerHour) + (30 * SecondsPerMinute)) withDSTPreferredTo: #'Australia/Adelaide' withDSTNotPreferredTo: #'Australia/Darwin';		bindStandardTimeOffsetFromUT: 10 * SecondsPerHour withDSTPreferredTo: #'Australia/Sydney' withDSTNotPreferredTo: #'Australia/Queensland';		bindStandardTimeOffsetFromUT: ((10 * SecondsPerHour) + (30 * SecondsPerMinute)) withDSTPreferredTo: #'Australia/Lord_Howe' withDSTNotPreferredTo: #'Australia/Lord_Howe';		bindStandardTimeOffsetFromUT: 11 * SecondsPerHour withDSTPreferredTo: #'Pacific/Guadalcanal' withDSTNotPreferredTo: #'Pacific/Guadalcanal';		bindStandardTimeOffsetFromUT: 12 * SecondsPerHour withDSTPreferredTo: #'Pacific/Auckland' withDSTNotPreferredTo: #'Pacific/Fiji';		bindStandardTimeOffsetFromUT: ((12 * SecondsPerHour) + (30 * SecondsPerMinute)) withDSTPreferredTo: #'Pacific/Chatham' withDSTNotPreferredTo: #'Pacific/Chatham';		bindStandardTimeOffsetFromUT: 13 * SecondsPerHour withDSTPreferredTo: #'Pacific/Tongatapu' withDSTNotPreferredTo: #'Pacific/Tongatapu';		bindStandardTimeOffsetFromUT: 14 * SecondsPerHour withDSTPreferredTo: #'Pacific/Kiritimati' withDSTNotPreferredTo: #'Pacific/Kiritimati';		bindCommonTzAbbreviation: #SST withDSTPreferredTo: #'Pacific/Apia' withDSTNotPreferredTo: #'Pacific/Apia';		bindCommonTzAbbreviation: #HAST withDSTPreferredTo: #'America/Atka' withDSTNotPreferredTo: #'Pacific/Honolulu';		bindCommonTzAbbreviation: #HADT withDSTPreferredTo: #'America/Atka' withDSTNotPreferredTo: #'America/Atka';		bindCommonTzAbbreviation: #MART withDSTPreferredTo: #'Pacific/Marquesas' withDSTNotPreferredTo: #'Pacific/Marquesas';		bindCommonTzAbbreviation: #AKST withDSTPreferredTo: #'America/Yakutat' withDSTNotPreferredTo: #'America/Anchorage';		bindCommonTzAbbreviation: #AKDT withDSTPreferredTo: #'America/Yakutat' withDSTNotPreferredTo: #'America/Yakutat';		bindCommonTzAbbreviation: #PST withDSTPreferredTo: #'America/Vancouver' withDSTNotPreferredTo: #'Pacific/Pitcairn';		bindCommonTzAbbreviation: #PDT withDSTPreferredTo: #'America/Vancouver' withDSTNotPreferredTo: #'America/Vancouver';		bindCommonTzAbbreviation: #MST withDSTPreferredTo: #'America/Edmonton' withDSTNotPreferredTo: #'America/Dawson_Creek';		bindCommonTzAbbreviation: #MDT withDSTPreferredTo: #'America/Edmonton' withDSTNotPreferredTo: #'America/Edmonton';		bindCommonTzAbbreviation: #CST withDSTPreferredTo: #'America/Mexico_City' withDSTNotPreferredTo: #'America/Regina';		bindCommonTzAbbreviation: #CDT withDSTPreferredTo: #'America/Mexico_City' withDSTNotPreferredTo: #'America/Mexico_City';		bindCommonTzAbbreviation: #EST withDSTPreferredTo: #'America/Toronto' withDSTNotPreferredTo: #'America/Indiana/Indianapolis';		bindCommonTzAbbreviation: #EDT withDSTPreferredTo: #'America/Toronto' withDSTNotPreferredTo: #'America/Toronto';		bindCommonTzAbbreviation: #VET withDSTPreferredTo: #'America/Caracas' withDSTNotPreferredTo: #'America/Caracas';		bindCommonTzAbbreviation: #CLT withDSTPreferredTo: #'America/Santiago' withDSTNotPreferredTo: #'America/Santiago';		bindCommonTzAbbreviation: #CLST withDSTPreferredTo: #'America/Santiago' withDSTNotPreferredTo: #'America/Santiago';		bindCommonTzAbbreviation: #ART withDSTPreferredTo: #'America/Argentina/Buenos_Aires' withDSTNotPreferredTo: #'America/Argentina/Buenos_Aires';		bindCommonTzAbbreviation: #BRT withDSTPreferredTo: #'America/Sao_Paulo' withDSTNotPreferredTo: #'America/Sao_Paulo';		bindCommonTzAbbreviation: #FNT withDSTPreferredTo: #'America/Noronha' withDSTNotPreferredTo: #'America/Noronha';		bindCommonTzAbbreviation: #GMT withDSTPreferredTo: #'Europe/London' withDSTNotPreferredTo: #Universal;		bindCommonTzAbbreviation: #WAT withDSTPreferredTo: #'Africa/Lagos' withDSTNotPreferredTo: #'Africa/Lagos';		bindCommonTzAbbreviation: #CET withDSTPreferredTo: #'Europe/Berlin' withDSTNotPreferredTo: #'Europe/Berlin';		bindCommonTzAbbreviation: #CEST withDSTPreferredTo: #'Europe/Berlin' withDSTNotPreferredTo: #'Europe/Berlin';		bindCommonTzAbbreviation: #SAST withDSTPreferredTo: #'Africa/Johannesburg' withDSTNotPreferredTo: #'Africa/Johannesburg';		bindCommonTzAbbreviation: #EET withDSTPreferredTo: #'Europe/Istanbul' withDSTNotPreferredTo: #'Europe/Istanbul';		bindCommonTzAbbreviation: #EEST withDSTPreferredTo: #'Europe/Istanbul' withDSTNotPreferredTo: #'Europe/Istanbul';		bindCommonTzAbbreviation: #EAT withDSTPreferredTo: #'Africa/Addis_Ababa' withDSTNotPreferredTo: #'Africa/Addis_Ababa';		bindCommonTzAbbreviation: #GST withDSTPreferredTo: #'Asia/Dubai' withDSTNotPreferredTo: #'Asia/Dubai';		bindCommonTzAbbreviation: #AZT withDSTPreferredTo: #'Asia/Baku' withDSTNotPreferredTo: #'Asia/Baku';		bindCommonTzAbbreviation: #AZST withDSTPreferredTo: #'Asia/Baku' withDSTNotPreferredTo: #'Asia/Baku';		bindCommonTzAbbreviation: #AFT withDSTPreferredTo: #'Asia/Kabul' withDSTNotPreferredTo: #'Asia/Kabul';		bindCommonTzAbbreviation: #PKT withDSTPreferredTo: #'Asia/Karachi' withDSTNotPreferredTo: #'Asia/Karachi';		bindCommonTzAbbreviation: #KGT withDSTPreferredTo: #'Asia/Bishkek' withDSTNotPreferredTo: #'Asia/Bishkek';		bindCommonTzAbbreviation: #KGST withDSTPreferredTo: #'Asia/Bishkek' withDSTNotPreferredTo: #'Asia/Bishkek';		bindCommonTzAbbreviation: #IST withDSTPreferredTo: #'Asia/Calcutta' withDSTNotPreferredTo: #'Asia/Calcutta';		bindCommonTzAbbreviation: #NPT withDSTPreferredTo: #'Asia/Katmandu' withDSTNotPreferredTo: #'Asia/Katmandu';		bindCommonTzAbbreviation: #NOVT withDSTPreferredTo: #'Asia/Novosibirsk' withDSTNotPreferredTo: #'Asia/Novosibirsk';		bindCommonTzAbbreviation: #NOVST withDSTPreferredTo: #'Asia/Novosibirsk' withDSTNotPreferredTo: #'Asia/Novosibirsk';		bindCommonTzAbbreviation: #LKT withDSTPreferredTo: #'Asia/Colombo' withDSTNotPreferredTo: #'Asia/Colombo';		bindCommonTzAbbreviation: #ICT withDSTPreferredTo: #'Asia/Bangkok' withDSTNotPreferredTo: #'Asia/Bangkok';		bindCommonTzAbbreviation: #HKT withDSTPreferredTo: #'Asia/Hong_Kong' withDSTNotPreferredTo: #'Asia/Hong_Kong';		bindCommonTzAbbreviation: #NZST withDSTPreferredTo: #'Pacific/Auckland' withDSTNotPreferredTo: #'Pacific/Auckland';		bindCommonTzAbbreviation: #NZDT withDSTPreferredTo: #'Pacific/Auckland' withDSTNotPreferredTo: #'Pacific/Auckland'.	self defineAllUniqueAbbreviationsIn: policy.	^policy</body><body package="Chronos-Localization" selector="newUnique">newUnique	| policy |	policy := self new.	policy setKey: #Unique.	self defineAllUniqueAbbreviationsIn: policy.	^policy</body><body package="Chronos-Localization" selector="resourceBroker">resourceBroker	^ChronosSystemFacade resourceRepositoryContext tzLocalizationPolicyResourceBroker</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy class</class-id> <category>accessing</category><body package="Chronos-Localization" selector="default">default	^Default == nil 		ifTrue: 			[| defaultCountryCode |			defaultCountryCode := ChronosLocale default countryCode.			self 				at: defaultCountryCode				ifAbsent: 					[defaultCountryCode == #US 						ifTrue: [self root]						ifFalse: [self at: #US ifAbsent: [self root]]]]		ifFalse: [Default]</body><body package="Chronos-Localization" selector="root">root	"TimeZoneLocalizationPolicy root"	Root == nil 		ifTrue: 			[Root := self newRoot.			Root forceRegistration].	^Root</body><body package="Chronos-Localization" selector="unique">unique	"TimeZoneLocalizationPolicy unique"	Unique == nil 		ifTrue: 			[Unique := self newUnique.			Unique forceRegistration].	^Unique</body><body package="Chronos-Localization" selector="unitedStates">unitedStates	"TimeZoneLocalizationPolicy unitedStates"	^self at: #US</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy class</class-id> <category>instance creation</category><body package="Chronos-Localization" selector="decodeDefaultMappingsFrom:into:">decodeDefaultMappingsFrom: stream into: policy	| atEnd |	ChronosFunction skipSeparators: stream.	atEnd := stream atEnd.	[atEnd] whileFalse:		[| key dstPreferred dstNotPreferred |		key := stream upTo: $ .		ChronosFunction skipSeparators: stream.		dstPreferred :=  (stream upTo: $ ) asSymbol.		ChronosFunction skipSeparators: stream.		dstNotPreferred := ChronosFunction nextLineFrom: stream.		dstNotPreferred last = $! 			ifTrue: 				[atEnd := true.				dstNotPreferred := dstNotPreferred copyFrom: 1 to: dstNotPreferred size - 1].		key first isLetter			ifTrue: [policy bindCommonTzAbbreviation: key asSymbol withDSTPreferredTo: dstPreferred withDSTNotPreferredTo: dstNotPreferred]			ifFalse: [policy bindStandardTimeOffsetFromUT: key asNumber withDSTPreferredTo: dstPreferred withDSTNotPreferredTo: dstNotPreferred].		atEnd := atEnd 						or: 							[ChronosFunction skipSeparators: stream.							stream atEnd]].</body><body package="Chronos-Localization" selector="decodeFrom:">decodeFrom: stream	| registrationKey policy |	registrationKey := self registrationKeyFrom: stream.	policy := self new.	policy setKey: registrationKey.	self decodeDefaultMappingsFrom: stream into: policy.	self decodeZoneMapFrom: stream into: policy.	^policy beImmutable</body><body package="Chronos-Localization" selector="decodeZoneMapFrom:into:">decodeZoneMapFrom: stream into: policy 	| tzKey abbreviation offsetSecondsFromUT stdTimeOffsetSecondsFromUT |	[ChronosFunction skipSeparators: stream.	stream atEnd or: [stream peekFor: $!]] 			whileFalse: 				[tzKey := (stream upTo: $:) asSymbol.				ChronosFunction skipSeparators: stream.				[stream peekFor: $@] whileTrue: 						[abbreviation := (ChronosFunction nextFrom: stream until: [:ch | ch isSeparator]) asSymbol.						[ChronosFunction skipSeparators: stream.						stream peekFor: $|] 								whileTrue: 									[| ch polarity |									ChronosFunction skipSeparators: stream.									ch := stream peek.									polarity := #($- $+) indexOf: ch ifAbsent: [0].									polarity = 0										ifTrue: [polarity := 1]										ifFalse: 											[stream next.											polarity := #(-1 1) at: polarity].									offsetSecondsFromUT := 										(ChronosFunction 											nextUnsignedIntegerFrom: stream											minDigits: 1											maxDigits: 5											acceptancePredicate: [:int :digitCount | true]											handleRejection: [:value :digitCount :rejectionReason | self signalError: rejectionReason]) * polarity.									ChronosFunction skipSeparators: stream.									ch := stream peek.									polarity := #($- $+) indexOf: ch ifAbsent: [0].									polarity = 0										ifTrue: [polarity := 1]										ifFalse: 											[stream next.											polarity := #(-1 1) at: polarity].									stdTimeOffsetSecondsFromUT := 										(ChronosFunction 											nextUnsignedIntegerFrom: stream											minDigits: 1											maxDigits: 5											acceptancePredicate: [:int :digitCount | true]											handleRejection: [:value :digitCount :rejectionReason | self signalError: rejectionReason]) * polarity.									policy 										addZoneWithKey: tzKey										abbreviation: abbreviation										offsetSecondsFromUT: offsetSecondsFromUT										stdTimeOffsetSecondsFromUT: stdTimeOffsetSecondsFromUT]]]</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy class</class-id> <category>country names</category><body package="Chronos-Localization" selector="defaultCountryNameAt:ifAbsent:">defaultCountryNameAt: countryCode ifAbsent: block0	^CountryNames at: countryCode ifAbsent: block0</body><body package="Chronos-Localization" selector="keysAndDefaultCountryNamesDo:">keysAndDefaultCountryNamesDo: block2	CountryNames keysAndValuesDo: block2</body><body package="Chronos-Localization" selector="parseCountryCodeToNameMappingsFrom:">parseCountryCodeToNameMappingsFrom: stream 	"{ChronosSystemFacade current resourceRepositoryContext invalidateCountryCodeToCountryNameMappings}"	CountryNames := Dictionary new.	[ChronosFunction skipSeparators: stream.	stream atEnd] whileFalse: 		[| code countryName |		(stream atEnd or: [stream peek = $#]) 			ifTrue: [ChronosFunction skipToNextLineOf: stream]			ifFalse: 				[code := ChronosFunction nextFrom: stream until: [:ch | ch isSeparator].				ChronosFunction skipSeparators: stream.				countryName := ChronosFunction nextLineFrom: stream.				CountryNames at: code asSymbol put: countryName]].</body></methods><methods><class-id>Chronos.TimeZoneLocalizationPolicy class</class-id> <category>class initialization</category><body package="Chronos-Localization" selector="initialize">initialize	"TimeZoneLocalizationPolicy initialize."	self basicInitializeAll.	Default := nil.	Root := nil.	Unique := nil.	CountryNames := Dictionary new</body></methods><methods><class-id>Chronos.NonStandardTime</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isStandardTime">isStandardTime	"Answer whether or not the offset from UT specified by the receiver defines the `standard time` of the time zone represented by the receiver (as opposed to `daylight saving time`, `summer time`, `war time`, 'three-year-long-year-round energy-saving-during-a-crisis time', etc)."	^false</body></methods><methods><class-id>Chronos.NonStandardTime</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	stdTimeOffsetFromUT := (literalArray at: 6) decodeAsLiteralArray</body><body package="Chronos-TimeZones" selector="setKey:offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:">setKey: aTZKey offsetSeconds: offsetSecondsFromUT stdTimeOffsetSeconds: stdTimeOffsetSeconds commonAbbreviation: aSymbol	"Set the receiver's time zone key to be &lt;aTZKey&gt;; 	set the receiver's offset from UT to be the specified number of &lt;offsetSecondsFromUT&gt;;. 	set the receiver's offset from UT during standard time (when DST is not in effect) to be the specified number of &lt;stdTimeOffsetSeconds&gt;;. 	set the receiver's common abbreviation to be &lt;aSymbol&gt;.	Fail if the receiver is not mutable."	self setKey: aTZKey offsetSeconds: offsetSecondsFromUT commonAbbreviation: aSymbol.	stdTimeOffsetFromUT := (self class offsetFromSeconds: stdTimeOffsetSeconds)</body></methods><methods><class-id>Chronos.NonStandardTime</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="offsetDelta">offsetDelta	"Answer a Duration that specifies the amount of time to be added to the receiver's standard-time offset from UT in order to compute the receiver's offset from UT when Daylight Saving Time (Summer Time) is in effect."	^self offsetFromUT - self stdTimeOffsetFromUT</body><body package="Chronos-TimeZones" selector="offsetDeltaSeconds">offsetDeltaSeconds	"Answer the number of seconds to be added to the receiver's standard-time offset from UT in order to compute the receiver's offset from UT when Daylight Saving Time (Summer Time) is in effect."	^self offsetSecondsFromUT - self stdTimeOffsetSecondsFromUT</body><body package="Chronos-TimeZones" selector="stdTimeOffsetFromUT">stdTimeOffsetFromUT	"Answer a Duration that specifies the receiver's offset from Universal Time when `standard time` is in effect (which is defined as the amount of time to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^stdTimeOffsetFromUT</body><body package="Chronos-TimeZones" selector="stdTimeOffsetSecondsFromUT">stdTimeOffsetSecondsFromUT	"Answer the receiver's offset from Universal Time in seconds when `standard time` is in effect (which is defined as the number of seconds to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^stdTimeOffsetFromUT asSeconds</body><body package="Chronos-TimeZones" selector="timeType">timeType	^#nonstandard</body></methods><methods><class-id>Chronos.NonStandardTime</class-id> <category>private</category><body package="Chronos-TimeZones" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut: self stdTimeOffsetFromUT literalArrayEncoding</body></methods><methods><class-id>Chronos.NonStandardTime</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processNonStandardTime: self</body></methods><methods><class-id>Passport.PassportSignedMetanumber</class-id> <category>comparing</category><body package="Passport-Kernel" selector="hash">hash	^isNegative hash</body></methods><methods><class-id>Passport.PassportSignedMetanumber</class-id> <category>arithmetic</category><body package="Passport-Kernel" selector="abs">abs	^isNegative ifTrue: [self class positive] ifFalse: [self]</body><body package="Passport-Kernel" selector="negated">negated	^isNegative ifTrue: [self class positive] ifFalse: [self class negative]</body></methods><methods><class-id>Passport.PassportSignedMetanumber</class-id> <category>testing</category><body package="Passport-Kernel" selector="negative">negative	^isNegative</body><body package="Passport-Kernel" selector="positive">positive	^isNegative not</body></methods><methods><class-id>Passport.PassportSignedMetanumber</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="beNegative">beNegative	self assertMutability.	isNegative := true</body><body package="Passport-Kernel" selector="bePositive">bePositive	self assertMutability.	isNegative := false</body><body package="Passport-Kernel" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	self assertMutability.		isNegative := false.</body></methods><methods><class-id>Passport.PassportSignedMetanumber</class-id> <category>printing</category><body package="Passport-Kernel" selector="printOn:">printOn: stream	isNegative		ifTrue: [stream nextPut: $-]		ifFalse: [stream nextPut: $+].</body></methods><methods><class-id>Passport.PassportSignedMetanumber</class-id> <category>private-comparing-VW</category><body package="Passport-Kernel-VW" selector="lessFromDouble:">lessFromDouble: aDouble	^self positive</body><body package="Passport-Kernel-VW" selector="lessFromFloat:">lessFromFloat: aFloat	^self positive</body><body package="Passport-Kernel-VW" selector="lessFromFraction:">lessFromFraction: aFraction	^self positive</body><body package="Passport-Kernel-VW" selector="lessFromInteger:">lessFromInteger: comparand	^self positive</body></methods><methods><class-id>Passport.PassportSignedMetanumber</class-id> <category>private-arithmetic-VW</category><body package="Passport-Kernel-VW" selector="productFromNumber:">productFromNumber: aNumber 	^aNumber isZero 		ifTrue: [0]		ifFalse: [aNumber negative ifTrue: [self negated] ifFalse: [self]]</body></methods><methods><class-id>Passport.PassportSignedMetanumber class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="polarity:">polarity: polarity 	^polarity ifTrue: [self positive] ifFalse: [self negative]</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>private-arithmetic</category><body package="Passport-Kernel" selector="addedToInfinitesimal:">addedToInfinitesimal: anInfinitesimal	^self</body><body package="Passport-Kernel" selector="addedToInfinity:">addedToInfinity: anInfinity	^isNegative == anInfinity negative		ifTrue: [self]		ifFalse: [PassportNotANumber canonical]</body><body package="Passport-Kernel" selector="dividingInfinitesimal:">dividingInfinitesimal: anInfinitesimal	^isNegative == anInfinitesimal negative		ifTrue: [isNegative ifTrue: [anInfinitesimal abs] ifFalse: [anInfinitesimal]]		ifFalse: [isNegative ifTrue: [anInfinitesimal negated] ifFalse: [anInfinitesimal]]</body><body package="Passport-Kernel" selector="dividingInfinity:">dividingInfinity: anInfinity	^PassportNotANumber canonical</body><body package="Passport-Kernel" selector="multipliedByInfinitesimal:">multipliedByInfinitesimal: anInfinitesimal	^PassportNotANumber canonical</body><body package="Passport-Kernel" selector="multipliedByInfinity:">multipliedByInfinity: anInfinity 	^isNegative == anInfinity negative		ifTrue: [isNegative ifTrue: [self abs] ifFalse: [self]]		ifFalse: [isNegative ifTrue: [self] ifFalse: [anInfinity]]</body><body package="Passport-Kernel" selector="subtractedFromInfinitesimal:">subtractedFromInfinitesimal: anInfinitesimal	^self</body><body package="Passport-Kernel" selector="subtractedFromInfinity:">subtractedFromInfinity: anInfinity	^isNegative == anInfinity negative		ifTrue: [PassportNotANumber canonical]		ifFalse: [anInfinity]</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>arithmetic</category><body package="Passport-Kernel" selector="*">* factor 	^factor multipliedByInfinity: self</body><body package="Passport-Kernel" selector="+">+ addend 	^addend addedToInfinity: self</body><body package="Passport-Kernel" selector="-">- subtrahend 	^subtrahend subtractedFromInfinity: self</body><body package="Passport-Kernel" selector="/">/ divisor 	^divisor dividingInfinity: self</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>printing</category><body package="Passport-Kernel" selector="printOn:">printOn: stream	super printOn: stream.	stream nextPutAll: 'infinity'</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>private-comparing</category><body package="Passport-Kernel" selector="compareToInfinitesimal:">compareToInfinitesimal: anInfinitesimal	^isNegative ifTrue: [1] ifFalse: [-1]</body><body package="Passport-Kernel" selector="compareToInfinity:">compareToInfinity: anInfinity 	^anInfinity negative 		ifTrue: [isNegative ifTrue: [0] ifFalse: [-1]]		ifFalse: [isNegative ifTrue: [1] ifFalse: [0]]</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>comparing</category><body package="Passport-Kernel" selector="compareTo:">compareTo: otherMagnitude	"Compare the value of the receiver to that of &lt;otherMagnitude&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;otherMagnitude&gt; are the same.)"	self == otherMagnitude ifTrue: [^0].	^[otherMagnitude compareToInfinity: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == otherMagnitude and: [ex message selector == #compareToInfinity:])					ifTrue: [ex return: (isNegative ifTrue: [-1] ifFalse: [1])]					ifFalse: [ex pass]]</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>testing</category><body package="Passport-Kernel" selector="isInfinite">isInfinite	^true</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>private-comparing-VW</category><body package="Passport-Kernel-VW" selector="lessFromInfinitesimal:">lessFromInfinitesimal: n	^isNegative not</body><body package="Passport-Kernel-VW" selector="lessFromInfinity:">lessFromInfinity: anInfinity	^isNegative		ifTrue: [anInfinity positive]		ifFalse: [false]</body></methods><methods><class-id>Passport.PassportInfinity</class-id> <category>private-arithmetic-VW</category><body package="Passport-Kernel-VW" selector="differenceFromNumber:">differenceFromNumber: aNumber	^self negated</body><body package="Passport-Kernel-VW" selector="quotientFromNumber:">quotientFromNumber: aNumber 	aNumber isZero ifTrue: [^0].	^PassportInfinitesimal polarity: aNumber negative == self negative</body></methods><methods><class-id>Passport.PassportInfinity class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="initialize">initialize	"PassportInfinity initialize."	Positive := nil.	Negative := nil.</body></methods><methods><class-id>Passport.PassportInfinity class</class-id> <category>constants</category><body package="Passport-Kernel" selector="negative">negative	Negative == nil ifTrue: [Negative := self basicNew beNegative].	^Negative</body><body package="Passport-Kernel" selector="positive">positive	Positive == nil ifTrue: [Positive := self basicNew bePositive].	^Positive</body></methods><methods><class-id>Passport.PassportInfinity class</class-id> <category>unit test</category><body package="Passport-Kernel" selector="testDoIts">testDoIts	"1 &gt; PassportInfinity positive 	PassportInfinity positive &lt; 1	1 &lt; PassportInfinity positive 	PassportInfinity positive &gt; 1	1 &gt; PassportInfinity negative 	PassportInfinity negative &lt; 1	1 &lt; PassportInfinity negative 	PassportInfinity negative &gt; 1	PassportInfinity positive &lt; PassportInfinity negative 	PassportInfinity negative &gt; PassportInfinity positive	7 + PassportInfinity positive	PassportInfinity positive + 7	7 - PassportInfinity positive	PassportInfinity positive - 7	7 * PassportInfinity positive	PassportInfinity positive * 7	7 / PassportInfinity positive	PassportInfinity positive / 7	7 + PassportInfinity negative	PassportInfinity negative + 7	7 - PassportInfinity negative	PassportInfinity negative - 7	7 * PassportInfinity negative	PassportInfinity negative * 7	7 / PassportInfinity negative	PassportInfinity negative / 7	-7 + PassportInfinity positive	PassportInfinity positive + -7	-7 - PassportInfinity positive	PassportInfinity positive - -7	-7 * PassportInfinity positive	PassportInfinity positive * -7	-7 / PassportInfinity positive	PassportInfinity positive / -7	-7 + PassportInfinity negative	PassportInfinity negative + -7	-7 - PassportInfinity negative	PassportInfinity negative - -7	-7 * PassportInfinity negative	PassportInfinity negative * -7	-7 / PassportInfinity negative	PassportInfinity negative / -7"</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id> <category>accessing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="annualDate">annualDate	^annualDate</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="annualDateKey">annualDateKey	^annualDate selfDescribingKey</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="maxDaysFromStartOfYearUntilTransitionForYearOfType:">maxDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^(annualDate maxDayOfYearOrdinalForYearOfType: yearTypeCode) - 1</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="minDaysFromStartOfYearUntilTransitionForYearOfType:">minDaysFromStartOfYearUntilTransitionForYearOfType: yearTypeCode	^(annualDate minDayOfYearOrdinalForYearOfType: yearTypeCode) - 1</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="semanticKey">semanticKey		"Answer a value that identifies the conceptual type of the receiver."	^#UntilAnnualDateTimeZoneTransition</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="typeKey">typeKey	^#'Until-Annual-Date-Transition'</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id> <category>initialize-release</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self setAnnualDateKey: (literalArray at: 7)</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="setAnnualDate:">setAnnualDate: anAnnualDate	self assertMutability.	annualDate := anAnnualDate</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="setAnnualDateKey:">setAnnualDateKey: anAnnualDateSelfDescribingKey	self setAnnualDate: (CalendricalAnnualDate at: anAnnualDateSelfDescribingKey)</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id> <category>queries</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDateAndTimeInYear:">transitionDateAndTimeInYear: year 	^self isSpecifiedAsLocalTime 		ifTrue: 			[self annualDate asDateAndTimeInYear: year timeZone: self offsetFromUT]		ifFalse: 			[self isSpecifiedAsStandardTime 				ifTrue: 					[self annualDate asDateAndTimeInYear: year						timeZone: self stdTimeOffsetFromUT asTimezone]				ifFalse: 					[self annualDate asDateAndTimeInUTYear: year timeZone: self offsetFromUT]]</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionDayOfWeekInYear:">transitionDayOfWeekInYear: year	^annualDate ansiDayOfWeekOrdinalInYear: year</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursAfter:">transitionOccursAfter: aDateAndTimeSpec	| diff |	aDateAndTimeSpec == nil ifTrue: [^false].	diff := aDateAndTimeSpec compareTo: self annualDate.	diff &gt; 0 ifTrue: [^false].	diff &lt; 0 ifTrue: [^true].	^aDateAndTimeSpec secondsSinceStartOfDay &lt; transitionSecondsSinceStartOfDay</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnFirstDayOfYear:">transitionOccursOnFirstDayOfYear: year	^annualDate minDayOfYearOrdinal = 1</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnLastDayOfYear:">transitionOccursOnLastDayOfYear: year	^annualDate maxDayOfYearOrdinal = (Gregorian daysInYear: year)</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="transitionOccursOnOrAfter:">transitionOccursOnOrAfter: aDateAndTimeSpec	| diff |	aDateAndTimeSpec == nil ifTrue: [^false].	diff := aDateAndTimeSpec compareTo: self annualDate.	diff &gt; 0 ifTrue: [^false].	diff &lt; 0 ifTrue: [^true].	^aDateAndTimeSpec secondsSinceStartOfDay &lt;= transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id> <category>printing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeOn:">encodeOn: stream	super encodeOn: stream.	stream 		nextPut: $:;		nextPutAll: self annualDateKey.</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="printOn:">printOn: stream	super printOn: stream.	stream		nextPutAll: ' annualDate=';		print: annualDate.	self printTimeOfDayOn: stream.</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id> <category>converting</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="asPolicyFor:">asPolicyFor: anInterYearTimeZonePolicy 	^UntilAnnualDateTimeZoneTransition 		for: anInterYearTimeZonePolicy		offsetSeconds: offsetSecondsFromUT		stdTimeOffsetSeconds: stdTimeOffsetSecondsFromUT		commonAbbreviation: self commonAbbreviation		annualDate: self annualDate		transitionSecondsSinceStartOfDay: transitionSecondsSinceStartOfDay		relativity: relativity</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id> <category>private</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut: self annualDateKey</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory</class-id> <category>processing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	^aTimezoneProcessor processUntilAnnualDateTimeZoneTransition: self</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory class</class-id> <category>instance creation</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:annualDate:transitionSecondsSinceStartOfDay:relativity:">offsetSeconds: secondsFromUTC stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol annualDate: anAnnualDate transitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol	^self new		setOffsetSeconds: secondsFromUTC stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol;		setTransitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol;		setAnnualDate: anAnnualDate;		beImmutable</body><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="offsetSeconds:stdTimeOffsetSeconds:commonAbbreviation:annualDateKey:transitionSecondsSinceStartOfDay:relativity:">offsetSeconds: secondsFromUTC stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol annualDateKey: annualDateRegistrationKey transitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol	^self new		setOffsetSeconds: secondsFromUTC  stdTimeOffsetSeconds: stdTimeSecondsFromUTC commonAbbreviation: aSymbol;		setTransitionSecondsSinceStartOfDay: transitionSeconds relativity: aRelativitySymbol;		setAnnualDateKey: annualDateRegistrationKey;		beImmutable</body></methods><methods><class-id>Chronos.UntilAnnualDateTimeZoneTransitionFactory class</class-id> <category>testing</category><body package="Chronos-TimeZones-PolicyFactories-Annual" selector="isConcrete">isConcrete	^true</body></methods><methods><class-id>Chronos.VWClassicSystemClock</class-id> <category>testing</category><body package="Chronos-System-VW" selector="isRelativeToUT">isRelativeToUT	"If the receiver reports ticks relative to UT, answer true.	If the receiver reports ticks relative to local time, answer false."	^isRelativeToUT</body><body package="Chronos-System-VW" selector="isRelativityDynamic">isRelativityDynamic	"Answer true if the relativity of the receiver (whether it keeps/reports time relative to UT or to local time) may be different in different operating environments (e.g., pre VW7x, the VW system clock is relative to local time on Windows and MacOS Classic, but relative to UT on all other platforms.)"	^true</body></methods><methods><class-id>Chronos.VWClassicSystemClock</class-id> <category>initialize-release</category><body package="Chronos-System-VW" selector="initialize">initialize	super initialize.	self invalidateRelativity</body><body package="Chronos-System-VW" selector="invalidateRelativity">invalidateRelativity	"Reset the receiver's UT/local relativity based on the current operating environment. If the new relativity differs from the old, inform dependents of the change using the aspect #relativity"	| oldRelativity ef |	oldRelativity := isRelativeToUT.	ef := EnvironmentFacade current.	isRelativeToUT := (ef isOnWindows or: [ef isOnMac]) not.	oldRelativity == nil		ifFalse:			[oldRelativity = isRelativeToUT ifFalse: [self changed: #relativity]].</body></methods><methods><class-id>Chronos.VWClassicSystemClock</class-id> <category>API-timing</category><body package="Chronos-System-VW" selector="microsecondsToRun:">microsecondsToRun: timedBlock	^(self millisecondsToRun: timedBlock) * 1000</body><body package="Chronos-System-VW" selector="millisecondsToRun:">millisecondsToRun: timedBlock	^Time millisecondsToRun: timedBlock</body><body package="Chronos-System-VW" selector="nanosecondsToRun:">nanosecondsToRun: timedBlock		^(self millisecondsToRun: timedBlock) * 1000000</body><body package="Chronos-System-VW" selector="ticksNowSinceSystemClockEpoch">ticksNowSinceSystemClockEpoch	"Answer the number of clock ticks since the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0)) up to the current moment. Do not adjust for timezone offset, just answer the raw value provided by the platform system clock (for many Smalltallk implementations, the platform system clock is a software device provided by the virtual machine, and can be accessed via primtive message send.)"		"{| clock |	clock := VWClassicSystemClock new.	DateAndTimeFactory		utSecondsSinceEpoch: (clock secondsFromGregorianEpochUpToSystemClockEpoch + (clock secondsFromTicks: clock ticksNowSinceSystemClockEpoch))		timeZone: Timezone default}" 	^Time secondClock</body></methods><methods><class-id>Chronos.VWClassicSystemClock</class-id> <category>calendar clock binding</category><body package="Chronos-System-VW" selector="secondsFromGregorianEpochUpToSystemClockEpoch">secondsFromGregorianEpochUpToSystemClockEpoch	"Answer the number of seconds from the Epoch date/time of the Proleptic Gregorian Calendar (i.e., January 1, 1 AD  00:00:00 Proleptic Gregorian) up to the Epoch date/time of the platform system clock encapsulated by the receiver (i.e., where clock ticks = 0).  For most Smalltallk implementations, the platform system clock is a software device provided by the virtual machine.  On most operating systems, the system clock's zero point will be 00:00:00 UT of the first day of some Gregorian year.  However, some platforms (e.g., Microsoft Windows) use a zero point that is 00:00:00 (midnight) LOCAL TIME.  Do not adjust the encapsulated clock's tick count from UT to local time, nor from local time to UT.  If the encapsulated clock reports ticks relative to UT, then #secondsFromGregorianEpochUpToSystemClockEpoch should answer the number of seconds since midnight UT of the clock's epoch date, and the instance method #isRelativeToUT should answer true. However, if the encapsulated clock reports ticks relative to local time, then #secondsFromGregorianEpochUpToSystemClockEpoch should answer the number of seconds since midnight local time of the clock's epoch date, and the instance method #isRelativeToUT should answer false.	See the comment for the same method in ChronosSystemClock for help in porting to other systems, or for help in converting to/from foreign system clocks."	"^Calendar gregorian secondsSinceEpochUpToYear: 1901" ^59958144000</body></methods><methods><class-id>Chronos.UniversalTime</class-id> <category>initialize-release</category><body package="Chronos-TimeZones" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	self beImmutable</body></methods><methods><class-id>Chronos.UniversalTime</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-TimeZones" selector="canonicalizeFromLocal:">canonicalizeFromLocal: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time in the local time defined by the receiver, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use Universal Time coordinates instead of local time coordinates.)"	"No action necessary"</body><body package="Chronos-TimeZones" selector="canonicalizeFromUT:">canonicalizeFromUT: aDateAndTime	"Library Private: Collaborate by double-dispatch with &lt;aDateAndTime&gt;, whose internal state currently designates a point-in-time using Universal Time coordinates, so that its internal state will canonically represent its designated point-in-time (the internal state of &lt;aDateAndTime&gt; may need to be partially or completely changed to use coordinates in the local time defined by the receiver instead of using Universal Time coordinates.)"	"No action necessary"</body></methods><methods><class-id>Chronos.UniversalTime</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="commonAbbreviation">commonAbbreviation	"Answer the common abbreviation for the timezone represented by the receiver."	^#UT</body><body package="Chronos-TimeZones" selector="key">key	"Answer the key that identifies the receiver."	^#Universal</body><body package="Chronos-TimeZones" selector="nameIfNone:">nameIfNone: noneBlock	^ChronosLocale default properNameAtSemanticKey: self key ifAbsent: [self defaultNameIfNone: noneBlock]</body><body package="Chronos-TimeZones" selector="netSecondsAfterAddingOffsetFromUTToSeconds:nanosecondsSinceSecond:">netSecondsAfterAddingOffsetFromUTToSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from adding the receiver's offset from UT to the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^seconds</body><body package="Chronos-TimeZones" selector="netSecondsAfterSubtractingOffsetFromUTFromSeconds:nanosecondsSinceSecond:">netSecondsAfterSubtractingOffsetFromUTFromSeconds: seconds nanosecondsSinceSecond: nanosecondsSinceSecond	"Answer the net number of integer seconds (truncated towards zero) that result from subtracting the receiver's offset from UT from the specified number of &lt;seconds&gt; and &lt;nanosecondsSinceSecond&gt;."	^seconds negated</body><body package="Chronos-TimeZones" selector="offsetFromUT">offsetFromUT	"Answer a Duration that specifies the receiver's offset from Universal Time (which is defined as the amount of time to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the local time defined by the receiver.)"	^ZeroDuration</body><body package="Chronos-TimeZones" selector="offsetSecondsFromUT">offsetSecondsFromUT	"Answer the receiver's offset from Universal Time in seconds (which is defined as the number of seconds to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the local time defined by the receiver.)"	^0</body><body package="Chronos-TimeZones" selector="stdTimeOffsetFromUT">stdTimeOffsetFromUT	"Answer a Duration that specifies the receiver's offset from Universal Time when `standard time` is in effect (which is defined as the amount of time to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^ZeroDuration</body><body package="Chronos-TimeZones" selector="stdTimeOffsetSecondsFromUT">stdTimeOffsetSecondsFromUT	"Answer the receiver's offset from Universal Time in seconds when `standard time` is in effect (which is defined as the number of seconds to be added to a temporal coordinate specified in Universal Time in order to derive the equivalent temporal coordinate specified in the `standard time' defined by the receiver.)"	^0</body></methods><methods><class-id>Chronos.UniversalTime</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="canonical">canonical	"Answer the canonical instance of the receiver's class whose value is equivalent to that of the receiver's."	^ChronosTimezone universal</body></methods><methods><class-id>Chronos.UniversalTime</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isUniversalTime">isUniversalTime	"Anwser whether the receiver has all the properties and behaviors of the international reference zero-offset time zone."	^true</body><body package="Chronos-TimeZones" selector="offsetIsZero">offsetIsZero	"Anwser whether the receiver's offset from UT is zero."	^true</body><body package="Chronos-TimeZones" selector="specifiesCommonAbbreviation">specifiesCommonAbbreviation	^true</body><body package="Chronos-TimeZones" selector="specifiesName">specifiesName	^true</body></methods><methods><class-id>Chronos.UniversalTime</class-id> <category>private</category><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneBlock	^'Universal Time'</body></methods><methods><class-id>Chronos.UniversalTime class</class-id> <category>private</category><body package="Chronos-TimeZones" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self universal</body></methods><methods><class-id>Passport.ResourcePathContext</class-id> <category>accessing</category><body package="Passport-Kernel" selector="defaultFacade">defaultFacade	^self facadeAt: self defaultProtocol</body><body package="Passport-Kernel" selector="defaultHostnameAt:">defaultHostnameAt: protocolSymbol	^self defaultHostnameAt: protocolSymbol ifAbsent: [#localhost]</body><body package="Passport-Kernel" selector="defaultHostnameAt:ifAbsent:">defaultHostnameAt: protocolSymbol ifAbsent: ifAbsent 	| hostname |	hostname := (defaultHostNamesAndPortsByProtocol at: protocolSymbol ifAbsent: [^ifAbsent value]) key.	^hostname == nil 		ifTrue: [ifAbsent value]		ifFalse: [hostname]</body><body package="Passport-Kernel" selector="defaultHostnameAt:put:">defaultHostnameAt: protocolSymbol put: aStringOrSymbol 	^(defaultHostNamesAndPortsByProtocol at: protocolSymbol		ifAbsentPut: [Association new]) key: 			(aStringOrSymbol == nil 				ifTrue: [#localhost]				ifFalse: [aStringOrSymbol asSymbol])</body><body package="Passport-Kernel" selector="defaultNamespaceAt:ifAbsent:">defaultNamespaceAt: protocolSymbol ifAbsent: ifAbsent 	^defaultNamespacesByProtocol at: protocolSymbol ifAbsent: ifAbsent</body><body package="Passport-Kernel" selector="defaultNamspaceAt:put:">defaultNamspaceAt: protocolSymbol put: aStringOrNil	(UtilityFunction isNilOrEmpty: aStringOrNil)		ifTrue: [defaultNamespacesByProtocol removeKey: protocolSymbol ifAbsent: []]		ifFalse: [defaultNamespacesByProtocol at: protocolSymbol put: aStringOrNil]</body><body package="Passport-Kernel" selector="defaultPassword">defaultPassword	^defaultPassword</body><body package="Passport-Kernel" selector="defaultPassword:">defaultPassword: aString	defaultPassword := aString == nil ifTrue: [''] ifFalse: [aString]</body><body package="Passport-Kernel" selector="defaultPortAt:">defaultPortAt: protocolSymbol	^self defaultPortAt: protocolSymbol ifAbsent: [-1]</body><body package="Passport-Kernel" selector="defaultPortAt:ifAbsent:">defaultPortAt: protocolSymbol ifAbsent: ifAbsent 	| port |	port := (defaultHostNamesAndPortsByProtocol at: protocolSymbol ifAbsent: [^ifAbsent value]) value.	^port == nil 		ifTrue: [ifAbsent value]		ifFalse: [port]</body><body package="Passport-Kernel" selector="defaultPortAt:put:">defaultPortAt: protocolSymbol put: portNumber	^(defaultHostNamesAndPortsByProtocol at: protocolSymbol ifAbsentPut: [nil-&gt;nil]) value: portNumber</body><body package="Passport-Kernel" selector="defaultProtocol">defaultProtocol	^defaultProtocol</body><body package="Passport-Kernel" selector="defaultProtocol:">defaultProtocol: protocolSymbol	defaultProtocol := protocolSymbol == nil ifTrue: [#platform] ifFalse: [protocolSymbol asSymbol]</body><body package="Passport-Kernel" selector="defaultResourcePath">defaultResourcePath	^ResourcePath context: self</body><body package="Passport-Kernel" selector="defaultUser">defaultUser	^defaultUser</body><body package="Passport-Kernel" selector="defaultUser:">defaultUser: aString	defaultUser := aString == nil ifTrue: [''] ifFalse: [aString]</body><body package="Passport-Kernel" selector="facadeAt:">facadeAt: protocolSymbol	protocolSymbol == nil ifTrue: [self signalError: 'Resource access protocol must not be nil'].	^self facadeAt: protocolSymbol ifAbsent: [self signalError: 'Resource access protocol not supported: ', protocolSymbol]</body><body package="Passport-Kernel" selector="facadeAt:ifAbsent:">facadeAt: protocolSymbol ifAbsent: ifAbsent 	^facadesByProtocol at: protocolSymbol		ifAbsentPut: 			[((EnvironmentFacade current				resourcePathFacadeFactoryReferenceAt: protocolSymbol				ifAbsent: [^ifAbsent value]) valueIfNone: [^ifAbsent value]) resourcePathContext: self]</body><body package="Passport-Kernel" selector="pathDescriptionAt:ifNone:">pathDescriptionAt: semanticKey ifNone: ifNone	^pathDescriptions at: semanticKey ifAbsent: ifNone</body><body package="Passport-Kernel" selector="pathDescriptionAt:put:">pathDescriptionAt: semanticKey put: aString	pathDescriptions at: semanticKey put: aString</body><body package="Passport-Kernel" selector="resourcePathTo:ifNone:">resourcePathTo: semanticKey ifNone: ifNone	"Answer a ResourcePath to the absolute resource pathname signified by the specified &lt;semanticKey&gt; (aSymbol.) The &lt;semanticKey&gt; identifies the logical role, function, purpose or intended usage of the resource, and does not explicitly describe or contain the name of any resource. It is the responsibility of the receiver to maintain a mapping from resource semantic keys to resource pathnames, and to construct ResourcePaths based on the name of the resource identified by the &lt;semanticKey&gt;.  Since Chronos only needs to use a small set of semantic keys for resources, it is acceptable to simply 'hard code' the mappings from &lt;semanticKey&gt; to resource pathname.  But ideally, the mapping information sould be maintained in a configuration file, database or remote reference data server.	The well-known pathnames and associated semantic keys used by the Chronos codebase:				Semantic Key							Role/function/purpose/usage of associated pathname		#TZRepository							The directory that contains the Chronos TimeZone specification files, and the zone alias file													(these files are generated by the Chronos TimeZone Administrator.)		#TZLocalizationPolicyRepository		The directory that contains the Chronos TimeZoneLocalizationPolicy definition files													(the default versions of these files are generated by the Chronos TimeZone Administrator.)		#TZForeignKeyMappings				The directory that contains files that associate foreign timezone keys with those used by Chronos.		#OlsonZoneInfoSourcesDirectory	The directory/folder containing the source files (text) for the Olson Timezone Database 													(used only by the Chronos TimeZone Administrator.)"	^pathMap at: semanticKey ifAbsent: ifNone</body><body package="Passport-Kernel" selector="resourcePathTo:put:">resourcePathTo: semanticKey put: aResourcePath	pathMap at: semanticKey put: aResourcePath</body></methods><methods><class-id>Passport.ResourcePathContext</class-id> <category>error signalling/handling</category><body package="Passport-Kernel" selector="handleNonExistenceOfResourcePathReferencedBy:">handleNonExistenceOfResourcePathReferencedBy: semanticKey	self reportInaccessibleResourcePath: semanticKey.		^false</body><body package="Passport-Kernel" selector="reportInaccessibleResourcePath:">reportInaccessibleResourcePath: aResourcePathKey 	| rp description |	rp := self resourcePathTo: aResourcePathKey ifNone: [].	description := self pathDescriptionAt: aResourcePathKey				ifNone: ['The ' , aResourcePathKey , ' persistent/remote resource'].	self reportToConsole: description , ' was not accessible at the path ' 				, (rp == nil 						ifTrue: [aResourcePathKey printString]						ifFalse: [rp printString])</body></methods><methods><class-id>Passport.ResourcePathContext</class-id> <category>testing</category><body package="Passport-Kernel" selector="hasDefaultPassword">hasDefaultPassword	^(UtilityFunction isNilOrEmpty: self defaultPassword) not</body><body package="Passport-Kernel" selector="hasDefaultUser">hasDefaultUser	^(UtilityFunction isNilOrEmpty: self defaultUser) not</body><body package="Passport-Kernel" selector="isDefault">isDefault	^self == self class default</body><body package="Passport-Kernel" selector="isNonBinding">isNonBinding	^self isPlatformDefault</body><body package="Passport-Kernel" selector="isPlatformDefault">isPlatformDefault	^self == PlatformDefault</body><body package="Passport-Kernel" selector="specifiesDefaultNamespaceAt:">specifiesDefaultNamespaceAt: protocolSymbol 	^defaultNamespacesByProtocol includesKey: protocolSymbol</body></methods><methods><class-id>Passport.ResourcePathContext</class-id> <category>initialize-release</category><body package="Passport-Kernel" selector="beDefault">beDefault	Default := self</body><body package="Passport-Kernel" selector="bePlatformDefault">bePlatformDefault	PlatformDefault := self</body><body package="Passport-Kernel" selector="initialize">initialize	self initializeFacades.	self initializeDefaults.	self initializePathMap</body><body package="Passport-Kernel" selector="initializeDefaults">initializeDefaults	defaultProtocol := #platform.	self initializePasswords.		defaultHostNamesAndPortsByProtocol := IdentityDictionary new.	defaultNamespacesByProtocol := IdentityDictionary new.	self class initializeWithDefaultPorts: self.</body><body package="Passport-Kernel" selector="initializeFacades">initializeFacades	facadesByProtocol := IdentityDictionary new.</body><body package="Passport-Kernel" selector="initializePasswords">initializePasswords	defaultUser := ''.	defaultPassword := ''.</body><body package="Passport-Kernel" selector="initializePathMap">initializePathMap	pathMap := IdentityDictionary new.	pathDescriptions := IdentityDictionary new.</body></methods><methods><class-id>Passport.ResourcePathContext</class-id> <category>enumerating</category><body package="Passport-Kernel" selector="resourcePathsDo:">resourcePathsDo: block2	pathMap keysAndValuesDo: block2</body></methods><methods><class-id>Passport.ResourcePathContext</class-id> <category>queries</category><body package="Passport-Kernel" selector="resourcePathsExist">resourcePathsExist	self resourcePathsDo: [:key :rp | rp exists ifFalse: [^false]].	^true</body></methods><methods><class-id>Passport.ResourcePathContext</class-id> <category>copying</category><body package="Passport-Kernel" selector="postCopy">postCopy	"PRECONDTION: The receiver has just been instantiated as a #shallowCopy of another object.  	POSTCONDITION: In response to this message, the receiver is required to make itself satisfy the following conditions and constraints: 1) It must be mutable,  2) It must compare (#=) as equal to the object from which it was shallowCopied, and 3) It must satisfy the following constraints: a) whenever the receiver mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the object from which it was shallowCopied must not be changed, and b) whenever the object from which the receiver was shallowCopied mutates the internal state of any object to which it refers as an attributive value (i.e., not as the target of an associative reference,) the state and behavior of the receiver must not be changed.  An associative reference is one where the semantics of the reference depend in any way on the object identity (#==) of the referenced object.  An attributive reference is one where any referenced object with the same value can transparently be substituted for any other such value-equivalent object without causing any error."	"Subclasses may need to subimplement this message in order to satisfy the required semantics.  All subimplementers should send #postCopy to super."	EnvironmentFacade current makeMutable: self.	facadesByProtocol := facadesByProtocol copy.	defaultHostNamesAndPortsByProtocol := defaultHostNamesAndPortsByProtocol copy.	defaultNamespacesByProtocol := defaultNamespacesByProtocol copy.	pathMap := pathMap copy.</body></methods><methods><class-id>Passport.ResourcePathContext class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="basicInvalidateFacades">basicInvalidateFacades	self allInstancesDo: [:each | each initializeFacades]</body><body package="Passport-Kernel" selector="initialize">initialize	"ResourcePathContext initialize"	Default := nil.	PlatformDefault := nil.	DefaultPortsByProtocol := nil</body><body package="Passport-Kernel" selector="invalidateFacades">invalidateFacades	self basicInvalidateFacades.	self subclasses do: [:each | each invalidateFacades]</body></methods><methods><class-id>Passport.ResourcePathContext class</class-id> <category>accessing</category><body package="Passport-Kernel" selector="default">default	"Answer the default instance of the receiver"	"ResourcePathContext default"	Default == nil ifTrue: [^self platformDefault].	^Default</body><body package="Passport-Kernel" selector="defaultPortAt:">defaultPortAt: protocolSymbol	DefaultPortsByProtocol == nil ifTrue: [self setDefaultPortsByProtocol].	^DefaultPortsByProtocol at: protocolSymbol ifAbsent: [-1]</body><body package="Passport-Kernel" selector="platformDefault">platformDefault	"Answer the default instance of the receiver for use with resources on the host platform"	"ResourcePathContext platformDefault"	PlatformDefault == nil ifTrue: [self new bePlatformDefault].	^PlatformDefault</body></methods><methods><class-id>Passport.ResourcePathContext class</class-id> <category>private</category><body package="Passport-Kernel" selector="initializeWithDefaultPorts:">initializeWithDefaultPorts: aResourcePathContext	DefaultPortsByProtocol == nil ifTrue: [self setDefaultPortsByProtocol].	DefaultPortsByProtocol 		keysAndValuesDo: [:protocol :port | aResourcePathContext defaultPortAt: protocol put: port]</body><body package="Passport-Kernel" selector="setDefaultPortsByProtocol">setDefaultPortsByProtocol	DefaultPortsByProtocol := IdentityDictionary new.	DefaultPortsByProtocol		at: #platform put: -1;		at: #file put: -1;		at: #http put: 80;		at: #https put: 443;		at: #ftp put: 21;		at: #ldap put: 389</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>canonical path suffixes</category><body package="Chronos-System" selector="leapSecondSchedulesDirectoryName">leapSecondSchedulesDirectoryName	^'leap-seconds'</body><body package="Chronos-System" selector="olsonZoneinfoSourcesDirectoryName">olsonZoneinfoSourcesDirectoryName	^'Olson-zoneinfo-sources'</body><body package="Chronos-System" selector="timeZoneResourcesDirectoryName">timeZoneResourcesDirectoryName	^'time-zones'</body><body package="Chronos-System" selector="timezoneExtension">timezoneExtension	^'tzn'</body><body package="Chronos-System" selector="timezoneForeignKeyDirectoryName">timezoneForeignKeyDirectoryName	^'foreign-keys'</body><body package="Chronos-System" selector="timezoneLocalizationPolicyDirectoryName">timezoneLocalizationPolicyDirectoryName	^'localization-policies'</body><body package="Chronos-System" selector="timezoneRulesetDirectoryName">timezoneRulesetDirectoryName	^'rulesets'</body><body package="Chronos-System" selector="tzLocalizationPolicyExtension">tzLocalizationPolicyExtension	^'tzl'</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>installation</category><body package="Chronos-System" selector="install">install	| success |	self invalidateResourcePaths.	ChronosSystemFacade current reportResourcePathnameMappings.	self setTimeZoneResourceBroker.	self setTzLocalizationPolicyResourceBroker.	TimeZonePolicyFactory initialize.	ChronosTimezone invalidate.	LeapSecondSchedule invalidateUTC.	success := 		self invalidateWindowsToOlsonTZKeyMappings 			and: [self invalidateTimeZoneKeys 				and: [self invalidateTimeZoneAliases					and: [self invalidateCountryCodeToCountryNameMappings]]].	success 		ifTrue: 			[[DateAndTimeFactory invalidateTimezones] 				on: Error				do: 					[:ex | 					ChronosSystemFacade current reportTimeZoneInvalidationFailure: ex.					ex return]].	EnvironmentFacade current performGarbageCollection.	^success</body><body package="Chronos-System" selector="invalidateCountryCodeToCountryNameMappings">invalidateCountryCodeToCountryNameMappings	"The memory-resident map of country-code to country-name mappings may be stale. Reload it from the canonical persistent data source. Answer true if successful, false otherwise."	"{ChronosSystemFacade current resourceRepositoryContext invalidateCountryCodeToCountryNameMappings}"	| rp stream |	rp := self 			resourcePathTo: #OlsonZoneInfoSourcesDirectory			ifNone: [self signal: Error message: 'The system has no reference to the directory containing the mappings to country names from country codes.'].	rp exists 		ifFalse: 				[self invalidateResourcePaths.			rp := self resourcePathTo: #OlsonZoneInfoSourcesDirectory ifNone: [rp]].	rp exists 		ifFalse: 			[(self handleNonExistenceOfResourcePathReferencedBy: #OlsonZoneInfoSourcesDirectory) ifFalse: [^false].			rp := self resourcePathTo: #OlsonZoneInfoSourcesDirectory ifNone: [rp]].	rp := rp appending: 'iso3166.tab'.	rp exists 		ifFalse: 			[self reportInaccessibleResource: rp.			^false].	stream := rp readStream.	[TimeZoneLocalizationPolicy parseCountryCodeToNameMappingsFrom: stream] 			ensure: [stream close].	^true</body><body package="Chronos-System" selector="invalidateResourcePaths">invalidateResourcePaths	"The resource paths may be invalid.  Reinitialize them."	"{ChronosSystemFacade current resourceRepositoryContext invalidateResourcePaths}"	| oldResourcePathPrefix |	self resourcePathsExist ifTrue: [^true].	oldResourcePathPrefix := resourcePathPrefix.	^(self findValidResourcePathPrefix: 			[:resourcePathPrefixString | 			self resourcePathPrefix: resourcePathPrefixString]) 		ifTrue: [true]		ifFalse: 			[resourcePathPrefix := oldResourcePathPrefix.			false]</body><body package="Chronos-System" selector="invalidateTimeZoneAliases">invalidateTimeZoneAliases	"The memory-resident cache of timezone aliases may be stale. Reload it from the canonical persistent data source. Answer true if successful, false otherwise."	"{ChronosSystemFacade current resourceRepositoryContext invalidateTimeZoneAliases}"	| rp stream |	rp := self 				resourcePathTo: #TZRepository				ifNone: [self signal: Error message: 'The system has no reference to the directory containing the timezone rule definitions.'].	rp exists 		ifFalse: 				[self invalidateResourcePaths.			rp := self resourcePathTo: #TZRepository ifNone: [rp]].	rp exists 		ifFalse: 			[(self handleNonExistenceOfResourcePathReferencedBy: #TZRepository) ifFalse: [^false].			rp := self resourcePathTo: #TZRepository ifNone: [rp]].	rp := rp appending: 'aliases'.	rp exists 		ifFalse: 			[self reportInaccessibleResource: rp.			^false].	[stream := rp readStream.	[ChronosFunction skipSeparators: stream.	stream atEnd] whileFalse: 				[| canonicalKey line aliases |				canonicalKey := TimeZonePolicyFactory registrationKeyFrom: stream.				line := ChronosFunction nextLineFrom: stream.				aliases := ChronosFunction componentsFromString: line separator: $ .				aliases do: 						[:aliasingKeyString | 						TimeZonePolicyFactory alias: canonicalKey as: aliasingKeyString asSymbol]]] 			ensure: [stream close].	^true</body><body package="Chronos-System" selector="invalidateTimeZoneKeys">invalidateTimeZoneKeys	"The memory-resident cache of timezone keys may be stale. Reload it from the canonical persistent data source. Answer true if successful, false otherwise."	"{ChronosSystemFacade current resourceRepositoryContext invalidateTimeZoneKeys}"	| rp stream |	rp := self 				resourcePathTo: #TZRepository				ifNone: [self signal: Error message: 'The system has no reference to the directory containing the timezone rule definitions.'].	rp exists 		ifFalse: 				[self invalidateResourcePaths.			rp := self resourcePathTo: #TZRepository ifNone: [rp]].	rp exists 		ifFalse: 			[(self handleNonExistenceOfResourcePathReferencedBy: #TZRepository) ifFalse: [^false].			rp := self resourcePathTo: #TZRepository ifNone: [rp]].	rp := rp appending: 'index'.	rp exists 		ifFalse: 			[self reportInaccessibleResource: rp.			^false].	[stream := rp readStream.		[ChronosFunction skipSeparators: stream.	stream atEnd] whileFalse: 				[| key |				key := (ChronosFunction nextLineFrom: stream) asSymbol.				TimeZonePolicyFactory define: key]] 			ensure: [stream close].	^true</body><body package="Chronos-System" selector="invalidateVersionAndTimestamp">invalidateVersionAndTimestamp	"{ChronosSystemFacade current resourceRepositoryContext invalidateVersionAndTimestamp}"	| rp stream |	rp := ResourcePath context: self components: (Array with: self timeZoneResourcesDirectoryName).	rp := rp appending: 'version'.	^[stream := rp readStream.	[(ChronosFunction nextLineFrom: stream) = self versionTextHeading ifFalse: [stream close. ^false].	ChronosFunction skipSeparators: stream.	(stream upTo: $:) = 'version' ifFalse: [stream close. ^false].	ChronosFunction skipSeparators: stream.	version := ChronosFunction nextFrom: stream until: [:ch | ch isSeparator].	ChronosFunction skipToNextLineOf: stream.	ChronosFunction skipSeparators: stream.	(stream upTo: $:) = 'timestamp' ifFalse: [stream close. ^false].	ChronosFunction skipSeparators: stream.	timestamp := DateAndTimeFactory readFrom: stream.	true] ensure: [stream close]] on: Error do: [:ex | ex return: false]</body><body package="Chronos-System" selector="invalidateWindowsToOlsonTZKeyMappings">invalidateWindowsToOlsonTZKeyMappings	"The memory-resident map of Windows to Olson timezone keys may be stale. Reload it from the canonical persistent data source. Answer true if successful, false otherwise."	"{ChronosSystemFacade current resourceRepositoryContext invalidateWindowsToOlsonTZKeyMappings}"	| rp stream |	rp := self 			resourcePathTo: #TZForeignKeyMappings			ifNone: [self signal: Error message: 'The system has no reference to the directory containing the mappings to Olson timezone keys from foreign timezone keys.'].	rp exists 		ifFalse: 				[self invalidateResourcePaths.			rp := self resourcePathTo: #TZForeignKeyMappings ifNone: [rp]].	rp exists 		ifFalse: 			[(self handleNonExistenceOfResourcePathReferencedBy: #TZForeignKeyMappings) ifFalse: [^false].			rp := self resourcePathTo: #TZForeignKeyMappings ifNone: [rp]].	rp := rp appending: 'windows'.	rp exists 		ifFalse: 			[self reportInaccessibleResource: rp.			^false].	stream := rp readStream.	[TimeZonePolicyFactory parseWindowsToOlsonTZKeyMappingsFrom: stream] 			ensure: [stream close].	^true</body><body package="Chronos-System" selector="retrieveLeapSecondSchedule:ifNone:">retrieveLeapSecondSchedule: key ifNone: ifNoneBlock	| rp stream lss |	rp := self resourcePathTo: #LeapSecondScheduleRepository				ifNone: [^ifNoneBlock value].	rp := rp appending: key.	rp := rp appendingExtension: 'lss'.	rp exists ifFalse: [^ifNoneBlock value].	stream := rp readStream.	[lss := LeapSecondSchedule decodeFrom: stream] ensure: [stream close].	^lss</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>services/utilities</category><body package="Chronos-System" selector="logVersionAndTimestamp">logVersionAndTimestamp	"ChronosResourceRepositoryContext default logVersionAndTimestamp"	| rp stream |	rp := ResourcePath context: self components: (Array with: self timeZoneResourcesDirectoryName).	rp := rp appending: 'version'.	stream := rp newWriteStream.	[stream 		nextPutAll: self versionTextHeading; cr; cr;		nextPutAll: 'version: ';  nextPutAll: self version; cr;		nextPutAll: 'timestamp: '; print: self timestamp] 			ensure: [stream close].</body><body package="Chronos-System" selector="persistCanonicalTimeZoneKeys">persistCanonicalTimeZoneKeys	"Store the memory-resident cache of canonical timezone keys into the canonical persistent data store for storing timezone information."	| rp stream |	rp := self				resourcePathTo: #TZRepository				ifNone: [self signalError: 'The system has no reference to the directory containing the timezone rule definitions.'].	rp := rp appending: 'index'.		[stream := rp newWriteStream.	TimeZonePolicyFactory writeCanonicalKeysOn: stream] ensure: [stream close]</body><body package="Chronos-System" selector="persistTimeZoneAliases">persistTimeZoneAliases	"Store the memory-resident cache of timezone aliases into the canonical persistent data store for storing timezone aliases."	| rp stream |	rp := self resourcePathTo: #TZRepository ifNone: [self signal: Error message: 'The system has no reference to the directory containing the timezone rule definitions.'].	rp := rp appending: 'aliases'.	[stream := rp newWriteStream.	TimeZonePolicyFactory writeAliasesOn: stream] 			ensure: [stream close].</body><body package="Chronos-System" selector="storeLeapSecondSchedule:">storeLeapSecondSchedule: lss	| rp stream |	rp := self resourcePathTo: #LeapSecondScheduleRepository ifNone: [].	rp makeDirectory.	rp := rp appending: lss registrationKey.	rp := rp appendingExtension: 'lss'.	stream := rp newWriteStream.	[lss encodeOn: stream] ensure: [stream close].</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>accessing</category><body package="Chronos-System" selector="resourcePathPrefix">resourcePathPrefix	^resourcePathPrefix</body><body package="Chronos-System" selector="resourcePathPrefix:">resourcePathPrefix: prefixString 	| newResourcePathPrefix rp |	newResourcePathPrefix := (ChronosFunction isNilOrEmpty: prefixString) ifFalse: [prefixString].	resourcePathPrefix = newResourcePathPrefix ifTrue: [^self resourcePathsExist].	rp := newResourcePathPrefix == nil 			ifTrue: [ResourcePath currentDirectory] 			ifFalse: 				[[ResourcePath fromString: newResourcePathPrefix] 					on: Error 					do: [:ex | ChronosSystemFacade current 									reportException: ex 									message: 'Unable to change the resource path prefix to the value specified due to the following error: '. ^false]].	self setToDefaultConfiguration.	rp setNonDefaultSpecifiedAttributesAsDefaultsInContext: self.	^self resourcePathsExist 		ifTrue: 			[resourcePathPrefix := newResourcePathPrefix.			true]		ifFalse: 			[self setToDefaultConfiguration.			resourcePathPrefix == nil 				ifFalse: 					[rp := ResourcePath fromString: resourcePathPrefix.					rp setNonDefaultSpecifiedAttributesAsDefaultsInContext: self].			false]</body><body package="Chronos-System" selector="timeZoneResourceBroker">timeZoneResourceBroker	timeZoneResourceBroker == nil ifTrue: [self setTimeZoneResourceBroker].	^timeZoneResourceBroker</body><body package="Chronos-System" selector="timestamp">timestamp	^timestamp == nil ifTrue: [DateAndTimeFactory utNow] ifFalse: [timestamp]</body><body package="Chronos-System" selector="tzLocalizationPolicyResourceBroker">tzLocalizationPolicyResourceBroker	tzLocalizationPolicyResourceBroker == nil ifTrue: [self setTzLocalizationPolicyResourceBroker].	^tzLocalizationPolicyResourceBroker</body><body package="Chronos-System" selector="version">version	^version == nil ifTrue: ['unknown'] ifFalse: [version]</body><body package="Chronos-System" selector="version:">version: aVersionString	"ChronosResourceRepositoryContext default version: 'Olson/2006b'"	aVersionString = version		ifFalse:			[version := aVersionString.			timestamp := DateAndTimeFactory utNow].</body><body package="Chronos-System" selector="versionTextHeading">versionTextHeading	^'## Chronos Time Zone Repository ##'</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>initialize-release</category><body package="Chronos-System" selector="initialize">initialize	super initialize.	resourcePathPrefix := nil. 	"Relative to current working directory by default."	self		setDefaultHostnames;		setCanonicalPathnameSuffixes;		setPathDescriptions.</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>private</category><body package="Chronos-System" selector="findValidResourcePathPrefix:">findValidResourcePathPrefix: block1	^ChronosSystemFacade current findValidResourcePathPrefix: block1</body><body package="Chronos-System" selector="setCanonicalPathnameSuffixes">setCanonicalPathnameSuffixes	"Set the path suffixes of the Chronos resources (e.g., timezone rulesets, timezone localization policies, etc.) to their standard values."	"{ChronosSystemFacade current resourcePathContext setCanonicalPathnameSuffixes}"	self 		resourcePathTo: #LeapSecondScheduleRepository			put: (ResourcePath 					context: self					components: (Array with: self timeZoneResourcesDirectoryName with: self leapSecondSchedulesDirectoryName));		resourcePathTo: #TZRepository			put: (ResourcePath 					context: self					components: (Array with: self timeZoneResourcesDirectoryName with: self timezoneRulesetDirectoryName));		resourcePathTo: #TZLocalizationPolicyRepository			put: (ResourcePath 					context: self					components: (Array with: self timeZoneResourcesDirectoryName with: self timezoneLocalizationPolicyDirectoryName));		resourcePathTo: #TZForeignKeyMappings			put: (ResourcePath 					context: self					components: (Array with: self timeZoneResourcesDirectoryName with: self timezoneForeignKeyDirectoryName));		resourcePathTo: #OlsonZoneInfoSourcesDirectory			put: (ResourcePath 					context: self					components: (Array with: self timeZoneResourcesDirectoryName with: self olsonZoneinfoSourcesDirectoryName)).</body><body package="Chronos-System" selector="setDefaultHostnames">setDefaultHostnames	self		defaultHostnameAt: #http put: #'date-time-zone.com';			defaultHostnameAt: #https put: #'date-time-zone.com'</body><body package="Chronos-System" selector="setPathDescriptions">setPathDescriptions	self 		pathDescriptionAt: #LeapSecondScheduleRepository put: 'The directory containing leap second schedules.';		pathDescriptionAt: #TZRepository put: 'The directory containing timezone ruleset definitions';		pathDescriptionAt: #TZLocalizationPolicyRepository put: 'The directory containing timezone localization policy definitions';		pathDescriptionAt: #TZForeignKeyMappings put: 'The directory containing mappings from non-Olson timezone keys (e.g., Windows) to Olson timezone keys';		pathDescriptionAt: #OlsonZoneInfoSourcesDirectory put: 'The directory containing the source Olson timezone rulesets from which Chronos compiles its timezone rulesets'</body><body package="Chronos-System" selector="setTimeZoneResourceBroker">setTimeZoneResourceBroker	timeZoneResourceBroker := ResourceBroker new.	timeZoneResourceBroker		context: self;		factory: TimeZonePolicyFactory;		baseDirectoryKey: #TZRepository;		elementExtension: self timezoneExtension</body><body package="Chronos-System" selector="setToDefaultConfiguration">setToDefaultConfiguration	self initializeDefaults.	self setDefaultHostnames.</body><body package="Chronos-System" selector="setTzLocalizationPolicyResourceBroker">setTzLocalizationPolicyResourceBroker	tzLocalizationPolicyResourceBroker := ResourceBroker new.	tzLocalizationPolicyResourceBroker		context: self;		factory: TimeZoneLocalizationPolicy;		baseDirectoryKey: #TZLocalizationPolicyRepository;		elementExtension: self tzLocalizationPolicyExtension</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>queries</category><body package="Chronos-System" selector="resourcePathsExist">resourcePathsExist	"ChronosResourceRepositoryContext default resourcePathsExist"	^self invalidateVersionAndTimestamp or: [super resourcePathsExist]</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext</class-id> <category>error signalling/handling</category><body package="Chronos-System" selector="handleNonExistenceOfResourcePathReferencedBy:">handleNonExistenceOfResourcePathReferencedBy: semanticKey 	| rp |	rp := self resourcePathTo: semanticKey				ifNone: [^super handleNonExistenceOfResourcePathReferencedBy: semanticKey].	self invalidateResourcePaths 		ifTrue: 			[rp := self resourcePathTo: semanticKey ifNone: [].			rp exists ifTrue: [^true]].	^super handleNonExistenceOfResourcePathReferencedBy: semanticKey</body><body package="Chronos-System" selector="reportInaccessibleResource:">reportInaccessibleResource: resourcePath 	self reportToConsole: resourcePath printString 				, ' persistent/remote resource is not accessible.'</body></methods><methods><class-id>Chronos.ChronosResourceRepositoryContext class</class-id> <category>accessing</category><body package="Chronos-System" selector="default">default	^ChronosSystemFacade resourceRepositoryContext</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec</class-id> <category>accessing</category><body package="Chronos-Calendars-Foundation" selector="daysPerMonth">daysPerMonth	"Answer the number of days in the month whose properties are specified by the receiver."	^daysPerMonth</body><body package="Chronos-Calendars-Foundation" selector="leapDayOrdinals">leapDayOrdinals	^leapDayOrdinals</body><body package="Chronos-Calendars-Foundation" selector="monthKey">monthKey	"Answer the semantic key that identifies the receiver's month."	^key == nil ifTrue: [#'no-month-specified'] ifFalse: [key]</body><body package="Chronos-Calendars-Foundation" selector="monthName">monthName	"Answer the name of the receiver's month according to the current default ChronosLocale."	^ChronosLocale default properNameAtSemanticKey: self nameKey</body><body package="Chronos-Calendars-Foundation" selector="nameKey">nameKey	^nameKey == nil ifTrue: [self monthKey] ifFalse: [nameKey]</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec</class-id> <category>testing</category><body package="Chronos-Calendars-Foundation" selector="hasLeapDayAt:">hasLeapDayAt: dayOfMonthOrdinal	"Answer whether the day of the receiver's month with the given &lt;dayOfMonthOrdinal&gt; is a leap day."	^leapDayOrdinals includes: dayOfMonthOrdinal</body><body package="Chronos-Calendars-Foundation" selector="hasLeapDays">hasLeapDays	"Answer whether there are any leap days in the receiver's month."	^leapDayOrdinals size &gt; 0</body><body package="Chronos-Calendars-Foundation" selector="isIntercalaryMonth">isIntercalaryMonth	"Answer whether the receiver's month is an intercalary month. An intercalary month is one that either a) does not occur every year, and/or b) does not have nearly the same number of days as the majority of months in the year."	^occurrenceType ~= Standard</body><body package="Chronos-Calendars-Foundation" selector="isLeapMonth">isLeapMonth	"Answer true if the month represented by the receiver does not occur in every type of year."	^occurrenceType = LeapIntercalary</body><body package="Chronos-Calendars-Foundation" selector="isStandardMonth">isStandardMonth	"Answer whether the receiver's month is a 'normal' month. A normal month is one that a) occurs every year, and b) has about the same number of days as the majority of months in the year."	^occurrenceType = Standard</body><body package="Chronos-Calendars-Foundation" selector="occursEveryYear">occursEveryYear	"Answer whether the month represented by the receiver occurs in each and every type of year of the receiver's calendrical system."	^occurrenceType ~= LeapIntercalary</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut:key;		nextPut: nameKey;		nextPut: daysPerMonth;		nextPut: occurrenceType;		nextPut: leapDayOrdinals</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	self assertMutability.	daysPerMonth := 0.	occurrenceType := Standard.	leapDayOrdinals := #()</body><body package="Chronos-Calendars-Foundation" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setKey: (literalArray at: 2);		setNameKey: (literalArray at: 3);		setDaysPerMonth: (literalArray at: 4) asNumber;		setOccurrenceType: (literalArray at: 5) asNumber;		setLeapDayOrdinals: (literalArray at: 6)</body><body package="Chronos-Calendars-Foundation" selector="setDaysPerMonth:">setDaysPerMonth: daysInMonth	self assertMutability.	daysPerMonth := daysInMonth.</body><body package="Chronos-Calendars-Foundation" selector="setKey:">setKey: anIdentifyingSymbol	self assertMutability.	key := anIdentifyingSymbol == nil ifFalse: [anIdentifyingSymbol asSymbol].</body><body package="Chronos-Calendars-Foundation" selector="setKey:daysPerMonth:occurrenceType:leapDayOrdinals:">setKey: anIdentifyingSymbol daysPerMonth: daysInMonth occurrenceType: occType leapDayOrdinals: leapDays	key := anIdentifyingSymbol.	daysPerMonth := daysInMonth.	occurrenceType := occType.	leapDayOrdinals := leapDays == nil ifTrue: [#()] ifFalse: [leapDays].</body><body package="Chronos-Calendars-Foundation" selector="setLeapDayOrdinals:">setLeapDayOrdinals: leapDays	self assertMutability.	leapDayOrdinals := leapDays == nil ifTrue: [#()] ifFalse: [leapDays].</body><body package="Chronos-Calendars-Foundation" selector="setNameKey:">setNameKey: anIdentifyingSymbol	self assertMutability.	nameKey := anIdentifyingSymbol == nil ifFalse: [anIdentifyingSymbol asSymbol].</body><body package="Chronos-Calendars-Foundation" selector="setOccurrenceType:">setOccurrenceType: occType	self assertMutability.	occurrenceType := occType</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec</class-id> <category>printing</category><body package="Chronos-Calendars-Foundation" selector="printOn:">printOn: stream	stream 		nextPut: ${;		nextPutAll: self class name;		nextPutAll: ' monthKey=';		print: self monthKey;		tab;		nextPutAll: ' name=';		nextPutAll: self monthName;		crtab;		nextPutAll: 'daysPerMonth=';		print: self daysPerMonth;		tab;		nextPutAll: ' leapDayOrdinals=';		print: self leapDayOrdinals;		nextPut: $}</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec</class-id> <category>enumerating</category><body package="Chronos-Calendars-Foundation" selector="dayOfMonthOrdinalsDo:">dayOfMonthOrdinalsDo: block1	"For each day of the receiver's month, evaluate &lt;block1&gt; with the day-of-month ordinal (in ascending sequence) of the day as the argument."	1 to: daysPerMonth do: [:index | block1 value: index]</body><body package="Chronos-Calendars-Foundation" selector="leapDayOrdinalsDo:">leapDayOrdinalsDo: block1	"For each leap day in the receiver's month, evaluate &lt;block1&gt; with the day-of-month ordinal (in ascending sequence) of the day as the argument."	leapDayOrdinals do: block1</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec class</class-id> <category>instance creation</category><body package="Chronos-Calendars-Foundation" selector="newIntercalaryWithKey:daysPerMonth:occursEveryYear:leapDayOrdinals:">newIntercalaryWithKey: anIdentifyingSymbol daysPerMonth: daysInMonth occursEveryYear: isNonLeap leapDayOrdinals: leapDays	"Answer a new instance of the receiver that represents an intercalary month with the following properties:		a) The key that semantically identifies the month (the 'month key') is &lt;anIdentifyingSymbol&gt;;		b) The key that idenfities the month's name is also &lt;anIdentifyingSymbol&gt;;		c) There are &lt;daysInMonth&gt; days in the month;		e) If &lt;isNonLeap&gt;, then the month occurs every year, otherwise it does not (it's a 'leap month');		d) The day-of-month ordinals of the month's leap days are contained in the Collection &lt;leapDays&gt; (which may be empty)"	^self basicNew		setKey: anIdentifyingSymbol;		setDaysPerMonth: daysInMonth;		setOccurrenceType: (isNonLeap ifTrue: [EveryYearIntercalary] ifFalse: [LeapIntercalary]);		setLeapDayOrdinals: leapDays;		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="newIntercalaryWithKey:nameKey:daysPerMonth:occursEveryYear:leapDayOrdinals:">newIntercalaryWithKey: anIdentifyingSymbol nameKey: nameKey daysPerMonth: daysInMonth occursEveryYear: isNonLeap leapDayOrdinals: leapDays	"Answer a new instance of the receiver that represents an intercalary month with the following properties:		a) The key that semantically identifies the month (the 'month key') is &lt;anIdentifyingSymbol&gt;;		b) The key that idenfities the month's name is &lt;nameKey&gt;;		c) There are &lt;daysInMonth&gt; days in the month;		e) If &lt;isNonLeap&gt;, then the month occurs every year, otherwise it does not (it's a 'leap month');		d) The day-of-month ordinals of the month's leap days are contained in the Collection &lt;leapDays&gt; (which may be empty)"	^self basicNew		setKey: anIdentifyingSymbol;		setNameKey: nameKey;		setDaysPerMonth: daysInMonth;		setOccurrenceType: (isNonLeap ifTrue: [EveryYearIntercalary] ifFalse: [LeapIntercalary]);		setLeapDayOrdinals: leapDays;		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="newWithKey:daysPerMonth:leapDayOrdinals:">newWithKey: anIdentifyingSymbol daysPerMonth: daysInMonth leapDayOrdinals: leapDays	"Answer a new instance of the receiver that represents a non-leap/non-intercalary month with the following properties:		a) The key that semantically identifies the month (the 'month key') is &lt;anIdentifyingSymbol&gt;;		b) The key that idenfities the month's name is also &lt;anIdentifyingSymbol&gt;;		c) There are &lt;daysInMonth&gt; days in the month;		d) The day-of-month ordinals of the month's leap days are contained in the Collection &lt;leapDays&gt; (which may be empty)"	^self basicNew		setKey: anIdentifyingSymbol;		setDaysPerMonth: daysInMonth;		setOccurrenceType: Standard;		setLeapDayOrdinals: leapDays;		beImmutable</body><body package="Chronos-Calendars-Foundation" selector="newWithKey:nameKey:daysPerMonth:leapDayOrdinals:">newWithKey: anIdentifyingSymbol nameKey: nameKey daysPerMonth: daysInMonth leapDayOrdinals: leapDays	"Answer a new instance of the receiver that represents a non-leap/non-intercalary month with the following properties:		a) The key that semantically identifies the month (the 'month key') is &lt;anIdentifyingSymbol&gt;;		b) The key that idenfities the month's name is &lt;nameKey&gt;;		c) There are &lt;daysInMonth&gt; days in the month;		d) The day-of-month ordinals of the month's leap days are contained in the Collection &lt;leapDays&gt; (which may be empty)"	^self basicNew		setKey: anIdentifyingSymbol;		setNameKey: nameKey;		setDaysPerMonth: daysInMonth;		setOccurrenceType: Standard;		setLeapDayOrdinals: leapDays;		beImmutable</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec class</class-id> <category>private</category><body package="Chronos-Calendars-Foundation" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self new		initializeFromLiteralArray: literalArray;		beImmutable</body></methods><methods><class-id>Chronos.MonthlyCalendarSpec class</class-id> <category>class initialization</category><body package="Chronos-Calendars-Foundation" selector="initialize">initialize	EveryYearIntercalary := 1.	LeapIntercalary := 2.	Standard := 0.</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: self dayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="value:value:">value: aYear value: aCalendarDay	self setDayOfYearOrdinal: aCalendarDay dayOfYear</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>initialize-release</category><body package="Chronos-Annual Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.		dayOfYearOrdinal := 1.</body><body package="Chronos-Annual Dates" selector="initializeFrom:">initializeFrom: aCalendricalCoordinate	self 		basicSetCalendar: aCalendricalCoordinate calendar;		setDayOfYearOrdinal: aCalendricalCoordinate dayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self setDayOfYearOrdinal: (literalArray at: 3) asNumber</body><body package="Chronos-Annual Dates" selector="setDayOfYearOrdinal:">setDayOfYearOrdinal: anOrdinal	self assertMutability.	dayOfYearOrdinal := anOrdinal</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="dayOfYearOrdinal">dayOfYearOrdinal	^dayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfYear">daysSinceStartOfYear	"Answer the number of days since the first day of the receiver's year up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the year represented by the receiver."	^self dayOfYearOrdinal - 1</body><body package="Chronos-Annual Dates" selector="identifiersDo:">identifiersDo: block2	super identifiersDo: block2.	block2 value: #dayOfYearOrdinal value: self dayOfYearOrdinal</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isDayOfYearInvariant">isDayOfYearInvariant	^dayOfYearOrdinal &gt; 0</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="calendarDayInYear:">calendarDayInYear: year 	^self calendar 		calendarDayFromDayOfYearOrdinal: (self dayOfYearOrdinalInYear: year)		inYear: year</body><body package="Chronos-Annual Dates" selector="dayOfYearOrdinalInYear:">dayOfYearOrdinalInYear: year 	^dayOfYearOrdinal &gt; 0 		ifTrue: [dayOfYearOrdinal]		ifFalse: [(self calendar daysInYear: year) + dayOfYearOrdinal]</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfYearInYear:">daysSinceStartOfYearInYear: year	^(self dayOfYearOrdinalInYear: year) - 1</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinal">maxDayOfYearOrdinal	^dayOfYearOrdinal &gt; 0 		ifTrue: [dayOfYearOrdinal]		ifFalse: [self calendar maxDaysPerYear + dayOfYearOrdinal]</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinalForYearOfType:">maxDayOfYearOrdinalForYearOfType: yearTypeCode	^self maxDayOfYearOrdinal</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinal">minDayOfYearOrdinal	^dayOfYearOrdinal &gt; 0 		ifTrue: [dayOfYearOrdinal]		ifFalse: [self calendar minDaysPerYear + dayOfYearOrdinal]</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>comparing</category><body package="Chronos-Annual Dates" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToDayOfYear: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aCalendrical and: [ex message selector == #compareToDayOfYear:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-Annual Dates" selector="hash">hash	^dayOfYearOrdinal hash</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>private-comparing</category><body package="Chronos-Annual Dates" selector="compareToDayOfYear:">compareToDayOfYear: aDayOfYear	aDayOfYear == self ifTrue: [^0].	aDayOfYear calendar = self calendar ifFalse: [^nil].	^aDayOfYear minDayOfYearOrdinal - self minDayOfYearOrdinal</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processDayOfYear: self</body></methods><methods><class-id>Chronos.DayOfYear</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printDayOfYear: self on: stream</body></methods><methods><class-id>Chronos.DayOfYear class</class-id> <category>examples</category><body package="Chronos-Annual Dates" selector="firstDayOfYear:inCalendar:">firstDayOfYear: year inCalendar: calendar	"{(DayOfYear firstDayOfYear: 2004 inCalendar: Calendar julian) asGregorian}"	"Note: Don't use this method for real work.  It's only an example.  The right way to do this is to either create and reuse a cached set of DayOfYear instances to do computations of this nature, or else to create an instance of DateAndTime using 'DateAndTime year: year month: 1 day: 1 calendar: calendar'].  The DayOfYear instance would be the preferred solution when there are a finite set of dayOfYear ordinals whose full date must be repeatedly computed for various years (e.g., holidays.)  The DateAndTime (a.k.a. Timepoint) instance would be the preferred solution when the full date is known in advance, or when neither the dayOfYearOrdinal nor the month/dayOfMonth are knowable in advance."	^(DayOfYearFactory ordinal: 1 calendar: calendar) inYear: year</body><body package="Chronos-Annual Dates" selector="lastDayOfYear:inCalendar:">lastDayOfYear: year inCalendar: calendar	"{(DayOfYear lastDayOfYear: 2004 inCalendar: Calendar julian) asGregorian}"	"Note: Don't use this method for real work.  It's only an example.  The right way to do this is to either create and reuse a cached set of DayOfYear instances to do computations of this nature, or else to create an instance of DateAndTime using 'DateAndTime year: year month: 12 day: 31 calendar: calendar' (or whatever the lastMonth/lastDayOfMonth ordinals are for the calendar in question--an issue which highlights one reason why you might want to use a DayOfYear instance instead of a DateAndTime.)  The DayOfYear instance would be the preferred solution when there are a finite set of dayrOfYear ordinals whose full date must be repeatedly computed for various years (e.g., holidays.)  The DateAndTime (a.k.a. Timepoint) instance would be the preferred solution when the full date is known in advance, or when neither the dayOfYearOrdinal nor the month/dayOfMonth are knowable in advance."	^(DayOfYearFactory ordinal: DayOfYearFactory lastDayOfYear calendar: calendar) inYear: year</body></methods><methods><class-id>Chronos.DayOfYear class</class-id> <category>constants</category><body package="Chronos-Annual Dates" selector="lastDayOfYear">lastDayOfYear	^0</body></methods><methods><class-id>Chronos.DayOfYear class</class-id> <category>instance creation</category><body package="Chronos-Annual Dates" selector="ordinal:">ordinal: dayOfYearOrdinal	^self new		setDayOfYearOrdinal: dayOfYearOrdinal;		beImmutable</body><body package="Chronos-Annual Dates" selector="ordinal:calendar:">ordinal: dayOfYearOrdinal calendar: aCalendar	^self new		setCalendar: aCalendar;		setDayOfYearOrdinal: dayOfYearOrdinal;		beImmutable</body></methods><methods><class-id>Chronos.UTCTimescale</class-id> <category>private</category><body package="Chronos-Timescales" selector="setSecondsSinceUnificationEpochUpToEpoch">setSecondsSinceUnificationEpochUpToEpoch	"Set the number of seconds since the initial moment of the unification timescale up to the initial moment of the receiver's timescale."	self assertMutability.	secondsSinceUnificationEpochUpToEpoch := 0</body></methods><methods><class-id>Chronos.UTCTimescale</class-id> <category>collaboration-dateAndTime</category><body package="Chronos-Timescales" selector="fromSecondsSinceEpoch:andNanosecondsSinceSecond:specifiedAsUT:setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto:">fromSecondsSinceEpoch: secondsSinceEpoch andNanosecondsSinceSecond: nanosecondsSinceSecond specifiedAsUT: isSpecifiedAsUT setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: aTimepoint 	"| ts tp secondsSinceEpoch ls |	secondsSinceEpoch := (DateAndTimeSpec year: 1980 month: 12 day: 31 hour: 23 minute: 59 second: 59) secondsSinceEpoch.	ls := LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: secondsSinceEpoch.	secondsSinceEpoch := secondsSinceEpoch + ls postNetLeapSeconds.	ts := UTCTimescale new.	tp := Timepoint basicNew.	tp 		basicSetCalendar: Gregorian;		basicSetTimeZone: Timezone universal.	ts 		fromSecondsSinceEpoch: secondsSinceEpoch 		andNanosecondsSinceSecond: 0 		specifiedAsUT: true		setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: tp.	tp beImmutable"	"| ts tp secondsSinceEpoch utSecondsSinceEpoch ls |	tp := Timepoint year: 1980 month: 12 day: 31 hour: 23 minute: 59 second: 59.	secondsSinceEpoch := tp secondsSinceEpoch.	utSecondsSinceEpoch := tp utSecondsSinceEpoch.	ls := LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: utSecondsSinceEpoch.	secondsSinceEpoch := secondsSinceEpoch + ls postNetLeapSeconds.	ts := UTCTimescale new.	tp := Timepoint basicNew.	tp 		basicSetCalendar: Gregorian;		basicSetTimeZone: Timezone default.	ts 		fromSecondsSinceEpoch: secondsSinceEpoch 		andNanosecondsSinceSecond: 0 		specifiedAsUT: false		setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: tp.	tp beImmutable"	| schedule leapSecond calendricalSecondsSinceEpoch insertLeapSecondsAtEndOfUTDay utSecondsSinceEpoch diff | 	schedule := LeapSecondSchedule utc.	leapSecond := schedule leapSecondOnOrBeforeScientificSecondsSinceEpoch: secondsSinceEpoch.	calendricalSecondsSinceEpoch := 		leapSecond == nil 			ifTrue: [secondsSinceEpoch]			ifFalse: [secondsSinceEpoch - leapSecond postNetLeapSeconds].	super			fromSecondsSinceEpoch: calendricalSecondsSinceEpoch			andNanosecondsSinceSecond: nanosecondsSinceSecond			specifiedAsUT: isSpecifiedAsUT			setDaysSinceEpochAndSecondsSinceStartOfDayAndNanosecondsSinceSecondInto: aTimepoint.	(isSpecifiedAsUT or: [aTimepoint localTimeIsUniversal])		ifTrue:			[leapSecond == nil				ifTrue: [^self]				ifFalse: 					[insertLeapSecondsAtEndOfUTDay := leapSecond intervalIncludesScientificSecondSinceEpoch: secondsSinceEpoch.					utSecondsSinceEpoch := secondsSinceEpoch]]		ifFalse: 			[leapSecond == nil				ifTrue: 					["Note: No time zone offset transitions occur within 24 hours of the first leap second on 1972-06-30T23:59:60."					utSecondsSinceEpoch := aTimepoint timeZone						netSecondsAfterSubtractingOffsetFromUTFromSeconds: secondsSinceEpoch						nanosecondsSinceSecond: nanosecondsSinceSecond.					diff := utSecondsSinceEpoch - schedule secondsSinceEpochOfFirstLeapSecond.					diff &lt; 0 ifTrue: [^self].					insertLeapSecondsAtEndOfUTDay := leapSecond intervalIncludesScientificSecondSinceEpoch: utSecondsSinceEpoch.					insertLeapSecondsAtEndOfUTDay ifFalse: [aTimepoint addSeconds: leapSecond postNetLeapSeconds negated]]				ifFalse: 					[| timeZone0  timeZone1 |					timeZone0 := aTimepoint timeZone.					[| ls |					utSecondsSinceEpoch := 						timeZone0							netSecondsAfterSubtractingOffsetFromUTFromSeconds: secondsSinceEpoch							nanosecondsSinceSecond: nanosecondsSinceSecond.					ls := leapSecond inEffectAtScientificSecondSinceEpoch: utSecondsSinceEpoch.					ls == leapSecond 						ifTrue: [true]						ifFalse: 							[aTimepoint addSeconds: leapSecond postNetLeapSeconds - ls postNetLeapSeconds.							leapSecond := ls.							timeZone0 isStatic 								or: 									[timeZone1 := aTimepoint timeZone.									timeZone0 == timeZone1]]] whileFalse: [timeZone0 := timeZone1].					insertLeapSecondsAtEndOfUTDay := leapSecond intervalIncludesScientificSecondSinceEpoch: utSecondsSinceEpoch]].	insertLeapSecondsAtEndOfUTDay 		ifTrue: 			[aTimepoint 				basicSetSecondsSinceStartOfDay: 					aTimepoint basicSecondsSinceStartOfDay 						+ utSecondsSinceEpoch - leapSecond firstScientificSecondSinceEpoch + 1]</body></methods><methods><class-id>Chronos.UTCTimescale class</class-id> <category>private</category><body package="Chronos-Timescales" selector="newRegistry">newRegistry	^self superclass registry</body></methods><methods><class-id>Chronos.ChineseCalendar class</class-id> <category>accessing</category><body package="Chronos-Calendars-Irregular" selector="registrationKey">registrationKey	"Answer the well-known semantic key that uniquely identifies the calendrical system implemented by the receiver."	^#Chinese</body></methods><methods><class-id>Chronos.ChineseCalendar class</class-id> <category>testing</category><body package="Chronos-Calendars-Irregular" selector="isAbstract">isAbstract	"Prevent registration, because I'm not implemented yet."	^true</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>accessing</category><body package="Chronos-Duration" selector="days">days	"Answer the integer number of days (truncated towards zero) represented by the receiver, independent of the number of months and/or years it may represent."	"Specified and required by the ANSI-Smalltalk Standard."	^seconds quo: SecondsPerDay</body><body package="Chronos-Duration" selector="hours">hours	"Answer the integer number of hours-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in hours after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^(seconds quo: SecondsPerHour) rem: HoursPerDay</body><body package="Chronos-Duration" selector="minutes">minutes	"Answer the integer number of minutes-since-the-hour (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in minutes after subtracting from its temporal extent integer number of hours (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^(seconds quo: SecondsPerMinute) rem: MinutesPerHour</body><body package="Chronos-Duration" selector="nanosecondsSinceSecond">nanosecondsSinceSecond	"Answer the integer number of nanoseconds-since-the-second (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in nanoseconds after subtracting from its temporal extent the integer number of seconds (truncated towards zero) represented by the receiver.)"	^nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^NanosecondDuration</body><body package="Chronos-Duration" selector="seconds">seconds	"Answer the integer number of seconds-since-the-minute (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of minutes (truncated towards zero) represented by the receiver.)"	"Specified and required by the ANSI-Smalltalk Standard."	^seconds rem: SecondsPerMinute</body><body package="Chronos-Duration" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	"Answer the integer number of seconds-since-the-day (truncated towards zero) represented by the receiver (i.e., the truncation-towards-zero of the remainder in seconds after subtracting from its temporal extent the integer number of days (truncated towards zero) represented by the receiver.) Assume an invariant number of seconds in each higher-order time period (days, hours, minutes.)"	^seconds rem: SecondsPerDay</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>private</category><body package="Chronos-Duration" selector="asCalendricalMutable">asCalendricalMutable	^self class civilDurationFactory new 		setSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="asCivilSubDayMutable">asCivilSubDayMutable	^self class civilDurationFactory new 		setSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="asSubDayMutable">asSubDayMutable	^self copy</body><body package="Chronos-Duration" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: seconds;		nextPut: nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>converting</category><body package="Chronos-Duration" selector="asCalendarDuration">asCalendarDuration	^self class calendarDurationFactory  days: self asDays</body><body package="Chronos-Duration" selector="asDate">asDate	"Answer a date-valued CalendricalCoordinate (bound to the Gregorian Calendar) that represents the same number of days since the epoch of the Gregorian calendar as is represented by the receiver's temporal extent in days.  A date-valued CalendricalCoordinate is one that specifies a date without specifying a particular time-of-day nor a particular timezone (i.e., it has nominal time semantics, and its quantum of resolution is 1 calendar day.)"	"{(Duration days: YearMonthDay today daysSinceEpoch) asDate}"	^DateFactory daysSinceEpoch: self asDays</body><body package="Chronos-Duration" selector="asDateAndTime">asDateAndTime	"Answer a a DateAndTime value (bound to the current default timezone and the Gregorian Calendar) that represents the same number of seconds and nanoseconds since the epoch of the Gregorian calendar as is represented by the receiver's temporal extent.  A DateAndTime value is a CalendricalCoordinate that specifies a point-in-time, with a quantum of resolution no larger than one second, with behavior/semantics that is invariant to UT, and that conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol. See the class comment of Timepoint for further clarification."	"{(Duration days: Timepoint now fractionalDaysSinceEpoch) asDateAndTime}"	^self asDateAndTimeIn: ChronosTimezone default</body><body package="Chronos-Duration" selector="asDateAndTimeIn:">asDateAndTimeIn: timeZone	"Answer a Gregorian point-in-time value (bound to the specified &lt;timeZone&gt;) that represents the same number of seconds and nanoseconds since the epoch of the Gregorian calendar as is represented by the receiver's temporal extent."	"{(Duration days: (Timezone at: 'Asia/Calcutta') now fractionalDaysSinceEpoch) asDateAndTimeIn: 'Asia/Calcutta'}"	^self class dateAndTimeFactory		secondsSinceEpoch: seconds		nanoseconds: nanosecondsSinceSecond		timeZone: timeZone</body><body package="Chronos-Duration" selector="asDays">asDays	"Answer the integer number of days (truncated towards zero) represented by the receiver's temporal extent."	"{(Duration days: 365) asSeconds}"	^seconds quo: SecondsPerDay</body><body package="Chronos-Duration" selector="asDelay">asDelay	"Answer a Delay whose delay duration is the same as the temporal extent represented by the receiver."	"{(Duration seconds: 3) asDelay wait}"	^ChronosSystemFacade current newDelayFromDuration: self</body><body package="Chronos-Duration" selector="asFractionalDays">asFractionalDays	"Answer the number of days (including any fractional part) represented by the receiver's temporal extent."	"{(Duration seconds: 123456789) asFractionalDays}"	"{(DateAndTimeFactory utcNow - (DateAndTimeFactory utcDaysSinceEpoch: 0 timeZone: Timezone utc)) asFractionalDays}"	^ScaledDecimal 		numerator: self asNanoseconds 		denominator: SecondsPerDay * NanosecondsPerSecond 		scale: 9</body><body package="Chronos-Duration" selector="asFractionalSeconds">asFractionalSeconds	"Answer the number of seconds (including any fractional part) represented by the receiver's temporal extent."	"{(Duration seconds: 1 nanoseconds: 500000000) asFractionalSeconds}"	"{DateAndTimeFactory secondsSinceEpoch: (ScientificDuration days: (DateAndTimeFactory now fractionalDaysSinceEpoch))  asFractionalSeconds}"	"{(DateAndTimeFactory utcNow - (DateAndTimeFactory utcDaysSinceEpoch: 0 timeZone: Timezone utc)) asFractionalSeconds}"	^ScaledDecimal 		numerator: self asNanoseconds		denominator: NanosecondsPerSecond		scale: 9</body><body package="Chronos-Duration" selector="asHours">asHours	"Answer the integer number of hours (truncated towards zero) represented by the receiver's temporal extent."	"{(Duration days: 2/3) asHours}"	^seconds quo: SecondsPerHour</body><body package="Chronos-Duration" selector="asMicroseconds">asMicroseconds	"Answer the integer number of microseconds (truncated towards zero) represented by the receiver's temporal extent."	"{(Duration toRun: [100000 timesRepeat: [Timepoint now]]) asMicroseconds}"	^((nanosecondsSinceSecond bitShift: -3) // 125) + ((seconds bitShift: 6) * 15625)</body><body package="Chronos-Duration" selector="asMilliseconds">asMilliseconds	"Answer the integer number of milliseconds (truncated towards zero) represented by the receiver's temporal extent."	"{(Duration toRun: [100000 timesRepeat: [Timepoint now]]) asMilliseconds}"	^((nanosecondsSinceSecond bitShift: -6) // 15625) + ((seconds * 125)  bitShift: 3)</body><body package="Chronos-Duration" selector="asMinutes">asMinutes	"Answer the integer number of minutes (truncated towards zero) represented by the receiver's temporal extent."	"{(Duration days: 1/6) asMinutes}"	^seconds quo: SecondsPerMinute</body><body package="Chronos-Duration" selector="asNanoseconds">asNanoseconds	"Answer the integer number of nanoseconds (truncated towards zero) represented by the receiver's temporal extent."	^nanosecondsSinceSecond + (seconds * NanosecondsPerSecond)</body><body package="Chronos-Duration" selector="asNominalDateAndTime">asNominalDateAndTime	"Answer a nominal-time-invariant DateAndTime value (bound to the Gregorian Calendar) that represents the same number of seconds and nanoseconds since the epoch of the Gregorian calendar as is represented by the receiver's temporal extent.  A nominal-time-invariant DateAndTime value is a CalendricalCoordinate that nominally specifies a point-in-time without reference to any particular timezone, and has a quantum of resolution no larger than one second. A nominal-time-invariant DateAndTime value conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol EXCEPT that its behavior/semantics is invariant to nominal time, as opposed to being UT invariant.  See the class comment of Timepoint for further clarification."	"{(Duration days: Timepoint now fractionalDaysSinceEpoch) asNominalDateAndTime}"	^self asDateAndTimeIn: ChronosTimezone nominal</body><body package="Chronos-Duration" selector="asSeconds">asSeconds	"Answer the integer number of seconds (truncated towards zero) represented by the receiver's temporal extent."	"Specified and required by the ANSI-Smalltalk Standard."	"{(Duration hours: -5) asSeconds}"	^seconds</body><body package="Chronos-Duration" selector="asTimezone">asTimezone	"Answer a ChronosTimezone whose offset-from-UT has the same temporal extent as that of the receiver."	"{(Duration hours: -8) asTimezone}"	^ChronosTimezone offset: self</body><body package="Chronos-Duration" selector="asWeeks">asWeeks	"Answer the integer number of weeks (truncated towards zero, 1 week = 7 days) represented by the receiver's temporal extent."	"{(DateAndTimeFactory utcNow - (DateAndTimeFactory utcDaysSinceEpoch: 0 timeZone: Timezone utc)) asWeeks}"	^seconds quo: (DaysPerWeek * SecondsPerDay)</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>private-arithmetic</category><body package="Chronos-Duration" selector="addedToCalendarDuration:">addedToCalendarDuration: aCalendarDuration	^aCalendarDuration		addingSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="addedToCivilDuration:">addedToCivilDuration: aCivilDuration	^aCivilDuration		addingSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="addedToDuration:">addedToDuration: aDuration	^aDuration  		addingSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="addedToTemporalInterval:">addedToTemporalInterval: aTemporalInterval 	^aTemporalInterval 		addingSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="subtractedFromCalendarDuration:">subtractedFromCalendarDuration: aCalendarDuration	^aCalendarDuration		subtractingSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="subtractedFromCivilDuration:">subtractedFromCivilDuration: aCivilDuration	^aCivilDuration		subtractingSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="subtractedFromDuration:">subtractedFromDuration: aDuration	^aDuration		subtractingSeconds: seconds 		nanoseconds: nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="subtractedFromTemporalInterval:">subtractedFromTemporalInterval: aTemporalInterval 	^aTemporalInterval 		subtractingSeconds: seconds		nanoseconds: nanosecondsSinceSecond</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>initialize-release</category><body package="Chronos-Duration" selector="addDays:">addDays: addedDays	addedDays isInteger 		ifTrue: [self addSeconds: (addedDays * 675 bitShift: 7)]		ifFalse: [self addSeconds: (addedDays * SecondsPerDay)].</body><body package="Chronos-Duration" selector="addHours:">addHours: addedHours	self addSeconds: addedHours * SecondsPerHour</body><body package="Chronos-Duration" selector="addHours:minutes:">addHours: addedHours minutes: addedMinutes	self assertMutability.	seconds := seconds + (addedHours * SecondsPerHour) + (addedMinutes * SecondsPerMinute)</body><body package="Chronos-Duration" selector="addHours:minutes:seconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds	self assertMutability.	seconds := seconds + addedSeconds + (addedHours * SecondsPerHour) + (addedMinutes * SecondsPerMinute)</body><body package="Chronos-Duration" selector="addHours:minutes:seconds:nanoseconds:">addHours: addedHours minutes: addedMinutes seconds: addedSeconds nanoseconds: addedNanoseconds	self assertMutability.	nanosecondsSinceSecond := nanosecondsSinceSecond + addedNanoseconds.	seconds := seconds + addedSeconds + (addedHours * SecondsPerHour) + (addedMinutes * SecondsPerMinute)</body><body package="Chronos-Duration" selector="addMinutes:">addMinutes: addedMinutes	self addSeconds: addedMinutes * SecondsPerMinute</body><body package="Chronos-Duration" selector="addSeconds:">addSeconds: addedSeconds	self assertMutability.	seconds := seconds + addedSeconds.</body><body package="Chronos-Duration" selector="addSeconds:nanoseconds:">addSeconds: addedSeconds nanoseconds: addedNanoseconds	self assertMutability.	nanosecondsSinceSecond := nanosecondsSinceSecond + addedNanoseconds.	seconds := seconds + addedSeconds.</body><body package="Chronos-Duration" selector="beAbsolute">beAbsolute	"Make the receiver's temporal extent be the absolute value of its current temporal extent. Fail if the receiver is immutable."	self assertMutability.	seconds := seconds abs.	nanosecondsSinceSecond := nanosecondsSinceSecond abs.</body><body package="Chronos-Duration" selector="beNegated">beNegated	"Make the receiver's temporal extent be the additive inverse ('negated value') of its current temporal extent. Fail if the receiver is immutable."	self assertMutability.	seconds := seconds negated.	nanosecondsSinceSecond := nanosecondsSinceSecond negated.</body><body package="Chronos-Duration" selector="canonicalize">canonicalize	"The receiver is about to made immutable.  Therefore, ensure that any instance variables of the receiver whose values must not be changed once the receiver becomes immutable have been set to valid, canonical and/or default values.  This may be accomplished by either a) resetting the value of variables, or b) raising an exception. Fail if the receiver is not mutable."	self assertMutability.	nanosecondsSinceSecond == nil ifTrue: [nanosecondsSinceSecond := 0].	seconds == nil 		ifTrue: [seconds := 0]		ifFalse:			[seconds isInteger				ifFalse:					[| int fractionalPart |					int := seconds truncated.					fractionalPart := seconds - int.					seconds := int.					nanosecondsSinceSecond := nanosecondsSinceSecond + (fractionalPart * NanosecondsPerSecond) rounded]].	nanosecondsSinceSecond abs &gt;= NanosecondsPerSecond		ifTrue: 			[seconds := seconds + ((nanosecondsSinceSecond bitShift: -9) quo: 1953125).			nanosecondsSinceSecond := nanosecondsSinceSecond rem: NanosecondsPerSecond].	seconds &gt; 0		ifTrue: 			[nanosecondsSinceSecond &lt; 0				ifTrue: 					[seconds := seconds - 1.					nanosecondsSinceSecond := nanosecondsSinceSecond + NanosecondsPerSecond]]		ifFalse: 			[seconds &lt; 0				ifTrue: 					[nanosecondsSinceSecond &gt; 0						ifTrue: 							[seconds := seconds + 1.							nanosecondsSinceSecond := nanosecondsSinceSecond - NanosecondsPerSecond]]]</body><body package="Chronos-Duration" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	seconds := 0.	nanosecondsSinceSecond := 0.</body><body package="Chronos-Duration" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self setSeconds: (literalArray at: 2) asNumber nanoseconds: (literalArray at: 3) asNumber</body><body package="Chronos-Duration" selector="setDays:">setDays: d	"Set the durational value of the receiver to a temporal extent of &lt;d&gt; days. Fail if the receiver is not mutable."	d isInteger 		ifTrue: [self setSeconds: (d * 675 bitShift: 7)]  		ifFalse: [self setSeconds: d * SecondsPerDay].</body><body package="Chronos-Duration" selector="setDays:hours:minutes:seconds:">setDays: d hours: h minutes: m seconds: s	"Set the component of the receiver's duration vector that represents its temporal extent in days to the value &lt;d&gt;, and set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds to the value (&lt;h&gt; * 3600) + (&lt;m&gt; * 60) + &lt;s&gt; (and if both days and sub-days are represented by the same vector component, set the value of that component to the sum of the specified day and sub-day extents.) Fail if the receiver is not mutable."	self 		setDays: d 		seconds: (h * SecondsPerHour) + (m * SecondsPerMinute) + s</body><body package="Chronos-Duration" selector="setDays:hours:minutes:seconds:nanoseconds:">setDays: d hours: h minutes: m seconds: s nanoseconds: n	"Set the component of the receiver's duration vector that represents its temporal extent in days to the value &lt;d&gt;, and set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds to the value (&lt;h&gt; * 3600) + (&lt;m&gt; * 60) + &lt;s&gt;, and set the component of the receiver's duration vector that represents its temporal extent in nanoseconds to the value &lt;n&gt; (and if both days and sub-days are represented by the same vector component, set the value of that component to the sum of the specified day and sub-day extents.) Fail if the receiver is not mutable."	self 		setDays: d 		seconds: (h * SecondsPerHour) + (m * SecondsPerMinute) + s 		nanoseconds: n</body><body package="Chronos-Duration" selector="setDays:seconds:">setDays: d seconds: s	"Set the durational value of the receiver to a temporal extent of &lt;d&gt; days and &lt;s&gt; seconds. Fail if the receiver is not mutable."	self setSeconds: (d * 675 bitShift: 7) + s</body><body package="Chronos-Duration" selector="setDays:seconds:nanoseconds:">setDays: d seconds: s nanoseconds: n	"Set the durational value of the receiver to a temporal extent of &lt;d&gt; days, &lt;s&gt; seconds and &lt;n&gt; nanoseconds. Fail if the receiver is not mutable."	self setSeconds: (d * 675 bitShift: 7) + s  nanoseconds: n</body><body package="Chronos-Duration" selector="setHours:">setHours: h	"Set the component of the receiver's duration vector that represents its temporal extent in hours to the value &lt;h&gt;. Fail if the receiver is not mutable."	self setSeconds: h * SecondsPerHour</body><body package="Chronos-Duration" selector="setHours:minutes:seconds:">setHours: h minutes: m seconds: s 	"Set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds. Fail if the receiver is not mutable."	self setSeconds: h * SecondsPerHour + (m * SecondsPerMinute) + s</body><body package="Chronos-Duration" selector="setHours:minutes:seconds:nanoseconds:">setHours: h minutes: m seconds: s nanoseconds: n	"Set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds. Fail if the receiver is not mutable."	self assertMutability.	seconds := (h * SecondsPerHour) + (m * SecondsPerMinute) + s.	nanosecondsSinceSecond := n</body><body package="Chronos-Duration" selector="setMinutes:">setMinutes: m	"Set the component of the receiver's duration vector that represents its temporal extent in minutes to the value &lt;m&gt;. Fail if the receiver is not mutable."	self setSeconds: m * SecondsPerMinute</body><body package="Chronos-Duration" selector="setNanoseconds:">setNanoseconds: n	"Set the component of the receiver's duration vector that represents its temporal extent in nanoseconds to the value &lt;n&gt;. Fail if the receiver is not mutable."	self assertMutability.	nanosecondsSinceSecond := n rounded.</body><body package="Chronos-Duration" selector="setSeconds:">setSeconds: s 	"Set the component of the receiver's duration vector that represents its temporal extent in seconds to the value &lt;s&gt;. Fail if the receiver is not mutable."	"s isInteger ifFalse: [^self setFractionalSeconds: s]."	self assertMutability.	seconds := s.</body><body package="Chronos-Duration" selector="setSeconds:nanoseconds:">setSeconds: s nanoseconds: n	"Set the component of the receiver's duration vector that represents its non-calendrical temporal extent to &lt;s&gt; seconds and &lt;n&gt; nanoseconds. Fail if the receiver is not mutable."	self assertMutability.	nanosecondsSinceSecond := n rounded.	seconds := s.</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>testing</category><body package="Chronos-Duration" selector="calendarPeriodsAreZero">calendarPeriodsAreZero	"Answer whether the components of the receiver's duration vector that represent calendrical periods (years, months, days) all have the value zero."	^true</body><body package="Chronos-Duration" selector="isDayDuration">isDayDuration	"Answer whether the receiver's temporal extent is one day."	^self subsecondsAreZero and: [seconds = SecondsPerDay]</body><body package="Chronos-Duration" selector="isHourDuration">isHourDuration	"Answer whether the receiver's temporal extent is one hour."	^self subsecondsAreZero and: [seconds = SecondsPerHour]</body><body package="Chronos-Duration" selector="isMinuteDuration">isMinuteDuration	"Answer whether the receiver's temporal extent is one minute."	^self subsecondsAreZero and: [seconds = SecondsPerMinute]</body><body package="Chronos-Duration" selector="isNanosecondDuration">isNanosecondDuration	"Answer whether the receiver's temporal extent is one nanosecond."	^nanosecondsSinceSecond = 1 and: [seconds = 0]</body><body package="Chronos-Duration" selector="isSecondDuration">isSecondDuration	"Answer whether the receiver's temporal extent is one second."	^self subsecondsAreZero and: [seconds = 1]</body><body package="Chronos-Duration" selector="isZero">isZero	"Answer the whether the receiver represents a zero-length temporal extent."	^self == Zero or: [self nonCalendarPeriodsAreZero]</body><body package="Chronos-Duration" selector="nonCalendarPeriodsAreZero">nonCalendarPeriodsAreZero	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is zero."	^seconds isZero and: [nanosecondsSinceSecond isZero]</body><body package="Chronos-Duration" selector="nonCalendarPeriodsPositive">nonCalendarPeriodsPositive	"Answer whether the non-calendrical temporal extent (hours/minutes/seconds/nanoseconds) of the receiver is positive."	seconds &gt; 0 ifTrue: [^true].	seconds &lt; 0 ifTrue: [^false].	^nanosecondsSinceSecond positive</body><body package="Chronos-Duration" selector="subsecondsAreZero">subsecondsAreZero	"Answer whether the sub-second temporal extent (seconds/nanoseconds) of the receiver is zero."	^nanosecondsSinceSecond = 0</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>comparing</category><body package="Chronos-Duration" selector="=">= aMagnitude 	"Answer whether the receiver is equal to the argument."	"Specified and required by the ANSI-Smalltalk Standard."	self == aMagnitude ifTrue: [^true].	^[aMagnitude isEqualToDuration: self]		on: MessageNotUnderstood		do: [:ex | 			(ex receiver == aMagnitude and: [ex message selector == #isEqualToDuration:])				ifTrue: [ex return: false]				ifFalse: [ex pass]]</body><body package="Chronos-Duration" selector="compareTo:">compareTo: aDuration	"Compare the value of the receiver to that of &lt;aDuration&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aDuration&gt; are the same.)"	self == aDuration ifTrue: [^0].	^[^aDuration compareToDuration: self]			on: MessageNotUnderstood		do: [:ex | (ex receiver == aDuration and: [#compareToDuration: == ex message selector]) 					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-Duration" selector="hash">hash	^(nanosecondsSinceSecond + seconds) hash</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>arithmetic</category><body package="Chronos-Duration" selector="*">* aNumber	"Specified and required by the ANSI-Smalltalk Standard."	"{(ScientificDuration hours: 6) * 4}"	aNumber = 1 ifTrue: [^self].	^self copy 		setSeconds: seconds * aNumber nanoseconds: nanosecondsSinceSecond * aNumber;		beImmutable</body><body package="Chronos-Duration" selector="+">+ aDurationOrTemporalCoordinate	"Specified and required by the ANSI-Smalltalk Standard."	"{((ScientificDuration days: 5) + (ScientificDuration days: 7 hours: 4 minutes: 0 seconds: 52))}"	"{(ScientificDuration days: 7 hours: 4 minutes: 0 seconds: 52) - YearMonthDay today}"	^aDurationOrTemporalCoordinate addedToDuration: self</body><body package="Chronos-Duration" selector="-">- aDurationOrTemporalCoordinate	"Specified and required by the ANSI-Smalltalk Standard."	"{((ScientificDuration days: 5) - (ScientificDuration days: 7 hours: 4 minutes: 0 seconds: 52))}"	"{(ScientificDuration days: 7 hours: 4 minutes: 0 seconds: 52) - YearMonthDay today}"	^aDurationOrTemporalCoordinate subtractedFromDuration: self</body><body package="Chronos-Duration" selector="/">/ aDurationOrNumber 	"Specified and required by the ANSI-Smalltalk Standard."	"{((Duration days: 4/3) addingSeconds: 0 nanoseconds: 4) / 4}"	"{(Duration days: 4/3) / (Duration days: 2/3)}"	^aDurationOrNumber respondsToArithmetic 		ifTrue: 			[aDurationOrNumber = 1 ifTrue: [^self].			(self copy)				setSeconds: self asFractionalSeconds / aDurationOrNumber;				beImmutable]		ifFalse: 			[(self copy)				setSeconds: self asFractionalSeconds / aDurationOrNumber asFractionalSeconds;				beImmutable]</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>private-comparing</category><body package="Chronos-Duration" selector="compareToDuration:">compareToDuration: aDuration	| diff |	diff := aDuration asSeconds - seconds.	diff = 0 ifFalse: [^diff].	^aDuration nanosecondsSinceSecond - nanosecondsSinceSecond</body><body package="Chronos-Duration" selector="isEqualToDuration:">isEqualToDuration: aDuration 	^seconds = aDuration asSeconds 		and: [nanosecondsSinceSecond = aDuration nanosecondsSinceSecond]</body></methods><methods><class-id>Chronos.ScientificDuration</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	"If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy default (or ChronosPrintPolicy ansiStandard,) then the receiver's printString will be formatted as required by the ANSI-Smalltalk Standard.	If &lt;aChronosPrintPolicy&gt; == ChronosPrintPolicy  iso8601, then the receiver's printString will be formatted as required by the ISO 8601 Standard."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printDuration: self on: stream</body></methods><methods><class-id>Chronos.ScientificDuration class</class-id> <category>instance creation</category><body package="Chronos-Duration" selector="days:hours:minutes:seconds:">days: d hours: h minutes: m seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;d&gt; days, &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds."	"Specified and required by the ANSI-Smalltalk Standard."	"{Timepoint now + (ScientificDuration days: 182 hours: 24 minutes: 10 seconds: -59)}"	"{Timepoint now + (CalendarDuration days: 182 hours: 24 minutes: 10 seconds: -59)}"	^self new		setDays: d hours: h minutes: m seconds: s;		beImmutable</body><body package="Chronos-Duration" selector="days:hours:minutes:seconds:nanoseconds:">days: d hours: h minutes: m seconds: s nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;d&gt; days, &lt;h&gt; hours, &lt;m&gt; minutes, &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{Timepoint now + (ScientificDuration days: 182 hours: 24 minutes: 10 seconds: -59 nanoseconds: -1)}"	"{Timepoint now + (CivilDuration days: 182 hours: 24 minutes: 10 seconds: -59 nanoseconds: -1)}"	^self new		setDays: d hours: h minutes: m seconds: s nanoseconds: n;		beImmutable</body><body package="Chronos-Duration" selector="hours:">hours: h	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours."	"{(ScientificDuration hours: -8) asTimezone}"	^self new		setHours: h;		beImmutable</body><body package="Chronos-Duration" selector="hours:minutes:seconds:">hours: h minutes: m seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds."	"{ScientificDuration hours: 1.5 minutes: 1.5 seconds: 1.5}"	^self new		setHours: h minutes: m seconds: s;		beImmutable</body><body package="Chronos-Duration" selector="hours:minutes:seconds:nanoseconds:">hours: h minutes: m seconds: s nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;h&gt; hours, &lt;m&gt; minutes and &lt;s&gt; seconds."	"{ScientificDuration hours: 1.5 minutes: 1.5 seconds: 1.5 nanoseconds: 1}"	^self new		setHours: h minutes: m seconds: s nanoseconds: n;		beImmutable</body><body package="Chronos-Duration" selector="microseconds:">microseconds: microseconds	"Answer an immutable durational value representing a temporal extent of &lt;microseconds&gt; microseconds."	"{ScientificDuration microseconds: 1.5}"	"{(ScientificDuration microseconds: (AnsiStandardCalendarClock now microsecondsSinceEpoch)) asDateAndTime}"	^microseconds isInteger		ifTrue: [self nanoseconds: ((microseconds * 125) bitShift: 3)]		ifFalse: [self seconds: microseconds / MicrosecondsPerSecond]</body><body package="Chronos-Duration" selector="milliseconds:">milliseconds: milliseconds	"Answer an immutable durational value representing a temporal extent of &lt;milliseconds&gt; milliseconds."	"{ScientificDuration milliseconds: 1.5}"	"{(ScientificDuration milliseconds: (AnsiStandardCalendarClock now millisecondsSinceEpoch)) asDateAndTime}"	^milliseconds isInteger		ifTrue: [self nanoseconds: ((milliseconds * 15625) bitShift: 6)]		ifFalse: [self seconds: milliseconds / MillisecondsPerSecond]</body><body package="Chronos-Duration" selector="minutes:">minutes: m	"Answer an immutable durational value representing a temporal extent of &lt;m&gt; minutes."	"{ScientificDuration minutes: 1.5}"	^self new		setMinutes: m;		beImmutable</body><body package="Chronos-Duration" selector="nanoseconds:">nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;n&gt; nanoseconds."	"{ScientificDuration nanoseconds: -1000000001}"	"{ScientificDuration seconds: -1 nanoseconds: 1}"	"{(ScientificDuration nanoseconds: (AnsiStandardCalendarClock now nanosecondsSinceEpoch)) asDateAndTime}"	^self new		setNanoseconds: n;		beImmutable</body><body package="Chronos-Parsing" selector="readFrom:using:">readFrom: stream using: aChronosParser	"Create an object based on the contents of &lt;stream&gt;, as interpreted by &lt;aChronosParser&gt;"	^(ChronosParser referencedBy: aChronosParser) nextDurationFrom: stream usingFactory: self</body><body package="Chronos-Duration" selector="seconds:">seconds: s	"Answer an immutable durational value representing a temporal extent of &lt;s&gt; seconds."	"Specified and required by the ANSI-Smalltalk Standard."	"{ScientificDuration seconds: SecondsPerDay negated + 1}"	"{(ScientificDuration seconds: (AnsiStandardCalendarClock now fractionalSecondsSinceEpoch)) asDateAndTime}"	^self new		setSeconds: s;		beImmutable</body><body package="Chronos-Duration" selector="seconds:nanoseconds:">seconds: s nanoseconds: n	"Answer an immutable durational value representing a temporal extent of &lt;s&gt; seconds and &lt;n&gt; nanoseconds."	"{ScientificDuration seconds: 1 nanoseconds: 1}"	"{ScientificDuration seconds: 1 nanoseconds: -1}"	"{ScientificDuration seconds: -1 nanoseconds: 1}"	"{ScientificDuration seconds: -1 nanoseconds: -1}"	^self new		setSeconds: s nanoseconds: n;		beImmutable</body></methods><methods><class-id>Chronos.ScientificDuration class</class-id> <category>class initialization</category><body package="Chronos-Duration" selector="initializeClassVariables">initializeClassVariables	"ScientificDuration initializeClassVariables"	Zero := self new beImmutable</body></methods><methods><class-id>Chronos.ScientificDuration class</class-id> <category>accessing</category><body package="Chronos-Duration" selector="zero">zero	"Answer a ScientificDuration that represents a temporal extent of zero."	"Specified and required by the ANSI-Smalltalk Standard."	"ScientificDuration zero"	^Zero</body></methods><methods><class-id>Chronos.JulianEaster</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isDayOfWeekInvariant">isDayOfWeekInvariant	^true</body></methods><methods><class-id>Chronos.JulianEaster</class-id> <category>initialize-release</category><body package="Chronos-Annual Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	calendar := Julian</body><body package="Chronos-Annual Dates" selector="setCalendar:">setCalendar: aCalendar 	self shouldNotImplement</body></methods><methods><class-id>Chronos.JulianEaster</class-id> <category>private-initialize-release</category><body package="Chronos-Annual Dates" selector="basicSetCalendar:">basicSetCalendar: aCalendar	self shouldNotImplement</body></methods><methods><class-id>Chronos.JulianEaster</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="calendarDayInYear:">calendarDayInYear: year 	"{JulianEaster canonical inYear: 2006}"	| modulus19 isoDayOfWeekCardinal daysSinceEpochUpToYear dayOfMonthOfPaschalMoon calendarDay daysSinceEpoch |	modulus19 := year \\ 19.	dayOfMonthOfPaschalMoon := self class paschalMoonTable at: modulus19 + 1.	calendarDay := dayOfMonthOfPaschalMoon calendarDayInYear: year.	daysSinceEpochUpToYear := self calendar daysSinceEpochUpToYear: year.	daysSinceEpoch := daysSinceEpochUpToYear + calendarDay daysSinceStartOfYear.	isoDayOfWeekCardinal := self calendar daysSinceStartOfISOWeekFromDaysSinceEpoch: daysSinceEpoch.	calendarDay := calendarDay addingDays: 6 - isoDayOfWeekCardinal.	"Add zero days if the calendarDay is a Sunday, otherwise add the number of days necessary to advance to the next Sunday"	^self daysOffset = 0 		ifTrue: [calendarDay]		ifFalse: 			[calendarDay 				startingWithYear: year				addingDays: daysOffset				setYearAndCalendarDayInto: [:y :cd | cd]]</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinal">maxDayOfYearOrdinal	"(DayOfMonth month: 4 day: 25 calendar: Julian) maxDayOfYearOrdinal"	^116 + self daysOffset</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinalForYearOfType:">maxDayOfYearOrdinalForYearOfType: yearTypeCode	^(yearTypeCode = 1 ifTrue: [115] ifFalse: [116]) + self daysOffset</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinal">minDayOfYearOrdinal	"(DayOfMonth month: 3 day: 22 calendar: Julian) minDayOfYearOrdinal"	^80 + self daysOffset</body><body package="Chronos-Annual Dates" selector="minDayOfYearOrdinalForYearOfType:">minDayOfYearOrdinalForYearOfType: yearTypeCode	^(yearTypeCode = 1 ifTrue: [80] ifFalse: [81]) + self daysOffset</body></methods><methods><class-id>Chronos.JulianEaster</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processJulianEaster: self</body></methods><methods><class-id>Chronos.JulianEaster class</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="paschalMoonTable">paschalMoonTable	PaschalMoonTable == nil		ifTrue: 			[PaschalMoonTable := Array new: 19.			PaschalMoonTable 				at: 1 put: (DayOfMonth month: 4 day: 5 calendar: Julian);				at: 2 put: (DayOfMonth month: 3 day: 25 calendar: Julian);					at: 3 put: (DayOfMonth month: 4 day: 13 calendar: Julian);				at: 4 put: (DayOfMonth month: 4 day: 2 calendar: Julian);				at: 5 put: (DayOfMonth month: 3 day: 22 calendar: Julian);				at: 6 put: (DayOfMonth month: 4 day: 10 calendar: Julian);					at: 7 put: (DayOfMonth month: 3 day: 30 calendar: Julian);				at: 8 put: (DayOfMonth month: 4 day: 18 calendar: Julian);				at: 9 put: (DayOfMonth month: 4 day: 7 calendar: Julian);				at: 10 put: (DayOfMonth month: 3 day: 27 calendar: Julian);					at: 11 put: (DayOfMonth month: 4 day: 15 calendar: Julian);				at: 12 put: (DayOfMonth month: 4 day: 4 calendar: Julian);				at: 13 put: (DayOfMonth month: 3 day: 24 calendar: Julian);				at: 14 put: (DayOfMonth month: 4 day: 12 calendar: Julian);					at: 15 put: (DayOfMonth month: 4 day: 1 calendar: Julian);				at: 16 put: (DayOfMonth month: 3 day: 21 calendar: Julian);				at: 17 put: (DayOfMonth month: 4 day: 9 calendar: Julian);					at: 18 put: (DayOfMonth month: 3 day: 20 calendar: Julian);				at: 19 put: (DayOfMonth month: 4 day: 17 calendar: Julian)].	^PaschalMoonTable</body></methods><methods><class-id>Chronos.DynamicYearlyCalendar</class-id> <category>queries</category><body package="Chronos-Calendars-Irregular" selector="dayAt:monthDayDo:">dayAt: dayOfYearOrdinal monthDayDo: block2	"For the day of the receiver's year type with the given &lt;dayOfYearOrdinal&gt;, evaluate &lt;block2&gt; with the day's month ordinal and day-of-month ordinal as the first and second arguments (respectively.)"	dayOfYearOrdinal &gt; daysPerYear ifTrue: [^nil].	dayOfYearOrdinal &lt; 1 ifTrue: [^nil].	daysUpToMonthSinceStartOfYear size to: 1 by: -1 do: 		[:monthOrdinal |			| daysUpToMonth |			daysUpToMonth := daysUpToMonthSinceStartOfYear at: monthOrdinal.			dayOfYearOrdinal &gt; daysUpToMonth				ifTrue: [^block2 value: monthOrdinal value: (dayOfYearOrdinal - daysUpToMonth)]]</body><body package="Chronos-Calendars-Irregular" selector="daysInMonthAt:">daysInMonthAt: monthOrdinal	"Answer the number of days in the month of the receiver's year type with the given &lt;monthOrdinal&gt;."	^(monthSpecs at: monthOrdinal) daysPerMonth</body><body package="Chronos-Calendars-Irregular" selector="daysInMonthWithKey:ifAbsent:">daysInMonthWithKey: monthKey ifAbsent: block0	"Answer the number of days in the month of the receiver's year type with the given &lt;monthKey&gt; (semantic identifier.) If there is no month with the given &lt;monthKey&gt; in the receiver's year, answer the result of evaluating &lt;block0&gt;."	^(self monthWithKey: monthKey ifAbsent: [^block0 value]) daysPerMonth</body><body package="Chronos-Calendars-Irregular" selector="daysUpToMonth:">daysUpToMonth: month	"Anwer the number of days from the first day of the year up to (but not including) the first day of the month (in the receiver's year type) with the given &lt;month&gt; ordinal. The answer should be the CARDINAL day-of-year number of the first day of the month."	^(daysUpToMonthSinceStartOfYear at: month)</body><body package="Chronos-Calendars-Irregular" selector="daysUpToMonthWithKey:ifAbsent:">daysUpToMonthWithKey: monthKey ifAbsent: block0	"Anwer the number of days from the first day of the year up to (but not including) the first day of the month (in the receiver's year type) with the given &lt;monthKey&gt; (semantic identifier.) The answer should be the CARDINAL day-of-year number of the first day of the month. If the receiver's year type has no month with the given &lt;monthKey&gt;, answer the result of evaluating &lt;block0&gt;."	| month | 	month := self monthWithKey: monthKey ifAbsent: [^block0 value].	^self daysUpToMonth: month monthOrdinal</body><body package="Chronos-Calendars-Irregular" selector="monthOrdinalForMonthWithKey:ifAbsent:">monthOrdinalForMonthWithKey: monthKey ifAbsent: block0	"Answer the month ordinal of the month with the given &lt;monthKey&gt; (semantic identifier) in the receiver's year type. If the receiver's year type has no month with the given &lt;monthKey&gt;, answer the result of evaluating &lt;block0&gt;." 	^(self monthWithKey: monthKey ifAbsent: [^block0 value]) monthOrdinal</body></methods><methods><class-id>Chronos.DynamicYearlyCalendar</class-id> <category>initialize-release</category><body package="Chronos-Calendars-Irregular" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.		monthSpecs := #().	daysUpToMonthSinceStartOfYear := #().</body></methods><methods><class-id>Chronos.DynamicYearlyCalendar</class-id> <category>accessing</category><body package="Chronos-Calendars-Irregular" selector="basicDayAt:">basicDayAt: dayOfYearOrdinal 	"Answer the CalendarDay with the given &lt;dayOfYearOrdinal&gt;.  Fail if the &lt;dayOfYearOrdinal&gt; is invalid."	^self dayAt: dayOfYearOrdinal monthDayDo: 		[:month :dayOfMonth | self basicMonthAt: month dayAt: dayOfMonth]</body><body package="Chronos-Calendars-Irregular" selector="basicMonthAt:dayAt:">basicMonthAt: monthOrdinal dayAt: day	"Answer the CalendarDay with the given &lt;monthOrdinal&gt; and &lt;day&gt;-of-month ordinal.  Fail if either the &lt;monthOrdinal&gt; or the the &lt;day&gt;-of-month ordinal are invalid."	^(self newMonthlyCalendarAt: monthOrdinal) basicDayAt: day</body><body package="Chronos-Calendars-Irregular" selector="dayAt:">dayAt: dayOfYearOrdinal	"Answer the CalendarDay with the given &lt;dayOfYearOrdinal&gt;.  Answer nil if the &lt;dayOfYearOrdinal&gt; is invalid."	^self dayAt: dayOfYearOrdinal monthDayDo: 		[:month :dayOfMonth | self monthAt: month dayAt: dayOfMonth]</body><body package="Chronos-Calendars-Irregular" selector="firstMonth">firstMonth	"Answer the MonthlyCalendar instance that specifies the properties of the first month of the receiver's year."	^self newMonthlyCalendarAt: 1</body><body package="Chronos-Calendars-Irregular" selector="lastMonth">lastMonth	"Answer the MonthlyCalendar instance that specifies the properties of the last month of the receiver's year."	^self newMonthlyCalendarAt: self monthsPerYear</body><body package="Chronos-Calendars-Irregular" selector="monthAt:">monthAt: monthOrdinal	"Answer the MonthlyCalendar for the month with the given &lt;monthOrdinal&gt;. Answer nil if the &lt;monthOrdinal&gt; is invalid."	^(monthOrdinal &gt; self monthsPerYear or: [monthOrdinal &lt; 1])		ifFalse: [self newMonthlyCalendarAt: monthOrdinal]</body><body package="Chronos-Calendars-Irregular" selector="monthsPerYear">monthsPerYear	"Answer the number of months in the type of year whose properties are specified by the receiver."	^monthSpecs size</body></methods><methods><class-id>Chronos.DynamicYearlyCalendar</class-id> <category>private</category><body package="Chronos-Calendars-Irregular" selector="monthWithKey:ifAbsent:">monthWithKey: monthKey ifAbsent: block0	^monthSpecs detect: [:each | each monthKey == monthKey] ifNone: block0</body><body package="Chronos-Calendars-Irregular" selector="monthlyCalendarClass">monthlyCalendarClass	"Answer the concrete subclass of MonthlyCalendar that should be used to instantiate MonthlyCalendars to represent the months of the receiver's year."	^DynamicMonthlyCalendar</body><body package="Chronos-Calendars-Irregular" selector="newMonthlyCalendarAt:">newMonthlyCalendarAt: monthOrdinal	^self monthlyCalendarClass		monthInYear: self 		monthOrdinal: monthOrdinal 		daysUpToMonthSinceStartOfYear: (daysUpToMonthSinceStartOfYear at: monthOrdinal)		specification: (monthSpecs at: monthOrdinal)</body><body package="Chronos-Calendars-Irregular" selector="setMonthsInYear:">setMonthsInYear: specificationOfMonths	"Initialize the receiver so that its month structure is as specified by &lt;specificationOfMonths&gt;--which is an Array of MonthlyCalendarSpecs, such that the entry in the Array whose index is M specifies the properties of the month whose month ordinal is also M. Fail if the receiver is immutable."	| leapMonthStream leapDaySet  |	self assertMutability.	monthSpecs := specificationOfMonths.	daysUpToMonthSinceStartOfYear := Array new: monthSpecs size.	daysPerYear := 0.	intercalaryMonthCount := 0.	leapMonthOrdinals := Array new.	leapMonthStream := leapMonthOrdinals writeStream.	leapDaySet := Set new.	1 to: monthSpecs size do: [:monthOrdinal | 		| month daysPerMonth |		daysUpToMonthSinceStartOfYear at: monthOrdinal put: daysPerYear.		month := monthSpecs at: monthOrdinal.		daysPerMonth := month daysPerMonth.		month isIntercalaryMonth 			ifTrue: 				[intercalaryMonthCount := intercalaryMonthCount + 1.				month isLeapMonth 					ifTrue: 						[leapMonthStream nextPut: monthOrdinal.						month dayOfMonthOrdinalsDo: [:dayOfMonth | leapDaySet add: dayOfMonth + daysPerYear]]].		month leapDayOrdinalsDo: [:leapDayOrdinal | leapDaySet add: (leapDayOrdinal + daysPerYear)].		daysPerYear := daysPerYear + daysPerMonth].	leapMonthOrdinals := leapMonthStream contents.	leapDayOrdinals := leapDaySet asArray.</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>converting</category><body package="Passport-Kernel" selector="asDouble">asDouble	^0.0 asDouble</body><body package="Passport-Kernel" selector="asFloat">asFloat	^0.0</body><body package="Passport-Kernel" selector="asInteger">asInteger	^0</body><body package="Passport-Kernel" selector="asRational">asRational	^PassportNotANumber canonical</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>private-arithmetic</category><body package="Passport-Kernel" selector="addedToInfinitesimal:">addedToInfinitesimal: anInfinitesimal	^isNegative == anInfinitesimal negative		ifTrue: [self]		ifFalse: [PassportNotANumber canonical]</body><body package="Passport-Kernel" selector="addedToInfinity:">addedToInfinity: anInfinity	^anInfinity</body><body package="Passport-Kernel" selector="dividingInfinitesimal:">dividingInfinitesimal: anInfinitesimal	^PassportNotANumber canonical</body><body package="Passport-Kernel" selector="dividingInfinity:">dividingInfinity: anInfinity	^isNegative == anInfinity negative		ifTrue: [isNegative ifTrue: [anInfinity abs] ifFalse: [anInfinity]]		ifFalse: [isNegative ifTrue: [anInfinity negated] ifFalse: [anInfinity]]</body><body package="Passport-Kernel" selector="multipliedByInfinitesimal:">multipliedByInfinitesimal: anInfinitesimal	^isNegative == anInfinitesimal negative		ifTrue: [isNegative ifTrue: [self abs] ifFalse: [self]]		ifFalse: [isNegative ifTrue: [self] ifFalse: [anInfinitesimal]]</body><body package="Passport-Kernel" selector="multipliedByInfinity:">multipliedByInfinity: anInfinity	^PassportNotANumber canonical</body><body package="Passport-Kernel" selector="subtractedFromInfinitesimal:">subtractedFromInfinitesimal: anInfinitesimal	^isNegative == anInfinitesimal negative		ifTrue: [PassportNotANumber canonical]		ifFalse: [anInfinitesimal]</body><body package="Passport-Kernel" selector="subtractedFromInfinity:">subtractedFromInfinity: anInfinity	^anInfinity</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>arithmetic</category><body package="Passport-Kernel" selector="*">* factor 	^factor multipliedByInfinitesimal: self</body><body package="Passport-Kernel" selector="+">+ addend 	^addend addedToInfinitesimal: self</body><body package="Passport-Kernel" selector="-">- subtrahend 	^subtrahend subtractedFromInfinitesimal: self</body><body package="Passport-Kernel" selector="/">/ divisor 	^divisor dividingInfinitesimal: self</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>private-comparing</category><body package="Passport-Kernel" selector="compareToInfinitesimal:">compareToInfinitesimal: anInfinitesimal	^anInfinitesimal negative 		ifTrue: [isNegative ifTrue: [0] ifFalse: [-1]]		ifFalse: [isNegative ifTrue: [1] ifFalse: [0]]</body><body package="Passport-Kernel" selector="compareToInfinity:">compareToInfinity: anInfinity 	^anInfinity negative ifTrue: [-1] ifFalse: [1]</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>testing</category><body package="Passport-Kernel" selector="isInfinitesimal">isInfinitesimal	^true</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>comparing</category><body package="Passport-Kernel" selector="compareTo:">compareTo: otherMagnitude	"Compare the value of the receiver to that of &lt;otherMagnitude&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;otherMagnitude&gt; are the same.)"	self == otherMagnitude ifTrue: [^0].	^[otherMagnitude compareToInfinitesimal: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == otherMagnitude and: [ex message selector == #compareToInfinitesimal:])					ifTrue: [ex return: (isNegative ifTrue: [otherMagnitude &lt; 0 ifTrue: [1] ifFalse: [-1]] ifFalse: [otherMagnitude &gt; 0 ifTrue: [-1] ifFalse: [1]])]					ifFalse: [ex pass]]</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>truncation and roundoff</category><body package="Passport-Kernel" selector="truncated">truncated	^0</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>printing</category><body package="Passport-Kernel" selector="printOn:">printOn: stream	super printOn: stream.	stream nextPutAll: 'infinitesimal'</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>private-arithmetic-VW</category><body package="Passport-Kernel-VW" selector="differenceFromNumber:">differenceFromNumber: aNumber	^aNumber isZero 		ifTrue: [self negated]		ifFalse: [aNumber]</body><body package="Passport-Kernel-VW" selector="quotientFromNumber:">quotientFromNumber: aNumber 	aNumber isZero ifTrue: [^0].	^PassportInfinity polarity: aNumber negative == self negative</body><body package="Passport-Kernel-VW" selector="sumFromNumber:">sumFromNumber: aNumber	^aNumber isZero 		ifTrue: [self]		ifFalse: [aNumber]</body></methods><methods><class-id>Passport.PassportInfinitesimal</class-id> <category>private-comparing-VW</category><body package="Passport-Kernel-VW" selector="lessFromInfinitesimal:">lessFromInfinitesimal: anInfinitesimal	^isNegative		ifTrue: [anInfinitesimal positive]		ifFalse: [false]</body><body package="Passport-Kernel-VW" selector="lessFromInfinity:">lessFromInfinity: anInfinity	^anInfinity positive</body></methods><methods><class-id>Passport.PassportInfinitesimal class</class-id> <category>unit test</category><body package="Passport-Kernel" selector="testDoIts">testDoIts	"0 &gt; PassportInfinitesimal positive 	PassportInfinitesimal positive &lt; 0	0 &lt; PassportInfinitesimal positive 	PassportInfinitesimal positive &gt; 0	0 &gt; PassportInfinitesimal negative 	PassportInfinitesimal negative &lt; 0	0 &lt; PassportInfinitesimal negative 	PassportInfinitesimal negative &gt; 0	PassportInfinitesimal positive &lt; PassportInfinity negative 	PassportInfinitesimal negative &gt; PassportInfinity positive	7 + PassportInfinitesimal positive	PassportInfinitesimal positive + 7	7 - PassportInfinitesimal positive	PassportInfinitesimal positive - 7	7 * PassportInfinitesimal positive	PassportInfinitesimal positive * 7	7 / PassportInfinitesimal positive	PassportInfinitesimal positive / 7	7 + PassportInfinitesimal negative	PassportInfinitesimal negative + 7	7 - PassportInfinitesimal negative	PassportInfinitesimal negative - 7	7 * PassportInfinitesimal negative	PassportInfinitesimal negative * 7	7 / PassportInfinitesimal negative	PassportInfinitesimal negative / 7	-7 + PassportInfinitesimal positive	PassportInfinitesimal positive + -7	-7 - PassportInfinitesimal positive	PassportInfinitesimal positive - -7	-7 * PassportInfinitesimal positive	PassportInfinitesimal positive * -7	-7 / PassportInfinitesimal positive	PassportInfinitesimal positive / -7	-7 + PassportInfinitesimal negative	PassportInfinitesimal negative + -7	-7 - PassportInfinitesimal negative	PassportInfinitesimal negative - -7	-7 * PassportInfinitesimal negative	PassportInfinitesimal negative * -7	-7 / PassportInfinitesimal negative	PassportInfinitesimal negative / -7"</body></methods><methods><class-id>Passport.PassportInfinitesimal class</class-id> <category>class initialization</category><body package="Passport-Kernel" selector="initialize">initialize	"PassportInfinitesimal initialize."	Positive := nil.	Negative := nil.</body></methods><methods><class-id>Passport.PassportInfinitesimal class</class-id> <category>constants</category><body package="Passport-Kernel" selector="negative">negative	Negative == nil ifTrue: [Negative := self basicNew beNegative].	^Negative</body><body package="Passport-Kernel" selector="positive">positive	Positive == nil ifTrue: [Positive := self basicNew bePositive].	^Positive</body></methods><methods><class-id>Chronos.LeapSecond</class-id> <category>accessing</category><body package="Chronos-Timescales" selector="calendricalSecondsSinceEpoch">calendricalSecondsSinceEpoch	^calendricalSecondsSinceEpoch</body><body package="Chronos-Timescales" selector="dateAndTimeSpec">dateAndTimeSpec	^DateAndTimeSpec daysSinceEpoch: daysSinceEpoch seconds: secondsSinceStartOfDay</body><body package="Chronos-Timescales" selector="daysSinceEpoch">daysSinceEpoch	^daysSinceEpoch</body><body package="Chronos-Timescales" selector="firstScientificSecondSinceEpoch">firstScientificSecondSinceEpoch	^firstScientificSecondSinceEpoch</body><body package="Chronos-Timescales" selector="lastScientificSecondSinceEpoch">lastScientificSecondSinceEpoch	^lastScientificSecondSinceEpoch</body><body package="Chronos-Timescales" selector="next">next	^next</body><body package="Chronos-Timescales" selector="postNetLeapSeconds">postNetLeapSeconds	^postNetLeapSeconds</body><body package="Chronos-Timescales" selector="preNetLeapSeconds">preNetLeapSeconds	^preNetLeapSeconds</body><body package="Chronos-Timescales" selector="prev">prev	^prev</body><body package="Chronos-Timescales" selector="secondsDelta">secondsDelta	^secondsDelta</body><body package="Chronos-Timescales" selector="secondsSinceStartOfDay">secondsSinceStartOfDay	^secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.LeapSecond</class-id> <category>initialize-release</category><body package="Chronos-Timescales" selector="beImmutable">beImmutable	"Make the receiver immutable.  Idempotent.  Must answer the receiver."	self isMutable 		ifTrue: 			[super beImmutable.			next == nil ifFalse: [next beImmutable].			prev == nil ifFalse: [prev beImmutable]]</body><body package="Chronos-Timescales" selector="beRelativeToLocalTime">beRelativeToLocalTime	self assertMutability.	isRelativeToUT := false</body><body package="Chronos-Timescales" selector="beRelativeToUT">beRelativeToUT	self assertMutability.	isRelativeToUT := true</body><body package="Chronos-Timescales" selector="initialize">initialize	self assertMutability.	prev := nil.	next := nil.	secondsDelta := 0.	preNetLeapSeconds := 0.	postNetLeapSeconds := 0.	daysSinceEpoch := 0. 	secondsSinceStartOfDay := 0. 	calendricalSecondsSinceEpoch := 0.	firstScientificSecondSinceEpoch := 0.	lastScientificSecondSinceEpoch := 0.	isRelativeToUT := true.</body><body package="Chronos-Timescales" selector="next:">next: aLeapSecond 	aLeapSecond == next 		ifFalse: 			[next == nil ifFalse: [next prev: nil].			self basicNext: aLeapSecond.			aLeapSecond == nil ifFalse: [aLeapSecond prev: self]]</body><body package="Chronos-Timescales" selector="prev:">prev: aLeapSecond 	aLeapSecond == prev 		ifFalse: 			[prev == nil ifFalse: [prev next: nil].			self basicPrev: aLeapSecond.			aLeapSecond == nil ifFalse: [aLeapSecond next: self]]</body><body package="Chronos-Timescales" selector="setSecondsDelta:preNetLeapSeconds:daysSinceEpoch:secondsSinceStartOfDay:">setSecondsDelta: leapSeconds preNetLeapSeconds: preNetLeapSecs daysSinceEpoch: days secondsSinceStartOfDay: timeOfDayAsSeconds	self assertMutability.	secondsDelta := leapSeconds.	preNetLeapSeconds := preNetLeapSecs.	postNetLeapSeconds := preNetLeapSeconds + secondsDelta.	daysSinceEpoch := days.	secondsSinceStartOfDay := timeOfDayAsSeconds.	calendricalSecondsSinceEpoch := (daysSinceEpoch * SecondsPerDay) + secondsSinceStartOfDay.	firstScientificSecondSinceEpoch := calendricalSecondsSinceEpoch + preNetLeapSeconds.	lastScientificSecondSinceEpoch := firstScientificSecondSinceEpoch + secondsDelta - 1</body></methods><methods><class-id>Chronos.LeapSecond</class-id> <category>queries</category><body package="Chronos-Timescales" selector="daysSinceDaySinceEpoch:">daysSinceDaySinceEpoch: daySinceEpoch 	^daysSinceEpoch - daySinceEpoch</body><body package="Chronos-Timescales" selector="daysUntilDaySinceEpoch:">daysUntilDaySinceEpoch: daySinceEpoch 	^daySinceEpoch - daysSinceEpoch</body><body package="Chronos-Timescales" selector="inEffectAtCalendricalSecondSinceEpoch:">inEffectAtCalendricalSecondSinceEpoch: secondSinceEpoch 	^secondSinceEpoch &gt;= calendricalSecondsSinceEpoch		ifTrue: 			[next == nil 				ifTrue: [self]				ifFalse: 					[secondSinceEpoch &lt; next calendricalSecondsSinceEpoch 						ifTrue: [self]						ifFalse: [next inEffectAtCalendricalSecondSinceEpoch: secondSinceEpoch]]]		ifFalse: 			[prev == nil 				ifFalse: [prev inEffectAtCalendricalSecondSinceEpoch: secondSinceEpoch]]</body><body package="Chronos-Timescales" selector="inEffectAtDaySinceEpoch:">inEffectAtDaySinceEpoch: daySinceEpoch 	^daySinceEpoch &gt;= daysSinceEpoch		ifTrue: 			[next == nil 				ifTrue: [self]				ifFalse: 					[daySinceEpoch &lt; next daysSinceEpoch 						ifTrue: [self]						ifFalse: [next inEffectAtDaySinceEpoch: daySinceEpoch]]]		ifFalse: 			[prev == nil 				ifFalse: [prev inEffectAtDaySinceEpoch: daySinceEpoch]]</body><body package="Chronos-Timescales" selector="inEffectAtScientificSecondSinceEpoch:">inEffectAtScientificSecondSinceEpoch: secondSinceEpoch 	^secondSinceEpoch &gt;= firstScientificSecondSinceEpoch		ifTrue: 			[next == nil 				ifTrue: [self]				ifFalse: 					[secondSinceEpoch &lt; next firstScientificSecondSinceEpoch 						ifTrue: [self]						ifFalse: [next inEffectAtScientificSecondSinceEpoch: secondSinceEpoch]]]		ifFalse: 			[prev == nil 				ifFalse: [prev inEffectAtScientificSecondSinceEpoch: secondSinceEpoch]]</body><body package="Chronos-Timescales" selector="intervalIncludesScientificSecondSinceEpoch:">intervalIncludesScientificSecondSinceEpoch: secondSinceEpoch 	^secondsDelta &gt; 1		ifTrue: 			[secondSinceEpoch 				between: firstScientificSecondSinceEpoch				and: lastScientificSecondSinceEpoch]		ifFalse: [secondSinceEpoch = firstScientificSecondSinceEpoch]</body><body package="Chronos-Timescales" selector="secondsSinceCalendricalSecondSinceEpoch:">secondsSinceCalendricalSecondSinceEpoch: secondSinceEpoch 	^calendricalSecondsSinceEpoch - secondSinceEpoch</body><body package="Chronos-Timescales" selector="secondsSinceScientificSecondSinceEpoch:">secondsSinceScientificSecondSinceEpoch: secondSinceEpoch 	^secondsDelta &gt; 1		ifTrue: 			[| diff |			diff := firstScientificSecondSinceEpoch - secondSinceEpoch.			diff &lt;= 0				ifTrue: 					[diff := lastScientificSecondSinceEpoch - secondSinceEpoch.					diff &gt;= 0						ifTrue: [0]						ifFalse: [diff]]				ifFalse: [diff]]		ifFalse: [firstScientificSecondSinceEpoch - secondSinceEpoch]</body><body package="Chronos-Timescales" selector="secondsUntilCalendricalSecondSinceEpoch:">secondsUntilCalendricalSecondSinceEpoch: secondSinceEpoch 	^secondSinceEpoch - calendricalSecondsSinceEpoch</body><body package="Chronos-Timescales" selector="secondsUntilScientificSecondSinceEpoch:">secondsUntilScientificSecondSinceEpoch: secondSinceEpoch 	^secondsDelta &gt; 1		ifTrue: 			[| diff |			diff :=  secondSinceEpoch - firstScientificSecondSinceEpoch.			diff &gt;= 0				ifTrue: 					[diff :=  secondSinceEpoch - lastScientificSecondSinceEpoch.					diff &lt;= 0						ifTrue: [0]						ifFalse: [diff]]				ifFalse: [diff]]		ifFalse: [secondSinceEpoch - firstScientificSecondSinceEpoch]</body></methods><methods><class-id>Chronos.LeapSecond</class-id> <category>testing</category><body package="Chronos-Timescales" selector="isRelativeToLocalTime">isRelativeToLocalTime	^isRelativeToUT not</body><body package="Chronos-Timescales" selector="isRelativeToUT">isRelativeToUT	^isRelativeToUT</body></methods><methods><class-id>Chronos.LeapSecond</class-id> <category>private</category><body package="Chronos-Timescales" selector="basicNext:">basicNext: aLeapSecond	"Allowed even if not mutable."	next := aLeapSecond</body><body package="Chronos-Timescales" selector="basicPrev:">basicPrev: aLeapSecond	self assertMutability.	prev := aLeapSecond</body></methods><methods><class-id>Chronos.LeapSecond</class-id> <category>printing</category><body package="Chronos-Timescales" selector="printOn:">printOn: stream	super printOn: stream.	stream		nextPut: $(;		print: self dateAndTimeSpec;		nextPutAll: ' | delta seconds=';		print: secondsDelta;		nextPutAll: ' | pre net leap seconds=';		print: preNetLeapSeconds;		nextPutAll: ' | post net leap seconds=';		print: postNetLeapSeconds;		nextPut: $)</body></methods><methods><class-id>Chronos.LeapSecond class</class-id> <category>instance creation</category><body package="Chronos-Timescales" selector="withSecondsDelta:preNetLeapSeconds:daysSinceEpoch:secondsSinceStartOfDay:isRelativeToUT:">withSecondsDelta: secondsDelta preNetLeapSeconds: preNetLeapSeconds daysSinceEpoch: daysSinceEpoch secondsSinceStartOfDay: secondsSinceStartOfDay isRelativeToUT: isRelativeToUT 	| ls |	ls := self new.	isRelativeToUT ifTrue: [ls beRelativeToUT] ifFalse: [ls beRelativeToLocalTime].	^ls		setSecondsDelta: secondsDelta		preNetLeapSeconds: preNetLeapSeconds		daysSinceEpoch: daysSinceEpoch		secondsSinceStartOfDay: secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.AlwaysDefaultTZ</class-id> <category>testing</category><body package="Chronos-TimeZones" selector="isAlwaysDefault">isAlwaysDefault	"Answer whether the receiver is the `always default` time zone."	^true</body><body package="Chronos-TimeZones" selector="isDefault">isDefault	"Answer whether the receiver is the default time zone."	^true</body></methods><methods><class-id>Chronos.AlwaysDefaultTZ</class-id> <category>converting</category><body package="Chronos-TimeZones" selector="asNonProxy">asNonProxy	"Answer the time zone to which the receiver indirectly refers by proxy.  If the receiver is not a proxy for a time zone other than itself, answer the receiver."	^ChronosTimezone default</body><body package="Chronos-TimeZones" selector="canonical">canonical	"Answer the canonical instance of the receiver's class whose value is equivalent to that of the receiver's."	^ChronosTimezone alwaysDefault</body></methods><methods><class-id>Chronos.AlwaysDefaultTZ</class-id> <category>processing</category><body package="Chronos-TimeZones" selector="processBy:">processBy: aTimezoneProcessor	"Visitor pattern; see TimezoneProcessor"	aTimezoneProcessor processAlwaysDefaultTZ: self</body></methods><methods><class-id>Chronos.AlwaysDefaultTZ</class-id> <category>private</category><body package="Chronos-TimeZones" selector="defaultNameIfNone:">defaultNameIfNone: noneblock	^'Dynamic Local Time (User)'</body></methods><methods><class-id>Chronos.AlwaysDefaultTZ class</class-id> <category>private</category><body package="Chronos-TimeZones" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray 	"Construct an object from the values containted in &lt;literalArray&gt;, which is an array that specifies the class and attributes of an object. The first element of &lt;literalArray&gt; must be the name of the class that should be responsible for constructing the object from the remaining components of &lt;literalArray&gt;. It is required that the receiver of #basicDecodeFromLiteralArray: be the class named by the first element of &lt;literalArray&gt;."	^self alwaysDefault</body></methods><methods><class-id>Chronos.AlwaysDefaultTZ class</class-id> <category>accessing</category><body package="Chronos-TimeZones" selector="registrationKey">registrationKey	"Anser the canonical key that uniquely identifies the receiver's canonical instance."	^#alwaysDefault</body></methods><methods><class-id>Passport.VWFtpUrlFacade</class-id> <category>accessing</category><body package="Passport-Kernel-VW" selector="protocol">protocol	^#ftp</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>private</category><body package="Chronos-Annual Dates" selector="computeMaxDayOfYearOrdinal">computeMaxDayOfYearOrdinal	^self maximumDayOfYearOrdinalOfDayOfMonth: 		(dayOfMonthOrdinal &gt; 0 			ifTrue: [dayOfMonthOrdinal]			ifFalse: [self maximumDaysPerMonth + dayOfMonthOrdinal])</body><body package="Chronos-Annual Dates" selector="computeMinDayOfYearOrdinal">computeMinDayOfYearOrdinal	^self minimumDayOfYearOrdinalOfDayOfMonth: 		(dayOfMonthOrdinal &gt; 0 			ifTrue: [dayOfMonthOrdinal]			ifFalse: [self minimumDaysPerMonth + dayOfMonthOrdinal])</body><body package="Chronos-Annual Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream 	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream nextPut:  self dayOfMonthOrdinal</body><body package="Chronos-Annual Dates" selector="value:value:">value: aYear value: aCalendarDay 	self		setMonthOrdinal: aCalendarDay month;		setDayOfMonthOrdinal: aCalendarDay dayOfMonth</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>accessing</category><body package="Chronos-Annual Dates" selector="dayOfMonth">dayOfMonth	^dayOfMonthOrdinal</body><body package="Chronos-Annual Dates" selector="dayOfMonthOrdinal">dayOfMonthOrdinal	^dayOfMonthOrdinal</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfMonth">daysSinceStartOfMonth	"Answer the number of days since the first day of the receiver's month up to (but not including) the day represented by the receiver. The answer is the CARDINAL number of the day of the month represented by the receiver."	^dayOfMonthOrdinal - 1</body><body package="Chronos-Annual Dates" selector="identifiersDo:">identifiersDo: block2	super identifiersDo: block2.	block2 value: #dayOfMonthOrdinal value: self dayOfMonthOrdinal.</body><body package="Chronos-Annual Dates" selector="resolutionQuantum">resolutionQuantum	"Answer a Duration whose value indicates the receiver's quantum of temporal resolution--the resolution of its ability to represent time.  The quantum of temporal resolution is the minimum non-zero temporal extent by which two instances of the receiver's class can differ in value."	^CalendarDayDuration</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>queries</category><body package="Chronos-Annual Dates" selector="calendarDayInYear:">calendarDayInYear: year 	| yearTypeCode mOrdinal |	yearTypeCode := self calendar typeCodeOfYear: year.	mOrdinal := self monthOrdinalForYearTypeCode: yearTypeCode.	^self calendar 		calendarDayFromMonth: mOrdinal		day: (dayOfMonthOrdinal &gt; 0 				ifTrue: [dayOfMonthOrdinal]				ifFalse: 					[(self calendar daysInMonth: mOrdinal forYearTypeCode: yearTypeCode) + dayOfMonthOrdinal])		forYearTypeCode: yearTypeCode</body><body package="Chronos-Annual Dates" selector="dayOfMonthOrdinalInYear:">dayOfMonthOrdinalInYear: year 	^dayOfMonthOrdinal &gt; 0 		ifTrue: [dayOfMonthOrdinal]		ifFalse: [(self daysInMonthInYear: year) + dayOfMonthOrdinal]</body><body package="Chronos-Annual Dates" selector="daysSinceStartOfMonthInYear:">daysSinceStartOfMonthInYear: year	^(self dayOfMonthOrdinalInYear: year) - 1</body><body package="Chronos-Annual Dates" selector="eitherYearMonthDayDo:orYearMonthkeyDayDo:">eitherYearMonthDayDo: block3a orYearMonthkeyDayDo: block3b	"If the receiver's month ordinal is unambigously specified, evaluate &lt;block3a&gt; with the receiver's year, its month ordinal and its day-of-month ordinal as the arguments. Otherwise, evaluate &lt;block3b&gt; with the receiver's year,  the semantic key that identifies the receiver's month and its day-of-month ordinal as the arguments."	^self isMonthOrdinalResolvable		ifTrue: [block3a value: nil value: self monthOrdinal value: self dayOfMonthOrdinal]		ifFalse: [block3b value: nil value: self monthKey value: self dayOfMonthOrdinal]</body><body package="Chronos-Annual Dates" selector="forYear:monthDayDo:">forYear: year monthDayDo: block2 	^block2 		value: (self monthOrdinalForYearTypeCode: (self calendar typeCodeOfYear: year))		value: (self dayOfMonthOrdinalInYear: year)</body><body package="Chronos-Annual Dates" selector="maxDayOfYearOrdinalForYearOfType:">maxDayOfYearOrdinalForYearOfType: yearTypeCode 	^self eitherMonthOrdinalDo: 			[:month | 			(self calendar 				calendarDayFromMonth: month				day: self dayOfMonth				forYearTypeCode: yearTypeCode) dayOfYear]		orMonthkeyDo: 			[:month | 			(self calendar 				calendarDayFromMonth: (self resolveMonthOrdinalFromMonthKey: month forYearTypeCode: yearTypeCode)				day: self dayOfMonth				forYearTypeCode: yearTypeCode) dayOfYear]</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>private-comparing</category><body package="Chronos-Annual Dates" selector="compareToDayOfMonth:">compareToDayOfMonth: aDayOfMonth	aDayOfMonth == self ifTrue: [^0].	aDayOfMonth calendar = self calendar ifFalse: [^nil].	^aDayOfMonth minDayOfYearOrdinal - self minDayOfYearOrdinal</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>initialize-release</category><body package="Chronos-Annual Dates" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.		dayOfMonthOrdinal := 1.</body><body package="Chronos-Annual Dates" selector="initializeFrom:">initializeFrom: aCalendricalCoordinate	self 		basicSetCalendar: aCalendricalCoordinate calendar;		setMonthOrdinal: aCalendricalCoordinate monthOrdinal;		setDayOfMonthOrdinal: aCalendricalCoordinate dayOfMonthOrdinal</body><body package="Chronos-Annual Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	super initializeFromLiteralArray: literalArray.	self setDayOfMonthOrdinal: (literalArray at: 4) asNumber</body><body package="Chronos-Annual Dates" selector="setDayOfMonthOrdinal:">setDayOfMonthOrdinal: dayOfMonth	"If &lt;dayOfMonth&gt; &lt;= 0, then it is interpreted as &lt;dayOfMonth&gt; days from the last day of the month."	self assertMutability.	dayOfMonthOrdinal := dayOfMonth</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>comparing</category><body package="Chronos-Annual Dates" selector="compareTo:">compareTo: aCalendrical	"Compare the value of the receiver to that of &lt;aCalendrical&gt;.  If the receiver's value is larger, answer a positive numerical value. If the receiver's value is smaller, answer a negative numerical value.  Otherwise, answer zero (when the value of the receiver and &lt;aCalendrical&gt; are the same.)"	self == aCalendrical ifTrue: [^0].	^[aCalendrical compareToDayOfMonth: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == aCalendrical and: [ex message selector == #compareToDayOfMonth:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="Chronos-Annual Dates" selector="hash">hash	^(super hash + dayOfMonthOrdinal) hash</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>testing</category><body package="Chronos-Annual Dates" selector="isDayOfMonthInvariant">isDayOfMonthInvariant	^dayOfMonthOrdinal &gt; 0</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>converting</category><body package="Chronos-Annual Dates" selector="asDayOfMonth">asDayOfMonth	^self</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>processing</category><body package="Chronos-Annual Dates" selector="processBy:">processBy: annualDateProcessor	annualDateProcessor processDayOfMonth: self</body></methods><methods><class-id>Chronos.DayOfMonth</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	"Delegate the responsibility for printing the receiver on &lt;stream&gt; to &lt;aChronosPrintPolicy&gt;."	(ChronosPrintPolicy referencedBy: aChronosPrintPolicy) printDayOfMonth: self on: stream</body></methods><methods><class-id>Chronos.DayOfMonth class</class-id> <category>examples</category><body package="Chronos-Annual Dates" selector="lastDayOfMonth:inYear:">lastDayOfMonth: month inYear: year	"DayOfMonth lastDayOfMonth: 2 inYear: 2004"	"Note: Don't use this method for real work.  It's only an example.  The right way to do this is to create and reuse a cached set of DayOfMonth instances to do computations of this nature. AnnualDates (such as DayOfMonth, DayOfYear and WeekOfMonthDayOfWeek) are the preferred solution when there are a finite set of incomplete date specifications (e.g, {month, dayOfMonth}, {dayOfYear}, {month, weekOfMonth, dayOfWeek}) whose full date must be repeatedly computed for various years (e.g., holidays.)  A DateAndTime (a.k.a. Timepoint) or YearMonthDay (a.k.a, 'Date') instance would be the preferred solution when the full date is known in advance, or when most or all of the date elements cannot be known in advance."	^(DayOfMonthFactory month: month day: DayOfMonthFactory lastDayOfMonth) inYear: year</body></methods><methods><class-id>Chronos.DayOfMonth class</class-id> <category>instance creation</category><body package="Chronos-Annual Dates" selector="month:day:">month: month day: day	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;dayOfMonth&gt; &lt;= 0, then it is interpreted as &lt;dayOfMonth&gt; days from the last day of the month."	^self new		setMonthOrdinal: month;		setDayOfMonthOrdinal: day;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="month:day:calendar:">month: month day: day calendar: calendar	"If &lt;monthOrdinal&gt; &lt;= 0, then it is interpreted as &lt;monthOrdinal&gt; months from the last month of the year."	"If &lt;dayOfMonth&gt; &lt;= 0, then it is interpreted as &lt;dayOfMonth&gt; days from the last day of the month."	^self new		setCalendar: calendar;		setMonthOrdinal: month;		setDayOfMonthOrdinal: day;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:day:">monthKey: monthKey day: day	"If &lt;dayOfMonth&gt; &lt;= 0, then it is interpreted as &lt;dayOfMonth&gt; days from the last day of the month."	^self new		setMonthKey: monthKey;		setDayOfMonthOrdinal: day;		beImmutable;		yourself</body><body package="Chronos-Annual Dates" selector="monthKey:day:calendar:">monthKey: monthKey day: day calendar: calendar	"If &lt;dayOfMonth&gt; &lt;= 0, then it is interpreted as &lt;dayOfMonth&gt; days from the last day of the month."	^self new		setCalendar: calendar;		setMonthKey: monthKey;		setDayOfMonthOrdinal: day;		beImmutable;		yourself</body></methods><methods><class-id>Chronos.DayOfMonth class</class-id> <category>constants</category><body package="Chronos-Annual Dates" selector="lastDayOfMonth">lastDayOfMonth	^0</body></methods><methods><class-id>Chronos.SemanticAnnualDateRule</class-id> <category>queries</category><body package="Chronos-Semantic Dates" selector="nominalDateInYear:">nominalDateInYear: aYear	^nominalAnnualDate inYear: aYear</body><body package="Chronos-Semantic Dates" selector="nominallyOccursOn:">nominallyOccursOn: aDate 	^nominalAnnualDate = aDate</body><body package="Chronos-Semantic Dates" selector="observanceDateAndTypeInYear:into:ifNone:">observanceDateAndTypeInYear: aYear into: block2 ifNone: ifNoneBlock	^observanceRule == nil		ifTrue: [block2 value: (self nominalDateInYear: aYear) value: #nominal]		ifFalse: [observanceRule observanceDateAndTypeOf: nominalAnnualDate inYear: aYear into: block2 ifNone: ifNoneBlock]</body><body package="Chronos-Semantic Dates" selector="observanceTypeFor:">observanceTypeFor: aDate 	^observanceRule == nil		ifTrue: [(self nominallyOccursOn: aDate) ifTrue: [#nominal] ifFalse: [#none]]		ifFalse: [observanceRule eventObservanceTypeNominallyOccuringOn: nominalAnnualDate for: aDate]</body><body package="Chronos-Semantic Dates" selector="occursInYear:">occursInYear: aYear	"Answer whether the semantic date represented by the receiver nominally occurs in &lt;aYear&gt;."	^observanceRule == nil or: [observanceRule doesEventNominallyOccurInYear: aYear]</body><body package="Chronos-Semantic Dates" selector="occursOn:">occursOn: aDate 	^observanceRule == nil		ifTrue: [self nominallyOccursOn: aDate]		ifFalse: [#(nominal observed) includes: (observanceRule eventObservanceTypeNominallyOccuringOn: nominalAnnualDate for: aDate)]</body></methods><methods><class-id>Chronos.SemanticAnnualDateRule</class-id> <category>accessing</category><body package="Chronos-Semantic Dates" selector="calendar">calendar	^nominalAnnualDate calendar</body><body package="Chronos-Semantic Dates" selector="nominalAnnualDate">nominalAnnualDate	^nominalAnnualDate</body><body package="Chronos-Semantic Dates" selector="observanceRule">observanceRule	^observanceRule</body></methods><methods><class-id>Chronos.SemanticAnnualDateRule</class-id> <category>initialize-release</category><body package="Chronos-Semantic Dates" selector="initializeFromLiteralArray:">initializeFromLiteralArray: literalArray 	"Initialize the receiver from the contents of &lt;literalArray&gt;, which must be an Array of the values that would canonically be used to portably represent and/or transport a value of the receiver's type, stored in canonical positions in the Array, and as would be produced when any object of the receiver's type is sent the message #literalArrayEncoding. Fail if the receiver is not mutable."	self 		setObservanceRule: (literalArray at: 5) decodeAsLiteralArray;		setNominalAnnualDate: (literalArray at: 7) decodeAsLiteralArray.	super initializeFromLiteralArray: literalArray.</body><body package="Chronos-Semantic Dates" selector="setNominalAnnualDate:">setNominalAnnualDate: anAnnualDate	self assertMutability.	nominalAnnualDate := anAnnualDate</body><body package="Chronos-Semantic Dates" selector="setObservanceRule:">setObservanceRule: anObservanceRule 	self assertMutability.	observanceRule := anObservanceRule.</body></methods><methods><class-id>Chronos.SemanticAnnualDateRule</class-id> <category>private</category><body package="Chronos-Semantic Dates" selector="encodeAsLiteralArrayOn:">encodeAsLiteralArrayOn: stream	"Write onto &lt;stream&gt;--in the canoncial order--the attribute values of the receiver that canonically occur in the receiver's `literalArrayEncoding.`  See the comment of the method #literalArrayEncoding for more information (which the receiver either implements or inherits.)"	super encodeAsLiteralArrayOn: stream.	stream 		nextPut: observanceRule literalArrayEncoding;		nextPut: nominalAnnualDate literalArrayEncoding</body></methods><methods><class-id>Chronos.SemanticAnnualDateRule class</class-id> <category>instance creation</category><body package="Chronos-Semantic Dates" selector="semanticKey:effectiveYear:nominalAnnualDate:observanceRule:">semanticKey: semanticKey effectiveYear: effectiveYear nominalAnnualDate: annualDate observanceRule: observanceRule	^self new		setKey: semanticKey;		setEffectiveYear: effectiveYear;		setNominalAnnualDate: annualDate;		setObservanceRule: observanceRule</body></methods><methods><class-id>Passport.VWFileUrlFacade</class-id> <category>accessing</category><body package="Passport-Kernel-VW" selector="protocol">protocol	^#file</body></methods><methods><class-id>Passport.VWFileUrlFacade</class-id> <category>testing</category><body package="Passport-Kernel-VW" selector="syntaxPermitsPort">syntaxPermitsPort	^false</body></methods><methods><class-id>Chronos.LeapSecondSchedule</class-id> <category>accessing</category><body package="Chronos-Timescales" selector="calendricalSecondsSinceEpochOfLastLeapSecond">calendricalSecondsSinceEpochOfLastLeapSecond	^calendricalSecondsSinceEpochOfLastLeapSecond</body><body package="Chronos-Timescales" selector="daysSinceEpochOfFirstLeapSecond">daysSinceEpochOfFirstLeapSecond	^daysSinceEpochOfFirstLeapSecond</body><body package="Chronos-Timescales" selector="daysSinceEpochOfLastLeapSecond">daysSinceEpochOfLastLeapSecond	^daysSinceEpochOfLastLeapSecond</body><body package="Chronos-Timescales" selector="firstScheduledLeapSecond">firstScheduledLeapSecond	^firstLeapSecond</body><body package="Chronos-Timescales" selector="lastScheduledLeapSecond">lastScheduledLeapSecond	^lastLeapSecond</body><body package="Chronos-Timescales" selector="scientificSecondsSinceEpochOfLastLeapSecond">scientificSecondsSinceEpochOfLastLeapSecond	^scientificSecondsSinceEpochOfLastLeapSecond</body><body package="Chronos-Timescales" selector="secondsSinceEpochOfFirstLeapSecond">secondsSinceEpochOfFirstLeapSecond	^secondsSinceEpochOfFirstLeapSecond</body></methods><methods><class-id>Chronos.LeapSecondSchedule</class-id> <category>initialize-release</category><body package="Chronos-Timescales" selector="addLeapSeconds:at:isRelativeToUT:">addLeapSeconds: secondsDelta at: dateAndTimeSpec isRelativeToUT: isRelativeToUT 	self addLeapSeconds: secondsDelta atDaysSinceEpoch: dateAndTimeSpec daysSinceEpoch secondsSinceStartOfDay: dateAndTimeSpec secondsSinceStartOfDay isRelativeToUT: isRelativeToUT</body><body package="Chronos-Timescales" selector="addLeapSeconds:atDaysSinceEpoch:secondsSinceStartOfDay:isRelativeToUT:">addLeapSeconds: secondsDelta atDaysSinceEpoch: daysSinceEpoch secondsSinceStartOfDay: secondsSinceStartOfDay isRelativeToUT: isRelativeToUT 	| secondsSinceEpoch prevLs ls newLs preNetLeapSeconds |	self assertMutability.	secondsSinceEpoch := (daysSinceEpoch * SecondsPerDay) + secondsSinceStartOfDay.	preNetLeapSeconds := 0.	map := Dictionary new.	prevLs := nil.	lastLeapSecond := nil.	ls := firstLeapSecond.	[ls notNil and: [secondsSinceEpoch &gt; ls calendricalSecondsSinceEpoch]] 		whileTrue: 			[self mapLeapSecond: ls.			preNetLeapSeconds := preNetLeapSeconds + ls secondsDelta.			prevLs := ls.			ls := prevLs next].	newLs := LeapSecond withSecondsDelta: secondsDelta preNetLeapSeconds: preNetLeapSeconds daysSinceEpoch: daysSinceEpoch secondsSinceStartOfDay: secondsSinceStartOfDay isRelativeToUT: isRelativeToUT.	prevLs == nil		ifTrue: [firstLeapSecond := newLs]		ifFalse: [newLs prev: prevLs].	self mapLeapSecond: newLs.	prevLs := newLs.	preNetLeapSeconds := preNetLeapSeconds + secondsDelta.	[ls == nil] 		whileFalse: 			[newLs := LeapSecond withSecondsDelta: ls secondsDelta preNetLeapSeconds: preNetLeapSeconds daysSinceEpoch: ls daysSinceEpoch secondsSinceStartOfDay: ls secondsSinceStartOfDay isRelativeToUT: ls isRelativeToUT.			newLs prev: prevLs.			self mapLeapSecond: newLs.			preNetLeapSeconds := preNetLeapSeconds + ls secondsDelta.			prevLs := newLs.			ls := ls next].	recentlyAccessedLeapSecond := lastLeapSecond := prevLs.	lastLeapSecond beImmutable.	daysSinceEpochOfFirstLeapSecond := firstLeapSecond daysSinceEpoch.	daysSinceEpochOfLastLeapSecond := lastLeapSecond daysSinceEpoch.	secondsSinceEpochOfFirstLeapSecond := firstLeapSecond calendricalSecondsSinceEpoch.	calendricalSecondsSinceEpochOfLastLeapSecond := lastLeapSecond calendricalSecondsSinceEpoch.	scientificSecondsSinceEpochOfLastLeapSecond := lastLeapSecond firstScientificSecondSinceEpoch.</body><body package="Chronos-Timescales" selector="beUTC">beUTC	registrationKey == nil 		ifTrue: [registrationKey := #utc]		ifFalse: 			[registrationKey == #utc 				ifFalse: 					[self assertMutability.					registrationKey := #utc]].	self forceRegistration.	UTC := self</body><body package="Chronos-Timescales" selector="initialize">initialize	self assertMutability.	map := Dictionary new.	daysSinceEpochOfFirstLeapSecond := 0.	daysSinceEpochOfLastLeapSecond := 0.	secondsSinceEpochOfFirstLeapSecond := 0.	calendricalSecondsSinceEpochOfLastLeapSecond := 0.	scientificSecondsSinceEpochOfLastLeapSecond := 0.</body><body package="Chronos-Timescales" selector="invalidate">invalidate	^self hasKey 		ifTrue: 			[| replacement |			replacement := ChronosSystemFacade resourceRepositoryContext retrieveLeapSecondSchedule: self key ifNone: [].			replacement == nil 				ifTrue: [self]				ifFalse: 					[replacement := replacement registerButIfPresent: [:collision | "ignore"].					replacement key == #utc ifTrue: [UTC := replacement].					replacement]]		ifFalse: [self]</body></methods><methods><class-id>Chronos.LeapSecondSchedule</class-id> <category>queries</category><body package="Chronos-Timescales" selector="leapSecondAtDaysSinceEpoch:">leapSecondAtDaysSinceEpoch: daysSinceEpoch 	| ls |	ls := map at: daysSinceEpoch ifAbsent: [].	^ls == nil ifFalse: [recentlyAccessedLeapSecond := ls]</body><body package="Chronos-Timescales" selector="leapSecondOnOrBeforeCalendricalSecondsSinceEpoch:">leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: secondsSinceEpoch 	"LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: Timepoint now utSecondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: (DateAndTimeSpec year: 1972 month: 6 day: 30 hour: 23 minute: 59 second: 59) secondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: (DateAndTimeSpec year: 1972 month: 6 day: 30 hour: 23 minute: 59 second: 60) secondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: (DateAndTimeSpec year: 1981 month: 6 day: 30 hour: 23 minute: 59 second: 59) secondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: (DateAndTimeSpec year: 1981 month: 7 day: 1 hour: 0 minute: 0 second: 0) secondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: (DateAndTimeSpec year: 2005 month: 12 day: 31 hour: 23 minute: 59 second: 59) secondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeCalendricalSecondsSinceEpoch: (DateAndTimeSpec year: 2006 month: 1 day: 1 hour: 0 minute: 0 second: 0) secondsSinceEpoch"	| ls |	secondsSinceEpoch &gt;= calendricalSecondsSinceEpochOfLastLeapSecond ifTrue: [^lastLeapSecond].	secondsSinceEpoch &lt; secondsSinceEpochOfFirstLeapSecond ifTrue: [^nil].	ls := recentlyAccessedLeapSecond inEffectAtCalendricalSecondSinceEpoch: secondsSinceEpoch.	ls == nil ifFalse: [recentlyAccessedLeapSecond := ls].	^ls</body><body package="Chronos-Timescales" selector="leapSecondOnOrBeforeDaysSinceEpoch:">leapSecondOnOrBeforeDaysSinceEpoch: daysSinceEpoch	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: Timepoint now utDaysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 1972 month: 6 day: 29) daysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 1972 month: 6 day: 30) daysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 1981 month: 6 day: 29) daysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 1981 month: 6 day: 30) daysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 1981 month: 7 day: 1) daysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 2005 month: 12 day: 30) daysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 2005 month: 12 day: 31) daysSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeDaysSinceEpoch: (DateSpec year: 2006 month: 1 day: 1) daysSinceEpoch"	| ls |	daysSinceEpoch &gt;= daysSinceEpochOfLastLeapSecond ifTrue: [^lastLeapSecond].	daysSinceEpoch &lt; daysSinceEpochOfFirstLeapSecond ifTrue: [^nil].	ls := recentlyAccessedLeapSecond inEffectAtDaySinceEpoch: daysSinceEpoch.	ls == nil ifFalse: [recentlyAccessedLeapSecond := ls].	^ls</body><body package="Chronos-Timescales" selector="leapSecondOnOrBeforeScientificSecondsSinceEpoch:">leapSecondOnOrBeforeScientificSecondsSinceEpoch: secondsSinceEpoch 	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: Timepoint now utSecondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: (DateAndTimeSpec year: 1972 month: 6 day: 30 hour: 23 minute: 59 second: 59) secondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: (DateAndTimeSpec year: 1972 month: 6 day: 30 hour: 23 minute: 59 second: 60) secondsSinceEpoch"	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: (DateAndTimeSpec year: 1981 month: 6 day: 30 hour: 23 minute: 59 second: 59) secondsSinceEpoch + 9"	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: (DateAndTimeSpec year: 1981 month: 7 day: 1 hour: 0 minute: 0 second: 0) secondsSinceEpoch + 9"	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: (DateAndTimeSpec year: 2005 month: 12 day: 31 hour: 23 minute: 59 second: 59) secondsSinceEpoch + 22"	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: (DateAndTimeSpec year: 2005 month: 12 day: 31 hour: 23 minute: 59 second: 60) secondsSinceEpoch + 22"	"LeapSecondSchedule utc leapSecondOnOrBeforeScientificSecondsSinceEpoch: (DateAndTimeSpec year: 2006 month: 1 day: 1 hour: 0 minute: 0 second: 0) secondsSinceEpoch + 22"	| ls |	secondsSinceEpoch &gt;= scientificSecondsSinceEpochOfLastLeapSecond ifTrue: [^lastLeapSecond].	secondsSinceEpoch &lt; secondsSinceEpochOfFirstLeapSecond ifTrue: [^nil].	ls := recentlyAccessedLeapSecond inEffectAtScientificSecondSinceEpoch: secondsSinceEpoch.	ls == nil ifFalse: [recentlyAccessedLeapSecond := ls].	^ls	"ls := lastLeapSecond.	[secondsSinceEpoch &gt;= ls firstScientificSecondSinceEpoch ifTrue: [^ls].	ls := ls prev.	ls == nil] whileFalse.	^nil"</body></methods><methods><class-id>Chronos.LeapSecondSchedule</class-id> <category>enumerating</category><body package="Chronos-Timescales" selector="leapSecondsDo:">leapSecondsDo: block1 	| ls |	ls := firstLeapSecond.	[ls == nil] whileFalse: 			[block1 value: ls.			ls := ls next]</body></methods><methods><class-id>Chronos.LeapSecondSchedule</class-id> <category>printing</category><body package="Chronos-Timescales" selector="encodeOn:">encodeOn: stream	stream 		nextPutAll: self registrationKey;		nextPut: $:;		cr.	self leapSecondsDo: [:leapSecond | 		stream 			tab;			print: leapSecond secondsDelta;			nextPut: $:;			print: leapSecond daysSinceEpoch;			nextPut: $:;			print: leapSecond secondsSinceStartOfDay;			nextPut: $:;			print: leapSecond isRelativeToUT;			cr]</body><body package="Chronos-Timescales" selector="printOn:">printOn: stream	stream nextPutAll: self globalNameOfClass.	stream nextPut: $(.	self encodeOn: stream.	stream nextPut: $).</body></methods><methods><class-id>Chronos.LeapSecondSchedule</class-id> <category>private</category><body package="Chronos-Timescales" selector="mapLeapSecond:">mapLeapSecond: aLeapSecond	self assertMutability.	map at: aLeapSecond daysSinceEpoch - 1 put: aLeapSecond.	map at: aLeapSecond daysSinceEpoch  put: aLeapSecond.	map at: aLeapSecond daysSinceEpoch + 1 put: aLeapSecond.</body></methods><methods><class-id>Chronos.LeapSecondSchedule</class-id> <category>persistence</category><body package="Chronos-Timescales" selector="storeInRepository">storeInRepository	ChronosSystemFacade resourceRepositoryContext storeLeapSecondSchedule: self</body></methods><methods><class-id>Chronos.LeapSecondSchedule class</class-id> <category>private</category><body package="Chronos-Timescales" selector="newDefaultUTC">newDefaultUTC	^self 		decodeFrom: 			'utc:				1:720073:86400:true				1:720257:86400:true				1:720622:86400:true				1:720987:86400:true				1:721352:86400:true				1:721718:86400:true				1:722083:86400:true				1:722448:86400:true				1:722813:86400:true				1:723360:86400:true				1:723725:86400:true				1:724090:86400:true				1:724821:86400:true				1:725735:86400:true				1:726466:86400:true				1:726831:86400:true				1:727378:86400:true				1:727743:86400:true				1:728108:86400:true				1:728657:86400:true				1:729204:86400:true				1:729753:86400:true				1:732310:86400:true' readStream</body><body package="Chronos-Timescales" selector="newRegistry">newRegistry	^IdentityDictionary new</body></methods><methods><class-id>Chronos.LeapSecondSchedule class</class-id> <category>accessing</category><body package="Chronos-Timescales" selector="default">default	"Answer the default instance of the receiver"	^self utc</body><body package="Chronos-Timescales" selector="typeKey">typeKey	^self name</body><body package="Chronos-Timescales" selector="utc">utc	UTC == nil ifTrue: [self invalidateUTC].	^UTC</body></methods><methods><class-id>Chronos.LeapSecondSchedule class</class-id> <category>class initialization</category><body package="Chronos-Timescales" selector="invalidateUTC">invalidateUTC	"LeapSecondSchedule invalidateUTC"	(ChronosSystemFacade resourceRepositoryContext retrieveLeapSecondSchedule: #utc ifNone: [self newDefaultUTC]) beUTC</body></methods><methods><class-id>Chronos.LeapSecondSchedule class</class-id> <category>instance creation</category><body package="Chronos-Timescales" selector="decodeFrom:">decodeFrom: stream	"LeapSecondSchedule		decodeFrom:			'utc:				1:720073:86400:true				1:720257:86400:true				1:720622:86400:true				1:720987:86400:true				1:721352:86400:true				1:721718:86400:true				1:722083:86400:true				1:722448:86400:true				1:722813:86400:true				1:723360:86400:true				1:723725:86400:true				1:724090:86400:true				1:724821:86400:true				1:725735:86400:true				1:726466:86400:true				1:726831:86400:true				1:727378:86400:true				1:727743:86400:true				1:728108:86400:true				1:728657:86400:true				1:729204:86400:true				1:729753:86400:true				1:732310:86400:true' readStream"	| key isRelativeToUT lss secondsDelta daysSinceEpoch secondsSinceStartOfDay |	ChronosFunction skipSeparators: stream.	key := (stream upTo: $:) asSymbol.	lss := self new.	lss setKey: key.	[ChronosFunction skipSeparators: stream.	stream atEnd] 		whileFalse: 			[secondsDelta := Integer readFrom: stream.			(stream peekFor: $:) ifFalse: [self signalError: 'Invalid ', self typeKey, ' encoding format.'].			daysSinceEpoch := Integer readFrom: stream.			(stream peekFor: $:) ifFalse: [self signalError: 'Invalid ', self typeKey, ' encoding format.'].			secondsSinceStartOfDay := Integer readFrom: stream.			(stream peekFor: $:) ifFalse: [self signalError: 'Invalid ', self typeKey, ' encoding format.'].			isRelativeToUT := Boolean readFrom: (ChronosFunction nextLineFrom: stream) readStream.			lss addLeapSeconds: secondsDelta atDaysSinceEpoch: daysSinceEpoch secondsSinceStartOfDay: secondsSinceStartOfDay isRelativeToUT: isRelativeToUT].	^lss beImmutable</body></methods><methods><class-id>Chronos.ChronosPrintableDecorator</class-id> <category>initialize-release</category><body package="Chronos-Printing" selector="setDefaultPolicy:">setDefaultPolicy: aChronosPrintPolicyOrSpec	self assertMutability.	defaultPolicy := (ChronosPrintPolicy referencedBy: aChronosPrintPolicyOrSpec)</body><body package="Chronos-Printing" selector="setDelegate:">setDelegate: aChronosPrintable	self assertMutability.	delegate := aChronosPrintable.</body></methods><methods><class-id>Chronos.ChronosPrintableDecorator</class-id> <category>printing</category><body package="Chronos-Printing" selector="printOn:using:">printOn: stream using: aChronosPrintPolicy	delegate printOn: stream using: aChronosPrintPolicy</body></methods><methods><class-id>Chronos.ChronosPrintableDecorator</class-id> <category>error handling</category><body package="Chronos-Printing" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	"Decorator pattern."	"{| decoratedTimepoint |	decoratedTimepoint := ChronosPrintableDecorator on: Timepoint now defaultPrintPolicy: #verbose.	Array		with: decoratedTimepoint printString		with: decoratedTimepoint fractionalDaysSinceEpoch}"	^delegate perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Chronos.ChronosPrintableDecorator</class-id> <category>accessing</category><body package="Chronos-Printing" selector="defaultPrintPolicy">defaultPrintPolicy	"Answer the default ChronosPrintPolicy for the receiver."	^defaultPolicy == nil 		ifTrue: [super defaultPrintPolicy]		ifFalse: [defaultPolicy]</body><body package="Chronos-Printing" selector="delegate">delegate	^delegate</body></methods><methods><class-id>Chronos.ChronosPrintableDecorator class</class-id> <category>instance creation</category><body package="Chronos-Printing" selector="on:defaultPrintPolicy:">on: aChronosPrintable defaultPrintPolicy: aChronosPrintPolicyOrSpec 	"(ChronosPrintableDecorator on: Timepoint now defaultPrintPolicy: #rfc2822) printString"	"(Timepoint now withDefaultPrintPolicy: #(useTimeBeforeDateOrder dateAndTimeSeparator: $ hideSubsecondFraction timeZoneSeparator: $ )) printString."	"(ChronosPrintableDecorator on: Timepoint now defaultPrintPolicy: #verbose) fractionalDaysSinceEpoch"	^(self new)		setDefaultPolicy: aChronosPrintPolicyOrSpec;		setDelegate: aChronosPrintable;		beImmutable</body></methods><methods><class-id>Chronos.ChronosPrintableDecorator class</class-id> <category>private</category><body package="Chronos-Printing" selector="basicDecodeFromLiteralArray:">basicDecodeFromLiteralArray: literalArray	" *** This method was defined by Chronos.ChronosObject class as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Core.Character class</class-id> <category>instance creation</category><body package="ANSI-Conformance-VW" selector="codePoint:">codePoint: anInteger	"Return a character whose encoding value is integer. As required by the ANSI Smalltalk Standard."	&lt;primitive: 411&gt;	^self valueFromInteger: anInteger asSmallInteger</body></methods><methods><class-id>Core.Character</class-id> <category>accessing</category><body package="ANSI-Conformance-VW" selector="codePoint">codePoint	"Answer the encoding value of the receiver. As required by the ANSI Smalltalk Standard."	&lt;primitive: 410&gt;	^self primitiveFailed</body></methods><methods><class-id>Core.Number</class-id> <category>converting-passport</category><body package="ANSI-Conformance-VW" selector="asScaledDecimal:">asScaledDecimal: newScale	^self asFixedPoint: newScale</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>private-arithmetic-passport</category><body package="Passport-Kernel-VW" selector="addedToInfinitesimal:">addedToInfinitesimal: anInfinitesimal	^self</body><body package="Passport-Kernel-VW" selector="addedToInfinity:">addedToInfinity: anInfinity	^anInfinity</body><body package="Passport-Kernel-VW" selector="dividingInfinitesimal:">dividingInfinitesimal: anInfinitesimal	self isZero ifTrue: [^ZeroDivide raise].	^self negative == anInfinitesimal negative		ifTrue: [anInfinitesimal abs]		ifFalse: [anInfinitesimal negated]</body><body package="Passport-Kernel-VW" selector="dividingInfinity:">dividingInfinity: anInfinity	self isZero ifTrue: [^ZeroDivide raise].	^self negative == anInfinity negative		ifTrue: [anInfinity abs]		ifFalse: [anInfinity negated]</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>testing-passport</category><body package="Passport-Kernel-VW" selector="isInfinite">isInfinite	^false</body><body package="Passport-Kernel-VW" selector="isInfinitesimal">isInfinitesimal	^false</body><body package="Passport-Kernel-VW" selector="isInfinity">isInfinity	^self isInfinite</body><body package="Passport-Kernel-VW" selector="isNaN">isNaN	^false</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>private-arithmetic-passport</category><body package="Passport-Kernel-VW" selector="multipliedByInfinitesimal:">multipliedByInfinitesimal: anInfinitesimal	^self negative == anInfinitesimal negative		ifTrue: [anInfinitesimal abs]		ifFalse: [anInfinitesimal negated]</body><body package="Passport-Kernel-VW" selector="multipliedByInfinity:">multipliedByInfinity: anInfinity	self isZero ifTrue: [^Passport.PassportNotANumber canonical].	^self negative == anInfinity negative		ifTrue: [anInfinity abs]		ifFalse: [anInfinity negated]</body><body package="Passport-Kernel-VW" selector="subtractedFromInfinitesimal:">subtractedFromInfinitesimal: anInfinitesimal	^self negated</body><body package="Passport-Kernel-VW" selector="subtractedFromInfinity:">subtractedFromInfinity: anInfinity	^anInfinity</body></methods><methods><class-id>Core.Integer</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="julianDayAsDate">julianDayAsDate	"2440423 julianDayAsDate"	^Chronos.YearMonthDay julianDay: self</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities-chronos</category><body package="Chronos-VW-Extensions" selector="accessTimepoints">accessTimepoints	"Answer a Dictionary with the file's access timepoints."	"{Filename defaultDirectory accessTimepoints}"	| dts bytes |	dts := IdentityDictionary new: 3.	bytes := self getDates.	1 to: (bytes size / 4) do: 		[:i | 		| secs start dateAndTime |		start := i - 1 * 4 + 1.		secs := UninterpretedBytes with: bytes from: start to: start + 3.		(secs unsignedLongAt: 1) = 0			ifTrue:	[dateAndTime := nil]			ifFalse:	[dateAndTime := DateAndTime utSecondsSinceEpoch: (secs unsignedLongAt: 1) +  59958144000 timeZone: Timezone alwaysSystem].			"Chronos.Calendar gregorian secondsSinceEpochUpToYear: 1901"		dts at: (#(#accessed #modified #statusChanged #created) at: i)			put: dateAndTime].	^dts</body></methods><methods><class-id>OS.Filename</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="asResourcePath">asResourcePath	"Filename defaultDirectory asResourcePath"	^(Passport.ResourcePathContext platformDefault facadeAt: #platform) constructResourcePathFromNativeResourceID: self</body></methods><methods><class-id>Core.Number</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="asTimezone">asTimezone	"Answer the conversion of the receiver into a time zone whose offset-seconds form Universal Time is the value of the receiver."	"(3600 * 5.5d) asTimezone"	"((3600 * 5.5s) + 0.123s) asTimezone"	^Timezone at: self</body><body package="Chronos-VW-Extensions" selector="daysSinceEpochAsDate">daysSinceEpochAsDate	"718997 daysSinceEpochAsDate"	^Chronos.YearMonthDay daysSinceEpoch: self</body><body package="Chronos-VW-Extensions" selector="daysSinceEpochAsDateAndTime">daysSinceEpochAsDateAndTime	"718997.428935186s daysSinceEpochAsDateAndTime"	^DateAndTime utDaysSinceEpoch: self</body><body package="Chronos-VW-Extensions" selector="julianDateAsDateAndTime">julianDateAsDateAndTime	"2440422.928935186s julianDateAsDateAndTime"	^DateAndTime utJulianDay: self</body><body package="Chronos-VW-Extensions" selector="months">months	"3 months"	^Chronos.CalendarDuration months: self</body><body package="Chronos-VW-Extensions" selector="secondsSinceEpochAsDateAndTime">secondsSinceEpochAsDateAndTime	"62121377860 secondsSinceEpochAsDateAndTime"	^DateAndTime utSecondsSinceEpoch: self</body><body package="Chronos-VW-Extensions" selector="weeks">weeks	"3  weeks"	^Chronos.CalendarDuration weeks: self</body><body package="Chronos-VW-Extensions" selector="years">years	"3 years"	^Chronos.CalendarDuration years: self</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>chronos-evaluating</category><body package="Chronos-VW-Extensions" selector="durationToRun">durationToRun	"Evaluate the receiver. Answer a Duration (Chronos.ScientificDuration) that represents the duration (extent) of time required for the execution."	^Duration toRun: self</body></methods><methods><class-id>Core.Date</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="\">\ aChronosCalendar	"Date today \ #Persian"	^self as: aChronosCalendar</body><body package="Chronos-VW-Extensions" selector="%">% aChronosPrintPolicyOrSpec	"Date today % #rfc2822"	"Date today % #iso8601"	^self asChronosValue % aChronosPrintPolicyOrSpec</body><body package="Chronos-VW-Extensions" selector="&lt;&lt;">&lt;&lt; timeZone	"Date today &lt;&lt;10 hours"	"Date today &lt;&lt; 'Australia/Adelaide'"	^self asDateAndTime in: timeZone</body><body package="Chronos-VW-Extensions" selector="&gt;&gt;">&gt;&gt; timeZone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"NOTE: Date instances are invariant to nominal time, because they are not bound to any particular timezone (or absolute time scale.). Example: Create a Date, save the image, transport it accross the International Date Line to a new time zone, then restart it. The Date will still show the same nominal time as when created--even after resetting the VW TimeZone to reflect the local offset and DST rules. Worse, it will compare as equal to any other Date with the same nominal time value, regardless of the intended timezone the Date's value reflects."	"{Date today &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTime now &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTime nominalNow &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTime now &gt;&gt; Timezone nominal}"	^self asNominalDateAndTime &gt;&gt; timeZone</body><body package="Chronos-VW-Extensions" selector="as:">as: aChronosCalendar	"Answer the result of converting the receiver into a calendrical coordinate whose Calendar is &lt;aChronosCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history)."	"Date today as: #Hebrew"	^Chronos.YearMonthDay fromNative: self as: aChronosCalendar</body><body package="Chronos-VW-Extensions" selector="asChronosValue">asChronosValue	"Answer the translation of the receiver into an object that is an instance of whichever class in the Chronos Date/Time Library would be most appropriate for the instantiation of an object equal and/or analogous to the receiver ."	"{Date today asChronosValue}"	^Chronos.YearMonthDay fromNative: self</body><body package="Chronos-VW-Extensions" selector="asDateAndTime">asDateAndTime	"Answer the conversion of the receiver into a DateAndTime value that represents the same point-in-time as does the receiver.  If the receiver is already a DateAndTime value, answer the receiver.  A DateAndTime value is a CalendricalCoordinate that specifies a point-in-time, with a quantum of resolution no larger than one second, with behavior/semantics that is invariant to UT, and that conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol. See the class comment of Timepoint for further clarification."	"Date today asDateAndTime"	^DateAndTime 		year: self year		day: self day</body><body package="Chronos-VW-Extensions" selector="asNative">asNative	^self</body><body package="Chronos-VW-Extensions" selector="asNominalDateAndTime">asNominalDateAndTime	"Answer the conversion of the receiver into a nominal-time-invariant DateAndTime value that represents the same local point-in-time as does the receiver.  If the receiver is already a nominal-time-invariant DateAndTime value, answer the receiver.  A nominal-time-invariant DateAndTime value is a CalendricalCoordinate that nominally specifies a point-in-time without reference to any particular timezone, and has a quantum of resolution no larger than one second. A nominal-time-invariant DateAndTime value conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol EXCEPT that its behavior/semantics is invariant to nominal time, as opposed to being UT invariant. See the class comment of Timepoint for further clarification."	"Date today asNominalDateAndTime"	^DateAndTime fromNative: self</body><body package="Chronos-VW-Extensions" selector="in:">in: timeZone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"NOTE: Date instances are invariant to nominal time, because they are not bound to any particular timezone (or absolute time scale.). Example: Create a Date, save the image, transport it accross the International Date Line to a new time zone, then restart it. The Date will still show the same nominal time as when created--even after resetting the VW TimeZone to reflect the local offset and DST rules. Worse, it will compare as equal to any other Date with the same nominal time value, regardless of the intended timezone the Date's value reflects."	"{Date today in: 'Asia/Calcutta'}"	"{DateAndTime now in: 'Asia/Calcutta'}"	"{DateAndTime nominalNow in: 'Asia/Calcutta'}"	"{DateAndTime now in: Timezone nominal}"	^self &gt;&gt; timeZone</body></methods><methods><class-id>Core.Timestamp</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="\">\ aChronosCalendar	"Timestamp now \ #Persian"	^self as: aChronosCalendar</body><body package="Chronos-VW-Extensions" selector="%">% aChronosPrintPolicyOrSpec	"Timestamp now % #rfc2822"	"Timestamp now % #iso8601"	^self asChronosValue % aChronosPrintPolicyOrSpec</body><body package="Chronos-VW-Extensions" selector="&lt;&lt;">&lt;&lt; timeZone	"Timestamp now &lt;&lt;10 hours"	"Timestamp now &lt;&lt; 'Australia/Adelaide'"	^self asDateAndTime in: timeZone</body><body package="Chronos-VW-Extensions" selector="&gt;&gt;">&gt;&gt; timeZone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"NOTE: Timestamps are invariant to nominal time, because they are not bound to any particular timezone (or absolute time scale.) Example: Create a Timestamp, save the image, transport it to the other side of the world, then restart it. The Timestamp will still show the same nominal time as when created--even after resetting the VW TimeZone to reflect the local offset and DST rules. Worse, a Timestamp will compare as equal to any other Timestamp having the same nominal time value, regardless of the timezone used to specify the time value of each instance."	"{Timestamp now &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTime now &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTime nominalNow &gt;&gt; 'Asia/Calcutta'}"	"{DateAndTime now &gt;&gt; Timezone nominal}"	^self asNominalDateAndTime &gt;&gt; timeZone</body><body package="Chronos-VW-Extensions" selector="as:">as: aChronosCalendar	"Answer the result of converting the receiver into a calendrical coordinate whose Calendar is &lt;aChronosCalendar&gt;, but which represents the same absolute temporal value (e.g., the same day in history)."	"(Timestamp now as: #Hebrew) localePrintString"	^DateAndTime fromNative: self as: aChronosCalendar</body><body package="Chronos-VW-Extensions" selector="asChronosValue">asChronosValue	"Answer the translation of the receiver into an object that is an instance of whichever class in the Chronos Date/Time Library would be most appropriate for the instantiation of an object equal and/or analogous to the receiver ."	"{Timestamp now asChronosValue}"	^DateAndTime fromNative: self</body><body package="Chronos-VW-Extensions" selector="asDateAndTime">asDateAndTime	"Answer the conversion of the receiver into a DateAndTime value that represents the same point-in-time as does the receiver.  If the receiver is already a DateAndTime value, answer the receiver.  A DateAndTime value is a CalendricalCoordinate that specifies a point-in-time, with a quantum of resolution no larger than one second, with behavior/semantics that is invariant to UT, and that conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol. See the class comment of Timepoint for further clarification."	"Timestamp now asDateAndTime"	^DateAndTime		year: self year		month: self month		day: self dayOfMonth		hour: self hour		minute: self minute		second: self second		nanosecond: self millisecond * 1000000</body><body package="Chronos-VW-Extensions" selector="asNative">asNative	^self</body><body package="Chronos-VW-Extensions" selector="asNominalDateAndTime">asNominalDateAndTime	"Answer the conversion of the receiver into a nominal-time-invariant DateAndTime value that represents the same local point-in-time as does the receiver.  If the receiver is already a nominal-time-invariant DateAndTime value, answer the receiver.  A nominal-time-invariant DateAndTime value is a CalendricalCoordinate that nominally specifies a point-in-time without reference to any particular timezone, and has a quantum of resolution no larger than one second. A nominal-time-invariant DateAndTime value conforms to the ANSI-Smalltalk &lt;DateAndTime&gt; protocol EXCEPT that its behavior/semantics is invariant to nominal time, as opposed to being UT invariant. See the class comment of Timepoint for further clarification."	"Timestamp now asNominalDateAndTime"	^self asChronosValue</body><body package="Chronos-VW-Extensions" selector="in:">in: timeZone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"NOTE: Timestamps are invariant to nominal time, because they are not bound to any particular timezone (or absolute time scale.) Example: Create a Timestamp, save the image, transport it to the other side of the world, then restart it. The Timestamp will still show the same nominal time as when created--even after resetting the VW TimeZone to reflect the local offset and DST rules. Worse, a Timestamp will compare as equal to any other Timestamp having the same nominal time value, regardless of the timezone used to specify the time value of each instance."	"{Timestamp now in: 'Asia/Calcutta'}"	"{DateAndTime now in: 'Asia/Calcutta'}"	"{DateAndTime nominalNow in: 'Asia/Calcutta'}"	"{DateAndTime now in: Timezone nominal}"	^self &gt;&gt; timeZone</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="ansiStandardAsDateAndTime">ansiStandardAsDateAndTime 	"Chronos.Timepoint nominalNow printString ansiStandardAsDateAndTime"	"Chronos.Timepoint now printString ansiStandardAsDateAndTime"	^self asDateAndTimeUsing: #ansiStandard</body><body package="Chronos-VW-Extensions" selector="asCalendar">asCalendar	"Answer the Calendar represented by the receiver.  If the receiver is a Calendar instance, answer the receiver.  If the receiver is a Calendar class, answer its canonical instance.  If the receiver is an indirect reference to a calendrical system, answer the canonical Calendar instance that implements that calendrical system."	"{'Persian' asCalendar}"	^Chronos.Calendar at: self</body><body package="Chronos-VW-Extensions" selector="asDateAndTimeUsing:">asDateAndTimeUsing: aChronosParser	"{'1776-07-04' asDateAndTimeUsing: #iso8601}" 	"{'1776-07-04' asDateAndTimeUsing: #ansiStandard}" 	"{'1776-07-04' asDateAndTimeUsing: #default}" 	"{'20040229' asDateAndTimeUsing: #iso8601}"	"{'2004-060' asDateAndTimeUsing: #iso8601}"	"{'2004060' asDateAndTimeUsing: #iso8601}"	"{'2004-W09-7' asDateAndTimeUsing: #iso8601}"	"{'2004W097' asDateAndTimeUsing: #iso8601}"	"{'7/4/76-07:00' asDateAndTimeUsing: #mdy}"	"{'7/4/1776+10:30' asDateAndTimeUsing: #mdy}"	"{'4 July 1776-04' asDateAndTimeUsing: #dmy}"	"{'04-JUL-1776Z' asDateAndTimeUsing: #dmy}"	"{'1776-07-04T09:22:12 America/New_York' asDateAndTimeUsing: #iso8601}"	"{'Thu, 04 Jul 1776 19:15:00 -0500' asDateAndTimeUsing: #rfc2822}"	"{'7/4/76 at 9:22:12 pm MDT' asDateAndTimeUsing: #mdy}"	"{'4 July ''76 9:22:12 pm MDT' asDateAndTimeUsing: #mdy}" "Note that unexpected order is detected and handled automatically, whenever possible."	"{'9:22:12 am 7/4/76 MST' asDateAndTimeUsing: #(expectTimeThenDate expectMDY)}"	"{'Thursday, July 4, 1776 @ 7:15 pm +0530' asDateAndTimeUsing: #(#expectDayOfWeekName #expectMDY)}"	"{'4 juillet 1776 7h15' asDateAndTimeUsing: #(expectDMY setLocale: #'fr_FR' setDefaultTimeZone: 'Europe/Paris')}"	"{('5536 Tammuz 17, 07:15' asDateAndTimeUsing: #(setCalendar: #Hebrew setDefaultTimeZone: 'Asia/Jerusalem')) localePrintString}"	"{('5765 Adar Rishon 14, 18:00' asDateAndTimeUsing: #(setCalendar: #Hebrew setDefaultTimeZone: 'Asia/Jerusalem')) localePrintString}"	"{('5765 Adar Sheni 14, 18:00' asDateAndTimeUsing: #(setCalendar: #Hebrew setDefaultTimeZone: 'Asia/Jerusalem')) localePrintString}"	"{('5765 Adar 14, 18:00' asDateAndTimeUsing: #(setCalendar: #Hebrew setDefaultTimeZone: 'Asia/Jerusalem')) localePrintString}"	"{('5765-13-14T18:00' asDateAndTimeUsing: #(setCalendar: #Hebrew #interpretMonthNumberAsNumericDesignator setDefaultTimeZone: 'Asia/Jerusalem')) localePrintString}"	"{('5765-07-14T18:00' asDateAndTimeUsing: #(setCalendar: #Hebrew setDefaultTimeZone: 'Asia/Jerusalem')) localePrintString}"	^(Chronos.ChronosParser referencedBy: aChronosParser) nextDateAndTimeFrom: self readStream</body><body package="Chronos-VW-Extensions" selector="asDateUsing:">asDateUsing: aChronosParser	"{'1776-07-04' asDateUsing: #iso8601}"	"{'1776-07-04' asDateUsing: #ansiStandard}"	"{'1776-07-04' asDateUsing: #default}"	"{'July 4, 1776' asDateUsing: #mdy}"	"{'7/4/76' asDateUsing: #mdy}"	"{'7/4/1776' asDateUsing: #mdy}"	"{'4 July 1776' asDateUsing: #dmy}"	"{'04-JUL-1776' asDateUsing: #dmy}"	"{'20040229' asDateUsing: #iso8601}"	"{'2004-060' asDateUsing: #iso8601}"	"{'2004060' asDateUsing: #iso8601}"	"{'2004-W09-7' asDateUsing: #iso8601}"	"{'2004W097' asDateUsing: #iso8601}"	"{'4 juillet 1776 7h15' asDateUsing: #(expectDMY setLocale: #fr_FR)}"	"{('5536 Tammuz 17, 07:15' asDateUsing: #(setCalendar: #Hebrew)) localePrintString}"	"{('5765 Adar Rishon 14, 18:00' asDateUsing: #(setCalendar: #Hebrew)) localePrintString}"	"{('5765 Adar Sheni 14, 18:00' asDateUsing: #(setCalendar: #Hebrew)) localePrintString}"	^(Chronos.ChronosParser referencedBy: aChronosParser) nextDateFrom: self readStream</body><body package="Chronos-VW-Extensions" selector="asDuration">asDuration	"{(Chronos.Timepoint now durationSince: (Chronos.Timepoint year: 1969 month: 7 day: 20)) printString asDuration}	{(Chronos.Timepoint now civilDurationSince: (Chronos.Timepoint year: 1969 month: 7 day: 20)) printString asDuration}	{'13674:03:00:47.258833' asDuration}	{'P37Y5M7DT3H1M12.572968S' asDuration}"	^Chronos.ChronosParser default nextDurationalFrom: self readStream</body><body package="Chronos-VW-Extensions" selector="asPathname">asPathname	"'/boo/far/zab' asPathname"	^Passport.Pathname fromString: self</body><body package="Chronos-VW-Extensions" selector="asPathnameWithSeparator:">asPathnameWithSeparator: separator	"'boo.far.zab' asPathnameWithSeparator: $."	^Passport.Pathname fromString: self separator: separator</body><body package="Chronos-VW-Extensions" selector="asResourcePath">asResourcePath	"Filename defaultDirectoryName asResourcePath"	^Passport.ResourcePath fromString: self</body><body package="Chronos-VW-Extensions" selector="asTimeOfDay">asTimeOfDay	"{'17:30:00.5' asTimeOfDay}"	"{'7h15' asTimeOfDay}"	^Chronos.ChronosParser iso8601 nextTimeOfDayFrom: self readStream</body><body package="Chronos-VW-Extensions" selector="asTimezone">asTimezone	"Answer the conversion of the receiver into a time zone whose key is the value of the receiver."	"{'America/Vancouver' asTimezone}"	^Timezone at: self</body><body package="Chronos-VW-Extensions" selector="dmyAsDate">dmyAsDate	"Date today printString dmyAsDate"	^self asDateUsing: #dmy</body><body package="Chronos-VW-Extensions" selector="dmyAsDateAndTime">dmyAsDateAndTime	"Timestamp now printString dmyAsDateAndTime"	^self asDateAndTimeUsing: #dmy</body><body package="Chronos-VW-Extensions" selector="iso8601AsDateAndTime">iso8601AsDateAndTime	"Chronos.Timepoint nominalNow printString iso8601AsDateAndTime"	"Chronos.Timepoint now printString iso8601AsDateAndTime"	^self asDateAndTimeUsing: #iso8601</body><body package="Chronos-VW-Extensions" selector="mdyAsDate">mdyAsDate	"Date today printString mdyAsDate"	^self asDateUsing: #mdy</body><body package="Chronos-VW-Extensions" selector="mdyAsDateAndTime">mdyAsDateAndTime	"Timestamp now printString mdyAsDateAndTime"	^self asDateAndTimeUsing: #mdy</body><body package="Chronos-VW-Extensions" selector="ymdAsDate">ymdAsDate	"Chronos.YearMonthDay today printString ymdAsDate"	"Date today printString ymdAsDate"	^self asDateUsing: #ymd</body><body package="Chronos-VW-Extensions" selector="ymdAsDateAndTime">ymdAsDateAndTime	"Chronos.Timepoint nominalNow printString ymdAsDateAndTime"	"Chronos.Timepoint now printString ymdAsDateAndTime"	"Timestamp now printString dmyAsDateAndTime"	^self asDateAndTimeUsing: #ymd</body></methods><methods><class-id>Core.Time</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="\">\ aChronosCalendar	"Time now \ #Persian"	^self as: aChronosCalendar</body><body package="Chronos-VW-Extensions" selector="%">% aChronosPrintPolicyOrSpec	"Time now % #rfc2822"	"Time now % #iso8601"	^self asChronosValue % aChronosPrintPolicyOrSpec</body><body package="Chronos-VW-Extensions" selector="&lt;&lt;">&lt;&lt; timeZone	"Time now &lt;&lt; 10 hours"	"Time now &lt;&lt; 'Australia/Adelaide'"	^self asDateAndTime in: timeZone</body><body package="Chronos-VW-Extensions" selector="&gt;&gt;">&gt;&gt; timeZone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"Time now &gt;&gt; 10 hours"	"Time now &gt;&gt; 'Australia/Adelaide'"	^self asChronosValue &gt;&gt; timeZone</body><body package="Chronos-VW-Extensions" selector="as:">as: aChronosCalendar	"Time now as: #Persian."	^self asChronosValue as: aChronosCalendar</body><body package="Chronos-VW-Extensions" selector="asChronosValue">asChronosValue	"Answer the translation of the receiver into an object that is an instance of whichever class in the Chronos Date/Time Library would be most appropriate for the instantiation of an object equal and/or analogous to the receiver ."	"Time now asChronosValue."	^Chronos.ChronosSystemFacade current chronosTimeOfDayFromNativeTimeOfDay: self</body><body package="Chronos-VW-Extensions" selector="asDateAndTime">asDateAndTime	"Time now asDateAndTime"	^self asChronosValue asDateAndTime</body><body package="Chronos-VW-Extensions" selector="asNative">asNative	^self</body><body package="Chronos-VW-Extensions" selector="asNominalDateAndTime">asNominalDateAndTime	"Time now asNominalDateAndTime"	^self asChronosValue asNominalDateAndTime</body><body package="Chronos-VW-Extensions" selector="in:">in: timeZone	"If &lt;aChronosTimezone&gt; is (or refers to) the Nominal Time Invariant timezone, then: Answer the result of converting the receiver into a nominal-time-invariant moment in time nominally equal to the local time represented by the receiver.	Otherwise, If the receiver is invariant to nominal time, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, and whose local time is nominally equal to the moment in time nominally represented by the receiver.	Otherwise, if &lt;aChronosTimezone&gt; is (or refers to) a timezone that is invariant to UT, then: Answer the result of converting the receiver into a moment in time whose timezone is &lt;aChronosTimezone&gt;, but which represents the same absolute temporal value (e.g., the same date-and-time UT)."	"Time now in: -6 hours"	"Time now in: TimeZone default"	^self &gt;&gt; timeZone</body></methods><methods><class-id>Core.TimeZone</class-id> <category>converting-chronos</category><body package="Chronos-VW-Extensions" selector="asChronosValue">asChronosValue	"Answer the translation of the receiver into an object that is an instance of whichever class in the Chronos Date/Time Library would be most appropriate for the instantiation of an object equal and/or analogous to the receiver ."	"DateAndTime nowIn: TimeZone default asChronosValue."	"(Chronos.ChronosTimezone at: 'Australia/Adelaide') asNative asChronosValue now."	^Chronos.ChronosSystemFacade current chronosTimezoneFromNativeTimeZone: self</body><body package="Chronos-VW-Extensions" selector="asNative">asNative	^self</body></methods><methods><class-id>Core.TimeZone</class-id> <category>private-chronos</category><body package="Chronos-VW-Extensions" selector="initializeFromAnnuallyRecurringTZPolicyFactoryArray:">initializeFromAnnuallyRecurringTZPolicyFactoryArray: arrayOfAnnuallyRecurringTZPolicyFactories	|  stdTimeOffsetSecondsFromUT offsetDeltaSeconds firstTransitionSecondsSinceStartOfDay secondTransitionSecondsSinceStartOfDay firstTransitionMaxDayOfYearOrdinal secondTransitionMaxDayOfYearOrdinal dayOfWeek annualPolicyElement1 intraYearRuleCount stdTimeOffsetSecondsFromUT1 offsetSecondsFromUT1 offsetDeltaSeconds1 annualPolicyElement2  stdTimeOffsetSecondsFromUT2 offsetSecondsFromUT2 offsetDeltaSeconds2 |	firstTransitionSecondsSinceStartOfDay := 0.	secondTransitionSecondsSinceStartOfDay := 0.	firstTransitionMaxDayOfYearOrdinal := 0.	secondTransitionMaxDayOfYearOrdinal := 0.	dayOfWeek := 1.	intraYearRuleCount := arrayOfAnnuallyRecurringTZPolicyFactories size.	annualPolicyElement1 := arrayOfAnnuallyRecurringTZPolicyFactories at: 1.	stdTimeOffsetSecondsFromUT := stdTimeOffsetSecondsFromUT1 := annualPolicyElement1 stdTimeOffsetSecondsFromUT.	offsetSecondsFromUT1 := annualPolicyElement1 offsetSecondsFromUT.	offsetDeltaSeconds := offsetDeltaSeconds1 := annualPolicyElement1 offsetDeltaSeconds.  	intraYearRuleCount &gt; 1 		ifTrue: 			["ASSUMPTIONS: 				1) There are only two transitions during the year, and 				2) The final transition returns to the same values as pertained at the start of the year.			There are cases where one or both of these assumptions DO NOT HOLD.  However, the VW TimeZone class CANNOT HANDLE SUCH CASES, so it is pointless to even check for them unless and until the TimeZone class can handle such situations, since there would otherwise be no satisfactory solution anyway. Fortunately, such pathological cases are relatively rare, especially in the United States in modern times."						| thisYear |			thisYear := Date today year.			firstTransitionMaxDayOfYearOrdinal := (annualPolicyElement1 maxDaysFromStartOfYearUntilTransitionForYearOfType: 1) + 1.			dayOfWeek := annualPolicyElement1 transitionDayOfWeekInYear: thisYear.			"We'll assume the dayOfWeek is the same in both cases--if not, the VW TimeZone as currently implemented can't deal with it, so..."			firstTransitionSecondsSinceStartOfDay := annualPolicyElement1 transitionSecondsSinceStartOfDay.			annualPolicyElement1 isSpecifiedAsLocalTime				ifFalse: 					["The rules are not specified in local `wall clock` time. However, the VW TimeZone only handles rules specified in local `wall clock' time, so we have to translate the rules into local time."					| secondsSinceStartOfDay dayDelta |					secondsSinceStartOfDay := annualPolicyElement1 isSpecifiedAsUT						ifTrue: [firstTransitionSecondsSinceStartOfDay + offsetSecondsFromUT1]						ifFalse: [firstTransitionSecondsSinceStartOfDay + offsetDeltaSeconds].					firstTransitionSecondsSinceStartOfDay := secondsSinceStartOfDay \\ 86400.					dayDelta := secondsSinceStartOfDay // 86400.					firstTransitionMaxDayOfYearOrdinal := firstTransitionMaxDayOfYearOrdinal + dayDelta.					dayOfWeek := (dayOfWeek - 1 + dayDelta) \\ 7 + 1].			annualPolicyElement2 := arrayOfAnnuallyRecurringTZPolicyFactories at: 2.			stdTimeOffsetSecondsFromUT2 := annualPolicyElement2 stdTimeOffsetSecondsFromUT.			offsetSecondsFromUT2 := annualPolicyElement2 offsetSecondsFromUT.			offsetDeltaSeconds2 := annualPolicyElement2 offsetDeltaSeconds.  			intraYearRuleCount &gt; 2				ifTrue: 					[secondTransitionMaxDayOfYearOrdinal := (annualPolicyElement2 maxDaysFromStartOfYearUntilTransitionForYearOfType: 1) + 1.					secondTransitionSecondsSinceStartOfDay := annualPolicyElement2 transitionSecondsSinceStartOfDay.						annualPolicyElement2 isSpecifiedAsLocalTime						ifFalse: 							[| secondsSinceStartOfDay dayDelta |							secondsSinceStartOfDay := annualPolicyElement2 isSpecifiedAsUT								ifTrue: [secondTransitionSecondsSinceStartOfDay + offsetSecondsFromUT2]								ifFalse: [secondTransitionSecondsSinceStartOfDay + offsetDeltaSeconds2].							secondTransitionSecondsSinceStartOfDay := secondsSinceStartOfDay \\ 86400.							dayDelta := secondsSinceStartOfDay // 86400.							secondTransitionMaxDayOfYearOrdinal := secondTransitionMaxDayOfYearOrdinal + dayDelta].					offsetDeltaSeconds1 = 0 "If the offsetDelta is zero, it's standard time--otherwise, it's DST."						ifTrue:							[stdTimeOffsetSecondsFromUT := stdTimeOffsetSecondsFromUT1.							offsetDeltaSeconds := offsetDeltaSeconds2]						ifFalse: 							["Handle Southern Hemisphere case."							| swap | 							stdTimeOffsetSecondsFromUT := stdTimeOffsetSecondsFromUT2.							offsetDeltaSeconds := offsetDeltaSeconds1.							swap := firstTransitionSecondsSinceStartOfDay.							firstTransitionSecondsSinceStartOfDay := secondTransitionSecondsSinceStartOfDay.							secondTransitionSecondsSinceStartOfDay := swap.							swap := firstTransitionMaxDayOfYearOrdinal.							firstTransitionMaxDayOfYearOrdinal := secondTransitionMaxDayOfYearOrdinal.							secondTransitionMaxDayOfYearOrdinal := swap]]				ifFalse: 					["We'll just assume that what we have here is a one time transition either TO or FROM daylight saving time--although the situation COULD be more complex.  The VW TimeZone is not designed to handle any of these cases, so we will have to improvise. We initially assume there is a single transition FROM standard time TO daylight saving time, which often happens right after a war or energy crisis has begun, but then check for and handle the case for the Southern Hemisphere, where the year starts out in DST."					secondTransitionSecondsSinceStartOfDay := 90001. "25 hours + 1 second--in case leap hours are ever adopted as the official UT1&lt;--&gt;UTC synchronization strategy."					secondTransitionMaxDayOfYearOrdinal := 373. "A week of the year none of whose days will ever be encountered."					offsetDeltaSeconds1 = 0 "If the offsetDelta is zero, it's standard time--otherwise, it's DST."						ifTrue:							[stdTimeOffsetSecondsFromUT := stdTimeOffsetSecondsFromUT1.							offsetDeltaSeconds := offsetDeltaSeconds2]						ifFalse: 							["Ooops!  VW's TimeZone class has a real problem with this case (where there is a one-time transition FROM daylight saving time TO standard time--which happens whenever civil authority decides to discontinue DST for some indefinite period (not everyone likes DST, to put it mildly.) So we cheat: we pretend that DST is STANDARD TIME, and vice versa."							stdTimeOffsetSecondsFromUT := stdTimeOffsetSecondsFromUT1.							offsetDeltaSeconds := offsetDeltaSeconds1 negated]]]		ifFalse:			[stdTimeOffsetSecondsFromUT := stdTimeOffsetSecondsFromUT1.			offsetDeltaSeconds := offsetDeltaSeconds1].	secondsFromGMT := stdTimeOffsetSecondsFromUT.	secondsForDST := offsetDeltaSeconds.	timeStartDST := firstTransitionSecondsSinceStartOfDay.	timeEndDST := secondTransitionSecondsSinceStartOfDay.	dayStartDST := firstTransitionMaxDayOfYearOrdinal.	dayEndDST := secondTransitionMaxDayOfYearOrdinal.	weekDayStartDST := (#(Sunday Monday Tuesday Wednesday Thursday Friday Saturday) at: dayOfWeek)</body></methods><methods><class-id>Core.TimeZone</class-id> <category>initialize-release-chronos</category><body package="Chronos-VW-Extensions" selector="initializeFromChronosTimezone:">initializeFromChronosTimezone: aChronosTimezone 	"TimeZone new initializeFromChronosTimezone: (Duration hours: -7)"	"TimeZone new initializeFromChronosTimezone: 'America/Chicago'"	"TimeZone new initializeFromChronosTimezone: #'Europe/Paris'"	"TimeZone new initializeFromChronosTimezone: Chronos.ChronosTimezone system"	"TimeZone new initializeFromChronosTimezone: TimeZone default asChronosValue"	Chronos.ChronosSystemFacade current 		initializeVWTimeZone: self		fromChronosTimezone: (Timezone referencedBy: aChronosTimezone)</body></methods><methods><class-id>Core.TimeZone</class-id> <category>private-chronos</category><body package="Chronos-VW-Extensions" selector="initializeFromTimeZoneAnnualTransitionPolicyFactory:">initializeFromTimeZoneAnnualTransitionPolicyFactory: aTimeZoneAnnualTransitionPolicyFactory	self initializeFromAnnuallyRecurringTZPolicyFactoryArray: aTimeZoneAnnualTransitionPolicyFactory annuallyRecurringTransitions</body></methods><methods><class-id>Core.TimeZone</class-id> <category>deprecated-chronos</category><body package="Chronos-VW-Extensions" selector="initializeFromTimeZonePolicyElementFactory:">initializeFromTimeZonePolicyElementFactory: aTimeZonePolicyElementFactory	self initializeFromAnnuallyRecurringTZPolicyFactoryArray: aTimeZonePolicyElementFactory annuallyRecurringTransitions</body></methods><methods><class-id>Core.TimeZone</class-id> <category>private-chronos</category><body package="Chronos-VW-Extensions" selector="initializeFromTimeZonePolicyFactory:">initializeFromTimeZonePolicyFactory: aTimeZonePolicyFactory 	self initializeFromTimeZoneAnnualTransitionPolicyFactory: aTimeZonePolicyFactory defaultAnnualTransitionPolicy</body></methods><methods><class-id>Core.TimeZone</class-id> <category>deprecated-chronos</category><body package="Chronos-VW-Extensions" selector="initializeFromTimeZonePolicySequenceFactory:">initializeFromTimeZonePolicySequenceFactory: aTimeZonePolicySequnceFactory 	^self initializeFromTimeZonePolicyFactory: aTimeZonePolicySequnceFactory</body></methods><initialize><class-id>Chronos.ChronosTimezone</class-id></initialize><initialize><class-id>Chronos.RegularCalendar</class-id></initialize><initialize><class-id>Chronos.CopticCalendar</class-id></initialize><initialize><class-id>Chronos.IndianCalendar</class-id></initialize><initialize><class-id>Chronos.ChronosSystemClock</class-id></initialize><initialize><class-id>Passport.EnvironmentFacade</class-id></initialize><initialize><class-id>Chronos.RomanicCalendar</class-id></initialize><initialize><class-id>Chronos.JulianCalendar</class-id></initialize><initialize><class-id>Chronos.HebrewCalendar</class-id></initialize><initialize><class-id>Chronos.AnnualDate</class-id></initialize><initialize><class-id>Passport.Registratable</class-id></initialize><initialize><class-id>Chronos.ChronosPrintPolicy</class-id></initialize><initialize><class-id>Passport.UrlPathFacade</class-id></initialize><initialize><class-id>Chronos.AnnuallyRecurringTZPolicyFactory</class-id></initialize><initialize><class-id>Chronos.SolarianCalendar</class-id></initialize><initialize><class-id>Passport.PassportNotANumber</class-id></initialize><initialize><class-id>Chronos.ImperialJulianCalendar</class-id></initialize><initialize><class-id>Chronos.InfiniteDuration</class-id></initialize><initialize><class-id>Chronos.TimeOfDay</class-id></initialize><initialize><class-id>Chronos.ComputedAnnualDate</class-id></initialize><initialize><class-id>Chronos.TimeZonePolicyFactory</class-id></initialize><initialize><class-id>Chronos.ChronosSystemFacade</class-id></initialize><initialize><class-id>Passport.ClassicVWEnvironmentFacade</class-id></initialize><initialize><class-id>Chronos.PersianCalendar</class-id></initialize><initialize><class-id>Chronos.IslamicFatimidCalendar</class-id></initialize><initialize><class-id>Chronos.Timepoint</class-id></initialize><initialize><class-id>Passport.Pathname</class-id></initialize><initialize><class-id>Chronos.ChronosEnvironment</class-id></initialize><initialize><class-id>Chronos.ChronosLocale</class-id></initialize><initialize><class-id>Chronos.VariableOffsetTimezone</class-id></initialize><initialize><class-id>Chronos.EthiopicCalendar</class-id></initialize><initialize><class-id>Chronos.SemanticDatePolicy</class-id></initialize><initialize><class-id>Chronos.ChronosParser</class-id></initialize><initialize><class-id>Chronos.ChronosInstaller</class-id></initialize><initialize><class-id>Chronos.GregorianCalendar</class-id></initialize><initialize><class-id>Chronos.BahaiCalendar</class-id></initialize><initialize><class-id>Chronos.TimeZoneLocalizationPolicy</class-id></initialize><initialize><class-id>Passport.PassportInfinity</class-id></initialize><initialize><class-id>Passport.ResourcePathContext</class-id></initialize><initialize><class-id>Chronos.MonthlyCalendarSpec</class-id></initialize><initialize><class-id>Passport.PassportInfinitesimal</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ArithmeticValue</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>TimeZone</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>secondsFromGMT dayStartDST dayEndDST timeStartDST timeEndDST secondsForDST weekDayStartDST </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>