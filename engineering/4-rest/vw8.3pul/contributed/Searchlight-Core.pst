<?xml version="1.0"?><st-source><!-- Name: Searchlight-CoreNotice: MIT LicenseCopyright (c) 2008-2014 Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: Searchlight is a search engine for the Smalltalk Image, inspired by Apple Spotlight. It is designed to integrate with the environment. It quickly scans the image across multiple domains from a single search criteria to return the closest search matches in the Refactoring Browser, from the VisualLauncher and in its own incremental search window too.This package contains the search database model for Searchlight and then tools reside in the package Searchlight-Tools.Requires: VisualWorks 7.7+DbIdentifier: bear73DbTrace: 499978DbUsername: trobinsonDbVersion: 343DialectVersion: VisualWorks 7.9PackageName: Searchlight-CoreParcel: #('Searchlight-Core')ParcelName: Searchlight-CorePrintStringCache: (343,trobinson)Version: 343Post-Load Block: 	[:package |	| time |	Transcript cr; show: 'Initializing Search Database... '.	time := Time millisecondsToRun:		[Searchlight.SearchDatabase default			initialize;			update].	Transcript show: time printString, 'ms'.	Searchlight.SearchDatabase register.	]Date: 10:14:13 AM April 7, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of April 7, 2017 on April 7, 2017 at 10:14:13 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Searchlight</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Searchlight-Core</package></attributes></name-space><class><name>InstanceVariable</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>behavior index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><comment><class-id>Searchlight.InstanceVariable</class-id><body>InstanceVariable represents a variable on a class.Instance Variables:	behavior	&lt;ClassDescriptor&gt;	the class or metaclass that has the variable	name	&lt;String&gt;	the name of the variable</body></comment><class><name>ParcelsCache</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>cachedParcelInformation </class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><comment><class-id>Searchlight.ParcelsCache</class-id><body>SearchParcels searches loaded and unloaded parcels. This search engine caches all the parcel information on load and doesn't update it afterwards. If you add/remove parcels from disk, they won't be reflected in our cache. This is done as an optimization because reading parcel information of disk is incredible slow.</body></comment><class><name>TemporaryVariable</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><comment><class-id>Searchlight.TemporaryVariable</class-id><body>TemporaryVariable represents a temporary variable in a method or a block, or a method or block argument.Instance Variables	block	&lt;CompiledCode&gt;	the compiled context we're associated with	index	&lt;Integer&gt;			the stack slot we are associated with in that context</body></comment><class><name>SharedVariable</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><comment><class-id>Searchlight.SharedVariable</class-id><body>SharedVariable represents a shared variable on a namespace or class.Instance Variables:	name &lt;String&gt;	the name of the binding that is the shared variable	namespace	&lt;ClassDescriptor | NameSpace&gt;	the class or namespace that contains the binding</body></comment><class><name>MethodAnalysis</name><environment>Searchlight</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method stack stream copied saves messages assignments references primitive getters setters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><comment><class-id>Searchlight.MethodAnalysis</class-id><body>MethodAnalysis computes what messages are sent, types those messages are sent to, what assignments are made and what references are made.Instance Variables	assignments	&lt;Dictionary&gt;	description of assignments	copied	&lt;Array&gt;	description of copied	messages	&lt;Dictionary&gt;	description of messages	method	&lt;AbstractCodeProbe | CompiledCode | Context | MethodDescription | MethodInstallationRecord | OverridenMethod | ProbeInsertionRecord | PseudoMethod&gt;	description of method	primitive	&lt;LensAbsentee | Object | ProtoObject | WeakProxy&gt;	description of primitive	references	&lt;Collection&gt;	description of references	saves	&lt;Dictionary&gt;	description of saves	stack	&lt;OrderedCollection&gt;	description of stack	stream	&lt;&gt;	description of stream</body></comment><class><name>SearchDatabase</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>behaviorsCache namespacesCache implementorsIndex sendersIndex classReferencesIndex primitivesIndex literalsIndex instanceVariablesIndex sharedVariablesIndex </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><class><name>MethodDescription</name><environment>Searchlight</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mclass selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Searchlight-Core</package></attributes></class><comment><class-id>Searchlight.MethodDescription</class-id><body>MethodDescription is a basic representation of a method installed in the system.Instance Variables	mclass	&lt;Behavior&gt;	the class the method belongs to	selector	&lt;Symbol&gt;	the selector of the method on the class</body></comment><methods><class-id>Searchlight.InstanceVariable</class-id> <category>accessing</category><body package="Searchlight-Core">behavior	^behavior</body><body package="Searchlight-Core">index	^index</body><body package="Searchlight-Core">name	^behavior allInstVarNames at: index</body></methods><methods><class-id>Searchlight.InstanceVariable</class-id> <category>comparing</category><body package="Searchlight-Core">= anObject	^anObject class == self class and: [anObject behavior == behavior and: [anObject index = index]]</body><body package="Searchlight-Core">hash	^behavior hash bitXor: index</body></methods><methods><class-id>Searchlight.InstanceVariable</class-id> <category>printing</category><body package="Searchlight-Core">printOn: stream	behavior printOn: stream.	stream nextPutAll: '&gt;&gt;@'.	stream nextPutAll: self name</body></methods><methods><class-id>Searchlight.InstanceVariable</class-id> <category>initialize-release</category><body package="Searchlight-Core">behavior: aBehavior index: anIndex	behavior := aBehavior.	index := anIndex</body></methods><methods><class-id>Searchlight.InstanceVariable class</class-id> <category>accessing</category><body package="Searchlight-Core">behavior: aBehavior index: anIndex	^self new behavior: aBehavior index: anIndex</body><body package="Searchlight-Core">behavior: aBehavior name: aName	^self behavior: aBehavior index: (aBehavior allInstVarNames indexOf: aName)</body></methods><methods><class-id>Searchlight.ParcelsCache class</class-id> <category>class initialization</category><body package="Searchlight-Core">initialize	| names |	names := OrderedCollection new writeStream.	Transcript cr; show: 'Caching Parcel Information...'.	Parcel putNamesAndVersionsMatching: '*' into: names until: [false].	cachedParcelInformation := names contents.	Transcript cr; show: 'Done'</body></methods><methods><class-id>Searchlight.ParcelsCache class</class-id> <category>accessing</category><body package="Searchlight-Core">cachedParcelInformation	^cachedParcelInformation</body></methods><methods><class-id>Searchlight.TemporaryVariable</class-id> <category>accessing</category><body package="Searchlight-Core">block	^block</body><body package="Searchlight-Core">index	^index</body></methods><methods><class-id>Searchlight.TemporaryVariable</class-id> <category>initialize-release</category><body package="Searchlight-Core">block: aBlock index: anIndex	block := aBlock.	index := anIndex</body></methods><methods><class-id>Searchlight.TemporaryVariable</class-id> <category>printing</category><body package="Searchlight-Core">printOn: stream	block printOn: stream.	stream nextPutAll: '['.	stream print: index.	stream nextPutAll: ']'</body></methods><methods><class-id>Searchlight.TemporaryVariable</class-id> <category>comparing</category><body package="Searchlight-Core">= anObject	^anObject class == self class and: [anObject block == block and: [anObject index == index]]</body><body package="Searchlight-Core">hash	^block hash bitXor: index hash</body></methods><methods><class-id>Searchlight.TemporaryVariable class</class-id> <category>instance creation</category><body package="Searchlight-Core">block: aBlock index: anIndex	^self new block: aBlock index: anIndex</body></methods><methods><class-id>Searchlight.SharedVariable</class-id> <category>printing</category><body package="Searchlight-Core">printOn: stream	namespace printOn: stream.	stream nextPutAll: '&gt;&gt;'.	name printOn: stream</body></methods><methods><class-id>Searchlight.SharedVariable</class-id> <category>comparing</category><body package="Searchlight-Core">= anObject	^anObject class == self class and: [anObject namespace == namespace and: [anObject name = name]]</body><body package="Searchlight-Core">hash	^namespace hash bitXor: name hash</body></methods><methods><class-id>Searchlight.SharedVariable</class-id> <category>accessing</category><body package="Searchlight-Core">name	^name</body><body package="Searchlight-Core">namespace	^namespace</body></methods><methods><class-id>Searchlight.SharedVariable</class-id> <category>initialize-release</category><body package="Searchlight-Core">namespace: aNamespace name: aName	namespace := aNamespace.	name := aName</body></methods><methods><class-id>Searchlight.SharedVariable class</class-id> <category>accessing</category><body package="Searchlight-Core">namespace: aNamespace name: aName	^self new namespace: aNamespace name: aName</body></methods><methods><class-id>Searchlight.MethodAnalysis</class-id> <category>opcodes-control</category><body package="Searchlight-Core">jump: delta	delta &gt; 0 ifTrue: [saves at: stream pc + delta put: stack copy]</body><body package="Searchlight-Core">jump: delta if: condition	self pop.	delta &gt; 0 ifTrue: [saves at: stream pc + delta put: stack copy]</body><body package="Searchlight-Core">makeCopyingBlock: aBlock count: count	| searcher searcherCopied |	searcherCopied := stack removeLast: count.	((aBlock numCopiedValues - count) max: 0) timesRepeat: [searcherCopied := searcherCopied copyWith: UndefinedObject].	searcher := self copy.	searcher initialize: aBlock copied: searcherCopied.	searcher analyse.	stack add: BlockClosure</body><body package="Searchlight-Core">makeFullBlock: aBlock	self makeCopyingBlock: aBlock count: 0</body><body package="Searchlight-Core">makeFullCopyingBlock: aBlock count: count	self makeCopyingBlock: aBlock count: count</body><body package="Searchlight-Core">methodPrimitive: index	primitive := index.	stack add: method mclass</body><body package="Searchlight-Core">send: selector numArgs: numArgs	stack removeLast: numArgs.	(messages at: stack removeLast ifAbsentPut: [Set new]) add: selector.	stack add: selector</body><body package="Searchlight-Core">sendNoCheck: selector numArgs: numArgs	self send: selector numArgs: numArgs</body><body package="Searchlight-Core">sendNonImmediate: selector numArgs: numArgs	self send: selector numArgs: numArgs</body><body package="Searchlight-Core">sendSuper: selector numArgs: numArgs	stack removeLast: numArgs + 2.	(messages at: ((method mclass findSelector: selector) ifNil: [UndefinedObject]) ifAbsentPut: [Set new]) add: selector.	stack add: selector</body></methods><methods><class-id>Searchlight.MethodAnalysis</class-id> <category>opcodes-data movement</category><body package="Searchlight-Core">dupFirst	stack add: stack last</body><body package="Searchlight-Core">dupLast	stack removeLast</body><body package="Searchlight-Core">dupNext	stack		removeLast;		add: stack last</body><body package="Searchlight-Core">pop	stack removeLast</body><body package="Searchlight-Core">pushConstant: value	(value class inheritsFrom: Object) ifTrue: [		value class == BlockClosure ifTrue: [^self makeCopyingBlock: value method count: 0].		value isBehavior ifTrue: [references add: value].		value respondsToArithmetic ifTrue: [references add: value]].	stack addLast: value class</body><body package="Searchlight-Core">pushContext	| context |	context := (stream method isKindOf: CompiledBlock)		ifTrue:	[BlockContext]		ifFalse:	[MethodContext].	references add: context.	stack addLast: context</body><body package="Searchlight-Core">pushCopiedValues: count	stack addAll: copied</body><body package="Searchlight-Core">pushInst: index	| variable |	variable := InstanceVariable behavior: method mclass index: index + 1.	getters add: variable.	stack add: variable</body><body package="Searchlight-Core">pushLocal: index	stack add: (stack at: index + 1)</body><body package="Searchlight-Core">pushLocalIndirect: majorIndex index: minorIndex	| variable |	variable := InstanceVariable behavior: (stack at: (majorIndex + 1)) index: minorIndex + 1.	getters add: variable.	stack add: variable</body><body package="Searchlight-Core">pushNewArray: size	references add: Array.	stack add: Array</body><body package="Searchlight-Core">pushReceiver	stack add: method mclass</body><body package="Searchlight-Core">pushStatic: association	| variable |	association isVariableBinding ifTrue: [^self pushConstant: association value].	variable := SharedVariable namespace: association environment name: association name.	references add: variable.	stack add: variable</body><body package="Searchlight-Core">storeInst: index	| variable |	variable := InstanceVariable behavior: method mclass index: index + 1.	setters add: variable.	(assignments at: variable ifAbsentPut: [Set new])		add: stack last</body><body package="Searchlight-Core">storeLocal: index	| variable |	variable := TemporaryVariable block: method index: index + 1.	setters add: variable.	(assignments at: variable ifAbsentPut: [Set new])		add: stack last</body><body package="Searchlight-Core">storePopInst: index	self storeInst: index.	self pop</body><body package="Searchlight-Core">storePopLocal: index	self storeLocal: index.	self pop</body><body package="Searchlight-Core">storePopLocalIndirect: majorIndex index: minorIndex	| variable |	variable := InstanceVariable behavior: (stack at: majorIndex + 1) index: minorIndex + 1.	setters add: variable.	(assignments at: variable ifAbsentPut: [Set new])		add: stack removeLast</body></methods><methods><class-id>Searchlight.MethodAnalysis</class-id> <category>accessing</category><body package="Searchlight-Core">allMessageSends	| messagesends |	messagesends := Set new.	messages values do: [:messageset | messagesends addAll: messageset].	^messagesends</body><body package="Searchlight-Core">assignments	^assignments</body><body package="Searchlight-Core">messages	^messages</body><body package="Searchlight-Core">primitive	^primitive</body><body package="Searchlight-Core">references	^references</body></methods><methods><class-id>Searchlight.MethodAnalysis</class-id> <category>initialize-release</category><body package="Searchlight-Core">initialize: aCompiledMethod	messages := Dictionary new.	assignments := Dictionary new.	references := Set new.	getters := Set new.	setters := Set new.	method := aCompiledMethod.	stream := InstructionStream on: aCompiledMethod.	stack := OrderedCollection new.	copied := #().	saves := Dictionary new.	1 to: aCompiledMethod numArgs + aCompiledMethod numTemps do: [:index |		stack add: (TemporaryVariable block: aCompiledMethod index: index)]</body><body package="Searchlight-Core">initialize: aCompiledBlock copied: aCollection	stream := InstructionStream on: aCompiledBlock.	copied := aCollection.	stack := OrderedCollection new.	saves := Dictionary new.	1 to: aCompiledBlock numArgs + aCompiledBlock numTemps do: [:index |		stack add: (TemporaryVariable block: aCompiledBlock index: index)]</body></methods><methods><class-id>Searchlight.MethodAnalysis</class-id> <category>api</category><body package="Searchlight-Core">analyse	[stream atEnd] whileFalse: [stream interpretNextInstructionFor: self].	^stack last</body></methods><methods><class-id>Searchlight.MethodAnalysis</class-id> <category>testing</category><body package="Searchlight-Core">test1	| temp1 |	self self1.	super super1.	thisContext context1.	stream stream1.	temp1 temp1.	Window.IconLabelLength shared1.	'string' string1.	[self self2. super super2. stream other2. self] value other3.	self self3: [self self4. super super3. stream other4]</body><body package="Searchlight-Core">test2: arg1	| temp1 |	arg1 arg1.	temp1 temp1</body><body package="Searchlight-Core">test3	&lt;primitive: 3&gt;	^4</body></methods><methods><class-id>Searchlight.MethodAnalysis class</class-id> <category>instance creation</category><body package="Searchlight-Core">analyse: aCompiledMethod	^(self on: aCompiledMethod)		analyse;		yourself</body><body package="Searchlight-Core">on: aCompiledMethod	^self new initialize: aCompiledMethod</body></methods><methods><class-id>Searchlight.MethodAnalysis class</class-id> <category>testing</category><body package="Searchlight-Core">analyseTest1	^self analyse: (self compiledMethodAt: #test1)</body><body package="Searchlight-Core">analyseTest2	^self analyse: (self compiledMethodAt: #test2)</body><body package="Searchlight-Core">analyseTest3	^self analyse: (self compiledMethodAt: #test3)</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>index management</category><body package="Searchlight-Core">cleanup	"Because some unload mechanisms do not report all the changes to the ChangeSet correctly, run through our database and remove invalid references."	self cleanupCache: namespacesCache.	self cleanupCache: behaviorsCache.	self cleanupIndex: instanceVariablesIndex.	self cleanupIndex: sharedVariablesIndex.	self cleanupIndex: implementorsIndex.	self cleanupIndex: primitivesIndex.	self cleanupIndex: sendersIndex.	self cleanupIndex: literalsIndex.	self cleanupIndex: classReferencesIndex.	self cleanupReverseIndex: classReferencesIndex</body><body package="Searchlight-Core">cleanupCache: aCache	| cleanup |	cleanup := OrderedCollection new.	aCache keysAndValuesDo: [:fullname :namespace | fullname ~= namespace fullName ifTrue: [cleanup add: fullname]].	cleanup do: [:each | aCache removeKey: each].</body><body package="Searchlight-Core">cleanupIndex: anIndex	"Because some unload mechanisms do not report all the changes to the ChangeSet correctly, run through our database and remove invalid references."	| trim |	trim := OrderedCollection new.	anIndex keysAndValuesDo: [:name :behaviors |		| cleanup |		cleanup := nil.		behaviors do: [:behavior |			(behavior isObsolete or: [behavior == Undeclared]) ifTrue:				[cleanup ifNil: [cleanup := Set new].				cleanup add: behavior]].		cleanup ifNotNil:			[behaviors removeAll: cleanup.			behaviors isEmpty ifTrue: [trim add: name]]].	trim do: [:each | anIndex removeKey: each].</body><body package="Searchlight-Core">cleanupReverseIndex: anIndex	| cleanup |	cleanup := OrderedCollection new.	anIndex keysDo: [:behavior | (behavior isObsolete or: [behavior == Undeclared]) ifTrue: [cleanup add: behavior]].	cleanup do: [:each | anIndex removeKey: each].</body><body package="Searchlight-Core">implementorsAdd: aMethodDescription	(implementorsIndex at: aMethodDescription selector ifAbsentPut: [IdentitySet new])		add: aMethodDescription mclass</body><body package="Searchlight-Core">implementorsRemove: aMethodDescription	| entry |	entry := implementorsIndex at: aMethodDescription selector ifAbsent: [^self].	entry remove: aMethodDescription mclass ifAbsent: [^self].	entry isEmpty ifTrue: [implementorsIndex removeKey: aMethodDescription selector]</body><body package="Searchlight-Core">instanceVariablesAdd: aBehavior	aBehavior instVarNames do: [:variable | self instanceVariablesAdd: aBehavior named: variable]</body><body package="Searchlight-Core">instanceVariablesAdd: aBehavior named: name	(instanceVariablesIndex at: name ifAbsentPut: [IdentitySet new])		add: aBehavior</body><body package="Searchlight-Core">instanceVariablesRemove: aBehavior	| trim |	trim := OrderedCollection new.	instanceVariablesIndex keysAndValuesDo: [:selector :senders |		senders remove: aBehavior ifAbsent: [].		senders isEmpty ifTrue: [trim add: selector]].	trim do: [:each | instanceVariablesIndex removeKey: each]</body><body package="Searchlight-Core">literalsAdd: aMethodDescription analysis: analysis	analysis references do: [:reference | self literalsAdd: aMethodDescription references: reference].	aMethodDescription method attributeMessages ifNotNil: [:messages |		messages do: [:message |			message arguments do: [:argument |				self literalsAdd: aMethodDescription references: argument]]]</body><body package="Searchlight-Core">literalsAdd: aMethodDescription references: literal	literal ifNil: [^self].	literal isSymbol ifTrue: [^self].	(literal isString or: [literal respondsToArithmetic]) ifFalse: [^self].	(literalsIndex at: literal ifAbsentPut: [Set new])		add: aMethodDescription</body><body package="Searchlight-Core">literalsRemove: aMethodDescription	| trim |	trim := OrderedCollection new.	literalsIndex keysAndValuesDo: [:selector :senders |		senders remove: aMethodDescription ifAbsent: [].		senders isEmpty ifTrue: [trim add: selector]].	trim do: [:each | literalsIndex removeKey: each]</body><body package="Searchlight-Core">primitivesAdd: aMethodDescription analysis: analysis	analysis primitive ifNil: [^self].	(primitivesIndex at: analysis primitive ifAbsentPut: [Set new]) add: aMethodDescription</body><body package="Searchlight-Core">primitivesRemove: aMethodDescription	| trim |	trim := OrderedCollection new.	primitivesIndex keysAndValuesDo: [:selector :senders |		senders remove: aMethodDescription ifAbsent: [].		senders isEmpty ifTrue: [trim add: selector]].	trim do: [:each | primitivesIndex removeKey: each]</body><body package="Searchlight-Core">referencesAdd: aMethodDescription analysis: analysis	analysis references do: [:reference | self referencesAdd: aMethodDescription references: reference].	aMethodDescription method attributeMessages ifNotNil: [:messages |		messages do: [:message |			message arguments do: [:argument |				self referencesAdd: aMethodDescription references: argument]]]</body><body package="Searchlight-Core">referencesAdd: aMethodDescription references: literal	| class binding |	class := nil.	binding := literal.	literal isVariableBinding ifTrue: [binding := literal binding].	binding isBindingReference ifTrue: [class := literal valueOrDo: [nil]].	binding isVariableBinding ifTrue: [class := binding value].	class isBehavior ifFalse: [^self].	(classReferencesIndex at: class ifAbsentPut: [Set new])		add: aMethodDescription</body><body package="Searchlight-Core">referencesRemove: aMethodDescription	| trim |	trim := OrderedCollection new.	classReferencesIndex keysAndValuesDo: [:selector :senders |		senders remove: aMethodDescription ifAbsent: [].		senders isEmpty ifTrue: [trim add: selector]].	trim do: [:each | classReferencesIndex removeKey: each]</body><body package="Searchlight-Core">sendersAdd: aMethodDescription analysis: analysis	analysis allMessageSends do: [:symbol | self sendersAdd: aMethodDescription sends: symbol].	aMethodDescription method attributeMessages ifNotNil: [:messages |		messages do: [:message |			implementorsIndex at: message selector ifAbsentPut: [Set new].			self sendersAdd: aMethodDescription sends: message selector]]</body><body package="Searchlight-Core">sendersAdd: aMethodDescription sends: selector	(sendersIndex at: selector ifAbsentPut: [Set new])		add: aMethodDescription</body><body package="Searchlight-Core">sendersRemove: aMethodDescription	| trim |	trim := OrderedCollection new.	sendersIndex keysAndValuesDo: [:selector :senders |		senders remove: aMethodDescription ifAbsent: [].		senders isEmpty ifTrue: [trim add: selector]].	trim do: [:each | sendersIndex removeKey: each]</body><body package="Searchlight-Core">sharedVariablesAdd: aBehavior	aBehavior asNameSpace bindingsDo: [:binding |		binding isForGeneral ifTrue: [self sharedVariablesAdd: aBehavior binding: binding key]]</body><body package="Searchlight-Core">sharedVariablesAdd: aBehavior binding: binding	(sharedVariablesIndex at: binding ifAbsentPut: [IdentitySet new])		add: aBehavior</body><body package="Searchlight-Core">sharedVariablesRemove: aNamespace	| trim |	trim := OrderedCollection new.	sharedVariablesIndex keysAndValuesDo: [:binding :namespaces |		namespaces remove: aNamespace ifAbsent: [].		namespaces isEmpty ifTrue: [trim add: binding]].	trim do: [:each | sharedVariablesIndex removeKey: each]</body><body package="Searchlight-Core">sharedVariablesRemove: aNamespace binding: aBinding	| entry |	entry := sharedVariablesIndex at: aBinding ifAbsent: [^self].	entry remove: aNamespace ifAbsent: [].	entry isEmpty ifTrue: [sharedVariablesIndex removeKey: aBinding]</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>accessing</category><body package="Searchlight-Core">behaviorsCache	^behaviorsCache</body><body package="Searchlight-Core">classReferencesIndex	^classReferencesIndex</body><body package="Searchlight-Core">implementorsIndex	^implementorsIndex</body><body package="Searchlight-Core">instanceVariablesIndex	^instanceVariablesIndex</body><body package="Searchlight-Core">literalsIndex	^literalsIndex</body><body package="Searchlight-Core">namespacesCache	^namespacesCache</body><body package="Searchlight-Core">primitivesIndex	^primitivesIndex</body><body package="Searchlight-Core">sendersIndex	^sendersIndex</body><body package="Searchlight-Core">sharedVariablesIndex	^sharedVariablesIndex</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>changes - properties</category><body package="Searchlight-Core">component: component property: propertySymbol value: value	| pundle |	(#(postLoadBlock postUnloadBlock preLoadBlock preReadBlock preSaveBlock preUnloadBlock) includes: propertySymbol)		ifFalse: [^self].	pundle := Store.Registry pundleNamed: component name.	self unloadPundleModel: pundle.	self loadPundleModel: pundle</body><body package="Searchlight-Core">loadPundleModel: aPundleModel	aPundleModel postLoadBlock ifNotNil: [:block | self updatePundleModel: aPundleModel propertyMethod: block method].	aPundleModel postUnloadBlock ifNotNil: [:block | self updatePundleModel: aPundleModel propertyMethod: block method].	aPundleModel preLoadBlock ifNotNil: [:block | self updatePundleModel: aPundleModel propertyMethod: block method].	aPundleModel preReadBlock ifNotNil: [:block | self updatePundleModel: aPundleModel propertyMethod: block method].	aPundleModel preSaveBlock ifNotNil: [:block | self updatePundleModel: aPundleModel propertyMethod: block method].	aPundleModel preUnloadBlock ifNotNil: [:block | self updatePundleModel: aPundleModel propertyMethod: block method]</body><body package="Searchlight-Core">unloadPundleModel: aPundleModel	self sendersRemove: aPundleModel.	self referencesRemove: aPundleModel.	self literalsRemove: aPundleModel</body><body package="Searchlight-Core">updatePundleModel: aPundleModel propertyMethod: method	| analysis |	analysis := MethodAnalysis analyse: method.	analysis allMessageSends do: [:symbol | self sendersAdd: aPundleModel sends: symbol].	analysis references do: [:reference |		self referencesAdd: aPundleModel references: reference.		self literalsAdd: aPundleModel references: reference]</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>printing</category><body package="Searchlight-Core">footprint	^self footprint: self</body><body package="Searchlight-Core">footprint: object	| footprint |	footprint := self		footprint: object		ote: ObjectMemory current bytesPerOTE		oop: ObjectMemory current bytesPerOOP		classes: self footprintClasses.	^footprint // 1024</body><body package="Searchlight-Core">footprint: object ote: ote oop: oop classes: classes	| footprint |	(classes includes: object class) ifFalse: [^0].	footprint := ote + (object class instSize * oop) + (object basicSize * oop).	(object == namespacesCache) ifTrue: [namespacesCache keysDo: [:each | footprint := footprint + each size]].	(object == behaviorsCache) ifTrue: [behaviorsCache keysDo: [:each | footprint := footprint + each size]].	1 to: object class instSize do: [:i | footprint := footprint + (self footprint: (object instVarAt: i) ote: ote oop: oop classes: classes)].	1 to: object basicSize do: [:i | footprint := footprint + (self footprint: (object basicAt: i) ote: ote oop: oop classes: classes)].	^footprint</body><body package="Searchlight-Core">footprintClasses	^(Array new: 7)		at: 1 put: SearchDatabase;		at: 2 put: Set;		at: 3 put: IdentitySet;		at: 4 put: Association;		at: 5 put: Dictionary;		at: 6 put: IdentityDictionary;		at: 7 put: MethodDescription;		yourself</body><body package="Searchlight-Core">printFootprint: label space: space on: aStream	aStream		cr;		nextPutAll: label;		nextPutAll: ': ';		print: space size;		nextPutAll: ' (';		print: (self footprint: space);		nextPutAll: 'k)'</body><body package="Searchlight-Core">printOn: aStream	aStream nextPutAll: 'Searchlight Search Database'.	aStream cr; nextPutAll: 'Memory Footprint: '; print: self footprint; nextPutAll: 'k'.	self printFootprint: 'Namespaces' space: namespacesCache on: aStream.	self printFootprint: 'Behaviors' space: behaviorsCache on: aStream.	self printFootprint: 'Implementors' space: implementorsIndex on: aStream.	self printFootprint: 'Primitives' space: primitivesIndex on: aStream.	self printFootprint: 'Senders' space: sendersIndex on: aStream.	self printFootprint: 'Class References' space: classReferencesIndex on: aStream.	self printFootprint: 'Instance Variables' space: instanceVariablesIndex on: aStream.	self printFootprint: 'Shared Variables' space: sharedVariablesIndex on: aStream.	self printFootprint: 'Literals' space: literalsIndex on: aStream.</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>changes - parcels</category><body package="Searchlight-Core">loadParcel: aParcel	aParcel definedNameSpaces do: [:namespace | self addNameSpace: namespace].	aParcel definedClassesDo: [:class | self addClass: class].	aParcel definedBindings keysAndValuesDo: [:namespace :keys |		keys do: [:key | self sharedVariablesAdd: namespace binding: key]].	aParcel classesAndSelectorsDo: [:class :selectors |		selectors do: [:selector | self addSelector: selector class: class]].	self loadPundleModel: aParcel pundleInImage.</body><body package="Searchlight-Core">unloadComponent: aParcel	self unloadParcel: aParcel</body><body package="Searchlight-Core">unloadParcel: aParcel	aParcel isLoaded ifFalse: [^self].	self cleanup</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>changes - bindings</category><body package="Searchlight-Core">addBinding: binding in: nameSpace	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | nameSpace isInStandardEnvironment ifFalse: [^nil]].	self sharedVariablesAdd: nameSpace binding: binding key</body><body package="Searchlight-Core">addBinding: binding in: nameSpace attributes: attributes	self addBinding: binding in: nameSpace</body><body package="Searchlight-Core">relocateBinding: binding from: nameSpace to: newNameSpace	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | nameSpace isInStandardEnvironment ifFalse: [^nil]].	self sharedVariablesRemove: nameSpace binding: binding key.	self sharedVariablesAdd: newNameSpace binding: binding key</body><body package="Searchlight-Core">removeBinding: binding in: nameSpace	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | nameSpace isInStandardEnvironment ifFalse: [^nil]].	self sharedVariablesRemove: nameSpace binding: binding key</body><body package="Searchlight-Core">renameBinding: binding in: nameSpace as: newName	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | nameSpace isInStandardEnvironment ifFalse: [^nil]].	self sharedVariablesRemove: nameSpace binding: binding key.	self sharedVariablesAdd: nameSpace binding: newName</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>updating</category><body package="Searchlight-Core">update: aspectSymbol with: parameterObject from: originatorObject	aspectSymbol isSymbol ifFalse: [^super update: aspectSymbol with: parameterObject from: originatorObject].	(self respondsTo: aspectSymbol) ifFalse: [^super update: aspectSymbol with: parameterObject from: originatorObject].	self perform: aspectSymbol withArguments: parameterObject</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>changes - namespaces</category><body package="Searchlight-Core">addNameSpace: aNamespace	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aNamespace isInStandardEnvironment ifFalse: [^nil]].	(aNamespace respondsTo: #reallyFullyQualifiedReference)		ifTrue:	[namespacesCache at: aNamespace reallyFullyQualifiedReference asString put: aNamespace]		ifFalse:	[namespacesCache at: aNamespace fullyQualifiedReference asString put: aNamespace]</body><body package="Searchlight-Core">addNameSpace: aNamespace attributes: attributes	self addNameSpace: aNamespace</body><body package="Searchlight-Core">relocateNameSpace: aNamespace from: oldEnvironment to: newEnvironment	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aNamespace isInStandardEnvironment ifFalse: [^nil]].	namespacesCache removeKey: aNamespace fullName.	newEnvironment == Smalltalk		ifTrue:	[namespacesCache at: aNamespace name asString put: aNamespace]		ifFalse:	[namespacesCache at: newEnvironment fullName, '.', aNamespace name put: aNamespace]</body><body package="Searchlight-Core">removeNameSpace: aNamespace	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aNamespace isInStandardEnvironment ifFalse: [^nil]].	namespacesCache removeKey: (namespacesCache keyAtValue: aNamespace ifAbsent: [^self]) ifAbsent: [^self].	self sharedVariablesRemove: aNamespace</body><body package="Searchlight-Core">renameNameSpace: aNamespace as: newName	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aNamespace isInStandardEnvironment ifFalse: [^nil]].	namespacesCache removeKey: aNamespace fullName.	aNamespace environment == Smalltalk		ifTrue:	[namespacesCache at: newName asString put: aNamespace]		ifFalse:	[namespacesCache at: aNamespace environment fullName, '.', newName put: aNamespace]</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>changes - behaviors</category><body package="Searchlight-Core">addClass: aClass	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aClass isInStandardEnvironment ifFalse: [^nil]].	(aClass respondsTo: #reallyFullyQualifiedReference)		ifTrue:	[behaviorsCache at: aClass reallyFullyQualifiedReference asString put: aClass]		ifFalse:	[behaviorsCache at: aClass fullyQualifiedReference asString put: aClass].	self instanceVariablesAdd: aClass.	self instanceVariablesAdd: aClass class</body><body package="Searchlight-Core">addClass: aClass attributes: attributes	self addClass: aClass</body><body package="Searchlight-Core">changeClass: aClass	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aClass isInStandardEnvironment ifFalse: [^nil]].	self instanceVariablesRemove: aClass.	self instanceVariablesAdd: aClass.	self instanceVariablesRemove: aClass class.	self instanceVariablesAdd: aClass class</body><body package="Searchlight-Core">changeClass: aClass attributes: attributes	self changeClass: aClass</body><body package="Searchlight-Core">relocateClass: aClass from: oldEnvironment to: newEnvironment	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aClass isInStandardEnvironment ifFalse: [^nil]].	behaviorsCache removeKey: aClass fullName ifAbsent: [].	newEnvironment == Smalltalk		ifTrue:	[behaviorsCache at: aClass name asString put: aClass]		ifFalse:	[behaviorsCache at: newEnvironment fullName, '.', aClass name put: aClass]</body><body package="Searchlight-Core">removeClass: aClass	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aClass isInStandardEnvironment ifFalse: [^nil]].	behaviorsCache removeKey: (behaviorsCache keyAtValue: aClass ifAbsent: [^self]) ifAbsent: [^self].	self instanceVariablesRemove: aClass.	self instanceVariablesRemove: aClass class.	self sharedVariablesRemove: aClass</body><body package="Searchlight-Core">renameClass: aClass as: newName	#{Store.Glorp.StoreObject} ifDefinedDo: [:ignore | aClass isInStandardEnvironment ifFalse: [^nil]].	behaviorsCache removeKey: aClass fullName ifAbsent: [].	aClass environment == Smalltalk		ifTrue:	[behaviorsCache at: newName asString put: aClass]		ifFalse:	[behaviorsCache at: aClass environment fullName, '.', newName put: aClass]</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>changes - selectors</category><body package="Searchlight-Core">addSelector: selector class: class	| description analysis |	description := MethodDescription mclass: class selector: selector.	analysis := MethodAnalysis analyse: (class compiledMethodAt: selector).	self implementorsAdd: description.	self primitivesAdd: description analysis: analysis.	self sendersAdd: description analysis: analysis.	self referencesAdd: description analysis: analysis.	self literalsAdd: description analysis: analysis</body><body package="Searchlight-Core">addSelector: selector class: class attributes: attributes	self addSelector: selector class: class</body><body package="Searchlight-Core">changeSelector: selector class: class	| description analysis |	description := MethodDescription mclass: class selector: selector.	self primitivesRemove: description.	self sendersRemove: description.	self referencesRemove: description.	self literalsRemove: description.	analysis := MethodAnalysis analyse: (class compiledMethodAt: selector).	self primitivesAdd: description analysis: analysis.	self sendersAdd: description analysis: analysis.	self referencesAdd: description analysis: analysis.	self literalsAdd: description analysis: analysis</body><body package="Searchlight-Core">changeSelector: selector class: class  attributes: attributes	self changeSelector: selector class: class</body><body package="Searchlight-Core">removeSelector: selector class: class	| description |	description := MethodDescription mclass: class selector: selector.	self implementorsRemove: description.	self primitivesRemove: description.	self sendersRemove: description.	self referencesRemove: description.	self literalsRemove: description</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>changes - pundles</category><body package="Searchlight-Core">loadPundle: aPundle	| pundle |	pundle := Store.Registry pundleNamed: aPundle name.	self loadPundleModel: pundle.	pundle isBundle ifTrue: [^self].	pundle nameSpaceModelsDo: [:namespace |		namespace isExtension ifFalse: [self addNameSpace: namespace actual].		namespace dataKeys do: [:key | self sharedVariablesAdd: namespace actual binding: key]].	pundle classModelsDo: [:model |		| behavior |		behavior := model actual.		model isExtension ifFalse: [self addClass: behavior].		model dataKeys do: [:key | self sharedVariablesAdd: behavior binding: key].		(model selectorsMeta: false) do: [:selector | self addSelector: selector class: behavior].		(model selectorsMeta: true) do: [:selector | self addSelector: selector class: behavior class]].</body><body package="Searchlight-Core">unloadPundle: aPundle	self unloadPundleModel: (Store.Registry pundleNamed: aPundle name).	self cleanup</body></methods><methods><class-id>Searchlight.SearchDatabase</class-id> <category>initialize-release</category><body package="Searchlight-Core">initialize	namespacesCache := Dictionary new.	behaviorsCache := Dictionary new.	instanceVariablesIndex := Dictionary new.	sharedVariablesIndex := Dictionary new.	implementorsIndex := IdentityDictionary new.	primitivesIndex := Dictionary new.	sendersIndex := IdentityDictionary new.	classReferencesIndex := IdentityDictionary new.	literalsIndex := IdentityDictionary new.</body><body package="Searchlight-Core">update	Root withAllNameSpacesDo: [:namespace |		self addNameSpace: namespace.		self sharedVariablesAdd: namespace].	SystemUtils allClassesDo: [:behavior |		self addClass: behavior.		self sharedVariablesAdd: behavior.		behavior selectorsAndMethodsDo: [:selector :method | self addSelector: selector class: behavior].		behavior class selectorsAndMethodsDo: [:selector :method | self addSelector: selector class: behavior class]].	Store.Registry bundlesDo: [:bundle | self loadPundleModel: bundle].	Store.Registry packagesDo: [:package | self loadPundleModel: package]</body></methods><methods><class-id>Searchlight.SearchDatabase class</class-id> <category>instance creation</category><body package="Searchlight-Core">default	^default ifNil: [default := self new]</body><body package="Searchlight-Core">new	^super new initialize</body></methods><methods><class-id>Searchlight.SearchDatabase class</class-id> <category>utility</category><body package="Searchlight-Core">rebuild	| replacement |	(replacement := self new) update.	default := replacement</body><body package="Searchlight-Core">validate	| comparison |	comparison := self new.	comparison update.	self default inspect.	comparison inspect.	^comparison</body></methods><methods><class-id>Searchlight.SearchDatabase class</class-id> <category>updating</category><body package="Searchlight-Core">update: aspectSymbol with: parameterObject from: originatorObject	self default update: aspectSymbol with: parameterObject from: originatorObject</body></methods><methods><class-id>Searchlight.SearchDatabase class</class-id> <category>private</category><body package="Searchlight-Core">deregister	ChangeSet removeDependent: self</body><body package="Searchlight-Core">register	(ChangeSet dependents includes: self) ifTrue: [^self].	ChangeSet addDependent: self</body></methods><methods><class-id>Searchlight.MethodDescription</class-id> <category>printing</category><body package="Searchlight-Core">printOn: aStream	aStream nextPutAll: mclass name, '&gt;&gt;', selector</body></methods><methods><class-id>Searchlight.MethodDescription</class-id> <category>comparing</category><body package="Searchlight-Core">= aMethodDescription	^aMethodDescription class == self class and: [aMethodDescription selector == selector and: [aMethodDescription mclass == mclass]]</body><body package="Searchlight-Core">hash	^selector hash bitXor: mclass hash</body></methods><methods><class-id>Searchlight.MethodDescription</class-id> <category>accessing</category><body package="Searchlight-Core">mclass	^mclass</body><body package="Searchlight-Core">method	^mclass compiledMethodAt: selector</body><body package="Searchlight-Core">selector	^selector</body></methods><methods><class-id>Searchlight.MethodDescription</class-id> <category>initialize-release</category><body package="Searchlight-Core">mclass: aClass selector: aSelector	mclass := aClass.	selector := aSelector</body></methods><methods><class-id>Searchlight.MethodDescription</class-id> <category>testing</category><body package="Searchlight-Core">isObsolete	^mclass isObsolete</body></methods><methods><class-id>Searchlight.MethodDescription class</class-id> <category>instance creation</category><body package="Searchlight-Core">mclass: mclass selector: selector	^self new mclass: mclass selector: selector</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Searchlight-Core">isObsolete	^(Store.Registry pundleNamed: self name) ~~ self</body></methods><initialize><class-id>Searchlight.ParcelsCache</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>InstructionClient</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>