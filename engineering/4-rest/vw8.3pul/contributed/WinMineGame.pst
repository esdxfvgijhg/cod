<?xml version="1.0"?><st-source><!-- Name: WinMineGameCard-catalog: NAME		WinMineGame	AUTHOR		Philippe KRIEF - ACKIA <krief@laforia.ibp.fr>	CONTRIBUTOR	Philippe KRIEF - ACKIA <krief@laforia.ibp.fr>	FUNCTION 	 Smalltalk implementation of the classic WinMine game from MS-Windows	ST-VERSIONS	R4.1	PREREQUISITES	 	CONFLICTS	 	DISTRIBUTION	world	VERSIONS	R	1.0	DATE		16 February 1994	SUMMARY	Classic WinMine.exe game from MS-Windows.Rules :	You must detect (mark) all mines of the area.		-	Use red button to discover a square.		-	Use yellow button to mark a mine.Beginner level :	ACKIAWinMineBrowser amateurIntermediate level :	ACKIAWinMineBrowser intermediaireAdvanced level :	ACKIAWinMineBrowser expertComment: Philippe KRIEF's <krief@laforia.ibp.fr> version of the Windows Minesweeper game.  Originally for ObjectWorks R4.1 and was located on the UIUC Smalltalk archive.Ported to VW5i.4/7 by Bob Westergaard -  minor changes to be event drivenPorted to VW8.0 by Kevin Greek -  minor class changesDbIdentifier: bear73DbTrace: 446390DbUsername: kgreekDbVersion: 8.0.1PackageName: WinMineGameParcel: #('WinMineGame')ParcelName: WinMineGamePrintStringCache: (8.0.1,kgreek)Version: 8.0.1Post-Load Block: 	[:package | |pages wb|pages := (#(#'card-catalog' #comment) collect:	[:name|	WorkspacePage		labeled: name asString		with: (package propertyAt: name)]) readStream.wb := Workbook new.wb		replaceAllTextPagesWith: pages next;	addPage: pages next;	open.wb builder window label: 'WinMineGame Information']Date: 10:17:57 AM September 26, 2014 --><time-stamp>From VisualWorksÂ®, 8.0 of September 26, 2014 on September 26, 2014 at 10:17:57 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ACKIAWinMineBrowser</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>level nbLignes nbColonnes tableau nbMines compteur startTime timeProcess endGame time topWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ACKIA-Games-WinMine</category><attributes><package>WinMineGame</package></attributes></class><comment><class-id>ACKIAWinMineBrowser</class-id><body>Written by Philippe KRIEF (ACKIA), February 1994e-mail : krief@laforia.ibp.frDescription :	Classic WinMine.exe game from MS-Windows.Rules :		You must detect (mark) all mines of the area.			-	Use red button to discover a square.			-	Use yellow button to mark a mine.Beginner level :	"ACKIAWinMineBrowser amateur"Intermediate level :	"ACKIAWinMineBrowser intermediaire"Advanced level :	"ACKIAWinMineBrowser expert"</body></comment><class><name>ACKIAControlledWrapper</name><environment>Smalltalk</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ACKIA-Interface-Widgets</category><attributes><package>WinMineGame</package></attributes></class><comment><class-id>ACKIAControlledWrapper</class-id><body>Copyright (c) ACKIA, 1993. All rights reserved.[Version initiale du 14 October 1993]  [Developpeur : Philippe KRIEF]Definition des Variables d'instance : 	- controller		&lt;Controller&gt;	- model			&lt;Object&gt;</body></comment><class><name>ACKIAWinMineStandardSystemController</name><environment>Smalltalk</environment><super>UI.ApplicationStandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ACKIA-Games-WinMine</category><attributes><package>WinMineGame</package></attributes></class><class><name>ACKIAWinMineScheduledWindow</name><environment>Smalltalk</environment><super>UI.ScheduledWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ACKIA-Games-WinMine</category><attributes><package>WinMineGame</package></attributes></class><class><name>ACKIAWinMineSquareController</name><environment>Smalltalk</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ACKIA-Games-WinMine</category><attributes><package>WinMineGame</package></attributes></class><class><name>ACKIADynamicWrapper</name><environment>Smalltalk</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model aspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ACKIA-Interface-Widgets</category><attributes><package>WinMineGame</package></attributes></class><class><name>ACKIAWinMineSquare</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position zone visualisation estMine positionsAroundMe minesAroundMe </inst-vars><class-inst-vars>icones </class-inst-vars><imports></imports><category>ACKIA-Games-WinMine</category><attributes><package>WinMineGame</package></attributes></class><shared-variable><name>Palette16</name><environment>ACKIAWinMineSquare</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WinMineGame</package></attributes></shared-variable><shared-variable><name>Aleatoire</name><environment>ACKIAWinMineBrowser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WinMineGame</package></attributes></shared-variable><shared-variable><name>Levels</name><environment>ACKIAWinMineBrowser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WinMineGame</package></attributes></shared-variable><shared-variable><name>MinesPerLevel</name><environment>ACKIAWinMineBrowser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WinMineGame</package></attributes></shared-variable><shared-variable><name>HighScores</name><environment>ACKIAWinMineBrowser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WinMineGame</package></attributes></shared-variable><methods><class-id>ACKIAWinMineBrowser</class-id> <category>accessing</category><body package="WinMineGame">addMark	self compteur: compteur + 1.	(compteur == nbMines and: 			[(tableau detect: 					[:ligne | 					(ligne 						detect: [:each | each estMine and: [each visualisation ~~ #marquer]]						ifNone: [nil]) notNil]				ifNone: [nil]) isNil]) 		ifTrue: [self jeuGagnant]</body><body package="WinMineGame">at: aPoint 	(aPoint x &lt; 1 		or: [aPoint x &gt; nbColonnes or: [aPoint y &lt; 1 or: [aPoint y &gt; nbLignes]]]) 			ifTrue: [^nil].	^(tableau at: aPoint y) at: aPoint x</body><body package="WinMineGame">compteur: aValue	compteur := aValue.	self changed: #compteurText.</body><body package="WinMineGame">compteurText	^(nbMines - compteur) printString asText allBold</body><body package="WinMineGame">randomIn: anInteger	^((Aleatoire next * anInteger) + 1) asInteger</body><body package="WinMineGame">removeMark	self compteur: compteur - 1</body><body package="WinMineGame">showHighScores	| menu |	menu := Menu labelList: (Array 						with: ((HighScores asSortedCollection: 									[:a1 :a2 | 									| i1 i2 |									(i1 := Levels indexOf: (a2 at: 1)) &lt; (i2 := Levels indexOf: (a1 at: 1)) 										or: [(i1 == i2 and: [(a1 at: 2) &lt; (a2 at: 2)]) or: [false]]]) 								collect: 									[:v | 									(v at: 3) , ' : ' , (v at: 2) printString , ' {' , (v at: 1) asString 										, '}'])).	(topWindow widgetPolicy menuViewForMenu: menu) openFromView: topWindow</body><body package="WinMineGame">timeText	^(startTime isNil 		ifTrue: [0]		ifFalse: [time := Time now asSeconds - startTime]) printString 		asText allBold</body><body package="WinMineGame">topWindow: window	topWindow := window</body></methods><methods><class-id>ACKIAWinMineBrowser</class-id> <category>browser-accessing</category><body package="WinMineGame">closeBrowser: aStandardSystemView 	timeProcess notNil ifFalse: [^self].	timeProcess terminate.	timeProcess := nil</body><body package="WinMineGame">maximumWindowSize	^self minimumWindowSize</body><body package="WinMineGame">minimumWindowSize	^((nbColonnes@nbLignes) * 16) + (8@50) max: 200@200</body><body package="WinMineGame">windowLabel	^'Demineur'</body></methods><methods><class-id>ACKIAWinMineBrowser</class-id> <category>initialize-release</category><body package="WinMineGame">jeuGagnant	| highScores name msg |	self stop.	highScores := HighScores select: [:each | each first == level].	(highScores size &lt;= 10 or: [(highScores last at: 2)			&gt; time])		ifFalse: [^self].	msg := 'Bravo !&lt;n&gt;Vous fantes partie&lt;n&gt;des 10 meilleurs scores !&lt;n&gt;Entrez votre nom :' expandMacros.	(name := Dialog request: msg) isEmpty ifTrue: [^self].	HighScores add: (Array			with: level			with: time			with: name).	self showHighScores</body><body package="WinMineGame">perdu	self stop.	tableau do: 			[:ligne | 			ligne do: 					[:each | 					each estMine 						ifTrue: [each visualiseMe]						ifFalse: 							[each visualisation == #marquer ifTrue: [each visualisation: #noMine]]]]</body><body package="WinMineGame">resetGagne	| mines |	Cursor execute showWhile: 			[tableau do: [:each | each do: [:pos | pos reset]].			mines := 0.			[mines &lt; nbMines] whileTrue: 					[| x y pos |					x := self randomIn: nbColonnes.					y := self randomIn: nbLignes.					(pos := self at: x @ y) estMine 						ifFalse: 							[pos beMine.							mines := mines + 1]].			self compteur: 0.			startTime := nil.			self changed: #timeText.			endGame := false]</body><body package="WinMineGame">size: aPoint level: aSymbol	nbLignes := aPoint y.	nbColonnes := aPoint x.	level := aSymbol.	nbMines := MinesPerLevel at: (Levels indexOf: aSymbol).	tableau := (Array new: nbLignes) collect: [:each | (Array new: nbColonnes)].	1 to: nbLignes do: [:l | | ligne |		ligne := tableau at: l.		1 to: nbColonnes do: [:c |			ligne at: c put: (ACKIAWinMineSquare at: c@l in: self)]].	self resetGagne</body><body package="WinMineGame">start	startTime notNil ifTrue: [^self].	startTime := Time now asSeconds.	timeProcess := [[self timingLoop] repeat] newProcess.	timeProcess name: 'WinMineGame timing process'.	timeProcess resume</body><body package="WinMineGame">stop	timeProcess terminate.	timeProcess := nil.	endGame := true</body></methods><methods><class-id>ACKIAWinMineBrowser</class-id> <category>private</category><body package="WinMineGame">timingLoop	(Delay forSeconds: 1) wait.	[self changed: #timeText] uiEventNow</body></methods><methods><class-id>ACKIAWinMineBrowser</class-id> <category>testing</category><body package="WinMineGame">isActive	^endGame not"*AppOrgVersion 14-2-94 2:54:43 pm 'PK'*"</body></methods><methods><class-id>ACKIAWinMineBrowser</class-id> <category>auto-accessing</category><body package="WinMineGame">nbColonnes	^nbColonnes</body><body package="WinMineGame">nbLignes	^nbLignes</body></methods><methods><class-id>ACKIAWinMineBrowser class</class-id> <category>resources</category><body package="WinMineGame">windowIcon	| defIcon |	defIcon := Icon new figure: self iconImage shape: self iconMask.	defIcon cleanFigure.	^defIcon</body></methods><methods><class-id>ACKIAWinMineBrowser class</class-id> <category>window creation</category><body package="WinMineGame">openFor: aModel	^self openFor: aModel labeled: aModel windowLabel</body><body package="WinMineGame">openFor: aModel labeled: aString 	| topWindow aComponent |	aComponent := self topViewFor: aModel.	topWindow := ACKIAWinMineScheduledWindow 				model: aModel				label: aString				minimumSize: aModel minimumWindowSize.	aModel topWindow: topWindow.	topWindow maximumSize: aModel maximumWindowSize.	topWindow component: aComponent.	topWindow icon: self windowIcon.	topWindow open</body></methods><methods><class-id>ACKIAWinMineBrowser class</class-id> <category>examples</category><body package="WinMineGame">amateur	"self amateur"	^self openFor: (self new size: 8 @ 8 level: #amateur)</body><body package="WinMineGame">expert	"self expert"	^self openFor: (self new size: 30 @ 16 level: #expert)</body><body package="WinMineGame">intermediaire	"self intermediaire"	^self openFor: (self new size: 16 @ 16 level: #intermediaire)</body></methods><methods><class-id>ACKIAWinMineBrowser class</class-id> <category>a redefinir</category><body package="WinMineGame">topViewFor: aModel	"A Redifinir"	| topView    indentation   x    |	indentation := 4.	topView := CompositePart new.	topView		add: (self compteurViewFor: aModel)		in: (LayoutFrame			leftFraction: 0 offset: indentation			rightFraction: 0 offset: indentation + 50			topFraction: 0 offset: indentation			bottomFraction: 0 offset: indentation + 25);		add: (self resetAndHighScoreViewFor: aModel)		in: (LayoutFrame			leftFraction: 0.5 offset: -25			rightFraction: 0.5 offset: 25			topFraction: 0 offset: indentation			bottomFraction: 0 offset: indentation + 25);		add: (self timeViewFor: aModel)		in: (LayoutFrame			leftFraction: 1 offset: indentation negated - 50			rightFraction: 1 offset: indentation negated			topFraction: 0 offset: indentation			bottomFraction: 0 offset: indentation + 25);		add: (self minesViewFor: aModel)		in: (LayoutFrame			leftFraction: 0.5 offset: (x := 1 + (16 * aModel nbColonnes // 2)) negated			rightFraction: 0.5 offset: x			topFraction: 0 offset: indentation + 25 + (2 * indentation)			bottomFraction: 0 offset: indentation + 25 + (2 * indentation) + (16 * aModel nbLignes)).	^topView</body></methods><methods><class-id>ACKIAWinMineBrowser class</class-id> <category>subview creation</category><body package="WinMineGame">compteurViewFor: aModel	|adaptor|	adaptor := (PluggableAdaptor on: aModel)		getBlock: [:m | m compteurText]		putBlock: [:m :v | nil ]		updateBlock: [:m :a :p | true].	^(LookPreferences edgeDecorator		on: ((TextEditorView				model: adaptor)					controller: NoController new;					displaySelection: false))					noMenuBar; noVerticalScrollBar"	^(LookPreferences edgeDecorator		on: ((TextView				on: aModel				aspect: #compteurText change: nil menu: nil)					controller: NoController new;					displaySelection: false))					noMenuBar; noVerticalScrollBar"</body><body package="WinMineGame">mineViewFor: aModel	^(ACKIAControlledWrapper		on: ((ACKIADynamicWrapper				on: aModel aspect: #mineView)				component: ACKIAWinMineSquare blank)		model: aModel)			controller: ACKIAWinMineSquareController new</body><body package="WinMineGame">minesViewFor: aModel	| topView  left right |	topView := CompositePart new.	1 to: aModel nbLignes do: [:y |		1 to: aModel nbColonnes do: [:x |			topView	add: (self mineViewFor: (aModel at: x@y))					in: (LayoutFrame						leftFraction: (left := ((x-1) / aModel nbColonnes) asFloat) offset: 0						rightFraction: left offset: 16						topFraction: (right := ((y-1) / aModel nbLignes) asFloat) offset: 0						bottomFraction: right offset: 16)]].	^BorderedWrapper on: topView</body><body package="WinMineGame">resetAndHighScoreViewFor: aModel	| composite resetModel hightScoreView hightScoreModel resetView |	composite := CompositePart new.	resetModel := (PluggableAdaptor on: aModel)					getBlock: [:m | false]					putBlock: [:m :v | m resetGagne]					updateBlock: [:m :a :p | false].	(resetView := LabeledBooleanView model: resetModel)				beVisual: ACKIAWinMineSquare content.	resetView controller beTriggerOnUp.	composite add: (BorderedWrapper on: resetView) in: (0@0 corner: 0.5@1).	hightScoreModel := (PluggableAdaptor on: aModel)					getBlock: [:m | false]					putBlock: [:m :v | m showHighScores]					updateBlock: [:m :a :p | false].	(hightScoreView := LabeledBooleanView model: hightScoreModel)				beVisual: ACKIAWinMineSquare gagnant.	hightScoreView controller beTriggerOnUp.	composite add: (BorderedWrapper on: hightScoreView) in: (0.5@0 corner: 1@1).	^composite</body><body package="WinMineGame">timeViewFor: aModel	|adaptor|	adaptor := (PluggableAdaptor on: aModel)		getBlock: [:m | m timeText]		putBlock: [:m :v | nil ]		updateBlock: [:m :a :p | true].	^(LookPreferences edgeDecorator		on: ((TextEditorView				model: adaptor)					controller: NoController new;					displaySelection: false))					noMenuBar; noVerticalScrollBar"	^(LookPreferences edgeDecorator		on: ((TextView				on: aModel				aspect: #timeText change: nil menu: nil)					controller: NoController new;					displaySelection: false))					noMenuBar; noVerticalScrollBar"</body></methods><methods><class-id>ACKIAWinMineBrowser class</class-id> <category>class initialization</category><body package="WinMineGame">initialize	"self initialize"	Aleatoire := Random new.	Levels := #(amateur intermediaire expert).	MinesPerLevel := #(10 40 99).	HighScores := OrderedCollection new</body></methods><methods><class-id>ACKIAControlledWrapper</class-id> <category>control</category><body package="WinMineGame">objectWantingControl	| ctrl |	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	" Trap errors occurring while searching for	the object wanting control. "	^Object errorSignal 		handle: [:ex |				Controller badControllerSignal					raiseErrorString: 'Bad controller in objectWantingControl']		do: [ctrl isControlWanted ifTrue: [self] ifFalse: [nil]]</body></methods><methods><class-id>ACKIAControlledWrapper</class-id> <category>initialize-release</category><body package="WinMineGame">flushCoordinateCaches	"Flush caches that relate to coordinate translations between this component 	and its container. 	As we implement wrappers with controllers we have to transmit the flush to the controller too."	| ctrl |	component == nil ifFalse: [component flushCoordinateCaches].	ctrl := self getController.	ctrl == nil ifFalse: [ctrl flushCoordinateCaches]</body><body package="WinMineGame">initialize	super initialize.	self controller: nil.	self model: nil.</body><body package="WinMineGame">release	self model: nil.	super release</body></methods><methods><class-id>ACKIAControlledWrapper</class-id> <category>controller accessing</category><body package="WinMineGame">controller	^self getController</body><body package="WinMineGame">controller: aController 	self setController: aController</body><body package="WinMineGame">defaultController	^self defaultControllerClass new</body><body package="WinMineGame">defaultControllerClass	^NoController</body></methods><methods><class-id>ACKIAControlledWrapper</class-id> <category>model access</category><body package="WinMineGame">model	^model</body><body package="WinMineGame">model: aModel	"Set the receiver's model."	self setModel: aModel</body><body package="WinMineGame">setModel: aModel	"Set the receiver's model."	(model notNil and: [model ~~ aModel]) ifTrue: [model removeDependent: self].	(aModel notNil and: [aModel ~~ model]) ifTrue: [aModel addDependent: self].	controller notNil ifTrue: [ controller model: aModel ].	model := aModel.</body></methods><methods><class-id>ACKIAControlledWrapper</class-id> <category>private</category><body package="WinMineGame">getController	controller == nil ifTrue: [self setController: self defaultController].	^controller</body><body package="WinMineGame">setController: aController 	"Set the receiver's controller to aController. If aController is not nil, its view is set to the receiver 	and its model is set to aModel."	aController == nil		ifFalse: 			[aController view: self.			aController model: model].	controller := aController</body></methods><methods><class-id>ACKIAControlledWrapper</class-id> <category>event driven</category><body package="WinMineGame">handlerForMouseEvent: aMouseEvent 	"Forward the control polling message to the receiver's component."	^self objectWantingControl</body></methods><methods><class-id>ACKIAControlledWrapper class</class-id> <category>instance creation</category><body package="WinMineGame">on: aVisualComponent model: aModel	"Create a new instance of the receiver on aVisualComponent."	^ (self on: aVisualComponent) model: aModel</body></methods><methods><class-id>ACKIAWinMineStandardSystemController</class-id> <category>scheduling</category><body package="WinMineGame">closeAndUnschedule	model closeBrowser: view.	super closeAndUnschedule</body></methods><methods><class-id>ACKIAWinMineScheduledWindow</class-id> <category>private</category><body package="WinMineGame">defaultController	"Answer an initialized instance of the receiver's default controller.	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^self defaultControllerClass new</body><body package="WinMineGame">getController	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	controller == nil ifTrue: [self setController: self defaultController].	^controller</body><body package="WinMineGame">setController: aController 	"Set the receiver's controller to aController. If aController is not nil, its view is set to the receiver 	and its model is set to aModel."	aController == nil		ifFalse: 			[aController view: self.			aController model: model].	controller := aController</body></methods><methods><class-id>ACKIAWinMineScheduledWindow</class-id> <category>controller accessing</category><body package="WinMineGame">controller	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	^self getController</body><body package="WinMineGame">defaultControllerClass	"Answer the class of the default controller for the receiver.	Subclasses should redefine defaultControllerClass if the class of the 	default controller is not Controller."	^ACKIAWinMineStandardSystemController</body></methods><methods><class-id>ACKIAWinMineSquareController</class-id> <category>events</category><body package="WinMineGame">redButtonPressedEvent: event	model enfoncer</body><body package="WinMineGame">yellowButtonPressedEvent: event	model marquer</body></methods><methods><class-id>ACKIAWinMineSquareController</class-id> <category>control defaults</category><body package="WinMineGame">isControlActive	^model isActive</body><body package="WinMineGame">isControlWanted	^model isActive</body></methods><methods><class-id>ACKIADynamicWrapper</class-id> <category>auto-accessing</category><body package="WinMineGame">aspect	^aspect</body><body package="WinMineGame">aspect: aValue	"aspect notNil	ifTrue: [Suppression des rifirence ` aspect]."	aspect := aValue.	"aspect notNil	ifTrue: [Mise ` jour des rifirence ` aspect]."</body></methods><methods><class-id>ACKIADynamicWrapper</class-id> <category>initialize-release</category><body package="WinMineGame">release	"Remove the receiver as a dependent of its model."	self model: nil.	super release</body></methods><methods><class-id>ACKIADynamicWrapper</class-id> <category>private</category><body package="WinMineGame">computeComponent	self setComponent: self getComponent.	self invalidateRectangle: self bounds repairNow: false.	^component</body><body package="WinMineGame">getComponent	^model perform: aspect</body><body package="WinMineGame">setModel: aModel	"Set the receiver's model."	(model notNil and: [model ~~ aModel]) ifTrue: [model removeDependent: self].	(aModel notNil and: [aModel ~~ model]) ifTrue: [aModel addDependent: self].	model := aModel.</body></methods><methods><class-id>ACKIADynamicWrapper</class-id> <category>accessing</category><body package="WinMineGame">component	^component isNil	ifTrue: [self computeComponent]	ifFalse: [component]</body><body package="WinMineGame">model	"Answer the receiver's model."	^model</body><body package="WinMineGame">model: aModel 	"Set the receiver's model to aModel."	self setModel: aModel</body><body package="WinMineGame">update: aspectSymbol	"Some aspect of the model has changed.	By default, repaint the receiver.  Subclasses	will often do something more selective."	aspectSymbol == aspect	ifTrue: [self invalidate]</body></methods><methods><class-id>ACKIADynamicWrapper</class-id> <category>updating</category><body package="WinMineGame">update: anAspect with: anArgument from: anObject 	anAspect == aspect 		ifTrue: 			[component release.			component := nil.			self invalidate]		ifFalse: 			[super 				update: anAspect				with: anArgument				from: anObject]</body></methods><methods><class-id>ACKIADynamicWrapper class</class-id> <category>instance creation</category><body package="WinMineGame">on: aModel	"Create a new instance of the receiver on aVisualComponent."	^self new model: aModel</body><body package="WinMineGame">on: aModel aspect: aspectMsg 	"Create a new instance of the receiver on aVisualComponent."	^(self new)		model: aModel;		aspect: aspectMsg;		yourself</body></methods><methods><class-id>ACKIAWinMineSquare</class-id> <category>accessing</category><body package="WinMineGame">mineView	^visualisation isNil	ifTrue: [self class blank] ifFalse: [	visualisation isInteger	ifTrue: [self class iconeFor: visualisation] ifFalse: [	visualisation == #marquer	ifTrue: [self class mine] ifFalse: [	visualisation == #noMine	ifTrue: [self class noMine]	ifFalse: [self class bombe]]]]</body><body package="WinMineGame">minesAroundMe	minesAroundMe notNil ifTrue: [^minesAroundMe].	minesAroundMe := 0.	self positionsAroundMe		do: [:each | each estMine ifTrue: [minesAroundMe := minesAroundMe + 1]].	^minesAroundMe</body><body package="WinMineGame">positionsAroundMe	positionsAroundMe notNil ifTrue: [^positionsAroundMe].	^positionsAroundMe := (((OrderedCollection new)				add: -1 @ -1;				add: 0 @ -1;				add: 1 @ -1;				add: -1 @ 0;				add: 1 @ 0;				add: -1 @ 1;				add: 0 @ 1;				add: 1 @ 1;				yourself) collect: [:pt | zone at: pt + position])				select: [:each | each notNil]</body><body package="WinMineGame">visualisation: aValue	visualisation := aValue.	self changed: #mineView"*AppOrgVersion 14-2-94 3:04:17 pm 'PK'*"</body><body package="WinMineGame">visualiseMe	self visualisation: (estMine					ifTrue: [#mine]					ifFalse: [self minesAroundMe]).</body><body package="WinMineGame">visualiseMeAndAllAround	self visualiseMe.	self positionsAroundMe		do: [:each |	each visualisation isNil					ifTrue: [each minesAroundMe == 0							ifTrue: [each visualiseMeAndAllAround]							ifFalse: [each visualiseMe]]]</body></methods><methods><class-id>ACKIAWinMineSquare</class-id> <category>auto-accessing</category><body package="WinMineGame">estMine	^estMine</body><body package="WinMineGame">position	^position</body><body package="WinMineGame">position: aValue	"position notNil	ifTrue: [Suppression des rifirence ` position]."	position := aValue.	"position notNil	ifTrue: [Mise ` jour des rifirence ` position]."</body><body package="WinMineGame">visualisation	^visualisation</body></methods><methods><class-id>ACKIAWinMineSquare</class-id> <category>initialize-release</category><body package="WinMineGame">at: aPoint in: aMineBrowser	position := aPoint.	zone := aMineBrowser.	self reset</body><body package="WinMineGame">beMine	estMine := true</body><body package="WinMineGame">reset	estMine := false.	self visualisation: nil.	minesAroundMe := nil</body></methods><methods><class-id>ACKIAWinMineSquare</class-id> <category>action button</category><body package="WinMineGame">enfoncer	zone start.	estMine 		ifTrue: [zone perdu]		ifFalse: 			[self minesAroundMe == 0 				ifTrue: [self visualiseMeAndAllAround]				ifFalse: [self visualiseMe]]</body><body package="WinMineGame">marquer	zone start.	visualisation == #marquer 		ifTrue: 			[self visualisation: nil.			zone removeMark]		ifFalse: 			[self visualisation: #marquer.			zone addMark]</body></methods><methods><class-id>ACKIAWinMineSquare</class-id> <category>testing</category><body package="WinMineGame">isActive	^(visualisation isNil or: [visualisation == #marquer]) and: [zone isActive]</body></methods><methods><class-id>ACKIAWinMineSquare class</class-id> <category>icones</category><body package="WinMineGame">blank	^self imageFor: #blank is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[255 255 255 255 255 255 255 247 255 255 255 255 255 255 255 120 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 255 119 119 119 119 119 119 136 247 136 136 136 136 136 136 136 120 136 136 136 136 136 136 136 ]]</body><body package="WinMineGame">bombe	^self imageFor: #bombe is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 7 119 119 119 135 119 119 119 7 119 119 119 135 119 7 0 0 7 7 119 135 119 112 0 0 0 119 119 135 119 0 255 0 0 7 119 135 119 0 255 0 0 7 119 135 0 0 0 0 0 0 7 135 119 0 0 0 0 7 119 135 119 0 0 0 0 7 119 135 119 112 0 0 0 119 119 135 119 7 0 0 7 7 119 135 119 119 119 7 119 119 119 135 119 119 119 7 119 119 119 135 119 119 119 119 119 119119 ]]</body><body package="WinMineGame">content	^self opaqueImageFor: #content is: [Depth4Image extent: 17@17 depth: 4 palette: (self palette16) bits: #[255 255 255 0 0 15 255 255 240 0 0 0 255 255 0 187 187 176 15 255 240 0 0 0 255 240 187 187 187 187 176 255 240 0 0 0 255 11 187 187 187 187 187 15 240 0 0 0 240 187 187 187 187 187 187 176 240 0 0 0 240 187 176 11 187 0 187 176 240 0 0 0 11 187 176 11 187 0 187 187 0 0 0 0 11187 187 187 187 187 187 187 0 0 0 0 11 187 187 187 187 187 187 187 0 0 0 0 11 187 187 187 187 187 187 187 0 0 0 0 11 187 11 187 187 187 11 187 0 0 0 0 240 187 176 187 187 176 187 176 240 0 0 0 240 187 187 0 0 11 187 176 240 0 0 0 255 11 187 187 187 187 187 15 240 0 0 0 255 240 187 187 187 187 176 255 240 0 0 0 255 255 0 187 187 176 15 255 240 0 0 0 255 255 255 0 0 15 255 255 240 0 0 0 ]]</body><body package="WinMineGame">five	^self imageFor: #five is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 123 187 187 187 187 183 119 135 123 187 187 187 187 183 119 135 123 187 119 119 119 119 119 135 123 187 119 119 119 119 119 135 123 187 187 187 183 119 119 135 123 187 187 187 187 119 119 135 119 119 119 119 187 183 119 135 119 119 119 119 187 183 119 135 123 187 187 187 187 183 119 135 123 187 187 187 187 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">four	^self imageFor: #four is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 116 68 116 68 119 119 135 119 116 68 116 68 119 119 135 119 68 71 116 68 119 119 135 119 68 71 116 68 119 119 135 116 68 68 68 68 71 119 135 116 68 68 68 68 71 119 135 119 119 119 116 68 119 119 135 119 119 119 116 68 119 119 135 119 119 119 116 68 119 119 135 119 119 119 116 68 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]"*AppOrgVersion 14-2-94 12:10:22 pm 'PK'*"</body><body package="WinMineGame">gagnant	^self opaqueImageFor: #gagnant is: [Depth4Image extent: 17@17 depth: 4 palette: (self palette16) bits: #[255 255 255 0 0 15 255 255 240 0 0 0 255 255 0 187 187 176 15 255 240 0 0 0 255 240 187 187 187 187 176 255 240 0 0 0 255 11 187 187 187 187 187 15 240 0 0 0 240 187 187 187 187 187 187 176 240 0 0 0 240 187 0 0 0 0 11 176 240 0 0 0 11 176 0 0 176 0 0 187 0 0 0 0 11 11 0 0 176 0 11 11 0 0 0 0 0 187 48 11 187 0 59 176 0 0 0 0 11 187 187 187 187 187 187 187 0 0 0 0 11 187 187 187 187 187 187 187 0 0 0 0 240 187 176 187 187 176 187 176 240 0 0 0 240 187 187 0 0 11 187 176 240 0 0 0 255 11 187 187 187 187 187 15 240 0 0 0 255 240 187 187 187 187 176 255 240 0 0 0 255 255 0 187 187 176 15 255 240 0 0 0 255 255 255 0 0 15 255 255 240 0 0 0 ]]</body><body package="WinMineGame">height	^self imageFor: #height is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 238 238 238 238 119 119 135 126 238 238 238 238 231 119 135 126 238 119 119 238 231 119 135 119 238 238 238 238 119 119 135 119 126 238 238 231 119 119 135 119 238 238 238 238 119 119 135 126 238 119 119 238 231 119 135 126 238 119 119 238 231 119 135 126 238 238 238 238 231 119 135 119 238 238 238 238 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">iconeFor: anInteger	^self perform: (#(zero one two three four five six seven height) at: anInteger + 1)</body><body package="WinMineGame">mine	^self imageFor: #mine is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[255 255 255 255 255 255 255 247 255 255 255 255 255 255 255 120 255 119 119 119 119 119 119 136 255 119 119 121 151 119 119 136 255 119 121 153 151 119 119 136 255 119 153 153 151 119 119 136 255 119 121 153 151 119 119 136 255 119 119 121 151 119 119 136 255 119 119 119 7 119 119 136 255 119 119 119 7 119 119 136 255 119 119 0 0 119 119 136 255 119 0 0 0 0 119 136 255 119 0 0 0 0 119 136 255 119 119 119 119 119 119 136 247 136 136 136 136 136 136 136 120 136 136 136 136 136 136 136 ]]</body><body package="WinMineGame">noMine	^self imageFor: #noMine is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 7 119 119 119 135 153 119 119 7 119 121 151 135 121 151 0 0 7 153 119 135 119 153 0 0 9 151 119 135 119 9 159 0 153 7 119 135 119 0 153 9 144 7 119 135 0 0 9 153 0 0 7 135 119 0 9 153 0 7 119 135 119 0 153 9 144 7 119 135 119 121 144 0 153 119 119 135 119 153 0 0 9 151 119 135 121 151 119 7 119 153 119 135 153 119 119 7 119 121 151 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">one	^self imageFor: #one is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 204 119 119 119 135 119 119 124 204 119 119 119 135 119 119 204 204 119 119 119 135 119 124 204 204 119 119 119 135 119 119 124 204 119 119 119 135 119 119 124 204 119 119 119 135 119 119 124 204 119 119 119 135 119 119 124 204 119 119 119 135 119 124 204 204 204 119 119 135 119 124 204 204 204 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">seven	^self imageFor: #seven is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 122 170 170 170 170 167 119 135 122 170 170 170 170 167 119 135 119 119 119 119 170 167 119 135 119 119 119 122 170 119 119 135 119 119 119 170 167 119 119 135 119 119 122 170 119 119 119 135 119 119 170 167 119 119 119 135 119 122 170 119 119 119 119 135 119 170 167 119 119 119 119 135 119 170 167 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">six	^self imageFor: #six is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 221 221 221 221 215 119 135 125 221 221 221 221 215 119 135 125 221 119 119 119 119 119 135 125 221 119 119 119 119 119 135 125 221 221 221 215 119 119 135 125 221 221 221 221 119 119 135 125 221 119 119 221 215 119 135 125 221 119 119 221 215 119 135 125 221 221 221 221 215 119 135 119 221 221 221 221 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">three	^self imageFor: #three is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 121 153 153 153 153 119 119 135 121 153 153 153 153 151 119 135 119 119 119 119 153 151 119 135 119 119 119 119 153 151 119 135 119 119 153 153 153 119 119 135 119 119 153 153 153 119 119 135 119 119 119 119 153 151 119 135 119 119 119 119 153 151 119 135 121 153 153 153 153 151 119 135 121 153 153 153 153 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">triste	^self opaqueImageFor: #triste is: [Depth4Image extent: 17@17 depth: 4 palette: (self palette16) bits: #[255 255 255 0 0 15 255 255 240 0 0 0 255 255 0 187 187 176 15 255 240 0 0 0 255 240 187 187 187 187 176 255 240 0 0 0 255 11 187 187 187 187 187 15 240 0 0 0 240 187 11 11 187 11 11 176 240 0 0 0 240 187 176 187 187 176 187 176 240 0 0 0 11 187 11 11 187 11 11 187 0 0 0 0 11 187 187 187 187 187 187 187 0 0 0 0 11 187 187 187 187 187 187 187 0 0 0 0 11 187 187 187 187 187 187 187 0 0 0 0 11 187 187 0 0 11 187 187 0 0 0 0 240 187 176 187 187 176 187 176 240 0 0 0 240 187 11 187 187 187 11 176 240 0 0 0 255 11 187 187 187 187 187 15 240 0 0 0 255 240 187 187 187 187 176 255 240 0 0 0 255 255 0 187 187 176 15 255 240 0 0 0 255 255 255 0 0 15 255 255 240 0 0 0 ]]</body><body package="WinMineGame">two	^self imageFor: #two is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 34 34 34 34 119 119 135 114 34 34 34 34 39 119 135 114 34 119 119 34 39 119 135 119 119 119 119 34 39 119 135 119 119 119 34 34 119 119 135 119 119 34 34 39 119 119 135 119 34 34 39 119 119 119 135 114 34 39 119 119 119 119 135 114 34 34 34 34 39 119 135 114 34 34 34 34 39 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body><body package="WinMineGame">zero	^self imageFor: #zero is: [Depth4Image extent: 16@16 depth: 4 palette: (self palette16) bits: #[136 136 136 136 136 136 136 136 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 135 119 119 119 119 119 119 119 ]]</body></methods><methods><class-id>ACKIAWinMineSquare class</class-id> <category>private</category><body package="WinMineGame">imageFor: symbol is: aBlock 	"Answer the Image associated with a &lt;symbol&gt;.  If it has not yet been defined, evaluate &lt;aBlock&gt; to get the Image."	^icones at: symbol ifAbsentPut: [CachedImage on: aBlock value]</body><body package="WinMineGame">opaqueImageFor: symbol is: aBlock 	"Answer the Image associated with a &lt;symbol&gt;.  If it has not yet been defined, evaluate &lt;aBlock&gt; to get the Image."	^icones at: symbol		ifAbsentPut: 			[| image shape |			image := aBlock value.			shape := (image copy convertToPalette: MappedPalette whiteBlack) 						filledConvexShape palette: CoveragePalette monoMaskPalette.			OpaqueImage figure: (CachedImage on: image) shape: shape]</body><body package="WinMineGame">palette16	Palette16 isNil	ifTrue: [Palette16 := MappedPalette basicWithColors: ((Array new: 16) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 0 scaledBlue: 0); at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 0); at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); at: 6 put: (ColorValue scaledRed: 4112 scaledGreen: 0 scaledBlue: 4112); at: 7 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 4112); at: 8 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 9 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 10 put: ColorValue red; at: 11 put: ColorValue green; at: 12 put: ColorValue yellow; at: 13 put: ColorValue blue; at: 14 put: ColorValue magenta; at: 15 put: ColorValue cyan; at: 16 put: ColorValue white; yourself)].	^Palette16</body></methods><methods><class-id>ACKIAWinMineSquare class</class-id> <category>class initialization</category><body package="WinMineGame">initialize	"self initialize"	icones := IdentityDictionary new</body></methods><methods><class-id>ACKIAWinMineSquare class</class-id> <category>instance creation</category><body package="WinMineGame">at: aPoint in: aMineBrowser	^self new at: aPoint in: aMineBrowser</body></methods><methods><class-id>ACKIAWinMineBrowser class</class-id> <category>resources</category><body package="WinMineGame">iconImage	"UIMaskEditor new openOnClass: self andSelector: #iconImage"	&lt;resource: #image&gt;	^CachedImage on: (((Image extent: 32@32 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 7452 scaledGreen: 7452 scaledBlue: 7452); at: 3 put: (Graphics.ColorValue scaledRed: 7934 scaledGreen: 7934 scaledBlue: 7934); at: 4 put: (Graphics.ColorValue scaledRed: 6841 scaledGreen: 6841 scaledBlue: 6841); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 5910 scaledGreen: 5910 scaledBlue: 5910); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L@L3L3L3L3L3L3L3L3L3L0L@L3L3L3L3L3L3L3L3L3LC@CL3L3L3L3L3L3L3L3L@@@@@L3L3L3L3L3L3@CL@L3L3L0@3@CL3L3L3L@L@L3L3L3L3@C@CL3L3L3@@@3L3L3L3L0@@@3L3L3L3@CL3L3L3L3L0@CL3L3L3L0L3L3L3L3L3L@@3L3L3L3LCL3L3L3L3@3@@L3L3L3L0L3L3L3L3L3LC@@L3L3L3LCL3L3L@@3L3L0@CL3L3L@@3L3L0L3@3L0L@@@L3L0L0L3L3LCL0@0L0@@L0L3L@@CL3L3@3@@@0L@@@@CL3L@@3L3L3@@@@L0L@@@L3L3L0@3L3L3@@@@L@@@L3L3L3L@L3LC@0@@@0L@@CL3L3L3L@LCLC@3@C@@@@L3L3L3L3@@L@LC@3@C@@@CL3L3L3L3@@@0@0@@@@@@L3L3L3L3L0@@@@@@@@@@@CL3L3L3L3@0@@@@@@@@@@LCL3L3L3L0@@@@@@@@@@@@@3L3L3L3L0@3L@@@@@L3@CL3L3L3L3L3L3L0@0L3L3L3L3L3L3L3L3L3L@LCL3L3L3L3L3L3L3L3L3L@L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L1IEL3L3L3L3L3L3L3L3L3Lb'))) convertForGraphicsDevice: Screen default)</body><body package="WinMineGame">iconImageOriginal	"UIMaskEditor new openOnClass: self andSelector: #iconImageOriginal"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 255 255 255 255 255 255 255 254 127 255 255 253 63 255 255 253 63 255 255 240 15 255 252 207 243 63 249 63 252 159 248 127 252 31 252 255 254 63 253 255 254 63 253 255 246 63 251 255 253 31 251 252 127 31 227 251 189 7 219 251 150 27 195 251 10 3 227 252 13 7 249 254 4 31 249 234 10 31 252 181 144 63 252 74 200 63 254 18 0 127 254 0 0 127 253 0 0 191 252 0 0 63 254 112 14 127 255 252 191 255 255 252 191 255 255 254 127 255 255 255 255 255 255 255 255 255]))</body><body package="WinMineGame">iconMask	"UIMaskEditor new openOnClass: self andSelector: #iconMask"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 15 240 0 3 63 252 192 7 255 255 224 7 255 255 224 3 255 255 192 3 255 255 192 3 255 255 192 7 255 255 224 7 255 255 224 31 255 255 248 63 255 255 252 63 255 255 252 31 255 255 248 7 255 255 224 7 255 255 224 3 255 255 192 3 255 255 192 1 255 255 128 1 255 255 128 3 255 255 192 3 255 255 192 1 143 241 128 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0]))</body></methods><initialize><class-id>ACKIAWinMineBrowser</class-id></initialize><initialize><class-id>ACKIAWinMineSquare</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ControllerWithMenu</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationStandardSystemController</name><environment>UI</environment><super>UI.StandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class></st-source>