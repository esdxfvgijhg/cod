<?xml version="1.0"?><st-source><!-- Name: XMLObjectSupportNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: XMLObjectSupport provides core classes mostly exceptions that are used in the Web services Toolkit.DbIdentifier: bear73DbTrace: 493888DbUsername: tkoganDbVersion: 8.3 - 0DevelopmentPrerequisites: #(#(#any 'WebServicesNamespace' '') #(#any 'Protocols-Common' '') #(#any 'Tools-Settings-VW' '') #(#any 'Tools-Settings' ''))PackageName: XMLObjectSupportParcel: #('XMLObjectSupport')ParcelName: XMLObjectSupportPrerequisiteDescriptions: #(#(#name 'WebServicesNamespace') #(#name 'Protocols-Common') #(#name 'Tools-Settings-VW') #(#name 'Tools-Settings' #componentType #package))PrerequisiteParcels: #(#('WebServicesNamespace' '') #('Protocols-Common' '') #('Tools-Settings-VW' '') #('Tools-Settings' ''))PrintStringCache: (8.3 - 0,tkogan)Version: 8.3 - 0Date: 2:31:37 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:37 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>XMLObjectBindingSignal</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLObjectBindingSignal</class-id><body>XMLObjectBindingSignal is the superclass for the binding exceptions</body></comment><class><name>ValidationNotification</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.ValidationNotification</class-id><body>ValidationNotification will be raised by the SimpleObjectMarshaler if the marshaled/unmarshaled value failed validation</body></comment><class><name>ClassIsNotDefinedSignal</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.ClassIsNotDefinedSignal</class-id><body>ClassNotDefinedSignal is raised by the compex object marshaler to signal that there is no smalltalk class for the XML attribute smalltalkClass.</body></comment><class><name>MissingValueSignal</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.MissingValueSignal</class-id><body>Missing value signal is error signaling that there is no value for a relation marshaler to unmarshal or marshal. Instance Variables:</body></comment><class><name>WrongObjectType</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.WrongObjectType</class-id><body>WrongObjectType will be raised by the type marshalers when the object type doesn't match the X2O binding spec.</body></comment><class><name>ObjectNotResolvedSignal</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.ObjectNotResolvedSignal</class-id><body>ObjectNotResolvedSignal is error signaling that the XML element was not resolved to a Smalltalk object</body></comment><class><name>XMLDatatypeError</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLDatatypeError</class-id><body>XMLDatatypeError is the super class for all errors raised while encoding objects into XML strings and decoding XML string into objects.</body></comment><class><name>NoMarshalerSignal</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.NoMarshalerSignal</class-id><body>NoMarshalerSignal is error signaling that there is no marshaler found for the node tag</body></comment><class><name>Struct</name><environment>WebServices</environment><super>Protocols.Struct</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.Struct</class-id><body>Struct respresents a named dictionary with part order.Instance Variables:	name	&lt;String&gt;	struct name	partOrder	&lt;OrderedCollection of: (Object)&gt;	struct part order</body></comment><class><name>WSDuplicateBindingsError</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.WSDuplicateBindingsError</class-id><body>WSDuplicateBindingsError raised by the BindingClassBuilder when the Smalltalk classes from X2O binding have being detect in the system. The exception parameter includes confict classes.- The classes won't be created if the exception proceeds.- All new classes will be created in if the exception resumes with #createAll parameter. - New list of classes can be provided by an application if the exception resumes with the #createClassesList key in the parameter struct.</body></comment><class><name>NonDeterministicContentModel</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.NonDeterministicContentModel</class-id><body>NonDeterministicContentModel is raised while validating a complex type relationsDeterminismXML DTDs and W3C XML Schema have a rule that requires schemas to have deterministic content models. From the XML 1.0 specification,For example, the content model ((b, c) | (b, d)) is non-deterministic, because given an initial b the XML processor cannot know which b in the model is being matched without looking ahead to see which element follows the b. The use of ##any means there are some schemas that we might like to express, but that aren't allowed.- Wildcards with ##any, where minOccurs does not equal maxOccurs, are not allowed before an element declaration. An instance of the element would be valid for the ##any or the element. ##other could be used.- The element before a wildcard with ##any must have cardinality of maxOccurs equals its minOccurs. If these were different, say minOccurs="1" and maxOccurs="2", then the optional occurrences could match either the element definition or the ##any. As a result of this rule, the minOccurs must be greater than zero.- Derived types that add element definitions after a wildcard with ##any must be avoided. A derived type might add an element definition after the wildcard, then an instance of the added element definition could match either the wildcard or the derived element definition.** Be Deterministic rule: Use of wildcards MUST be deterministic. Location of wildcards, namespace of wildcard extensions, minOccurs and maxOccurs values are constrained, and type restriction is controlled.</body></comment><class><name>XMLBuildingPolicy</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementAssist targetNamespace choiceIndex anyIndex sequenceIndex groupIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLBuildingPolicy</class-id><body>XMLBuildingPolicy is super class for diffrent policiesInstance Variables	elementAssist	&lt;XMLElementAssist&gt; 	targetNamespace	&lt;String&gt; target namespace	choiceIndex	&lt;Integer&gt; the number is used to create a choice aspect value	anyIndex	&lt;Integer&gt; the number is used to create a &lt;any&gt; aspect value	sequenceIndex	&lt;Integer&gt; the number is used to create a &lt;sequence&gt; aspect value	groupIndex	&lt;Integer&gt; the number is used to create a &lt;group ref=".."&gt; aspect value</body></comment><class><name>XMLDefaultBindingPolicy</name><environment>WebServices</environment><super>WebServices.XMLBuildingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLDefaultBindingPolicy</class-id><body>XMLDefaultBindingPolicy creates default XML types mapping. By default XML nodes with complex contents are mapped  to a smalltalk dictionaries.The example:  &lt;types&gt;    &lt;s:schema elementFormDefault="qualified" targetNamespace="http://vbcentral.net/ShipService/"&gt;      &lt;s:element name="HelloShipRater"&gt;        &lt;s:complexType&gt;          &lt;s:sequence&gt;            &lt;s:element minOccurs="0" maxOccurs="1" name="TestReturnData" type="s:string" /&gt;          &lt;/s:sequence&gt;        &lt;/s:complexType&gt;      &lt;/s:element&gt;    &lt;/s:schema&gt;&lt;/types&gt;Default mapping:&lt;schemaBindings &gt; &lt;xmlToSmalltalkBinding &gt;  &lt;struct name="HelloShipRater"&gt;      &lt;element name="TestReturnData" ref="s:string"/&gt;  &lt;/struct&gt; &lt;/xmlToSmalltalkBinding &gt;&lt;/schemaBindings &gt;</body></comment><class><name>MissingValueNotification</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.MissingValueNotification</class-id><body>Missing value notification is usually raised by relation/compex marshalers to signal that there is no value for a realtion marshaler to unmarshal or marshal. It is not always an error -- if relation in question is non-mandatory, the value will be niled or ignored. If it is mandatory, the exception is re-raised as MissingValueSignalInstance Variables:</body></comment><class><name>XMLDecodingError</name><environment>WebServices</environment><super>WebServices.XMLDatatypeError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xmlDatatype </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLDecodingError</class-id><body>Represents notifications raised while decoding XML strings into objects (simple types)Instance Variables:	xmlDatatype	&lt;Symbol&gt;	expected XML datatype </body></comment><class><name>DecodedInvalidString</name><environment>WebServices</environment><super>WebServices.XMLDecodingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.DecodedInvalidString</class-id><body>Raised if a decoded string has invalid characters (violating the restrictions of the XML string type). The error is resumable and the default action returns the XML string as it was received.</body></comment><class><name>XMLEncodingError</name><environment>WebServices</environment><super>WebServices.XMLDatatypeError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expectedClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLEncodingError</class-id><body>Represents errors raised while encoding objects (simple types ) into XML strings.Instance Variables:	expectedClass	&lt;Class&gt;	expected class to encode</body></comment><class><name>EncodingIntegerOutOfRange</name><environment>WebServices</environment><super>WebServices.XMLEncodingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.EncodingIntegerOutOfRange</class-id><body>Raised if the integer value to be encoded is outside of the range of the expected XML datatype. The error is resumable and expects the encoded, string form of the integer as the resumption value.</body></comment><class><name>ValidationError</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.ValidationError</class-id><body>ValidationError is raised by the simple object marshaler to signal failed validation. </body></comment><class><name>EncodingInvalidString</name><environment>WebServices</environment><super>WebServices.XMLEncodingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.EncodingInvalidString</class-id><body>Raised if a string to be encoded includes invalid characters (violating the restrictions of the XML string datatype). The error is resumable and expects a corrected string as the resumption value.The string datatype represents character strings in XML. The ·value space· of string is the set of finite-length sequences of characters (as defined in [XML 1.0 (Second Edition)]A character is an atomic unit of text as specified by ISO/IEC 10646 [ISO/IEC 10646] [E67](see also [ISO/IEC 10646-2000]). Legal characters are tab, carriage return, line feed, and the legal characters of Unicode and ISO/IEC 10646. [E69]The versions of these standards cited in A.1 Normative References were current at the time this document was prepared. New characters may be added to these standards by amendments or new editions. Consequently, XML processors must accept any character in the range specified for Char. The use of 'compatibility characters', as defined in section 6.8 of [Unicode] [E67](see also D21 in section 3.6 of [Unicode3]), is discouraged.]Character Range[2]    Char    ::=    #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]  /* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */</body></comment><class><name>XMLElementAssist</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaces currentElement root imports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLElementAssist</class-id><body>XMLElementAssist helps to create XML elements and attributes.Instance Variables:	currentElement	&lt;XML.Element&gt;	current XML element	namespaces	&lt;Dictionary&gt;	XML namespaces	root	&lt;XML.Element&gt;	root element	imports &lt;OrderedCollection of: XML.Element&gt; import elements</body></comment><class><name>MissingTypeAttribute</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.MissingTypeAttribute</class-id><body>The exception is raised if a complex type declared as abstract was encoded without  xsi:type attribute.http://www.w3.org/TR/xmlschema-0/#abstract.When an element's corresponding type definition is declared as abstract, all instances of that element must use xsi:type to indicate a derived type that is not abstract. </body></comment><class><name>XMLObjectBindingPolicy</name><environment>WebServices</environment><super>WebServices.XMLDefaultBindingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes </inst-vars><class-inst-vars>useExistingAspectNamesHolder </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.XMLObjectBindingPolicy</class-id><body>XMLObjectBindingPolicy maps XML types with complex contents  to  smalltalk classesFor example  &lt;types&gt;    &lt;s:schema elementFormDefault="qualified" targetNamespace="http://vbcentral.net/ShipService/"&gt;      &lt;s:element name="HelloShipRater"&gt;        &lt;s:complexType&gt;          &lt;s:sequence&gt;            &lt;s:element minOccurs="0" maxOccurs="1" name="TestReturnData" type="s:string" /&gt;          &lt;/s:sequence&gt;        &lt;/s:complexType&gt;      &lt;/s:element&gt;    &lt;/s:schema&gt;&lt;/types&gt;Object mapping:&lt;schemaBindings &gt; &lt;xmlToSmalltalkBinding &gt;  &lt;object name="HelloShipRater" smalltalkClass="HelloShipRater"      &lt;element name="TestReturnData" ref="s:string" aspect='testReturnData"/&gt;  &lt;/object&gt; &lt;/xmlToSmalltalkBinding &gt;&lt;/schemaBindings &gt;Instance Variables	classes	&lt;Collection of: String&gt; collection of class names created for this mapping	choiceIndex	&lt;Integer&gt; is used to create inst vars for choice groupsClass Instance Variables	useExistingAspectNamesHolder &lt;ValueHolder on: OrderedCollection&gt; allow specifying aspect conflict names that can be used without underscores. The aspect names (or values of element name attributes) are used as  getter and setter method names and there is possible to have a conflict with already existing system methods. To avoid conflicts the tool adds underscore to these aspect names. Use #useExistingAspectNames: method to set the collection values.Shared Variables	DefaultClassNamespace	&lt;String&gt; Smalltalk is default class namespace	RemoveAspectUnderscores	&lt;Boolean&gt; defines if underscores will be removed from names	UseExistingClassName	&lt;Boolean&gt; defines if the existing class names will be used in the mapping</body></comment><class><name>DecodedIntegerOutOfRange</name><environment>WebServices</environment><super>WebServices.XMLDecodingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decodedInteger </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.DecodedIntegerOutOfRange</class-id><body>Raised if an XML string decoded into an integer that is out of the expected XML datatype range. The error is resumable and the default action returns the decoded integer.Instance Variables:	decodedInteger	&lt;Integer&gt;	decoded integer</body></comment><class><name>RequiresRegex</name><environment>WebServices</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.RequiresRegex</class-id><body>The notification is raised when XML simple type requires pattern validation and Regex11 package is not loaded</body></comment><class><name>NilValueNotAllowed</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><comment><class-id>WebServices.NilValueNotAllowed</class-id><body>NilValueNotAllowed exception will be raised if a type marshaler detects the nil values for the XML element that was described with the nillable="false" attribute</body></comment><shared-variable><name>DefaultClassNamespace</name><environment>WebServices.XMLObjectBindingPolicy</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>XMLObjectSupport</package></attributes></shared-variable><shared-variable><name>UseExistingClassName</name><environment>WebServices.XMLObjectBindingPolicy</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>XMLObjectSupport</package></attributes></shared-variable><shared-variable><name>RemoveAspectUnderscores</name><environment>WebServices.XMLObjectBindingPolicy</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>XMLObjectSupport</package></attributes></shared-variable><methods><class-id>WebServices.XMLObjectBindingSignal class</class-id> <category>testing</category><body package="XMLObjectSupport">mayResume	^true</body></methods><methods><class-id>WebServices.Struct</class-id> <category>accessing</category><body package="XMLObjectSupport">asValue	"Return a ValueHolder on the receiver"	^ValueHolder with: self</body><body package="XMLObjectSupport">at: key ifAbsentPut: aBlock	| value |	1 to: lastIndex do: [ :i || asc |		asc := self basicAt: i.		asc key = key ifTrue: [^asc value] ].	value := aBlock value.	self addLast: key -&gt; value.	^value</body><body package="XMLObjectSupport">evaluate	"Answer the result of evaluating the receiver, or the receiver itself if	it does not have any execution semantics."	^self</body><body package="XMLObjectSupport">keys      | coll |	coll := OrderedCollection new.	1 to: lastIndex do: [ :i | coll add: (self basicAt: i) key ].	^coll</body><body package="XMLObjectSupport">name	^name</body><body package="XMLObjectSupport">name: aString	name := aString</body><body package="XMLObjectSupport">orderedValues     | coll |	coll := OrderedCollection new.	1 to: lastIndex do: [ :i | coll add: (self basicAt: i) value ].	^coll</body><body package="XMLObjectSupport">partOrder       ^self keys</body><body package="XMLObjectSupport">partOrder: aCollection       ^aCollection do: [ :px | self at: px ifAbsentPut: nil ].</body><body package="XMLObjectSupport">size	^self structSize</body><body package="XMLObjectSupport">values	^self orderedValues</body></methods><methods><class-id>WebServices.Struct</class-id> <category>printing</category><body package="XMLObjectSupport">displayString		^self printString</body><body package="XMLObjectSupport">printOn: aStream	aStream nextPutAll: self class name asString, ': '.	self printNameOn: aStream.	aStream nextPut: ${.	self 		associationsDo: [ :asc | aStream nextPutAll: asc key printString, '-&gt;', asc value printString ]		separatedBy: [ aStream nextPutAll: ' ' ].	aStream nextPut: $}.</body></methods><methods><class-id>WebServices.Struct</class-id> <category>testing</category><body package="XMLObjectSupport">isOutputParameter	^false</body><body package="XMLObjectSupport">isProtocolAdaptor	^false</body><body package="XMLObjectSupport">isSignalledException	^false</body><body package="XMLObjectSupport">isSoapEnvelope	^false</body><body package="XMLObjectSupport">isSoapFault	^false</body></methods><methods><class-id>WebServices.WSDuplicateBindingsError class</class-id> <category>testing</category><body package="XMLObjectSupport">mayResume	^true</body></methods><methods><class-id>WebServices.NonDeterministicContentModel</class-id> <category>printing</category><body package="XMLObjectSupport">defaultMessageText	^(#TheContentModelIsNotDeterministic &lt;&lt; #webservices &gt;&gt; 'The content model is not deterministic. Unmarshaling XML can produce wrong results') asString</body></methods><methods><class-id>WebServices.XMLBuildingPolicy</class-id> <category>complex types</category><body package="XMLObjectSupport">addChoiceTo: anXMLElement do: aBlock	^self subclassResponsibility</body><body package="XMLObjectSupport">addComplexContentWithExtension: aString to: anXMLElement</body><body package="XMLObjectSupport">addExtension: aString to: anXMLElement</body><body package="XMLObjectSupport">addRestrictions: aCollection to: anXMLElement	| n |	aCollection		do: [ :assoc |			n := self createElementType: assoc key.			self addAttribute: 'value' value: assoc value to: n.			anXMLElement addNode: n ].</body><body package="XMLObjectSupport">addSequenceTo: anXMLElement do: aBlock	^self subclassResponsibility</body><body package="XMLObjectSupport">arrayNode: anXMLElement addType: typeNode dimension: aNumber	^self subclassResponsibility</body><body package="XMLObjectSupport">newArrayName: aString type: typeNode dimension: aNumber	| node |	node := self newArrayNamed: aString.	self arrayNode: node addType: typeNode dimension: aNumber.	^node</body><body package="XMLObjectSupport">newArrayNamed: aString	^self subclassResponsibility</body><body package="XMLObjectSupport">newChoice	^self elementAssist createElement: 'choice'.</body><body package="XMLObjectSupport">newChoiceType: aString	^self newComplexType: aString</body><body package="XMLObjectSupport">newChoiceWith: aString	^self newChoice</body><body package="XMLObjectSupport">newCollectionNamed: aString	^self subclassResponsibility</body><body package="XMLObjectSupport">newComplexType: aString 	^self newComplexType: aString inNamespace: nil</body><body package="XMLObjectSupport">newComplexType: aString inNamespace: nsString	^self subclassResponsibility</body><body package="XMLObjectSupport">newStructType: aString	^self subclassResponsibility</body></methods><methods><class-id>WebServices.XMLBuildingPolicy</class-id> <category>documentation</category><body package="XMLObjectSupport">addDocumentation: aString to: anXMLElement	self elementAssist addAnnotation: aString to: anXMLElement</body></methods><methods><class-id>WebServices.XMLBuildingPolicy</class-id> <category>accessing</category><body package="XMLObjectSupport">anyIndex	^anyIndex isNil		ifTrue: [ anyIndex := 0 ]		ifFalse: [ anyIndex := anyIndex + 1 ]</body><body package="XMLObjectSupport">choiceIndex	^choiceIndex isNil		ifTrue: [ choiceIndex := 0 ]		ifFalse: [ choiceIndex := choiceIndex + 1 ]</body><body package="XMLObjectSupport">defaultAnyValue	^'any'</body><body package="XMLObjectSupport">defaultChoiceValue	^'choiceValue'</body><body package="XMLObjectSupport">defaultGroupValue	^'groupValue'</body><body package="XMLObjectSupport">defaultSequenceValue	^'sequenceValue'</body><body package="XMLObjectSupport">elemName: anElement 	^(anElement 		attributeNamed: 'name' 		ifAbsent: [ (anElement attributeNamed: 'ref' ifAbsent: [ ^nil]) ]	) value</body><body package="XMLObjectSupport">elementAssist	^elementAssist isNil		ifTrue: [ elementAssist := XMLElementAssist new]		ifFalse: [elementAssist]</body><body package="XMLObjectSupport">elementAssist: anObject	elementAssist := anObject</body><body package="XMLObjectSupport">groupIndex	^groupIndex isNil		ifTrue: [ groupIndex := 0 ]		ifFalse: [ groupIndex := groupIndex + 1 ]</body><body package="XMLObjectSupport">nextAnyValue	| ind |	ind := self anyIndex.	^ind = 0 		ifTrue: [ self defaultAnyValue ]		ifFalse: [ self defaultAnyValue, ind printString]</body><body package="XMLObjectSupport">nextChoiceValue	| ind |	ind := self choiceIndex.	^ind = 0 		ifTrue: [ self defaultChoiceValue ]		ifFalse: [ self defaultChoiceValue, ind printString]</body><body package="XMLObjectSupport">nextGroupValue	| ind |	ind := self groupIndex.	^ind = 0 		ifTrue: [ self defaultGroupValue ]		ifFalse: [ self defaultGroupValue, ind printString]</body><body package="XMLObjectSupport">nextSequenceValue	| ind |	ind := self sequenceIndex.	^ind = 0 		ifTrue: [ self defaultSequenceValue ]		ifFalse: [ self defaultSequenceValue, ind printString]</body><body package="XMLObjectSupport">nodeTagFor: aString	^NodeTag 		qualifier: self targetNamespaceQualifier		ns: self targetNamespace		type:aString</body><body package="XMLObjectSupport">rootChildName	^self subclassResponsibility</body><body package="XMLObjectSupport">rootName	^self subclassResponsibility</body><body package="XMLObjectSupport">sequenceIndex	^sequenceIndex isNil		ifTrue: [ sequenceIndex := 0 ]		ifFalse: [ sequenceIndex := sequenceIndex + 1 ]</body><body package="XMLObjectSupport">targetNamespace	^targetNamespace</body><body package="XMLObjectSupport">targetNamespace: anObject	targetNamespace := anObject</body><body package="XMLObjectSupport">targetNamespaceQualifier 	^'tns'</body></methods><methods><class-id>WebServices.XMLBuildingPolicy</class-id> <category>elements</category><body package="XMLObjectSupport">createCollectionElementNamed: aString</body><body package="XMLObjectSupport">createElementFrom: anXMLElement	^self elementAssist createElement: 'element' attrName: (self elemName: anXMLElement)</body><body package="XMLObjectSupport">createElementFromTag: anXMLNodeTag  	^self elementAssist createElementFromTag: anXMLNodeTag</body><body package="XMLObjectSupport">createElementName: aString	^self elementAssist createElement: 'element' attrName: aString</body><body package="XMLObjectSupport">createElementType: aString	^self elementAssist createElement: aString</body><body package="XMLObjectSupport">createElementType: aString attrName: aStringName	^self elementAssist createElement: aString attrName: aStringName</body><body package="XMLObjectSupport">createRootNodeWithAttributes: attributes	| root node |	root := self createElementType: self rootName.	node := self  createElementType: self rootChildName.	root addNode: node.	self  addNamespacesTo: node. 	attributes keysAndValuesDo:		[ :key :value | self addAttribute: key asString value: value  to: node ].	^root</body><body package="XMLObjectSupport">createSimpleTypeName: aString	^self subclassResponsibility</body><body package="XMLObjectSupport">createText: aString	^self elementAssist createText: aString</body><body package="XMLObjectSupport">root: anXMLNode	elementAssist root: anXMLNode.</body></methods><methods><class-id>WebServices.XMLBuildingPolicy</class-id> <category>attributes</category><body package="XMLObjectSupport">addAspectAttribute: aString from: aCtmComplexType to: anXMLElement</body><body package="XMLObjectSupport">addAspectAttribute: aString to: anXMLElement</body><body package="XMLObjectSupport">addAspectAttributeTo: anXMLElement</body><body package="XMLObjectSupport">addAspectToAny: xmlElement	xmlElement parent ifNotNil: [ :parent | 		(parent realElements collect: [ :each | each tag type = 'any' ]) size = 1 ifTrue: [anyIndex := nil ]].				self addAttribute: 'aspect' value: self nextAnyValue to: xmlElement</body><body package="XMLObjectSupport">addAspectToChoice: xmlElement	xmlElement parent ifNotNil: [ :parent | 		(parent realElements select: [ :each | each tag type = 'choice']) size = 1			ifTrue: [choiceIndex := nil ]].				self addAttribute: 'aspect' value: self nextChoiceValue to: xmlElement</body><body package="XMLObjectSupport">addAspectToGroup: xmlElement	xmlElement parent ifNotNil: [ :parent | 		(parent realElements select: [ :each | each tag type = 'group' ]) size = 1			ifTrue: [groupIndex := nil ]].				self addAttribute: 'aspect' value: self nextGroupValue to: xmlElement</body><body package="XMLObjectSupport">addAspectToSequence: xmlElement	xmlElement parent ifNotNil: [ :parent | 		(parent realElements select: [ :each | each tag type = 'sequence' ]) size = 1			ifTrue: [sequenceIndex := nil ]].				self addAttribute: 'aspect' value: self nextSequenceValue to: xmlElement</body><body package="XMLObjectSupport">addAttribute: anXMLAttribute to: anXMLElement	^anXMLAttribute notNil		ifTrue: [ self elementAssist addAttribute: anXMLAttribute to: anXMLElement ]		ifFalse: [ nil ]</body><body package="XMLObjectSupport">addAttribute: aStringOrNode value: valString to: anXMLElement	^aStringOrNode notNil		ifTrue: [self elementAssist addAttribute: aStringOrNode value: valString to: anXMLElement ]		ifFalse: [ nil ]</body><body package="XMLObjectSupport">addTypeAttribute: anXMLNode to: anXMLElement	^self subclassResponsibility</body><body package="XMLObjectSupport">maxOccurs: aNumber	| str |	str := (aNumber isString		ifTrue: [aNumber]		ifFalse: [aNumber printString]).	^str ~= '1' 		ifTrue:  [ self elementAssist createAttribute: 'maxOccurs' value:  str ]		ifFalse: [ nil ]</body><body package="XMLObjectSupport">minOccurs: aNumber	| str |	str := (aNumber isString		ifTrue: [aNumber]		ifFalse: [aNumber printString]).	^str ~= '1' 		ifTrue:  [ self elementAssist createAttribute: 'minOccurs' value:  str ]		ifFalse: [ nil ]</body></methods><methods><class-id>WebServices.XMLBuildingPolicy</class-id> <category>namespaces</category><body package="XMLObjectSupport">addNamespacesTo: anXMLElement 	self registerNamespaceAt: self targetNamespaceQualifier put: self targetNamespace.	self defaultNS.	self registerNamespaceAt: 'xsd' put: self class defaultUriXsd.</body><body package="XMLObjectSupport">defaultNS	^self subclassResponsibility</body><body package="XMLObjectSupport">qualifierFor: qString namespace: nsString	^self elementAssist qualifierFor: qString namespace: nsString</body><body package="XMLObjectSupport">registerNamespaceAt: qString put: nsString	^self elementAssist registerNamespaceAt: qString put: nsString.</body><body package="XMLObjectSupport">setNamespacesFor: anXMLElement	^self elementAssist setNamespacesFor: anXMLElement</body></methods><methods><class-id>WebServices.XMLBuildingPolicy</class-id> <category>imports</category><body package="XMLObjectSupport">addImportNs: nsString	self elementAssist addImportNs: nsString</body><body package="XMLObjectSupport">addImportNs: nsString location: lString	self elementAssist addImportNs: nsString location: lString</body><body package="XMLObjectSupport">imports	^self elementAssist imports</body></methods><methods><class-id>WebServices.XMLBuildingPolicy class</class-id> <category>defaults</category><body package="XMLObjectSupport">defaultUriXsd" Answer URI of XSchema namespace "	^'http://www.w3.org/2001/XMLSchema'</body><body package="XMLObjectSupport">uriVWBinding" Answer namespace of VisualWorks schema binding "	^'urn:visualworks:VWSchemaBinding'</body></methods><methods><class-id>WebServices.XMLDefaultBindingPolicy</class-id> <category>accessing</category><body package="XMLObjectSupport">elemTag: anElement 	| attr |	attr := anElement attributeNamed: 'tag' ifAbsent: [ nil].	^attr notNil		ifTrue: [ attr value]		ifFalse: [ nil]</body><body package="XMLObjectSupport">rootChildName	^'xmlToSmalltalkBinding'</body><body package="XMLObjectSupport">rootName	^'schemaBindings'</body></methods><methods><class-id>WebServices.XMLDefaultBindingPolicy</class-id> <category>complex types</category><body package="XMLObjectSupport">addComplexContentWithExtension: aString to: anXMLElement 	^self addExtension: aString to: anXMLElement</body><body package="XMLObjectSupport">addExtension: aString to: anXMLElement 	self elementAssist 		addAttribute: 'baseType'		value: aString		to: anXMLElement.	^anXMLElement</body><body package="XMLObjectSupport">addSequenceTo: anXMLElement do: aBlock	aBlock value: anXMLElement.	^anXMLElement</body><body package="XMLObjectSupport">arrayNode: anXMLElement addType: typeNode dimension: aNumber	self addAttribute: 'ref' value: typeNode asString to: anXMLElement.	self addAttribute: 'dimension' value: aNumber printString to: anXMLElement.	^anXMLElement</body><body package="XMLObjectSupport">newArrayNamed: aString	^self createElementType: 'soapArray' attrName: aString.</body><body package="XMLObjectSupport">newChoiceType: aString	^self elementAssist createElement: 'struct' attrName: aString.</body><body package="XMLObjectSupport">newCollectionNamed: aString	^self createElementType: 'sequence_of' attrName: aString.</body><body package="XMLObjectSupport">newComplexType: aString inNamespace: nsString	^self elementAssist createElement: 'struct' attrName: aString.</body><body package="XMLObjectSupport">newComplexTypeFrom: anElement inNamespace: nsString	^self elementAssist createElement: 'struct' attrName: ( self elemName: anElement).</body><body package="XMLObjectSupport">newStructType: aString	| el  |	el := self elementAssist createElement: 'struct' attrName: aString.	self elementAssist addAttribute: 'smalltalkClass' value: Struct name asString.	^el</body></methods><methods><class-id>WebServices.XMLDefaultBindingPolicy</class-id> <category>attributes</category><body package="XMLObjectSupport">addRefAttribute: anXMLNode to: anXMLElement	self elementAssist addAttribute: 'ref' value: anXMLNode asString to: anXMLElement.</body><body package="XMLObjectSupport">addTagAttributeFrom: anElement to: anXMLElement	| tag |	(tag := self elemName: anElement) notNil		ifTrue: 			[self elementAssist 				addAttribute: 'tag' 				value: tag				to: anXMLElement]</body><body package="XMLObjectSupport">addTypeAttribute: anXMLElement to: rootXMLElement	self elementAssist addAttribute: 'ref' value: anXMLElement tag asString to: rootXMLElement.	anXMLElement attributes 		do: [ :attr |  rootXMLElement attributes add: attr ].	anXMLElement realElements notEmpty		ifTrue: [ rootXMLElement elements: anXMLElement realElements]</body></methods><methods><class-id>WebServices.XMLDefaultBindingPolicy</class-id> <category>elements</category><body package="XMLObjectSupport">createCollectionElementNamed: aString	| node |	node :=self createElementType:  'element'.	self addAttribute: 'name' value: aString to: node.	^node</body><body package="XMLObjectSupport">createSimpleTypeName: aString	^self elementAssist createElement: 'simple' attrName: aString</body></methods><methods><class-id>WebServices.XMLDefaultBindingPolicy</class-id> <category>testing</category><body package="XMLObjectSupport">isComplex: anXMLNodeTag	^anXMLNodeTag tag type ~= 'xmlToSmalltalkBinding'</body><body package="XMLObjectSupport">isDefaultPolicy	^true</body></methods><methods><class-id>WebServices.XMLDefaultBindingPolicy</class-id> <category>namespaces</category><body package="XMLObjectSupport">defaultNS	self registerNamespaceAt: '' put: self class uriVWBinding.</body></methods><methods><class-id>WebServices.XMLDecodingError</class-id> <category>private - actions</category><body package="XMLObjectSupport">defaultAction	"What to do when the exception is unhandled. Return decoded integer "		^self defaultResumeValue</body></methods><methods><class-id>WebServices.XMLDecodingError</class-id> <category>accessing</category><body package="XMLObjectSupport">xmlDatatype	^xmlDatatype</body><body package="XMLObjectSupport">xmlDatatype: aSymbol	xmlDatatype := aSymbol</body></methods><methods><class-id>WebServices.DecodedInvalidString</class-id> <category>constants</category><body package="XMLObjectSupport">defaultResumeValue		^parameter</body></methods><methods><class-id>WebServices.XMLEncodingError</class-id> <category>accessing</category><body package="XMLObjectSupport">expectedClass	^expectedClass</body><body package="XMLObjectSupport">expectedClass: aClass	expectedClass := aClass</body></methods><methods><class-id>WebServices.XMLElementAssist</class-id> <category>utilities</category><body package="XMLObjectSupport">add: anXMLElement to: anXMLElement1	anXMLElement1 addNode: anXMLElement</body><body package="XMLObjectSupport">addAttribute: anXMLAttribute to: anXMLElement	^anXMLElement attributes add: anXMLAttribute</body><body package="XMLObjectSupport">addAttribute: aString value: valString	^self addAttribute: aString value: valString to: currentElement</body><body package="XMLObjectSupport">addAttribute: aString value: valString to: anXMLElement	| attr |	attr := self createAttribute: aString value: valString.	anXMLElement addAttribute: attr.	^attr</body><body package="XMLObjectSupport">addImportNs: nsString 	self addImportNs: nsString location: nil</body><body package="XMLObjectSupport">addImportNs: nsString location: lString " &lt;import namespace='http://schemas.xmlsoap.org/soap/encoding/' /&gt; ""  &lt;import location='http://www.whitemesa.com/wsdl/wmmsgrouter.xsd' namespace='http://whitemesa.com/headers/soapmsgrouter.xsd' /&gt; "	| el |	el := self createElement: 'import'.	self addAttribute: 'namespace' value: nsString to: el.	lString ~~ nil		ifTrue: [ 	self addAttribute: 'location'  value: lString to: el].	self imports add: el.</body><body package="XMLObjectSupport">addTo: anXMLElement	anXMLElement addNode: currentElement</body><body package="XMLObjectSupport">addToRoot: anXMLElementOrCollection	anXMLElementOrCollection isNil ifTrue: [ ^nil ].	(anXMLElementOrCollection isKindOf: Collection)		ifTrue: [ anXMLElementOrCollection do: [ :n | root addNode: n]]		ifFalse: [root addNode: anXMLElementOrCollection].</body><body package="XMLObjectSupport">createAttribute: aString value: valString	^Attribute name: aString value: valString</body><body package="XMLObjectSupport">createElement: aString  	^self createElement: aString qualifier: '' ns: '' attrName: nil</body><body package="XMLObjectSupport">createElement: aString  attrName: aStringName	^self createElement: aString qualifier: '' ns: '' attrName: aStringName</body><body package="XMLObjectSupport">createElement: aString  qualifier: aStringQ 	^self createElement: aString qualifier: aStringQ ns: '' attrName: nil</body><body package="XMLObjectSupport">createElement: aString qualifier: aStringQ ns: aStringNs attrName: aStringName	currentElement := Element tag: (NodeTag qualifier: aStringQ ns: aStringNs type: aString).	currentElement attributes: (OrderedCollection new: 10).	aStringName notNil		ifTrue: 			[(aStringName isKindOf: NodeTag)				ifTrue: [self addAttribute: 'name' value: aStringName type]				ifFalse: [self addAttribute: 'name' value: aStringName]].	^currentElement</body><body package="XMLObjectSupport">createElementFromTag: anXMLNodeTag  	| el  |	el := Element tag: anXMLNodeTag.	el attributes: (OrderedCollection new: 10).	^el</body><body package="XMLObjectSupport">createText: aString	^XML.Text text: aString</body></methods><methods><class-id>WebServices.XMLElementAssist</class-id> <category>namespaces</category><body package="XMLObjectSupport">qualifierFor: aProposedQualifier namespace: aString 	^self qualifierFor: aProposedQualifier namespace: aString namespaces: namespaces.</body><body package="XMLObjectSupport">qualifierFor: aProposedQualifier namespace: aString namespaces: namespacesx " Obtain qualifier for given namespace. We assume this namespace is not is the dictionary of namespaces. Answer qualifier of this namespace if it can be found in namespace map. Otherwise manufacture a new qualifier in such a way that it does not match any of qualifiers in eiher namespaces or in namespace map "	| suffix candidate prefix ns | 	(ns := namespacesx values detect: [ :n | n = aString] ifNone: [nil]) notNil		ifTrue: [ ^namespacesx keyAtValue: ns].	suffix := nil.	prefix := aProposedQualifier.	candidate := prefix.	[namespacesx includesKey: candidate ]			whileTrue:				[suffix := suffix isNil							ifTrue: [0]							ifFalse: [suffix + 1].				candidate := prefix, (suffix printStringRadix: 16)].	self registerNamespaceAt: candidate put: aString.	^candidate.</body><body package="XMLObjectSupport">registerNamespaceAt: qString put: nsString	namespaces at: qString ifAbsentPut: [nsString]</body><body package="XMLObjectSupport">setNamespaces	self root namespaces: namespaces</body><body package="XMLObjectSupport">setNamespacesFor: anXMLElement	anXMLElement namespaces: namespaces</body></methods><methods><class-id>WebServices.XMLElementAssist</class-id> <category>initialize</category><body package="XMLObjectSupport">initialize	namespaces := Dictionary new: 10</body></methods><methods><class-id>WebServices.XMLElementAssist</class-id> <category>accessing</category><body package="XMLObjectSupport">imports	^imports isNil		ifTrue: [ imports := OrderedCollection new: 5 ]		ifFalse: [ imports ]</body><body package="XMLObjectSupport">namespaces	^namespaces</body><body package="XMLObjectSupport">namespaces: aDictionary	namespaces := aDictionary</body><body package="XMLObjectSupport">root	^root</body><body package="XMLObjectSupport">root: anElement	root := anElement</body></methods><methods><class-id>WebServices.XMLElementAssist</class-id> <category>documentation</category><body package="XMLObjectSupport">addAnnotation: aString to: anXMLElement		| annot |	aString notNil		ifTrue: 			[annot := self  createElement: 'annotation'.			self addDocumentation: aString to: annot.			self add: annot to: anXMLElement]</body><body package="XMLObjectSupport">addDocumentation: aString to: anXMLElement		| doc |	aString notNil		ifTrue: 			[doc := self  createElement: 'documentation'.			self add: doc to: anXMLElement.			self add: (self createText: aString)  to: doc]</body></methods><methods><class-id>WebServices.XMLElementAssist class</class-id> <category>instance creation</category><body package="XMLObjectSupport">new	^super new initialize</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy</class-id> <category>attributes</category><body package="XMLObjectSupport">addAspectAttribute: aString to: anXMLElement	self elementAssist addAttribute: 'aspect' value: aString to: anXMLElement.</body><body package="XMLObjectSupport">addAspectAttributeTo: anXMLElement	| attr value  aspect |	(attr := anXMLElement attributeNamed: 'name' ifAbsent: [ nil]) == nil		ifTrue: [ (attr := anXMLElement attributeNamed: 'tag' ifAbsent: [ nil]) == nil				ifTrue: [ attr := anXMLElement attributeNamed: 'ref' ifAbsent: [ nil]]].	attr == nil ifTrue: [ ^self error: (#CanNotSetAspect &lt;&lt; #webservices &gt;&gt; 'Can not set aspect')].	value := attr value.	(value anySatisfy: [ :c | c = $:] )		ifTrue: [value := value copyFrom: ( value indexOf: $: ) + 1 to: value size].	aspect :=  self createAspectValue: value.	aspect ~= value asSymbol		ifTrue: [ self elementAssist 					addAttribute: 'aspect' 					value: aspect					to: anXMLElement ].</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy</class-id> <category>services</category><body package="XMLObjectSupport">createSmalltalkClassNameFrom: aString inNamespace: nsString	^self class createSmalltalkClassNameFrom: aString inNamespace: nsString</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy</class-id> <category>complex types</category><body package="XMLObjectSupport">newClassName:  aString    | versionNumber newName |    (self classes includes: aString) ifFalse: [ self classes add: aString. ^aString].    versionNumber := 1.    [self classes includes: (newName := aString, '_v', versionNumber printString)]        whileTrue: [versionNumber := versionNumber + 1].    self classes add: newName.    ^newName</body><body package="XMLObjectSupport">newComplexType: aString inNamespace: nsString	| el name |	el := self elementAssist createElement: 'object' attrName: aString. 	name := (nsString == nil		ifTrue: [ aString]		ifFalse: [ name := self  createSmalltalkClassNameFrom: aString inNamespace: nsString ]).	name := self newClassName: name.	self elementAssist addAttribute: 'smalltalkClass' value: name.	^el</body><body package="XMLObjectSupport">newComplexTypeFrom: anElement inNamespace: nsString	| el name className parent |	parent := anElement parent.	name := self elemName: anElement.	className := name.	[parent isNil or: [parent tag type = 'schema' ] ]		whileFalse: [(parent attributeNamed: 'name'  ifAbsent: [ nil ]) ifNotNil: [ :nm | className :=   nm value, '_', className  ].					parent := parent parent. ].	el := self elementAssist createElement: 'object' attrName: name. 	name := (nsString 		ifNil: [ className ]		ifNotNil: [ self createSmalltalkClassNameFrom: className inNamespace: nsString ]).	name := self newClassName: name.	self elementAssist addAttribute: 'smalltalkClass' value: name.	^el</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy</class-id> <category>accessing</category><body package="XMLObjectSupport">classes	^classes ifNil: [classes := Set new]</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy</class-id> <category>testing</category><body package="XMLObjectSupport">isDefaultPolicy	^false</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy</class-id> <category>private</category><body package="XMLObjectSupport">createAspectValue: aString	|  value stream ind  ch vx aspect |	value := aString.	stream := (String new: value size) writeStream.	self class removeAspectUnderscores		ifTrue: 			[ ind := 1.			"Remove leading $_ "			[(value at: ind) = $_ ] 				whileTrue: 					[ind = value size ifTrue: [^''].					ind := ind + 1].			value := value copyFrom: ind to: value size.			1 to: value size do:				[ :i |				vx := value at: i.				vx ~= $_					ifTrue:						[ i = 1							ifTrue: [ stream nextPut: vx asLowercase]							ifFalse: [ stream nextPut: vx]]]]		ifFalse:			[1 to: value size do: 				[ :i |				ch := value at: i.				i = 1 					ifTrue: [ stream nextPut: ch asLowercase]					ifFalse: 						[ ch ~= $. ifTrue: [ stream nextPut: ch]]]].	aspect := stream contents.	[		(Object canUnderstand:  aspect asSymbol) 			and: [(self class useExistingAspectNames includes: aspect ) not]			] whileTrue: [aspect := aspect, '_' ].			^SystemUtils validateInstanceVariableName: aspect		confirm: [:msg :nm | true ]		warn: [:msg | ]</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy class</class-id> <category>defaults</category><body package="XMLObjectSupport">defaultClassName	^#WebServicesClass</body><body package="XMLObjectSupport">defaultClassNamespace	^DefaultClassNamespace isNil		ifTrue: [DefaultClassNamespace := self defaultClassNamespaceValue ]		ifFalse: [ DefaultClassNamespace ]</body><body package="XMLObjectSupport">defaultClassNamespace: aString	DefaultClassNamespace := aString</body><body package="XMLObjectSupport">removeAspectUnderscores	^RemoveAspectUnderscores 		ifNil: [ RemoveAspectUnderscores := self removeAspectUnderscoresValue ]</body><body package="XMLObjectSupport">removeAspectUnderscores: aBoolean	RemoveAspectUnderscores := aBoolean</body><body package="XMLObjectSupport">useExistingAspectNames"The method retuns list of names that will be used for aspects even if they have a conflict with existing methods( self useExistingAspectNames )"	^self useExistingAspectNamesHolder value</body><body package="XMLObjectSupport">useExistingAspectNames: anOrderedCollection"The method allows to set a list of names that will be used for aspects even if they have a conflict with existing methods.(self useExistingAspectNames:  (OrderedCollection with: 'size'))"	self useExistingAspectNamesHolder value:  (anOrderedCollection ifNil: [OrderedCollection new])</body><body package="XMLObjectSupport">useExistingAspectNamesHolder	^useExistingAspectNamesHolder ifNil: [useExistingAspectNamesHolder := self defaultUseExistingAspectNamesValue asValue ]</body><body package="XMLObjectSupport">useExistingClassName	" self useExistingClassName "	^UseExistingClassName ifNil: [UseExistingClassName := self useExistingClassNameValue].</body><body package="XMLObjectSupport">useExistingClassName: aBoolean	UseExistingClassName := aBoolean</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy class</class-id> <category>default values</category><body package="XMLObjectSupport">defaultClassNamespaceValue	^'WSDefault'</body><body package="XMLObjectSupport">defaultUseExistingAspectNamesValue	^OrderedCollection new</body><body package="XMLObjectSupport">removeAspectUnderscoresValue 	^false</body><body package="XMLObjectSupport">useExistingClassNameValue	^true</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy class</class-id> <category>private</category><body package="XMLObjectSupport">setRemoveAspectUnderscores	^self removeAspectUnderscores  printString asSymbol</body><body package="XMLObjectSupport">setRemoveAspectUnderscores: aSymbol	^self removeAspectUnderscores: (aSymbol = #true )</body><body package="XMLObjectSupport">setRemoveAspectUnderscoresValue 	^self removeAspectUnderscoresValue printString asSymbol</body><body package="XMLObjectSupport">setUseExistingClassName	^self useExistingClassName  printString asSymbol</body><body package="XMLObjectSupport">setUseExistingClassName: aSymbol	self useExistingClassName: (aSymbol = #true )</body><body package="XMLObjectSupport">setUseExistingClassNameValue	^self useExistingClassNameValue printString asSymbol</body></methods><methods><class-id>WebServices.XMLObjectBindingPolicy class</class-id> <category>utilities</category><body package="XMLObjectSupport">createSmalltalkClassNameFrom: aString inNamespace: nsString" self createSmalltalkClassNameFrom: 'Event'  inNamespace: 'MyNS'  "" self createSmalltalkClassNameFrom: 'MyEvent'  inNamespace: 'UI'  "	^self createSmalltalkClassNameFrom: aString inNamespace: nsString useExistingClassName: self useExistingClassName</body><body package="XMLObjectSupport">createSmalltalkClassNameFrom: aString inNamespace: nsString useExistingClassName: aBoolean" self createSmalltalkClassNameFrom: 'Event'  inNamespace: 'MyNS'  "" self createSmalltalkClassNameFrom: 'MyEvent'  inNamespace: 'UI'  "	| nm |	nm := SystemUtils 				validateClassName: aString				confirm: [:msg :newname | nm := newname. true ]				warn: [:msg | nm := self defaultClassName ].		aBoolean ifTrue: [		[(nsString asQualifiedReference isDefined 			and: [ (nsString, '.', nm)  asSymbol asQualifiedReference isDefined])				ifTrue: [^nm ].			] on:Error do: [ :ex | nil]].	^self createUniqueClassNameFrom: nm inNamespace: nsString.</body><body package="XMLObjectSupport">createUniqueClassNameFrom: aString inNamespace: nsString	| clName nm |	"Check if there is no such a class"	nm := aString.	clName := (nsString notNil 				ifTrue: [clName := nsString, '.', nm]				ifFalse: [ nm]).	[(clName asSymbol asQualifiedReference isDefined not		and: [('Smalltalk.', nm) asSymbol asQualifiedReference isDefined not ]) 			ifTrue: [^aString ].	] on: DuplicateBindingsError do: [ :ex | ex return ].	"We can not use the existing class let's create a new one"	[ nm asQualifiedReference isDefined ]		whileTrue: 			[ nm := (nm last isDigit 				ifTrue: [(nm copyFrom: 1 to: nm size -1), (nm  last digitValue + 1 ) printString ]				ifFalse: [ nm, '0']).].	^nm</body></methods><methods><class-id>WebServices.DecodedIntegerOutOfRange</class-id> <category>private - actions</category><body package="XMLObjectSupport">defaultResumeValue		^decodedInteger</body></methods><methods><class-id>WebServices.DecodedIntegerOutOfRange</class-id> <category>accessing</category><body package="XMLObjectSupport">decodedInteger	^decodedInteger</body><body package="XMLObjectSupport">decodedInteger: anInteger	decodedInteger := anInteger</body></methods><methods><class-id>WebServices.RequiresRegex</class-id> <category>constants</category><body package="XMLObjectSupport">defaultResumeValue	"This exception is raised in the context of XML restriction validation.	By default answer false to indicate that the validation failed."	^false</body></methods><methods><class-id>XML.Attribute</class-id> <category>soap-extensions</category><body package="XMLObjectSupport">namespaceAtQualifier: qString	^self parent namespaceAtQualifier: qString</body><body package="XMLObjectSupport">namespaceAtQualifier: qString ifAbsent: aBlock	^self parent namespaceAtQualifier: qString ifAbsent: aBlock</body><body package="XMLObjectSupport">realElements	^#()</body><body package="XMLObjectSupport">targetNamespace	^self parent targetNamespace</body></methods><methods><class-id>XML.Text</class-id> <category>soap-extensions</category><body package="XMLObjectSupport">realElements	^#()</body><body package="XMLObjectSupport">targetNamespace	^self parent targetNamespace</body></methods><methods><class-id>XML.Text</class-id> <category>printing</category><body package="XMLObjectSupport">wsPrintOn: aStream depth: indent	self printOn: aStream depth: indent</body></methods><methods><class-id>XML.Document class</class-id> <category>ws-utilities</category><body package="XMLObjectSupport">saveDocument: aDocument intoFile: fileName	| fStream |	fStream := (fileName asFilename withEncoding: #UTF_8) writeStream lineEndTransparent.		[fStream nextPutAll:  '&lt;?xml version="1.0" encoding="utf-8" ?&gt;'.	aDocument wsPrintOn: fStream depth: 0]			ensure: [fStream close]</body><body package="XMLObjectSupport">saveDocument: anElement intoMethod: methName class: aClass withComment: commentString 	self 		saveIntoMethod: methName		class: aClass		comment: commentString		do: [:stream | anElement wsPrintOn: stream depth: 0]</body><body package="XMLObjectSupport">saveIntoMethod: methName class: aClass comment: commentString do: aBlock 	"..save the XML schema in class method "	| methodStream xmlStream |	xmlStream := (String new: 1024) writeStream.	"Use a temporary buffer; we do not know what's inside. 	E.g. a comment node having text with single quotes will mess up the final source code..."	aBlock value: xmlStream.	methodStream := (String new: xmlStream size + methName size + commentString size + 10) writeStream.	methodStream		nextPutAll: methName;		cr.	commentString notNil 		ifTrue: 			[methodStream				tab;				nextPut: $";				nextPutAll: commentString;				nextPut: $";				cr].	methodStream nextPut: $^.	methodStream print: xmlStream contents.	aClass class compile: methodStream contents classified: 'wsdl schema'</body></methods><methods><class-id>XML.Document</class-id> <category>printing</category><body package="XMLObjectSupport">wsPrintOn: aStream depth: indent	self root wsPrintOn: aStream depth: indent</body></methods><methods><class-id>XML.Element</class-id> <category>modifying</category><body package="XMLObjectSupport">addFirstNode: aNode	aNode parent: self.	elements == nil		ifTrue: [elements := OrderedCollection new: 5]		ifFalse: [elements class == Array			ifTrue: [elements := elements asOrderedCollection]].	elements addFirst: aNode</body></methods><methods><class-id>XML.Element</class-id> <category>namespaces</category><body package="XMLObjectSupport">allNamespaces	| coll current |	coll := namespaces isNil			ifTrue: [Dictionary new]			ifFalse: [namespaces copy].	current := self.	[current parent notNil and: [(current := current parent) isElement]]		whileTrue: 			[current namespaces 				keysAndValuesDo: [ :q :ns | coll at: q ifAbsentPut: [ns]]].	^coll</body></methods><methods><class-id>XML.Element</class-id> <category>accessing</category><body package="XMLObjectSupport">attributeNamed: attributeName ifAbsent: aBlock	^self attributes		detect: [:a | a tag isLike: attributeName]		ifNone: aBlock</body></methods><methods><class-id>XML.Element</class-id> <category>soap-extensions</category><body package="XMLObjectSupport">namespace" Answer element's namespace which is tag's namespace or, if this namespace is empty, the default namespace (namespace with qualifier '') "	| current value |	current := self.	[value := (current tag namespace isNil or: [current tag namespace isEmpty])					ifTrue: [current namespaceAt: '']					ifFalse: [current tag namespace].	(value isNil or: [value isEmpty]) and: 		[(current := current parent) notNil and: [current isElement]]] whileTrue.	^value</body></methods><methods><class-id>XML.Element</class-id> <category>namespaces</category><body package="XMLObjectSupport">namespaceAt: q put: ns	namespaces isNil		ifTrue: [namespaces := Dictionary new: 5].	namespaces at: q put: ns</body></methods><methods><class-id>XML.Element</class-id> <category>soap-extensions</category><body package="XMLObjectSupport">namespaceAtQualifier: qString" Answer namespace for the specified qualifier "	^self 		namespaceAtQualifier: qString 		ifAbsent: 			[ self 				error: ((#CannotFindNamespaceForQualifier &lt;&lt; #webservices &gt;&gt; 'Can not find namespace for: &lt;1s&gt;')				expandMacrosWith: qString)]</body><body package="XMLObjectSupport">namespaceAtQualifier: qString ifAbsent: aBlock" Answer namespace for the specified qualifier "		^self 		namespaces at: qString		ifAbsent:  			[ (self parent notNil and: [ self parent isElement])				ifTrue: [ self parent namespaceAtQualifier: qString ifAbsent: aBlock]					ifFalse: [ aBlock value ]]</body></methods><methods><class-id>XML.Element</class-id> <category>namespaces</category><body package="XMLObjectSupport">namespaces	^namespaces isNil		ifTrue: [Dictionary new: 5]		ifFalse: [namespaces]</body></methods><methods><class-id>XML.Element</class-id> <category>printing</category><body package="XMLObjectSupport">printCanonicalOn: aStream	| az |	aStream nextPut: $&lt;.	aStream nextPutAll: tag asString.	attributes == nil		ifFalse:			[az := attributes asSortedCollection: [:x :y | x key &lt; y key].			az do: [:at |				aStream space.				at printCanonicalOn: aStream]].	self printNamespacesOn: aStream.	elements == nil		ifTrue: [aStream nextPutAll: '/&gt;']		ifFalse: 			[aStream nextPut: $&gt;.			elements do: [:e | e printCanonicalOn: aStream].			aStream nextPutAll: '&lt;/', tag asString, '&gt;' ]</body><body package="XMLObjectSupport">printNamespacesOn: aStream	namespaces == nil		ifFalse: 			[namespaces keysAndValuesDo: [ :q :ns |				aStream 					space; 					nextPutAll: 'xmlns'.					q isEmpty not ifTrue: [ aStream nextPutAll: ':', q].				aStream					nextPutAll: '="'; 					nextPutAll: ns; 					nextPut: $"]].</body></methods><methods><class-id>XML.Element</class-id> <category>soap-extensions</category><body package="XMLObjectSupport">targetNamespace" Answer element's target namespace. Target namspace is namespace of all unqualified  NCNAMES. It is declared with attribute targetNamespace. Usually elements also associate prefix 'tns' with this namespace so QNAMEs can be bound to it "	|current value |	current := self.	[value := current valueOfAttribute: 'targetNamespace' ifAbsent: [nil].	value isNil and: 		[(current := current parent) notNil and: [current isElement]]] whileTrue.	^value</body></methods><methods><class-id>XML.Element</class-id> <category>accessing</category><body package="XMLObjectSupport">userDataOfAttribute: attributeName	^(self attributes		detect: [:a | a tag isLike: attributeName]		ifNone: [^nil]) userData</body></methods><methods><class-id>XML.Element</class-id> <category>printing</category><body package="XMLObjectSupport">wsPrintHTMLOn: aStream	| elem az |	aStream nextPut: $&lt;.	aStream nextPutAll: tag asString.	attributes == nil		ifFalse:			[az := attributes asSortedCollection: [:x :y | x key &lt; y key].			az do: [:at |				aStream space.				at printOn: aStream]].	namespaces == nil			ifFalse: 				[namespaces keysAndValuesDo: [ :q :ns |				q = '' 					ifFalse: 						[aStream 							space; 							nextPutAll: 'xmlns:'; 							nextPutAll: q;							nextPutAll: '="'; 							nextPutAll: ns; 							nextPut: $"]]].	aStream nextPut: $&gt;.	elem := elements == nil		ifTrue: [#()]		ifFalse: [elements" reject: [:str | str isBlankText]"].	self isHTMLBlock ifTrue: [aStream cr].	elem do: [:e |		e printHTMLOn: aStream.		self isHTMLBlock ifTrue: [aStream cr]].	aStream nextPutAll: '&lt;/', tag asString, '&gt;'</body><body package="XMLObjectSupport">wsPrintOn: aStream depth: indent	| elem |	aStream nextPut: $&lt;.	aStream nextPutAll: tag asString.	attributes == nil		ifFalse: [1 to: attributes size do: 			[:i | | a |			a := attributes at: i.			aStream space.			a printOn: aStream]].	self printNamespacesOn: aStream.	elements == nil		ifTrue: [aStream nextPutAll: '/&gt;']		ifFalse:			[aStream nextPut: $&gt;.			elem := elements reject: [:str | str isText and: [str isStripped or: [str isBlankText]]].			(elem size &lt;= 1 and: [(elem contains: [:n | n isText not]) not])				ifTrue: [elem do: [:e |							e wsPrintOn: aStream depth: indent+1]]				ifFalse:					[1 to: elem size do: [:i | | e |						e := elem at: i.						aStream crtab: indent+1.						e isString 							ifTrue: [aStream nextPutAll: e]							ifFalse: [e wsPrintOn: aStream depth: indent+1]].					aStream crtab: indent].			aStream nextPutAll: '&lt;/', tag asString, '&gt;']</body></methods><methods><class-id>XML.Comment</class-id> <category>printing</category><body package="XMLObjectSupport">wsPrintOn: aStream depth: indent	self printOn: aStream depth: indent</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="XMLObjectSupport">isStruct	^false</body></methods><methods><class-id>XML.Node</class-id> <category>soap-extensions</category><body package="XMLObjectSupport">namespaceAtQualifier: qString	^nil</body><body package="XMLObjectSupport">targetNamespace" Answer element's target namespace. Target namspace is namespace of all unqualified  NCNAMES. It is declared with attribute targetNamespace. Usually elements also associate prefix 'tns' with this namespace so QNAMEs can be bound to it "	^nil</body></methods><methods><class-id>XML.NodeTag class</class-id> <category>instance creation</category><body package="XMLObjectSupport">qualifier: q ns: ns type: typeStr	^self new		qualifier: q ns: ns type: typeStr;		yourself</body></methods><methods><class-id>XML.NodeTag</class-id> <category>initialize</category><body package="XMLObjectSupport">resetNamespaceTo: aString	namespace := aString</body><body package="XMLObjectSupport">resetQualifierTo: aString	qualifier := aString</body><body package="XMLObjectSupport">resetTypeTo: aString	type := aString</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="XMLObjectSupport">webServicesPage	&lt;settingsPage: #(webservices)&gt;	^ModularSettingsPage new		label: #WebServices &lt;&lt; #webservices &gt;&gt; 'Web Services';		icon: (ListIconLibrary visualFor: #web);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(webservices))</body><body package="XMLObjectSupport">webServicesXMLObjectMappingPage	&lt;settingsPage: #(webservices xmlObjectMapping)&gt;	^ModularSettingsPage new		label: #XMLObjectMapping &lt;&lt; #webservices &gt;&gt; 'XMLSchema Mapping';		icon: (ListIconLibrary visualFor: #web);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(webservices xmlObjectMapping))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws-classbuilder</category><body package="XMLObjectSupport">ws5UseExistingClassNames	&lt;setting: #(webservices xmlObjectMapping useExistingClassNames)&gt;	^((EnumerationSetting 		choices: #(#true #false)		labels: (				Array 					with: (#UseExistingName &lt;&lt; #webservices &gt;&gt; 'Use the existing class name') 					with: (#NotUseExistingNames &lt;&lt; #webservices &gt;&gt; 'Create a new unique class name')))	on: WebServices.XMLObjectBindingPolicy aspect: #setUseExistingClassName)		label: #UsingExistingClassName &lt;&lt; #webservices &gt;&gt; 'If the class name to be created already exists:';		default: WebServices.XMLObjectBindingPolicy setUseExistingClassNameValue;		helpText: #UseExistingNamesHelpText &lt;&lt; #dialogs &gt;&gt; 'Depending on this setting, the tool does the following:- If "Use the existing class name" is selected, then if a class with this name is already in the system, the class name is not generated and the existing class name is used for the binding. This is the default option.- If "Create a new unique class name" is selected, new class names are always generated in the namespace where the classes are defined.Unique names are created by appending an integer to the class name. For example, if the specified namespace already has the class Document and the XML attribute is name=Document, then the binding object name will be set to Document1.'</body><body package="XMLObjectSupport">ws6RemoveAspectUnderscores	&lt;setting: #(webservices xmlObjectMapping removeAspectUnderscores)&gt;	^((EnumerationSetting 		choices: #(#false #true)		labels: (				Array 					with: (#NotChangeAccessors &lt;&lt; #webservices &gt;&gt; 'Use unchanged schema name')					with: (#RemoveUnderscoresInAccessors &lt;&lt; #webservices &gt;&gt; 'Convert underscores')))	on: WebServices.XMLObjectBindingPolicy aspect: #setRemoveAspectUnderscores)		label: #ClassAccessorHasUnderscores &lt;&lt; #webservices &gt;&gt; 'If a schema element name has underscores:';		default: WebServices.XMLObjectBindingPolicy setRemoveAspectUnderscoresValue;		helpText: #RemoveAspectUnderscoresHelpText &lt;&lt; #dialogs &gt;&gt; 'Depending on this setting, the tool does the following:- If "Use unchanged schema name" is selected, then if a schema complex type has an element name with underscores this name will be mapped to class accessors as it is. This is the default option.For example: the element: &lt;element name="__customer_name"..&gt; will be mapped to #__customer_name/#__customer_name: accessors.- If "Remove underscores" is selected, then if a schema complex type has an element name with underscores this name will be mapped to  class accessors without underscores. For example: the element: &lt;element name="__customer_name"..&gt; will be mapped to #customerName/#customerName: accessors.'</body><body package="XMLObjectSupport">ws7UseExistingAspectNames	&lt;settingsPage: #(webservices xmlObjectMapping useExistingAspectNames)&gt;	^(SequenceSettingPage new)		label: #x2oUseExistingAspectNames &lt;&lt; #labels &gt;&gt; 'Use existing aspect names:';		icon: (ListIconLibrary visualFor: #net);			listHolder: WebServices.XMLObjectBindingPolicy useExistingAspectNamesHolder 			displayBlock: [ :value | value  ]  			acceptBlock: [ :value |  value ];		helpText: #x2oUseExistingAspectNamesText &lt;&lt; #net &gt;&gt; 'Specifies the list of names that won''t be changed even if the object has already have the same methods. For example: The aspect from the element named "size" will be created as "size_" since Object has #size method. To avoid creating aspects with underscore add them to this list';		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Node</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent flags userData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Document</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root nodes dtd ids </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Text</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text stripped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>NodeTag</name><environment>XML</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace type qualifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Attribute</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Struct</name><environment>Protocols</environment><super>Protocols.ProtoObject</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>Comment</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>