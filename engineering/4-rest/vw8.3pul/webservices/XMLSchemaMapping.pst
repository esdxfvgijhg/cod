<?xml version="1.0"?><st-source><!-- Name: XMLSchemaMappingNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: Contains classes that help to create XML to Smalltalk binding specification.The XMLTypesParser creates default or object binding based on XML schema elements. The default binding maps all XML elements with complex contents in  to WebServices.Struct class, the object binding maps them to smalltalk classes. For more information see "XML to Object Mapping" chapter from WebServices documentation.DbIdentifier: bear73DbTrace: 493902DbUsername: tkoganDbVersion: 8.3 - 0DevelopmentPrerequisites: #(#(#any 'XMLObjectSupport' '') #(#any 'XPath' ''))PackageName: XMLSchemaMappingParcel: #('XMLSchemaMapping')ParcelName: XMLSchemaMappingPrerequisiteDescriptions: #(#(#name 'XMLObjectSupport') #(#name 'XPath' #componentType #package))PrerequisiteParcels: #(#('XMLObjectSupport' '') #('XPath' ''))PrintStringCache: (8.3 - 0,tkogan)Version: 8.3 - 0Date: 2:31:37 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:37 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NodeHandler</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.NodeHandler</class-id><body>NodeHandler represents XML elements registry and provide handlers for the XMLTypesParser.Instance Variables:	element	&lt;XML.Element&gt;	 instance of XML.ElementShared Variables:	Registry &lt;Dictionary&gt; holds all supported handlers to process XML elements and attributes</body></comment><class><name>AttributeGroupHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.AttributeGroupHandler</class-id><body>Accepts the XML element with &lt;attributeGroup&gt; node tag</body></comment><class><name>ImportHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.ImportHandler</class-id><body>ImportHandler accepts the XML ellement with &lt;import&gt; node tag</body></comment><class><name>AnyHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.AnyHandler</class-id><body>AnyHandler accepts the XML element with &lt;any&gt; node tag</body></comment><class><name>SimpleTypeTotalDigitsHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeTotalDigitsHandler</class-id><body>SimpleTypeTotalDigitsHandler accepts the XML element with &lt;totalDigits&gt; node tag.</body></comment><class><name>AllHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.AllHandler</class-id><body>The handler accepts the XML element with &lt;all&gt; node tag</body></comment><class><name>XMLTypesParser</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structList prefix xmlToSmalltalkBinding bindingPolicy baseURI simpleTypes schemaBindings schemaElements imports isImported useSequenceMapping namespaceMap needToResolveList </inst-vars><class-inst-vars>useSequenceMapping loggingBlock defaultXMLSchemaQualifier </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.XMLTypesParser</class-id><body>XMLTypesParser parses the WSDL schema user defined data types and creates XML to object binding specification. The binding specification can be created in two forms as:* Object binding  - the XML complex types are mapped into Smalltalk objects* Default binding - the XML complex types are mapped to StructAll XML to object bindings created by the XMLTypesParser instance will be added to the #schemaBindings document.Instance Variables	structList	&lt;List&gt; Collection of: &lt;struct&gt; X2O mapping for complex types	prefix	&lt;String&gt; prefix for data types defined in "http://www.w3.org/2001/XMLSchema"	xmlToSmalltalkBinding	&lt;XML.Element&gt; current &lt;xmlToSmalltalkBinding&gt; element	bindingPolicy	&lt;XMLBindingPolicy&gt; depending on policy creates default (to dictionary) or object binding.	namespaceMap	&lt;Dictionary&gt;  XML schema target namespaces mapped to Smalltalk namespaces, where the key: schema target namespace, the value: Smalltalk namespace to create and resolve objects created from the schema complex types	baseURI	&lt;URI&gt; the schema url	simpleTypes	&lt;Dictionary&gt; simple types dictionary: key: name type: XML.Element	schemaBindings	&lt;XML.Document&gt; the schema bindings document with the root node: &lt;schemaBindings&gt; .	schemaElements	&lt;XML.Element&gt; &lt;schema&gt; element nodes	imports	&lt;Dictionary&gt; key is an import element url and value is an XML schema element if this import has not been processed or the symbol (#done) if X2O binding has been created for this url.	isImported	&lt;Boolean&gt; if true the parser uses #addFirst to add this x2o binding to schema bindings. It will help to reduce a number of unresolved references while loading the schema bindings	useSequenceMapping	&lt;Boolean&gt; if the option is set to true the parser maps an XML complex type with one unbounded element to &lt;sequence_of&gt; and serialize XML data in to Smalltalk collection. If the option is false (default) the same complex type will be mapped to a Smalltalk class with one inst. var. that will be a collection.Class Instance Variables	useSequenceMapping	&lt;Boolean&gt; if the option is set to true a complex type with the only element and maxOccurs &gt; 1 will be mapped to &lt;sequence_of&gt;	loggingBlock	&lt;Boolean&gt; print mapping log	defaultXMLSchemaQualifier	&lt;String&gt; by default is set to 'xsd'Class Variables	useSequenceMapping &lt;Boolean&gt; specifies fefault for the #useSequenceMapping option	loggingBlock &lt;Block&gt; log output which is Transcript by default	defaultXMLSchemaQualifier &lt;String&gt;  XML Schema namespace qualifier, by default 'xsd' string</body></comment><class><name>SimpleTypeMinInclusiveHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeMinInclusiveHandler</class-id><body>SimpleTypeMinInclusiveHandler accepts the XML element with &lt;minInclusive&gt; node tag.</body></comment><class><name>ComplexTypeHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.ComplexTypeHandler</class-id><body>ComplexTypeHandler accepts the XML element with &lt;complexType&gt; node tag</body></comment><class><name>SimpleTypeMaxLengthHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeMaxLengthHandler</class-id><body>SimpleTypeMaxLengthHandler accepts the XML element with &lt;maxLength&gt; node tag.</body></comment><class><name>SimpleTypeFractionDigitsHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeFractionDigitsHandler</class-id><body>SimpleTypeFractionDigitsHandler accepts the XML element with &lt;fractionDigits&gt; node tag.</body></comment><class><name>SimpleTypeWhiteSpaceHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeWhiteSpaceHandler</class-id><body>SimpleTypeWhiteSpaceHandler accepts the XML element with &lt;whiteSpace&gt; node tag.</body></comment><class><name>UnionHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.UnionHandler</class-id><body>UnionHandler creates mapping for XML &lt;union&gt; type</body></comment><class><name>SimpleTypeLengthHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeLengthHandler</class-id><body>SimpleTypeLengthHandler accepts the XML element with &lt;length&gt; node tag</body></comment><class><name>ComplexContentHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.ComplexContentHandler</class-id><body>ComplexContentHandler accepts the XML element with &lt;complexContent&gt; node tag</body></comment><class><name>XMLTypesParserExc</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.XMLTypesParserExc</class-id><body>XMLTypesParserExc is raised while creating XML to Object binding specification from an XML schema.</body></comment><class><name>MappingDerivationToStructs</name><environment>WebServices</environment><super>WebServices.XMLTypesParserExc</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.MappingDerivationToStructs</class-id><body>Complex types with derivation or abstract types cause marshaling ambiguities when mapped to Structs (as opposed to Objects). An instance of Struct cannot unambiguously identify its corresponding derived type, thus marshaling can pick the wrong type. This exception is a proceedable warning.</body></comment><class><name>UnresolvedImportLocation</name><environment>WebServices</environment><super>WebServices.XMLTypesParserExc</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.UnresolvedImportLocation</class-id><body>UnresolvedImportLocation will be raised if &lt;include&gt; or &lt;import&gt; element includes partial URI</body></comment><class><name>AttributeHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.AttributeHandler</class-id><body>AttributeHandler accepts the XML element with &lt;attribute&gt; node tag</body></comment><class><name>SimpleTypeMinLengthHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeMinLengthHandler</class-id><body>SimpleTypeMinLengthHandler accepts the XML element with &lt;minLength&gt; node tag.</body></comment><class><name>AnyAttributeHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.AnyAttributeHandler</class-id><body>The handler accepts the XML element with &lt;anyAttribute&gt; node tag</body></comment><class><name>BindingMergeConflict</name><environment>WebServices</environment><super>WebServices.XMLTypesParserExc</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schema existingBinding parser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.BindingMergeConflict</class-id><body>This exception is raised if the parser encounters an XML schema with a targetNamespace that is the same as target namespace of an already existing XML to Object binding. Most likely this is the case of incremental imports. If there is no difference in attributes between the existing binding and the schema, the XMLTypesParser tries to merge schema attributes into the binding and continue with the existing binding. If there is a difference in attributes this exception is raised instead. The exception is resumable. The expected resume value should be an updated XML to object binding element and the parser proceeds building the binding specification. If the exception is resumed with nil, the parser will skip the imported schema element altogether and continue parsing the rest of the specification. The default resume value is the existing binding.Instance Variables	schema	&lt;Element&gt; an XML schema element with the same targetNamespace as in existingBinding	existingBinding	&lt;Element)  - existing xml to object binding	parser	&lt;XMLTypesParser&gt; current parserExample:Default resume action returns the existing binding element which will be used as the root element for new binding elements created from the schema.The expectation is that the handler will merge the attributes from the schema element into to the existing binding element.	[ 	WsdlSchemaLoader defaultReadFrom:  self resource serviceWsdl.	] on: BindingMergeConflict	do: [ :ex | 		ex schema attributes do: [ :attribute | "merge attributes into the existingBinding" ].		"Return existingBinding"		ex resume ].</body></comment><class><name>SequenceHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SequenceHandler</class-id><body>SequenceHandler accepts the XML &lt;sequence&gt; type</body></comment><class><name>SimpleTypeMaxInclusiveHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeMaxInclusiveHandler</class-id><body>SimpleTypeMaxInclusiveHandler accepts the XML element with &lt;maxInclusive&gt; node tag.</body></comment><class><name>GroupHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.GroupHandler</class-id><body>AttributeGroupHandler  accepts the XML element with &lt;attributeGroup&gt; node tag&lt;attributeGroup  id = ID  name = NCName  ref = QName  {any attributes with non-schema namespace . . .}&gt;  Content: (annotation?, ((attribute | attributeGroup)*, anyAttribute?))&lt;/attributeGroup&gt;</body></comment><class><name>SimpleTypePatternHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypePatternHandler</class-id><body>SimpleTypePatternHandler accepts the XML element with &lt;pattern&gt; node tag.</body></comment><class><name>EnumerationHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.EnumerationHandler</class-id><body>EnumerationHandler accepts the XML ellement with &lt;enumeration&gt; node tag</body></comment><class><name>SimpleContentHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleContentHandler</class-id><body>SimpleContentHandler accepts the XML &lt;simpleContent&gt; type</body></comment><class><name>SimpleTypeHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeHandler</class-id><body>SimpleTypeHandler accepts the XML element with &lt;simpleType&gt; node tag</body></comment><class><name>MappingUnboundedContentToStruct</name><environment>WebServices</environment><super>WebServices.XMLTypesParserExc</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.MappingUnboundedContentToStruct</class-id><body>The exception is raised while mapping complex types with unbounded sequence or group as content to default binding.Mapping the XML complex types with unbounded sequence:&lt;xs:complexType name="CategoryType"&gt;  &lt;xs:sequence maxOccurs="unbounded"&gt;     &lt;xs:element name="count" type="xs:int"/&gt;      &lt;xs:element name="delimiter" type="xs:string"/&gt;  &lt;/xs:sequence&gt;&lt;/xs:complexType&gt;unbounded group:&lt;group name="idGroup"&gt;  	&lt;sequence&gt;		&lt;element name="attr" type="xsd:string"/&gt;		&lt;element name="id" type="xsd:string"/&gt;	&lt;/sequence&gt;&lt;/group&gt;&lt;xs:complexType name="CategoryType"&gt;	&lt;attribute name="name" type="xsd:string"/&gt;	&lt;group minOccurs="0" maxOccurs="unbounded" ref="tns:idGroup"/&gt;&lt;/xs:complexType&gt;are supported only for the object binding where the object is a collection type object. The collection items are instances of Struct with sequence/group elements as keys. The complex type attributes are mapped to the object instance variables. </body></comment><class><name>SimpleTypeMaxExclusiveHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeMaxExclusiveHandler</class-id><body>SimpleTypeMaxExclusiveHandler accepts the XML element with &lt;maxExclusive&gt; node tag.</body></comment><class><name>WSSAXDriver</name><environment>WebServices</environment><super>XML.DOM_SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BindingTool</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.WSSAXDriver</class-id><body>WSSAXDriver represents a specialized type of DOM_SAXDriver processor. The driver creates the XML.Attribute value as an instance of NodeTag. </body></comment><class><name>ElementHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.ElementHandler</class-id><body>ElementHandler accepts the XML ellement with &lt;element&gt; node tag</body></comment><class><name>SimpleTypeMinExclusiveHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.SimpleTypeMinExclusiveHandler</class-id><body>SimpleTypeMinExclusiveHandler accepts the XML element with &lt;minExclusive&gt; node tag.</body></comment><class><name>IncludeHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.IncludeHandler</class-id><body>IncludeHandler accepts the XML ellement with &lt;include&gt; node tag</body></comment><class><name>ChoiceHandler</name><environment>WebServices</environment><super>WebServices.NodeHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLSchemaMapping</package></attributes></class><comment><class-id>WebServices.ChoiceHandler</class-id><body>ChoiceHandler accepts the XML element with &lt;choice&gt; node tag</body></comment><shared-variable><name>Registry</name><environment>WebServices.NodeHandler</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>XMLSchemaMapping</package></attributes></shared-variable><methods><class-id>WebServices.NodeHandler</class-id> <category>accessing</category><body package="XMLSchemaMapping">element	^element</body><body package="XMLSchemaMapping">element: anElement	element := anElement</body></methods><methods><class-id>WebServices.NodeHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: argument" Override by invoking appropriate message on the visitor "</body></methods><methods><class-id>WebServices.NodeHandler class</class-id> <category>class initialization</category><body package="XMLSchemaMapping">initializeRegistry		(Registry := Dictionary new)		at: 'element' put: ElementHandler;		at: 'import' put: ImportHandler;		at: 'include' put: IncludeHandler;		at: 'complexType' put: ComplexTypeHandler;		at: 'group' put: ComplexTypeHandler;		at: 'sequence' put: SequenceHandler;		at: 'all' put: AllHandler;		at: 'choice' put: ChoiceHandler;		at: 'attribute' put: AttributeHandler;		at: 'simpleType' put: SimpleTypeHandler;		at: 'simpleContent' put: SimpleContentHandler;		at: 'complexContent' put: ComplexContentHandler;		at: 'choice' put: ChoiceHandler;		at: 'any' put: AnyHandler;		at: 'anyAttribute' put: AnyAttributeHandler;		at: 'enumeration' put: EnumerationHandler;		at: 'length' put: SimpleTypeLengthHandler;		at: 'minLength' put: SimpleTypeMinLengthHandler;		at: 'maxLength' put: SimpleTypeMaxLengthHandler;		at: 'pattern' put: SimpleTypePatternHandler;		at: 'whiteSpace' put: SimpleTypeWhiteSpaceHandler;		at: 'minExclusive' put: SimpleTypeMinExclusiveHandler;		at: 'maxExclusive' put: SimpleTypeMaxExclusiveHandler;		at: 'minInclusive' put: SimpleTypeMinInclusiveHandler;		at: 'maxInclusive' put: SimpleTypeMaxInclusiveHandler;		at: 'attributeGroup' put: AttributeGroupHandler;		at: 'fractionDigits' put: SimpleTypeFractionDigitsHandler;		at: 'totalDigits' put: SimpleTypeTotalDigitsHandler;		at: 'group' put: GroupHandler;		at: 'union' put: UnionHandler.</body><body package="XMLSchemaMapping">resetRegistry	"self resetRegistry"	Registry := nil</body></methods><methods><class-id>WebServices.NodeHandler class</class-id> <category>accessing</category><body package="XMLSchemaMapping">handlerFor: anElement	| handler |	handler := self registry at: anElement tag type ifAbsent: [ ^nil ].	^handler new		element: anElement;		yourself</body><body package="XMLSchemaMapping">registry	" (self registry) "	Registry isNil ifTrue: [ self initializeRegistry].	^Registry</body></methods><methods><class-id>WebServices.AttributeGroupHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptAttributeGroupNode: self element with: anElement</body></methods><methods><class-id>WebServices.ImportHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptImportNode: self element with: anElement</body></methods><methods><class-id>WebServices.AnyHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptAnyTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeTotalDigitsHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeTotalDigitsNode: self element with: anElement</body></methods><methods><class-id>WebServices.AllHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptAllTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>accessing</category><body package="XMLSchemaMapping">bindingPolicy	^bindingPolicy isNil		ifTrue: [bindingPolicy := XMLDefaultBindingPolicy new]		ifFalse: [bindingPolicy]</body><body package="XMLSchemaMapping">handlerFor: anElement	^NodeHandler handlerFor: anElement</body><body package="XMLSchemaMapping">imports	^imports ifNil: [ imports := Dictionary new].</body><body package="XMLSchemaMapping">imports: aDictionary	imports := aDictionary</body><body package="XMLSchemaMapping">isImported	^isImported ifNil: [ false]</body><body package="XMLSchemaMapping">isImported: aBoolean	isImported := aBoolean</body><body package="XMLSchemaMapping">logging	^self class loggingBlock notNil</body><body package="XMLSchemaMapping">namespace	^self namespaceMap at: '*' ifAbsent: [ XMLObjectBindingPolicy defaultClassNamespace ]</body><body package="XMLSchemaMapping">namespace: aStringOrDictionary	aStringOrDictionary isString 		ifTrue: [self namespaceMap at: '*' put: aStringOrDictionary] 		ifFalse: [namespaceMap := aStringOrDictionary].</body><body package="XMLSchemaMapping">namespaceMap	^namespaceMap ifNil: [namespaceMap := Dictionary new]</body><body package="XMLSchemaMapping">namespaceMap: aDictionary	namespaceMap := aDictionary</body><body package="XMLSchemaMapping">needToResolveList	^needToResolveList ifNil: [ needToResolveList := OrderedCollection new ]</body><body package="XMLSchemaMapping">prefix	prefix isNil		ifTrue: [ prefix := 'xsd'].	^prefix</body><body package="XMLSchemaMapping">prefix: aString	prefix := aString</body><body package="XMLSchemaMapping">schemaBindings	schemaBindings ifNil: [schemaBindings := self createBindingElement ].	^schemaBindings</body><body package="XMLSchemaMapping">schemaBindings: anElement	schemaBindings := anElement</body><body package="XMLSchemaMapping">schemaElements	^schemaElements ifNil: [ schemaElements := OrderedCollection new ]</body><body package="XMLSchemaMapping">schemaElements: aColl	schemaElements := aColl</body><body package="XMLSchemaMapping">simpleTypes	^simpleTypes ifNil: [ simpleTypes := Dictionary new].</body><body package="XMLSchemaMapping">simpleTypes: anObject	simpleTypes := anObject</body><body package="XMLSchemaMapping">structList	^structList isNil		ifTrue: [ structList := OrderedCollection new]		ifFalse: [ structList ]</body><body package="XMLSchemaMapping">useSequenceMapping	^useSequenceMapping ifNil: [useSequenceMapping := self class useSequenceMapping]</body><body package="XMLSchemaMapping">useSequenceMapping: aBoolean	useSequenceMapping := aBoolean</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>tasks</category><body package="XMLSchemaMapping">visit: anElement 	anElement acceptVisit: self with: nil</body><body package="XMLSchemaMapping">visit: anElement with: argument	anElement acceptVisit: self with: argument</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>private</category><body package="XMLSchemaMapping">addArrayAttributesFrom: anElement to: anXMLElement	| attr  elName |	anElement realElements do: 		[ :el | 			el tag type = 'element' 				ifTrue: 					[( elName := self bindingPolicy elemName: el) notNil						ifTrue: [self bindingPolicy addAttribute: 'elementTag'  value:  elName to: anXMLElement].					((attr := el attributeNamed: 'minOccurs' ifAbsent: [ nil]) notNil 						or: [(attr := el attributeNamed: 'maxOccurs' ifAbsent: [ nil]) notNil ])						ifTrue: [self bindingPolicy addAttribute: attr key value: attr value to: anXMLElement]]				ifFalse: [ ^self addArrayAttributesFrom: el to: anXMLElement] ].</body><body package="XMLSchemaMapping">addArrayElement: anElement name: aString	| arrType el attr dimension |	(attr := self findArrayTypeIn: anElement) notNil 		ifTrue: 				["Array type can be specified in two ways: using a type or arrayType attribute.			The type attribute is returned as an instance of NodeTag.			The arrayType is a string -  wsdl:arrayType=string[] "			arrType := attr value isString				ifTrue: 					[dimension := (attr value occurrencesOf: $,) + 1.  					arrType := attr value copyUpTo: $[. 					self processQName: arrType from: attr parent ]				ifFalse: 					[dimension := 1.					attr value]]		ifFalse: 			[^self 				excFor: anElement 				text: ((#CantFindArrayInElement &lt;&lt; #webservices &gt;&gt; 'Can not find array type in the element: &lt;1s&gt;')						expandMacrosWith: anElement simpleDescription)].	el := self bindingPolicy 				newArrayName: aString 				type: (self createNodeFrom: arrType parent: attr parent ) 				dimension: dimension.	xmlToSmalltalkBinding addNode: el.</body><body package="XMLSchemaMapping">addAttribute: anAttribute to: anElement	 anAttribute key qualifier notEmpty 		ifTrue: [ xmlToSmalltalkBinding namespaces at: anAttribute key qualifier ifAbsentPut: [ anAttribute key namespace ]].	self bindingPolicy addAttribute: anAttribute key value: anAttribute value to: anElement</body><body package="XMLSchemaMapping">addAttributesFrom: schemaElement to: bindingElement 	schemaElement attributes 		do: [ :a | 			(a tag type = 'type' or: [ a tag type = 'ref' ])				ifTrue: [self 						addRef: (a userData ifNil: [a value ] ifNotNil: [ :ud | ud ] ) 						to: bindingElement 						parent: a parent. ]				ifFalse: 	[ self addAttribute: a to: bindingElement ]]</body><body package="XMLSchemaMapping">addConstraintFrom: anElement to: rootElement	| elem ref |	elem := (self  realElements: anElement) first.	(ref := self userDataOfAttributeBaseFrom:  elem) ifNil: [^nil].	self bindingPolicy addAttribute: 'constraint' value: elem tag type to: rootElement.	self bindingPolicy 		addAttribute: 'baseType'		value: (self createNodeFrom: ref parent: elem) asString		to: rootElement.</body><body package="XMLSchemaMapping">addImport: importElement 	| url |	importElement attributeNamed: 'schemaLocation' ifAbsent: [ ^nil ].	url := self importURIFrom: importElement.	self log: ( 'Added import element:&lt;n&gt;&lt;1s&gt;&lt;n&gt;at &lt;2s&gt;' expandMacrosWith: importElement printString with: url printString).	self imports at: url  ifAbsentPut: [importElement ].</body><body package="XMLSchemaMapping">addRef: aString to: anXMLElement parent: anElem	self bindingPolicy addRefAttribute: (self createNodeFrom: aString parent: anElem) to: anXMLElement</body><body package="XMLSchemaMapping">addTextTo: anXMLElement ref: aNodeTag 	| el | 	el := self bindingPolicy createElementType: 'text'. 	self bindingPolicy addAttribute: 'name' value: 'value' to: el.		aNodeTag ifNotNil: [ self bindingPolicy addAttribute: 'ref' value: aNodeTag asString to: el].		anXMLElement addNode: el.	^el</body><body package="XMLSchemaMapping">createNodeFrom: value parent: anElement	| node |  	node := value isNil		ifTrue: [ NodeTag qualifier: '' ns: self class defaultUriXsd type: 'anyType' ]		ifFalse: 			[ value isString 				ifTrue: [ self processQName: value from: anElement ]				ifFalse: [ value ]].	node qualifier = 'xml' ifTrue: [node resetNamespaceTo: ''].	node namespace isEmpty ifTrue: [^node].	^NodeTag 		qualifier: (self setQualifierFor: node namespace fromElement: anElement )		ns: node namespace 		type: node type</body><body package="XMLSchemaMapping">createSequenceOfFrom: anXMLElement with: attrName	| node ref implEl attr |  	node := self bindingPolicy newCollectionNamed: attrName.	self bindingPolicy 		addSequenceTo: node 		do: [ :n | 			implEl :=self bindingPolicy createCollectionElementNamed: (self bindingPolicy elemName: anXMLElement).			(attr := anXMLElement attributeNamed: 'minOccurs' ifAbsent: [ nil]) notNil 				ifTrue: [self bindingPolicy addAttribute: attr key value: attr value to: implEl].			(attr := anXMLElement attributeNamed: 'maxOccurs' ifAbsent: [ nil]) notNil				ifTrue: [self bindingPolicy addAttribute: attr key value: attr value to: implEl].			(ref := anXMLElement userDataOfAttribute: 'type') 				ifNil: [ ref := anXMLElement userDataOfAttribute: 'ref' ].			self bindingPolicy addTypeAttribute: (Element tag: (self createNodeFrom: ref parent: anXMLElement )) to: implEl.			n addNode: implEl  ].	^node</body><body package="XMLSchemaMapping">excFor: anObject text: aString	^XMLTypesParserExc new			messageText: ((#CreatingXMLToObjectBindingError  &lt;&lt; #webservices &gt;&gt; 'Creating XML to object binding error: &lt;1s&gt;')			expandMacrosWith: aString);			parameter: anObject;			raiseRequest</body><body package="XMLSchemaMapping">findArrayTypeIn: anElement	| attr |	anElement realElements do: 		[ :el | 			attr := el attributes detect: [ :at | '*type*' match: at key asString] ifNone: [nil].			attr notNil ifTrue: [ ^attr].			(el realElements notNil and: [ el realElements notEmpty])				ifTrue: 					[ (attr := self findArrayTypeIn: el) notNil ifTrue: [ ^attr]]].	^nil</body><body package="XMLSchemaMapping">importURIFrom: anElement	| location |	location := anElement valueOfAttribute: 'schemaLocation' ifAbsent: [ ^nil ].	^baseURI 		ifNotNil: [baseURI,  location]		ifNil: [location asURI].</body><body package="XMLSchemaMapping">log: aString	self logging ifFalse: [^nil].	self class loggingBlock value: aString</body><body package="XMLSchemaMapping">newQualifier	| q suffix keys |	q := 'ns'. 	suffix := 0.	keys := xmlToSmalltalkBinding namespaces keys.	[(keys detect: [ :k | k = q] ifNone: [ nil]) notNil ]		whileTrue: 			[q := 'ns',  suffix printString.			suffix := suffix + 1 ].		^q</body><body package="XMLSchemaMapping">processQName: value from: anElement 	| q ns val  |  	val := value.	(value indexOf: $:) &gt; 0		ifTrue: 			[q := value copyUpTo: $:.			val := value copyFrom: ( q size + 2) to: value size.			(ns :=  xmlToSmalltalkBinding namespaceAt: q ) isNil				ifTrue: 					[(ns := anElement namespaceAtQualifier: q ifAbsent: [nil] ) isNil 						ifTrue: [^self 									excFor: anElement 									text:  ((#NoSpecifiedNamespace &lt;&lt; #webservices &gt;&gt; 'No specified namespace for:&lt;1s&gt;')													expandMacrosWith: q)]]]		ifFalse: [ns := anElement allNamespaces at: '' ifAbsent: ['']].	^NodeTag qualifier: '' ns: ns type: val</body><body package="XMLSchemaMapping">qualifierForTargetNs	^xmlToSmalltalkBinding qualifierAtNamespace: xmlToSmalltalkBinding targetNamespace</body><body package="XMLSchemaMapping">realElements: anElement	^anElement realElements reject:		[:elem | elem tag namespace = anElement tag namespace and: [elem tag type = 'annotation']].</body><body package="XMLSchemaMapping">resolveSimpleContentNode: anXMLElement ref: aNodeTag	| xp nodes |	"Add &lt;text&gt; if the simple contents is defined as extention/restriction to an XML primitive type:	&lt;xsd:simpleContent&gt;&lt;xsd:extension base=xsd:string&gt;..&lt;/xsd:simpleContent&gt;	"	('http://www.w3.org/*/XMLSchema' match: aNodeTag namespace)		ifTrue: [^self addTextTo: anXMLElement ref: aNodeTag ].				"Add &lt;text&gt; if the simple contents is defined as extention/restriction to a custom primitive type:	 &lt;xs:simpleContent&gt;&lt;xs:extension base=tns:My_SimpleType&gt;... &lt;xs:simpleContent&gt;	where My_SimpleType is defined as:	 &lt;xs:simpleType name=My_SimpleType&gt; "	xp := XPathParser new 				xmlNode: schemaBindings parent; 				parse: 'descendant::simple[attribute::name="', aNodeTag type, '"]' as: #locationPath.	nodes := (xp xpathValueFor: schemaBindings variables: nil) sortedNodes.	nodes notEmpty ifTrue: [ self addTextTo: anXMLElement ref: aNodeTag]</body><body package="XMLSchemaMapping">setQualifierFor: nsString fromElement: anElement	| q |	XMLBuildingPolicy defaultUriXsd = nsString		ifTrue: [	xmlToSmalltalkBinding namespaces at: self class defaultXMLSchemaQualifier ifAbsentPut: [ nsString].				^self class defaultXMLSchemaQualifier].	(xmlToSmalltalkBinding allNamespaces associations detect: [ :assoc | assoc value = nsString] ifNone: [nil]) 		ifNotNil: [ :qx | ^qx key].	q := (anElement allNamespaces associations detect: [ :assoc | assoc value = nsString] ifNone: [self newQualifier-&gt;nil]) key.	(xmlToSmalltalkBinding namespaces at: q ifAbsent: [nil]) ifNotNil: [ q := self newQualifier].	xmlToSmalltalkBinding namespaces at: q put: nsString.	^q</body><body package="XMLSchemaMapping">simpleContentNode: anXMLElement addValue: aNodeTag constraint: aString"There are two types of simple contents that we treat differently.1.  simple contents derived from another simple contents which is not derived from a primitive type:	&lt;xsd:complexType name=PasswordString&gt;		&lt;xsd:simpleContent&gt;&lt;xsd:extension base='wsse:AttributedString'&gt;..&lt;/xsd:extension&gt;&lt;/xsd:simpleContent&gt;	&lt;/xsd:complexType&gt;	&lt;xsd:complexType name=EncodedString&gt;		&lt;xsd:simpleContent&gt;&lt;xsd:extension base=PasswordString&gt;..&lt;/xsd:extension&gt;&lt;/xsd:simpleContent&gt;	&lt;/xsd:complexType&gt;We map this XML as an inherited complex type:		&lt;object baseType=AttributedString constraint=extension name=PasswordString smalltalkClass=PasswordString&gt;..&lt;/object&gt;		&lt;object baseType=PasswordString constraint=extension name=EncodedString smalltalkClass=EncodedString&gt;..&lt;/object&gt;2. simple contents derived from a primitive type (base=xsd:string):	&lt;xsd:complexType name=AttributedString&gt;		&lt;xsd:simpleContent&gt;&lt;xsd:extension base=xsd:string&gt;..&lt;/xsd:extension&gt;&lt;/xsd:simpleContent&gt;	&lt;/xsd:complexType&gt;	&lt;xsd:complexType name=PasswordString&gt;		&lt;xsd:simpleContent&gt;&lt;xsd:extension base=wsse:AttributedString&gt;..&lt;/xsd:extension&gt;&lt;/xsd:simpleContent&gt;	&lt;/xsd:complexType&gt;We map this XML as a complex type with TextMarshaler:	&lt;object baseType=xsd:string constraint=extension name=AttributedString smalltalkClass=AttributedString&gt;			&lt;text name=value ref=xsd:string&gt;&lt;/text&gt;		&lt;/object&gt;	&lt;object baseType=AttributedString constraint=extension name=PasswordString smalltalkClass=PasswordString&gt;..&lt;/object&gt;At this moment we don't know if the #baseType is a primitive or another simple contents. When we finish building X2O DOM we will find it out and finish mapping."	self bindingPolicy addAttribute: 'baseType' value: aNodeTag asString to: anXMLElement.	aString ifNotNil: [ self bindingPolicy addAttribute: 'constraint' value: aString to: anXMLElement].	"Postpone mapping. If #baseType is primitive type add &lt;text&gt; node and resolve it to #baseType "	self needToResolveList add: [ self resolveSimpleContentNode: anXMLElement ref: aNodeTag ].	^anXMLElement</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>public</category><body package="XMLSchemaMapping">baseURI: aString	baseURI := aString</body><body package="XMLSchemaMapping">readFrom: aStreamOrDoc	^self readSchemas: (self schemaDocumentsFrom: aStreamOrDoc) asOrderedCollection.</body><body package="XMLSchemaMapping">readSchemas: schemaNodes	| schemas |	schemas :=  self resolveEmptyImportsInSchemas: schemaNodes.	schemas do: [ :el | self parseSchemaElement: el with: self schemaBindings ].  	self isImported ifFalse: [ self readImports ].  	self needToResolveList do: [ :block | block value ].	^self schemaBindings</body><body package="XMLSchemaMapping">setBindingPolicy: aXMLBindingPolicy	bindingPolicy := aXMLBindingPolicy</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>utilities</category><body package="XMLSchemaMapping">allExistingSmClasses	| coll  cl |	coll := OrderedCollection new.	self allSmClasses		do: [ :clx | 			(cl := (self namespace, '.', clx asString) asQualifiedReference valueOrDo: [nil]) notNil			ifTrue: [ coll add: cl ]].	^coll</body><body package="XMLSchemaMapping">allSmClasses	| coll cl |	coll := OrderedCollection new.	self structList do: 		[ :elx | 		(elx tag type = 'object' 			and: [ (cl := elx valueOfAttribute: 'smalltalkClass' ifAbsent: [nil]) notNil])			ifTrue: [ coll add: cl]].	^coll</body><body package="XMLSchemaMapping">replaceClassName: oldString with: newString	| element attr |	element := self structList 				detect: [ :elx | 						elx tag type = 'object' 							and: [ (elx valueOfAttribute: 'smalltalkClass' ifAbsent: [nil]) asString = oldString asString ]]				ifNone: [nil].	element ifNotNil:		[ attr := element attributeNamed: 'smalltalkClass' ifAbsent: [nil].		attr value: newString].	^element</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>private parse</category><body package="XMLSchemaMapping">collectNoNSImportsFrom: aCollection "http://www.w3.org/TR/xmlschema-0/#import3. Also in a schema, the  import element has optional namespace and schemaLocation  attributes. If present, the schemaLocation  attribute is understood in a way which parallels the interpretation of   xsi:schemaLocation in (1). Specifically, it provides a hint from the author to a processor regarding the location of a schema document that the author warrants supplies the required components for the namespace identified by the  namespace attribute. To import components that are not in any target namespace, the import element is used without a namespace  attribute (and with or without a schemaLocation  attribute). References to components imported in this manner are unqualified. "	| xpath importEls coll |	coll := OrderedCollection new.	aCollection do: [ :sch | 				xpath := XPathParser new  parse: 'child::import' as: #locationPath.				importEls := (xpath xpathValueFor: sch variables: nil) sortedNodes.				importEls do: [ :importElement | 	importElement valueOfAttribute: 'namespace' 	ifAbsent: [coll add: importElement ]]].	^coll</body><body package="XMLSchemaMapping">createBindingElement	| doc |	doc := XML.Document new.	doc addNode:		(Element 			tag: (NodeTag 					qualifier: '' 					ns: self class uriVWBinding					type: 'schemaBindings')).	^doc root</body><body package="XMLSchemaMapping">hasSoapArrayEncoding: anElement	| attr qualifier |	attr := anElement attributes 		detect: [ :attribute | attribute key type = 'base' and: ['*:Array' match: attribute value ]]		ifNone: [^false ].	qualifier := (attr value tokensBasedOn: $:) first.	^(anElement namespaceAtQualifier: qualifier ifAbsent: ['']) = 'http://schemas.xmlsoap.org/soap/encoding/'</body><body package="XMLSchemaMapping">initializeBindingElementFrom: anXMLElement	| ns targetNamespace |	structList := OrderedCollection new: 30.	xmlToSmalltalkBinding := self bindingPolicy createElementType: 'xmlToSmalltalkBinding'.	xmlToSmalltalkBinding attributes: anXMLElement attributes copy asOrderedCollection.	xmlToSmalltalkBinding namespaces: (Dictionary new: 10).	xmlToSmalltalkBinding attributes 		do: [ :attr | 			(attr key qualifier notEmpty 				and: [(ns := anXMLElement namespaces at: attr key qualifier ifAbsent: [nil]) notNil ])				ifTrue: [xmlToSmalltalkBinding namespaces at: attr key qualifier put: ns ]].	xmlToSmalltalkBinding namespaces at: '' put: self class uriVWBinding.	targetNamespace := anXMLElement  valueOfAttribute: 'targetNamespace' ifAbsent: [ nil ].	"R2105 All xsd:schema elements contained in a wsdl:types element of a DESCRIPTION MUST have a targetNamespace attribute with a valid and non-null value, UNLESS the xsd:schema element has xsd:import and/or xsd:annotation as its only child element(s). http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html#Schema_targetNamespace_Structure""http://www.w3.org/TR/xmlschema-1/#element-schema.Since the empty string is not a legal namespace name, supplying an empty string for targetNamespace is incoherent, and is not the same as not specifying it at all. The appropriate form of schema document corresponding to a Â·schemaÂ· whose components have no {target namespace} is one which has no targetNamespace attribute specified at all.TK. We should raise an error if we have targetNamespace with empty value but there is a customer with DiffgramFormat from urn:schemas-microsoft-com:xml-msdata that receives responses with: &lt;xsd:schema id='NewDataSet' targetNamespace="" ...	(targetNamespace notNil and: [targetNamespace isEmpty]) 		ifTrue: [self error: 'If #targetNamespace attribute is present it is not legal to have it empty']."	(targetNamespace notNil and: [targetNamespace notEmpty]) 		ifTrue: [ xmlToSmalltalkBinding namespaces at: 'tns' put: targetNamespace ].		( self bindingPolicy isKindOf:  XMLObjectBindingPolicy )		ifTrue: [ 	xmlToSmalltalkBinding attributes add: 				( Attribute 					name: 'defaultClassNamespace' 					value: (self namespaceMap at: targetNamespace ifAbsent: [self namespace]))].		^xmlToSmalltalkBinding</body><body package="XMLSchemaMapping">merge: anXMLElement withBinding: aSchemaBindings	| targetNamespace theSame x2oBinding |	targetNamespace := anXMLElement attributes detect: [ :a | a key type = 'targetNamespace'] ifNone: [nil].	self log: 'Merging the schema element in to existing X2O'.	theSame :=  true.	"If the new import has the same attributes as the existing one, we will simply merge them, otherwise we raise the merge conflict."	x2oBinding := self initializeBindingElementFrom: anXMLElement.	x2oBinding attributes size = aSchemaBindings attributes size		ifTrue: [ x2oBinding attributes do:  [ :attr1 |				 (aSchemaBindings attributes anySatisfy: 					[ :attr2 | attr1 key = attr2 key and: [attr1 value = attr2 value]])  ifFalse: [ theSame := false ]  ]]		ifFalse: [ theSame :=  false.].	theSame ifTrue: [^aSchemaBindings].		^BindingMergeConflict new		messageText: ((#ThereIsAlreadyX2OBindingWithTargetNamespace1s  &lt;&lt; #webservices &gt;&gt; 'Target namespace &lt;1s&gt; of an imported schema matches an existing binding, but the associated attributes are different. The attributes have to be merged to continue.')		expandMacrosWith: targetNamespace value);		schema: anXMLElement;		existingBinding: aSchemaBindings;		parser: self;		raiseRequest</body><body package="XMLSchemaMapping">missingImports	^(self imports keys select: [ :url | (self imports at: url ) isKindOf: XML.Element]) asOrderedCollection</body><body package="XMLSchemaMapping">newParser	| parser |	parser := self class new.	parser 			baseURI: baseURI;			namespaceMap: namespaceMap;			useSequenceMapping: self useSequenceMapping;			setBindingPolicy: self bindingPolicy;			schemaElements: self schemaElements;			schemaBindings: self schemaBindings.	^parser</body><body package="XMLSchemaMapping">raiseMappingUnboundedContentToStruct: rootElement 	|  clName |	(MappingUnboundedContentToStruct new 		parameter: rootElement;		raiseRequest) ifNotNil: [ :mapping |			mapping = #object 				ifTrue: [(rootElement valueOfAttribute: 'name' ifAbsent: [nil ]) ifNotNil: [ :name |						rootElement tag resetTypeTo: 'object'.						clName := XMLObjectBindingPolicy createSmalltalkClassNameFrom: name inNamespace: self namespace.						rootElement addAttribute: (Attribute name: 'smalltalkClass' value: clName).						xmlToSmalltalkBinding 							attributeNamed: 'defaultClassNamespace' 							ifAbsent: [xmlToSmalltalkBinding attributes add: ( Attribute name: 'defaultClassNamespace' value: self namespace) ]]]]</body><body package="XMLSchemaMapping">readImportSchemaFrom: anURI	| parser |	anURI isPartial ifTrue: [^UnresolvedImportLocation raiseRequestWith: anURI errorString: ( #CannotGetResourceFromPartialURL &lt;&lt; #webservices &gt;&gt;'Can not get resource from PartialURL. The parser has #baseURI as nil')].	(parser := self newParser )		isImported: true;		imports: self imports;		baseURI: anURI.	self log: ('Parsing imported schema at &lt;1s&gt;' expandMacrosWith: anURI printString).	^parser readFrom: anURI</body><body package="XMLSchemaMapping">readImports	| previousSet nextSet |	[	previousSet := self missingImports.		previousSet isNotEmpty ifTrue: [ self log: ('Unresolved imported URL''s:&lt;n&gt;&lt;1s&gt;' expandMacrosWith: previousSet printString)].		previousSet do: [ :url | 						self readImportSchemaFrom: url. 						self imports at: url put: #done ].		nextSet := self missingImports.		nextSet notEmpty	] whileTrue: [		(previousSet isSameSequenceAs: nextSet) ifTrue: [			self error: #CannotResolveImports &lt;&lt; #webservices &gt;&gt; 'Cannot resolve schema imports' ] ]</body><body package="XMLSchemaMapping">resolveEmptyImportsInSchemas: xmlElements		|  noTargetNsSchemas tns schemas |	noTargetNsSchemas := OrderedCollection new.	(xmlElements select: [ :scx | scx tag type = 'import']) do: [ :scx | self addImport: scx ].	(schemas := xmlElements select: [ :scx | scx tag type = 'schema']) 		 do: [ :scx | 			(tns := scx valueOfAttribute: 'targetNamespace' ifAbsent: [nil]) ifNil: [noTargetNsSchemas add: scx]. 					self schemaElements 								detect: [:elx | (elx valueOfAttribute: 'targetNamespace' ifAbsent: ['']) = tns ] 								ifNone: [self schemaElements add: scx]].	(self collectNoNSImportsFrom: schemas) do: [:impElem | self resolveNoNSImport: impElem from: noTargetNsSchemas].	^schemas</body><body package="XMLSchemaMapping">resolveNoNSImport: importElement from: noTargetNsSchemas"The &lt;import&gt; element information item identifies namespaces used in external references, i.e. those whose Â·QNameÂ· identifies them as coming from a different namespace (or none) than the enclosing schema document's targetNamespace. The Â·actual valueÂ· of its namespace [attribute] indicates that the containing schema document may contain qualified references to schema components in that namespace (via one or more prefixes declared with namespace declarations in the normal way). If that attribute is absent, then the import allows unqualified reference to components with no target namespace. Note that components to be imported need not be in the form of a Â·schema documentÂ·; the processor is free to access or construct components using means of its own choosing.The Â·actual valueÂ· of the schemaLocation, if present, gives a hint as to where a serialization of a Â·schema documentÂ· with declarations and definitions for that namespace (or none) may be found. When no schemaLocation [attribute] is present, the schema author is leaving the identification of that schema to the instance, application or user, via the mechanisms described below in Layer 3: Schema Document Access and Web-interoperability (Â§4.3). When a schemaLocation is present, it must contain a single URI reference which the schema author warrants will resolve to a serialization of a Â·schema documentÂ· containing the component(s) in the &lt;import&gt;ed namespace referred to elsewhere in the containing schema document.Note: Since both the namespace and schemaLocation [attribute] are optional, a bare &lt;import/&gt; information item is allowed. This simply allows unqualified reference to foreign components with no target namespace without giving any hints as to where to find them."	| parent  |	parent := importElement parent.	( importElement valueOfAttribute: 'schemaLocation' ifAbsent: [nil ])		ifNil: [			noTargetNsSchemas do: [ :s |				s realElements reverseDo: [ :elx | parent addFirstNode: elx] ] ]		ifNotNil: [ :location | | url |				[url := location asURI] 				on: Error do: [ :ex | self error: (#CannotCreateURLForImport &lt;&lt; #webservices &gt;&gt;'Can not create URI from import location attribute')].			url isPartial ifTrue: [ url := baseURI, url ].			(self schemaDocumentsFrom: url) do: [ :sch | sch  realElements do: [ :elx |  parent addNode: elx]]].	"I hope we have all import elements in the  parent by now. Remove it to exclude from processing"	parent elements remove: importElement.</body><body package="XMLSchemaMapping">schemaDocumentsFrom: aDataSourceOrDoc	| doc aDocument xpath coll |	doc := (aDataSourceOrDoc isKindOf: XML.Document)		ifTrue: [aDataSourceOrDoc printString readStream]		ifFalse: [aDataSourceOrDoc ].	aDocument := WSSAXDriver on: doc."Why selecting  first 'self:types' but not 'self:schema' because there are some wsdl with wrong structure:&lt;wsdl:types&gt;&lt;xsd:import namespace='urn:s1' schemaLocation='Schema1.xsd/&gt;&lt;xsd:import namespace='urn:s2' schemaLocation='Schema2.xsd'/&gt;&lt;/wsdl:types&gt;From Basic Profile: http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html#refinement16498504R2003 A DESCRIPTION MUST use the XML Schema 'import' statement only within the xsd:schema element of the types section. "	xpath := XPathParser new 				parse: 'descendant-or-self::*[self::types]' as: #locationPath.	coll := (xpath xpathValueFor: aDocument root variables: nil) sortedNodes.	coll isNotEmpty ifTrue: [ ^coll first realElements ].	xpath := XPathParser new 				parse: 'descendant-or-self::*[self::schema]' as: #locationPath.	^(xpath xpathValueFor: aDocument root variables: nil) sortedNodes.</body><body package="XMLSchemaMapping">userDataOfAttributeBaseFrom:  anElement	^(anElement attributes detect: [:a | a tag isLike: 'base'] ifNone: [nil]) 		ifNotNil: [ :attr | 			attr userData 				ifNil: [self processQName: attr value from: anElement ]				ifNotNil: [ :ud | ud ]]</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptAllTypeNode: anElement with: rootElement	| all |	all :=  self bindingPolicy createElementType: 'all'.	all attributes: anElement attributes.	rootElement addNode: all.	(self  realElements: anElement) do: [ :elx | self parse: elx with: all ].</body><body package="XMLSchemaMapping">acceptAnyAttributeNode: anElement with: rootElement	| el |	el := self bindingPolicy createElementType: 'anyAttribute'.	self addAttributesFrom: anElement to: el.	self bindingPolicy 		addAttribute: 'aspect' 		value: 'anyAttributes'		to: el.	rootElement addNode: el.	(self realElements: anElement ) do: [ :elx | self parse: elx with: el].	^true</body><body package="XMLSchemaMapping">acceptAnyTypeNode: anElement with: rootElement"&lt;any  id = ID  maxOccurs = (nonNegativeInteger | unbounded)  : 1  minOccurs = nonNegativeInteger : 1  namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any  processContents = (lax | skip | strict) : strict  {any attributes with non-schema namespace . . .}&gt;  Content: (annotation?)&lt;/any&gt;"	| elem |	elem := XML.Element tag: 'any' attributes: anElement attributes copy asOrderedCollection elements: OrderedCollection new.	rootElement addNode: elem.	self bindingPolicy addAspectToAny: elem.</body><body package="XMLSchemaMapping">acceptAttributeGroupNode: anElement with: rootElement"&lt;attributeGroup  id = ID  name = NCName  ref = QName  {any attributes with non-schema namespace . . .}&gt;  Content: (annotation?, ((attribute | attributeGroup)*, anyAttribute?))&lt;/attributeGroup&gt; The same element, in this case attributeGroup, serves both to define and to incorporate by reference. In the first case the name attribute is required, in the second the ref attribute is required, and the element must be empty. These two are mutually exclusive, and also conditioned by context: the defining form, with a name, must occur at the top level of a schema, whereas the referring form, with a ref, must occur within a complex type definition or an attribute group definition.""We are mapping the #attributegroup and #group element as following:1. elements with name are mapped to #struct2. elements with ref are mapped to group "	| node |	(anElement attributeNamed: 'name' ifAbsent: [ nil]) 		ifNotNil: 			[ node := self bindingPolicy createElementType: 'modelAttributeGroup'.			self addAttributesFrom: anElement to: node].	(anElement attributeNamed: 'ref' ifAbsent: [ nil]) 		ifNotNil: 			[ node := self bindingPolicy createElementType: 'attributeGroup'.			self addAttributesFrom: anElement to: node. ].	rootElement addNode: node.	(self realElements: anElement)  do: [ :el |  self parse: el with: node ].	^true</body><body package="XMLSchemaMapping">acceptAttributeNode: anElement with: rootElement	| el |	el := ( anElement attributeNamed: 'ref'  ifAbsent: [ nil ]) 			ifNotNil: [ self bindingPolicy createElementType: 'implicitAttribute' ]			ifNil: [ self bindingPolicy createElementType: 'attribute' ].	self addAttributesFrom: anElement to: el.	self bindingPolicy addAspectAttributeTo: el.	rootElement addNode: el.	(self realElements: anElement ) do: [ :elx | self parse: elx with: el].	^true</body><body package="XMLSchemaMapping">acceptChoiceTypeNode: anElement with: rootElement"&lt;complexType name='ServiceChoice'&gt;	&lt;choice&gt;		&lt;element name='weather' type='ns:LDSrvcWeatherForecast'/&gt;		&lt;element name='search'  type='ns:LDSrvcSearch'/&gt;	&lt;/choice&gt;&lt;/complexType&gt;"	| choice | 	choice := self bindingPolicy newChoice.	rootElement addNode: choice.	self addAttributesFrom: anElement to: choice.	self bindingPolicy addAspectToChoice: choice.	( self realElements: anElement)  do: [ :elx |  self parse: elx with: choice ]</body><body package="XMLSchemaMapping">acceptComplexContentTypeNode: anElement with: rootElement	| name elem  el xpath  base isRestriction isExtension |	self bindingPolicy isDefaultPolicy ifTrue: [ | nodes |		xpath := XPathParser new parse: 'child::*[ self::extension or self::restriction ]' as: #locationPath.		(nodes := (xpath xpathValueFor: anElement variables: nil) sortedNodes) notEmpty			ifTrue: [	"Ignore &lt;restriction base=SOAP-ENC:Array&gt; "					(self hasSoapArrayEncoding: nodes first) ifFalse: [MappingDerivationToStructs signal ]]].	name := self bindingPolicy elemName: rootElement. 	elem := (self  realElements: anElement) first.		isRestriction := elem tag type = 'restriction'.	isExtension := elem tag type = 'extension'.	( elem tag type = 'all' ) ifTrue: [^(self realElements: elem) do: [ :elx | self parse: elx with: rootElement]].	base := self userDataOfAttributeBaseFrom:  elem.	((isRestriction or: [ isExtension ]) and: [base == nil])		ifTrue: [ ^self 					excFor: anElement 					text: (#NoBaseTypeSpecified &lt;&lt; #webservices &gt;&gt; 'No base type specified')].	(isRestriction and: [self processArrayType: elem rootName: name ]) ifTrue: [^self structList remove: rootElement]. 	(isRestriction and: [base type ~= 'anyType' and: [self class xmlSimpleTypes includes: base type]])		ifTrue: [rootElement addNode:( el := self bindingPolicy createElementFrom: rootElement). 				self bindingPolicy addAttribute: 'constraint' value: 'restriction' to: el.				self  addRef: base  to: el parent: elem.				^(self realElements: elem) do: [ :n | self parse: n with: el]].	(isExtension or: [isRestriction ])		ifTrue: [self addConstraintFrom: anElement to: rootElement.			^(self realElements: elem) do: [ :elx | self parse: elx with: rootElement]].	^self 		excFor: elem 		text: ((#CanNotProcessComplexContent1s &lt;&lt; #webservices &gt;&gt; 'Can not process complexContent &lt;1s&gt;. Expected nodes: (restriction | extension) ' )				expandMacrosWith: elem tag type)</body><body package="XMLSchemaMapping">acceptComplexTypeNode: anElement with: rootElement	| root name xpath abstractAttributes |	self bindingPolicy isDefaultPolicy ifTrue: [		xpath := XPathParser new parse: 'attribute::abstract' as: #locationPath.		abstractAttributes := (xpath xpathValueFor: anElement variables: nil) sortedNodes.		(abstractAttributes anySatisfy: [:attr | attr value = 'true'])			ifTrue: [MappingDerivationToStructs signal ]].	name := self bindingPolicy elemName: anElement.	(self processArrayType: anElement rootName: name ) ifTrue: [^true].	root := name ~~ nil		ifTrue: [self structList add: (self bindingPolicy newComplexType: name inNamespace: self namespace )]		ifFalse: [ rootElement ].	anElement attributes do: [ :att | att key type ~= 'name' ifTrue: [ root addAttribute: att] ].	(self realElements: anElement)  do: [ :el |  self parse: el with: root ].	^true</body><body package="XMLSchemaMapping">acceptElementTypeNode: anElement with: rootElement	| realElements |	realElements := self realElements: anElement. 	(self processCollection: anElement parent: rootElement realElements: realElements) ifTrue: [^true].	(self processSimpleElement: anElement parent: rootElement realElements: realElements) 	ifTrue: [^true].	(self processRefElement: anElement parent: rootElement realElements: realElements) ifTrue: [ ^true].	(self processComplexType: anElement parent: rootElement realElements: realElements) ifTrue: [^true].	^self 		excFor: anElement 		text: ((#CanNotParseTheNode &lt;&lt; #webservices &gt;&gt; 'Can not parse the node: &lt;1s&gt;')				expandMacrosWith: anElement tag asString).</body><body package="XMLSchemaMapping">acceptEnumerationTypeNode: anElement with: rootElement	|  attr type ud coll |	type := self userDataOfAttributeBaseFrom:  anElement parent.	(type notNil 		and: [type type = 'QName'			and: [(ud := anElement userDataOfAttribute: 'value' ) notNil]])		ifTrue: [ud resetQualifierTo: 					(self setQualifierFor: ud namespace fromElement: anElement).				attr := anElement attributeNamed: 'value' ifAbsent: [ nil].				ud qualifier notEmpty ifTrue: [attr value: ud qualifier, ':', ud type ]].	anElement  tag resetQualifierTo: ''. 	rootElement addNode: anElement.	(coll := self realElements: anElement) isEmpty		ifTrue: [anElement elements: nil]		ifFalse: [anElement elements: coll]</body><body package="XMLSchemaMapping">acceptGroupNode: anElement with: rootElement"&lt;group  id = ID  maxOccurs = (nonNegativeInteger | unbounded)  : 1  minOccurs = nonNegativeInteger : 1  name = NCName  ref = QName  {any attributes with non-schema namespace . . .}&gt;  Content: (annotation?, (all | choice | sequence)?)&lt;/group&gt; The same element, in this case attributeGroup, serves both to define and to incorporate by reference. In the first case the name attribute is required, in the second the ref attribute is required, and the element must be empty. These two are mutually exclusive, and also conditioned by context: the defining form, with a name, must occur at the top level of a schema, whereas the referring form, with a ref, must occur within a complex type definition or an attribute group definition.""We are mapping the #attributegroup and #group element as following:1. elements with name are mapped to #struct2. elements with ref are mapped to group "	| node |	(anElement attributeNamed: 'name' ifAbsent: [ nil]) ifNotNil: 			[ node := self bindingPolicy createElementType: 'modelGroup'.		self addAttributesFrom: anElement to: node.].	(anElement attributeNamed: 'ref' ifAbsent: [ nil]) 		ifNotNil: [ node := self acceptGroupRefNode: anElement with: rootElement.].	rootElement addNode: node.	(self realElements: anElement)  do: [ :el | self parse: el with: node ].	^true</body><body package="XMLSchemaMapping">acceptGroupRefNode: anElement with: rootElement	| node |	(anElement parent tag type  = 'complexType'		and: [(anElement valueOfAttribute: 'maxOccurs' ifAbsent: [nil ]) notNil			and: [ self bindingPolicy isDefaultPolicy]])		ifTrue: [self raiseMappingUnboundedContentToStruct: rootElement ].	node := self bindingPolicy createElementType: 'group'.	self addAttributesFrom: anElement to: node.	(rootElement tag type = 'sequence'		and: [(anElement valueOfAttribute: 'maxOccurs' ifAbsent: [nil ]) notNil])		ifTrue: ["group in sequence. Add aspect "				self bindingPolicy addAspectToGroup: node ].	^node</body><body package="XMLSchemaMapping">acceptImportNode: anElement with: rootElement	| ns schemaLocation |" Since both the namespace and schemaLocation [attribute] are optional, a bare &lt;import/&gt; information item is allowed. This simply allows unqualified reference to foreign components with no target namespace without giving any hints as to where to find them."	ns := anElement valueOfAttribute: 'namespace' ifAbsent: [ ^nil ].	schemaLocation := anElement valueOfAttribute: 'schemaLocation' ifAbsent: [ String new ].	ns = (anElement parent  valueOfAttribute: 'targetNamespace' ifAbsent: [ nil ])		ifTrue: [^self 				excFor: anElement 				text: (#ImportMayNotHaveSameNS &lt;&lt; #webservices &gt;&gt; 'Import may not have the same namespace as its enclosing schema' )].		(rootElement anyElementsNamed: 'bindingImport')		detect: [:imp | ((imp attributeNamed: 'namespace' ifAbsent: []) value = ns)						and: [(imp attributeNamed: 'schemaLocation' ifAbsent: []) value = schemaLocation]]		ifNone: 	[| elx |				elx := self bindingPolicy createElementType: 'bindingImport'.				self addAttributesFrom: anElement to: elx.				rootElement addFirstNode: elx.].	self addImport: anElement.</body><body package="XMLSchemaMapping">acceptIncludeNode: anElement with: rootElement	| uri |	(uri :=  self importURIFrom:  anElement) ifNil: [ ^false ].	uri isPartial ifTrue: [^UnresolvedImportLocation raiseRequestWith: uri errorString: ( #CannotGetResourceFromPartialURL &lt;&lt; #webservices &gt;&gt;'Can not get resource from PartialURL. The parser has #baseURI as nil')].	self log: ( 'Processing include element:&lt;n&gt;&lt;1s&gt;&lt;n&gt;at &lt;2s&gt;' expandMacrosWith: anElement printString with: uri printString ).	rootElement realElements 		detect: [ :el | 				el tag type = 'include' 					and: [ (el valueOfAttribute: 'schemaLocation' ifAbsent: [nil]) = (anElement valueOfAttribute: 'schemaLocation' ifAbsent: [nil]) ]] 		ifNone: [ rootElement addFirstNode: (Element tag: (NodeTag new qualifier: '' ns: '' type: 'include') attributes: anElement attributes elements: nil   ).				(self schemaDocumentsFrom: uri) do: [ :elx | 					elx  realElements do: [ :el | self parse: el with: rootElement]]].	^true</body><body package="XMLSchemaMapping">acceptListNode: anElement with: rootElement "&lt;list  id = ID  itemType = QName  {any attributes with non-schema namespace . . .}&gt;  Content: (annotation?, simpleType?)&lt;/list&gt;the type definition resolved to by the actual value of the itemType [attribute] of &lt;list&gt;, if present, otherwise the type definition corresponding to the &lt;simpleType&gt; among the [children] of &lt;list&gt;."	| list  listElement |	list := self bindingPolicy createElementType: 'list'.	list attributes: anElement attributes. "add name attribute from simpleType  "	listElement := ( self realElements: anElement) first.	listElement attributes do: [ :each |		each key type = 'itemType' 			ifTrue: [ 	list addAttribute: (Attribute name: 'itemType' value: (self createNodeFrom: each value parent: anElement) asString)]  			ifFalse: [list addAttribute: each]].	rootElement addNode: list.	(self realElements: listElement ) do: [ :elx | self parse: elx with: list ].	^true</body><body package="XMLSchemaMapping">acceptRestrictionTypeNode: anElement with: rootElement"&lt;restriction  base = QName  id = ID  {any attributes with non-schema namespace . . .}&gt;  Content: (annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))&lt;/restriction&gt;If the &lt;restriction&gt; alternative is chosen, either it must have a base [attribute] or a &lt;simpleType&gt; among its [children], but not both."	| name simpleEl val |	(anElement parent attributeNamed: 'name' ifAbsent: [nil]) ifNotNil: [ :attr | name := attr value].	simpleEl := self bindingPolicy createSimpleTypeName:  name.	rootElement  addNode: simpleEl.	(self userDataOfAttributeBaseFrom:  anElement) 		ifNotNil: [ :baseAttr | 				val := (self createNodeFrom: baseAttr parent: anElement ) asString.				self bindingPolicy addAttribute: 'baseType' value: val to: simpleEl.				rootElement tag type = 'text'					ifTrue: [self bindingPolicy addAttribute: 'baseType' value: val to: rootElement parent.						self bindingPolicy addAttribute: 'constraint' value: 'restriction' to: rootElement parent]				]		ifNil: ["There is the #base attribute which was not resolved in the attribute userData. Let''s complain about it "				self excFor: anElement  text: ((#CanNotResolveRestrictionBaseType1s &lt;&lt; #webservices &gt;&gt; 'Can not resolve the restriction base type: &lt;1s&gt;') expandMacrosWith: anElement printString) ].	(self realElements: anElement) do: [ :elx | self parse: elx with: simpleEl].	^true</body><body package="XMLSchemaMapping">acceptSequenceTypeNode: anElement with: rootElement	| seq  val|		(self bindingPolicy isDefaultPolicy		and: [anElement parent tag type = 'complexType'			and: [(val := anElement valueOfAttribute: 'maxOccurs' ifAbsent: [nil ]) notNil				and: [val ~= '1' ]]])		ifTrue: [self raiseMappingUnboundedContentToStruct: rootElement ].	seq :=  self bindingPolicy createElementType: 'sequence'.	seq attributes: anElement attributes.	rootElement addNode: seq.	(rootElement tag type = 'sequence'		or: [ rootElement tag type = 'choice'])		ifTrue: ["nested sequence. Add aspect "				self bindingPolicy addAspectToSequence: seq ].	(self  realElements: anElement) do: [ :elx | self parse: elx with: seq ].</body><body package="XMLSchemaMapping">acceptSimpleContentTypeNode: anElement with: rootElement	| elem ref text |	elem := (self realElements: anElement) first.	"&lt;extension: Content: (annotation?, ((attribute | attributeGroup)*, anyAttribute?))"	elem tag type = 'extension' 		ifTrue: 			["&lt;text name='value' ref='xsd:string' aspect='value'/&gt;" 			(ref := self userDataOfAttributeBaseFrom:  elem) notNil				ifTrue: 					[self 						simpleContentNode: rootElement 						addValue: (self createNodeFrom: ref parent: elem )						constraint: elem tag type.					( self realElements: elem)  do: [ :node | self parse: node with: rootElement].					^rootElement]].	"&lt;restriction:  (simpleType?, (minExclusive | minInclusive | maxExclusive... "			elem tag type = 'restriction'		ifTrue: ["&lt;text name='value' /&gt;" 			text := self addTextTo: rootElement ref: nil.			^self acceptRestrictionTypeNode: elem with: text ].	^self 		excFor: anElement 		text: (#CanNotParseSimpleContent &lt;&lt; #webservices &gt;&gt; 'Can not parse simple content')</body><body package="XMLSchemaMapping">acceptSimpleTypeFractionDigitsNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'fractionDigits'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeLengthNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'length'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeMaxExclusiveNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'maxExclusive'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeMaxInclusiveNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'maxInclusive'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeMaxLengthNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'maxLength'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeMinExclusiveNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'minExclusive'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeMinInclusiveNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'minInclusive'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeMinLengthNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'minLength'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeNode: anElement with: rootElement	| elem  |	elem := ( self realElements: anElement) first.	elem tag type = 'union' ifTrue: [^self acceptUnionNode: anElement with: rootElement].	elem tag type = 'list' ifTrue: [ ^self acceptListNode: anElement with: rootElement ].	elem tag type = 'restriction' ifTrue: [^self acceptRestrictionTypeNode: elem with: rootElement ].	self excFor: anElement  text: ((#NotSupportedSimpleTypeContent1s &lt;&lt; #webservices &gt;&gt; 'Not supported the simple type content: &lt;1s&gt;') expandMacrosWith: anElement printString)</body><body package="XMLSchemaMapping">acceptSimpleTypePatternNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'pattern'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeTotalDigitsNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'totalDigits'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptSimpleTypeWhiteSpaceNode: anXMLElement with: rootElement	| elx |	elx := self bindingPolicy createElementType: 'whiteSpace'.	self addAttributesFrom: anXMLElement to: elx.	rootElement addNode: elx</body><body package="XMLSchemaMapping">acceptUnionNode: anElement with: rootElement "&lt;union id=ID memberTypes='list of QNames' any attributes&gt;(annotation?,(simpleType*))&lt;/union&gt; "	| union  unionElement |	union := self bindingPolicy createElementType: 'union'.	union attributes: anElement attributes. "add name attribute from simpleType  "	unionElement := ( self realElements: anElement) first.	unionElement attributes do: [ :each |		each key type = 'memberTypes' 			ifTrue: [ | node value |					value := String new.					(each value tokensBasedOn: Character space)						do: [ :type | 							node := self createNodeFrom: type parent: anElement.							value isNotEmpty ifTrue: [ value := value, ' '].							value := value, node asString ].					union addAttribute: (each copy value: value)]  			ifFalse: [union addAttribute: each]].	rootElement addNode: union.	(self realElements: unionElement ) do: [ :elx | self parse: elx with: union ].	^true</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>parsing</category><body package="XMLSchemaMapping">mergeSchemaElement: anXMLElement  existingX2O: existingX2O root: aSchemaBindings	"If the exception is resumed with nil, we assume the user wants to skip this import element altogether and continue with the rest of the schema."	^(self merge: anXMLElement withBinding: existingX2O)		ifNotNil: [ :x2oBinding | 				anXMLElement realElements do: [ :el | self parse: el with: x2oBinding ].				self structList do: [ :node |					x2oBinding realElements 						detect: [ :el | (el valueOfAttribute: 'name' ifAbsent: [nil]) = (node valueOfAttribute: 'name' ifAbsent: [nil])]						ifNone: [ x2oBinding addNode: node]]. 				x2oBinding ]</body><body package="XMLSchemaMapping">parse: anElement with: rootElement	(self handlerFor: anElement) 	ifNotNil: [ :handler | self visit: handler  with: rootElement ]</body><body package="XMLSchemaMapping">parseNewSchemaElement: anXMLElement 	| newBinding |	newBinding := self initializeBindingElementFrom: anXMLElement.	anXMLElement realElements do: [ :el | self parse: el with: newBinding ].	self structList do: [ :node | newBinding addNode: node]. 	^newBinding</body><body package="XMLSchemaMapping">parseSchemaElement: anXMLElement with: aSchemaBindings	| ns  |	ns := anXMLElement  valueOfAttribute: 'targetNamespace' ifAbsent: [ nil ].	self log: ('Parsing schema with targetNamespace &lt;1s&gt;' expandMacrosWith: ns printString).	^(self schemaBindings realElements detect: [ :elx | (elx valueOfAttribute: 'targetNamespace' ifAbsent: ['']) = ns ] ifNone: [nil]) 		ifNil: [ | newBinding |			newBinding := self parseNewSchemaElement: anXMLElement.			self isImported				ifTrue: [aSchemaBindings addFirstNode: newBinding ] 				ifFalse: [aSchemaBindings addNode: newBinding ].]		ifNotNil: [ :existingX2O |				self log: ('Found existing X2O binding for targetNamespace &lt;1s&gt;' expandMacrosWith: ns printString).				self mergeSchemaElement: anXMLElement  existingX2O: existingX2O root: aSchemaBindings ].</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>processing</category><body package="XMLSchemaMapping">processArrayType: anElement rootName: aString	| attr |	(attr := self userDataOfAttributeBaseFrom:  anElement ) isNil ifTrue: [ ^false].	('array' match: attr type ) ifFalse: [^false].	self addArrayElement: anElement name: aString.	^true</body><body package="XMLSchemaMapping">processCollection: anElement parent: rootElement realElements: realElements"This type of element is going to be mapped to &lt;sequence_of..&gt;     &lt;s:complexType name='ArrayOfRater'&gt;        &lt;s:sequence&gt;          &lt;s:element minOccurs='0' maxOccurs='unbounded' name='Rater' nillable='true' type='s0:Rater' /&gt;        &lt;/s:sequence&gt;      &lt;/s:complexType&gt;"	| node |	self useSequenceMapping ifFalse: [ ^false].	(anElement parent realElements size = 1		and: [anElement parent parent isElement			and: [anElement parent parent tag type = 'complexType'				and: [anElement parent parent realElements size = 1					and: [realElements isEmpty]]]]) ifFalse: [^false].	(anElement attributeNamed: 'maxOccurs' ifAbsent: [^false ]) value = '1' ifTrue: [ ^false].	node := self 				createSequenceOfFrom: anElement 				with: (self bindingPolicy elemName: rootElement parent).	xmlToSmalltalkBinding addNode: node.	self structList remove: rootElement parent.	^true</body><body package="XMLSchemaMapping">processComplexType: anElement parent: rootElement realElements: realElements	| struct newElem | 	(self realElements: anElement)  first tag type = 'complexType'  ifFalse: [ ^false ].	newElem :=  self bindingPolicy createElementType: 'element'.	anElement attributes do: [ :a | a key type ~= 'type' ifTrue: [ self  addAttribute: a to: newElem ]].	rootElement addNode: newElem.	self bindingPolicy addAspectAttributeTo: newElem.	struct := self bindingPolicy newComplexTypeFrom: anElement inNamespace: self namespace.	"Constraints on XML Representations of Element Declarations	3. type and either &lt;simpleType&gt; or &lt;complexType&gt; are mutually exclusive. "	(anElement attributeNamed: 'type'  ifAbsent: [ nil ])  ifNotNil: [ :type |		"We should raise an error here based on the element constraints but there are some malformed schemas have attributes under complexType.		If there is any element defined let's not copy the type attribute"		((self realElements: (self realElements: anElement)  first ) anySatisfy: [ :each | each tag type = 'element' or: [each tag type = 'sequence' ]])			ifFalse: [self  						simpleContentNode: struct 						addValue: (self createNodeFrom: type userData  parent: anElement )						constraint: nil ]].	newElem addNode: struct.	self parse: realElements first with: struct.	^true</body><body package="XMLSchemaMapping">processRefElement: anElement parent: rootElement realElements: realElements	| el refNode v |	refNode := anElement userDataOfAttribute: 'ref'.	^((self bindingPolicy isComplex: rootElement) and: [refNode notNil ])		ifTrue:			[el := self bindingPolicy createElementFrom: rootElement. 			(v := self bindingPolicy elemTag: rootElement) notNil				ifTrue: [self bindingPolicy addAttribute: 'tag'  value: v 	to: el].			self addRef: refNode to: el parent: anElement.			self structList remove: rootElement.			xmlToSmalltalkBinding addNode: el.			true]		ifFalse: [ false ]</body><body package="XMLSchemaMapping">processSimpleElement: anElement parent: rootElement realElements: realElements	| nameAttr el  |	nameAttr := self bindingPolicy elemName: anElement.	^((realElements size = 0 and: [ nameAttr notNil ])		or: [realElements first tag type = 'simpleType'			or: [realElements size &gt; 0 and:[#('unique' 'key' 'keyref') includes: realElements first tag type]] ])		ifTrue: 			[el := ( anElement attributeNamed: 'ref'  ifAbsent: [ nil ]) 					ifNotNil: [ self bindingPolicy createElementType: 'implicit' ]					ifNil: [ self bindingPolicy createElementType: 'element' ].			"anElement realElements size = 0 - the element won't be resolved by a local type. Let's add anyType if there is no type/ref provided "			self addAttributesFrom: anElement  to: el.			self bindingPolicy addAspectAttributeTo: el.			anElement realElements notEmpty				ifTrue: 					[realElements notEmpty 						ifTrue: 							[realElements first tag type = 'annotation'								ifTrue: 									["add annotation"  									el elements: anElement realElements.									"remove empty nodes"									el elements first elements: anElement realElements first realElements].							self parse: realElements first with: el. ]].			rootElement addNode: el.			true]		ifFalse: [ false ]</body></methods><methods><class-id>WebServices.XMLTypesParser</class-id> <category>testing</category><body package="XMLSchemaMapping">hasDefaultBindingPolicy	^self bindingPolicy class = XMLDefaultBindingPolicy</body></methods><methods><class-id>WebServices.XMLTypesParser class</class-id> <category>instance creation</category><body package="XMLSchemaMapping">defaultBinding	^self new		setBindingPolicy: XMLDefaultBindingPolicy new;		yourself</body><body package="XMLSchemaMapping">objectBindingInNamespace: aString	^self new		namespace: aString;		setBindingPolicy: XMLObjectBindingPolicy new;		yourself</body><body package="XMLSchemaMapping">readFrom: aStreamOrDoc	^self defaultBinding		readFrom: aStreamOrDoc</body><body package="XMLSchemaMapping">url: aStringOrURI	^self defaultBinding		readFrom: aStringOrURI asURI</body><body package="XMLSchemaMapping">useObjectBindingReadFrom: aStreamOrDoc inNamespace: aString	^(self objectBindingInNamespace: aString)		readFrom: aStreamOrDoc</body><body package="XMLSchemaMapping">useObjectBindingUrl: aStringOrURI inNamespace: aString	^(self objectBindingInNamespace: aString)		readFrom: aStringOrURI asURI</body></methods><methods><class-id>WebServices.XMLTypesParser class</class-id> <category>accessing</category><body package="XMLSchemaMapping">defaultLoggingBlock	^[ :string | Transcript cr;cr; nextPutAll: string]</body><body package="XMLSchemaMapping">defaultUriXsd 	^'http://www.w3.org/2001/XMLSchema'</body><body package="XMLSchemaMapping">loggingBlock	^loggingBlock</body><body package="XMLSchemaMapping">loggingBlock: aBlock	loggingBlock := aBlock</body><body package="XMLSchemaMapping">uriVWBinding	^'urn:visualworks:VWSchemaBinding'</body><body package="XMLSchemaMapping">xmlSimpleTypes	^#('anyType' 'string' 'decimal' 'int' 'positiveInteger' 'negativeInteger' 'short' 'double' 'float' 'boolean' 'anyURI' 'duration' 'time' 'date' 'dateTime' 'void' 'QName' 'base64Binary')</body></methods><methods><class-id>WebServices.XMLTypesParser class</class-id> <category>defaults</category><body package="XMLSchemaMapping">defaultXMLSchemaQualifier	^defaultXMLSchemaQualifier ifNil: [ 'xsd' ]</body><body package="XMLSchemaMapping">defaultXMLSchemaQualifier: aString 	defaultXMLSchemaQualifier := aString</body><body package="XMLSchemaMapping">useSequenceMapping	^useSequenceMapping ifNil: [ useSequenceMapping := self useSequenceMappingValue ]</body><body package="XMLSchemaMapping">useSequenceMapping: aBoolean	useSequenceMapping := aBoolean</body><body package="XMLSchemaMapping">useSequenceMappingValue	^false</body></methods><methods><class-id>WebServices.SimpleTypeMinInclusiveHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeMinInclusiveNode: self element with: anElement</body></methods><methods><class-id>WebServices.ComplexTypeHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptComplexTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeMaxLengthHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeMaxLengthNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeFractionDigitsHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeFractionDigitsNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeWhiteSpaceHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeWhiteSpaceNode: self element with: anElement</body></methods><methods><class-id>WebServices.UnionHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptUnionNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeLengthHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeLengthNode: self element with: anElement</body></methods><methods><class-id>WebServices.ComplexContentHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptComplexContentTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.XMLTypesParserExc class</class-id> <category>testing</category><body package="XMLSchemaMapping">mayResume	^true</body></methods><methods><class-id>WebServices.MappingDerivationToStructs</class-id> <category>printing</category><body package="XMLSchemaMapping">defaultMessageText	^(#MapDerivedTypesToObjects &lt;&lt; #webservices &gt;&gt; 'Mapping complex types with derivation to Struct can cause wrong marshaling results. Derived complex types should be mapped to Objects.') asString</body></methods><methods><class-id>WebServices.AttributeHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptAttributeNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeMinLengthHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeMinLengthNode: self element with: anElement</body></methods><methods><class-id>WebServices.AnyAttributeHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptAnyAttributeNode: self element with: anElement</body></methods><methods><class-id>WebServices.BindingMergeConflict</class-id> <category>accessing</category><body package="XMLSchemaMapping">existingBinding	^existingBinding</body><body package="XMLSchemaMapping">existingBinding: xmlElement	existingBinding := xmlElement</body><body package="XMLSchemaMapping">parser	^parser</body><body package="XMLSchemaMapping">parser: anXMLTypesParser	parser := anXMLTypesParser</body><body package="XMLSchemaMapping">schema	^schema</body><body package="XMLSchemaMapping">schema: xmlElement	schema := xmlElement</body></methods><methods><class-id>WebServices.BindingMergeConflict</class-id> <category>constants</category><body package="XMLSchemaMapping">defaultResumeValue		^existingBinding</body></methods><methods><class-id>WebServices.SequenceHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSequenceTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeMaxInclusiveHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeMaxInclusiveNode: self element with: anElement</body></methods><methods><class-id>WebServices.GroupHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptGroupNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypePatternHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypePatternNode: self element with: anElement</body></methods><methods><class-id>WebServices.EnumerationHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptEnumerationTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleContentHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleContentTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.MappingUnboundedContentToStruct</class-id> <category>accessing</category><body package="XMLSchemaMapping">complexType	^parameter</body><body package="XMLSchemaMapping">complexType: anElement	parameter := anElement</body></methods><methods><class-id>WebServices.MappingUnboundedContentToStruct</class-id> <category>printing</category><body package="XMLSchemaMapping">defaultMessageText	| name |	name := parameter valueOfAttribute: 'name' ifAbsent: [''].	^(#MappingUnboundedContentToStructException &lt;&lt; #webservices &gt;&gt; 'Mapping complex type: &lt;1s&gt; with unbounded content (sequence or group) to Struct is not supported. If you resume the exception the type will be mapped to a Smalltalk class named: &lt;1s&gt;.') expandMacrosWith: name</body></methods><methods><class-id>WebServices.MappingUnboundedContentToStruct</class-id> <category>constants</category><body package="XMLSchemaMapping">defaultResumeValue	^#object</body></methods><methods><class-id>WebServices.SimpleTypeMaxExclusiveHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeMaxExclusiveNode: self element with: anElement</body></methods><methods><class-id>WebServices.WSSAXDriver</class-id> <category>content handler</category><body package="XMLSchemaMapping">startElement: namespaceURI localName: localName qName: name attributes: attributes	super startElement: namespaceURI localName: localName qName: name attributes: attributes.	self processAttributes: attributes.</body></methods><methods><class-id>WebServices.WSSAXDriver</class-id> <category>private</category><body package="XMLSchemaMapping">processAttributes: aCollection	| types |	types := #( 'ref' 'type' 'base' 'itemType' 'value' ).	aCollection do: 		[ :attribute | 		( types includes: attribute tag type )			ifTrue: [ attribute userData: ( self processQName: attribute value)]]</body><body package="XMLSchemaMapping">processQName: aName	| idx qualifier local ns |	(aName includes: $:)		ifFalse:			[(ns := stack last namespaceAtQualifier: '' ifAbsent: [stack last targetNamespace]) ifNil: [ ^nil ].			^NodeTag new qualifier: '' ns: ns type: aName].	idx := aName indexOf: $:.	qualifier := aName copyFrom: 1 to: idx-1.	local := aName copyFrom: idx+1 to: aName size.	ns := stack last namespaceAtQualifier: qualifier ifAbsent: [nil]. 	^NodeTag new qualifier: qualifier ns: ns type: local</body></methods><methods><class-id>WebServices.WSSAXDriver class</class-id> <category>instance creation</category><body package="XMLSchemaMapping">on: aDataSource	^(XMLParser on: aDataSource)		validate: false;		saxDriver: self new;		scanDocument.</body></methods><methods><class-id>WebServices.ElementHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	aVisitor acceptElementTypeNode: self element with: anElement</body></methods><methods><class-id>WebServices.SimpleTypeMinExclusiveHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptSimpleTypeMinExclusiveNode: self element with: anElement</body></methods><methods><class-id>WebServices.IncludeHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptIncludeNode: self element with: anElement</body></methods><methods><class-id>WebServices.ChoiceHandler</class-id> <category>visiting</category><body package="XMLSchemaMapping">acceptVisit: aVisitor with: anElement	^aVisitor acceptChoiceTypeNode: self element with: anElement</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>DOM_SAXDriver</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack document newNamespaces stateForCDATA </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class></st-source>