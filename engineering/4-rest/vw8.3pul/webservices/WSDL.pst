<?xml version="1.0"?><st-source><!-- Name: WSDLNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.BundleName: WSDLBundleStructure: a Store.BundleForParcelComment: Provides support for the WSDL 1.1 and 2.0 spec. The WSDL framework enables you to load WSDL schema,  create a SOAP message based on this schema, send the message to the service provider and unmarshal the received result.The class that provides all Web services message exchange is WsdlClient. For more information see WsdlClient class commentsTo create and run Soap server you need to load SOAP-Server package.DevelopmentPrerequisites: #(#(#any 'HTTP' '') #(#any 'XMLObjectMarshalers' '') #(#any 'Tools-Settings-VW' ''))Parcel: nilParcelName: WSDLPrerequisiteDescriptions: #(#(#name 'HTTP' #componentType #package) #(#name 'XMLObjectMarshalers' #componentType #package) #(#name 'Tools-Settings-VW' #componentType #package))PrerequisiteParcels: #(#('HTTP' '') #('XMLObjectMarshalers' '') #('Tools-Settings-VW' ''))Version: 8.3 - 2Date: 2:31:38 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:38 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NoWsdlSchemaError</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.NoWsdlSchemaError</class-id><body>This error is raised on the client in response to a ?wsdl query when the server doesn't have the WSDL document available.</body></comment><class><name>WsdlComponentDescriptor</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.WsdlComponentDescriptor</class-id><body>WsdlComponentDescriptor is a superclass for  Wsdl schema componentsInstance Variables:	documentation	&lt;String&gt;	documentation </body></comment><class><name>Wsdl20SoapOperationParameterDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageLabel soapHeaders soapModule httpContentEncoding httpHeader name any </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20SoapOperationParameterDescriptor</class-id><body>Represents WSDL 2.0 Soap binding operation parameter descriptor.&lt;input messageLabel="xs:NCName"...&gt;&lt;output messageLabel="xs:NCName"..&gt;Instance Variables	messageLabel	&lt;String&gt; messageLabel	soapHeaders	&lt;OrderedCollection of Wsdl20SoapHeaderDescriptor&gt; soapHeader	soapModule	&lt;Struct&gt; soapModule	httpContentEncoding	&lt;String&gt; description of httpContentEncoding	httpHeader	&lt;Struct&gt; httpHeader	name	&lt;String&gt; 	any	&lt;Strring&gt; </body></comment><class><name>SoapMessage</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkEntity accessPoint binding operation transportEntity header dom transport processingPolicy interceptorDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapMessage</class-id><body>SoapMessage is the super class for the soap request/response.Subclasses must implement the following messages:	marshaling		marshalerInstance Variables	smalltalkEntity	&lt;Message&gt;	 requested service message with parameters	accessPoint	&lt;String&gt;	server access point (URI asString)	binding	&lt;WsdlBinding&gt;	SOAP to VW Smalltalk binding	operation	&lt;SoapOperationBinding&gt;	soap operation	transport &lt;TransportBinding&gt; transport binding	transportEntity	&lt;HttpEntity&gt;	instance of the Http response	header	&lt;SoapHeader&gt;	message header	dom	&lt;XML.Element&gt;	 message XML element</body></comment><class><name>WsdlBindingDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name soapTransportBinding operations interfaceDescriptor protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.WsdlBindingDescriptor</class-id><body>WsdlBindingDescriptor is a super class for binding/operation binding descriptorsInstance Variables	name	&lt;NodeTag&gt; description of name	soapTransportBinding	&lt;SoapTransportBinding&gt; description of soapTransportBinding	operations	&lt;OrderedCollection&gt; description of operations	interfaceDescriptor	&lt;WsdlInterfaceDescriptor&gt; description of interfaceDescriptor	protocol	&lt;String&gt; description of protocol</body></comment><class><name>Wsdl11OperationParameterDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type message key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11OperationParameterDescriptor</class-id><body>Represents &lt;input&gt;/&lt;output&gt; elements with &lt;operation&gt; parent in WsdlInstance Variables	name	&lt;String&gt; name	type	&lt;String&gt; part type	message	&lt;WsdlMessagePartDescriptor&gt; 	key	&lt;String&gt; </body></comment><class><name>ClientInterceptorDispatcher</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policy interceptors requestHeader headerEntries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.ClientInterceptorDispatcher</class-id><body>The class maintains a sequence of interceptors that are invoked for each SOAP header block. Instance Variables	headerEntries	&lt;Collection of: SoapHeaderEntry&gt; unmarshaled request header entries	policy	&lt;SoapProcessingPolicy&gt; 	interceptors	&lt;OrderedCollection of: SoapMessageInterceptor&gt; 	requestHeader	&lt;Collection of: XML.Element&gt; caches the request header on the client side and the header elements on the server side</body></comment><class><name>Wsdl20HttpHeaderDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name targetNamespace type required </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20HttpHeaderDescriptor</class-id><body>Represents Http Header descriptorInstance Variables	type	&lt;NodeTag&gt;	 type reference	name	&lt;String&gt;	#name attribute	required	&lt;Boolean&gt;	#required attribute	targetNamespace	&lt;String&gt; targetNamespace</body></comment><class><name>Wsdl11MessageEncodingDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name namespace use encodingStyle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11MessageEncodingDescriptor</class-id><body>Represents &lt;faultType&gt; element in Wsdl 1.1Instance Variables	name	&lt;String&gt; fault type name	namespace	&lt;URI&gt; namespace	use	&lt;String&gt; 'encoded'/'literal' specifies how the XML will be encoded into SOAP messages: literally, or by following the SOAP specification encoding	encodingStyle	&lt;String&gt; string  that defines encoding style</body></comment><class><name>SoapFault</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code detail source message role </inst-vars><class-inst-vars>faultCodes </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapFault</class-id><body>SoapFault represents a special Soap element containing fault information generated by a Soap server. Usually it indicates that the server was not able to parse the message body.Instance Variables	code	&lt;String&gt; SOAP fault code	detail	&lt;String&gt; carrying application specific error information related to the SOAP Body	source	&lt;XML.Element&gt; raw XML element   &lt;Fault&gt;	message	&lt;Message&gt; the operation message the fault was raised from	role	&lt;String&gt; roleClass Instance Variables	faultCodes	&lt;Dictionary&gt; currently supported Soap Fault codes</body></comment><class><name>Soap12Fault</name><environment>WebServices</environment><super>WebServices.SoapFault</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reason node header </inst-vars><class-inst-vars>language </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.Soap12Fault</class-id><body>Soap12Fault is specific to SOAP 1.2 protocol fault codesInstance Variables	reason	&lt;Struct&gt; provides a human-readable explanation of the fault. The Struct has the #texts entry which is collection of Struct's. The text struct includes #text (String type) and #lang (String type). The #lang values are defined in  ftp://ftp.isi.edu/in-notes/bcp/bcp47.txt	node	&lt;String&gt; SOAP node on the SOAP message path caused the fault to happen (http://www.w3.org/TR/soap12-part1/#msgexchngmdl)	header	&lt;WebServices.Struct&gt; key: header name, value: an objectClass Instance Variables	language	&lt;String&gt; sets the attribute:   xml:lang='en'</body></comment><class><name>MustUnderstandFault</name><environment>WebServices</environment><super>WebServices.Soap12Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.MustUnderstandFault</class-id><body>Raised if an immediate child element information item of the SOAP Header element information item targeted at the faulting node that was not understood by the faulting node contained a SOAP mustUnderstand attribute information item with a value of "true" (see 5.2.3 SOAP mustUnderstand Attribute and 5.4.8 SOAP mustUnderstand Faults)</body></comment><class><name>WsdlInterfaceDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name operations styleDefault extends faults serviceMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.WsdlInterfaceDescriptor</class-id><body>Represents &lt;interface&gt; and &lt;portType&gt;  components in  WSDLInstance Variables	name	&lt;XML.NodeTag&gt; maps the attribute 'name'	operations	&lt;OrderedCollection of: WsdlOperationDescriptor&gt; maps the 'operation' elements	styleDefault	&lt;String&gt; maps default interface style (http://www.w3.org/TR/2007/REC-wsdl20-adjuncts-20070626/#styles)	extends	&lt;NodeTag&gt; maps  interfaces that this interface derives from	faults	&lt;Collection of: Struct &gt; maps interface fault elements	serviceMap	&lt;ServiceMap&gt; maps  service class methods to interface operations</body></comment><class><name>SoapBodyStruct</name><environment>WebServices</environment><super>WebServices.Struct</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapBodyStruct</class-id><body>This class represents SOAP body.</body></comment><class><name>SoapBodyMarshaler</name><environment>WebServices</environment><super>WebServices.AnyRelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapBodyMarshaler</class-id><body>BodyMarshaler represents marshaler for the Soap body. While unmarshaling it attempts to unmarshal the message based on the WSDL schema. If it fails, it tries to use the inline type (xsi:type) if it is present.</body></comment><class><name>Soap11Fault</name><environment>WebServices</environment><super>WebServices.SoapFault</super><private>false</private><indexed-type>none</indexed-type><inst-vars>faultString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.Soap11Fault</class-id><body>Soap11Fault is specific to SOAP 1.1 protocolInstance Variables	faultString	&lt;String&gt; fault description</body></comment><class><name>SoapBinding</name><environment>WebServices</environment><super>WebServices.XMLObjectBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapBinding</class-id><body>SoapBinding loads all soap related marshalers</body></comment><class><name>Wsdl11PortDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name binding address version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11PortDescriptor</class-id><body>Represents &lt;portType&gt; element in  WSDL 1.1  Instance Variables	name	&lt;XML.NodeTag&gt; maps the 'name' attribute	binding	&lt;WsdlBinding&gt; maps the   'binding' attribute	address	&lt;String&gt; maps the 'location' attribute from the element 'soapAddress'	version	&lt;String&gt; Soap spec version</body></comment><class><name>DataEncodingUnknownFault</name><environment>WebServices</environment><super>WebServices.Soap12Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.DataEncodingUnknownFault</class-id><body>DataEncodingUnknownFault is raised if a SOAP header block or SOAP body child element information item targeted at the faulting SOAP node is scoped (see 5.1.1 SOAP encodingStyle Attribute) with a data encoding that the faulting node does not support.</body></comment><class><name>Wsdl11SoapOperationEnvelopeDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soapHeader soapBody urlEncoded version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11SoapOperationEnvelopeDescriptor</class-id><body>Represents &lt;input&gt; and  &lt;output&gt; elements in the WSDL 1.1 schema Operation binding element. The element specifies how the message parts appear inside the SOAP Envelope element.Instance Variables	soapBody	&lt;Wsdl11SoapBodyPartDescriptor&gt;	Soap 1.1 or 1.2 Body	soapHeader	&lt;Collection of Wsdl11SoapHeaderDescriptor&gt;	Soap 1.1 or 1.2 Header	urlEncoded	&lt;String&gt;	description of urlEncoded	version	&lt;String&gt;	Soap version 1.1 or 1.2</body></comment><class><name>WsdlClient</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>port config wsdlUrl accessPoint header request response responseValue transport processingPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlClient</class-id><body>Class WsdlClient makes it easy to use Web services defined by the WSDL protocol. The class is superclass for WSDL specific clients created by WS tool.Instance Variables	port	&lt;WsdlPort&gt; instance of WsdlPort. If the port is not specified to execute request the first Wsdl schema port will be used	config	&lt;WsdlConfiguration&gt; instance of WsdlConfiguration	wsdlUrl	&lt;URI&gt; URI - the Wsdl schema location	accessPoint	&lt;HttpURL&gt; service access point	header	&lt;SoapHeader&gt; soap message header	request	&lt;SoapRequest&gt; soap request	response	&lt;SoapResponse&gt; soap response	responseValue	&lt;Object&gt; response value	transport	&lt;HttpClient&gt; transport	processingPolicy	&lt;ClientProcessingPolicy&gt; extends message processing for SOAP messagesOverviewThe class is Web services client that communicates with a server by sending and receiving SOAP messages.UsageFor details on using the client, see Web Services documentation.There are two usages of WsdlClient class. The class can be used as a client. For example:The WsdlClient loads WSDL schema for a given resource, creates default X2O binding.  If the WSDL schema includes the schema-defined data types (&lt;schema&gt;), class WsdlClient creates an XML-to-Smaltalk binding element &lt;schemaBindings&gt;. By default, all XML complexType elements are mapped to Smalltalk Dictionary objects.	client := WsdlClient url: 'http://www.someserver/services'.The client  marshals the web services parameters in to SOAP nessages and  sends a SOAP request and receives a SOAP response using HttpClient as a transport.	val := client executeSelector: #echoString args: #('ABc12')The WsdlClient class is used as subclass for a clients that handle specific WSDL schemas. This clients can be created using Web services tools. The specific client has to have the following methods:Class methods:#wsdlSchema - returns WSDL as a string or URL to WSDL schema. If WSDL has &lt;import&gt; statements the method has to provide URL which will be base URL to resolve &lt;import&gt; location URL's#x2oBinding - the method returns X2O binding string. The binding maps XML schema complex types to Smalltalk classes.#serviceMap - the method returns service map as a string. The service map binds a service class selectors with WSDL interface operations.#bindingName and # bindingTargetNamespace - the WSDL &lt;binding&gt; name and target namespace  that the client serves#processingPolicy - it is optional. The method can provide a processing policy with interceptors. The interceptors callback allow to expand the SOAP message processing. For example SOAP headers and aatachments can be added in interceptor callbacks.Instance methods: 	The methods are wrappers to call web services operations. For example TimeClient implements asTimestamp: as:asTimestamp: aTime 		^self executeSelector: #AsTimestamp args: (Array with: aTime)ImplementationThe client loads WSDL and registers parsed object in a few global registries. For example WsdlBinding.WsdlBindings holds all Wsdl binding. When a specific client is created the registries are checked if there is already WsdlBinding for this client. If there is no such binding the client will use #wsdlSchema to initialize registries.Using Http client as a transport allows to use persistent connection and authentication provided by HTTP framework.Handling SOAP headers and attchment can be done via processing policy interceptors. Examples:Execute operation: #echoString 	client := WsdlClient url: 'http://www.someserver/services'.	val := client executeSelector: #echoString args: #('ABc12')Persistent connection:	client := WsdlClient url: 'http://www.someserver/services'.	client connectToHost: 'www.someserver'.	[client executeSelector: #echoInteger args: #(123).	client executeSelector: #echoString args: #('ABc 46')]		ensure: [client close].Running client on a port different than WSDL SOAP address port:&lt;port name="TimeNowService" binding="tns:TimeNowService"&gt;	&lt;soap:address location="http://localhost:4950/TimeNowService"/&gt;&lt;/port&gt;	TimeServer defaultStart.	TimeServer default resetPortAt:  'localhost:4950' to: 4955.       val :=   ( client := TimeClient new )				setServerPortTo: 4955;				timeNow.	TimeServer defaultStop.    </body></comment><class><name>SoapHeaderEntryMarshaler</name><environment>WebServices</environment><super>WebServices.ComplexObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valueMarshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapHeaderEntryMarshaler</class-id><body>SoapHeaderEntryMarshaler marshal XML soap header to SoapHeaderEntry and visa versa.Instance Variables	valueMarshaler	&lt;XMLTypeMarshaler&gt; </body></comment><class><name>Wsdl20SoapHeaderDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element mustUnderstand required </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20SoapHeaderDescriptor</class-id><body>Represents Soap Header descriptorInstance Variables	element	&lt;NodeTag&gt;	 element reference	mustUnderstand	&lt;Boolean&gt;	#mustUnderstand attribute	required	&lt;Boolean&gt;	#required attribute</body></comment><class><name>ClientProcessingPolicy</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcherClass interceptorClasses adaptor processOptionalHeaders </inst-vars><class-inst-vars>defaultDispatcherClass defaultInterceptorClasses defaultProcessOptionalHeaders </class-inst-vars><imports></imports><category></category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.ClientProcessingPolicy</class-id><body>The processing policy extends message processing for SOAP messages sent by WsdlClient.  The only supported role for the Soap server is ultimate receiver.Instance Variables	dispatcherClass	&lt;SoapInterceptorDispatcher&gt; description of dispatcherClass	interceptorClasses	&lt;Collection of SoapMessageInterceptor&gt; description of interceptorClasses	adaptor	&lt;BasicObjectAdaptor&gt; 	processOptionalHeaders	&lt;Boolean&gt; should we unmarshal optional headers that came with the attribute "mustUnderstand="false" ?Class Instance Variables	defaultDispatcherClass	&lt;SoapInterceptorDispatcher&gt; 	defaultInterceptorClasses	&lt;OrderedCollection&gt; 	defaultProcessOptionalHeaders	&lt;Boolean&gt; should we unmarshal optional headers ? Default is false.</body></comment><class><name>WsdlConfiguration</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>imports bindings services name descriptor rebuildX2OBinding </inst-vars><class-inst-vars>rebuildX2OBinding </class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlConfiguration</class-id><body>Class WsdlConfiguration uses a WsdlConfigurationDescriptor to build the configuration file that provides all necessary information to create and  invoke a SOAP message.Instance Variables	imports	&lt;Collection of: XMLObjectBinding&gt; binding imports	bindings	&lt;OrderedCollection of: WsdlBindings&gt; bindings	services	&lt;SequenceableCollection of: WsdlService&gt; services	name	&lt;String&gt; Wsdl schema name	descriptor	&lt;WsdlConfigurationDescriptor&gt; 	rebuildX2OBinding	&lt;Boolean&gt; if set to false the configuration will try to find XMLObjectBinding instance in the registry instead of rebuilding from X2O specClass Instance Variables	rebuildX2OBinding	&lt;Boolean&gt;  default value</body></comment><class><name>Wsdl11Configuration</name><environment>WebServices</environment><super>WebServices.WsdlConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.Wsdl11Configuration</class-id><body>Wsdl11BindingBuilder parses and builds WsdlConfiguration for Wsdl 1.1 schema</body></comment><class><name>SoapRequest</name><environment>WebServices</environment><super>WebServices.SoapMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapRequest</class-id><body>SoapRequest marshal, execute and unmarshal a Soap request. The class has #transportClient API to set persistent connection.Examples:Soap 1.1	request := WebServices.SoapRequest new		binding: aWsdlBinding;		accessPoint:  aWsdlBinding port address;		smalltalkEntity: (Message 				selector: #convert:from:to:measure:				arguments: #(5.0d 'cm' 'in' 'length'));		yourself. 	(request headerFor: #authenticationToken)		value: ( Struct new				username: 'good user';				password: 'good password';				yourself).	result := request execute; value.Soap 1.2	request := WebServices.SoapRequest new		binding: aWsdlBinding;		accessPoint:  aWsdlBinding port address;		smalltalkEntity: (Message 				selector: #convert:from:to:measure:				arguments: #(5.0d 'cm' 'in' 'length'));		yourself. 	(request headerFor: #AuthenticationToken)		value: ( Struct new				username: 'good user';				password: 'good password';				yourself).	result := request execute; value.</body></comment><class><name>OperationBinding</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transport inputBodyMarshaler outputBodyMarshaler binding descriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.OperationBinding</class-id><body>OperationBinding is an abstract class that provides marshalers for the remote service operation.Instance Variables	transport	&lt;TransportBinding&gt; 	inputBodyMarshaler	&lt;SoapParameterBinding&gt; request body marshaler	outputBodyMarshaler	&lt;SoapParameterBinding&gt; response body marshaler	binding	&lt;WsdlBinding&gt; 	descriptor	&lt;WsdlOperationBindingDescriptor&gt; </body></comment><class><name>SoapOperationBinding</name><environment>WebServices</environment><super>WebServices.OperationBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>rpcResultAsStruct </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapOperationBinding</class-id><body>SoapOperationBinding is a super class for Soap operation bindingsSubclasses must implement the following messages:	marshal request		inputHeaderBindings		marshalRequestWith:header:		unmarshalRequest:	marshal response		marshalResponseWith:header:		outputHeaderBindings		unmarshalResponse:	testing		isRpcClass Instance Variables	rpcResultAsStruct	&lt;Boolean&gt; should we return an RPC result as a Struct</body></comment><class><name>UserHeaderError</name><environment>WebServices</environment><super>WebServices.Soap11Fault</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			WebServices.*			</imports><category>Opentalk-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.UserHeaderError</class-id><body>Signals errors during Soap 1.1 header processing. It's raised by message interceptors. </body></comment><class><name>MessageBinding</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace style structMarshaler partMarshalers structName isWrapped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.MessageBinding</class-id><body>The class is a super class for Wsdl 1.1 and 2.0 binding marshalers. This class knows how to build marshalers and prepare arguments to marshal SOAP requests.Instance Variables	namespace	&lt;String&gt; 	style	&lt;String&gt; maps style attribute	structMarshaler	&lt;ComplexObjectMarshaler&gt; 	partMarshalers	&lt;Collection of: XMLTypeMarshaler &gt; part marshalers	structName	&lt;NodeTag&gt; 	isWrapped &lt;Boolean&gt; defines if the operation marshaler expects parameters wrapped in to Struct</body></comment><class><name>SoapWsdl11PartBinding</name><environment>WebServices</environment><super>WebServices.MessageBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encodingStyle partNames use </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl11PartBinding</class-id><body>SoapWsdl11PartBinding handles SOAP requests described by Wsdl 1.1.For document-style communication body parts appear as direct children of SOAP Body element. Therefore, part marshalers are enough for the job and struct marshaler is not used; so both structName and structMarshaler are nil. For rpc-style communication we need to create a pseudo-struct whose name is the same as name of the body and accessors for individual parts whose names are same as accessor names. In this case we create struct marshaler and populate it with relation marshalers for parts.Instance Variables	encodingStyle	&lt;String&gt; URI that defines encoding style	partNames	&lt;OrderedCollection&gt; For document-style communication a collection of part names in their order of appearance	use	&lt;String&gt; either 'literal' or 'encoded'</body></comment><class><name>SoapMustUnderstandFault</name><environment>WebServices</environment><super>WebServices.Soap11Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapMustUnderstandFault</class-id><body>SoapMustUnderstandFault is raised by the Soap server if the header entry from a soap message has the mustUndertand attribute set to true and there is no header processor for this entry.Instance Variables:	headerName	&lt;NodeTag&gt;	header entry tag</body></comment><class><name>TransportBinding</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>verb action retryExceptions client protocol binding maxRetries </inst-vars><class-inst-vars>retryExceptions maxRetries </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.TransportBinding</class-id><body>TransportBinding is a super class for transport bindings. Responsible for the creation, transmission, and processing of a  message through Http clientSubclasses must implement the following messages:	accessing		operationBindingClassInstance Variables	verb	&lt;String&gt; Http verb	action	&lt;String&gt; action	retryExceptions	&lt;ExceptionSet&gt; retry exceptions	client	&lt;HttpClient&gt; client sends and receives messages	protocol	&lt;String&gt; protocol ('http://www.w3.org/2003/05/soap/bindings/HTTP/')	binding	&lt;WsdlBinding&gt; binding	maxRetries &lt;Number&gt; max number of retries for exceptions from #retryExceptions setClass Instance Variables	retryExceptions	&lt;ExceptionSet&gt; default exceptions set	maxRetries &lt;Number&gt; default max number of retries for exceptions from #retryExceptions set</body></comment><class><name>HttpTransportBinding</name><environment>WebServices</environment><super>WebServices.TransportBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputSerialization outputSerialization faultSerialization ignoreUncited location contentEncoding queryParameterSeparator cookies </inst-vars><class-inst-vars>queryParameterSeparator </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.HttpTransportBinding</class-id><body>Represents Http transport binding in Wsdl schemaInstance Variables	inputSerialization	&lt;String&gt; optional inputSerialization attribute	outputSerialization	&lt;String&gt; optional outputSerialization attribute	faultSerialization	&lt;String&gt; optional faultSerialization attribute	ignoreUncited	&lt;Boolean&gt; 	location	&lt;String&gt; optional location attribute	contentEncoding	&lt;String&gt; optional contentEncoding attribute	queryParameterSeparator	&lt;String&gt; optional queryParameterSeparator attribute	cookies	&lt;Boolean&gt; allows binding components to indicate that HTTP cookies (as defined by [IETF RFC 2965]) are usedClass Instance Variables	queryParameterSeparator	&lt;Strring&gt; Default: '&amp;'</body></comment><class><name>SenderFault</name><environment>WebServices</environment><super>WebServices.Soap12Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SenderFault</class-id><body>Raised if the message was incorrectly formed or did not contain the appropriate information in order to succeed. For example, the message could lack the proper authentication or payment information. It is generally an indication that the message is not to be resent without change (see also 5.4 SOAP Fault  for a description of the SOAP fault detail sub-element).</body></comment><class><name>WsdlPort</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binding address portDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlPort</class-id><body>WsdlPort serves as a registry for ports defined using WSDL 1.1 schemas. Class Instance Variables	PortRegistry 		&lt;Dictionary&gt; 		key: port name value: WsdlPortInstance Variables	binding	&lt;WsdlBinding&gt; instance of  WsdlBinding	address	&lt;URI&gt; service access point	portDescriptor	&lt;WsdlPortDescriptor&gt; port descriptorShared Variables	PortRegistry	&lt;Dictionary&gt; key: the port name value: an instance of WsdlPort or WsdlInterface</body></comment><class><name>WsdlInterface</name><environment>WebServices</environment><super>WebServices.WsdlPort</super><private>false</private><indexed-type>none</indexed-type><inst-vars>faults </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlInterface</class-id><body>WsdlInterface serves as a registry for interfaces defined using WSDL 2.0 schemas. Instance Variables	faults	&lt;Collection of: SoapWsdl20FaultBinding&gt; </body></comment><class><name>ReceiverFault</name><environment>WebServices</environment><super>WebServices.Soap12Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.ReceiverFault</class-id><body>Raised if the message could not be processed for reasons attributable to the processing of the message rather than to the contents of the message itself. For example, processing could include communicating with an upstream SOAP node, which did not respond. The message could succeed if resent at a later point in time (see also 5.4 SOAP Fault  for a description of the SOAP fault detail sub-element).</body></comment><class><name>SoapWsdl20MessageBinding</name><environment>WebServices</environment><super>WebServices.MessageBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headers elementType operationBinding </inst-vars><class-inst-vars></class-inst-vars><imports>			private WebServices.*			</imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl20MessageBinding</class-id><body>SoapWsdl20MessageBinding handles SOAP requests described by Wsdl 2.0Instance Variables	headers	&lt;Collection of: SoapWsdl20HeaderBinding&gt; header marshalers	elementType	&lt;NodeTag&gt; XML type	operationBinding	&lt;SoapWsdl20OperationBinding&gt; parent</body></comment><class><name>SoapClientFault</name><environment>WebServices</environment><super>WebServices.Soap11Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapClientFault</class-id><body>SoapClientFault indicates that the message was incorrectly formed or did not contain the appropriate information in order to succeed. For example, the message could lack the proper authentication or payment information. It is generally an indication that the message should not be resent without change.</body></comment><class><name>SoapServerFault</name><environment>WebServices</environment><super>WebServices.Soap11Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapServerFault</class-id><body>This type of fault indicates that the message could not be processed for reasons not directly attributable to the contents of the message itself but rather to the processing of the message. For example, processing could include communicating with an upstream processor, which didn't respond. The message may succeed at a later point in time.</body></comment><class><name>UserHeader12Error</name><environment>WebServices</environment><super>WebServices.Soap12Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.UserHeader12Error</class-id><body>Reraised if any error accurs while processing Soap 1.2 header entries</body></comment><class><name>SoapException</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapException</class-id><body>Raised in case of the soap server  and socket errors.</body></comment><class><name>WsdlConfigurationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetNamespace imports interfaces bindings services schemaBindings types buildOptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.WsdlConfigurationDescriptor</class-id><body>Represents parsed a WSDL schema components. To create the components the class scans a Wsdl schema with imports and creates XML Object Binding for the schema types.Instance Variables	targetNamespace	&lt;String&gt; maps the 'targetNamespace' attribute	imports	&lt;Collection of: BindingImport&gt; provides components from other namespaces	interfaces	&lt;Collection of: WsdlInterfaceDescriptor&gt; maps the 'portType' element	bindings	&lt;Collection of: WsdlBindingDescriptor&gt; maps the 'binding' element	services	&lt;Collection of: WsdlServiceDescriptor&gt; maps the 'services' element	schemaBindings	&lt;Collection of: XMLObjectBinding&gt; maps the 'schemaBindings' element	types	&lt;Collection of XML.Element&gt; XML schema types	buildOptions	&lt;WsdlBuildOptions&gt; options to build a descriptor</body></comment><class><name>Wsdl11ConfigurationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlConfigurationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages soapEncoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id><body>Represents parsed a WSDL 1.1 schema componentsInstance Variables	messages	&lt;Collection of: Wsdl11MessageDescriptor&gt; maps the 'message' element	soapEncoding	&lt;String&gt; encoding url string</body></comment><class><name>SoapResponse</name><environment>WebServices</environment><super>WebServices.SoapMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapResponse</class-id><body>SoapResponse unmarshal the Soap response. Value returns the value of the Soap message body or SoapFault if the server failed to parse the request.Instance Variables	request	&lt;SoapRequest&gt; instance of Soap request</body></comment><class><name>Wsdl20BindingDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlBindingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>faults type httpTransportBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20BindingDescriptor</class-id><body>Represents &lt;binding&gt; element in  Wsdl 2.0 schemaInstance Variables	faults	&lt;Collection of: Struct&gt; faults	type	&lt;String&gt; type	httpTransportBinding	&lt;HttpTransportBinding&gt; httpTransportBinding</body></comment><class><name>Wsdl20Configuration</name><environment>WebServices</environment><super>WebServices.WsdlConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.Wsdl20Configuration</class-id><body>Wsdl11BindingBuilder parses and builds WsdlConfiguration for Wsdl 2.0 schema</body></comment><class><name>Wsdl11SoapBodyPartDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parts namespace use encodingStyle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11SoapBodyPartDescriptor</class-id><body>Represents &lt;soap:body&gt; element in the WSDL 1.1 schema Operation element. The element specifies how the message parts appear inside the SOAP Body element.Instance Variables	parts	&lt;OrderedCollection of: String&gt; maps the 'parts'  attribute	namespace	&lt;URI&gt; maps the 'namespace' attribute	use	&lt;String&gt; maps the 'use' attribute (can be 'encoded' or 'literal')	encodingStyle	&lt;URI&gt; maps the 'encodingStyle' attribute</body></comment><class><name>Wsdl11SoapHeaderFaultDescriptor</name><environment>WebServices</environment><super>WebServices.Wsdl11SoapBodyPartDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11SoapHeaderFaultDescriptor</class-id><body>Represents &lt;soap:headerfault&gt; element in the WSDL 1.1 schema Operation part. The soap:headerfault element allows header to be defined that are transmitted inside the Header element of the SOAP Envelope. Instance Variables	message	&lt;WsdlMessageDescriptor&gt; fault message descriptor</body></comment><class><name>SoapTransportBinding</name><environment>WebServices</environment><super>WebServices.TransportBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soapVersion mep soapModule transport pattern </inst-vars><class-inst-vars>defaultSoapActionBlock </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapTransportBinding</class-id><body>SoapTransportBinding is responsible for the creation, transmission, and processing of a SOAP message through Http clientInstance Variables	soapVersion	&lt;String&gt; 1.1 or 1.2	mep	&lt;String&gt; message exchange pattern as it defined by Soap 1.2 . For example: http://www.w3.org/2003/05/soap/mep/request-response/	soapModule	&lt;String&gt; SOAP Module component	transport	&lt;TransportBinding&gt; 	pattern	&lt;String&gt; as defined by Wsdl 2.0 for example:  'http://www.w3.org/ns/wsdl/in-only'Class Instance Variables	defaultSoapActionBlock	&lt;BlockClosure&gt; default action block. The default block returns a Soap message operation name as  value of  'Content-type' field action parameter</body></comment><class><name>WsdlInterfaceOperationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name input output faults style selector pattern </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id><body>The class describes an interface operation. Represents  &lt;operation&gt; element with &lt;interface&gt; parent in Wsdl 2.0Instance Variables	name	&lt;String&gt; operation name	input	&lt;Struct&gt; input descriptor	output	&lt;Struct&gt; output  descriptor	faults	&lt;Collection of: Struct&gt; faults descriptions	style	&lt;String&gt; interface style	selector	&lt;Symbol&gt; operation selector	pattern	&lt;String&gt;  pattern</body></comment><class><name>Wsdl11InterfaceOperationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlInterfaceOperationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11InterfaceOperationDescriptor</class-id><body>Represents  &lt;operation&gt; element with &lt;portType&gt; parent in Wsdl 1.1Instance Variables	parameterOrder	&lt;OrderedCollection of: String&gt; maps the 'parameterOrder' attribute</body></comment><class><name>Wsdl20InterfaceOperationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlInterfaceOperationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outfaults rpcSignature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20InterfaceOperationDescriptor</class-id><body>Represents &lt;operation&gt; element with &lt;interface&gt; parent in  Wsdl 2.0Instance Variables	outfaults	&lt;Collection of: Struct&gt; outfaults description	rpcSignature	&lt;String&gt; rpcSignature attribite	pattern	&lt;String&gt; mep attribute</body></comment><class><name>Wsdl11SoapHeaderDescriptor</name><environment>WebServices</environment><super>WebServices.Wsdl11SoapHeaderFaultDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>faults version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11SoapHeaderDescriptor</class-id><body>Represents &lt;soap:header&gt; element in the WSDL 1.1 schema Operation element. The 'soap:header' element allows header to be defined that are transmitted inside the Header element of the SOAP Envelope. Not implemented yetInstance Variables	faults	&lt;OrderedCollection of: SoapFault&gt; header faults	version	&lt;String&gt; Soap spec version</body></comment><class><name>SoapHeaderEntry</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mustUnderstand value name anyAttribute </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapHeaderEntry</class-id><body>SoapHeaderEntry is a superclass for Soap 1.1 and 1.2 header entriesInstance Variables	mustUnderstand	&lt;Boolean&gt; mustUnderstand attribute	value	&lt;Object&gt; the header entry contents	name	&lt;NodeTag&gt; header entry node tag	anyAttribute	&lt;Collection of: Object&gt; objects unmarshaled by AnyAttributeMarshaler</body></comment><class><name>Soap12HeaderEntry</name><environment>WebServices</environment><super>WebServices.SoapHeaderEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>role relay encodingStyle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.Soap12HeaderEntry</class-id><body>Soap12HeaderEntry implements Soap 1.2 header entry.Instance Variables	role	&lt;String&gt; role attribute	relay	&lt;String&gt; relay attribute	encodingStyle	&lt;String&gt; encodingStyle attribute</body></comment><class><name>VersionMismatchFault</name><environment>WebServices</environment><super>WebServices.Soap12Fault</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.VersionMismatchFault</class-id><body>Raised if the faulting node found an invalid element information item instead of the expected Envelope element information item. The namespace, local name or both did not match the Envelope element information item required by this recommendation (see 2.8 SOAP Versioning Model and 5.4.7 VersionMismatch Faults)</body></comment><class><name>Wsdl20OperationBindingDescriptor</name><environment>WebServices</environment><super>WebServices.Wsdl20BindingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output outfaults soapOperationDescriptor parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20OperationBindingDescriptor</class-id><body>Represents &lt;operation&gt; element with &lt;binding&gt; parent in  Wsdl 2.0 Instance Variables	input	&lt;WsdlMessageBinding&gt; input description	output	&lt;WsdlMessageBinding&gt; output description	outfaults	&lt;WsdlFaultBinding&gt; outfaults description	soapOperationDescriptor	&lt;Struct&gt; soap operation descriptor	parent	&lt;WsdlBindingDescriptor&gt; description of parent</body></comment><class><name>NoOperationBindingException</name><environment>WebServices</environment><super>WebServices.SoapException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.NoOperationBindingException</class-id><body>Raised if no operation is defined for the first node tag in a soap body.</body></comment><class><name>SoapEnvelope</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header body </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapEnvelope</class-id><body>SoapEnvelope represents the &lt;Envelope&gt; element. It has one or two child elements: &lt;Header&gt; and &lt;Body&gt;. Instance Variables	header	&lt;SoapHeader&gt; instance of SoapHeader	body	&lt;SoapBodyStruct&gt; instance of SoapBodyStruct</body></comment><class><name>SoapWsdl11OperationBinding</name><environment>WebServices</environment><super>WebServices.SoapOperationBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputHeaderBindings inputHeaderMarshaler outputHeaderMarshaler outputHeaderBindings faultMarshalers </inst-vars><class-inst-vars>usePart1InSelector defaultUseOldDocStyleInvocation wrapDocumentLiteralResult </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl11OperationBinding</class-id><body>SoapWsdl11OperationBinding provides Wsdl 1.1 marshalers for the remote service operation.Instance Variables	inputHeaderBindings	&lt;Collection of: SoapHeaderBinding&gt; 	inputHeaderMarshaler	&lt;SoapHeaderMarshaler&gt; request header marshaler	outputHeaderMarshaler	&lt;SoapHeaderMarshaler&gt; response header marshaler	outputHeaderBindings	&lt;Collection of: SoapHeaderBinding&gt; 	faultMarshalers	&lt;Collection of: XMLTypeMarshalers&gt; fault marshalersClass Instance Variables	usePart1InSelector	&lt;Boolean&gt; specifies whether or not the name of the first part of the operation will be included in the operation selector. For example: operation #getRate has parts: Country1 and Country2,  the operation selector will be #getRateCountry1:country2:	defaultUseOldDocStyleInvocation	&lt;Boolean&gt; should we return the document-style result as a Struct	wrapDocumentLiteralResult	&lt;Boolean&gt; This option defines how to return results in document/literal style, bare or wrapped in a collection. The latter form used to be the behavior in previous releases. This option allows to restore the backward compatible behavior</body></comment><class><name>RPCReturnEncoder</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.RPCReturnEncoder</class-id><body>RPCReturnEncoder marshals RPC result node.  A non-void return value is represented by a terminal node with a local name of result and a namespace name of "http://www.w3.org/2003/05/soap-rpc" which terminates in a terminal node. The type of that terminal node is a xs:QName and its value is the name of the node which terminates in the actual return value.</body></comment><class><name>SoapHeader</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerEntries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapHeader</class-id><body>SoapHeader represents the Soap header element &lt;Header&gt;. Instance Variables	headerEntries	&lt;Collection of SoapHeaderEntry&gt; soap header entries</body></comment><class><name>SoapWsdl11HeaderBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl11PartBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>faults excMarshalers tags faultTags entryMarshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl11HeaderBinding</class-id><body>SoapHeaderMarshaler builds Soap header entry marshalers for an operation.Instance Variables	faults	&lt;(Collection of: SoapParameterMarshaler) &gt; faults	excMarshalers	&lt;Dictionary&gt; exception marshalers dictionary; key: an exception class, value: SoapParameterMarshaler	tags	&lt;Collection of: NodeTag&gt; operation header entry tags	faultTags	&lt;Collection of: NodeTag&gt; fault tags	entryMarshaler	&lt;XMLTypeMarshaler&gt; Shared Variables	HeadersBeOptional	&lt;Boolean&gt; should the soap headers be optional or mandatory. There is no an attribute in Wsdl 1.1 that provides this information</body></comment><class><name>FaultSubcode</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value subcode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.FaultSubcode</class-id><body>FaultSubcode defines a subcode for Soap12Fault Instance Variables	subcode	&lt;FaultSubcode&gt;	subcode	value	&lt;NodeTag&gt;	 value is an application defined subcategory </body></comment><class><name>SoapWsdl20FaultBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl20MessageBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code subcodes name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl20FaultBinding</class-id><body>SoapWsdl20MessageBinding builds operation fault marshalers described by Wsdl 2.0Instance Variables	code	&lt;NodeTag&gt; code attribute	subcodes	&lt;NodeTag&gt; subcode attribute	name	&lt;NodeTag&gt; fault name</body></comment><class><name>MissingRequiredHeader</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.MissingRequiredHeader</class-id><body>Raised if a required Soap header is missing.</body></comment><class><name>UpgradeHeaderEntry</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportedEnvelopes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.UpgradeHeaderEntry</class-id><body>UpgradeHeaderEntry unmarshals  &lt;env:SupportedEnvelope&gt; Soap header nodeInstance Variables	supportedEnvelopes	&lt;Collection of Struct&gt; key is #qname, value the Soap 1.1 or 1.2 envelope node</body></comment><class><name>Wsdl11BindingDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlBindingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindingType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11BindingDescriptor</class-id><body>Represents &lt;binding&gt; element in  Wsdl 1.1 schema A binding defines the message format and protocol details for operations and messages defined by a particular portTypeInstance Variables	extension	&lt;WsdlExtensionDescriptor&gt; instance of	WsdlExtensionDescriptor (optional)	bindingType	&lt;String&gt; defines the binding type</body></comment><class><name>NotUnderstoodHeaderEntry</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>qname </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.NotUnderstoodHeaderEntry</class-id><body>Created and raised for Soap 1.2 &lt;NotUnderstood&gt;  header fault elements. When a SOAP node generates a fault with a Value of Code set to "env:MustUnderstand", it provides NotUnderstood SOAP header blocks in the generated fault message. The NotUnderstood SOAP header blocks detail the XML qualified names of the particular SOAP header block(s) which were not understood.http://www.w3.org/TR/soap12-part1/#soapnotunderstoodInstance Variables	qname	&lt;NodeTag&gt; not understood node</body></comment><class><name>Wsdl11ServiceDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name ports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11ServiceDescriptor</class-id><body>Represents &lt;service&gt; element in WSDL 1.1 schema Instance Variables	name	&lt;XML.NodeTag&gt; maps the 'name' attribute	ports	&lt;OrderedCollection of: WsdlPortDescriptor&gt; maps the 'port' element for Soap 1.1 and 'endpoint' for Soap 1.2</body></comment><class><name>Wsdl20ServiceDescriptor</name><environment>WebServices</environment><super>WebServices.Wsdl11ServiceDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20ServiceDescriptor</class-id><body>Represents &lt;service&gt; element in WSDL 2.0 schema Instance Variables	interface	&lt;WsdlInterfaceDescription&gt; interface</body></comment><class><name>WsdlEndpointDescriptor</name><environment>WebServices</environment><super>WebServices.Wsdl11PortDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authenticationScheme authenticationRealm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.WsdlEndpointDescriptor</class-id><body>Represents &lt;endpoint&gt; element with &lt;service&gt; parent in WSDL 2.0 Instance Variables	authenticationScheme	&lt;String&gt; HTTP   authenticationScheme attribute	authenticationRealm	&lt;String&gt; HTTP   authenticationRealm attribute</body></comment><class><name>WsdlSchemaLoader</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>documents bindDocuments parser baseURI wsdlServiceDoc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlSchemaLoader</class-id><body>The class is deprecated. Use WsdlConfigurationDescriptor insteadInstance Variables	bindDocuments	&lt;(Collection of XML.Document)&gt;	collection of WSDL and XML to Object binding documents	documents 		&lt;(Collection of: of XML.Document)&gt;	row WSDL document 	parser				&lt;XMLTypesParser&gt;	XMLTypesParser parser to create default(dictionary) or object binding	baseURI 			&lt;URI&gt; base url for a wsdl schema	wsdlServiceDoc 	&lt;XML.Document&gt; first loaded WSDL document. In most cases this is a document with the &lt;service&gt; description.</body></comment><class><name>Wsdl11MessagePartDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name typeName elementName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11MessagePartDescriptor</class-id><body>Represents &lt;part&gt; element with &lt;message&gt; parent in Wsdl 1.1Instance Variables	name	&lt;XML.NodeTag&gt; maps the  'name' attribute	typeName	&lt;XML.NodeTag&gt; maps the 'type' attribute.	elementName	&lt;XML.NodeTag&gt; maps the 'element' attribute</body></comment><class><name>Wsdl20ConfigurationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlConfigurationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id><body>Represents parsed a WSDL 2.0  schema components</body></comment><class><name>WsdlService</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ports serviceDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlService</class-id><body>WsdlService acts as a repository for schema-defined services.Class Instance Variables	ServiceRegistry &lt;Dictionary&gt; key: wsdl service name value: instance of WsdlServiceInstance Variables	name	&lt;String&gt; identifier that the name is unique among Services defined in this document.	ports	&lt;SequenceableCollection of: WsdlPort&gt; ports	serviceDescriptor	&lt;Wsdl11ServiceDescriptor or Wsdl20ServiceDescriptor&gt; descriptorShared Variables	ServiceRegistry	&lt;Dictionary&gt; services registry</body></comment><class><name>Soap12Wsdl11OperationBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl11OperationBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.Soap12Wsdl11OperationBinding</class-id><body>Soap12Wsdl11OperationBinding  provides Wsdl 1.1/SOAP 1.2 marshalers for the remote service operation.</body></comment><class><name>SoapWsdl11HttpBinding</name><environment>WebServices</environment><super>WebServices.SoapTransportBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl11HttpBinding</class-id><body>SoapHttpBindingDescriptor responsible for the creation, transmission, and processing of a SOAP 1.1 described by WSDL 1.1 message through Http client</body></comment><class><name>Soap12Wsdl11HttpBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl11HttpBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.Soap12Wsdl11HttpBinding</class-id><body>Soap12Wsdl11HttpBinding responsible for the creation, transmission, and processing of a SOAP 1.2 message described by WWSDL 1.1  through Http client</body></comment><class><name>SoapMarshalingManager</name><environment>WebServices</environment><super>WebServices.XMLObjectMarshalingManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>selectStartPartBlock </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapMarshalingManager</class-id><body>SoapMarshalingManager serves as a manager during marshaling and unmarshaling Soap messages. Class Instance Variables	selectStartPartBlock	&lt;BlockContext&gt; The default block implements main part (part with Soap body) search in a multipart Soap message. See http://www.w3.org/TR/SOAP-attachments#SOAPMultipart and #selectStartPartBlockDefault method comments</body></comment><class><name>SoapWsdl20HeaderBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl20MessageBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mustUnderstand </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl20HeaderBinding</class-id><body>SoapWsdl20HeaderBinding builds operation header marshalers described by Wsdl 2.0Instance Variables	mustUnderstand	&lt;Boolean&gt; mustUnderstand attribute</body></comment><class><name>SoapWsdl11HeaderFaultBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl11HeaderBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl11HeaderFaultBinding</class-id><body>SoapHeaderMarshaler builds Soap header fault marshalers for an operation.Instance Variables	smalltalkClass	&lt;Class&gt; represents the header  fault class</body></comment><class><name>SoapEmptyBodyException</name><environment>WebServices</environment><super>WebServices.SoapException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapEmptyBodyException</class-id><body>SoapEmptyBodyException is error signaling that after the response unmarshaling  the Soap body is empty</body></comment><class><name>WsdlBinding</name><environment>WebServices</environment><super>WebServices.XMLObjectBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transport operations bindingDescriptor schemaSource faults port idTag refTag headerMarshalers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlBinding</class-id><body>WsdlBinding class serves as a repository of Wsdl schema elements to Smalltalk objects binding information.Class Instance Variables	WsdlBindings &lt;Dictionary&gt; key: WsdlBindings name value: instance of WsdlBindingInstance Variables	transport	&lt;TransportBinding&gt; instance of TransportBinding	operations	&lt;OrderedCollection of: SoapOperationBinding&gt; operations collection	bindingDescriptor	&lt;WsdlBindingDescriptor&gt; Wsdl binding descriptor	schemaSource	&lt;String&gt; the WSDL schema	faults	&lt;Collection of: SoapWsdl20FaultBinding&gt; for Wsdl 2.0	port	&lt;WsdlPort&gt; 	idTag	&lt;NodeTag&gt; the tag defines id attribute. The dafault value is "id"	refTag	&lt;NodeTag&gt; the tag defines href/ref attributes. The default value is "href"Shared Variables	WsdlBindings	&lt;Disctionary&gt; binding registryExamples:aWsdlConfiguration := WsdlBinding loadWsdlBindingFrom: aWsdlSchema  readStream.document := WsdlSchemaLoader defaultReadFrom: aWsdlSchema readStream.aWsdlConfiguration := WsdlBinding loadWsdlBindingFrom: document. </body></comment><class><name>Wsdl11OperationBindingDescriptor</name><environment>WebServices</environment><super>WebServices.Wsdl11BindingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soapOperationDescriptor selector parameterOrder input output faults relativeUriHolder parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11OperationBindingDescriptor</class-id><body>Represents &lt;operation&gt; element with &lt;binding&gt; parent in Wsdl 1.1Instance Variables	soapOperationDescriptor	&lt;Struct&gt; 	selector	&lt;String&gt; maps  the 'selector' attribute	parameterOrder	&lt;Collection of: Strings&gt; maps attribute 'parameterOrder'	input	&lt;Dictionary&gt; maps the  'input' element -- key: #soapBody;  value: WsdlSoapBodyPartDescriptor	output	&lt;Dictionary&gt; maps the 'output' element -- key: #soapBody;  value: WsdlSoapBodyPartDescriptor	faults	&lt;(Collection of: Dictionary)&gt; key: #name; value: fault element name	relativeUriHolder	&lt;ValueHolder&gt; relativeUriHolder	parent	&lt;WsdlBindingDescription&gt; </body></comment><class><name>SoapHeaderMarshaler</name><environment>WebServices</environment><super>WebServices.ComplexObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.SoapHeaderMarshaler</class-id><body>SoapHeaderMarshaler marshals/unmarshals an instance of  SoapHeader </body></comment><class><name>Soap11HeaderEntry</name><environment>WebServices</environment><super>WebServices.SoapHeaderEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>SOAPBinding</package></attributes></class><comment><class-id>WebServices.Soap11HeaderEntry</class-id><body>Soap11HeaderEntry implements Soap 1.1 header entry.Instance Variables	actor	&lt;String&gt; URL string</body></comment><class><name>WsdlExtensionDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preferredEncoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.WsdlExtensionDescriptor</class-id><body>Represents &lt;bindingExtension&gt; attribute in a WSDL 1.1 schema (Optional)Instance Variables	preferredEncoding	&lt;String&gt; preferred encoding</body></comment><class><name>WsdlParsingErrors</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.WsdlParsingErrors</class-id><body>WsdlParsingErrors is raised if any errors while parsing a Wsdl schema </body></comment><class><name>Wsdl11MessageDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name parts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11MessageDescriptor</class-id><body>Represents &lt;message&gt; element in WSDL 1.1Instance Variables	name	&lt;XML.NodeTag&gt; maps the 'name' attribute	parts	&lt;Collection of: WsdlMessagePartDescriptor&gt; maps the message 'input'/'output' elements</body></comment><class><name>ClientMessageInterceptor</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.ClientMessageInterceptor</class-id><body>Creating SOAP messages has additional interception points between SOAP header and SOAP body marshaling and unmarshaling. This class adds the callbacks for those. The interceptors are used by WsdlClient class.Instance Variables	dispatcher	&lt;SoapInterceptorDispatcher&gt;	</body></comment><class><name>SoapWsdl20OperationBinding</name><environment>WebServices</environment><super>WebServices.SoapOperationBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputFaultMarshalers inputFaultMarshalers interfaceDescriptor style rpcSignature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SoapWsdl20OperationBinding</class-id><body>SoapWsdl20OperationBinding  provides Wsdl 2.0/Soap 1.2 marshalers for the remote service operation.Instance Variables	outputFaultMarshalers	&lt;SoapWsdl20FaultBinding&gt; output fault marshalers	inputFaultMarshalers	&lt;SoapWsdl20FaultBinding&gt; input fault marshalers	interfaceDescriptor	&lt;Wsdl20InterfaceOperationDescriptor&gt; interface descriptor	style	&lt;String&gt; 	rpcSignature	&lt;Dictionary key: String value: Symbol&gt;  key is a selector part and value one of the following four: "#in", "#out", "#inout" "#return"</body></comment><class><name>SelectorMap</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operations binding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.SelectorMap</class-id><body>The class is obsolete. Use ServiceMap to map Wsdl interface operations to service class methods</body></comment><class><name>Wsdl11SoapOperationFaultDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name fault version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl11SoapOperationFaultDescriptor</class-id><body>Represents &lt;fault&gt;  element in the WSDL 1.1 schema Operation binding element. Instance Variables	fault	&lt;Wsdl11MessageEncodingDescriptor&gt;	operation binding  fault	name	&lt;String&gt;	fault name	version	&lt;String&gt;	Soap 1.1 or 1.2  version</body></comment><class><name>ServiceMap</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface operations serviceClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WSDL</category><attributes><package>WSDLBinding</package></attributes></class><comment><class-id>WebServices.ServiceMap</class-id><body>Represents operation and selector map for the specific interface and service class.The class can marshal itself to an XML specification and can unmarshal a selector map instance from an XML element.Instance Variables	interface	&lt; NodeTag&gt;	 interface	operations	&lt;Collection of: Association&gt;	  operations	serviceClass	&lt;Class&gt;	serviceClass</body></comment><class><name>Wsdl20SoapFaultDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name targetNamespace soapFaultCode soapFaultSubcode soapHeaders soapModule </inst-vars><class-inst-vars>soapFaultCodes </class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><comment><class-id>WebServices.Wsdl20SoapFaultDescriptor</class-id><body>Represents Wsdl 2.0 binding fault descriptorhttp://www.w3.org/TR/wsdl20-adjuncts/#property-BindingFault.soapfaultcode{soap fault code} A union of xs:QName and xs:token, to the Binding Fault component, where: when the value of the {soap version} is 1.2, the allowed QNames MUST be the ones defined by [SOAP 1.2 Part 1: Messaging Framework (Second Edition)],   the allowed token value is #any. The value of this property identifies a possible SOAP fault for the operations in scope. If the value of this property is #any, no assertion is made about the possible value of the SOAP fault code.{soap fault subcodes} A union of list of xs:QName, and xs:token where the allowed token value is #any, to the Binding Fault component. The value of this property identifies one or more subcodes for this SOAP fault. The list of subcodes is the nested sequence of subcodes. An empty list represents a fault code without subcodes.Instance Variables	name	&lt;NodeTag&gt; name	targetNamespace	&lt;String&gt; targetNamespace	soapFaultCode	&lt;NodeTag&gt; soap fault code	soapFaultSubcode	&lt;OrderedCollection of NodeTag&gt; soap fault subcodes	soapHeaders	&lt;OrderedCollection of Wsdl20SoapHeaderDescriptor&gt; fault headers	soapModule	&lt;String&gt; Class Instance Variables	soapFaultCodes	&lt;OrderedCollection&gt; codes as they defined at http://www.w3.org/TR/soap12-part1/#faultcodes</body></comment><shared-variable><name>WsdlBindings</name><environment>WebServices.WsdlBinding</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Dictionary new: 20</initializer><attributes><package>WSDLBinding</package></attributes></shared-variable><shared-variable><name>HeadersBeOptional</name><environment>WebServices.SoapWsdl11HeaderBinding</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>WSDLBinding</package></attributes></shared-variable><shared-variable><name>ServiceRegistry</name><environment>WebServices.WsdlService</environment><private>false</private><constant>false</constant><category>Registry</category><attributes><package>WSDLBinding</package></attributes></shared-variable><shared-variable><name>PortRegistry</name><environment>WebServices.WsdlPort</environment><private>false</private><constant>false</constant><category>Registry</category><attributes><package>WSDLBinding</package></attributes></shared-variable><methods><class-id>WebServices.NoWsdlSchemaError</class-id> <category>initialize-release</category><body package="WSDLBinding">messageText	^(#ThereIsNoWSDL &lt;&lt; #webservices &gt;&gt; 'There is no WSDL schema provided') asString</body></methods><methods><class-id>WebServices.NoWsdlSchemaError class</class-id> <category>testing</category><body package="WSDLBinding">mayResume	^true</body></methods><methods><class-id>WebServices.WsdlComponentDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">documentation	^documentation</body><body package="WSDLDescriptors">documentation: anObject	documentation := anObject</body></methods><methods><class-id>WebServices.WsdlComponentDescriptor</class-id> <category>wsdl schema</category><body package="WSDLDescriptors">xmlDocumentation	(documentation notNil and: [ documentation isEmpty]) ifTrue: [ ^nil ].	^documentation</body></methods><methods><class-id>WebServices.Wsdl20SoapOperationParameterDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addSoapHeader: aSoapHeaderDescriptor	soapHeaders ifNil: [soapHeaders := OrderedCollection new].	soapHeaders add: aSoapHeaderDescriptor</body><body package="WSDLDescriptors">any	^any</body><body package="WSDLDescriptors">any: anObject	any := anObject</body><body package="WSDLDescriptors">httpContentEncoding	^httpContentEncoding</body><body package="WSDLDescriptors">httpContentEncoding: aString	httpContentEncoding := aString</body><body package="WSDLDescriptors">httpHeader	^httpHeader</body><body package="WSDLDescriptors">httpHeader: anObject	httpHeader := anObject</body><body package="WSDLDescriptors">messageLabel	^messageLabel</body><body package="WSDLDescriptors">messageLabel: aString	messageLabel := aString</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aNodeTag	name := aNodeTag</body><body package="WSDLDescriptors">soapHeaders	^soapHeaders</body><body package="WSDLDescriptors">soapHeaders: aCollSoapHeaderDescriptor	soapHeaders := aCollSoapHeaderDescriptor</body><body package="WSDLDescriptors">soapModule	^soapModule</body><body package="WSDLDescriptors">soapModule: anObject	soapModule := anObject</body></methods><methods><class-id>WebServices.Wsdl20SoapOperationParameterDescriptor</class-id> <category>initialize-release</category><body package="WSDLDescriptors">initialize	soapHeaders := OrderedCollection new.	httpHeader := OrderedCollection new.</body></methods><methods><class-id>WebServices.Wsdl20SoapOperationParameterDescriptor class</class-id> <category>instance creation</category><body package="WSDLDescriptors">new	^self basicNew initialize</body></methods><methods><class-id>WebServices.SoapMessage</class-id> <category>accessing</category><body package="WSDLBinding">accessPoint	^accessPoint</body><body package="WSDLBinding">binding	^binding</body><body package="WSDLBinding">dom	^dom</body><body package="WSDLBinding">interceptorDispatcher	^interceptorDispatcher ifNil: [interceptorDispatcher := self processingPolicy provideInterceptorDispatcher]</body><body package="WSDLBinding">interceptorDispatcher: anObject	interceptorDispatcher := anObject</body><body package="WSDLBinding">operation	operation ifNil: [self setOperation].	^operation</body><body package="WSDLBinding">port	^self accessPoint</body><body package="WSDLBinding">processingPolicy	^processingPolicy ifNil: [ processingPolicy := ClientProcessingPolicy new ]</body><body package="WSDLBinding">processingPolicy: anObject	processingPolicy := anObject</body><body package="WSDLBinding">smalltalkEntity	^smalltalkEntity</body><body package="WSDLBinding">smalltalkEntity: aValue	smalltalkEntity := aValue</body><body package="WSDLBinding">transport	^self operation  		ifNotNil: [ :op | op transport ]		ifNil: [transport]</body><body package="WSDLBinding">transport: aValue	self operation 		ifNotNil: [ :op | op transport: aValue ]		ifNil: [ transport := aValue ]</body><body package="WSDLBinding">transportEntity	^transportEntity</body></methods><methods><class-id>WebServices.SoapMessage</class-id> <category>initialization</category><body package="WSDLBinding">accessPoint: aValue	accessPoint := aValue</body><body package="WSDLBinding">binding: aValue	binding := aValue</body><body package="WSDLBinding">dom: anXMLElement	dom := anXMLElement</body><body package="WSDLBinding">initialize	self resetHeader</body><body package="WSDLBinding">operation: aSoapOperationBinding	operation := aSoapOperationBinding</body><body package="WSDLBinding">port: aWsdlPort	binding := aWsdlPort binding.	accessPoint := aWsdlPort accessPoint.</body><body package="WSDLBinding">readDocumentFrom: httpEntity	dom := (self class readDocumentFrom:  httpEntity ) root.	^dom</body><body package="WSDLBinding">resetHeader	header := SoapHeader new.</body><body package="WSDLBinding">setHeaderFrom: aSoapHeader	aSoapHeader headerEntries do: [ :val | self header add: val copy  ]</body><body package="WSDLBinding">setOperation</body><body package="WSDLBinding">setOperationFrom: anXMLElement</body><body package="WSDLBinding">transportEntity: aHttpEntity	transportEntity := aHttpEntity</body></methods><methods><class-id>WebServices.SoapMessage</class-id> <category>header</category><body package="WSDLBinding">addHeaderEntry: aSoapHeaderEntry	^self header add: aSoapHeaderEntry</body><body package="WSDLBinding">header 	^header</body><body package="WSDLBinding">header: aSoapHeader 	header := aSoapHeader</body><body package="WSDLBinding">headerAt: aSymbol ifAbsent: aBlock	self header == nil ifTrue: [^aBlock value].	^self header headerAt: aSymbol  ifAbsent: aBlock</body><body package="WSDLBinding">headerAt: aSymbol ifAbsentPut: aBlock"Get header entry.  "	^self header headerAt: aSymbol ifAbsentPut: aBlock</body><body package="WSDLBinding">headerAt: aSymbol put: aSoapHeaderEntry	^self header headerAt: aSymbol put: aSoapHeaderEntry</body><body package="WSDLBinding">headerEntries	^self header headerEntries</body><body package="WSDLBinding">headerEntriesDo: aBlock	^self header keysAndValuesDo: aBlock</body><body package="WSDLBinding">headerFor: aSymbolOrNodeTag	^self header 			headerAt: aSymbolOrNodeTag 			ifAbsentPut: [self headerEntryClass name: aSymbolOrNodeTag]</body><body package="WSDLBinding">headerRemoveKey: aSymbol ifAbsent: aBlock"Remove header entry.  "	self header removeKey: aSymbol  ifAbsent: aBlock</body><body package="WSDLBinding">unmarshalHeaderEntriesFromXML: anXMLElementCollection	operation ifNil: [ self error: (#OperationIsNotSpecified &lt;&lt; #webservices &gt;&gt; 'The operation is not set. Can not unmarshal header entries') ].	^operation unmarshalHeaderEntriesFromXML: anXMLElementCollection</body></methods><methods><class-id>WebServices.SoapMessage</class-id> <category>testing</category><body package="WSDLBinding">headerEntryClass	^self binding transport headerEntryClass</body><body package="WSDLBinding">isOneWay	^self operation notNil		ifTrue: [ self operation isOneWay ]		ifFalse: [ false ]</body><body package="WSDLBinding">isResponse	^false</body></methods><methods><class-id>WebServices.SoapMessage</class-id> <category>copying</category><body package="WSDLBinding">from: aSoapMessage	binding := aSoapMessage binding.	accessPoint := aSoapMessage accessPoint.	operation := aSoapMessage operation.</body></methods><methods><class-id>WebServices.SoapMessage</class-id> <category>api - marshal</category><body package="WSDLBinding">marshal" Marshal Smalltalk object into something ready for transport "	self sendingMessage.	self marshalDom.	dom ifNotNil: [self sendingMessageDOM].	self setTransportEntityBody.	self sendingMessageEnvelope. 	^transportEntity</body><body package="WSDLBinding">marshalDom	^self subclassResponsibility</body><body package="WSDLBinding">sendingMessage</body><body package="WSDLBinding">sendingMessageDOM</body><body package="WSDLBinding">sendingMessageEnvelope</body><body package="WSDLBinding">setTransportEntityBody	dom ifNotNil: [ transportEntity body source:  (XMLObjectMarshalingManager printContentsFrom: dom )].	^transportEntity</body></methods><methods><class-id>WebServices.SoapMessage</class-id> <category>api - unmarshal</category><body package="WSDLBinding">receivingMessage</body><body package="WSDLBinding">receivingMessageEnvelope</body><body package="WSDLBinding">unmarshal	| result |	self readDocumentFrom: transportEntity.	self receivingMessageEnvelope.	result := self unmarshal: dom.	self receivingMessage.	^result</body><body package="WSDLBinding">unmarshal: aDOM	^self subclassResponsibility</body></methods><methods><class-id>WebServices.SoapMessage class</class-id> <category>instance creation</category><body package="WSDLBinding">createFrom: aHttpEntity binding: aWsdlBinding	| message |	message := aHttpEntity isResponse		ifTrue:  [ SoapResponse new ]		ifFalse:  [ SoapRequest new ].	message 		binding: aWsdlBinding;		transportEntity: aHttpEntity.	^message</body><body package="WSDLBinding">new	^super new initialize</body><body package="WSDLBinding">unmarshalTransportEntity: aTransportEntity with: aWsdlBinding	^(self createFrom: aTransportEntity binding: aWsdlBinding)  unmarshal</body></methods><methods><class-id>WebServices.SoapMessage class</class-id> <category>print message</category><body package="WSDLBinding">printContentsFrom:  anXMLElement" The method creates the a Soap message stream from the XML element. The stream can used in a HttpEntity body source"	^XMLObjectMarshalingManager printContentsFrom:  anXMLElement</body></methods><methods><class-id>WebServices.SoapMessage class</class-id> <category>defaults</category><body package="WSDLBinding">encoding	^#'UTF-8'</body></methods><methods><class-id>WebServices.SoapMessage class</class-id> <category>read message</category><body package="WSDLBinding">readDocumentFrom: httpEntity"The method reads a decompressed and decoded HttpEntity body contents, parses it and returns XMLElement"	^SoapMarshalingManager readDocumentFrom: httpEntity</body></methods><methods><class-id>WebServices.WsdlBindingDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addOperation: aBindingOperationDescriptor	operations ifNil: [operations := OrderedCollection new: 20.].	operations add: aBindingOperationDescriptor</body><body package="WSDLDescriptors">interfaceDescriptor	^interfaceDescriptor</body><body package="WSDLDescriptors">interfaceDescriptor: aWsdlInterfaceDescriptor	interfaceDescriptor := aWsdlInterfaceDescriptor</body><body package="WSDLDescriptors">interfaceDescriptorName	^interfaceDescriptor name</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aString	name := aString</body><body package="WSDLDescriptors">operationNamed: aString ifNone: aBlock	^self operations detect: [ :op | op name type = aString ] ifNone: aBlock</body><body package="WSDLDescriptors">operations	^operations</body><body package="WSDLDescriptors">operations: anOrderedCollection	operations := anOrderedCollection</body><body package="WSDLDescriptors">protocol	^protocol</body><body package="WSDLDescriptors">protocol: aString	protocol := aString</body></methods><methods><class-id>WebServices.WsdlBindingDescriptor class</class-id> <category>instance creation</category><body package="WSDLDescriptors">new	^super new initialize</body></methods><methods><class-id>WebServices.Wsdl11OperationParameterDescriptor</class-id> <category>validation</category><body package="WSDLDescriptors">resolveFrom: aWsdlConfigurationDescriptor ifError: aBlock	message ifNil: 			[message := aWsdlConfigurationDescriptor messages 				detect: [ :mess | mess name = self type ] 				ifNone:  aBlock ]</body></methods><methods><class-id>WebServices.Wsdl11OperationParameterDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">key	^key</body><body package="WSDLDescriptors">key: aNode	key := aNode</body><body package="WSDLDescriptors">message	^message</body><body package="WSDLDescriptors">message: anObject	message := anObject</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: anObject	name := anObject.	key := anObject</body><body package="WSDLDescriptors">tag	^self type</body><body package="WSDLDescriptors">type	^type</body><body package="WSDLDescriptors">type: anObject	type := anObject</body><body package="WSDLDescriptors">value	^self message</body><body package="WSDLDescriptors">value: aValue	^self message: aValue</body></methods><methods><class-id>WebServices.ClientInterceptorDispatcher</class-id> <category>interceptor</category><body package="WSDLBinding">addInterceptor: anInterceptor	interceptors add: anInterceptor.	anInterceptor dispatcher: self.</body><body package="WSDLBinding">interceptors	^interceptors</body><body package="WSDLBinding">setInterceptors: aSequenceOfInterceptors	interceptors := aSequenceOfInterceptors.	aSequenceOfInterceptors do: [ :each | each dispatcher: self ]</body></methods><methods><class-id>WebServices.ClientInterceptorDispatcher</class-id> <category>accessing</category><body package="WSDLBinding">policy	^policy</body><body package="WSDLBinding">policy: anObject	policy := anObject</body><body package="WSDLBinding">requestHeader	^requestHeader</body><body package="WSDLBinding">requestHeader: anObject	requestHeader := anObject</body></methods><methods><class-id>WebServices.ClientInterceptorDispatcher</class-id> <category>processing callbacks</category><body package="WSDLBinding">receivingReply: aReply in: aTransport	self interceptors do: [ :each | each receivingReply: aReply in: aTransport ]</body><body package="WSDLBinding">receivingReplyEnvelope: aReply in: aTransport	self interceptors do: [ :each | each receivingReplyEnvelope: aReply in: aTransport ]</body><body package="WSDLBinding">sendingRequest: aRequest in: aTransport	self interceptors do: [ :each | each sendingRequest: aRequest in: aTransport ]</body><body package="WSDLBinding">sendingRequestDOM: aDOM	self interceptors do: [ :each | each sendingRequestDOM: aDOM ]</body><body package="WSDLBinding">sendingRequestEnvelope: aRequest in: aTransport	self interceptors do: [ :each | each sendingRequestEnvelope: aRequest in: aTransport ].</body></methods><methods><class-id>WebServices.ClientInterceptorDispatcher</class-id> <category>initialize-release</category><body package="WSDLBinding">initialize	 interceptors := OrderedCollection new .</body></methods><methods><class-id>WebServices.ClientInterceptorDispatcher class</class-id> <category>instance creation</category><body package="WSDLBinding">new	^super new initialize</body></methods><methods><class-id>WebServices.Wsdl20HttpHeaderDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: anObject	name := anObject</body><body package="WSDLDescriptors">required	^required</body><body package="WSDLDescriptors">required: anObject	required := anObject</body><body package="WSDLDescriptors">targetNamespace	^targetNamespace</body><body package="WSDLDescriptors">targetNamespace: anObject	targetNamespace := anObject</body><body package="WSDLDescriptors">type	^type</body><body package="WSDLDescriptors">type: anObject	type := anObject</body></methods><methods><class-id>WebServices.Wsdl11MessageEncodingDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">encodingStyle	^encodingStyle</body><body package="WSDLDescriptors">encodingStyle: aValue	encodingStyle := aValue</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aString	name := aString</body><body package="WSDLDescriptors">namespace	^namespace</body><body package="WSDLDescriptors">namespace: aValue	namespace := aValue</body><body package="WSDLDescriptors">parts	^nil</body><body package="WSDLDescriptors">use	^use</body><body package="WSDLDescriptors">use: aValue	use := aValue</body></methods><methods><class-id>WebServices.SoapFault</class-id> <category>accessing</category><body package="SOAPBinding">code	^code</body><body package="SOAPBinding">code: anObject	code := anObject</body><body package="SOAPBinding">contents	^Array with: self</body><body package="SOAPBinding">detail	^detail</body><body package="SOAPBinding">detail: aValue	detail := aValue.</body><body package="SOAPBinding">detailContentFirst	^self detailContents ifNotNil: [:details | details first ]</body><body package="SOAPBinding">detailContents	^detail == nil		ifTrue: [ nil  ]		ifFalse: [ detail at: #contents ifAbsent: [nil] ]</body><body package="SOAPBinding">detailContents: aValue	detail := Struct new.	(aValue isKindOf: OrderedCollection) 		ifTrue: [ detail contents: aValue ]		ifFalse: [ detail contents: (OrderedCollection with: aValue)].</body><body package="SOAPBinding">faultCode	^self code</body><body package="SOAPBinding">faultCode: aValue	self code: aValue</body><body package="SOAPBinding">faultCodes	^self class faultCodes</body><body package="SOAPBinding">faultTag	^self class faultTag</body><body package="SOAPBinding">httpCode"the code is used to set http response code "	^'500'</body><body package="SOAPBinding">message	^message</body><body package="SOAPBinding">message: anObject	message := anObject</body><body package="SOAPBinding">namespace 	^self subclassResponsibility</body><body package="SOAPBinding">role	^role</body><body package="SOAPBinding">role: aString	role := aString</body><body package="SOAPBinding">source	^source</body><body package="SOAPBinding">source: aValue	source := aValue</body></methods><methods><class-id>WebServices.SoapFault</class-id> <category>testing</category><body package="SOAPBinding">failed	^true</body><body package="SOAPBinding">isSoapFault	^true</body><body package="SOAPBinding">isUserHeaderError	^false</body><body package="SOAPBinding">successful	^false</body></methods><methods><class-id>WebServices.SoapFault</class-id> <category>converting</category><body package="SOAPBinding">asNotUnderstoodHeaderEntries	^self parameter collect: [ :nodex |  		self  headerEntryClass new			name:  (NodeTag qualifier: '' ns: self namespace type: 'NotUnderstood');			value: ( NotUnderstoodHeaderEntry qname: nodex);			yourself ]</body><body package="SOAPBinding">asSoapFault</body><body package="SOAPBinding">asSpecificFault</body><body package="SOAPBinding">asUpgradeHeaderEntry	^self headerEntryClass new			name:  (NodeTag qualifier: '' ns: self namespace type: 'Upgrade');			value: UpgradeHeaderEntry supportedEnvelopes;			yourself</body><body package="SOAPBinding">headerEntryClass	^self subclassResponsibility</body></methods><methods><class-id>WebServices.SoapFault</class-id> <category>printing</category><body package="SOAPBinding">description	"Answer the exception text."	^self printString</body></methods><methods><class-id>WebServices.SoapFault</class-id> <category>marshaling</category><body package="SOAPBinding">getDetails"The method is called from Fault marshaler to set the detail values. See SoapBinding class&gt;&gt;soap12Specification and soap11Specification "	^detail</body><body package="SOAPBinding">setDetails: aValue"The method is called from Fault marshaler to set the detail values. See SoapBinding class&gt;&gt;soap12Specification and soap11Specification "	detail := aValue</body></methods><methods><class-id>WebServices.SoapFault</class-id> <category>visiting</category><body package="WSDLBinding">acceptVisit: aSoapTransportBinding with: aMarshalers	^aSoapTransportBinding  marshalSoapFault: self with: aMarshalers</body></methods><methods><class-id>WebServices.SoapFault class</class-id> <category>accessing</category><body package="SOAPBinding">defaultQualifier	^self subclassResponsibility</body><body package="SOAPBinding">faultCodes	^faultCodes isNil		ifTrue: [self initializeFaultCodes ]		ifFalse: [faultCodes]</body><body package="SOAPBinding">faultTag	^ NodeTag 			qualifier: self defaultQualifier			ns: self namespace			type: 'Fault'</body><body package="SOAPBinding">initializeFaultCodes	"(self initializeFaultCodes)"	faultCodes := Dictionary new.	self subclasses		do: [ :cl |  faultCodes at: cl faultTag put: cl ].	^faultCodes</body><body package="SOAPBinding">namespace	^self subclassResponsibility</body></methods><methods><class-id>WebServices.SoapFault class</class-id> <category>testing</category><body package="SOAPBinding">isReceiverFault	^false</body><body package="SOAPBinding">isSenderFault	^false</body><body package="SOAPBinding">mayResume	^true</body></methods><methods><class-id>WebServices.SoapFault class</class-id> <category>instance creation</category><body package="SOAPBinding">faultCode: codeString faultString: faultString	^Soap11Fault faultCode: codeString faultString: faultString detail: nil</body><body package="SOAPBinding">faultCode: codeString faultString: faultString detail: anObject	^Soap11Fault faultCode: codeString faultString: faultString detail: anObject</body><body package="SOAPBinding">faultCode: codeString faultString: faultString detailContents:  anObject	^Soap11Fault faultCode: codeString faultString: faultString detailContents:  anObject</body><body package="SOAPBinding">faultString: faultString	^Soap11Fault faultString: faultString</body><body package="SOAPBinding">faultString: faultString detail: description	^Soap11Fault faultString: faultString detail: description</body></methods><methods><class-id>WebServices.Soap12Fault</class-id> <category>accessing</category><body package="SOAPBinding">asSoapFault	^Soap12Fault new		node: self node;		reason: self reason;		detail: self detail;		code: self code;		parameter: self parameter;		yourself</body><body package="SOAPBinding">asSpecificFault	| cl |		cl := self faultCodes 	at: self code value ifAbsent: [^self ].	^cl new		node: self node;		reason: self reason;		code: self code;		detail: self detail;		parameter: self parameter;		yourself</body><body package="SOAPBinding">code"The code is used to marshal Soap Fault Code  element"	^code ifNil: [ (code := WebServices.Struct new) value: self class faultTag; yourself ]</body><body package="SOAPBinding">code: aStruct" expected Struct that is mapped in to:&lt;struct name='env:FaultCode'&gt; &lt;element name='env:Value' ref='env:FaultValue' aspect='value' form='qualified' minOccurs ='1'/&gt;  &lt;element name='env:Subcode' ref='env:FaultSubcode' aspect='subcode'  minOccurs ='0'/&gt; &lt;/struct&gt;"	code := aStruct</body><body package="SOAPBinding">codeValue: aNode	self code value: aNode</body><body package="WSDLBinding">defaultTransport	^SoapTransportBinding</body><body package="SOAPBinding">exception: anException	self faultString: anException errorString.	self detailContents: anException</body><body package="SOAPBinding">faultCode	^self code value</body><body package="SOAPBinding">faultString	^self reason texts first text</body><body package="SOAPBinding">faultString: aString 	^self reasonText: aString lang: self class language</body><body package="SOAPBinding">header	^header ifNil: [header := SoapHeader new]</body><body package="SOAPBinding">header: aSoapHeader	header := aSoapHeader</body><body package="SOAPBinding">headerAt: aString put: anObject	^self header headerAt: aString put: (Soap12HeaderEntry new 											value: anObject; 											yourself)</body><body package="SOAPBinding">headerEntryClass	^Soap12HeaderEntry</body><body package="SOAPBinding">namespace	^SoapBinding soap12_uri</body><body package="SOAPBinding">node	^node</body><body package="SOAPBinding">node: aString	node := aString</body><body package="SOAPBinding">reason	^reason</body><body package="SOAPBinding">reason: aStruct	reason := aStruct</body><body package="SOAPBinding">reasonText: aString lang: faultReason		reason ifNil: [ reason := Struct new name: 'FaultReason'; yourself.				reason texts: OrderedCollection new  ].	reason texts add: (Struct new						text: aString;						lang:  faultReason;						yourself ).</body><body package="SOAPBinding">reasonTexts	^self reason texts</body><body package="SOAPBinding">subcode	^self code at: #subcode ifAbsent: [nil]</body><body package="SOAPBinding">subcode: aFaultSubcode	self code subcode: aFaultSubcode</body></methods><methods><class-id>WebServices.Soap12Fault</class-id> <category>printing</category><body package="SOAPBinding">printOn: aStream	aStream nextPutAll: self class name.	self code ifNotNil: 		[aStream nextPutAll: ' /Fault Code: ', self code value asString.		self subcode ifNotNil: [ aStream nextPutAll: ' /Subcode: ', self subcode value asString ]].	(self reason notNil and: [self reasonTexts  notNil ])		 ifTrue: [	aStream nextPutAll: ' /Reason: ',self reasonTexts first text ]</body></methods><methods><class-id>WebServices.Soap12Fault class</class-id> <category>accessing</category><body package="SOAPBinding">defaultLanguage	^'en'</body><body package="SOAPBinding">defaultQualifier	^'env'</body><body package="SOAPBinding">language	^language ifNil: [ self defaultLanguage]</body><body package="SOAPBinding">language: aString	language := aString</body><body package="SOAPBinding">namespace	^SoapBinding soap12_uri</body></methods><methods><class-id>WebServices.Soap12Fault class</class-id> <category>instance creation</category><body package="SOAPBinding">exception: anException	^self new 		exception: anException; 		yourself</body><body package="SOAPBinding">faultCode: codeString faultString: faultString	^self node: codeString reasonText: faultString lang: self language</body><body package="SOAPBinding">faultString: faultString	^self new		reasonText: faultString lang: self language;		yourself</body><body package="SOAPBinding">node: codeString reasonText: aString lang: faultReason	^self new		node: codeString;		reasonText: aString lang: faultReason		yourself</body></methods><methods><class-id>WebServices.MustUnderstandFault</class-id> <category>visiting</category><body package="WSDLBinding">acceptVisit: aSoapTransportBinding with: aMarshalers	^aSoapTransportBinding marshalMustUnderstandFault: self with: aMarshalers</body></methods><methods><class-id>WebServices.MustUnderstandFault class</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'MustUnderstand'</body></methods><methods><class-id>WebServices.WsdlInterfaceDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addOperation: aWsdlOperationDescriptor	operations isNil ifTrue: [ operations := OrderedCollection new: 20].	operations add: aWsdlOperationDescriptor</body><body package="WSDLDescriptors">allFaults	| collection |	collection := OrderedCollection new.	faults ifNotNil: [collection addAll: faults].	self extends ifNotNil: [ self extends do: [ :each |  collection addAll: each allFaults ]].	^collection</body><body package="WSDLDescriptors">allOperations	| collection |	collection := OrderedCollection withAll: operations.	self extends ifNotNil: [ self extends do: [ :each |  collection addAll: each allOperations ]].	^collection</body><body package="WSDLDescriptors">extends	^extends</body><body package="WSDLDescriptors">extends: aCollection	extends := aCollection</body><body package="WSDLDescriptors">faults	^faults</body><body package="WSDLDescriptors">faults: anObject	faults := anObject</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aNodeTag	name := aNodeTag</body><body package="WSDLDescriptors">operations	^operations</body><body package="WSDLDescriptors">operations: aCollOfWsdlOperationDescriptor	operations := aCollOfWsdlOperationDescriptor</body><body package="WSDLDescriptors">postCopy	super postCopy.	operations := operations collect: [ :op | op copy].	faults := faults ifNotNil: [ faults collect: [ :fl | fl copy]].</body><body package="WSDLDescriptors">styleDefault	^styleDefault</body><body package="WSDLDescriptors">styleDefault: anObject	styleDefault := anObject</body></methods><methods><class-id>WebServices.WsdlInterfaceDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	aStream nextPutAll: 'InterfaceDescriptor '.	name ifNotNil: [ aStream nextPutAll: ' name=', name asString].</body></methods><methods><class-id>WebServices.WsdlInterfaceDescriptor</class-id> <category>service map</category><body package="WSDLDescriptors">addOperationsToServiceMap		self serviceMap operations: OrderedCollection new.		self operations do: [ :interfaceOperation | 		 interfaceOperation selector ifNotNil: [ 			self serviceMap addOperationNamed: interfaceOperation name type selector: interfaceOperation selector ]]</body><body package="WSDLDescriptors">serviceClass	^self serviceMap serviceClass</body><body package="WSDLDescriptors">serviceClass: aClass	self serviceMap serviceClass: aClass</body><body package="WSDLDescriptors">serviceMap		^serviceMap ifNil: [ serviceMap := ServiceMap new interface: self name; yourself ]</body><body package="WSDLDescriptors">serviceMap: aServiceMap		serviceMap := aServiceMap.</body></methods><methods><class-id>WebServices.SoapBodyStruct</class-id> <category>accessing</category><body package="SOAPBinding">contents	^self values</body><body package="SOAPBinding">contents: aSequenceableCollection	^(self partOrder isNil or: [self partOrder isEmpty])		ifTrue: [self at: 'contents' put: aSequenceableCollection]		ifFalse: 			[self partOrder size ~=  aSequenceableCollection size				ifTrue: [ ^Error raiseErrorString:  (#MismatchNumberOfPartsAndArg &lt;&lt; #webservices &gt;&gt; 'Mismatch number of parts  and arguments')].			self partOrder with: aSequenceableCollection				do: [ :part :value | self at: part put: value]]</body><body package="SOAPBinding">fault       ^self at: #fault ifAbsent: [super doesNotUnderstand: (Message selector: #fault arguments: #())]</body><body package="SOAPBinding">operationName	^self partOrder first asString</body></methods><methods><class-id>WebServices.SoapBodyMarshaler</class-id> <category>api -- unmarshal</category><body package="SOAPBinding">acceptNodesAndUnmarshal: marshalingContext do: aBlock	| node  child bodyMarshaler |	node := marshalingContext nodes first.	marshalingContext aspect: self relation.	"find operation marshaler from WsdlBinding "	bodyMarshaler := marshalingContext binding 		marshalerForTag: node tag 		ifAbsent: [self error: ((#CannotFindBodyMarshalerTag &lt;&lt; #webservices &gt;&gt; 'Can not find SoapBodyMarshaler for: &lt;1s&gt;') expandMacrosWith: node tag printString ) ].	child := marshalingContext asPartMarshaler: bodyMarshaler source: node.	child nodeContext: (OrderedCollection with: node).	bodyMarshaler		acceptNodesAndUnmarshal: marshalingContext 		do: [ :mc | marshalingContext value: mc value. aBlock value: marshalingContext ].</body></methods><methods><class-id>WebServices.SoapBodyMarshaler</class-id> <category>api -- marshal</category><body package="SOAPBinding">setNodeAndMarshalFrom: marshalingContext	| realMarshaler |	relation 		marshalFrom: marshalingContext		do: [ :value | 			realMarshaler := marshalingContext manager 							marshalerForObject: value							ifAbsent: [ marshalingContext notifyNoMarshalerFor:  value].			marshalingContext 				value: value;				marshaler: realMarshaler.			realMarshaler setNodeAndMarshalFrom: marshalingContext.]</body></methods><methods><class-id>WebServices.Soap11Fault</class-id> <category>accessing</category><body package="WSDLBinding">defaultTransport	^SoapWsdl11HttpBinding</body><body package="SOAPBinding">faultCodeString	^code asString</body><body package="SOAPBinding">faultString	^faultString</body><body package="SOAPBinding">faultString: aValue	faultString := aValue</body><body package="SOAPBinding">headerEntryClass	^Soap11HeaderEntry</body><body package="SOAPBinding">namespace	^SoapBinding soap11_uri</body></methods><methods><class-id>WebServices.Soap11Fault</class-id> <category>printing</category><body package="SOAPBinding">printOn: aStream	| digest |	super printOn: aStream.	self code notNil		ifTrue: [aStream nextPutAll:  ' : ', self code asString, ' '].	(self faultString notNil and: [self faultString  notEmpty])		 ifTrue: 			[digest := self faultString size &lt; 100 				ifTrue: [self faultString]				ifFalse: [(self faultString copyFrom: 1 to: 100), '...'].			aStream nextPutAll: ' ', digest]</body></methods><methods><class-id>WebServices.Soap11Fault</class-id> <category>converting</category><body package="SOAPBinding">asSoapFault	^(Soap11Fault faultCode: self faultCode faultString: self faultString)		detail: self detail;		parameter: self parameter;		yourself</body><body package="SOAPBinding">asSpecificFault	| cl |		cl := self faultCodes 	at: self faultCode ifAbsent: [^self ].	^(cl faultString: self faultString detail: self detail) 			parameter: self parameter;			yourself</body></methods><methods><class-id>WebServices.Soap11Fault class</class-id> <category>accessing</category><body package="SOAPBinding">defaultQualifier	^'SOAP-ENV'</body><body package="SOAPBinding">namespace	^SoapBinding soap11_uri</body></methods><methods><class-id>WebServices.Soap11Fault class</class-id> <category>instance creation</category><body package="SOAPBinding">faultCode: codeString faultString: faultString	^self faultCode: codeString faultString: faultString detail: nil</body><body package="SOAPBinding">faultCode: codeString faultString: faultString detail: anObject	^self new 		faultCode: codeString;		faultString: faultString;		detailContents: anObject;		yourself</body><body package="SOAPBinding">faultCode: codeString faultString: faultString detailContents:  anObject	^self new 		faultCode: codeString;		faultString: faultString;		detailContents:  anObject;		yourself</body><body package="SOAPBinding">faultString: faultString	^self faultString: faultString detail: nil</body><body package="SOAPBinding">faultString: faultString detail: description	^self new 		faultCode: self faultTag;		faultString: faultString;		detail: description;		yourself</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>accessing bindings</category><body package="SOAPBinding">soap11Binding	^XMLObjectBinding bindingAtNamespace: self  soap11_uri</body><body package="SOAPBinding">soap11EncodingBinding	^XMLObjectBinding bindingAtNamespace: self soap11_encoding_uri</body><body package="SOAPBinding">soap12Binding	^XMLObjectBinding bindingAtNamespace: self soap12_uri</body><body package="SOAPBinding">soap12EncodingBinding	^XMLObjectBinding bindingAtNamespace: self soap12_encoding_uri</body><body package="SOAPBinding">soapBinding	^self soap11Binding</body><body package="SOAPBinding">soapEncodingBinding	^self soap11EncodingBinding</body><body package="SOAPBinding">soapNotUnderstoodBinding	^XMLObjectBinding bindingAtNamespace: 'urn:visualworks:headerNotUnderstood'</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>specification - uri</category><body package="SOAPBinding">soap11_encoding_uri" Answers ns of SOAP encoding "	^'http://schemas.xmlsoap.org/soap/encoding/'</body><body package="SOAPBinding">soap11_uri	^'http://schemas.xmlsoap.org/soap/envelope/'.</body><body package="SOAPBinding">soap12_encoding_uri" Answers ns of SOAP1.2 encoding "	^'http://www.w3.org/2003/05/soap-encoding'</body><body package="SOAPBinding">soap12_rpc_uri" Answers ns of SOAP1.2 rpc style "	^'http://www.w3.org/2003/05/soap-rpc'</body><body package="SOAPBinding">soap12_uri	^'http://www.w3.org/2003/05/soap-envelope'</body><body package="SOAPBinding">supportedSoapVersions	"This method is used by the Soap server to verify arrived envelope version  "	^Array with: self soap12_uri with: self soap11_uri</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>obsolete</category><body package="SOAPBinding">soapNamespace	^self soap11_uri</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>accessing</category><body package="SOAPBinding">resolvedSoapTypes	" self resolvedSoapTypes "	^(XMLObjectBinding bindingAtNamespace: self soap11_encoding_uri) marshalers collect: [ :k | k tag type ]</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>class initialization</category><body package="SOAPBinding">configure	"self configure"	BindingBuilder registry at: 'soapbody' put: SoapBodyMarshaler.	BindingBuilder registry at: 'soapArray' put: SoapArrayMarshaler.	BindingBuilder registry at: 'headerEntryObject' put: SoapHeaderEntryMarshaler.	BindingBuilder registry at: 'soapheader' put: SoapHeaderMarshaler.	self 		loadSoapSpecifications;		loadSoapEncodingSpecifications</body><body package="SOAPBinding">initialize	"(self initialize)"	self  configure</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>specification - load</category><body package="SOAPBinding">loadSoapEncodingSpecifications	XMLObjectBinding loadFrom: self soap11EncodingSpecification readStream.	self soapEncodingBinding ifNil:		[^self error: ((#Soap11EncodingNotFound &lt;&lt; #webservices &gt;&gt; 'SOAP 1.1 Encoding binding is not found at &lt;1s&gt;')							expandMacrosWith: self soap11_encoding_uri)].</body><body package="SOAPBinding">loadSoapSpecifications	" self loadSoapSpecifications "	XMLObjectBinding loadFrom: self soap11Specification readStream.	XMLObjectBinding loadFrom: self soap12Specification readStream.	self soap11Binding ifNil:		[^self error: ((#Soap11BindingNotFound &lt;&lt; #webservices &gt;&gt; 'SOAP 1.1 Binding is not found at &lt;1s&gt;')							expandMacrosWith: self  soap11_uri)].	self soap12Binding ifNil:		[^self error: ((#Soap12BindingNotFound &lt;&lt; #webservices &gt;&gt; 'SOAP 1.2 Binding is not found at &lt;1s&gt;')							expandMacrosWith: self  soap12_uri)].</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>load/unload</category><body package="SOAPBinding">prerequisitesForLoading	^super prerequisitesForLoading		add: SoapBodyStruct;		add: SoapBodyMarshaler;		add: XMLObjectBinding;		add: SoapFault;		add: Soap12Fault;		add: Soap11Fault;		yourself</body></methods><methods><class-id>WebServices.SoapBinding class</class-id> <category>specifications</category><body package="SOAPBinding">soap11EncodingSpecification	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="SoapEncodingBinding" 	targetNamespace="http://schemas.xmlsoap.org/soap/encoding/"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:tns="urn:visualworks:SOAPEncodingBinding"&gt;&lt;!-- Bindings for simple types --&gt;&lt;simple name="string" baseType="xsd:string"/&gt;&lt;simple name="boolean" baseType="xsd:boolean"/&gt;&lt;simple name="float" baseType="xsd:float"/&gt;&lt;simple name="double" baseType="xsd:double"/&gt;&lt;simple name="decimal" baseType="xsd:decimal"/&gt;&lt;simple name="uriReference" baseType="xsd:uriReference"/&gt;&lt;simple name="ID" baseType="xsd:ID"/&gt;&lt;simple name="IDREF" baseType="xsd:IDREF"/&gt;&lt;simple name="ENTITY" baseType="xsd:ENTITY"/&gt;&lt;simple name="NOTATION" baseType="xsd:NOTATION"/&gt;&lt;simple name="QName" baseType="xsd:QName"/&gt;&lt;simple name="language" baseType="xsd:language"/&gt;&lt;simple name="ENTITIES" baseType="xsd:ENTITIES"/&gt;&lt;simple name="NMTOKEN" baseType="xsd:NMTOKEN"/&gt;&lt;simple name="NMTOKENS" baseType="xsd:NMTOKENS"/&gt;&lt;simple name="NCName" baseType="xsd:NCName"/&gt;&lt;simple name="integer" baseType="xsd:integer"/&gt;&lt;simple name="nonPositiveInteger" baseType="xsd:nonPositiveInteger"/&gt;&lt;simple name="negativeInteger" baseType="xsd:negativeInteger"/&gt;&lt;simple name="long" baseType="xsd:long"/&gt;&lt;simple name="int" baseType="xsd:int"/&gt;&lt;simple name="short" baseType="xsd:short"/&gt;&lt;simple name="nonNegativeInteger" baseType="xsd:nonNegativeInteger"/&gt;&lt;simple name="unsignedLong" baseType="xsd:unsignedLong"/&gt;&lt;simple name="unsignedInt" baseType="xsd:unsignedInt"/&gt;&lt;simple name="unsignedInt" baseType="xsd:unsignedInt"/&gt;&lt;simple name="unsignedShort" baseType="xsd:unsignedShort"/&gt;&lt;simple name="positiveInteger" baseType="xsd:positiveInteger"/&gt;&lt;simple name="time" baseType="xsd:time"/&gt;&lt;simple name="date" baseType="xsd:date"/&gt;&lt;simple name="month" baseType="xsd:gMonth"/&gt;&lt;simple name="year" baseType="xsd:gYear"/&gt;&lt;simple name="byte" baseType="xsd:byte"/&gt;&lt;simple name="unsignedByte" baseType="xsd:unsignedByte"/&gt;&lt;simple name="ur-type" baseType="xsd:uriReference"/&gt;&lt;simple name="binary" baseType="xsd:base64Binary"/&gt;&lt;simple name="base64" baseType="xsd:base64Binary"/&gt;&lt;simple name="base64Binary" baseType="xsd:base64Binary"/&gt;&lt;simple name="timeDuration" baseType="xsd:dateTime"/&gt;&lt;simple name="recurringDuration" baseType="xsd:dateTime"/&gt;&lt;simple name="Name" baseType="xsd:string"/&gt;&lt;simple name="timeInstant" baseType="xsd:dateTime"/&gt;&lt;simple name="timePeriod" baseType="xsd:dateTime"/&gt; &lt;simple name="century" baseType="xsd:string"/&gt; &lt;simple name="binary" id="binary"/&gt;&lt;!--SOAP Message bindings --&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="SOAPBinding">soap11Specification	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="SoapBinding" 	defaultClassNamespace="WebServices"	elementFormDefault="qualified" defaultQualifier="SOAP-ENV"	attributeFormDefault="qualified"	useReference="false"	useTaggedObject="false"	targetNamespace="http://schemas.xmlsoap.org/soap/envelope/"	xmlns="http://schemas.xmlsoap.org/soap/envelope/"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:SOAPEnc="http://schemas.xmlsoap.org/soap/envelope/"&gt;&lt;!-- Imports --&gt;&lt;bindingImport name="XsdBinding"/&gt;&lt;!--SOAP Message bindings  --&gt;&lt;soapheader name="Header" smalltalkClass="SoapHeader"&gt;	&lt;any aspect="headerEntries" processContents="strict" form="qualified" minOccurs = "0" maxOccurs="*"/&gt;&lt;/soapheader&gt;&lt;headerRelation name="NotUnderstood"  ref="NotUnderstoodType" minOccurs = "0" form="qualified" /&gt;&lt;object name="NotUnderstoodType" smalltalkClass="NotUnderstoodHeaderEntry"&gt;   &lt;attribute name="qname" ref="xsd:QName"  /&gt;&lt;/object&gt;&lt;attribute name="SOAPEnc:actor" aspect="actor" ref="xsd:string" /&gt;&lt;attribute name="SOAPEnc:mustUnderstand" aspect="mustUnderstand" setSelector="setMustUnderstand:" getSelector="getMustUnderstand" &gt;		&lt;simple name="int" baseType="xsd:int"&gt;          		&lt;enumeration value="1" /&gt;		      &lt;enumeration value="0" /&gt;		&lt;/simple&gt;	&lt;/attribute&gt;&lt;headerEntryObject name="SoapHeaderEntry" smalltalkClass="Soap11HeaderEntry"&gt;	&lt;implicitAttribute ref="SOAPEnc:mustUnderstand"/&gt;	&lt;implicitAttribute ref="SOAPEnc:actor" /&gt;&lt;/headerEntryObject&gt;&lt;object name="Body" smalltalkClass="SoapBodyStruct" useInlineType="false"&gt;	&lt;soapbody aspect="contents" useInlineType="false" minOccurs = "0" maxOccurs = "*" /&gt;&lt;/object&gt;&lt;object name="Envelope" smalltalkClass="SoapEnvelope"&gt;	&lt;element ref="Header"  minOccurs="0" aspect="header"  useInlineType="false"/&gt;	&lt;element ref="Body" aspect="body"  useInlineType="false"/&gt;&lt;/object&gt;&lt;struct name="detailEntry"&gt;	&lt;any aspect="contents" processContents="lax" form="qualified" minOccurs = "0" maxOccurs="*"/&gt;&lt;/struct&gt;&lt;element name="Fault" aspect="fault" minOccurs = "0" maxOccurs = "1" ref="Fault" form="qualified"/&gt;&lt;object name="Fault" smalltalkClass="Soap11Fault"&gt;	&lt;all&gt; 		&lt;element name="faultcode" ref="xsd:QName" aspect="faultCode" form="unqualified"/&gt;  		&lt;element name="faultstring" ref="xsd:string" aspect="faultString" form="unqualified"/&gt;  		&lt;element name="detail" ref="detailEntry" setSelector="setDetails:" getSelector="getDetails" minOccurs = "0" maxOccurs = "1" form="unqualified" /&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="SoapClientFault" tag="Fault" smalltalkClass="SoapClientFault" baseType="Fault"/&gt;&lt;object name="SoapServerFault" tag="Fault" smalltalkClass="SoapServerFault" baseType="Fault"/&gt;&lt;object name="SoapMustUnderstandFault" tag="Fault" smalltalkClass="SoapMustUnderstandFault" baseType="Fault"/&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="SOAPBinding">soap12EncodingSpecification	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="Soap12EncodingBinding" 	targetNamespace="http://www.w3.org/2003/05/soap-encoding"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:tns="http://www.w3.org/2003/05/soap-encoding"&gt;&lt;!-- Imports --&gt;&lt;bindingImport name="XsdBinding"/&gt;&lt;!-- Bindings for simple types --&gt;&lt;implicit name="string" ref="xsd:string"/&gt;&lt;implicit name="boolean" ref="xsd:boolean"/&gt;&lt;implicit name="float" ref="xsd:float"/&gt;&lt;implicit name="double" ref="xsd:double"/&gt;&lt;implicit name="decimal" ref="xsd:decimal"/&gt;&lt;implicit name="uriReference" ref="xsd:uriReference"/&gt;&lt;implicit name="ID" ref="xsd:ID"/&gt;&lt;implicit name="IDREF" ref="xsd:IDREF"/&gt;&lt;implicit name="ENTITY" ref="xsd:ENTITY"/&gt;&lt;implicit name="NOTATION" ref="xsd:NOTATION"/&gt;&lt;implicit name="QName" ref="xsd:QName"/&gt;&lt;implicit name="language" ref="xsd:language"/&gt;&lt;implicit name="ENTITIES" ref="xsd:ENTITIES"/&gt;&lt;implicit name="NMTOKEN" ref="xsd:NMTOKEN"/&gt;&lt;implicit name="NMTOKENS" ref="xsd:NMTOKENS"/&gt;&lt;implicit name="NCName" ref="xsd:NCName"/&gt;&lt;implicit name="integer" ref="xsd:integer"/&gt;&lt;implicit name="nonPositiveInteger" ref="xsd:nonPositiveInteger"/&gt;&lt;implicit name="negativeInteger" ref="xsd:negativeInteger"/&gt;&lt;implicit name="long" ref="xsd:long"/&gt;&lt;implicit name="int" ref="xsd:int"/&gt;&lt;implicit name="short" ref="xsd:short"/&gt;&lt;implicit name="nonNegativeInteger" ref="xsd:nonNegativeInteger"/&gt;&lt;implicit name="unsignedLong" ref="xsd:unsignedLong"/&gt;&lt;implicit name="unsignedInt" ref="xsd:unsignedInt"/&gt;&lt;implicit name="unsignedInt" ref="xsd:unsignedInt"/&gt;&lt;implicit name="unsignedShort" ref="xsd:unsignedShort"/&gt;&lt;implicit name="positiveInteger" ref="xsd:positiveInteger"/&gt;&lt;implicit name="time" ref="xsd:time"/&gt;&lt;implicit name="date" ref="xsd:date"/&gt;&lt;implicit name="month" ref="xsd:gMonth"/&gt;&lt;implicit name="year" ref="xsd:gYear"/&gt;&lt;implicit name="byte" ref="xsd:byte"/&gt;&lt;implicit name="unsignedByte" ref="xsd:unsignedByte"/&gt;&lt;implicit name="ur-type" ref="xsd:uriReference"/&gt;&lt;implicit name="binary" ref="xsd:base64Binary"/&gt;&lt;implicit name="base64" ref="xsd:base64Binary"/&gt;&lt;implicit name="timeDuration" ref="xsd:dateTime"/&gt;&lt;implicit name="recurringDuration" ref="xsd:dateTime"/&gt;&lt;implicit name="Name" ref="xsd:string"/&gt;&lt;implicit name="timeInstant" ref="xsd:dateTime"/&gt;&lt;implicit name="timePeriod" ref="xsd:dateTime"/&gt; &lt;implicit name="century" ref="xsd:string"/&gt; &lt;simple name="binary" id="binary"/&gt;&lt;!--SOAP Message bindings --&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="SOAPBinding">soap12Specification	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="Soap12Binding" 	defaultClassNamespace="WebServices"	elementFormDefault="qualified" defaultQualifier="SOAP-ENV"	attributeFormDefault="qualified"	useReference="false"	useTaggedObject="false"	targetNamespace="http://www.w3.org/2003/05/soap-envelope"	xmlns="http://www.w3.org/2003/05/soap-envelope"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:env="http://www.w3.org/2003/05/soap-envelope"	xmlns:enc="http://www.w3.org/2003/05/soap-encoding" 	xmlns:rpc="http://www.w3.org/2003/05/soap-rpc"&gt;&lt;!-- Imports --&gt;&lt;bindingImport name="XsdBinding"/&gt;&lt;!--SOAP Header entries  --&gt;&lt;soapheader name="env:Header" smalltalkClass="SoapHeader"&gt;	&lt;any aspect="headerEntries" processContents="strict" form="qualified" minOccurs = "0" maxOccurs="*"/&gt;&lt;/soapheader&gt;&lt;simple name="RoleType" baseType="xsd:string"&gt;    &lt;enumeration value="http://www.w3.org/2003/05/soap-envelope/role/next" /&gt;     &lt;enumeration value="http://www.w3.org/2003/05/soap-envelope/role/none" /&gt;     &lt;enumeration value="http://www.w3.org/2003/05/soap-envelope/role/ultimateReceiver" /&gt;&lt;/simple&gt;&lt;attribute name="env:mustUnderstand" aspect="mustUnderstand" ref="xsd:boolean"/&gt;&lt;attribute name="env:role" aspect="role" ref="xsd:string"/&gt;&lt;attribute name="env:relay" aspect="relay" ref="xsd:boolean"/&gt;&lt;attribute name="env:encodingStyle" minOccurs = "0" aspect="encodingStyle" ref="xsd:string"/&gt;&lt;headerEntryObject name="SoapHeaderEntry" smalltalkClass="Soap12HeaderEntry"  form="qualified"&gt;	&lt;implicitAttribute ref="env:mustUnderstand" /&gt;	&lt;implicitAttribute ref="env:role" /&gt;	&lt;implicitAttribute ref="env:relay" /&gt;	&lt;implicitAttribute ref="env:encodingStyle"/&gt;&lt;/headerEntryObject&gt;&lt;element name="env:NotUnderstood" ref="env:NotUnderstood"  minOccurs = "0" form="qualified"/&gt;&lt;object name="env:NotUnderstood" smalltalkClass="NotUnderstoodHeaderEntry"&gt;   &lt;attribute name="qname" ref="xsd:QName" form="unqualified" /&gt;&lt;/object&gt;&lt;element name="env:Upgrade" ref="env:Upgrade" minOccurs = "0" form="qualified"/&gt;&lt;object name="env:Upgrade"  smalltalkClass="UpgradeHeaderEntry"&gt;	 &lt;element name="env:SupportedEnvelope" aspect="supportedEnvelopes" ref="env:SupportedEnvelopeType"  maxOccurs="*"/&gt;&lt;/object&gt;&lt;struct name="env:SupportedEnvelopeType" &gt;	 &lt;attribute name="qname" ref="xsd:QName"  form="unqualified" /&gt;&lt;/struct&gt;&lt;object name="env:Body" smalltalkClass="SoapBodyStruct"  form="qualified" useInlineType="false"&gt;	&lt;soapbody aspect="contents" useInlineType="false" minOccurs = "0" maxOccurs = "*"/&gt;&lt;/object&gt;&lt;object name="env:Envelope" smalltalkClass="SoapEnvelope"  form="qualified"&gt;	&lt;element name="env:Header" ref="env:Header"  minOccurs="0" aspect="header"   form="qualified"/&gt;	&lt;element name="env:Body"  ref="env:Body" aspect="body"  minOccurs = "1"  form="qualified"/&gt;&lt;/object&gt;&lt;element name="env:Fault" aspect="fault" minOccurs = "0" maxOccurs = "1" ref="env:Fault" form="qualified"/&gt;&lt;object name="env:Fault" smalltalkClass="Soap12Fault"&gt;	&lt;all&gt;		&lt;element name="env:Code" ref="env:FaultCode" aspect="code" form="qualified" minOccurs = "1"/&gt; 		&lt;element name="env:Reason" ref="env:FaultReason" aspect="reason" form="qualified" minOccurs = "1"/&gt; 		&lt;element name="env:Node" ref="xsd:string" minOccurs="0" aspect="node" form="qualified"/&gt; 		&lt;element name="env:Role" ref="xsd:string" minOccurs="0" aspect="role" form="qualified"/&gt; 		&lt;element name="env:Detail" ref="env:DetailEntry" aspect="detail" setSelector="setDetails:" getSelector="getDetails" minOccurs = "0"  form="qualified"/&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="DataEncodingUnknownFault" tag="Fault" smalltalkClass="DataEncodingUnknownFault" baseType="Fault"/&gt;&lt;object name="MustUnderstandFault" tag="Fault" smalltalkClass="MustUnderstandFault" baseType="Fault"/&gt;&lt;object name="ReceiverFault" tag="Fault" smalltalkClass="ReceiverFault" baseType="Fault"/&gt;&lt;object name="SenderFault" tag="Fault" smalltalkClass="SenderFault" baseType="Fault"/&gt;&lt;object name="VersionMismatchFault" tag="Fault" smalltalkClass="VersionMismatchFault" baseType="Fault"/&gt;&lt;struct name="env:FaultCode"&gt; &lt;element name="env:Value" ref="env:FaultValue" aspect="value" form="qualified" minOccurs = "1"/&gt;  &lt;element name="env:Subcode" ref="env:FaultSubcode" aspect="subcode" form="qualified" minOccurs = "0"/&gt; &lt;/struct&gt;&lt;simple name="env:FaultValue"  form="qualified" baseType="xsd:QName"&gt;      	&lt;enumeration value="env:VersionMismatch" /&gt;      &lt;enumeration value="env:MustUnderstand" /&gt;      &lt;enumeration value="env:DataEncodingUnknown" /&gt;      &lt;enumeration value="env:Sender" /&gt;      &lt;enumeration value="env:Receiver" /&gt;      &lt;enumeration value="enc:MissingID"/&gt;       &lt;enumeration value="enc:DuplicateID"/&gt;       &lt;enumeration value="enc:UntypedValue"/&gt;       &lt;enumeration value="rpc:ProcedureNotPresent"/&gt;       &lt;enumeration value="rpc:BadArguments"/&gt; &lt;/simple&gt;&lt;simple name="env:RoleType"  form="qualified" baseType="xsd:string"&gt;      &lt;enumeration value="http://www.w3.org/2003/05/soap-envelope/role/next" /&gt;     &lt;enumeration value="http://www.w3.org/2003/05/soap-envelope/role/none" /&gt;     &lt;enumeration value="http://www.w3.org/2003/05/soap-envelope/role/ultimateReceiver" /&gt;&lt;/simple&gt;&lt;object name="env:FaultSubcode" smalltalkClass="FaultSubcode"&gt;	&lt;element name="env:Value" ref="xsd:QName" aspect="value" form="qualified" minOccurs = "1"/&gt; 	&lt;element name="env:Subcode" ref="env:FaultSubcode" aspect="subcode" form="qualified" minOccurs = "0"/&gt; &lt;/object&gt;&lt;struct name="env:FaultReason"&gt; 	&lt;element name="env:Text" aspect="texts"  ref="env:TextType" minOccurs = "1" maxOccurs = "*"/&gt;&lt;/struct&gt;&lt;struct name="env:TextType"&gt; 	&lt;text ref="xsd:string" aspect="text"/&gt; 	&lt;attribute name="xml:lang" ref="xsd:string" aspect="lang" form="qualified" minOccurs = "0"/&gt; &lt;/struct&gt;&lt;struct name="env:DetailEntry"&gt;	&lt;any aspect="contents"  processContents="lax"  form="qualified" minOccurs = "0" maxOccurs="*"/&gt;&lt;/struct&gt;&lt;/xmlToSmalltalkBinding&gt;'</body></methods><methods><class-id>WebServices.Wsdl11PortDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">address	^address</body><body package="WSDLDescriptors">address: aValue	address := aValue</body><body package="WSDLDescriptors">addressString	^address value</body><body package="WSDLDescriptors">addressString: aString	address value: aString</body><body package="WSDLDescriptors">binding	^binding</body><body package="WSDLDescriptors">binding: aValue	binding := aValue</body><body package="WSDLDescriptors">bindingName	^binding name</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aValue	name := aValue</body></methods><methods><class-id>WebServices.Wsdl11PortDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	super printOn: aStream.	name ifNotNil: [ aStream nextPutAll: ' name=', name type ]</body></methods><methods><class-id>WebServices.Wsdl11PortDescriptor</class-id> <category>private</category><body package="WSDLDescriptors">soap11Address	^version = '1.1'		ifTrue: [ self address ]		ifFalse: [ nil ]</body><body package="WSDLDescriptors">soap11Address: aValueHolder	self address: aValueHolder.	version := '1.1'</body><body package="WSDLDescriptors">soap12Address	^version = '1.2'		ifTrue: [ self address ]		ifFalse: [ nil ]</body><body package="WSDLDescriptors">soap12Address: aValueHolder	self address: aValueHolder.	version := '1.2'</body></methods><methods><class-id>WebServices.Wsdl11PortDescriptor</class-id> <category>initialize-release</category><body package="WSDLDescriptors">initialize	version := '1.1'</body></methods><methods><class-id>WebServices.Wsdl11PortDescriptor class</class-id> <category>instance creation</category><body package="WSDLDescriptors">new	^self basicNew initialize</body></methods><methods><class-id>WebServices.DataEncodingUnknownFault class</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'DataEncodingUnknown'</body></methods><methods><class-id>WebServices.Wsdl11SoapOperationEnvelopeDescriptor</class-id> <category>testing</category><body package="WSDLDescriptors">isVersion11	^version = '1.1'</body><body package="WSDLDescriptors">isVersion12	^version = '1.2'</body></methods><methods><class-id>WebServices.Wsdl11SoapOperationEnvelopeDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">soapBody	^soapBody</body><body package="WSDLDescriptors">soapBody: anObject	soapBody := anObject</body><body package="WSDLDescriptors">soapHeader	^soapHeader</body><body package="WSDLDescriptors">soapHeader: anObject	soapHeader := anObject</body><body package="WSDLDescriptors">urlEncoded	^urlEncoded</body><body package="WSDLDescriptors">urlEncoded: anObject	urlEncoded := anObject</body></methods><methods><class-id>WebServices.Wsdl11SoapOperationEnvelopeDescriptor</class-id> <category>initialize-release</category><body package="WSDLDescriptors">initialize	soapHeader := OrderedCollection new.	self setVersion11</body></methods><methods><class-id>WebServices.Wsdl11SoapOperationEnvelopeDescriptor</class-id> <category>private</category><body package="WSDLDescriptors">setVersion11	version := '1.1'</body><body package="WSDLDescriptors">setVersion12	version := '1.2'</body><body package="WSDLDescriptors">soap11Body	^self isVersion11 ifTrue: [ self soapBody ] ifFalse: [ nil ]</body><body package="WSDLDescriptors">soap11Body: anObject	self soapBody: anObject.	self setVersion11</body><body package="WSDLDescriptors">soap11Header	^self isVersion11 ifTrue: [ self soapHeader ] ifFalse: [ OrderedCollection  new ]</body><body package="WSDLDescriptors">soap11Header: aColl	aColl notEmpty 	ifTrue: [ 			self soapHeader: aColl.		self setVersion11 ]</body><body package="WSDLDescriptors">soap12Body	^self isVersion11 ifTrue: [ nil ] ifFalse: [ self soapBody ]</body><body package="WSDLDescriptors">soap12Body: anObject	self soapBody: anObject.	self setVersion12</body><body package="WSDLDescriptors">soap12Header	^self isVersion11 ifTrue: [ OrderedCollection new ] ifFalse: [self soapHeader ]</body><body package="WSDLDescriptors">soap12Header: aColl	aColl notEmpty ifTrue: [ 			self soapHeader: aColl.		self setVersion12 ]</body></methods><methods><class-id>WebServices.Wsdl11SoapOperationEnvelopeDescriptor class</class-id> <category>instance creation</category><body package="WSDLDescriptors">new	^self basicNew initialize</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>accessing</category><body package="WSDLBinding">accessPoint	^accessPoint</body><body package="WSDLBinding">accessPoint: aStringOrUrl	accessPoint := aStringOrUrl asURI</body><body package="WSDLBinding">config	"The #config is defined when WsdlClient created by #loadFrom: " 	^config</body><body package="WSDLBinding">config: aWsdlConfiguration	"WsdlClient initialization "	config := aWsdlConfiguration</body><body package="WSDLBinding">headerEntryClass	self port binding transport isSoapBinding ifFalse: [^nil].	^self port binding transport isSoap11		ifTrue: [ Soap11HeaderEntry ]		ifFalse: [Soap12HeaderEntry ]</body><body package="WSDLBinding">headerFor: aSymbol	self port binding transport isSoapBinding ifFalse: [^nil].	^self headerAt: aSymbol ifAbsentPut: [ self headerEntryClass name: aSymbol  ]</body><body package="WSDLBinding">policy	^self processingPolicy</body><body package="WSDLBinding">port	port ifNil: [ port := self config anyPort ].	^port</body><body package="WSDLBinding">port: aWsdlPort	port := aWsdlPort</body><body package="WSDLBinding">processingPolicy	^processingPolicy</body><body package="WSDLBinding">processingPolicy: aSoapProcessingPolicy	processingPolicy := aSoapProcessingPolicy</body><body package="WSDLBinding">request	^request</body><body package="WSDLBinding">request: aSoapRequest	request := aSoapRequest</body><body package="WSDLBinding">requestClass	^SoapRequest</body><body package="WSDLBinding">requestContents	(self request isNil or: [self request transportEntity isNil]) ifTrue: [ ^nil].	^self request transportEntity contents</body><body package="WSDLBinding">response	^response</body><body package="WSDLBinding">responseContents	(self response isNil or: [self response transportEntity isNil]) ifTrue: [ ^nil].	^self response transportEntity contents</body><body package="WSDLBinding">value	^responseValue</body><body package="WSDLBinding">wsdlSpecification"Returns XML Documents with WSDL schema  specification "	| doc |	doc := XML.Document new.	config 		ifNil: [" specific client "			self class binding asWsdl ifNotNil: [ :wsdl | doc addNode: wsdl ]]		ifNotNil: [ " WsdlClient "			doc addNode: self config descriptor asWsdl ].	^doc</body><body package="WSDLBinding">wsdlUrl 	^wsdlUrl</body><body package="WSDLBinding">wsdlUrl: anUrl 	wsdlUrl := anUrl</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>transport</category><body package="WSDLBinding">close	"Disconnect HttpClient "	self disconnect</body><body package="WSDLBinding">connect	"Connect HttpClient to the server"	^self transportClient connect</body><body package="WSDLBinding">connectToHost: aStringHostName	"Connect HttpClient to the server"	self transportClient connectToHost: aStringHostName</body><body package="WSDLBinding">connectToHost: aStringHostName port: aNumber	"Connect HttpClient to the server"	self transportClient connectToHost: aStringHostName port: aNumber</body><body package="WSDLBinding">disconnect	"Disconnect HttpClient "	self transportClient disconnect</body><body package="WSDLBinding">hostName	^self transportClient hostName</body><body package="WSDLBinding">hostName: aStringHostName	self transportClient hostName: aStringHostName</body><body package="WSDLBinding">isConnected	^self transportClient isConnected</body><body package="WSDLBinding">newTransportClient	"Create a new HttpClient to deliver Soap messages "	^accessPoint 		ifNotNil: [  HttpClient new 					protocol: accessPoint protocol;					hostName: accessPoint host;					portNumber: accessPoint port;					yourself ]		ifNil: [ port 				ifNil: [HttpClient new]				ifNotNil: [ HttpClient new protocol: port address asURI class protocol]]</body><body package="WSDLBinding">portNumber	^self transportClient portNumber</body><body package="WSDLBinding">portNumber: aNumber	self transportClient portNumber: aNumber</body><body package="WSDLBinding">reconnect	self transportClient reconnect</body><body package="WSDLBinding">retries	^self transportClient retries</body><body package="WSDLBinding">retries: aNumber	self transportClient retries: aNumber</body><body package="WSDLBinding">timeout	^self transportClient timeout</body><body package="WSDLBinding">timeout: aNumber	self transportClient timeout: aNumber</body><body package="WSDLBinding">transportClient	"Return existing or create a new HttpClient "	^transport isNil		ifTrue: [ transport := self newTransportClient ]		ifFalse: [ transport ]</body><body package="WSDLBinding">transportClient: aNetClient 	"Specify HttpClient "	transport := aNetClient</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>utilities</category><body package="WSDLBinding">resetRetryExceptions	self port ifNil: [ (#PortIsNotProvided &lt;&lt; #webservices &gt;&gt; 'Port is not provided!')  ].	self port binding transport retryExceptions: nil.</body><body package="WSDLBinding">saveDocument: anElement intoFile: fileName	self class saveDocument: anElement intoFile: fileName</body><body package="WSDLBinding">saveDocument: anElement intoMethod: methName class: aClass withComment: aString	self class 		saveDocument: anElement		intoMethod: methName		class: aClass		withComment: aString</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>send request</category><body package="WSDLBinding">executeRequest	"In case of persistent transport client set to nil old values"	response := nil.	responseValue := nil.	"Execute request and set new response"	response := self request executeWith: self transportClient. 	responseValue := response value.	^responseValue</body><body package="WSDLBinding">executeRequest: aSoapRequest	self request: aSoapRequest.	self request setHeaderFrom: self header.	^self executeRequest</body><body package="WSDLBinding">executeSelector: aSymbol 	^self executeSelector: aSymbol args:  OrderedCollection new</body><body package="WSDLBinding">executeSelector: aSymbol args: aCollection	request := self newRequest.	request smalltalkEntity: (Message selector: aSymbol arguments: aCollection).	^self executeRequest</body><body package="WSDLBinding">wsdlSchemaRequest"The method creates url with ?WSDL query, executes the request and returns WSDL schema. Raises NoWsdlSchemaError if the server doesn't support WSDL query "	| httpEntity |	^self port		ifNotNil: 			[httpEntity := self transportClient						get: (self port address copy query: 'WSDL').			httpEntity isSuccess				ifTrue: [httpEntity contents]				ifFalse: 					[(NoWsdlSchemaError new)						messageText: httpEntity contents;						yourself]]</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>header</category><body package="WSDLBinding">addHeaderEntry: aSoapHeaderEntry	^self header add: aSoapHeaderEntry</body><body package="WSDLBinding">header	^header isNil		ifTrue: [ header := SoapHeader new ]		ifFalse: [ header ]</body><body package="WSDLBinding">headerAt: aSymbol ifAbsent: aBlock"Get header entry.  "	^self header headerAt: aSymbol ifAbsent: aBlock</body><body package="WSDLBinding">headerAt: aSymbol ifAbsentPut: aBlock"Get header entry.  "	^self header headerAt: aSymbol ifAbsentPut: aBlock</body><body package="WSDLBinding">headerAt: aSymbol put: aSoapHeaderEntry"Set header entry for requests "	^self header headerAt: aSymbol  put: aSoapHeaderEntry.</body><body package="WSDLBinding">headerEntries	^self header headerEntries</body><body package="WSDLBinding">headerEntriesDo: aBlock	^self header keysAndValuesDo: aBlock</body><body package="WSDLBinding">headerRemoveKey: aSymbol ifAbsent: aBlock"Remove header entry.  "	self header removeKey: aSymbol ifAbsent: aBlock</body><body package="WSDLBinding">requestHeader	^self request == nil		ifTrue: [ nil ]		ifFalse: [self request header ]</body><body package="WSDLBinding">requestHeaderAt: aSymbol ifAbsent: aBlock	^self request == nil		ifTrue: [ aBlock value ]		ifFalse: [ self request headerAt: aSymbol ifAbsent: aBlock ]</body><body package="WSDLBinding">requestHeaderAt: aSymbol ifAbsentPut: aBlock	self request == nil ifTrue: [ self request: self newRequest ].	^self request headerAt: aSymbol ifAbsentPut: aBlock</body><body package="WSDLBinding">requestHeaderAt: aSymbol put: aSoapHeaderEntry	self request == nil ifTrue: [ self request: self newRequest ].	^self request headerAt: aSymbol asString  put: aSoapHeaderEntry.</body><body package="WSDLBinding">requestHeaderRemoveKey: aSymbol ifAbsent: aBlock"Remove header entry.  "	request == nil 		ifTrue: [ aBlock value ]		ifFalse: [ self request headerRemoveKey: aSymbol ifAbsent: aBlock]</body><body package="WSDLBinding">resetRequestHeader	request ~~ nil 		ifTrue: [ self request resetHeader. ]</body><body package="WSDLBinding">responseHeader"Returns all header entries from the response "	^self response ~~ nil		ifTrue: [ self response header ]		ifFalse: [ nil ]</body><body package="WSDLBinding">responseHeaderAt: aSymbol ifAbsent: aBlock"Get header entry from response "	^self response ~~ nil		ifTrue: [ self response headerAt: aSymbol ifAbsent: aBlock]		ifFalse: [ aBlock value ]</body><body package="WSDLBinding">setRequestHeader	request == nil  		ifTrue: [ request := self newRequest ]		ifFalse: 	[self setRequestHeader: self request ]</body><body package="WSDLBinding">setRequestHeader: aSoapRequest	aSoapRequest resetHeader.	aSoapRequest setHeaderFrom: self header</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>private</category><body package="WSDLBinding">newRequest	self port ifNil: [ ^self error: (#PortIsNotProvided &lt;&lt; #webservices &gt;&gt; 'Port is not provided!') ].	^self requestClass new 		setHeaderFrom: self header;		processingPolicy: self processingPolicy;		binding: self port binding;		accessPoint: (accessPoint						ifNotNil: [ accessPoint ]						ifNil: [ self port accessPoint ]);		yourself</body><body package="WSDLBinding">newRequest: aSymbol args: aCollection	^self newRequest smalltalkEntity: (Message selector: aSymbol arguments: aCollection).</body><body package="WSDLBinding">printRequestHeaderCommentOn: aStream headers: partMarshalers	self class printRequestHeaderCommentOn: aStream headers: partMarshalers</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>initialization</category><body package="WSDLBinding">initialize	self resetHeader.	"Use processing policy with interceptors to extend message processing for SOAP messages. For example: Soap headers can be added to requests in interceptors "	processingPolicy :=  (self class processingPolicy 						ifNotNil: [ :policy |  policy ]						ifNil: [ClientProcessingPolicy new]).	"Initialize port and acces point for a specific client (subclass of WsdlClient)"	(self class bindingTargetNamespace notNil 		and: [ self class bindingName notNil ])			ifTrue: [self setPortNamed: (XML.NodeTag qualifier: '' ns: self class bindingTargetNamespace  type: self class bindingName) ].</body><body package="WSDLBinding">initializeRegistries" The method won't reinitialize the registries if there is already WsdlBinding registered with this target namespace.If you need update the WsdlBinding registry use: WsdlBinding initializeRegistriesFor:  self class "	self class bindingIfAbsent: [ WsdlBinding initializeRegistriesFor:  self class ]</body><body package="WSDLBinding">reset	self resetHeader.	request := nil</body><body package="WSDLBinding">resetHeader	header := SoapHeader new.</body><body package="WSDLBinding">setPortNamed: aNodeTag"The method sets an instance of WsdlPort for WSDL 1.1 or WsdlInterface for WSDL 2.0 "	request := nil.	transport := nil.	self initializeRegistries.	port := config 		ifNotNil: [ | binding |				 "WsdlClient "				binding := config bindings detect: [ :b | b name = aNodeTag] ifNone: [self error: ((#CannotFindBindingNode &lt;&lt; #net &gt;&gt; 'Can not find binding at &lt;1s&gt;') expandMacrosWith: aNodeTag printString)].				binding port]		ifNil: [" specific client " 			self class binding port].	accessPoint := port accessPoint.</body><body package="WSDLBinding">setServerPortTo: aNumber"The method resets the accessPoint a port number. The accessPoint is url that is used to connect to a server "	accessPoint ifNotNil: [ accessPoint host: accessPoint host port: aNumber].</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>creating script</category><body package="WSDLBinding">createScript	"The method creates a workspace script to execute requests "	^self class createScriptFrom: self</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>loading schema</category><body package="WSDLBinding">loadFrom:  aDataSource"Create configuration file from the resource. This method is used to initialize WsdlClient class but not subclasses. Subclasses expected use #initializeRegistries method. "	config := WsdlConfiguration defaultReadFrom:  aDataSource.</body></methods><methods><class-id>WebServices.WsdlClient</class-id> <category>http authorization</category><body package="WSDLBinding">username: unString password: pString"The method sets HttpClient user name and password to authenticate requests "	self transportClient username: unString password: pString</body></methods><methods><class-id>WebServices.WsdlClient class</class-id> <category>instance creation</category><body package="WSDLBinding">fileName: fileNameOrString"Construct new WsdlClient, validates the wsdl schema, creates XML to object default binding and creates config from the specified fileExample:	self readFrom: 'airportWeather.wsdl' "	^self url: fileNameOrString asFilename asURI</body><body package="WSDLBinding">new	^super new initialize</body><body package="WSDLBinding">readFrom: aStream" Construct new WsdlClient, validates the wsdl schema, creates XML to object default binding and creates config from the specified streamExample:	self readFrom: 'airportWeather.wsdl' asFilename readStream lineEndTransparent "	^self new		loadFrom: aStream;		yourself</body><body package="WSDLBinding">readFrom: aStream binding: x2oBindingStream" Loads X2O binding from the stream, constructs a WsdlClient, validates the wsdl schema and creates config from the specified stream"	| descriptor config |	descriptor := WsdlConfigurationDescriptor loadAndParse: aStream.	descriptor schemaBindings: (XMLObjectBinding loadBindings:  x2oBindingStream).	(config := descriptor configurationBuilder) buildComponents.	^self new		config: config;		yourself</body><body package="WSDLBinding">url: url" Loads Wsdl schema from the specified url, constructs a WsdlClient, creates XML to object default binding, validates schema and creates configExample:	self url: 'http://www.capescience.com/AirportWeather.wsdl' import: 	self url: 'http://www.apache.org/~rubys/ApacheSoap.wsdl' "	^self new		wsdlUrl: url asURI;		loadFrom:  url asURI;		yourself</body></methods><methods><class-id>WebServices.WsdlClient class</class-id> <category>utilities</category><body package="WSDLBinding">saveDocument: anElement intoFile: fileName"Save XML.Element in to the specified file"	XML.Document saveDocument: anElement intoFile: fileName</body><body package="WSDLBinding">saveDocument: anElement intoMethod: methName class: aClass withComment: commentString 	| s c | 	self 		saveIntoMethod: methName		class: aClass		comment: commentString		do: [:stream | 			s := (String new: 1024) writeStream. 			anElement wsPrintOn: s depth: 0.			s := s contents readStream.			[s atEnd]				whileFalse:					[c := s next.					(c = $' and: [ (s peek = $') not])						ifTrue: [stream nextPut: $'].					stream nextPut: c ]]</body></methods><methods><class-id>WebServices.WsdlClient class</class-id> <category>accessing</category><body package="WSDLBinding">binding	^self bindingIfAbsent: [self error: ((#Binding1sNotRegistered &lt;&lt; #webservices &gt;&gt; 'Binding &lt;1s&gt; is not registered!') expandMacrosWith: self bindingName) ].</body><body package="WSDLBinding">bindingIfAbsent: aBlock	^WsdlBinding		bindingAt: self bindingNode		ifAbsent: aBlock.</body><body package="WSDLBinding">bindingName	"Subclass should return a WSDL &lt;binding&gt; element name For example:	^'TimeServicesBinding'"	^nil</body><body package="WSDLBinding">bindingNode	^self bindingTargetNamespace notNil		ifTrue: [ NodeTag qualifier: '' ns: self bindingTargetNamespace type: self bindingName]		ifFalse: [ self bindingName ]</body><body package="WSDLBinding">bindingTargetNamespace	"Subclass should return a binding target namespace. For example: 	^'urn:testSecurity'"	^nil</body><body package="WSDLBinding">findClient: aNodeTag	^WsdlClient subclasses		detect: [ :clx | clx bindingNode = aNodeTag ]		ifNone: [ nil ].</body><body package="WSDLBinding">processingPolicy	"Subclasses should define the processing policy here.For example: 	^(ClientProcessingPolicy new 			interceptorClasses: (OrderedCollection with: SecurityHeaderClientInterceptor) ; 			yourself )."	^nil</body><body package="WSDLBinding">serviceMap	"Subclass should return a service map string. This method provides a map for service class methods and WSDL interface operations.For example:&lt;ns:serviceMap xmlns:ns0='urn:testSecurity' xmlns:ns='urn:visualworks:serviceMap'&gt;	&lt;ns:serviceClass&gt;WSSecurityDemo.TimeServices&lt;/ns:serviceClass&gt;	&lt;ns:interface&gt;ns0:TimeServices&lt;/ns:interface&gt;	&lt;ns:operation name='TimeNow' selector='timeNow'/&gt;&lt;/ns:serviceMap&gt;"	^nil</body></methods><methods><class-id>WebServices.WsdlClient class</class-id> <category>creating script</category><body package="WSDLBinding">createScript	"The method creates a workspace script for a subclass of WSDLClient "	^self createScriptFrom: self new</body><body package="WSDLBinding">createScriptFrom: aWsdlClient	| stream str ports |	aWsdlClient config 		ifNotNil: [ports :=  OrderedCollection new.				aWsdlClient config services do: [ :each | ports addAll: each ports]  ]		ifNil: [ aWsdlClient port ifNotNil: [ :port | ports := (OrderedCollection with:  aWsdlClient port) ]].	ports ifNil: [^self error: (#ThereIsNoPortDefinedForClient &lt;&lt; #webservices &gt;&gt; 'There is no ports defined for the client' )].	stream := (String new: 1024) writeStream.		stream nextPutAll: (#CreateClient &lt;&lt; #webservices &gt;&gt; '"Create the client"') asString; cr.	aWsdlClient class name = #WsdlClient 		ifTrue: [ aWsdlClient wsdlUrl ifNotNil: [				str := (aWsdlClient wsdlUrl protocol = 'file')					ifTrue: [ 'fileName: ''', aWsdlClient wsdlUrl asFilename asString]					ifFalse: ['url: ''',  aWsdlClient wsdlUrl asString].				stream nextPutAll: 'client := WsdlClient ', str; nextPutAll: '''.'; cr;cr]]		ifFalse: [stream tab; nextPutAll: 'client := ',  aWsdlClient class fullName, ' new.'; cr ].	ports do: [ :port |		aWsdlClient class name = #WsdlClient			ifTrue: [	stream 						tab; 						nextPutAll: 'client setPortNamed: (XML.NodeTag new qualifier: '''' ns: ', port name namespace printString, ' type: ', port name type printString, '). '; 						cr ].		port binding  operations 			do: [ :operation | operation createScriptOn: stream client: aWsdlClient ]			separatedBy: [ stream cr ]].	^stream contents</body><body package="WSDLBinding">createScriptUrl: aStringOrUrl	"The method creates a workspace script for WSDLClient " 	^self createScriptFrom: (WsdlClient url: aStringOrUrl)</body></methods><methods><class-id>WebServices.WsdlClient class</class-id> <category>private</category><body package="WSDLBinding">initializeBindingServiceMap: aConfigurationDescriptor x2oImports: xmlObjectBindings"The method is called by a specific client to set binding selector map and XMLObject bindings "	| binding |	binding := aConfigurationDescriptor bindings detect: [ :bx | bx name type = self bindingName ] ifNone: [^nil].	xmlObjectBindings ifNotNil: [xmlObjectBindings do: [ :x2o |  binding importBinding: x2o]]</body><body package="WSDLBinding">printRequestHeaderCommentOn: aStream headers: partMarshalers"The method creates a script to set Soap headers for WsdlClient "	aStream cr.	partMarshalers		do: [ :mx | 			aStream 				cr; tab; nextPutAll: '( client headerFor: #', mx tag type printString, ')';				cr; tab: 2; nextPutAll: 'value: ( '.			mx typeMarshaler valueMarshaler printArgsOn: aStream indentation: 3.			aStream nextPutAll: ').' ]		separatedBy: [aStream cr]</body><body package="WSDLBinding">saveIntoMethod: methName class: aClass comment: commentString do: aBlock	"Saves the Wsdl schema in class method "	XML.Document 		saveIntoMethod: methName 		class: aClass 		comment: commentString 		do: aBlock</body></methods><methods><class-id>WebServices.WsdlClient class</class-id> <category>wsdl schema</category><body package="WSDLBinding">wsdlSchema	"Subclass should return a wsdl schema string or WSDL URL. If WSDL schema has &lt;import&gt; statements the method has to return URL with WSDL schema location. This URL will be used to resolve &lt;import&gt; location elements "	^nil</body><body package="WSDLBinding">x2oBinding	"Subclass should return an X2O binding string if WSDL schema has types defined in &lt;schema&gt; elements"	^''</body></methods><methods><class-id>WebServices.SoapHeaderEntryMarshaler</class-id> <category>accessing</category><body package="SOAPBinding">inlineTypeNode	^self elementMarshalers first inlineTypeNode</body><body package="SOAPBinding">relations	| coll |	coll := OrderedCollection new.	valueMarshaler ifNotNil: [coll add: valueMarshaler].	coll addAll: self attributeMarshalers.	^coll</body><body package="SOAPBinding">valueMarshaler	^valueMarshaler</body></methods><methods><class-id>WebServices.SoapHeaderEntryMarshaler</class-id> <category>api -- unmarshal</category><body package="SOAPBinding">getRealMarshaler: marshalingContext unmarshal: anElement	^self</body><body package="SOAPBinding">unmarshalFrom: marshalingContext do: aBlock	| object child |	marshalingContext node ifNil: [MissingValueNotification raiseWith: self xpath xpathExpression printString].	marshalingContext marshaler: self.	object := marshalingContext marshaler smalltalkClass new.	object name: self tag. 	marshalingContext value: object.	self unmarshalElementsFrom: marshalingContext.	(child := marshalingContext newChild) 		nodeContext: marshalingContext nodeContext;		source: marshalingContext source;		value:  valueMarshaler typeMarshaler smalltalkClass new.	valueMarshaler isSimpleType		ifTrue: [ valueMarshaler unmarshalFrom: child ]		ifFalse: [ valueMarshaler unmarshalElementsFrom: child ].	marshalingContext value value: child value.	marshalingContext isUnresolved 		ifTrue: [marshalingContext value: (ObjectNotResolvedSignal raiseRequestWith: marshalingContext source)].	(marshalingContext value respondsTo: #_complete)		ifTrue: [marshalingContext value _complete].	aBlock value: marshalingContext.</body></methods><methods><class-id>WebServices.SoapHeaderEntryMarshaler</class-id> <category>api -- marshal</category><body package="SOAPBinding">getRealMarshalerMarshal: aMarshalingContext	^self</body><body package="SOAPBinding">privateMarshalFrom: marshalingContext	| child |	self attributeMarshalers do: [ :attrMarshaler | self marshalElement: attrMarshaler from: marshalingContext ].	(child := marshalingContext newChild) 					source: marshalingContext source;					value: (marshalingContext value value).	 valueMarshaler  isSimpleType		ifTrue: [ valueMarshaler marshalFrom: child ]		ifFalse: [valueMarshaler marshalElementsFrom: child ]</body></methods><methods><class-id>WebServices.SoapHeaderEntryMarshaler</class-id> <category>api -- builder</category><body package="SOAPBinding">buildFrom: aNode marshaler: aTypeMarshaler	self xpath buildFrom: aNode  xpath:  aNode  asString for: self.	self tag: aNode.	valueMarshaler := aTypeMarshaler typeMarshaler.</body></methods><methods><class-id>WebServices.Wsdl20SoapHeaderDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">element	^element</body><body package="WSDLDescriptors">element: aNodeTag	element := aNodeTag</body><body package="WSDLDescriptors">mustUnderstand	^mustUnderstand ifNil: [false]</body><body package="WSDLDescriptors">mustUnderstand: aBoolean	mustUnderstand := aBoolean</body><body package="WSDLDescriptors">required	^required ifNil: [false]</body><body package="WSDLDescriptors">required: aBoolean	required := aBoolean</body></methods><methods><class-id>WebServices.ClientProcessingPolicy</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream nextPutAll: '(', self class name,  ' new '.	interceptorClasses ifNotNil: [ 		aStream nextPutAll: 'interceptorClasses: ( OrderedCollection '.		interceptorClasses do: [ :each | aStream nextPutAll: ' with: '. each printOn: aStream ].		aStream nextPutAll: '); yourself );' ]</body></methods><methods><class-id>WebServices.ClientProcessingPolicy</class-id> <category>accessing</category><body package="WSDLBinding">adaptor	^adaptor</body><body package="WSDLBinding">adaptor: anObject	adaptor := anObject</body><body package="WSDLBinding">dispatcherClass	dispatcherClass ifNil: [ dispatcherClass := self class defaultDispatcherClass].	^dispatcherClass</body><body package="WSDLBinding">dispatcherClass: aClass	dispatcherClass := aClass</body><body package="WSDLBinding">interceptorClasses	^interceptorClasses ifNil: [ interceptorClasses := self class defaultInterceptorClasses ]</body><body package="WSDLBinding">interceptorClasses: aCollectionOfMessageInterceptor	interceptorClasses := aCollectionOfMessageInterceptor</body><body package="WSDLBinding">processOptionalHeaders	^processOptionalHeaders ifNil: [ self class defaultProcessOptionalHeaders ]</body><body package="WSDLBinding">processOptionalHeaders: aBoolean"	aBoolean &lt;Boolean&gt; should we unmarshal and process headers that are not marked 'MustUnderstand=true' ?"	processOptionalHeaders := aBoolean</body><body package="WSDLBinding">provideInterceptorDispatcher	^self dispatcherClass new		setInterceptors: ( self interceptorClasses collect: [ :each | each new] );		policy: self;		yourself</body></methods><methods><class-id>WebServices.ClientProcessingPolicy class</class-id> <category>defaults</category><body package="WSDLBinding">defaultDispatcherClass	^defaultDispatcherClass ifNil: [defaultDispatcherClass := self defaultDispatcherClassValue ]</body><body package="WSDLBinding">defaultDispatcherClass: aClass	defaultDispatcherClass := aClass</body><body package="WSDLBinding">defaultInterceptorClasses	^defaultInterceptorClasses ifNil: [ self defaultInterceptorClassesValue ]</body><body package="WSDLBinding">defaultInterceptorClasses: aClassOrCollection	defaultInterceptorClasses := (aClassOrCollection isSequenceable 		or: [aClassOrCollection isNil ])		ifTrue: [ 	aClassOrCollection ]		ifFalse: 	[ OrderedCollection with: aClassOrCollection ]</body><body package="WSDLBinding">defaultProcessOptionalHeaders	^defaultProcessOptionalHeaders ifNil: [ defaultProcessOptionalHeaders := self defaultProcessOptionalHeadersValue ]</body><body package="WSDLBinding">defaultProcessOptionalHeaders: aBoolean	defaultProcessOptionalHeaders := aBoolean</body></methods><methods><class-id>WebServices.ClientProcessingPolicy class</class-id> <category>default values</category><body package="WSDLBinding">defaultDispatcherClassValue	^ClientInterceptorDispatcher</body><body package="WSDLBinding">defaultInterceptorClassesValue 	^OrderedCollection new</body><body package="WSDLBinding">defaultProcessOptionalHeadersValue	^false</body></methods><methods><class-id>WebServices.ClientProcessingPolicy class</class-id> <category>instance creation</category><body package="WSDLBinding">new	^super new initialize</body></methods><methods><class-id>WebServices.WsdlConfiguration</class-id> <category>accessing</category><body package="WSDLBinding">addPort: aWsdlPort to: service	self interfaces add: aWsdlPort.	^service addPort: aWsdlPort.</body><body package="WSDLBinding">addService: aWsdlService	^services add: aWsdlService.</body><body package="WSDLBinding">anyPort	^[services first ports first] on: Error do: [ :ex | nil ]</body><body package="WSDLBinding">bindingNamed: aStringOrNode ifAbsent: aBlock	^(aStringOrNode isKindOf: NodeTag)		ifTrue: [self bindings detect: [ :b | b name  = aStringOrNode ] ifNone: aBlock ]		ifFalse: [ self bindings detect: [ :b | b name type = aStringOrNode] ifNone: aBlock ]</body><body package="WSDLBinding">bindings	^bindings</body><body package="WSDLBinding">bindings: aValue	bindings := aValue</body><body package="WSDLBinding">classDescriptor	^self subclassResponsibility</body><body package="WSDLBinding">descriptor	^descriptor ifNil: [ descriptor := self classDescriptor new ]</body><body package="WSDLBinding">descriptor: aWsdlConfigurationDescriptor	descriptor := aWsdlConfigurationDescriptor</body><body package="WSDLBinding">imports	^imports</body><body package="WSDLBinding">imports: aValue	imports := aValue</body><body package="WSDLBinding">interfaceClass	^self subclassResponsibility</body><body package="WSDLBinding">interfaces	^self descriptor interfaces</body><body package="WSDLBinding">interfaces: collPortDescriptor	self descriptor interfaces: collPortDescriptor</body><body package="WSDLBinding">name	^name</body><body package="WSDLBinding">name: aString	name := aString</body><body package="WSDLBinding">rebuildX2OBinding	^rebuildX2OBinding ifNil: [ self class rebuildX2OBinding ]</body><body package="WSDLBinding">rebuildX2OBinding: aBoolean	rebuildX2OBinding := aBoolean</body><body package="WSDLBinding">service	^(services notNil and: [ services notEmpty ])		ifTrue: [services first]		ifFalse: [self error: (#NoServiceSpecified &lt;&lt; #webservices &gt;&gt; 'No service specified')]</body><body package="WSDLBinding">serviceNamed: aString ifAbsent: aBlock	services isNil ifTrue: [^aBlock value].	^self services detect: [ :s | s name = aString ] ifNone: aBlock</body><body package="WSDLBinding">services	^services</body><body package="WSDLBinding">services: aValue	services := aValue</body><body package="WSDLBinding">soapBinding</body><body package="WSDLBinding">targetNamespace	^self descriptor targetNamespace</body><body package="WSDLBinding">targetNamespace: aValue	self descriptor targetNamespace: aValue</body></methods><methods><class-id>WebServices.WsdlConfiguration</class-id> <category>build components</category><body package="WSDLBinding">addImport: x20Binding	self imports detect: [ :binding | binding targetNamespace = x20Binding targetNamespace ] ifNone: [ self imports add: x20Binding ]</body><body package="WSDLBinding">buildBindingComponents	self bindings isEmpty ifTrue: [ ^WsdlParsingErrors raiseRequestErrorString: (#ThereIsNoBindingDescription &lt;&lt; #webservices &gt;&gt; 'There is no binding description in the schema')].</body><body package="WSDLBinding">buildBindingFaultsFrom: bindingDescriptor binding: binding</body><body package="WSDLBinding">buildBindingTransportFrom: bindingDescriptor binding: binding</body><body package="WSDLBinding">buildComponents	self 		buildSchemaBindings;		buildBindingComponents;		buildServiceComponents</body><body package="WSDLBinding">buildHttpBindingOperationsFrom: bindingDescriptor binding: binding</body><body package="WSDLBinding">buildInterfaceFrom: portDescriptor	|   port address |	(port := self interfaceClass new)  	portDescriptor: portDescriptor.	address := portDescriptor address.	(address notNil and: [address isKindOf: ValueHolder ]) ifTrue: [address := address value ].	address ifNotNil: [ port address: address asURI ].	(WsdlBinding  bindingAt: portDescriptor binding ifAbsent: [nil])		ifNotNil: [ :binding | 				port binding: binding.				binding port: port ].	WsdlPort register: port.	^port</body><body package="WSDLBinding">buildSchemaBindings	| anXMLElements |	anXMLElements := OrderedCollection new.	descriptor schemaBindings do: [ :binding | (self buildX2OBindingFor: binding) ifNotNil: [ :elems | anXMLElements addAll: elems] ].	"We need to collect all x2o bindings and then build XMLObjectBinding objects. There are possible cross-references in bindings "	(XMLObjectDriver buildBindingFromElements: anXMLElements) do: [ :binding | self addImport: binding ].</body><body package="WSDLBinding">buildServiceComponents	self services: ( descriptor services collect: [ :each | self buildServiceFrom: each ]).</body><body package="WSDLBinding">buildServiceFrom: serviceDescriptor	|  service |	(service := WsdlService new) serviceDescriptor: serviceDescriptor.	service ports: ( serviceDescriptor ports collect: [ :each | self buildInterfaceFrom: each ]).	WsdlService register: service.	self services add: service.	^service</body><body package="WSDLBinding">buildSoapBindingOperationFrom: operationBindingDescriptor binding: binding</body><body package="WSDLBinding">buildSoapBindingOperationsFrom: aBindingDescriptor binding: binding</body><body package="WSDLBinding">buildWsdlBindingFrom: bindingDescriptor	| binding |	binding := WsdlBinding new.	binding 		targetNamespace: descriptor targetNamespace;		bindingDescriptor: bindingDescriptor.	binding	importedBindings addAll: self imports.	self buildBindingTransportFrom: bindingDescriptor binding: binding.	self buildBindingFaultsFrom: bindingDescriptor binding: binding.	binding transport ifNotNil: [ :transport | transport buildOperationsFor: self from: bindingDescriptor ].	binding name ifNotNil: [WsdlBinding bindingAt: binding name  put: binding].	self bindings add: binding. 	^binding</body><body package="WSDLBinding">buildX2OBindingFor: aSchemaBindingElement	"XMLObjectBinding was already created  " 	(aSchemaBindingElement isKindOf: XMLObjectBinding) ifTrue: [self addImport: aSchemaBindingElement. ^nil ].	"There is already registered X2O binding with this target namespace and we don't want to rebuild it "	self rebuildX2OBinding ifFalse: [		( aSchemaBindingElement valueOfAttribute: 'targetNamespace' ifAbsent: [nil]) ifNotNil: [ :targetNamespace |			(XMLObjectBinding bindingAtNamespace: targetNamespace) ifNotNil: [ :x2o | self addImport: x2o. ^nil ]]].	"There is  &lt;schemaBinding&gt; element. Create and register XMLObjectBinding "					^ (aSchemaBindingElement isDocument 		ifTrue: [ aSchemaBindingElement root ] 		ifFalse: [ aSchemaBindingElement ]) realElements.</body></methods><methods><class-id>WebServices.WsdlConfiguration</class-id> <category>initialization</category><body package="WSDLBinding">buildComponentsFrom: aWsdlConfigurationDescriptor		descriptor := aWsdlConfigurationDescriptor.	self buildComponents</body><body package="WSDLBinding">initialize	imports := OrderedCollection new.	bindings := OrderedCollection new: 5.	services := OrderedCollection new: 5.</body></methods><methods><class-id>WebServices.WsdlConfiguration</class-id> <category>wsdl schema</category><body package="WSDLBinding">asWsdl	^ descriptor ifNil: [ nil ] ifNotNil: [ descriptor asWsdl ]</body></methods><methods><class-id>WebServices.WsdlConfiguration class</class-id> <category>instance creation</category><body package="WSDLBinding">buildComponentsFrom: aWsdlConfigurationDescriptor	^aWsdlConfigurationDescriptor configurationBuilder buildComponentsFrom: aWsdlConfigurationDescriptor</body><body package="WSDLBinding">buildConfigurationFrom: dataSource" dataSource: collection of XML.Document / Stream / URI "	^self defaultReadFrom: dataSource</body><body package="WSDLBinding">defaultReadFrom: dataSource" dataSource: collection of XML.Document / Stream / URI "	^self buildComponentsFrom: (WsdlConfigurationDescriptor defaultReadFrom: dataSource)</body><body package="WSDLBinding">new	^super new initialize</body><body package="WSDLBinding">objectReadFrom: aDataSource inNamespace: aString" dataSource: collection of XML.Document / Stream / URI "	^self buildComponentsFrom: (WsdlConfigurationDescriptor objectReadFrom: aDataSource inNamespace: aString)</body></methods><methods><class-id>WebServices.WsdlConfiguration class</class-id> <category>accessing</category><body package="WSDLBinding">defaultTransportUri	^self subclassResponsibility.</body><body package="WSDLBinding">rebuildX2OBinding	^rebuildX2OBinding ifNil: [ true ]</body><body package="WSDLBinding">rebuildX2OBinding: aBoolean	rebuildX2OBinding := aBoolean</body></methods><methods><class-id>WebServices.WsdlConfiguration class</class-id> <category>wsdl schema</category><body package="WSDLBinding">asWsdlAt: targetNamespaceString	^self new  		descriptor: ( WsdlConfigurationDescriptor initializeFor: targetNamespaceString); 		asWsdl</body></methods><methods><class-id>WebServices.Wsdl11Configuration</class-id> <category>accessing</category><body package="WSDLBinding">classDescriptor	^Wsdl11ConfigurationDescriptor</body><body package="WSDLBinding">headerEntryMarshaler	^SoapBinding soap11Binding marshalerForClass: Soap11HeaderEntry ifAbsent: [nil]</body><body package="WSDLBinding">interfaceClass	^WsdlPort</body><body package="WSDLBinding">messages	^self descriptor messages</body><body package="WSDLBinding">messages: aCollection	self descriptor messages:  aCollection</body><body package="WSDLBinding">soapBinding	^SoapBinding soap11Binding</body></methods><methods><class-id>WebServices.Wsdl11Configuration</class-id> <category>private</category><body package="WSDLBinding">buildFaultMarshalers: operationBindingDescriptor operation: interfaceOperation operationBinding: operationBinding binding: binding	"http://www.ws-i.org/profiles/basicprofile-1.1.html#name_Attribute_on_Faults4.7.15 name Attribute on FaultsThere is inconsistency between the WSDL 1.1 specification and the WSDL 1.1 schema, which does not list the name attribute.R2721 A wsdl:binding in a DESCRIPTION MUST have the name attribute specified on all contained soapbind:fault elements.R2754 In a DESCRIPTION, the value of the name attribute on a soapbind:fault element MUST match the value of the name attribute on its parent wsdl:fault element. "	| intOperationFault faultName |	^operationBindingDescriptor faults collect: 		[:bindingFaultType |		faultName := bindingFaultType fault name ifNil: [			bindingFaultType name ifNil: [				Error 					raiseWith: operationBindingDescriptor					errorString: ('Operation #&lt;1s&gt; in binding #&lt;2s&gt;: A fault did not specify the required name attribute on its soap:fault element.' expandMacrosWith: operationBindingDescriptor name type with: binding name type)]].		intOperationFault := interfaceOperation faults			detect: [:intOperationParameter | faultName = intOperationParameter key type]			ifNone: [ Error 						raiseWith: bindingFaultType						errorString: ('Operation #&lt;1s&gt; fault #&lt;2s&gt; in binding #&lt;3s&gt;: The fault name does not match the name of any fault element of the corresponding operation in the portType.' 										expandMacrosWith: operationBindingDescriptor name type										with: faultName										with: binding name type)].			SoapWsdl11PartBinding new				buildFaultMarshalerFor: intOperationFault operation: operationBinding 	binding: binding;				yourself ]</body><body package="WSDLBinding">buildHeaderMarshalers: headers operation: operation operationBinding: operationBinding  binding: binding	| headerMarshaler headerBinding soapBinding headerEntryBindings headerEntryMarshaler |	headers == nil ifTrue: [ ^nil].	binding isSoap12		ifTrue: [ soapBinding := SoapBinding soap12Binding.				headerEntryMarshaler := SoapBinding soap12Binding marshalerForClass: Soap12HeaderEntry ifAbsent: [nil].]		ifFalse: [soapBinding :=  SoapBinding soap11Binding.				headerEntryMarshaler := SoapBinding soap11Binding marshalerForClass: Soap11HeaderEntry ifAbsent: [nil]. ].	headerMarshaler := (soapBinding marshalers 			detect: [ :marshaler | marshaler tag type = 'Header'] 			ifNone: [^self error:  ((#NotSupportedTransportBinding &lt;&lt; #webservices &gt;&gt; 'There is no marshaler for &lt;Header&gt; in the Soap binding &lt;1s&gt;') expandMacrosWith: soapBinding targetNamespace) ]) copy.	headerEntryBindings := headers collect:		[ :headerDescriptor |  		descriptor resolveMessageFor: headerDescriptor.		headerDescriptor faults do: [ :headerFault |  descriptor resolveMessageFor: headerFault ].		headerBinding := SoapWsdl11HeaderBinding new.		headerBinding structMarshaler: headerMarshaler.		headerBinding entryMarshaler: headerEntryMarshaler.		headerBinding style: operationBinding style.		headerBinding			buildHeaderMarshalerFor: headerDescriptor message			operation: operation 			from: headerDescriptor 			binding: binding.		headerBinding].	^Array with: headerMarshaler with: headerEntryBindings</body><body package="WSDLBinding">buildMarshalerFor: message operation: operation from: bindingDescriptor operationBinding: operationBinding binding: binding	^SoapWsdl11PartBinding new		style: operationBinding style;		buildMarshalerFor: message 		operation: operation 		from: bindingDescriptor 		binding: binding;		yourself</body><body package="WSDLBinding">registerOperationMarshalers: operationBinding binding: binding	operationBinding marshalers 		do: [ :m | (binding marshalers includes: m) ifFalse: [binding addElementMarshaler: m ] ]</body><body package="WSDLBinding">resolveMessagesFrom: aWsdlInterfaceOperation	aWsdlInterfaceOperation input ifNotNil: [ :inputMessage |		inputMessage			resolveFrom: descriptor  			ifError:  [WsdlParsingErrors raiseRequestErrorString: ((#CanNotResolveOperationInputMessage1s &lt;&lt; #webservices &gt;&gt;  'Cannot resolve the operation &lt;1s&gt;  input message &lt;2s&gt;') expandMacrosWith: aWsdlInterfaceOperation name printString with: inputMessage printString) ]].	aWsdlInterfaceOperation output ifNotNil: [ :outputMessage |		outputMessage 			resolveFrom: descriptor 			ifError:  [WsdlParsingErrors raiseRequestErrorString: ((#CanNotResolveOperationOutputMessage1s &lt;&lt; #webservices &gt;&gt;  'Cannot resolve the operation &lt;1s&gt;  output message &lt;2s&gt;') expandMacrosWith: aWsdlInterfaceOperation name printString with: outputMessage printString) ]].	aWsdlInterfaceOperation faults do: [ :each | 		each 			resolveFrom: descriptor			ifError:  [WsdlParsingErrors raiseRequestErrorString: ((#CanNotResolveOperationFaultMessage1s &lt;&lt; #webservices &gt;&gt;  'Cannot resolve the operation &lt;1s&gt;  fault message &lt;2s&gt;') expandMacrosWith: aWsdlInterfaceOperation name printString with: each name printString) ]].</body><body package="WSDLBinding">validateStyle: aString andMessagePartDefinition: aWsdl11MessageDescriptor"http://www.ws-i.org/profiles/basicprofile-1.1-2004-08-24.html#Bindings_and_PartsR2203 An rpc-literal binding in a DESCRIPTION MUST refer, in its soapbind:body element(s), only to wsdl:part element(s) that have been defined using the type attribute. R2204 A document-literal binding in a DESCRIPTION MUST refer, in each of its soapbind:body element(s), only to wsdl:part element(s) that have been defined using the element attribute. "	aWsdl11MessageDescriptor parts ifNil: [^nil].	aWsdl11MessageDescriptor parts do: [ :part |		(aString = #rpc and: [ part typeName isNil]) 			ifTrue: [ self error: ((#WSDLNotCompliantWithBPRpcType &lt;&lt; #webservices &gt;&gt; 'The WSDL is not compliant with Basic Profile 1.1. In #rpc style WSDL the message &lt;1s&gt; parts have to be defined using the type attribute' ) expandMacrosWith: aWsdl11MessageDescriptor name printString)].		(aString = #document and: [ part elementName isNil])			ifTrue: [ self error: ((#WSDLNotCompliantWithBPDocElement &lt;&lt; #webservices &gt;&gt; 'The WSDL is not compliant with Basic Profile 1.1. In #document style WSDL the message &lt;1s&gt;  parts have to be defined using the element attribute' ) expandMacrosWith: aWsdl11MessageDescriptor name printString) ].	].</body></methods><methods><class-id>WebServices.Wsdl11Configuration</class-id> <category>build components</category><body package="WSDLBinding">buildBindingComponents	descriptor  bindings do: [ :each | each bindingType ifNotNil: [self buildWsdlBindingFrom: each ]].	super buildBindingComponents.	self bindings do: [ :binding |  		descriptor soapEncoding ifTrue: [ binding useReference: true ]]</body><body package="WSDLBinding">buildBindingTransportFrom: bindingDescriptor binding: binding	bindingDescriptor bindingType ifNil: ["We got non-supported transport. Skip it" ^nil].	binding transport: bindingDescriptor bindingTransport.	binding transport binding: binding.</body><body package="WSDLBinding">buildSoapBindingOperationFrom: operationBindingDescriptor binding: binding	| interfaceOperation  operationBinding |	binding transport ifNil: ["not supported transport in Wsdl 1.1 " ^nil].	operationBinding :=  binding transport operationBindingClass  new		initializeFrom: operationBindingDescriptor binding: binding  transport: binding transport;		yourself.	interfaceOperation := operationBindingDescriptor parent interfaceDescriptor operations 			detect: [ :operationx | operationx name type = operationBinding name type]			ifNone: [ WsdlParsingErrors raiseRequestErrorString: ((#Operation1sIsNotDefined &lt;&lt; #webservices &gt;&gt; 'Operation &lt;1s&gt; is not defined') expandMacrosWith: operationBinding name asString)].	operationBindingDescriptor interfaceDescriptor: interfaceOperation.	self  resolveMessagesFrom: interfaceOperation.	interfaceOperation setDefaultsForStyle: operationBinding style.	(self 		buildHeaderMarshalers: operationBindingDescriptor  inputSoapHeaders		operation: interfaceOperation 		operationBinding: operationBinding		binding: binding) 			ifNotNil: [ :coll |					operationBinding inputHeaderMarshaler: coll first.					operationBinding inputHeaderBindings: coll last].	(self 		buildHeaderMarshalers: operationBindingDescriptor  outputSoapHeaders		operation: interfaceOperation 			operationBinding: operationBinding		binding: binding)			ifNotNil: [ :coll |				operationBinding outputHeaderMarshaler: coll first.				operationBinding outputHeaderBindings: coll last].	interfaceOperation input ifNotNil: [ 		self validateStyle: operationBinding style andMessagePartDefinition: interfaceOperation input message.		operationBinding inputBodyMarshaler: ( self				buildMarshalerFor: interfaceOperation input			operation: interfaceOperation 			from: operationBindingDescriptor inputSoapBody			operationBinding: operationBinding			binding: binding). ]. 	interfaceOperation output ifNotNil: [ 		self validateStyle: operationBinding style andMessagePartDefinition: interfaceOperation output message.		operationBinding outputBodyMarshaler: ( self				buildMarshalerFor: interfaceOperation output			operation: interfaceOperation 			from: operationBindingDescriptor outputSoapBody			operationBinding: operationBinding			binding: binding)].	operationBinding faultMarshalers: ( self 						buildFaultMarshalers: operationBindingDescriptor 						operation: interfaceOperation 						operationBinding: operationBinding						binding: binding).	^operationBinding</body><body package="WSDLBinding">buildSoapBindingOperationsFrom: aBindingDescriptor binding: binding	| op  opMap |	binding operations: OrderedCollection new.	opMap := Dictionary new: 30.	aBindingDescriptor operations		do: [ :operationDescriptor | 				op := self buildSoapBindingOperationFrom: operationDescriptor binding: binding .				(opMap at: op name type asSymbol ifAbsent: [ nil])					ifNil: [ opMap at: op name type asSymbol put: op.						binding operations add: op.						self registerOperationMarshalers: op binding: binding]					ifNotNil:	[WsdlParsingErrors 							raiseRequestWith: op 							errorString: ((#OperationNameIsNotUnique &lt;&lt; #webservices &gt;&gt; 'The operation name #&lt;1s&gt; is not unique. Overloaded operations are not supported') expandMacrosWith: operationDescriptor name asString) ]].</body></methods><methods><class-id>WebServices.Wsdl11Configuration class</class-id> <category>accessing</category><body package="WSDLBinding">defaultOperationStyle	^'rpc'</body><body package="WSDLBinding">defaultTransportUri	^WsdlBinding httpTransportUri</body><body package="WSDLBinding">transports" Answer map transport (uri-&gt;selector answering transport). Note the hack below -- we maintain two forms of http transport URI -- with and without trailing slash because of many sloppy WSDL documents that misspell it "	^Dictionary new		at: 'http://schemas.xmlsoap.org/soap/http/' put: #soapHttpTransport;		at: WsdlBinding wsdl11_soap_http_uri  put: #soapHttpTransport;		yourself</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>accessing</category><body package="WSDLBinding">arguments" Arguments is used by WsdlBinding when marshaling the request "	^smalltalkEntity arguments</body><body package="WSDLBinding">handler</body><body package="WSDLBinding">message	^self smalltalkEntity</body><body package="WSDLBinding">selector	^self smalltalkEntity selector</body><body package="WSDLBinding">transportClient	^self transport client</body><body package="WSDLBinding">transportClient: aNetClient	^self transport client: aNetClient</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>converting</category><body package="WSDLBinding">asResponse	^self responseClass new		from: self;		request: self;		yourself</body><body package="WSDLBinding">responseClass	^SoapResponse</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>api - execute</category><body package="WSDLBinding">execute	self setOperation; marshal. 	^self executeTransportEntity: self transportEntity</body><body package="WSDLBinding">executeTransportEntity: aTransportEntity	| transportResponse |	transportEntity := aTransportEntity.	transportResponse := self transport sendAndWaitForReply: self.	^self asResponse		transportEntity: transportResponse;		interceptorDispatcher: self interceptorDispatcher;		unmarshal;		yourself</body><body package="WSDLBinding">executeWith: aNetClient	self transportClient: aNetClient.	^self execute</body><body package="WSDLBinding">value	^self execute value</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>initialization</category><body package="WSDLBinding">setOperation	self smalltalkEntity ifNil: [^nil].	(operation == nil or: [ self smalltalkEntity selector asString ~= operation name type ])		ifTrue: 			[operation := self binding operations 							detect: [ :opBinding | self accepts: opBinding ]							ifNone: [ ^self error: ((#NoDefinedOperationFor &lt;&lt; #webservices &gt;&gt; 'No defined operation for &lt;1s&gt;')									expandMacrosWith: smalltalkEntity selector asString)].			transport ifNotNil: [ operation transport: transport ]].</body><body package="WSDLBinding">setOperationFrom: anXMLElement	operation := self binding transport findOperationForRequest:  anXMLElement</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>testing</category><body package="WSDLBinding">needsHeader: aSymbol	^self  operation notNil		ifTrue: [ self operation needsInputHeader: aSymbol ]		ifFalse: [ false ]</body><body package="WSDLBinding">successful	^true</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>api -- translation</category><body package="WSDLBinding">accepts: anSoapOperationBinding	^anSoapOperationBinding name type asSymbol = self selector		or: [(self binding findSelectorForOperation: anSoapOperationBinding name type) = self selector ]</body><body package="WSDLBinding">findSelectorForOperation	^self binding findSelectorForOperation: self operation name type.</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>api - marshal</category><body package="WSDLBinding">marshalDom" Marshal Smalltalk object into XML Document "	transportEntity := self operation prepareRequestFor:  self.	dom := self operation 		marshalRequestIn: self transportEntity 		with: self smalltalkEntity 		header: self header.	^dom</body><body package="WSDLBinding">sendingMessage	self interceptorDispatcher sendingRequest: self in: self transportEntity.</body><body package="WSDLBinding">sendingMessageDOM	self interceptorDispatcher sendingRequestDOM: self dom</body><body package="WSDLBinding">sendingMessageEnvelope	self interceptorDispatcher sendingRequestEnvelope: self in: self transportEntity</body></methods><methods><class-id>WebServices.SoapRequest</class-id> <category>api - unmarshal</category><body package="WSDLBinding">unmarshal: anXMLElement	self operation ifNil: [self setOperationFrom: anXMLElement].	^self operation  unmarshalRequest: anXMLElement</body><body package="WSDLBinding">unmarshalBodyFromXML: anXMLElement	self operation ifNil: [self setOperationFrom: anXMLElement].	^self operation unmarshalBodyFromXML: anXMLElement</body></methods><methods><class-id>WebServices.OperationBinding</class-id> <category>accessing</category><body package="WSDLBinding">binding	^binding</body><body package="WSDLBinding">binding: anObject	binding := anObject</body><body package="WSDLBinding">descriptor	^descriptor</body><body package="WSDLBinding">descriptor: anObject	descriptor := anObject</body><body package="WSDLBinding">inputBodyMarshaler	^inputBodyMarshaler</body><body package="WSDLBinding">inputBodyMarshaler: aSoapParameterMarshaler	inputBodyMarshaler := aSoapParameterMarshaler</body><body package="WSDLBinding">inputBodyParameters	| inputMarshaler |	self inputBodyMarshaler structMarshaler ifNotNil: [^#() ].	(inputMarshaler :=  self inputBodyMarshaler bodyMarshaler) ifNil: [^#()].	inputMarshaler := inputMarshaler  typeMarshaler.	^(inputMarshaler isComplexTypeMarshaler 		and: [inputMarshaler isDictionaryType 			and: [inputMarshaler relations notEmpty ]])		ifTrue: [inputMarshaler relations ]		ifFalse: [ OrderedCollection with: inputMarshaler ]</body><body package="WSDLBinding">name	^descriptor name</body><body package="WSDLBinding">name: aNodeTag	descriptor name: aNodeTag</body><body package="WSDLBinding">outputBodyMarshaler	^outputBodyMarshaler</body><body package="WSDLBinding">outputBodyMarshaler: aSoapParameterMarshaler	outputBodyMarshaler := aSoapParameterMarshaler</body><body package="WSDLBinding">transport	^transport ifNil: [self binding transport]</body><body package="WSDLBinding">transport: aTransportBinding	transport := aTransportBinding</body></methods><methods><class-id>WebServices.OperationBinding</class-id> <category>tool</category><body package="WSDLBinding">asKeyword: aString on: aStream"Lowercase the first letter, remove underscores and uppercase any letter after an underscore."	aString inject: nil into: [ :prev :next |		next = $_ ifFalse: [			aStream nextPut: (prev = $_				ifTrue: [ next asUppercase ]				ifFalse: [ prev = nil					ifTrue: [ next asLowercase ]					ifFalse: [ next ] ])].		next]</body><body package="WSDLBinding">equivalentSmalltalkMessageName	^self operationSelector</body><body package="WSDLBinding">inputHeaderMarshaler	^nil</body><body package="WSDLBinding">operationSelector	| opName stream   inputParameters |	opName := self name asString. 	stream := (String new: opName size) writeStream.	self asKeyword: opName on: stream.	"There is no parts in the message"	(inputParameters := self inputBodyParameters)  isEmpty ifTrue: [ ^stream contents ].	stream	nextPut: $:.	inputParameters size = 1 ifTrue:[ ^stream contents ].	2 to: inputParameters size do: [ :ind |		self  asKeyword: (inputParameters at: ind) name type on: stream.		stream nextPut: $: ].	^stream contents asSymbol</body><body package="WSDLBinding">usePart1InSelector		^false</body></methods><methods><class-id>WebServices.OperationBinding</class-id> <category>wsdl -- initialization</category><body package="WSDLBinding">initializeFrom: aWsdlOperationBindingDescriptor binding: aWsdlBinding transport: aTransportBinding	descriptor := aWsdlOperationBindingDescriptor.	binding := aWsdlBinding.	transport := aTransportBinding</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>testing</category><body package="WSDLBinding">canAcceptInputTag: aNodeTag	^(self inputBodyMarshaler partMarshalers anySatisfy: [ :marshaler | marshaler tag = aNodeTag ])		or: [self name = aNodeTag ]</body><body package="WSDLBinding">canAcceptOutputTag: aNodeTag	^self outputBodyMarshaler notNil		and: [ self outputBodyMarshaler partMarshalers anySatisfy: [ :marshaler | marshaler tag = aNodeTag ]]</body><body package="WSDLBinding">isInOnly	^false</body><body package="WSDLBinding">isMarshalerResultWrapper: marshaler	^((self isParameterStructMarshaler: marshaler)		and: [marshaler relations size = 1 			and: [marshaler relations first relation getSelector = #result]])</body><body package="WSDLBinding">isOneWay	^false</body><body package="WSDLBinding">isParameterStructMarshaler: marshaler	^marshaler notNil and: [marshaler isStructMarshaler]</body><body package="WSDLBinding">isRobustInOnly	^false</body><body package="WSDLBinding">isRpc	^self subclassResponsibility</body><body package="WSDLBinding">needsFaultHeader: aSymbol" Is used from header interceptors"	^false</body><body package="WSDLBinding">needsInputHeader: aSymbol" Is used from header interceptors"		^self subclassResponsibility</body><body package="WSDLBinding">needsOutputHeader: aSymbol" Is used from header interceptors"	^self subclassResponsibility</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>accessing</category><body package="WSDLBinding">action	^nil</body><body package="WSDLBinding">bodyMarshalerFor: envMarshaler	^(envMarshaler relations detect: [ :mx | mx tag type = 'Body' ] ifNone: [nil]) typeMarshaler.</body><body package="WSDLBinding">bodyTag	| ns |	ns := self transport soapVersion = '1.1' ifTrue: [SoapBinding soap11_uri ] ifFalse: [ SoapBinding soap12_uri ].	^NodeTag new qualifier: '' ns: ns 	type: 'Body'</body><body package="WSDLBinding">envelope	^SoapEnvelope</body><body package="WSDLBinding">headerEntryMarshaler	^self binding		marshalerForTag:  (NodeTag qualifier: '' ns: self binding targetNamespace  type: 'SoapHeaderEntry')		ifAbsent: [nil]</body><body package="WSDLBinding">headerMarshalerFor: envMarshaler	^(envMarshaler relations detect: [ :mx | mx tag type = 'Header' ] ifNone: [nil])</body><body package="WSDLBinding">headerTag	| ns |	ns := self transport soapVersion = '1.1' ifTrue: [SoapBinding soap11_uri ] ifFalse: [ SoapBinding soap12_uri ].	^NodeTag new qualifier: '' ns: ns 	type: 'Header'</body><body package="WSDLBinding">manager	^SoapMarshalingManager  on: self binding</body><body package="WSDLBinding">selector	 | selector |	(binding notNil and: [binding serviceMap notNil]) ifTrue: [ selector := binding findSelectorForOperation: self name type ].	^selector ifNil: [ self equivalentSmalltalkMessageName ]</body><body package="WSDLBinding">soapEnvelopeMarshaler	^self binding soapEnvelopeMarshaler</body><body package="WSDLBinding">style	^nil</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>marshal response</category><body package="WSDLBinding">marshalResponse: aCollection header: aHeader transportEntity: aHttpEntity"Opentalk-Soap callback. "	^self marshalResponsetIn: aHttpEntity with: aCollection header: aHeader</body><body package="WSDLBinding">marshalResponseFault: aFault transportEntity: anHttpEntity" Marshal fault message. "	self isInOnly ifTrue: [ ^nil ].	self transport binding ifNil: [self transport binding: binding].	^self transport 		marshalResponseFault: aFault 		transportEntity: anHttpEntity		with: (self outputFaultMarshalerFor: aFault)</body><body package="WSDLBinding">marshalResponseWith: anArguments header: header" Marshal Smalltalk object and header objects into XML Element"	^self subclassResponsibility</body><body package="WSDLBinding">marshalResponsetIn: aTransportEntity with: anArguments header: aSoapHeader" Marshal Smalltalk object into XML Document "	^self marshalResponseWith: anArguments header: aSoapHeader.</body><body package="WSDLBinding">outputFaultMarshalerFor: aFault	^self subclassResponsibility</body><body package="WSDLBinding">outputHeaderBindings	^self subclassResponsibility</body><body package="WSDLBinding">processFault: aSoapFault	^aSoapFault detail isStruct		ifTrue: [ | detail |			detail := aSoapFault detailContentFirst.			detail isSignalledException				ifTrue: [ detail localErrorString ifNil: [detail messageText: aSoapFault faultString].    						detail ]				ifFalse: [ aSoapFault ] ]		ifFalse: [ aSoapFault ]</body><body package="WSDLBinding">raiseAsUserHeaderError: anException	^self subclassResponsibility</body><body package="WSDLBinding">responseValueFrom: anObject requestArguments: anArguments	anObject isSoapFault ifTrue: [ ^( self  processFault: anObject asSpecificFault ) raise].	^self isRpc		ifTrue: [self rpcValue: anObject requestArguments: anArguments ]		ifFalse: [self class wrapDocumentLiteralResult 					ifTrue: [  OrderedCollection with: anObject ]					ifFalse: [ anObject] ].</body><body package="WSDLBinding">rpcValue: result requestArguments: anArguments	^self subclassResponsibility</body><body package="WSDLBinding">setOneWayResponseCode: anHttpResponse</body><body package="WSDLBinding">unmarshalResponse: aSoapResponse	^self subclassResponsibility</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>marshal request</category><body package="WSDLBinding">inputHeaderBindings	^self subclassResponsibility</body><body package="WSDLBinding">marshalRequestIn: aTransportEntity with: smalltalkEntity header: aSoapHeader" Marshal Smalltalk object into something ready for transport "	^self 		marshalRequestWith: (self setRequestArgumentsFrom: smalltalkEntity ) asArray 		header: aSoapHeader.</body><body package="WSDLBinding">marshalRequestWith: anArguments header: header" Marshal Smalltalk object and header objects into XML Element"	^self subclassResponsibility</body><body package="WSDLBinding">prepareTargetArguments:  arguments selector: aSymbol" Opentalk callback. Prepare arguments based on a service selector "	| m  |	(m := self inputBodyMarshaler partMarshaler) isNil ifTrue: [^#() ].	^(m typeMarshaler isObjectTypeMarshaler 		and: [m typeMarshaler isDictionaryType 			and: [m typeMarshaler relations size = (aSymbol occurrencesOf: $:) ]])		ifTrue: [arguments  values asArray ]		ifFalse: 	[Array with: arguments ]</body><body package="WSDLBinding">setRequestArgumentsFrom: aCollection</body><body package="WSDLBinding">smalltalkEntityFromRequest: anObject" Opentalk callback"	| arguments  requestSelector | 	requestSelector := self binding findSelectorForOperation: self name type.	arguments := self  isRpc			ifTrue: [self smalltalkEntityFromRpcRequest: anObject selector: requestSelector ]			ifFalse: [self prepareTargetArguments:  anObject  selector: requestSelector ].	^(Message selector: requestSelector arguments: arguments asArray).</body><body package="WSDLBinding">smalltalkEntityFromRpcRequest: soapEnvelope selector: requestSelector	^self subclassResponsibility</body><body package="WSDLBinding">unmarshalAsMessage: anXMLElement	" Opentalk callback"	| env |	env := self unmarshalBodyFromXML: anXMLElement.	^self smalltalkEntityFromRequest: env bodyContents</body><body package="WSDLBinding">unmarshalRequest: anXMLElement" Unmarshal XML Element in to Smalltalk object "	^self unmarshalSoapEnvelope: anXMLElement</body><body package="WSDLBinding">verifyRequestHeaderFrom: xmlElements"A SOAP header block MAY carry a mustUnderstand attribute . When the value of such an attribute information item is 'true', the SOAP header block is said to be mandatory. For every mandatory SOAP header block targeted to a node, that node MUST either process the header block or not process the SOAP message at all, and instead generate a fault. Tagging SOAP header blocks as mandatory thus assures that such modifications will not be silently (and, presumably, erroneously) ignored by a SOAP node to which the header block is targeted.If one or more of the SOAP header blocks identified in the preceding step are not understood by the node then generate a single SOAP fault with the Value of Code set to 'env:MustUnderstand'  If such a fault is generated, any further processing MUST NOT be done. "	| missingHeaders notUnderstood |	missingHeaders := String new.	"First, make sure that all mandatory headers are present "	self inputHeaderBindings do: [ :headerBinding | 		headerBinding partMarshalers first isMandatory ifTrue: 			[xmlElements detect: [ :el | el tag = headerBinding partMarshalers first tag ] ifNone: [missingHeaders := missingHeaders, ' ', headerBinding partMarshalers first tag type ]] ].	missingHeaders isNotEmpty ifTrue: [		(transport senderFault faultString: (( #MissingRequiredHeaders1s &lt;&lt; #webservices &gt;&gt; 'Missing required headers: &lt;1s&gt; ') expandMacrosWith: missingHeaders) )					raise ].	"Second, make sure that unknown headers don't have mustUnderstand = 'true' "	notUnderstood := Set new.	xmlElements do: [ :el |		((self inputHeaderBindings detect: [ : headerBinding | el tag = headerBinding partMarshalers first tag ] ifNone: [nil]) isNil			and: [binding muValueOfAttribute: el ]) ifTrue: [ notUnderstood add: el tag]].		notUnderstood do: [ :tag |(binding elementMarshalerForTag: tag ifAbsent: [nil]) ifNotNil: [notUnderstood remove: tag]].	notUnderstood notEmpty ifTrue: 			[ transport mustUnderstandFault new				parameter: notUnderstood asOrderedCollection;				raise ].</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream nextPutAll: self class name asString.	self name ifNotNil: [ aStream nextPutAll: ' name=';					nextPutAll: self name asString.].	self style ifNotNil: [aStream 					nextPutAll: ' style=';					nextPutAll: self style].	self action notNil		ifTrue: 			[aStream 				nextPutAll: ' soapAction="';				nextPutAll: self action;				nextPut: $"].</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>private creating script</category><body package="WSDLBinding">anyHeaderBinding	^nil</body><body package="WSDLBinding">argumentMarshalers	^self isRpc		ifTrue: 	[ self inputBodyMarshaler partMarshalers ]		ifFalse: [ | argMarshalers bodyMarshaler |				self inputBodyMarshaler hasInputParameters ifFalse: ["there is no input parameters" ^#() ].				argMarshalers := OrderedCollection new.				bodyMarshaler := self inputBodyMarshaler bodyMarshaler typeMarshaler.				(bodyMarshaler isStructMarshaler and: [bodyMarshaler relations notEmpty])					ifTrue: [  argMarshalers addAll: bodyMarshaler relations ]					ifFalse: [argMarshalers add: bodyMarshaler ].					argMarshalers]</body><body package="WSDLBinding">argumentsFor: aClient indentation: indentation	|  m currentArg  method sel value aStream selTokens outputScript argumentMarshalers |	outputScript := self returnType.	value := (outputScript ifNotNil: ['value := client'] ifNil: ['client']).	argumentMarshalers :=  self argumentMarshalers.	aStream := String new writeStream.	aClient class = WsdlClient		ifTrue: [	argumentMarshalers  isEmpty					ifTrue: [aStream tab; nextPutAll: 'args := Array new.' ]					ifFalse: 	[  self printWsdlClientScriptOn: aStream marshalers: argumentMarshalers.							aStream position: aStream position -1.							aStream nextPut: $. ].  				^aStream contents -&gt; (value, ' executeSelector: #', self name type, ' args: args.')].	selTokens :=  self selector asString tokensBasedOn: $: .	(argumentMarshalers isNil or: [argumentMarshalers isEmpty]) ifTrue: [ ^nil-&gt;(value, ' ', selTokens first, '.') ].	method := String new writeStream.	method nextPutAll: value.	1 to: argumentMarshalers size		do: [ :ind |			m := argumentMarshalers at: ind.			sel := selTokens at: ind.			currentArg := 'arg', ind printString.			aStream crtab: indentation; nextPutAll: currentArg, ' := '.			m printArgsOn: aStream indentation: 1.			aStream nextPut: $..			method nextPutAll: ' ', sel, ': arg', ind printString]. 	method nextPut: $..	^aStream contents-&gt;method contents</body><body package="WSDLBinding">bodyExceptions</body><body package="WSDLBinding">headerExceptions	^OrderedCollection new.</body><body package="WSDLBinding">headerPartMarshalers		^self subclassResponsibility</body><body package="WSDLBinding">printExceptions: aCollection on: stream indentation: number	stream cr;tab: number; nextPutAll: 'on: '.	(aCollection asSortedCollection:  [:a :b | a name &lt;= b name])		do: [ :excCl | stream nextPutAll: excCl fullName ]		separatedBy: [ stream nextPutAll: ', ' ].	stream cr;tab: number; nextPutAll: 'do: [ :exception | Dialog warn: exception errorString ].'.</body><body package="WSDLBinding">printHeaderExceptions: aCollection on: stream indentation: indentation	stream 		cr; tab: indentation; nextPutAll: 'on: WebServices.SoapClientFault';		cr; tab: indentation; nextPutAll: 'do: [ :exception | Dialog warn: exception errorString].'.</body><body package="WSDLBinding">printRequestHeaderCommentOn: aStream client: aClient	| intName env headerBindings |	(headerBindings := self anyHeaderBinding) ifNil: [ ^nil].	((aClient isKindOf: WsdlClient) and: [aClient class name = #WsdlClient]) ifTrue: [ 		^aClient 			printRequestHeaderCommentOn: aStream 			headers: self headerPartMarshalers ].	aStream cr; nextPut: $".	aStream nextPutAll: 'The request requires Soap header blocks. Add Soap headers to the request in interceptor classes: '.	headerBindings 		do: [ :mx | 			env := (aClient isBehavior ifTrue: [ aClient ] ifFalse: [ aClient class])  environment name.			intName := (WebServices.ClientMessageInterceptor detectInterceptorNamed: mx path type asSymbol  in: env)				ifNotNil: [ :cl | cl fullName]				ifNil: [env asString, '.', (XMLObjectBindingPolicy 											createSmalltalkClassNameFrom: mx path type, 'Interceptor'											inNamespace:  env 											useExistingClassName: true) ].			aStream cr; nextPutAll: 'RefactoringBrowser newOnClass: ', intName, '.' ].	aStream cr; nextPut: $"</body><body package="WSDLBinding">printWsdlClientScriptOn: aStream marshalers: marshalers</body><body package="WSDLBinding">returnMarshaler	^nil</body><body package="WSDLBinding">returnType		^self setReturnObject: self returnMarshaler</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>tool</category><body package="WSDLBinding">setReturnObject: aTypeMarshaler 	| stream outStream c |	aTypeMarshaler ifNil: [^nil].	stream := String new readWriteStream.	aTypeMarshaler printArgsOn: stream indentation: 0.	stream reset.	outStream := String new writeStream.	[ stream atEnd ]		whileFalse:			[ c := stream next.			c = $"				ifTrue: [ outStream nextPut: $' ]				ifFalse: [ outStream nextPut: c]].	^outStream contents</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>private</category><body package="WSDLBinding">marshalArguments: anArguments header: header bodyMarshaler: aMarshaler headerMarshaler: headerBindings" Marshal Smalltalk object and header objects into XML Element"	| envelope manager envMarshaler  | 	envelope := self envelope new.	manager := self manager. 	envMarshaler := self soapEnvelopeMarshaler copy.  	headerBindings ifNotNil: [ self validateHeaders: header with: headerBindings ].	(header isNil or: [ header isEmpty])		ifTrue: [envelope header: nil] 		ifFalse: [envelope header: header.			header headerEntries do: [ :value |  binding findSoapEntryHeaderMarshalerFor: value version: self transport soapVersion ]].	aMarshaler 		prepareMarshal: envelope 		arguments: anArguments 		marshaler: manager.	^manager marshal: envelope with: envMarshaler.</body><body package="WSDLBinding">unmarshalBodyFromXML: anXMLElement 	|  envelope |	envelope := SoapEnvelope new.	envelope body: (self manager unmarshal: (anXMLElement elementsNamed: self bodyTag) first ).	^envelope</body><body package="WSDLBinding">unmarshalHeaderEntriesFromXML: anXMLElementCollection 	| manager  mc |	manager := self manager.	^(manager marshalerForTag: anXMLElementCollection first parent tag 	ifAbsent: [nil])		ifNotNil: [ :marshaler |			(mc := MarshalingContext marshaler: marshaler)				manager: manager;				value: SoapHeader new;				source: anXMLElementCollection first parent.			marshaler unmarshalElements: anXMLElementCollection from: mc.			mc value].</body><body package="WSDLBinding">unmarshalSoapEnvelope: anXMLElement " Unmarshal XML Element in to Smalltalk object "	^self manager unmarshal: anXMLElement with: self soapEnvelopeMarshaler.</body><body package="WSDLBinding">validateHeaders: headers with: headerMarshaler</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>creating script</category><body package="WSDLBinding">createScriptOn: aStream client: aClient	| assoc indentation exceptions  |	aStream cr; nextPutAll: ((#RunOperation &lt;&lt; #webservices &gt;&gt; '"Run operation #&lt;1s&gt;"' ) expandMacrosWith: self name).	indentation := 1.	assoc := self argumentsFor: aClient indentation: indentation.	"Print request headers"	self printRequestHeaderCommentOn: aStream client: aClient.	"Collect all exceptions. If there is more than two of them create an instance of ExceptionSet "	exceptions :=  self headerExceptions asSet.	exceptions addAll: self bodyExceptions.	"Print service arguments"	(assoc key notNil and: [assoc key notEmpty])  ifTrue: [ aStream crtab: indentation; nextPutAll: assoc key ].	"Start exception blocks"	exceptions notEmpty		ifTrue: [aStream cr; tab: indentation; nextPut: $[ . 				indentation := indentation + 1].	"Print service invocation"	aStream cr; tab: indentation; nextPutAll: assoc value.	"Print exception handling"	exceptions notEmpty		ifTrue: 			[indentation := indentation - 1.			aStream cr;tab: indentation; nextPut: $].			self printExceptions: exceptions on: aStream indentation: indentation ].</body></methods><methods><class-id>WebServices.SoapOperationBinding class</class-id> <category>default</category><body package="WSDLBinding">rpcResultAsStruct	rpcResultAsStruct ifNil: [ rpcResultAsStruct := false ].	^rpcResultAsStruct</body><body package="WSDLBinding">rpcResultAsStruct: aBoolean	rpcResultAsStruct := aBoolean</body><body package="WSDLBinding">wrapDocumentLiteralResult	^false</body></methods><methods><class-id>WebServices.UserHeaderError</class-id> <category>accessing</category><body package="SOAPBinding">faultCode	^self class faultTag</body><body package="SOAPBinding">faultTag	^SoapClientFault faultTag</body></methods><methods><class-id>WebServices.UserHeaderError</class-id> <category>testing</category><body package="SOAPBinding">isUserHeaderError	^true</body></methods><methods><class-id>WebServices.UserHeaderError</class-id> <category>converting</category><body package="SOAPBinding">asSoapFault	^SoapFault faultCode: SoapClientFault faultTag faultString: self faultString</body></methods><methods><class-id>WebServices.UserHeaderError</class-id> <category>visiting</category><body package="WSDLBinding">acceptVisit: aSoapTransportBinding with: aMarshalers	^aSoapTransportBinding marshalUserHeaderError: self with: aMarshalers</body></methods><methods><class-id>WebServices.UserHeaderError class</class-id> <category>deprecation</category><body package="SOAPBinding">headerName: aString exception: anException	^self new		parameter: aString; 		faultString: anException errorString;		detailContents: anException;		yourself</body></methods><methods><class-id>WebServices.MessageBinding</class-id> <category>accessing</category><body package="WSDLBinding">isWrapped	^isWrapped ifNil: [ false]</body><body package="WSDLBinding">isWrapped: aBoolean	isWrapped := aBoolean</body><body package="WSDLBinding">namespace	^namespace</body><body package="WSDLBinding">namespace: anObject	^namespace := anObject</body><body package="WSDLBinding">partMarshaler	^(partMarshalers notNil and: [ partMarshalers notEmpty ])		ifTrue: [partMarshalers first]		ifFalse: [nil]</body><body package="WSDLBinding">partMarshalers	^partMarshalers isNil 		ifTrue: [Array new]		ifFalse: [partMarshalers]</body><body package="WSDLBinding">partMarshalers: aValue	partMarshalers := aValue</body><body package="WSDLBinding">structMarshaler	^structMarshaler</body><body package="WSDLBinding">structMarshaler: aValue	structMarshaler := aValue</body><body package="WSDLBinding">structName	^structName</body><body package="WSDLBinding">structName: aValue	structName := aValue</body><body package="WSDLBinding">style	^style</body><body package="WSDLBinding">style: anObject	style := anObject asSymbol</body></methods><methods><class-id>WebServices.MessageBinding</class-id> <category>api -- marshal</category><body package="WSDLBinding">prepareMarshal: soapEnvelope arguments: arguments marshaler: anMarshalingManager</body></methods><methods><class-id>WebServices.SoapWsdl11PartBinding</class-id> <category>accessing</category><body package="WSDLBinding">bodyMarshaler	^self isDocument		ifTrue: [ partMarshalers ifNil: [structMarshaler] ifNotNil: [partMarshalers first ]]		ifFalse: 	[structMarshaler]</body><body package="WSDLBinding">encodingStyle	^encodingStyle</body><body package="WSDLBinding">encodingStyle: aString	encodingStyle := aString</body><body package="WSDLBinding">entryName	^self partMarshalers first xpath xpathExpression asSymbol</body><body package="WSDLBinding">marshalers	^self isDocument		ifTrue: [self partMarshalers ]		ifFalse: 	[Array with: structMarshaler]</body><body package="WSDLBinding">partNames	^partNames</body><body package="WSDLBinding">partNames: aValue	partNames := aValue</body><body package="WSDLBinding">use	^use</body><body package="WSDLBinding">use: aString	use := aString</body></methods><methods><class-id>WebServices.SoapWsdl11PartBinding</class-id> <category>initialization</category><body package="WSDLBinding">addPartMarshaler: anXMLTypeMarshaler	partMarshalers isNil ifTrue: [ partMarshalers := OrderedCollection new].	partMarshalers add: anXMLTypeMarshaler</body><body package="WSDLBinding">addPartName: aNodeTag	partNames isNil ifTrue: [ partNames := OrderedCollection new].	partNames add: aNodeTag</body></methods><methods><class-id>WebServices.SoapWsdl11PartBinding</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream nextPutAll: self class name.	namespace ifNotNil: [		aStream			nextPutAll: ' namespace=';			nextPutAll: namespace asString ].	structName ifNotNil: [		aStream 			nextPutAll: ' structName=';			nextPutAll: structName asString].	self partNames ifNotNil: [		aStream			nextPutAll: ' part names=';			nextPutAll: self partNames printString].</body></methods><methods><class-id>WebServices.SoapWsdl11PartBinding</class-id> <category>testing</category><body package="WSDLBinding">hasInputParameters	^partNames notEmpty</body><body package="WSDLBinding">includesPartName: aString	^self isDocument		ifTrue: [partNames includes: aString asSymbol]		ifFalse: [partMarshalers anySatisfy: [ :pm | pm tag type = aString ] ]</body><body package="WSDLBinding">isDocument	^style = #document</body><body package="WSDLBinding">isRpc	^style = #rpc</body><body package="WSDLBinding">isStructType	| bodyMarshaler |	bodyMarshaler :=  self bodyMarshaler typeMarshaler.	^bodyMarshaler isComplexTypeMarshaler and: [ bodyMarshaler isDictionaryType ]</body></methods><methods><class-id>WebServices.SoapWsdl11PartBinding</class-id> <category>private</category><body package="WSDLBinding">asDocumentFrom: sortedAssocList 	sortedAssocList isEmpty		ifTrue:			[structMarshaler := BindingBuilder newResolverAt: 'struct'.			structMarshaler qualified: true.			structMarshaler buildFromTag: structName copy smalltalkClass: SoapBodyStruct]		ifFalse:			[structName := structMarshaler := nil.			partMarshalers := sortedAssocList collect: 	[ :assoc | 				self use = 'encoded'					ifTrue: [self setDocPartMarshaler: (self docMarshalerForTag: assoc key marshaler: assoc value)]					ifFalse: [isWrapped := (assoc value typeMarshaler isStructMarshaler											and: [assoc value typeMarshaler elementMarshalers size = 1]).							 assoc value  ]]].</body><body package="WSDLBinding">asRpcFrom: sortedAssocList" Create pseudo-structure around body parts. Each element's tag is part's name; structure tag is that of the message itself "	| elementMarshaler ns tag paramName  |	structMarshaler := BindingBuilder newResolverAt: 'struct'.	structMarshaler		useUnorderedMarshaler;		buildFromTag: structName smalltalkClass: SoapBodyStruct.	partMarshalers := sortedAssocList collect: 						[ :assoc |						paramName := assoc key.						ns := namespace notNil 									ifTrue: [namespace asString]									ifFalse: [paramName namespace]."http://www.ws-i.org/Profiles/BasicProfile-1_2(WGAD).html#Part_Accessors4.7.20 Part AccessorsFor rpc-literal envelopes, WSDL 1.1 is not clear what namespace, if any, the accessor elements for parameters and return value are a part of. Different implementations make different choices, leading to interoperability problems. R2735 An ENVELOPE described with an rpc-literal binding MUST place the part accessor elements for parameters and return value in no namespace. R2755 The part accessor elements in a MESSAGE described with an rpc-literal binding MUST have a local name of the same value as the name attribute of the corresponding wsdl:part element. "						tag := NodeTag qualifier: '' ns: '' type: paramName type.						elementMarshaler := self rpcMarshalerForTag: tag marshaler: assoc value.						elementMarshaler aspect: tag asString.						structMarshaler addElementMarshaler: elementMarshaler.						elementMarshaler].</body><body package="WSDLBinding">docMarshalerForTag: tag marshaler: marshaler" Create marshaler that will recognize the tag and process contents according to marshaler "	| elementMarshaler |	elementMarshaler := BindingBuilder newResolverAt: 'element'.	elementMarshaler buildFromTag: tag marshaler: marshaler.	elementMarshaler qualified: true.	^elementMarshaler</body><body package="WSDLBinding">rpcMarshalerForTag: tag marshaler: marshaler" Create marshaler that will recognize the tag and process contents according to marshaler ""http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html#Namespaces_for_Children_of_Part_AccessorsHowever, it does not explicitly state that the element and attribute content of the abstract (complexType) types is namespace qualified to the targetNamespace in which those elements and attributes were defined. WSDL 1.1 was intended to function in much the same manner as XML Schema. Hence, implementations must follow the same rules as for XML Schema. If a complexType defined in targetNamespace A were imported and referenced in an element declaration in a schema with targetNamespace B, the element and attribute content of the child elements of that complexType would be qualified to namespace A and the element would be qualified to namespace B&lt;s:Body&gt;      &lt;m:BarOperation xmlns:m=http://example.org/bar/&gt;         &lt;BarAccessor&gt;            &lt;foo:bar&gt;String&lt;/foo:bar&gt;            &lt;foo:baf&gt;0&lt;/foo:baf&gt;         &lt;/BarAccessor&gt;      &lt;/m:BarOperation&gt;    &lt;/s:Body&gt;"	| elementMarshaler |	"Hack to skip namespaces for the rpc/encoded children"	 elementMarshaler := RPCEncRelationMarshaler newProxy xpathPrefix: 'child::';yourself.	elementMarshaler buildFromTag: tag marshaler: marshaler.	elementMarshaler qualified: true.	use = 'literal' ifTrue: [elementMarshaler useInlineType: false].	^elementMarshaler</body><body package="WSDLBinding">setDocPartMarshaler: partMarshaler	namespace ~~ nil 		ifTrue: 			[partMarshaler 				setNewNamespaceForTag: namespace asString 				qualifier: ''].	^partMarshaler</body><body package="WSDLBinding">sort: assocList inOrder: parameterOrderx" assocList is sequenceable collection of associations (part name tag-&gt;part marshaler). Apply parameterOrder sort if any and process it according to my style (document/rpc). For document marshalers are used to marshal elements directly into the soap body. For RPC a structure is created around parameters; each parameter becomes an accessor in this structure. Structure's tag is my structName  "	^(parameterOrderx isNil or: [parameterOrderx isEmpty])		ifTrue: [assocList]		ifFalse: [ | sorted |				sorted := OrderedCollection new.				parameterOrderx do: [ :paramName | 					(assocList detect: [ :assocx | assocx key type = paramName ] ifNone: [nil]) ifNotNil: [ :assocx | sorted add: assocx]].				"If we have parameters list size is not equal the sorted collection size, there is possible wrong value of parameterOrder attribute. Since parameterOrder is optional let's ignore it and return parameters  "				assocList size ~= sorted size 					ifTrue: [ assocList ]					ifFalse: [ sorted ]]</body></methods><methods><class-id>WebServices.SoapWsdl11PartBinding</class-id> <category>api -- marshal</category><body package="WSDLBinding">prepareDocument: soapEnvelope arguments: anArray marshaler: anMarshalingManager	| struct arguments parts |	partNames notEmpty		ifTrue: [ arguments := 				(anArray size ~= partMarshalers size 					and: [ partMarshalers first typeMarshaler isObjectTypeMarshaler						and: [anArray size = (parts := partMarshalers first typeMarshaler relations) size]])				ifTrue: [struct := Struct new.						1 to: parts size do: [ :ind | struct at: (parts at: ind) relation getSelector put: (anArray at: ind) ].						Array with: struct ]				ifFalse: [anArray].							arguments with: partMarshalers 				do: [ :argument :partMarshaler |					partMarshaler qualified:  true.					anMarshalingManager register: argument marshalWith: partMarshaler].			soapEnvelope 				partOrder: self partNames copy;				contents: arguments]		ifFalse: 			[struct := SoapBodyStruct name: structName type.			soapEnvelope 				partOrder: (OrderedCollection with: structName);				contents: (OrderedCollection with: struct).				structMarshaler qualified: true.				anMarshalingManager register: struct marshalWith: structMarshaler.]</body><body package="WSDLBinding">prepareHeaders: soapHeader	"Do nothing for 1.1"</body><body package="WSDLBinding">prepareMarshal: soapEnvelope arguments: arguments marshaler: anMarshalingManager 	self isDocument			ifTrue: [self prepareDocument: soapEnvelope arguments: arguments marshaler: anMarshalingManager ]			ifFalse: [self prepareRpc: soapEnvelope arguments:  arguments marshaler: anMarshalingManager ].</body><body package="WSDLBinding">prepareRpc: soapEnvelope arguments: arguments marshaler: anMarshalingManager	| dict |	dict := SoapBodyStruct new: arguments size.	dict		partOrder: self partNames copy;		contents: arguments.	soapEnvelope 		partOrder: (OrderedCollection with: structName);		contents: (OrderedCollection with: dict).	structMarshaler 	qualified: true.	self setEncodingStyleFor: structMarshaler.	anMarshalingManager register: dict marshalWith: structMarshaler.</body><body package="WSDLBinding">setEncodingStyleFor: aTypeMarshaler	(self encodingStyle notNil and: [self encodingStyle notEmpty])		ifTrue: 			[aTypeMarshaler 				setRequiredAttribute: ( NodeTag 										qualifier: 'SOAP-ENV'										ns: SoapBinding soap11_uri										type: 'encodingStyle')				value:  (NodeTag qualifier: '' ns: '' type: self encodingStyle asString )].</body></methods><methods><class-id>WebServices.SoapWsdl11PartBinding</class-id> <category>api -- builder</category><body package="WSDLBinding">buildFaultMarshalerFor: intOperationFault operation: operationBinding binding: binding" http://ws-i.org/profiles/BasicProfile-1.2-2010-11-09.html#Bindings_and_FaultsBecause faults and headers do not contain parameters, wsoap11:fault , wsoap11:header and wsoap11:headerfault assume, per WSDL 1.1, that the value of the style attribute is #document. R2204 requires that all wsdl:part elements with a style attribute whose value is #document that are bound to wsoap11:body be defined using the element attribute. This requirement does the same for wsoap11:fault , wsoap11:header and wsoap11:headerfault elements."	| assocList |	self		style: 'document';		use: 'literal';		structName: intOperationFault key.	assocList := self				collectPartMarshaler: intOperationFault value parts				operation: operationBinding				binding: binding.	partMarshalers := (assocList collect: [:assoc | assoc value]).</body><body package="WSDLBinding">buildMarshalerFor: message operation: operation from: bindingDescriptor binding: binding	" Build marshaler based on body marshaler inside specified operation and binding information. Answer proper marshaler after factors like parameter order, style (document/rpc) and potentially encoding specifics been taken into consideration. The main factor is document/rpc style. For document encoding style message parts are included directly in SOAP body. For rpc style an enclosing structure has to be created. "	| qname assocList parts |	bindingDescriptor		ifNotNil: 			[(bindingDescriptor namespace == nil or: [bindingDescriptor namespace = ''])				ifFalse: [self namespace: bindingDescriptor namespace].			self use: bindingDescriptor use.			self encodingStyle: bindingDescriptor encodingStyle]		ifNil: [use := 'literal'].	"Horrible hack to force inline type for rpc/encoded  "	( self isRpc and: [ self use = 'encoded' ])		ifTrue: [binding useInlineType: true.].	qname := message key.	self namespace ifNotNil: [qname resetNamespaceTo: self namespace].	self structName: qname.	"If the parts attribute is omitted in binding description, then define marshaler for all parts defined by the message"	parts := self collectPartsFrom: message bindingDescriptor: bindingDescriptor.	" collect marshalers for message parts as associations "	assocList := self				collectPartMarshaler: parts				operation: operation				binding: binding.					"Operation parameter order makes sense only for input bindings. Skip sorting parts for output bindings "	self 		buildPartMarshalersFrom: assocList 		order: (message == operation output ifTrue: [nil] ifFalse: [operation parameterOrder]) 		binding: binding.</body><body package="WSDLBinding">buildPartMarshalersFrom: assocList order: parameterOrderx binding: binding" Configure yourself based on part marshalers and binding information. assocList is the list of (part name tag-&gt;part descriptor). These have to be sorted in (optional) order imposed by parameterOrder.useType is either 'literal' or 'encoded'. If 'encoded', part refers to the abstract part and it has to be encoded according to uris that refer to existing encodings. For the time being we ignore encoding style and create an implicit binding for the part. That is, we construct a marshaler that will recognize part name tag and resolve it according to the type.The other major and orthogonal factor is document/rpc style. For document encoding style message parts are included directly in SOAP body. For rpc style an enclosing structure has to be created. "" collect marshalers for message parts as associations "" Pre-sort marshalers in parameterOrder sequence "	| sortedAssocList |	sortedAssocList := self sort: assocList inOrder: parameterOrderx.	partNames := sortedAssocList collect: [ :assoc | assoc key type asSymbol].	self isDocument		ifTrue: [self asDocumentFrom: sortedAssocList ]		ifFalse: [self asRpcFrom: sortedAssocList].	structMarshaler ifNotNil: [ binding addElementMarshaler: structMarshaler ].	partMarshalers ifNotNil: [ partMarshalers do: [ :each | binding addElementMarshaler: each ]]</body><body package="WSDLBinding">collectPartMarshaler: parts operation: operation binding: binding	| marshaler qname assocList  |	assocList := OrderedCollection new.	" collect marshalers for message parts as associations "	parts do: [ :partDescriptor |  | type |		qname := partDescriptor elementName notNil					ifTrue: [type := #element. partDescriptor elementName]					ifFalse: [ type := #type. partDescriptor typeName ].		qname 			ifNil: [ XMLObjectBindingSignal raiseRequestErrorString:  ((#PartHasNoTypeInfo &lt;&lt; #webservices &gt;&gt; 'Part &lt;1s&gt; of operation &lt;2s&gt; has no type information')							expandMacrosWith: partDescriptor name asString with: operation name asString).]			ifNotNil: [ | marshalers |					marshalers := binding findMarshalersLike: qname ifAbsent: [#() ].					marshalers isEmpty 						ifTrue: [ XMLObjectBindingSignal raiseRequestErrorString: ((#PartCantResolveRef &lt;&lt; #webservices &gt;&gt; 'Part %&lt;&lt;1s&gt;%&gt;  of operation %&lt;&lt;2s&gt;%&gt;  can not resolve reference:  &lt;3s&gt;')										expandMacrosWith: partDescriptor name asString with: operation name asString with: qname asString)].					marshaler := marshalers 						detect: [ :mx | mx symbolSpace = type ] 						ifNone: [ "If there is old mapping that doesn't a marshaler with correct type, let's check tags  "							marshaler := marshalers 									detect: [ :mx | mx tag = qname ] 									ifNone: [ | text |								 text :=  (#CannotResolvePartReference &lt;&lt; #webservices &gt;&gt; 'Can not find marshaler for &lt;1s&gt;. ' ) expandMacrosWith: qname printString.								text := text, (type = #type 											ifTrue: [#ExpectedTypeOfObjectMarshalerOrSimpleTypeMarshaler &lt;&lt; #webservices &gt;&gt; 'Expected type of ObjectMarshaler or SimpleTypeMarshaler'] 											ifFalse: [ #ExpectedTypeOfRelationMarshaler  &lt;&lt; #webservices &gt;&gt; 'Expected type of RelationMarshaler']) asString.								self error: text ]].					].  		marshaler ifNotNil: [	assocList add: (partDescriptor name)-&gt;marshaler]].	^assocList</body><body package="WSDLBinding">collectPartsFrom: message bindingDescriptor: aSoapBodyPartDescriptor	"If the parts attribute is omitted in binding description, then define marshaler for all parts defined by the message"	| parts |	(aSoapBodyPartDescriptor isNil		or: [aSoapBodyPartDescriptor parts isNil or: [ aSoapBodyPartDescriptor parts isEmpty]])			ifTrue: [parts := message value parts]			ifFalse: 				[parts := OrderedCollection new: aSoapBodyPartDescriptor parts size.				aSoapBodyPartDescriptor parts do: [:px |					(message value parts detect: [:mpx | mpx name type = px] ifNone: [nil])						ifNotNil: [:part | parts add: part]]].	"If the parts attribute is omitted in binding description, then define marshaler for all parts defined by the message"	^parts</body></methods><methods><class-id>WebServices.SoapMustUnderstandFault</class-id> <category>accessing</category><body package="SOAPBinding">code	^self faultTag</body></methods><methods><class-id>WebServices.SoapMustUnderstandFault</class-id> <category>visiting</category><body package="WSDLBinding">acceptVisit: aSoapTransportBinding with: aMarshalers		^aSoapTransportBinding marshalMustUnderstandFault: self with: aMarshalers</body></methods><methods><class-id>WebServices.SoapMustUnderstandFault class</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'MustUnderstand'</body></methods><methods><class-id>WebServices.TransportBinding</class-id> <category>accessing</category><body package="WSDLBinding">action	^action</body><body package="WSDLBinding">action: aValue	action := aValue</body><body package="WSDLBinding">binding	^binding</body><body package="WSDLBinding">binding: aWsdlBinding	binding := aWsdlBinding</body><body package="WSDLBinding">client	^client</body><body package="WSDLBinding">client: aHttpClient	client := aHttpClient</body><body package="WSDLBinding">headerEntryClass</body><body package="WSDLBinding">maxRetries	^maxRetries ifNil: [ maxRetries := self class maxRetries ]</body><body package="WSDLBinding">maxRetries: aNumber	maxRetries := aNumber</body><body package="WSDLBinding">method	^self verb</body><body package="WSDLBinding">method: aMethod	self verb: aMethod</body><body package="WSDLBinding">operationBindingClass	^self subclassResponsibility</body><body package="WSDLBinding">protocol	^protocol</body><body package="WSDLBinding">protocol: anObject	protocol := anObject</body><body package="WSDLBinding">retryExceptions	retryExceptions ifNil: [ ^self class retryExceptions].	^retryExceptions</body><body package="WSDLBinding">retryExceptions: anExceptionSet	retryExceptions := anExceptionSet</body><body package="WSDLBinding">verb	^verb</body><body package="WSDLBinding">verb: aValue	verb := aValue</body></methods><methods><class-id>WebServices.TransportBinding</class-id> <category>visiting</category><body package="WSDLBinding">buildOperationsFor: aBuilder from: descriptor</body></methods><methods><class-id>WebServices.TransportBinding</class-id> <category>initialize-release</category><body package="WSDLBinding">setSpecificOptionsFrom: aTransportBinding</body></methods><methods><class-id>WebServices.TransportBinding</class-id> <category>testing</category><body package="WSDLBinding">isHttpBinding	^false</body><body package="WSDLBinding">isSoapBinding	^false</body><body package="WSDLBinding">validate</body></methods><methods><class-id>WebServices.TransportBinding</class-id> <category>api -- new request</category><body package="WSDLBinding">execute: aSoapRequest	^self sendAndWaitForReply: aSoapRequest</body></methods><methods><class-id>WebServices.TransportBinding</class-id> <category>private</category><body package="WSDLBinding">sendAndWaitForReply: aSoapRequest</body></methods><methods><class-id>WebServices.TransportBinding class</class-id> <category>accessing</category><body package="WSDLBinding">maxRetries	^maxRetries ifNil: [maxRetries := self maxRetriesValue]</body><body package="WSDLBinding">maxRetries: aNumber	maxRetries := aNumber</body><body package="WSDLBinding">retryExceptions	^retryExceptions isNil		ifTrue: [ retryExceptions := self defaultRetryExceptionsValue]		ifFalse: [retryExceptions]</body><body package="WSDLBinding">retryExceptions: anExceptionSet	retryExceptions := anExceptionSet</body></methods><methods><class-id>WebServices.TransportBinding class</class-id> <category>defaults</category><body package="WSDLBinding">defaultCharset" utf-8 [RFC2279] is the recommended value, representing the UTF-8 charset.  UTF-8 is supported by all conforming processors of [XML]."	^'utf-8'</body><body package="WSDLBinding">defaultContentType	^'text/xml'</body><body package="WSDLBinding">defaultRetryExceptionsValue	^(ExceptionSet new: 4)		add: HttpTimeout;		add: OSErrorHolder unpreparedOperationSignal;		add: OSErrorHolder needRetrySignal;		add: HttpStatusLineError;		yourself</body><body package="WSDLBinding">maxRetriesValue	^0</body></methods><methods><class-id>WebServices.TransportBinding class</class-id> <category>api -- translation</category><body package="WSDLBinding">faultCodeForHttpResponse: response	| map |	map := #( 		#('3*' 'Server.Moved')		#('400' 'Client.BadRequest')		#('401' 'Client.Unauthorized')		#('402' 'Client.PaymentRequired')		#('403' 'Client.Forbidden')		#('404' 'Client.NotFound')		#('405' 'Client.MethodNotAllowed')		#('406' 'Client.NotAcceptable')		#('407' 'Client.ProxyAuthentcationRequired')		#('408' 'Client.RequestTimeout')		#('409' 'Client.Conflict')		#('410' 'Client.Gone')		#('411' 'Client.LengthRequired')		#('412' 'Client.PreconditionFailed')		#('413' 'Client.EntityTooLarge')		#('414' 'Client.URITooLarge')		#('415' 'Client.UnsupportedMediaType')		#('500' 'Server')		#('501' 'Server.NotImplemented')		#('502' 'Server.BadGateway')		#('503' 'Server.Unavailable')		#('504' 'GatewayTimeout')		#('505' 'Server.HttpVersionNotSupported')		#('*' 'Server.UnknownError')	).	^(map 		detect: [ :element | element first match: response code]		ifNone: [^'Server.UnknownError']) 		last</body></methods><methods><class-id>WebServices.HttpTransportBinding</class-id> <category>accessing</category><body package="WSDLBinding">contentEncoding	^contentEncoding</body><body package="WSDLBinding">contentEncoding: anObject	contentEncoding := anObject</body><body package="WSDLBinding">cookies	^cookies</body><body package="WSDLBinding">cookies: anObject	cookies := anObject</body><body package="WSDLBinding">faultSerialization	^faultSerialization</body><body package="WSDLBinding">faultSerialization: anObject	faultSerialization := anObject</body><body package="WSDLBinding">headerEntryClass	^self error: ( #ThereIsNoHeaderEntriesFotHttpBinding &lt;&lt; #webservices &gt;&gt; 'There is no header entries for Http binding' )</body><body package="WSDLBinding">ignoreUncited	^ignoreUncited ifNil: [false]</body><body package="WSDLBinding">ignoreUncited: anObject	ignoreUncited := anObject</body><body package="WSDLBinding">inputContentTypeFor: aMethod"6.4.4 Default input and output serialization format{http input serialization} 	{http output serialization}GET 	application/x-www-form-urlencoded 	application/xmlPOST 	application/xml 	application/xmlPUT 	application/xml 	application/xmlDELETE 	application/x-www-form-urlencoded 	application/xml "	self inputSerialization ifNotNil: [^self inputSerialization].	(('GET' match: aMethod) or: ['DELETE' match: aMethod] ) ifTrue: [^'application/x-www-form-urlencoded'].	^'application/xml'</body><body package="WSDLBinding">inputSerialization	^inputSerialization</body><body package="WSDLBinding">inputSerialization: anObject	inputSerialization := anObject</body><body package="WSDLBinding">location	^location</body><body package="WSDLBinding">location: anObject	location := anObject</body><body package="WSDLBinding">newRequest	^HttpRequest new</body><body package="WSDLBinding">outputContentTypeFor: aMethod"6.4.4 Default input and output serialization format{http input serialization} 	{http output serialization}GET 	application/x-www-form-urlencoded 	application/xmlPOST 	application/xml 	application/xmlPUT 	application/xml 	application/xmlDELETE 	application/x-www-form-urlencoded 	application/xml "	self outputSerialization ifNotNil: [^self outputSerialization].	^'application/xml'</body><body package="WSDLBinding">outputSerialization	^outputSerialization</body><body package="WSDLBinding">outputSerialization: anObject	outputSerialization := anObject</body><body package="WSDLBinding">queryParameterSeparator	^queryParameterSeparator ifNil: [ self class queryParameterSeparator ]</body><body package="WSDLBinding">queryParameterSeparator: anObject	queryParameterSeparator := anObject</body></methods><methods><class-id>WebServices.HttpTransportBinding</class-id> <category>visiting</category><body package="WSDLBinding">buildOperationsFor: aBuilder from: descriptor	aBuilder buildHttpBindingOperationsFrom: descriptor binding: binding</body></methods><methods><class-id>WebServices.HttpTransportBinding</class-id> <category>initialize-release</category><body package="WSDLBinding">parseLocation: aString"The {http location} property MAY cite local names of elements from the instance data  of the message to be serialized in request IRI.The {http location} property MUST conform to the following EBNF [ISO/IEC 14977:1996] grammar, which represents the patterns for constructing the request IRI:â httpLocation ::= charData? (( openBrace | closeBrace | template ) charData?)*charData ::= [^{}]*openBrace ::= '{{'closeBrace ::= '}}'template ::= rawTemplate | encodedTemplaterawTemplate ::= '{!' NCName '}'encodedTemplate ::= '{' NCName '}' "		location := aString</body><body package="WSDLBinding">setSpecificOptionsFrom: anHttpTransportBinding	anHttpTransportBinding queryParameterSeparator ifNotNil: [ :option | queryParameterSeparator := option ].	contentEncoding := (anHttpTransportBinding contentEncoding 						ifNil: [self class defaultCharset]						ifNotNil: [ :option | option ]).	anHttpTransportBinding action ifNotNil: [ :option | action := option ].	anHttpTransportBinding ignoreUncited ifNotNil: [ :option | ignoreUncited := option ].	anHttpTransportBinding location ifNotNil: [ self parseLocation: anHttpTransportBinding location	]</body></methods><methods><class-id>WebServices.HttpTransportBinding</class-id> <category>marshaling</category><body package="WSDLBinding">applyPairs: pairs toTemplate: template preserve: charsToPreserve	| input output |	input := template readStream.	output := String new writeStream.	[	output nextPutAll: (input upTo: ${).		input atEnd	] whileFalse: [				input peek = ${			ifTrue: [ output put: ${ ]			ifFalse: [ | tag dontEncode |				(dontEncode := input peek = $!) ifTrue: [ input next ].				tag := input upTo: $}.				(pairs detect: [ :pair | pair key = tag ] ifNone: [ nil ]) ifNotNil: [ :pair |					output nextPutAll: (						dontEncode							ifTrue: [ pair value ]							ifFalse: [ URLEncoder new urlSpecials: charsToPreserve; encode: pair value ]).					pairs remove: pair ] ] ].	^output contents</body><body package="WSDLBinding">deserialize: url marshalers: partMarshaler endpoint: serviceUrl	| pairs arguments marshalers |	pairs := self deserializePairsFrom: url endpoint: serviceUrl.	partMarshaler ifNil: [ ^#() ].	marshalers := partMarshaler typeMarshaler isComplexTypeMarshaler		ifTrue: [ partMarshaler typeMarshaler relations]		ifFalse: [OrderedCollection with: partMarshaler typeMarshaler].	arguments := marshalers collect: [ :marshaler |		(pairs detect: [ :asc | asc key = marshaler tag type ] ifNone: [ nil ])			ifNil: [ ignoreUncited ifFalse: [ self error: 'Missing argument!' ]. nil ]			ifNotNil: [ :pair |				pairs remove: pair.				marshaler typeMarshaler deserializationBlock					value: (MarshalingContext new value: pair value)					value: pair value					value: marshaler typeMarshaler smalltalkClass ] ].	^arguments</body><body package="WSDLBinding">deserializePairsFrom: fullUrl endpoint: serviceUrl	| query separator toPreserve pairs url queryData |	pairs := OrderedCollection new.	url := fullUrl asPartial.	url path: (fullUrl path allButFirst: serviceUrl path size).	separator := self queryParameterSeparator first.	toPreserve := '-._~'.	location ifNotNil: [ | mark path |		(mark := location indexOf: $?) isZero			ifTrue: [ path := location. query := nil ]			ifFalse: [ path := location copyFrom: 1 to: mark - 1.				query := location copyFrom: mark + 1 to: location size ].		(path tokensBasedOn: $/) with: url path do: [ :pathComponent :urlComponent |			self readPairsInto: pairs from: urlComponent usingTemplate: pathComponent preserve: toPreserve ].		query ifNotNil: [			queryData := url query readStream.			(query tokensBasedOn: separator) do: [ :parameter |				self readPairsInto: pairs					from: (queryData upTo: separator)					usingTemplate: parameter					preserve: (toPreserve copyWithout: separator) ] ] ].	(self ignoreUncited or: [ url query isNil ]) ifFalse: [		queryData ifNil: [ queryData := url query readStream ].		[ queryData atEnd ] whileFalse: [			pairs add: ((queryData upTo: $=) -&gt; (queryData upTo: separator)) ] ].	^pairs</body><body package="WSDLBinding">readPairsInto: pairs from: inputString usingTemplate: templateString preserve: charsToPreserve	| input template gap readGap |	input := inputString readStream.	template := templateString readStream.	"gap is the content between tags, it can include literal ${ expressed as {{"	readGap := [ gap := ''. [ gap := gap, (template upTo: ${). template peek = ${ ] whileTrue: [ gap := gap, '{'. template next ] ].	"skip the initial gap"	readGap value.	input next: gap size.	[ template atEnd ] whileFalse: [ | tag dontEncode value |		(dontEncode := template peek = $!) ifTrue: [ template next ].		tag := template upTo: $}.		readGap value.		"This assumes that 'gap' can't be present in the value. It is potentially ambiguous but best I can figure out at this point."		gap isEmpty ifTrue: [ value := input upToEnd ] ifFalse: [ value := input upToAll: gap. input next: gap size ].		dontEncode ifFalse: [ value := URLEncoder new urlSpecials: charsToPreserve; decode: value ].		pairs add: tag -&gt; value ].	^pairs</body><body package="WSDLBinding">serialize: arguments marshalers: partMarshaler into: url	| pairs marshalers  |	pairs := OrderedCollection new.	partMarshaler ifNotNil: [		marshalers := partMarshaler typeMarshaler isComplexTypeMarshaler			ifTrue: [ partMarshaler typeMarshaler relations]			ifFalse: [OrderedCollection with: partMarshaler typeMarshaler].		marshalers with: arguments do: [ :marshaler :argument || serializedArgument |			serializedArgument :=					marshaler typeMarshaler serializationBlock					value: (MarshalingContext new value: argument)					value: marshaler typeMarshaler smalltalkClass.			pairs add: marshaler tag type -&gt; serializedArgument ]].	^self serializePairs: pairs into: url</body><body package="WSDLBinding">serializePairs: pairs into: url	| query separator toPreserve |	separator := self queryParameterSeparator first.	toPreserve := '-._~'.	location ifNotNil: [ | mark path |		(mark := location indexOf: $?) isZero			ifTrue: [ path := location. query := nil ]			ifFalse: [ path := location copyFrom: 1 to: mark - 1.				query := location copyFrom: mark + 1 to: location size ].		(path tokensBasedOn: $/) do: [ :pathComponent |			url addEncodedComponent: (self applyPairs: pairs toTemplate: pathComponent preserve: toPreserve) ].		query ifNotNil: [			query := self applyPairs: pairs toTemplate: query preserve: (toPreserve copyWithout: separator).			query := WriteStream with: query  ] ].	(self ignoreUncited or: [ pairs isEmpty ]) ifFalse: [		query			ifNil: [ query := String new writeStream ]			ifNotNil: [ query nextPut: separator ].		pairs do: [ :pair |				query nextPutAll: pair key; nextPut: $=; nextPutAll: pair value ]			separatedBy: [ query nextPut: separator  ] ].	query ifNotNil: [ url query: query contents ].	^url</body></methods><methods><class-id>WebServices.HttpTransportBinding class</class-id> <category>defaults</category><body package="WSDLBinding">queryParameterSeparator	^queryParameterSeparator ifNil: [ queryParameterSeparator := self queryParameterSeparatorValue ]</body><body package="WSDLBinding">queryParameterSeparator: aString	queryParameterSeparator := aString</body><body package="WSDLBinding">queryParameterSeparatorValue	^'&amp;'</body></methods><methods><class-id>WebServices.SenderFault</class-id> <category>accessing</category><body package="SOAPBinding">httpCode"the code is used to set httpResponse code"	^'400'</body></methods><methods><class-id>WebServices.SenderFault class</class-id> <category>testing</category><body package="SOAPBinding">isSenderFault	^true</body></methods><methods><class-id>WebServices.SenderFault class</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'Sender'</body></methods><methods><class-id>WebServices.SenderFault class</class-id> <category>instance creation</category><body package="SOAPBinding">timeout	^self new reasonText: (#RequestTimeout &lt;&lt; #webservices &gt;&gt; 'Request Timeout') asString lang: self language</body></methods><methods><class-id>WebServices.WsdlPort</class-id> <category>accessing</category><body package="WSDLBinding">= anObject	^self name = anObject name</body><body package="WSDLBinding">accessPoint	^self address</body><body package="WSDLBinding">address	^address</body><body package="WSDLBinding">binding	^binding</body><body package="WSDLBinding">documentation	^self portDescriptor documentation</body><body package="WSDLBinding">documentation: aString	self portDescriptor documentation: aString</body><body package="WSDLBinding">hostName	^self address host</body><body package="WSDLBinding">name	^self portDescriptor name</body><body package="WSDLBinding">portDescriptor	^portDescriptor</body><body package="WSDLBinding">portDescriptor: aWsdlPortDescriptor	portDescriptor := aWsdlPortDescriptor</body></methods><methods><class-id>WebServices.WsdlPort</class-id> <category>initialization</category><body package="WSDLBinding">address: aValue	address := aValue asURI</body><body package="WSDLBinding">binding: aWsdlBinding	binding := aWsdlBinding</body><body package="WSDLBinding">name: aValue	self portDescriptor name: aValue</body></methods><methods><class-id>WebServices.WsdlPort</class-id> <category>api -- new request</category><body package="WSDLBinding">findOperationFor: aSoapRequest	^binding findOperationFor: aSoapRequest</body></methods><methods><class-id>WebServices.WsdlPort</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream 		nextPutAll: self class name;		nextPutAll: ' name=', self name asString;		nextPutAll: ', location='.	self address printOn: aStream.	aStream nextPutAll: ', '.	self binding printOn: aStream</body></methods><methods><class-id>WebServices.WsdlPort class</class-id> <category>instance creation</category><body package="WSDLBinding">name: aString address: aStringAddress	^self new		name: aString;		address: aStringAddress;		yourself</body></methods><methods><class-id>WebServices.WsdlPort class</class-id> <category>accessing</category><body package="WSDLBinding">portAt: aStringOrNodeTag ifAbsent: aBlock	^aStringOrNodeTag isString	 	ifTrue: [self portRegistry values detect: [ :port | port name type = aStringOrNodeTag ] ifNone: aBlock ]		ifFalse: [self portRegistry at: aStringOrNodeTag ifAbsent: aBlock ]</body><body package="WSDLBinding">portForBinding: aWsdlBinding ifAbsent: aBlock	^self portRegistry values detect: [ :px  | px binding = aWsdlBinding ] ifNone: aBlock</body><body package="WSDLBinding">portRegistry	^PortRegistry</body><body package="WSDLBinding">register: port	self portRegistry at: port name put: port</body></methods><methods><class-id>WebServices.WsdlPort class</class-id> <category>class initialization</category><body package="WSDLBinding">initialize	self reset</body><body package="WSDLBinding">reset	PortRegistry := Dictionary new: 10</body></methods><methods><class-id>WebServices.WsdlInterface</class-id> <category>accessing</category><body package="WSDLBinding">faults	^faults</body><body package="WSDLBinding">faults: aCollection	faults := aCollection</body></methods><methods><class-id>WebServices.ReceiverFault class</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'Receiver'</body></methods><methods><class-id>WebServices.ReceiverFault class</class-id> <category>testing</category><body package="SOAPBinding">isReceiverFault	^true</body></methods><methods><class-id>WebServices.SoapWsdl20MessageBinding</class-id> <category>accessing</category><body package="WSDLBinding">bodyMarshaler		^self elementType = '#none'		ifTrue: [ nil ]		ifFalse: [ self partMarshaler ]</body><body package="WSDLBinding">elementType	^elementType</body><body package="WSDLBinding">elementType: anObject	elementType := anObject</body><body package="WSDLBinding">headers	^headers</body><body package="WSDLBinding">headers: anObject	headers := anObject</body><body package="WSDLBinding">marshalers	^self partMarshalers</body><body package="WSDLBinding">operationBinding	^operationBinding</body><body package="WSDLBinding">operationBinding: anObject	operationBinding := anObject</body><body package="WSDLBinding">partMarshalers	^partMarshalers</body><body package="WSDLBinding">typeMarshaler 		partMarshalers isEmpty ifTrue: [^nil].	^self partMarshaler typeMarshaler</body></methods><methods><class-id>WebServices.SoapWsdl20MessageBinding</class-id> <category>api -- builder</category><body package="WSDLBinding">buildHeaderMarshalersFrom: headerDescriptors binding: binding	headers := OrderedCollection new.	headerDescriptors do: [ :headerDescriptor | 		self headers add: ( SoapWsdl20HeaderBinding buildMarshalersFrom: headerDescriptor binding: binding)	 ]</body><body package="WSDLBinding">buildMarshalerFor: anOperationBinding direction: aString "http://www.w3.org/TR/wsdl20/#component-InterfaceMessageReference "	| direction interfaceMessages bindingDescriptors |	operationBinding := anOperationBinding.	aString =  'in' 		ifTrue: [interfaceMessages := operationBinding interfaceDescriptor input.				operationBinding descriptor  ifNotNil: [ bindingDescriptors := operationBinding descriptor  input ]] 		ifFalse: [interfaceMessages := operationBinding interfaceDescriptor output.				operationBinding descriptor  ifNotNil: [ bindingDescriptors := operationBinding descriptor  output ]].	partMarshalers := OrderedCollection new.	interfaceMessages do: [ :message | 		direction := message at: #messageLabel ifAbsent: [nil].		(direction isNil and: [interfaceMessages size &gt; 1]) ifTrue: [ WsdlParsingErrors raiseRequestErrorString: ((#MessageLabelAttributeMustBePresent1s &lt;&lt; #webservices &gt;&gt;  'Operation: &lt;1s&gt;. #messageLabel attribute must be present if the message exchange pattern has more than one placeholder message with {direction} equal to the message direction ') expandMacrosWith:  operationBinding name printString  )].		(direction notNil and: [(direction match: aString) not ]) ifTrue: [ WsdlParsingErrors raiseRequestErrorString: ((#MessageLabelMustMatchMessageDirection1s &lt;&lt; #webservices &gt;&gt; 'Operation: &lt;1s&gt;. #messageLabel attribute value MUST match message direction') expandMacrosWith:  operationBinding name printString  )].	self resolveElementNodeFrom: message  binding: operationBinding binding.	(anOperationBinding isRpc and: [partMarshalers notEmpty and: [partMarshalers first isRelationMarshaler not]])		ifTrue: [ WsdlParsingErrors raiseRequestErrorString: ((#WrongXMLToObjectBindingFor1s2s &lt;&lt; #webservices &gt;&gt; 'Wrong XML to object binding for &lt;1s&gt; in operation &lt;2s&gt;. RelationMarshaler is required to resolve the reference')  expandMacrosWith: elementType printString with: operationBinding name printString) ].	isWrapped := (anOperationBinding isRpc not 		and: [partMarshalers notEmpty 			and: [partMarshalers first typeMarshaler isStructMarshaler]]).			bindingDescriptors ifNotNil: [		bindingDescriptors do: [ :messageBindingDescriptor |			messageBindingDescriptor soapHeaders ifNotNil: [ :headerDescriptors |				self buildHeaderMarshalersFrom: headerDescriptors binding: operationBinding binding ]]]].</body><body package="WSDLBinding">resolveElementNodeFrom: message  binding: binding	"The type of the element attribute information item is a union of xs:QName and xs:token where the allowed token values are #any, #none, or #other."	(elementType := message element) isString ifTrue: [^self setTokenType].		"xs:QName "	partMarshalers add: (binding 				elementMarshalerForTag: elementType 				ifAbsent: [ WsdlParsingErrors raiseRequestErrorString: ((#CanNotResolveInterfaceMessageElement &lt;&lt; #webservices &gt;&gt;'Can not resolve interface message element: &lt;1s&gt;') expandMacrosWith: elementType printString )]).	partMarshalers first qualified: true.</body><body package="WSDLBinding">setTokenType"The type of the element attribute information item is a union of xs:QName and xs:token where the allowed token values are #any, #none, or #other.""A value of #any indicates that the message content is any single element. Assume any element from the schema types definition""A value of #other indicates that the message content is described by some other extension property that references a declaration in a non-XML extension type system.""#none indicates there is no message content"	elementType = '#any' ifTrue: 	[ partMarshalers add:  AnyRelationMarshaler newProxy ].	elementType = '#others' ifTrue: 		[WsdlParsingErrors raiseRequestErrorString: ((#OthersNotSupported &lt;&lt; #webservices &gt;&gt;'#others is not supported element value ') expandMacrosWith: elementType printString )].	elementType = '#none' ifTrue: 		[structMarshaler := BindingBuilder newResolverAt: 'struct'.		structMarshaler qualified: true.		structMarshaler buildFromTag: self operationBinding name smalltalkClass: SoapBodyStruct].</body></methods><methods><class-id>WebServices.SoapWsdl20MessageBinding</class-id> <category>testing</category><body package="WSDLBinding">hasInputParameters	^partMarshalers notEmpty</body></methods><methods><class-id>WebServices.SoapWsdl20MessageBinding</class-id> <category>api -- marshal</category><body package="WSDLBinding">prepareHeaders: soapHeader	self headers ifNil: [^nil].	self headers do: [ :headerBinding | 		headerBinding partMarshaler isMandatory ifTrue: [			soapHeader ifNil: [ MissingRequiredHeader raiseRequestErrorString: (#ThereisNoRequiredSoapHeaderForMessage &lt;&lt; #webservices &gt;&gt;'There is no required SoapHeader for the message' )].			soapHeader headerAt: headerBinding headerTag type ifAbsent: [ MissingRequiredHeader raiseRequestErrorString: (#MissingRequiredHeaderEntry &lt;&lt; #webservices &gt;&gt;'The SoapHeader is missing required header entry: &lt;1s&gt; ' expandMacrosWith: headerBinding headerTag type )]].			(soapHeader headerAt: headerBinding headerTag type ifAbsent: [nil]) 				ifNotNil: [ :headerValue | headerValue mu: headerBinding  mustUnderstand]].</body><body package="WSDLBinding">prepareMarshal: envelope arguments: anArguments marshaler: aManager	| object |	self elementType = '#none'		ifTrue: [^self prepareNoneElementType: envelope arguments: anArguments marshaler: aManager ].	anArguments isEmpty ifTrue: [self error: (#ThereisNoRequiredParametrForMessage &lt;&lt; #webservices &gt;&gt;'There is no required parameter for the message' )].	(self partMarshaler typeMarshaler isSimpleType		or: [	anArguments size = 1 and: [anArguments first class includesBehavior: self partMarshaler typeMarshaler smalltalkClass ]])		ifTrue: [	aManager register: anArguments first marshalWith: self partMarshaler.				^envelope contents: anArguments first].	object := [self partMarshaler typeMarshaler smalltalkClass new] 		on: Error do: [ :ex | self partMarshaler typeMarshaler smalltalkClass basicNew].	self partMarshaler typeMarshaler isComplexTypeMarshaler ifTrue: [		1 to:anArguments size do: [ :ind |			self partMarshaler typeMarshaler 				setRelation: (self partMarshaler typeMarshaler  relations at: ind)  relation				for: object				to: (anArguments at: ind) evaluate 				context: MarshalingContext new ]].	aManager register: object marshalWith: self partMarshaler.	envelope contents: object</body><body package="WSDLBinding">prepareNoneElementType: envelope arguments: anArguments marshaler: aManager	| struct |	anArguments isNotEmpty ifTrue: [^self error: (#TheMessageDoesNotExpectParameters &lt;&lt; #webservices &gt;&gt;'The message does not expect any parameters' )].	aManager register: ( struct := SoapBodyStruct new) marshalWith: structMarshaler.	envelope contents: struct</body></methods><methods><class-id>WebServices.SoapWsdl20MessageBinding</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream nextPutAll: self class name.	elementType ifNotNil: [		aStream 			nextPutAll: ' element type: ';			nextPutAll: elementType printString ].</body></methods><methods><class-id>WebServices.SoapClientFault</class-id> <category>accessing</category><body package="SOAPBinding">faultCode	^self  class faultTag</body></methods><methods><class-id>WebServices.SoapClientFault class</class-id> <category>instance creation</category><body package="SOAPBinding">badRequest	^self faultString: (#BadRequest &lt;&lt; #webservices &gt;&gt; 'Bad Request') asString</body><body package="SOAPBinding">timeout	^self faultString: (#RequestTimeout &lt;&lt; #webservices &gt;&gt; 'Request Timeout') asString</body></methods><methods><class-id>WebServices.SoapClientFault class</class-id> <category>testing</category><body package="SOAPBinding">isSenderFault	^true</body></methods><methods><class-id>WebServices.SoapClientFault class</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'Client'</body></methods><methods><class-id>WebServices.SoapServerFault</class-id> <category>accessing</category><body package="SOAPBinding">faultCode	^self  class faultTag</body><body package="SOAPBinding">headerName	^parameter</body></methods><methods><class-id>WebServices.SoapServerFault class</class-id> <category>constants</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'Server'</body></methods><methods><class-id>WebServices.SoapServerFault class</class-id> <category>testing</category><body package="SOAPBinding">isReceiverFault	^true</body></methods><methods><class-id>WebServices.UserHeader12Error</class-id> <category>testing</category><body package="SOAPBinding">isUserHeaderError	^true</body></methods><methods><class-id>WebServices.UserHeader12Error</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^SenderFault faultTag</body></methods><methods><class-id>WebServices.UserHeader12Error</class-id> <category>converting</category><body package="SOAPBinding">asSoapFault	^Soap12Fault new		code: self code;		reason: self reason;		yourself</body></methods><methods><class-id>WebServices.UserHeader12Error</class-id> <category>visiting</category><body package="WSDLBinding">acceptVisit: aSoapTransportBinding with: aMarshalers	^aSoapTransportBinding marshalUserHeaderError: self with: aMarshalers</body></methods><methods><class-id>WebServices.SoapException</class-id> <category>printing</category><body package="SOAPBinding">defaultMessageText	^super defaultMessageText, '\(' withCRs, parameter printString, ')'</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">bindingUrl	^self class bindingUrl</body><body package="WSDLDescriptors">bindings	^bindings</body><body package="WSDLDescriptors">bindings: aValue	bindings := aValue</body><body package="WSDLDescriptors">configurationBuilder	^self configurationBuilderClass new		descriptor: self;		yourself</body><body package="WSDLDescriptors">configurationBuilderClass	^self subclassResponsibility</body><body package="WSDLDescriptors">imports	^imports</body><body package="WSDLDescriptors">imports: aValue	imports := aValue</body><body package="WSDLDescriptors">interfaces	^interfaces</body><body package="WSDLDescriptors">interfaces: aValue	interfaces := aValue</body><body package="WSDLDescriptors">schemaBindings	^schemaBindings</body><body package="WSDLDescriptors">schemaBindings: aValue	schemaBindings :=  aValue</body><body package="WSDLDescriptors">services	^services</body><body package="WSDLDescriptors">services: aValue	services := aValue</body><body package="WSDLDescriptors">targetNamespace	^targetNamespace</body><body package="WSDLDescriptors">targetNamespace: aValue	targetNamespace := aValue</body><body package="WSDLDescriptors">types	^types</body><body package="WSDLDescriptors">types: aCollection	types := aCollection</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>adding</category><body package="WSDLDescriptors">add: aWsdlConfigurationDescriptorOrXMLObjectBinding	( aWsdlConfigurationDescriptorOrXMLObjectBinding isKindOf: XMLObjectBinding )		ifTrue: [	^self schemaBindings add: aWsdlConfigurationDescriptorOrXMLObjectBinding ].	"Patching the invalid case when &lt;schema&gt; is defined by &lt;import&gt; directly under &lt;description&gt; element but not in &lt;types&gt; section "	((aWsdlConfigurationDescriptorOrXMLObjectBinding isKindOf: Association ) 		and: [ (aWsdlConfigurationDescriptorOrXMLObjectBinding key isKindOf: Element )			and: [aWsdlConfigurationDescriptorOrXMLObjectBinding key tag type = 'schema' ]])		ifTrue: [^self types add: aWsdlConfigurationDescriptorOrXMLObjectBinding key ].	self targetNamespace: aWsdlConfigurationDescriptorOrXMLObjectBinding targetNamespace.	 self types  addAll: aWsdlConfigurationDescriptorOrXMLObjectBinding types.	self interfaces addAll:  aWsdlConfigurationDescriptorOrXMLObjectBinding interfaces.	self bindings addAll:  aWsdlConfigurationDescriptorOrXMLObjectBinding bindings.	self services addAll: aWsdlConfigurationDescriptorOrXMLObjectBinding services.	self schemaBindings addAll: aWsdlConfigurationDescriptorOrXMLObjectBinding schemaBindings.	self imports addAll: aWsdlConfigurationDescriptorOrXMLObjectBinding imports</body><body package="WSDLDescriptors">addAll: aWsdlConfigurationDescriptor	((aWsdlConfigurationDescriptor isKindOf: Collection )		ifTrue: [aWsdlConfigurationDescriptor]		ifFalse: [OrderedCollection with: aWsdlConfigurationDescriptor]) do: [ :each | self add: each]</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>wsdl schema</category><body package="WSDLDescriptors">addType: anElement	anElement realElements size &gt; 0 ifTrue: [ types add: anElement ].</body><body package="WSDLDescriptors">asWsdl	| manager |	manager := self manager.	manager qualifierMap at: self targetNamespace  put: 'tns'.	manager significantNamespaces at: '' put: self wsdlTargetNamespace.	^manager marshal: self</body><body package="WSDLDescriptors">bindingNodes	^self asWsdl realElements collect: [ :each | each tag type = 'binding' ]</body><body package="WSDLDescriptors">getImports	^self imports</body><body package="WSDLDescriptors">getXMLSchemaBindings	"We are not creating X2O elements for WSDL schema "	^OrderedCollection new</body><body package="WSDLDescriptors">getXMLTypes	"Create &lt;types&gt; elements for WSDL schema. The type elements are generated from XML schema bindings "	| x2oBindings |	x2oBindings := Set new.	"Collect all registered X2O bindings for this target namespace "	(self schemaBindings notEmpty and: [self schemaBindings first isKindOf: XMLObjectBinding])		ifTrue: [x2oBindings := self schemaBindings]		ifFalse: [ self bindings do: [ :binding | (WsdlBinding bindingAt: binding name ifAbsent: [nil]) ifNotNil: [ :registeredBinding | x2oBindings addAll: registeredBinding importedBindings ]]].	x2oBindings notEmpty 		ifTrue: [^OrderedCollection with: (XML.Element											tag: (NodeTag new qualifier: '' ns: '' type: 'types' )											elements:  (x2oBindings collect: [ :x2o | x2o asXMLSchemaSpecification ]))].	"If there is no registered x2o bindings it can be: 1. there is no types 2. x2o binding was not created yet.	Let''s use types as they were in the original schema "	^self types</body><body package="WSDLDescriptors">manager	^self class manager</body><body package="WSDLDescriptors">messageNodes	^OrderedCollection new</body><body package="WSDLDescriptors">portNodes	^OrderedCollection new</body><body package="WSDLDescriptors">serviceInterfaceNodes	^OrderedCollection new</body><body package="WSDLDescriptors">serviceNodes	^self asWsdl realElements collect: [ :each | each tag type = 'service' ]</body><body package="WSDLDescriptors">wsdlTargetNamespace	^''</body><body package="WSDLDescriptors">x2oDocuments	| schemaBindingsElement |	self schemaBindings isEmpty ifTrue: [ ^#() ].	 ^(self schemaBindings first isKindOf: XMLObjectBinding)		ifTrue: [schemaBindingsElement := Element tag: (NodeTag qualifier: '' ns: '' type: 'schemaBindings').				self schemaBindings do: [ :anXMLObjectBinding | schemaBindingsElement addNode: anXMLObjectBinding asX2OSpecification].				OrderedCollection with: schemaBindingsElement]		ifFalse: [self schemaBindings ].</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">initialize	imports := OrderedCollection new.	types := OrderedCollection new: 20.	interfaces := OrderedCollection new: 5.	bindings := OrderedCollection new: 5.	services := OrderedCollection new: 5.	schemaBindings := OrderedCollection new: 5.</body><body package="WSDLDescriptors">initializeFrom: targetNamespaceString	self initializeFrom: targetNamespaceString bindingNamed: nil</body><body package="WSDLDescriptors">initializeFrom: targetNamespaceString bindingNamed: aString	| interfaceDescriptors bindingDescriptors |	self targetNamespace: targetNamespaceString.	interfaceDescriptors := Set new.	bindingDescriptors :=Set new.	(WsdlService registry values select: [ :serv | serv name namespace = self targetNamespace ])		do: [ :wsdlService | 			self services add: wsdlService serviceDescriptor.			wsdlService ports do: [ :wsdlPort | 				wsdlPort binding ifNotNil: [ :binding |					(aString isNil or: [ aString = binding name type])						ifTrue: [ 	interfaceDescriptors add:  binding bindingDescriptor  interfaceDescriptor.								bindingDescriptors add:  binding  bindingDescriptor ]]]].	self interfaces: interfaceDescriptors asOrderedCollection.	self bindings: bindingDescriptors asOrderedCollection.</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>parsing</category><body package="WSDLDescriptors">createDefaultBinding	self createDefaultBindingBaseURI: nil</body><body package="WSDLDescriptors">createDefaultBindingBaseURI: anURI	self 		createX2OBindingUsing: XMLTypesParser defaultBinding 		baseURI: anURI</body><body package="WSDLDescriptors">createObjectBindingInNamespace: aString	self 		createX2OBindingUsing: (XMLTypesParser objectBindingInNamespace: aString) 		baseURI: nil</body><body package="WSDLDescriptors">createObjectBindingInNamespace: aString baseURI: anURI	self 		createX2OBindingUsing: (XMLTypesParser objectBindingInNamespace: aString) 		baseURI: anURI</body><body package="WSDLDescriptors">createX2OBindingUsing: xmlTypesParser baseURI: aDataSourceOrURI	self schemaBindings add: 			(xmlTypesParser				baseURI: ([aDataSourceOrURI asURI] on: Error do: [ :ex | ex return: nil] ) ;				readSchemas:  self xmlSchemas)</body><body package="WSDLDescriptors">parse: xmlDocuments"xmlDocuments is collection of valid XML.Document or XML.Element "	| descriptors binding |	binding := WsdlBinding  bindingAtNamespace: self bindingUrl.	descriptors := OrderedCollection new: 10.	xmlDocuments do: [ :dom |		[descriptors add: ( binding unmarshal: dom root) ] on: MissingValueSignal  do: [ :ex | ex proceed]].	descriptors do: [ :each | self addAll: each ].	self setBindingInterfaceDescriptor.</body><body package="WSDLDescriptors">setBindingInterfaceDescriptor	self  bindings do: [ :binding | binding operations do: [ :operation | operation parent: binding]]</body><body package="WSDLDescriptors">xmlSchemas	| schemas |	schemas := OrderedCollection new.	self types do: [ :typeElement | 		typeElement tag type = 'types' 			ifTrue: [ schemas addAll: typeElement realElements] 			ifFalse:[ schemas add: typeElement] ].	^schemas</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLDescriptors">buildComponents	^self configurationBuilder buildComponentsFrom: self</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printSpecOn: aStream	aStream nextPutAll: XMLObjectBinding prolog; cr.	self asWsdl wsPrintOn: aStream depth: 0</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor class</class-id> <category>instance creation</category><body package="WSDLDescriptors">defaultReadFrom:  dataSource"The dataSource can be a stream, URI, file name or collection of xml elements "	| descriptor |	descriptor := self loadAndParse: dataSource.	descriptor schemaBindings isEmpty ifTrue: [ descriptor createDefaultBindingBaseURI: dataSource ].	^descriptor</body><body package="WSDLDescriptors">initializeFor: targetNamespaceString	| binding |	binding := WsdlBinding wsdlBindings values 		detect: [ :serv | serv name namespace = targetNamespaceString ]		ifNone: [^self error: ((#ThereIsNoWsdlBindingAt1s &lt;&lt; #webservices &gt;&gt; 'There is no WsdlBinding registered at: &lt;1s&gt;')  expandMacrosWith: targetNamespaceString ) ].		^binding bindingDescriptor configurationDescriptorClass new initializeFrom: targetNamespaceString</body><body package="WSDLDescriptors">loadAndParse: dataSource"The dataSource can be a stream, URI, file name or collection of xml elements "	| documents |	documents := (( dataSource isKindOf: Collection) and: [dataSource first isKindOf: Node ])		ifTrue: [ dataSource]		ifFalse: [ self loadFrom: dataSource ].		^self parse: documents</body><body package="WSDLDescriptors">new	^super new initialize</body><body package="WSDLDescriptors">objectReadFrom: aDataSource inNamespace: aString"The dataSource can be a stream, URI, file name or collection of xml elements "	| descriptor |	descriptor := self loadAndParse: aDataSource.	descriptor schemaBindings isEmpty ifTrue: [ descriptor createObjectBindingInNamespace: aString  baseURI: aDataSource ].	^descriptor</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor class</class-id> <category>loading</category><body package="WSDLDescriptors">loadFrom: dataSource"The dataSource can be a stream, URI or file name "	| baseURI allDocuments document |	document := self scanDocument: dataSource.	(document root tag type = 'definitions' or: [document root tag type = 'description']) ifFalse: [^self noDefinitionNodeError ].	allDocuments := OrderedCollection new.	allDocuments add: document.	baseURI := [dataSource   asURI ] on:Error do: [ :ex | ex return: nil].	self loadImportsFrom: document root  url: baseURI addTo:  allDocuments.	^allDocuments</body><body package="WSDLDescriptors">loadImportsFrom: anElement url: baseUrl addTo:  allDocuments	| xpath url importURI |	xpath := XPathParser new			xmlNode: anElement;			parse: 'child::import' as: #locationPath.	(xpath xpathValueFor: anElement  variables: nil) sortedNodes do: [ :importElem | 		(importElem  valueOfAttribute: 'location' ifAbsent: [nil]) ifNotNil: [ :location |			importURI := location asURI.			url := (baseUrl isNil or: [importURI isPartial not])						ifTrue: [ importURI ]						ifFalse: [baseUrl, importURI ].			self loadXMLDocumentsFrom: url  addTo:  allDocuments ]]</body><body package="WSDLDescriptors">loadXMLDocumentsFrom: aDataSource addTo: documents	| doc  |	doc := self scanDocument: aDataSource.	documents add: doc.	self  loadImportsFrom: doc root url: aDataSource addTo: documents.</body><body package="WSDLDescriptors">scanDocument: aDataSource 	| xmlParser|	(xmlParser := XMLParser  on: aDataSource) validate: false; saxDriver: WSSAXDriver new.	^[xmlParser scanDocument.	] 		on: XML.MalformedSignal		do:  [ :ex | 			ex errorString: ((#ErrorParsingXMLDoc &lt;&lt; #webservices &gt;&gt; 'Error parsing XML document: &lt;1s&gt;') expandMacrosWith: ex errorString).			ex parameter: aDataSource.			ex pass ].</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor class</class-id> <category>accessing</category><body package="WSDLDescriptors">bindingUrl	^self subclassResponsibility</body><body package="WSDLDescriptors">manager	^self subclassResponsibility</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor class</class-id> <category>parsing</category><body package="WSDLDescriptors">noDefinitionNodeError	^self error: (#WsdlSchemaDefinitionsOrDescriptionNodeNotFound &lt;&lt;#webservices &gt;&gt; 'Wsdl schema definitions or description node is not found in the document')</body><body package="WSDLDescriptors">parse: xmlDocuments"xmlDocuments collection of XML.Document or XML.Element"	| definitionsNS aClass |	definitionsNS := (xmlDocuments 		detect: [ :doc | doc root tag type = 'definitions' or: [doc root tag type = 'description']] 		ifNone: [^self noDefinitionNodeError ]) root tag namespace.	aClass := self subclasses 			detect: [ :cl | cl bindingUrl = definitionsNS ] 			ifNone: [self error: #UnknownWsdlSchemaNamespace &lt;&lt; #webservices &gt;&gt; 'Unknown Wsdl schema root namespace'].	^aClass new 		parse: xmlDocuments;		yourself</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">addBindingMessagesFrom: aWsdl11SoapOperationEnvelopeDescriptor 	aWsdl11SoapOperationEnvelopeDescriptor ifNil: [^nil].	aWsdl11SoapOperationEnvelopeDescriptor soapHeader ifNotNil: [ :headers |		headers do: [ :header | 			header message ifNotNil: [ self messages add:  header message value ].			header faults do: [ :fault | self messages add: fault message value]] ]</body><body package="WSDLDescriptors">addInterfaceMessagesFrom: anOperationParameterDescriptor	(anOperationParameterDescriptor notNil		and: [ anOperationParameterDescriptor message notNil ]) 		ifTrue: [ self messages add:  anOperationParameterDescriptor message ].</body><body package="WSDLDescriptors">initialize	super initialize.	messages := OrderedCollection new: 30.</body><body package="WSDLDescriptors">initializeFrom: targetNamespaceString	super initializeFrom: targetNamespaceString.	messages := Set new.	self interfaces do: [ :interface | 		interface operations do: [ :operation | 			self addInterfaceMessagesFrom: operation input.			self addInterfaceMessagesFrom: operation output.			operation faults do: [ :fault | self addInterfaceMessagesFrom: fault. ]]].	self bindings do: [ :binding | 		binding operations do: [ :operation | 			self addBindingMessagesFrom: operation input.			self addBindingMessagesFrom: operation output. ]].	messages := messages asOrderedCollection.</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>wsdl schema</category><body package="WSDLDescriptors">messageNodes	^self asWsdl realElements collect: [ :each | each tag type = 'message' ]</body><body package="WSDLDescriptors">portNodes	^self asWsdl realElements collect: [ :each | each tag type = 'port' ]</body><body package="WSDLDescriptors">serviceInterfaceNodes	^self asWsdl realElements collect: [ :each | each tag type = 'message' or: [each tag type = 'port' ] ]</body><body package="WSDLDescriptors">wsdlTargetNamespace	^'http://schemas.xmlsoap.org/wsdl/'</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">configurationBuilderClass	^Wsdl11Configuration</body><body package="WSDLDescriptors">messages	^messages</body><body package="WSDLDescriptors">messages: anObject	messages := anObject</body><body package="WSDLDescriptors">soapEncoding	^soapEncoding ifNil: [ false ]</body><body package="WSDLDescriptors">soapEncoding: anObject	soapEncoding := anObject</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>parsing</category><body package="WSDLDescriptors">parse: xmlDocuments	super parse: xmlDocuments.	"Remove non-supported bindings "	self bindings: (self bindings reject: [ :binding | binding bindingType isNil]). 	self services do: [ :service | 		service ports: 			( service ports select: [ :port | self bindings anySatisfy: [ :binding | binding name =  port binding ]]) ].</body><body package="WSDLDescriptors">setBindingInterfaceDescriptor	self  bindings do: [ :binding | 		binding operations do: [ :operation | 			soapEncoding ifNil: [operation input 				ifNotNil: [ :val | soapEncoding := ( val soapBody use = 'encoded' )]				ifNil: [operation output ifNotNil: [  :val | soapEncoding := ( val soapBody use = 'encoded' ) ]]].			operation parent: binding].		binding bindingType ifNotNil:			[ binding interfaceDescriptor: 				(self interfaces					detect: [ :interface | interface name type = binding interfaceDescriptor type ]					ifNone: [ ^WsdlParsingErrors raiseRequestErrorString: ((#NoInterfaceForBinding1s &lt;&lt; #webservices &gt;&gt; 'Interface not found for binding &lt;1s&gt;') expandMacrosWith: binding interfaceDescriptor asString )]).]]</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>adding</category><body package="WSDLDescriptors">add: aWsdlConfigurationDescriptor	super add:  aWsdlConfigurationDescriptor.	(aWsdlConfigurationDescriptor isKindOf:  WsdlConfigurationDescriptor)		ifTrue: [ self messages addAll:  aWsdlConfigurationDescriptor messages ].</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>resolving</category><body package="WSDLDescriptors">resolveMessageFor: aDescriptor	| mess aNodeTag |	(aDescriptor message isKindOf: Association) ifTrue: 		["Tool creates messages. No need to resolve it "		^aDescriptor message].	aNodeTag := aDescriptor message. 	(mess := self messages detect: [ :mx | mx name = aNodeTag ] ifNone: [ nil]) isNil			ifTrue: 				[self error: ((#CannotResolveMessage1s &lt;&lt; #webservices &gt;&gt; 'Can not resolve message: &lt;1s&gt;')					expandMacrosWith: aNodeTag message expandedName)].		aDescriptor message: aNodeTag-&gt;mess</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor class</class-id> <category>accessing</category><body package="WSDLDescriptors">bindingUrl	^WsdlBinding wsdl11_uri</body><body package="WSDLDescriptors">manager	| manager |	manager := SoapMarshalingManager on: WsdlBinding wsdl11Binding.	manager qualifierMap		at: 'http://schemas.xmlsoap.org/wsdl/' put: '';		at: 'http://www.w3.org/2001/XMLSchema' put: 'xsd';		at: 'http://schemas.xmlsoap.org/wsdl/' put:  'wsdl' ;    		at: 'http://schemas.xmlsoap.org/wsdl/soap/' put:  'soap';		at: 'http://schemas.xmlsoap.org/wsdl/http/' put:  'http'.	^manager</body></methods><methods><class-id>WebServices.SoapResponse</class-id> <category>testing</category><body package="WSDLBinding">failed	^self successful not</body><body package="WSDLBinding">hasException: aClass	| details |	details := self smalltalkEntity		ifNotNil: [self smalltalkEntity detailContents]		ifNil: [ self smalltalkEntity faultContents detail ifNotNil: [ :d | d contents]]. 	^details 		ifNil: [false]		ifNotNil: [ details first isKindOf: aClass ]</body><body package="WSDLBinding">hasFault	^self failed</body><body package="WSDLBinding">isResponse	^true</body><body package="WSDLBinding">needsHeader: aSymbol	^self operation notNil		ifTrue: [ (self operation needsOutputHeader: aSymbol) or: [self operation needsFaultHeader: aSymbol] ]		ifFalse: [ false ]</body><body package="WSDLBinding">successful	^self transportEntity isSuccess</body></methods><methods><class-id>WebServices.SoapResponse</class-id> <category>initialization</category><body package="WSDLBinding">request: aSoapRequest	request := aSoapRequest</body><body package="WSDLBinding">setOperationFrom: anXMLElement	operation := self binding transport findOperationForResponse:  anXMLElement</body><body package="WSDLBinding">setSmalltalkEntity: anObject	self smalltalkEntity: (anObject isSoapFault		ifTrue: [anObject]		ifFalse: [(Message 					selector: operation name type asSymbol  					arguments:  ( anObject ifNil: [#()] ifNotNil: [Array with: anObject]) )])</body></methods><methods><class-id>WebServices.SoapResponse</class-id> <category>accessing</category><body package="WSDLBinding">handler</body><body package="WSDLBinding">location	^self request isNil		ifTrue: [nil]		ifFalse: [self request accessPoint]</body><body package="WSDLBinding">reply	^self smalltalkEntity</body><body package="WSDLBinding">request	^request</body><body package="WSDLBinding">value	smalltalkEntity ifNil: [^nil]. "One-way operation "	smalltalkEntity bodyContents		ifNil: [SoapEmptyBodyException 					raiseWith: self transportEntity contents 					errorString: (#CanNotParseBodyContents &lt;&lt; #webservices &gt;&gt; 'Can not parse body contents') asString].	self operation 		resultFrom:  smalltalkEntity 		arguments: request smalltalkEntity arguments 		valueDo:  [ :envelopex :value | ^value ]		faultDo: [ :value | value raise ].</body></methods><methods><class-id>WebServices.SoapResponse</class-id> <category>api - unmarshal</category><body package="WSDLBinding">raiseException	| detail |	((detail := self smalltalkEntity faultContents detail) notNil and: [ detail contents first isSignalledException])		ifTrue: [	^detail  contents first raiseSignal ].		self smalltalkEntity faultContents asSpecificFault raise</body><body package="WSDLBinding">receivingMessage	self interceptorDispatcher receivingReply: self in: self transportEntity.</body><body package="WSDLBinding">receivingMessageEnvelope	self interceptorDispatcher receivingReplyEnvelope: self in: self transportEntity.</body><body package="WSDLBinding">unmarshal	((self operation notNil and: [self operation isInOnly and: [self transportEntity isSuccess]] )		or: [self transportEntity contentLength = 0 ]) 			ifTrue: [^nil].	^super unmarshal</body><body package="WSDLBinding">unmarshal: anXMLElement	( self binding transport findOperationForResponse:  anXMLElement)		ifNotNil: [ :anOperation | smalltalkEntity :=  anOperation  unmarshalResponse: anXMLElement]		ifNil: [ " fault message. Wsdl 2.0 can have faults with headers "			| envMarshaler headerMarshaler |						envMarshaler := self binding soapEnvelopeMarshaler copy.			headerMarshaler := (envMarshaler relations detect: [ :m | m path type = 'Header' ] ifNone: [nil]) typeMarshaler.			self binding faults ifNotNil: [ :faults | 				faults do: [ :faultBinding | 					faultBinding headers ifNotNil: [ :headers | 						headers do: [ :hBinding | headerMarshaler relations add: hBinding partMarshalers first ]]]].			smalltalkEntity := (SoapMarshalingManager on: self binding) unmarshal: anXMLElement with: envMarshaler].	header := smalltalkEntity header.	^smalltalkEntity</body><body package="WSDLBinding">unmarshalBodyFromXML: anXMLElement	operation ifNil: [ self setOperationFrom: anXMLElement ].	^operation unmarshalBodyFromXML: anXMLElement</body></methods><methods><class-id>WebServices.SoapResponse</class-id> <category>api - marshal</category><body package="WSDLBinding">marshalDom" Marshal Smalltalk object into something ready for transport "	| args |	operation ifNotNil: [ transportEntity := self operation transport prepareResponseFor: self].	self smalltalkEntity isSoapFault		ifTrue: [(binding isNil or: [(self smalltalkEntity isKindOf: VersionMismatchFault) ]) ifTrue: [self marshalFaultWithoutBinding. ^dom ].				operation 					ifNil: [dom := self binding transport marshalResponseFault: self smalltalkEntity transportEntity: self transportEntity]					ifNotNil: [dom := operation marshalResponseFault: self smalltalkEntity transportEntity: self transportEntity ]]		ifFalse: 	[args := operation setResponseArguments: self request message arguments value: self smalltalkEntity arguments.				dom := operation marshalResponsetIn: self transportEntity  with: args header: self header ].	^dom</body><body package="WSDLBinding">marshalFaultWithoutBinding"Opentalk callback.It can happen if - we got bogus url in a request and the server supports a few bindings. The smalltalkEntity expected to be Soap11Fault or Soap12Fault type-  there is not supported Envelope node tag. The fault is VersionMismatchFault"	| marshaler envelope manager envMarshaler |	(self smalltalkEntity isKindOf: VersionMismatchFault) 		ifTrue: [transport := SoapTransportBinding new binding: SoapBinding soap12Binding; yourself.				dom := transport marshalVersionMismatchFault:  self smalltalkEntity.				^transport prepareTransportEntity: self transportEntity].	binding ifNil: [binding := XMLObjectBinding registry values 					detect: [ :b | (b classMap at: self smalltalkEntity class ifAbsent: [nil]) notNil]					ifNone: [^dom := self smalltalkEntity printString]].	marshaler := binding marshalerForTag: (NodeTag qualifier: '' ns: binding targetNamespace type: 'Fault'). 	envelope := SoapEnvelope new. 	envelope fault: self smalltalkEntity.	manager := SoapMarshalingManager on: binding. 	envMarshaler := (binding  marshalerForClass: SoapEnvelope ifAbsent: [nil] ) copy.  	manager register: self smalltalkEntity marshalWith: marshaler.	dom := manager marshal: envelope with: envMarshaler.	self smalltalkEntity defaultTransport new prepareTransportEntity: self transportEntity.</body><body package="WSDLBinding">shouldReturnOneWayContents	(self operation isNil or: [ self operation isOneWay not ])  ifTrue: [^false].	" Failed Wsdl 2.0 'robust-in-only' operations will marshal the error in to the response "	(self operation isRobustInOnly and: [self transportEntity failed]) ifTrue: [^false].	"http://www.ws-i.org/profiles/basicprofile-1.1-2004-08-24.html#One-Way_Operations"	"http://www.w3.org/TR/2007/REC-wsdl20-adjuncts-20070626/#http-operation-decl-dest"	self operation setOneWayResponseCode: self transportEntity.	"Wsdl 1.1 one-way  and Wsdl 2.0 in-only/robust-in-only  operations return an empty response."	self transportEntity contents: ''.	^true</body></methods><methods><class-id>WebServices.Wsdl20BindingDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">configurationDescriptorClass	^Wsdl20ConfigurationDescriptor</body><body package="WSDLDescriptors">faults	^faults</body><body package="WSDLDescriptors">faults: aCollection	faults := aCollection</body><body package="WSDLDescriptors">type	^type</body><body package="WSDLDescriptors">type: aString	type := aString</body></methods><methods><class-id>WebServices.Wsdl20BindingDescriptor</class-id> <category>accessing soap 1.2 attributes</category><body package="WSDLDescriptors">bindingTransport	^self type		ifNotNil: [ :bindingTransportType |			self perform: ( self class transports 				at: bindingTransportType asLowercase				ifAbsent: [WsdlParsingErrors raiseRequestErrorString: ((#UnknownTransport1s &lt;&lt; #webservices &gt;&gt; 'Unknown transport: &lt;1s&gt;') expandMacrosWith: bindingTransportType asString)]) ]		ifNil: [WsdlParsingErrors raiseRequestErrorString: ((#BindingDoesnotDefineTransportType1s &lt;&lt; #webservices &gt;&gt; 'The binding doesn''t define the transport type') expandMacrosWith: name printString)]</body><body package="WSDLDescriptors">getTransportBinding	^self type		ifNotNil: [ :bindingTransportType |			self perform: ( self class transports 				at: bindingTransportType asLowercase				ifAbsent: [WsdlParsingErrors raiseRequestErrorString: ((#UnknownTransport1s &lt;&lt; #webservices &gt;&gt; 'Unknown transport: &lt;1s&gt;') expandMacrosWith: bindingTransportType asString)]) ]		ifNil: [WsdlParsingErrors raiseRequestErrorString: ((#BindingDoesnotDefineTransportType1s &lt;&lt; #webservices &gt;&gt; 'The binding doesn''t define the transport type') expandMacrosWith: name printString)]</body><body package="WSDLDescriptors">soapBinding	self protocol		ifNotNil: [ :soapProtocol |		self soapTransport protocol: soapProtocol.		self soapTransport transport: (			self perform: ( self class transports 				at: soapProtocol asLowercase				ifAbsent: [WsdlParsingErrors raiseRequestErrorString: ((#UnknownTransport1s &lt;&lt; #webservices &gt;&gt; 'Unknown transport: &lt;1s&gt;') expandMacrosWith: soapProtocol asString)])) ]				ifNil: [WsdlParsingErrors raiseRequestErrorString: ((#BindingDoesnotDefineTransportProtocol1s &lt;&lt; #webservices &gt;&gt; 'The binding doesn''t define the transport protocol') expandMacrosWith: name printString)].	^soapTransportBinding</body><body package="WSDLDescriptors">soapMep		^self soapTransport mep</body><body package="WSDLDescriptors">soapMep: aString		self soapTransport mep: aString</body><body package="WSDLDescriptors">soapModule		^self soapTransport soapModule</body><body package="WSDLDescriptors">soapModule: aStruct		self soapTransport soapModule: aStruct</body><body package="WSDLDescriptors">soapTransport	soapTransportBinding ifNil: [soapTransportBinding := SoapTransportBinding new].	^soapTransportBinding</body><body package="WSDLDescriptors">soapVersion		^self soapTransport soapVersion</body><body package="WSDLDescriptors">soapVersion: aString		self soapTransport soapVersion: aString</body></methods><methods><class-id>WebServices.Wsdl20BindingDescriptor</class-id> <category>accessing http attributes</category><body package="WSDLDescriptors">getHttpQueryParameterSeparator	| separator |	^((separator := self httpTransport queryParameterSeparator) = '&amp;' or: [ separator = ';' ])		ifTrue: [ nil ]		ifFalse: [ separator ]</body><body package="WSDLDescriptors">httpContentEncoding	^self httpTransport contentEncoding</body><body package="WSDLDescriptors">httpContentEncoding: aString	self httpTransport contentEncoding: aString</body><body package="WSDLDescriptors">httpCookies	^self httpTransport cookies</body><body package="WSDLDescriptors">httpCookies: aBoolean	self httpTransport cookies: aBoolean</body><body package="WSDLDescriptors">httpMethod	^self httpTransport method</body><body package="WSDLDescriptors">httpMethod: aString	self httpTransport method: aString</body><body package="WSDLDescriptors">httpQueryParameterSeparator	^self httpTransport queryParameterSeparator</body><body package="WSDLDescriptors">httpQueryParameterSeparator: aString	self httpTransport queryParameterSeparator: aString</body><body package="WSDLDescriptors">httpTransport	httpTransportBinding ifNil: [httpTransportBinding := HttpTransportBinding new.].	^httpTransportBinding</body></methods><methods><class-id>WebServices.Wsdl20BindingDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">initialize	faults := OrderedCollection new: 5</body></methods><methods><class-id>WebServices.Wsdl20BindingDescriptor class</class-id> <category>accessing</category><body package="WSDLDescriptors">default	| default |	default := self new.	default 		name: (NodeTag qualifier: '' ns: 'urn:wsSoap12Binding' type:  'WSSoap12Binding');		type: 'http://www.w3.org/ns/wsdl/soap';		protocol: 'http://www.w3.org/2003/05/soap/bindings/HTTP/';		soapVersion:  '1.2'.	^default</body><body package="WSDLDescriptors">transports	^Dictionary new		at: 'http://www.w3.org/ns/wsdl/soap' put: #soapBinding;		at: 'http://www.w3.org/2006/01/soap11/bindings/http/' put: #httpTransport;		at: 'http://www.w3.org/ns/wsdl/http' put: #httpTransport;		at: 'http://www.w3.org/2003/05/soap/bindings/http/'  put: #httpTransport;		yourself</body></methods><methods><class-id>WebServices.Wsdl20Configuration</class-id> <category>build components</category><body package="WSDLBinding">buildBindingComponents	descriptor bindings do: [ :bindingDescriptor | self buildWsdlBindingFrom: bindingDescriptor ].	super buildBindingComponents</body><body package="WSDLBinding">buildBindingFaultsFrom: bindingDescriptor binding: binding"http://www.w3.org/TR/wsdl20/#component-InterfaceFaultReference"	bindingDescriptor interfaceDescriptor ifNil: [^nil].	binding faults: 	  (bindingDescriptor interfaceDescriptor allFaults collect: [ :fault |		SoapWsdl20FaultBinding new 			buildMarshalerFrom: fault bindingFaults: bindingDescriptor  faults binding: binding; 			yourself ]).</body><body package="WSDLBinding">buildBindingTransportFrom: bindingDescriptor binding: binding	binding transport: bindingDescriptor bindingTransport.	binding transport binding: binding.	binding transport validate.</body><body package="WSDLBinding">buildHttpBindingOperationsFrom: aBindingDescriptor binding: binding"	binding operations: (		aBindingDescriptor interface allOperations			collect: [ :operationDescriptor | 				self buildHttpBindingOperationFrom: operationDescriptor bindingDescriptor: aBindingDescriptor binding: binding])"</body><body package="WSDLBinding">buildSoapBindingOperationFrom: interfaceOperation bindingDescriptor: aBindingDescriptor  binding: binding	|  operationBinding |	operationBinding := binding transport operationBindingClass new		interfaceDescriptor: interfaceOperation;		initializeFrom: aBindingDescriptor binding: binding;		yourself.	interfaceOperation input notEmpty ifTrue: [ 		operationBinding inputBodyMarshaler:			(SoapWsdl20MessageBinding new				buildMarshalerFor: operationBinding direction: 'in';				yourself).].	(interfaceOperation output notNil and: [interfaceOperation output notEmpty ]) ifTrue: [ 		operationBinding outputBodyMarshaler: 			(SoapWsdl20MessageBinding new				buildMarshalerFor: operationBinding direction: 'out' ;				yourself).			operationBinding isRpc ifTrue: [operationBinding setRpcStyleFrom: interfaceOperation].].	operationBinding inputFaultMarshalers: ( self 						buildFaultMarshalers: interfaceOperation  infaults						binding: binding).	operationBinding outputFaultMarshalers: ( self 						buildFaultMarshalers: interfaceOperation  outfaults 						binding: binding).	^operationBinding</body><body package="WSDLBinding">buildSoapBindingOperationsFrom: aBindingDescriptor binding: binding	binding operations: (		aBindingDescriptor interfaceDescriptor allOperations			collect: [ :operationDescriptor | 				self buildSoapBindingOperationFrom: operationDescriptor bindingDescriptor: aBindingDescriptor binding: binding])</body></methods><methods><class-id>WebServices.Wsdl20Configuration</class-id> <category>accessing</category><body package="WSDLBinding">classDescriptor	^Wsdl20ConfigurationDescriptor</body><body package="WSDLBinding">interfaceClass	^WsdlInterface</body><body package="WSDLBinding">soapBinding	^SoapBinding soap12Binding</body></methods><methods><class-id>WebServices.Wsdl20Configuration</class-id> <category>private</category><body package="WSDLBinding">buildFaultMarshalers: aCollection binding: binding"http://www.w3.org/TR/wsdl20/#component-InterfaceFaultReferencehttp://www.w3.org/TR/2007/REC-wsdl20-adjuncts-20070626/#soap-binding"	^aCollection collect: 		[ :struct | 		binding faults 			detect: [ :each | each name = (struct at: #name ifAbsent: [nil]) ] 			ifNone: [ WsdlParsingErrors raiseRequestErrorString: ((#ThereIsNoNameAttributeForInterfaceFault &lt;&lt; #webservices &gt;&gt;'There is no interface fault for the message:  &lt;1s&gt;') expandMacrosWith: struct printString )]]</body></methods><methods><class-id>WebServices.Wsdl20Configuration class</class-id> <category>accessing</category><body package="WSDLBinding">defaultTransportUri	^self soapTransportUri</body><body package="WSDLBinding">httpMethodFor: anUri	^self soapMEP at: anUri ifAbsent: [self error: (#UnknownSoapMep &lt;&lt;#webservices &gt;&gt; 'Unknown SOAP MEP in the schema binding') ]</body><body package="WSDLBinding">httpTransportUri	^'http://www.w3.org/ns/wsdl/http'</body><body package="WSDLBinding">soapHttpTransportUri	^'http://www.w3.org/2003/05/soap/bindings/HTTP/'</body><body package="WSDLBinding">soapMEP	^Dictionary new		at: #'http://www.w3.org/2003/05/soap/mep/soap-response' put: 'GET';		at: #'http://www.w3.org/2003/05/soap/mep/request-response/' put: 'POST';		yourself</body><body package="WSDLBinding">soapTransportUri	^'http://www.w3.org/ns/wsdl/soap'</body></methods><methods><class-id>WebServices.Wsdl11SoapBodyPartDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">encodingStyle	^encodingStyle</body><body package="WSDLDescriptors">encodingStyle: aValue	encodingStyle := aValue</body><body package="WSDLDescriptors">namespace	^namespace</body><body package="WSDLDescriptors">namespace: aString	namespace := aString</body><body package="WSDLDescriptors">parts	^parts</body><body package="WSDLDescriptors">parts: aValue	parts := aValue</body><body package="WSDLDescriptors">use	^use</body><body package="WSDLDescriptors">use: aValue	use := aValue asString</body></methods><methods><class-id>WebServices.Wsdl11SoapHeaderFaultDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">message	^message</body><body package="WSDLDescriptors">message: aWsdlMessageDescriptor	message := aWsdlMessageDescriptor</body><body package="WSDLDescriptors">messageNode	^(message isKindOf: Association)		ifTrue: [message key]		ifFalse: [message]</body><body package="WSDLDescriptors">part	^parts</body><body package="WSDLDescriptors">part: aString	parts := aString</body><body package="WSDLDescriptors">parts	^OrderedCollection with: parts</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>accessing faults</category><body package="WSDLBinding">mustUnderstandFault	^self isSoap11		ifTrue: [SoapMustUnderstandFault ]		ifFalse: [MustUnderstandFault ]</body><body package="WSDLBinding">receiverFault	^self isSoap11		ifTrue: [SoapServerFault ]		ifFalse: [ReceiverFault ]</body><body package="WSDLBinding">senderFault	^self isSoap11		ifTrue: [SoapClientFault ]		ifFalse: [SenderFault ]</body><body package="WSDLBinding">userHeaderError	^self isSoap11 ifTrue: [UserHeaderError] ifFalse: [UserHeader12Error]</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>api -- new request</category><body package="WSDLBinding">bodyChildNodeFromXML: anXMLElement	| nodes xp |	xp := XPathParser new xmlNode: anXMLElement; parse: '//child::Body' as: #locationPath.	(nodes := (xp xpathValueFor: anXMLElement variables: nil) sortedNodes) isEmpty		ifTrue: [SoapEmptyBodyException 					raiseWith: anXMLElement					errorString: (#CanNotParseBodyContents &lt;&lt; #webservices &gt;&gt; 'Can not parse body contents') asString].	^nodes first realElements first</body><body package="WSDLBinding">findOperationForRequest:  anXMLElement	| tag |	tag := (self bodyChildNodeFromXML: anXMLElement) tag.	self binding operations 		do: [ :operationBinding | (operationBinding canAcceptInputTag: tag) ifTrue: [^operationBinding] ].	NoOperationBindingException new		messageText: ((#NoOperationBindingFor1s &lt;&lt; #webservices &gt;&gt; 'No operation binding for &lt;1s&gt;')		expandMacrosWith: tag printString);		parameter: anXMLElement;		raise</body><body package="WSDLBinding">findOperationForResponse:  anXMLElement	| tag |	tag := (self bodyChildNodeFromXML: anXMLElement) tag.	tag type = 'Fault' ifTrue: [^nil ].	self binding operations 		do: [ :operationBinding | (operationBinding canAcceptOutputTag: tag) ifTrue: [^operationBinding] ].	NoOperationBindingException new		messageText: ((#NoOperationBindingFor1s &lt;&lt; #webservices &gt;&gt; 'No operation binding for &lt;1s&gt;')		expandMacrosWith: tag printString);		parameter: anXMLElement;		raise</body><body package="WSDLBinding">headerNodeFromXML: anXMLElement	| xp |	xp := XPathParser new			xmlNode: anXMLElement;			parse: '//child::Header' as: #locationPath.	^(xp xpathValueFor: anXMLElement variables: nil) sortedNodes</body><body package="WSDLBinding">newRequest	^HttpRequest new</body><body package="WSDLBinding">operationFromHttpHeader: aHttpEntity	| soapAction |	^(soapAction := self class defaultSoapActionBlock value: aHttpEntity )				ifNotNil: [self binding operations detect: [ :opx | opx  action = soapAction ]  ifNone: [ nil ]]		ifNil: [nil]</body><body package="WSDLBinding">prepareRequestFor: aSoapRequest 	aSoapRequest transportEntity 		ifNil: [aSoapRequest transportEntity:  self newRequest.			  aSoapRequest transportEntity method: self verb url: aSoapRequest accessPoint].	^self soapVersion = '1.1'		ifTrue: [ self prepareSoap11RequestFor: aSoapRequest ]			ifFalse: [self prepareSoap12RequestFor: aSoapRequest ]</body><body package="WSDLBinding">prepareResponseFor: aSoapRequest 	self soapVersion = '1.1'		ifTrue: [self prepareTransportEntity: aSoapRequest transportEntity ]			ifFalse: [aSoapRequest transportEntity contentType:  'application/soap+xml' charset: self transport contentEncoding.].	^aSoapRequest transportEntity</body><body package="WSDLBinding">prepareSoap11RequestFor: aSoapRequest 	| sa | 	(sa := self soap11ActionFor: aSoapRequest) ifNotNil: [		(sa isEmpty or: [sa first ~~ $"]) ifTrue: [ sa := '"', sa, '"'].		aSoapRequest transportEntity fieldValueAt: 'SOAPAction' put: sa].	^self prepareTransportEntity: aSoapRequest transportEntity.</body><body package="WSDLBinding">prepareSoap12RequestFor: aSoapRequest 	| type |"http://www.ietf.org/rfc/rfc3902.txt application/soap+xml  Content-Type: application/soap+xml; action=http://example.com/ticker  "	(type := self transport inputContentTypeFor: self method) = 'application/xml' ifTrue: [type := 'application/soap+xml'].	aSoapRequest transportEntity contentType: type charset: self transport contentEncoding.	self action ifNotNil: [( aSoapRequest transportEntity fieldAt: 'content-type') parameterAt: 'action' put: self action ].	^aSoapRequest transportEntity</body><body package="WSDLBinding">prepareTransportEntity: anHttpEntity 	^anHttpEntity		contentType: self class defaultContentType charset: self class defaultCharset;		yourself</body><body package="WSDLBinding">soap11ActionFor: aSoapRequest 	^self action</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>accessing</category><body package="WSDLBinding">action	^action</body><body package="WSDLBinding">headerEntryClass	^Soap12HeaderEntry</body><body package="WSDLBinding">httpBinding: anHttpBinding		transport := anHttpBinding</body><body package="WSDLBinding">httpTransport	^transport ifNil: [transport := HttpTransportBinding new]</body><body package="WSDLBinding">mep	^mep</body><body package="WSDLBinding">mep: anObject	mep := anObject</body><body package="WSDLBinding">operationBindingClass			^SoapWsdl20OperationBinding</body><body package="WSDLBinding">soapEnvelopeMarshaler	| ns |	ns := self soapVersion = '1.1' ifTrue: [ SoapBinding soap11_uri ] ifFalse: [ SoapBinding soap12_uri  ].	^(XMLObjectBinding bindingAtNamespace:ns)  typeMarshalerForTag: ( NodeTag qualifier: '' ns: ns type: 'Envelope' )</body><body package="WSDLBinding">soapModule	^soapModule</body><body package="WSDLBinding">soapModule: anObject	soapModule := anObject</body><body package="WSDLBinding">soapNamespace	^self isSoap11		ifTrue: [SoapBinding soap11_uri ]		ifFalse: [SoapBinding soap12_uri ]</body><body package="WSDLBinding">soapVersion	^soapVersion ifNil: [ '1.2' ]</body><body package="WSDLBinding">soapVersion: anObject	soapVersion := anObject</body><body package="WSDLBinding">transport	^transport ifNil: [transport := HttpTransportBinding new]</body><body package="WSDLBinding">transport: anTransportBinding		transport := anTransportBinding</body><body package="WSDLBinding">verb	verb ifNil: [verb := self class verbFor: self mep ].	^verb</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>testing</category><body package="WSDLBinding">isOneWay	^pattern = 'http://www.w3.org/ns/wsdl/in-only'</body><body package="WSDLBinding">isSoap11	^self soapVersion = '1.1'</body><body package="WSDLBinding">isSoap12	^self soapVersion = '1.2'</body><body package="WSDLBinding">isSoapBinding	^true</body><body package="WSDLBinding">validate	( soapVersion notNil and: [ soapVersion ~= '1.1' and: [ soapVersion ~= '1.2']]) 		ifTrue: [ WsdlParsingErrors raiseRequestErrorString: ((#NotSupportedSoapVersion &lt;&lt; #webservices &gt;&gt; 'The WSDL schema binding has non-supported Soap version: &lt;1s&gt;. Supported 1.1 and 1.2' ) expandMacrosWith: self soapVersion ) ].</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>initialize-release</category><body package="WSDLBinding">setDefaultPattern: aString	pattern := aString</body><body package="WSDLBinding">setSpecificOptionsFrom: aSoapTransportBinding	self transport setSpecificOptionsFrom: aSoapTransportBinding transport.	aSoapTransportBinding  mep ifNotNil: [ :option |  mep := option ].	aSoapTransportBinding  action ifNotNil: [ :option | action := option ].</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>visiting</category><body package="WSDLBinding">buildOperationsFor: aBuilder from: descriptor 	aBuilder buildSoapBindingOperationsFrom: descriptor binding: binding</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>copying</category><body package="WSDLBinding">postCopy	transport := transport copy.</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>marshal faults</category><body package="WSDLBinding">envelope	^SoapEnvelope</body><body package="WSDLBinding">envelopeMarshalerWithFault	| envMarshaler  |	envMarshaler := self binding soapEnvelopeMarshaler copy.  	((envMarshaler relations detect: [ :mx | mx tag type = 'Body' ] ifNone: [nil]) typeMarshaler )  		relations: (OrderedCollection with: (self binding soapFaultMarshaler qualified: true)).	^envMarshaler</body><body package="WSDLBinding">findSoapHeaderEntryMarshalerFor: anObject	^self binding findSoapEntryHeaderMarshalerFor: anObject version: self soapVersion</body><body package="WSDLBinding">manager	^SoapMarshalingManager on: self binding</body><body package="WSDLBinding">marshalFaultDoc: aFault with: aMarshalers	^aFault acceptVisit: self with: aMarshalers</body><body package="WSDLBinding">marshalMustUnderstandFault:  aFault with: aMarshalers" Marshal MustUnderstandFault object into XML Element "	| envelope objects |	objects := aFault asNotUnderstoodHeaderEntries.	self findSoapHeaderEntryMarshalerFor: objects first.	self mustUnderstandFaultString:  aFault.	envelope := self envelope new.	envelope header: (SoapHeader new headerEntries: objects; yourself) .		envelope fault: aFault asSoapFault.	^self manager marshal: envelope with: self soapEnvelopeMarshaler</body><body package="WSDLBinding">marshalResponseFault: aFault transportEntity: anHttpEntity" Marshal fault message when an operation is unknown "	^self marshalResponseFault: aFault transportEntity: anHttpEntity with: nil</body><body package="WSDLBinding">marshalResponseFault: aFault transportEntity: anHttpEntity with: faultMarshaler" Marshal fault message from an operation. Returns XML Document "	| http |	http := self prepareTransportEntity: anHttpEntity.	http statusCode:  aFault httpCode.	^self marshalFaultDoc: aFault with: faultMarshaler</body><body package="WSDLBinding">marshalSoapFault: aSoapFault with: aFaultBinding" Marshal Fault object into XML Element "	| envelope manager   obj  marshaler |	envelope := self envelope new. 	envelope fault: aSoapFault.	manager := self manager.	aSoapFault header notEmpty		ifTrue: [aFaultBinding prepareHeaders: aSoapFault header.				envelope header: aSoapFault header.			 	aSoapFault header headerEntries do: [ :value |  binding findSoapEntryHeaderMarshalerFor: value version: '1.2' ]].		(obj := aSoapFault detailContents) ifNotNil: [ :contents |		obj := contents first.		aFaultBinding ifNotNil: [ 			marshaler := aFaultBinding partMarshalers detect: [ :partMarshaler | partMarshaler typeMarshaler smalltalkClass = obj class] ifNone: [nil]]. 		marshaler ifNil: [			marshaler := ( XMLObjectBinding simpleMarshalerType: 'string' ) copy.		 	obj := obj printString.			aSoapFault detailContents: obj.].		marshaler typeMarshaler qualified: true.		manager register: obj marshalWith: marshaler typeMarshaler].	^manager marshal: envelope with: self soapEnvelopeMarshaler</body><body package="WSDLBinding">marshalUserHeaderError: anUserError with: aFaultBinding" Marshal header exception "	| fault |	fault := SenderFault new				faultString: anUserError faultString;				detail:  anUserError detail;				parameter: anUserError parameter;				reason: anUserError reason;				header: anUserError header;				yourself.	^self marshalSoapFault:  fault with: aFaultBinding</body><body package="WSDLBinding">marshalVersionMismatchFault:  aFault" Marshal VersionMismatchFault object into XML Element. #binding is SoapBinding  "	| envelope entry |	aFault faultString: (#VersionMismatch &lt;&lt; #webservices &gt;&gt; 'VersionMismatch' ) asString.	envelope := self envelope new.	entry := aFault asUpgradeHeaderEntry.	envelope header: (SoapHeader new addEntry: entry; yourself).	envelope fault: aFault asSoapFault.	self findSoapHeaderEntryMarshalerFor: entry.	^self manager marshal: envelope with: self soapEnvelopeMarshaler</body><body package="WSDLBinding">marshalVersionMismatchFault:  aFault with: aMarshalers	^self marshalVersionMismatchFault:  aFault</body><body package="WSDLBinding">mustUnderstandFaultString:  aFault " Marshal MustUnderstandFault object into XML Element "	|  faultString |	faultString := (#OneOrMoreHeaderBlocksNotUnderstood &lt;&lt; #webservices &gt;&gt; 'The following mandatory SOAP header blocks are not understood: ') asString. 	 aFault parameter do: [ :node | faultString := faultString, '  ', node namespace, ':', node type  ].	aFault faultString: faultString.</body></methods><methods><class-id>WebServices.SoapTransportBinding</class-id> <category>private</category><body package="WSDLBinding">sendAndWaitForReply: aSoapRequest" Send Http request and wait for reply. Translate any error that is handledat all into SOAPException carrying SoapFault "	| http retries  |	http := self client				ifNil: [aSoapRequest transportEntity newClient]				ifNotNil: [self client].	retries := 0.	http decodeContents: true.	http decompressContents: true.	^[			[http executeRequest: aSoapRequest transportEntity				] on: self retryExceptions				do: [ :ex |  retries &lt; self maxRetries 						ifTrue: [retries := retries + 1. ex retry]						ifFalse: 	[ex pass]]	]		on: HttpException		do: 	[:ex | |  response |			response := ex parameter.			(response isNil or: [HttpTimeout , HttpUnauthorizedError , HttpRedirectionError handles: ex])				ifTrue: [ex pass].			( 'text/xml' = response contentType 				or: [ 'application/soap+xml' = response contentType ])					ifTrue: [ ex return: response]					ifFalse: [ex pass]].</body></methods><methods><class-id>WebServices.SoapTransportBinding class</class-id> <category>instance creation</category><body package="WSDLBinding">verb: verbString action: soapActionString	^self new		verb: verbString;		action: soapActionString;		yourself</body><body package="WSDLBinding">verb: verbString soapAction: soapActionString	^SoapWsdl11HttpBinding verb: verbString soapAction: soapActionString</body></methods><methods><class-id>WebServices.SoapTransportBinding class</class-id> <category>defaults</category><body package="WSDLBinding">default	^self verb: 'POST' action: nil</body><body package="WSDLBinding">defaultSoapActionBlock	^defaultSoapActionBlock ifNil: [ self defaultSoapActionBlockValue]</body><body package="WSDLBinding">defaultSoapActionBlock: aBlock 	defaultSoapActionBlock := aBlock</body><body package="WSDLBinding">defaultSoapActionBlockValue	^[ :aHttpEntity | self findOperationTagFrom: aHttpEntity]</body><body package="WSDLBinding">findOperationTagFrom: aHttpEntity	^(aHttpEntity fieldValueAt: 'Content-type')		ifNil: [nil]		ifNotNil: [ :value | value first paramAt: 'action' ifAbsent: [nil] ]</body><body package="WSDLBinding">getUri	^'http://www.w3.org/2003/05/soap/mep/soap-response/'</body><body package="WSDLBinding">postUri	^'http://www.w3.org/2003/05/soap/mep/request-response/'</body><body package="WSDLBinding">verbFor: anUri		anUri = self getUri ifTrue: [^'GET'].	^'POST'</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">beInOnly</body><body package="WSDLDescriptors">beInOut	pattern := self class defaultPattern</body><body package="WSDLDescriptors">beRobustInOnly</body><body package="WSDLDescriptors">inputName: aNodeTag	input key: aNodeTag</body><body package="WSDLDescriptors">name: aValue	name := aValue</body><body package="WSDLDescriptors">outputName: aNodeTag	output key: aNodeTag</body><body package="WSDLDescriptors">pattern: anObject	pattern := anObject</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">faults	^faults</body><body package="WSDLDescriptors">faults: aValue	faults := aValue</body><body package="WSDLDescriptors">input	^input</body><body package="WSDLDescriptors">input: aValue	input := aValue</body><body package="WSDLDescriptors">inputName	^input key</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">output	^output</body><body package="WSDLDescriptors">output: aValue	output := aValue</body><body package="WSDLDescriptors">outputName	^output key</body><body package="WSDLDescriptors">pattern	^pattern ifNil: [self class defaultPattern]</body><body package="WSDLDescriptors">selector	^selector</body><body package="WSDLDescriptors">selector: aSymbol	selector := aSymbol</body><body package="WSDLDescriptors">style	^style</body><body package="WSDLDescriptors">style: anObject	style := anObject</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	aStream nextPutAll: self class name.	name ifNotNil: [aStream nextPutAll: ' #', name asString].	selector  ifNotNil: [aStream nextPutAll: ' selector: #', selector asString].</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id> <category>copying</category><body package="WSDLDescriptors">postCopy	super postCopy.	faults := faults collect: [ :fl | fl copy].</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id> <category>testing</category><body package="WSDLDescriptors">hasDescription	^input notNil or: [output notNil]</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor class</class-id> <category>defaults</category><body package="WSDLDescriptors">defaultPattern	^#inOut</body></methods><methods><class-id>WebServices.Wsdl11InterfaceOperationDescriptor</class-id> <category>testing</category><body package="WSDLDescriptors">isNotification	^input isNil</body><body package="WSDLDescriptors">isOneWay	^output isNil</body><body package="WSDLDescriptors">isRequestResponse	^input isNil not and: [output isNil not]</body></methods><methods><class-id>WebServices.Wsdl11InterfaceOperationDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">getParameterOrder	^parameterOrder isEmpty ifTrue: [nil] ifFalse: [parameterOrder]</body><body package="WSDLDescriptors">parameterOrder	^parameterOrder</body></methods><methods><class-id>WebServices.Wsdl11InterfaceOperationDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">beInOnly	output := nil</body><body package="WSDLDescriptors">beRobustInOnly	pattern := #OneWay.	self beInOnly</body><body package="WSDLDescriptors">initialize	parameterOrder := OrderedCollection new: 5</body><body package="WSDLDescriptors">parameterOrder: aValue	parameterOrder := aValue</body><body package="WSDLDescriptors">setDefaultsForStyle: documentOrRpc" WSDL prescribes default naming conventions for constituent messages of operations if no name was specified. For faults WSDL schema requires that name is always specied explicitly. However, we have seen WSDL specs with no name for faults, so we are using fault's name as a default rather than throwing error "	| suffix |	(self isNotification not and: [self inputName ~= self name]) 		ifTrue: 			[self inputName: (NodeTag 								qualifier: '' 								ns: self name namespace 								type: self name type)].	(self isOneWay not and: [self outputName ~= self name])		ifTrue: 			[suffix := (self isRequestResponse or: [documentOrRpc = #document ])						ifTrue: ['Response'] ifFalse: [''].			self outputName: (NodeTag 								qualifier: '' 								ns: self name namespace 								type: self name type, suffix)].	faults do: [ :faultAssoc | faultAssoc key ifNil: [faultAssoc key: faultAssoc value name]]</body></methods><methods><class-id>WebServices.Wsdl11InterfaceOperationDescriptor class</class-id> <category>instance creation</category><body package="WSDLDescriptors">new	^super new initialize</body></methods><methods><class-id>WebServices.Wsdl20InterfaceOperationDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">beInOnly	pattern := 'http://www.w3.org/ns/wsdl/in-only'.	output := OrderedCollection new.	outfaults := OrderedCollection new.</body><body package="WSDLDescriptors">beInOut	pattern := self class defaultPattern</body><body package="WSDLDescriptors">beRobustInOnly	pattern := 'http://www.w3.org/ns/wsdl/robust-in-only'.	output := OrderedCollection new.</body><body package="WSDLDescriptors">infaults: aValue	self faults: aValue</body><body package="WSDLDescriptors">outfaults: anObject	outfaults := anObject</body><body package="WSDLDescriptors">rpcSignature: anObject	rpcSignature := anObject</body></methods><methods><class-id>WebServices.Wsdl20InterfaceOperationDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">infaults	^self faults</body><body package="WSDLDescriptors">outfaults	^outfaults</body><body package="WSDLDescriptors">rpcSignature	^rpcSignature</body></methods><methods><class-id>WebServices.Wsdl20InterfaceOperationDescriptor</class-id> <category>testing</category><body package="WSDLDescriptors">hasDescription	^super hasDescription and: [ input notEmpty or: [output notEmpty]]</body><body package="WSDLDescriptors">isInOnly	^pattern = 'http://www.w3.org/ns/wsdl/in-only'</body><body package="WSDLDescriptors">isInOut	^pattern = self class defaultPattern</body><body package="WSDLDescriptors">isOneWay	^self isInOnly or: [ self isRobustInOnly ]</body><body package="WSDLDescriptors">isRobustInOnly	^pattern = 'http://www.w3.org/ns/wsdl/robust-in-only'</body></methods><methods><class-id>WebServices.Wsdl20InterfaceOperationDescriptor</class-id> <category>copying</category><body package="WSDLDescriptors">postCopy	super postCopy.	outfaults := outfaults collect: [ :fl | fl copy].</body></methods><methods><class-id>WebServices.Wsdl20InterfaceOperationDescriptor class</class-id> <category>defaults</category><body package="WSDLDescriptors">defaultPattern	^'http://www.w3.org/ns/wsdl/in-out'</body></methods><methods><class-id>WebServices.Wsdl11SoapHeaderDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addFault: aFaultDescriptor	^faults add: aFaultDescriptor</body><body package="WSDLDescriptors">faults	^faults</body><body package="WSDLDescriptors">faults: aCollection	faults := aCollection</body></methods><methods><class-id>WebServices.Wsdl11SoapHeaderDescriptor</class-id> <category>initialize-release</category><body package="WSDLDescriptors">initialize	faults := OrderedCollection new.</body></methods><methods><class-id>WebServices.Wsdl11SoapHeaderDescriptor</class-id> <category>private</category><body package="WSDLDescriptors">faultChoice	| key |	key := (version = '1.2' ifTrue: [ #faults12 ] ifFalse: [ #faults11 ]).	^key -&gt; self faults</body><body package="WSDLDescriptors">faultChoice: anAssociation		| theAssociation |	(theAssociation := anAssociation) isStruct		ifTrue: [theAssociation := anAssociation associations first].	theAssociation key = #faults11 ifTrue: [ version := '1.1' ].	theAssociation key = #faults12 ifTrue: [ version := '1.2' ].	self faults: theAssociation value</body></methods><methods><class-id>WebServices.Wsdl11SoapHeaderDescriptor class</class-id> <category>instance creation</category><body package="WSDLDescriptors">new	^self basicNew initialize</body></methods><methods><class-id>WebServices.SoapHeaderEntry</class-id> <category>accessing</category><body package="SOAPBinding">actor	^nil</body><body package="SOAPBinding">anyAttributes	^anyAttribute ifNil: [OrderedCollection new]</body><body package="SOAPBinding">anyAttributes: aCollection	anyAttribute := aCollection</body><body package="SOAPBinding">mu	^self mustUnderstand</body><body package="SOAPBinding">mu: aBoolean	self mustUnderstand: aBoolean</body><body package="SOAPBinding">mustUnderstand	^mustUnderstand</body><body package="SOAPBinding">mustUnderstand: aBoolean	mustUnderstand := aBoolean</body><body package="SOAPBinding">name	^name</body><body package="SOAPBinding">name: aStringOrNodeTag	name := (aStringOrNodeTag isString				ifTrue: [ NodeTag qualifier: '' ns: '' type: aStringOrNodeTag asString]				ifFalse: [aStringOrNodeTag])</body><body package="SOAPBinding">value	^value</body></methods><methods><class-id>WebServices.SoapHeaderEntry</class-id> <category>initialization</category><body package="SOAPBinding">value: anObject	value := anObject</body></methods><methods><class-id>WebServices.SoapHeaderEntry</class-id> <category>printing</category><body package="SOAPBinding">printAttributesOn: aStream	name ifNotNil: [ aStream nextPutAll: 'named: ',name type printString].	self mustUnderstand ifNotNil: 		[aStream nextPutAll: ' mu: '.		self mustUnderstand printOn: aStream].</body><body package="SOAPBinding">printOn: aStream	aStream nextPutAll: self class name, ' ( '.	self printAttributesOn: aStream.	aStream nextPutAll: ';  value: '.	self value printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>WebServices.SoapHeaderEntry class</class-id> <category>instance creation</category><body package="SOAPBinding">name: aStringOrNodeTag	^self new		mu: true;		name: aStringOrNodeTag;		yourself</body><body package="SOAPBinding">value: anObject 	^self new		value: anObject;		yourself</body><body package="SOAPBinding">value: anObject mustUnderstand: aBoolean 	^self new		value: anObject;		mustUnderstand: aBoolean;		yourself</body></methods><methods><class-id>WebServices.Soap12HeaderEntry</class-id> <category>testing</category><body package="SOAPBinding">isNext	^self role isNil 		ifTrue: [ false ]		ifFalse: [ self class nextRole match: self role ]</body></methods><methods><class-id>WebServices.Soap12HeaderEntry</class-id> <category>accessing</category><body package="SOAPBinding">encodingStyle	^encodingStyle</body><body package="SOAPBinding">encodingStyle: anObject	encodingStyle := anObject</body><body package="SOAPBinding">relay	^relay</body><body package="SOAPBinding">relay: aBoolean	relay := aBoolean</body><body package="SOAPBinding">role	^role</body><body package="SOAPBinding">role: anObject	role := anObject</body></methods><methods><class-id>WebServices.Soap12HeaderEntry class</class-id> <category>instance creation</category><body package="SOAPBinding">targetRecipientMU0Value: anObject	^self 		value: anObject		mustUnderstand: false		role: self nextRole</body><body package="SOAPBinding">targetRecipientMU1Value: anObject	^self 		value: anObject		mustUnderstand: true		role: self nextRole</body><body package="SOAPBinding">targetRecipientValue: anObject	^self value: anObject role: self nextRole</body><body package="SOAPBinding">value: anObject mustUnderstand: aBoolean role: aString	^self new		value: anObject;		mustUnderstand: aBoolean;		role: aString;		yourself</body><body package="SOAPBinding">value: anObject role: aString	^self new		value: anObject;		role: aString;		yourself</body></methods><methods><class-id>WebServices.Soap12HeaderEntry class</class-id> <category>testing</category><body package="SOAPBinding">nextRole	^'http://www.w3.org/2003/05/soap-envelope/role/next'</body></methods><methods><class-id>WebServices.VersionMismatchFault class</class-id> <category>accessing</category><body package="SOAPBinding">faultTag	^NodeTag 		qualifier: self defaultQualifier		ns: self namespace		type: 'VersionMismatch'</body></methods><methods><class-id>WebServices.Wsdl20OperationBindingDescriptor</class-id> <category>accessing http attributes</category><body package="WSDLDescriptors">getHttpIgnoreUncited	^self httpTransport ignoreUncited ifFalse: [ nil]</body><body package="WSDLDescriptors">httpFaultSerialization	^self httpTransport  faultSerialization</body><body package="WSDLDescriptors">httpFaultSerialization: aString	self httpTransport faultSerialization: aString</body><body package="WSDLDescriptors">httpIgnoreUncited	^self httpTransport ignoreUncited</body><body package="WSDLDescriptors">httpIgnoreUncited: aBoolean	self httpTransport ignoreUncited: aBoolean</body><body package="WSDLDescriptors">httpInputSerialization	^self httpTransport inputSerialization</body><body package="WSDLDescriptors">httpInputSerialization: aString	self httpTransport inputSerialization: aString</body><body package="WSDLDescriptors">httpLocation	^self httpTransport location</body><body package="WSDLDescriptors">httpLocation: aString	^self httpTransport location: aString</body><body package="WSDLDescriptors">httpOutputSerialization	^self httpTransport outputSerialization</body><body package="WSDLDescriptors">httpOutputSerialization: aString	^self httpTransport outputSerialization: aString</body></methods><methods><class-id>WebServices.Wsdl20OperationBindingDescriptor</class-id> <category>accessing soap attributes</category><body package="WSDLDescriptors">getSoapMep		^self soapMep = parent soapMep		ifTrue: [ nil]		ifFalse: [ self soapMep ]</body><body package="WSDLDescriptors">soapAction	^self soapOperationDescriptor action</body><body package="WSDLDescriptors">soapAction: aValue	self soapTransport action:  aValue.	self soapOperationDescriptor action: aValue</body><body package="WSDLDescriptors">soapOperationDescriptor	^soapOperationDescriptor ifNil: [soapOperationDescriptor := Struct new]</body><body package="WSDLDescriptors">soapOperationDescriptor: aValue	soapOperationDescriptor := aValue</body><body package="WSDLDescriptors">soapStyle: aValue		self soapOperationDescriptor style: aValue</body></methods><methods><class-id>WebServices.Wsdl20OperationBindingDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addInfault: aStruct	faults ifNil: [faults := OrderedCollection new].	(faults detect: [ :fl | ( fl at: #name) = (aStruct at: #name)] ifNone: [nil])		ifNotNil: [ :fault | faults remove: fault ].	faults add: aStruct</body><body package="WSDLDescriptors">addInputSoapHeader: aWsdl20HeaderDescriptor	input ifNil: [input := OrderedCollection new].	input isEmpty ifTrue: [ input add: self soapParameterDescriptor ].	input first addSoapHeader: aWsdl20HeaderDescriptor.</body><body package="WSDLDescriptors">addOutfault: aStruct	outfaults ifNil: [ outfaults := OrderedCollection new].	(outfaults detect: [ :fl | ( fl at: #name) = (aStruct at: #name)] ifNone: [nil])		ifNotNil: [ :fault | outfaults remove: fault ].	outfaults add: aStruct.</body><body package="WSDLDescriptors">addOutputSoapHeader: aWsdl20HeaderDescriptor	output ifNil: [output := OrderedCollection new].	output isEmpty ifTrue: [ output add: self soapParameterDescriptor ].	output first addSoapHeader: aWsdl20HeaderDescriptor.</body><body package="WSDLDescriptors">infaults	^self faults</body><body package="WSDLDescriptors">infaults: aColl	self faults: aColl</body><body package="WSDLDescriptors">input	^input</body><body package="WSDLDescriptors">input: anObject	input := anObject</body><body package="WSDLDescriptors">outfaults	^outfaults</body><body package="WSDLDescriptors">outfaults: anObject	outfaults := anObject</body><body package="WSDLDescriptors">output	^output</body><body package="WSDLDescriptors">output: anObject	output := anObject</body><body package="WSDLDescriptors">parent	^parent</body><body package="WSDLDescriptors">parent: anObject	parent := anObject</body><body package="WSDLDescriptors">protocol	^parent protocol</body><body package="WSDLDescriptors">soapParameterDescriptor	^Wsdl20SoapOperationParameterDescriptor new</body></methods><methods><class-id>WebServices.Wsdl20OperationBindingDescriptor</class-id> <category>testing</category><body package="WSDLDescriptors">hasHttpTransport	^httpTransportBinding notNil</body><body package="WSDLDescriptors">hasSoapTransport	^soapOperationDescriptor notNil</body></methods><methods><class-id>WebServices.Wsdl20OperationBindingDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	aStream nextPutAll: self class name.	name ifNotNil: [aStream nextPutAll: ' ref=', name type ].</body></methods><methods><class-id>WebServices.Wsdl20OperationBindingDescriptor</class-id> <category>accessing soap 1.2 attributes</category><body package="WSDLDescriptors">soapMep: aString		self soapTransport mep: aString</body></methods><methods><class-id>WebServices.SoapEnvelope</class-id> <category>initialization</category><body package="SOAPBinding">initialize	body := SoapBodyStruct new</body></methods><methods><class-id>WebServices.SoapEnvelope</class-id> <category>testing</category><body package="SOAPBinding">failed	^self isFault</body><body package="SOAPBinding">hasHeader	^self header ~~ nil</body><body package="SOAPBinding">isFault	^self contents isEmpty not and: [ self bodyContents isSoapFault]</body><body package="SOAPBinding">successful	^self failed not</body></methods><methods><class-id>WebServices.SoapEnvelope</class-id> <category>accessing</category><body package="SOAPBinding">body	^body</body><body package="SOAPBinding">body: aSoapBodyStruct	body := aSoapBodyStruct</body><body package="SOAPBinding">bodyContents	^self contents isNotEmpty ifTrue: [self contents first] ifFalse: [nil ]</body><body package="SOAPBinding">contents	^body contents</body><body package="SOAPBinding">contents: anObject	body contents: anObject</body><body package="SOAPBinding">fault	^self bodyContents</body><body package="SOAPBinding">fault: aFault	self body at: #fault put: aFault</body><body package="SOAPBinding">header	^header</body><body package="SOAPBinding">header: aStruct	header := aStruct</body><body package="SOAPBinding">headerAt: aString ifAbsent: aBlock	^self header == nil		ifTrue: [ nil ]		ifFalse: [ self header headerAt: aString ifAbsent: aBlock ]</body><body package="SOAPBinding">headerAt: aString put: aSoapHeader	header ifNil: [ header := SoapHeader new]. 	header headerAt: aString put: aSoapHeader.</body><body package="SOAPBinding">operationName	^self body operationName</body><body package="SOAPBinding">partOrder	^body partOrder</body><body package="SOAPBinding">partOrder: anArray	body partOrder: anArray</body><body package="SOAPBinding">rpcValues	^self bodyContents orderedValues</body></methods><methods><class-id>WebServices.SoapEnvelope</class-id> <category>obsolete</category><body package="SOAPBinding">documentContents	^self bodyContents</body><body package="SOAPBinding">faultContents	^self fault</body><body package="SOAPBinding">rpcContents	^self bodyContents</body></methods><methods><class-id>WebServices.SoapEnvelope class</class-id> <category>instance creation</category><body package="SOAPBinding">fault: aFault	^self new		fault: aFault;		yourself</body><body package="SOAPBinding">new	^super new initialize</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>accessing</category><body package="WSDLBinding">action	^descriptor soapOperationDescriptor at: #soapAction ifAbsent: [nil]</body><body package="WSDLBinding">action: aString 	^descriptor soapOperationDescriptor at: #soapAction put: aString</body><body package="WSDLBinding">anyEncoding	^self inputBodyMarshaler use</body><body package="WSDLBinding">bindingTypeString	^'Soap'</body><body package="WSDLBinding">equivalentSmalltalkMessageName	^self isDocument		ifTrue: [self operationSelector]		ifFalse: [ self rpcSelector].</body><body package="WSDLBinding">faultMarshalers	^faultMarshalers</body><body package="WSDLBinding">faultMarshalers: aCollSoapParameterMarshaler	faultMarshalers := aCollSoapParameterMarshaler</body><body package="WSDLBinding">headerMarshalerNamed: aString 	| hm |	(hm := self inputHeaderBindings detect: [ :mx |  mx entryName asString = aString asString ] ifNone: [ nil ]) notNil		ifTrue: [^hm ].	(hm := self outputHeaderBindings detect: [ :mx |  mx entryName asString  = aString asString ] ifNone: [ nil ]) notNil		ifTrue: [^hm ].	^nil</body><body package="WSDLBinding">headerMarshalerNamed: aString ifAbsent: aBlock	| hm |	(hm := self inputHeaderBindings detect: [ :mx |  mx entryName asString = aString asString ] ifNone: [ nil ]) notNil		ifTrue: [^hm ].	(hm := self outputHeaderBindings detect: [ :mx |  mx entryName asString  = aString asString ] ifNone: [ nil ]) notNil		ifTrue: [^hm ].	^aBlock value</body><body package="WSDLBinding">inputFaultHeaderTags	| coll |	coll := OrderedCollection new.	self inputHeaderBindings collect: [ :mx | coll addAll: mx faultTags ].	^coll</body><body package="WSDLBinding">inputHeaderBindings	^inputHeaderBindings == nil		ifTrue: [ Array new ]		ifFalse: [ inputHeaderBindings ]</body><body package="WSDLBinding">inputHeaderBindings: aCollSoapHeaderBindings	inputHeaderBindings := aCollSoapHeaderBindings</body><body package="WSDLBinding">inputHeaderMarshaler	^inputHeaderMarshaler</body><body package="WSDLBinding">inputHeaderMarshaler: aComplexObjectMarshaler	inputHeaderMarshaler := aComplexObjectMarshaler</body><body package="WSDLBinding">inputHeaderTags	^self inputHeaderBindings collect: [ :mx | mx  headerTag]</body><body package="WSDLBinding">marshalers	| coll |	coll := OrderedCollection new: 20.	self faultMarshalers do: [ :m | coll addAll: m marshalers].	self inputBodyMarshaler ifNotNil:  [ coll addAll: self inputBodyMarshaler marshalers].	self outputBodyMarshaler ifNotNil: [ coll addAll: self outputBodyMarshaler marshalers]. 	self inputHeaderBindings do: [ :m |  coll addAll: m marshalers ].	self outputHeaderBindings do: [ :m | coll addAll: m marshalers ].	^coll</body><body package="WSDLBinding">outputFaultHeaderTags	| coll |	coll := OrderedCollection new.	self outputHeaderBindings collect: [ :mx | coll addAll: mx faultTags ].	^coll</body><body package="WSDLBinding">outputFaultMarshalers	^#()</body><body package="WSDLBinding">outputHeaderBindings	^outputHeaderBindings == nil		ifTrue: [ Array new ]		ifFalse: [ outputHeaderBindings ]</body><body package="WSDLBinding">outputHeaderBindings: aCollSoapHeaderBinding	outputHeaderBindings := aCollSoapHeaderBinding</body><body package="WSDLBinding">outputHeaderMarshaler	^outputHeaderMarshaler</body><body package="WSDLBinding">outputHeaderMarshaler: aComplexObjectMarshaler	outputHeaderMarshaler := aComplexObjectMarshaler</body><body package="WSDLBinding">outputHeaderTags	^self outputHeaderBindings collect: [ :mx | mx headerTag ]</body><body package="WSDLBinding">outputParts	^self outputBodyMarshaler partNames</body><body package="WSDLBinding">rpcSelector	| params opName stream |	opName := self name asString.	stream := (String new: opName size) writeStream.	self asKeyword: opName on: stream.	params := self inputBodyMarshaler partNames.	params notEmpty ifTrue: 		[self class usePart1InSelector ifTrue: 			[stream 				nextPut: params first first asUppercase;				nextPutAll: ( params first copyFrom: 2 to: params first size)].		stream nextPut: $:.		2 to: params size do: [ :i |			self  asKeyword: (params at: i) on: stream.			stream nextPut: $: ] ].	^stream contents asSymbol</body><body package="WSDLBinding">soapAction	^self action</body><body package="WSDLBinding">soapAction: aValue	self action: aValue</body><body package="WSDLBinding">style	^descriptor soapOperationDescriptor at: #style ifAbsent: [descriptor parent style ]</body><body package="WSDLBinding">style: aString 	^descriptor soapOperationDescriptor at: #style put: aString</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>testing</category><body package="WSDLBinding">canAcceptInputTag: aNodeTag		^self isDocument		ifTrue: [ self inputBodyMarshaler partNames notEmpty				ifTrue: [self inputBodyMarshaler partMarshalers anySatisfy: [ :marshaler | marshaler tag = aNodeTag ] ]				ifFalse: [self inputBodyMarshaler structMarshaler tag = aNodeTag]]		ifFalse: [ self inputBodyMarshaler structMarshaler tag = aNodeTag ]</body><body package="WSDLBinding">canAcceptOutputTag: aNodeTag	self isOneWay ifTrue: [^false].	^self isDocument		ifTrue: [ self outputBodyMarshaler partNames notEmpty				ifTrue: [self outputBodyMarshaler partMarshalers anySatisfy: [ :marshaler | marshaler tag = aNodeTag ] ]				ifFalse: [self outputBodyMarshaler structMarshaler tag = aNodeTag]]		ifFalse: [ self outputBodyMarshaler structMarshaler tag = aNodeTag ]</body><body package="WSDLBinding">isDocument	^self style = #document</body><body package="WSDLBinding">isInOnly	^self isOneWay</body><body package="WSDLBinding">isOneWay	^self inputBodyMarshaler notNil and: [self outputBodyMarshaler isNil ]</body><body package="WSDLBinding">isRobustInOnly	^false</body><body package="WSDLBinding">isRpc	^self style = #rpc</body><body package="WSDLBinding">needsInputHeader: aSymbol	^self inputHeaderBindings anySatisfy: [ :hbinding | hbinding partNames first = aSymbol asSymbol ]</body><body package="WSDLBinding">needsOutputHeader: aSymbol	^self outputHeaderBindings anySatisfy: [ :hbinding | hbinding partNames first = aSymbol asSymbol]</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>marshal request</category><body package="WSDLBinding">marshalRequestWith: anArguments header: header" Marshal Smalltalk object and header objects into XML Element"	^self 		marshalArguments: anArguments 		header: header 		bodyMarshaler: self inputBodyMarshaler		headerMarshaler: self inputHeaderBindings</body><body package="WSDLBinding">prepareRequestFor: aSoapRequest		^self transport prepareRequestFor: aSoapRequest.</body><body package="WSDLBinding">setRequestArgumentsFrom: aMessage 	| argCollection  marshaler relations struct | 	argCollection := aMessage arguments.	argCollection isEmpty ifTrue: [^argCollection].	( argCollection first isKindOf: self envelope) ifTrue: [^argCollection first contents first ].	^self isDocument 		ifTrue: [ (self class defaultUseOldDocStyleInvocation					or: [	self inputBodyMarshaler isWrapped not						or: [(marshaler := self inputBodyMarshaler partMarshaler ) isNil							or: [(relations := marshaler typeMarshaler relations) size ~= argCollection size ]]]) ifTrue: [^argCollection].				(marshaler typeMarshaler relations size = 1					and: [ argCollection size =1 						and: [ argCollection first isStruct							and: [marshaler typeMarshaler relations first tag type = argCollection first keys first asString ]]])						ifTrue: [^argCollection].				struct := Struct new.				1 to: relations size do: [ :ind |struct at: (relations at: ind) relation name asSymbol put: (argCollection at: ind) ].				OrderedCollection with: struct]		ifFalse: 	[( argCollection copyFrom: 1 to: self inputBodyMarshaler structMarshaler relations size )					collect: [ :arg | arg evaluate ] ].</body><body package="WSDLBinding">smalltalkEntityFromRpcRequest: soapBody selector: requestSelector" Opentalk callback"	| numberParts args inArgs |	numberParts := self  inputBodyMarshaler partMarshalers size.	args := Array new: requestSelector numArgs.	inArgs := soapBody orderedValues.	inArgs with: (1 to: inArgs size) do: [ :arg :i | args at: i put: arg].	args size &gt; numberParts		ifTrue: [numberParts + 1 to: args size do: [ :i | args at: i put: (args at: i) asOutputParameter ]].	^args</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>marshal response</category><body package="WSDLBinding">headerNameFromBindingsFor: anException	self inputHeaderBindings do: [ :b | 		(b excMarshalers notNil 			and: [(b excMarshalers at: anException class ifAbsent: [nil]) notNil])				ifTrue: [^b entryName]]. 	self outputHeaderBindings do: [ :b | 		(b excMarshalers notNil 			and: [(b excMarshalers at: anException class ifAbsent: [nil]) notNil]) 				ifTrue: [^b entryName ]]. 	^nil</body><body package="WSDLBinding">marshalResponseWith: anArguments header: header" Marshal Smalltalk object and header objects into XML Element"	^self 		marshalArguments: anArguments 		header: header 		bodyMarshaler: self outputBodyMarshaler		headerMarshaler: self outputHeaderBindings</body><body package="WSDLBinding">outputFaultMarshalerFor: aFault	^(aFault isKindOf: UserHeaderError)		ifTrue: [ (self headerMarshalerNamed: aFault parameter ifAbsent: [nil])					ifNotNil: [ :headerMarshaler | headerMarshaler faultMarshalerForObject: aFault detailContentFirst class ifAbsent: [nil ]]]		ifFalse: [aFault detailContents ifNotNil: [ :contents | 					binding marshalerForClass: contents first class ifAbsent: [nil]]]</body><body package="WSDLBinding">raiseAsUserHeaderError: anException	| headerName |	headerName := ( anException class respondsTo: #headerName ) 		ifTrue: [anException class headerName]		ifFalse: [self headerNameFromBindingsFor: anException].	headerName ifNil: [headerName := 'Header Error'  ].	(UserHeaderError headerName: headerName exception: anException ) raise</body><body package="WSDLBinding">resultFrom:  envelope arguments: arguments valueDo: aBlock faultDo: faultBlock"Opentalk-Soap callback."	| value bodyResult |	envelope isFault ifTrue: [ ^faultBlock value: (self processFault: envelope fault asSpecificFault)].	value := self isDocument		ifTrue: 			[ (envelope bodyContents isNil or: [ self class defaultUseOldDocStyleInvocation])				ifTrue: [ envelope contents ]				ifFalse: 	[ bodyResult := envelope bodyContents.						value := (bodyResult isStruct and: [bodyResult keys first = #result ]) ifTrue: [bodyResult values first] ifFalse: [bodyResult]].						self class wrapDocumentLiteralResult ifTrue: [ OrderedCollection with: value ] ifFalse: [ value ]  ]		ifFalse: 			[ | results args |			results := envelope rpcValues.			args := arguments select: [ :arg | arg isOutputParameter ].			args isEmpty				ifTrue: [ results isEmpty 	ifTrue: [nil] ifFalse: [results first] ]				ifFalse: [ args with: (2 to: results size) do: [ :vh :i | vh value: (results at: i) ].						results first ]].	aBlock value: envelope value: value.</body><body package="WSDLBinding">rpcValue: result requestArguments: anArguments	| r struct |  	^self class rpcResultAsStruct		ifTrue: [struct := Struct new: 20.				self  outputParts with: result contents 					do: [ :part :res | struct at: part put: res].				struct ]		ifFalse: 	[result contents size &gt; 1					ifTrue: [ result contents]					ifFalse: [(r := result  contents) isEmpty ifTrue: [nil] ifFalse: [r first]]]</body><body package="WSDLBinding">setOneWayResponseCode: anHttpResponse"http://www.ws-i.org/profiles/basicprofile-1.1-2004-08-24.html#One-Way_Operations.One-way operations do not produce SOAP responses. Therefore, the Profile prohibits sending a SOAP envelope in response to a one-way operation. This means that transmission of one-way operations can not result in processing level responses or errors. For example, a '500 Internal Server Error' HTTP response that contains a fault can not be returned in this situation. The HTTP response to a one-way operation indicates the success or failure of the transmission of the message. Based on the semantics of the different response status codes supported by the HTTP protocol, the Profile specifies that '200' and '202' are the preferred status codes that the sender should expect, signifying that the one-way message was received. A successful transmission does not indicate that the SOAP processing layer and the application logic has had a chance to validate the envelope or have committed to processing it " 	anHttpResponse isSuccess 		ifTrue: [ anHttpResponse statusLine code: '202'  ]		ifFalse: [  anHttpResponse statusLine code: '500'  ].</body><body package="WSDLBinding">setResponseArguments: anArguments value: reply	| args collection |	args := anArguments select: [ :arg | arg isOutputParameter ].	collection := args isEmpty		ifTrue: [  reply ]		ifFalse: [ args					inject: ((OrderedCollection new: args size + 1) addAll: reply; 	yourself)					into: [ :newArgs :arg | newArgs add: arg evaluate; yourself ] ].	^self  setResponseArgumentsFrom: collection</body><body package="WSDLBinding">setResponseArgumentsFrom: aCollection"Opentalk-Soap callback."	| m docSelector |	^(aCollection isEmpty 			or: [ self isRpc 				or: [ self class  defaultUseOldDocStyleInvocation ]])		ifTrue: [ aCollection ]		ifFalse:	[m := self outputBodyMarshaler partMarshalers first.				( self isMarshalerResultWrapper: m typeMarshaler )					ifTrue: [ docSelector := m typeMarshaler relations first relation getSelector .							Array with:   (Struct new  at: docSelector  put: aCollection first; yourself)]					ifFalse: [ aCollection ]]</body><body package="WSDLBinding">unmarshalResponse: anXMLElement" Unmarshal XML Element in to Smalltalk object "	^self unmarshalSoapEnvelope: anXMLElement</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>private creating script</category><body package="WSDLBinding">anyHeaderBinding	(self inputHeaderBindings isNil or: [self inputHeaderBindings isEmpty]) ifTrue: [^nil].	^self inputHeaderBindings collect: [ :hbinding | hbinding partMarshaler ].</body><body package="WSDLBinding">bodyExceptions	| fmarshaler  excNames |	excNames := OrderedCollection new.	faultMarshalers isEmpty ifTrue: [ ^excNames ].	faultMarshalers		do: [ :partBinding |  			fmarshaler := partBinding partMarshalers first typeMarshaler. 			fmarshaler smalltalkClassName ~= 'Struct' ifTrue: [ excNames add: fmarshaler smalltalkClass ]].	^excNames</body><body package="WSDLBinding">headerExceptions	| exceptions |	exceptions := OrderedCollection new.	self inputHeaderBindings, self outputHeaderBindings do: [ :header | 		header faults ifNotNil: [ 			header faults do: [ :fault | fault smalltalkClass ifNotNil: [ exceptions add: fault smalltalkClass ]]]].	^exceptions</body><body package="WSDLBinding">headerPartMarshalers 	^self inputHeaderBindings collect: [ :hbinding | hbinding partMarshaler ]</body><body package="WSDLBinding">marshalerForTag: anXMLNode 	^(XMLObjectBinding 		typeMarshalerForTag: anXMLNode  		ifAbsent: [self error: ((#CantFindMarshalerFor &lt;&lt; #webservices &gt;&gt; 'Can not find marshaler for &lt;1s&gt;')							expandMacrosWith: anXMLNode printString)]) .</body><body package="WSDLBinding">marshalerForTag: anXMLNode type: aSymbol	| error marshalers |	error :=  [self error: ((#CantFindMarshalerFor &lt;&lt; #webservices &gt;&gt; 'Can not find marshaler for &lt;1s&gt;') 	expandMacrosWith: anXMLNode printString)].	marshalers := XMLObjectBinding findMarshalersLike: anXMLNode  ifAbsent: error.	^marshalers detect: [ :mx | mx symbolSpace = aSymbol ] ifNone: error</body><body package="WSDLBinding">printWsdlClientScriptDocOn: aStream marshalers: marshalers	| parameters |	parameters := marshalers.	marshalers size = 1 		ifTrue: [marshalers first typeMarshaler isSimpleType				ifTrue: [aStream nextPutAll: 'args := Array with: '.						marshalers first typeMarshaler printArgsOn: aStream indentation: 0.						^aStream nextPut: $.]					ifFalse: [parameters :=  marshalers first typeMarshaler relations ]].	aStream 		nextPutAll: 'struct := WebServices.Struct new.'; crtab;		nextPutAll: 'args := Array with: struct.'; crtab;		nextPutAll: 'struct'.	parameters do: [ :m |		aStream 			crtab: 2; 			nextPutAll: 'at: ', m tag type asSymbol printString, ' put: ('. 		m printArgsOn: aStream indentation: 2.		aStream nextPutAll: ');' ].</body><body package="WSDLBinding">printWsdlClientScriptOn: aStream marshalers: marshalers	self  isDocument		ifTrue: [self printWsdlClientScriptDocOn: aStream marshalers: marshalers ]		ifFalse: [self printWsdlClientScriptRpcOn: aStream marshalers: marshalers ].</body><body package="WSDLBinding">printWsdlClientScriptRpcOn: aStream marshalers: marshalers	| m |	aStream 			nextPutAll: 'args := Array new: ', marshalers size printString, '.';			crtab; 			nextPutAll: 'args'.	1 to: marshalers size 		do: [ :ind |			m := marshalers at: ind.			aStream crtab; nextPutAll: 'at: ', ind printString, ' put: ('.			m printArgsOn: aStream indentation: 1.			aStream nextPutAll: ');']</body><body package="WSDLBinding">returnMarshaler	| part m  objMarshaler  interfaceDescriptor |	interfaceDescriptor := self descriptor interfaceDescriptor.	interfaceDescriptor output ifNil: [^nil ].	1 to: interfaceDescriptor output value parts size 		do: [ :ind |			part := interfaceDescriptor output value parts at: ind. 			part type ifNotNil:				[m :=  self marshalerForTag:  part type type: (part elementName ifNotNil: [#element] ifNil: [#type]). 				( interfaceDescriptor parameterOrder includes: part name type )					ifTrue: [objMarshaler := m typeMarshaler ]					ifFalse: 	[( self isRpc 								or: [m typeMarshaler isSimpleType or: [m typeMarshaler isObjectType]])									ifTrue: [objMarshaler := m typeMarshaler.]									ifFalse:	[m typeMarshaler relations notEmpty												ifTrue: [objMarshaler := m typeMarshaler relations first typeMarshaler. ]]]]].	^objMarshaler</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>private</category><body package="WSDLBinding">validateHeaders: soapHeader with: headerBindings	headerBindings ifNil: [^nil].	headerBindings do: [ :headerBinding | 		headerBinding partMarshaler isMandatory ifTrue: [			soapHeader ifNil: [ MissingRequiredHeader raiseErrorString: (#ThereisNoRequiredSoapHeaderForMessage &lt;&lt; #webservices &gt;&gt;'There is no required SoapHeader for the message' )].			soapHeader headerAt: headerBinding headerTag type ifAbsent: [ MissingRequiredHeader raiseErrorString: (#MissingRequiredHeaderEntry &lt;&lt; #webservices &gt;&gt;'The SoapHeader is missing required header entry: &lt;1s&gt; ' expandMacrosWith: headerBinding headerTag type )]] ].</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding class</class-id> <category>default</category><body package="WSDLBinding">defaultUseOldDocStyleInvocation	^defaultUseOldDocStyleInvocation ifNil: [ self defaultUseOldDocStyleInvocationValue ]</body><body package="WSDLBinding">defaultUseOldDocStyleInvocation: aBoolean	^defaultUseOldDocStyleInvocation := aBoolean</body><body package="WSDLBinding">defaultUseOldDocStyleInvocationValue	^false</body><body package="WSDLBinding">usePart1InSelector	^usePart1InSelector ifNil: [ usePart1InSelector := self usePart1InSelectorValue ]</body><body package="WSDLBinding">usePart1InSelector: aBoolean	usePart1InSelector := aBoolean</body><body package="WSDLBinding">usePart1InSelectorValue	^false</body><body package="WSDLBinding">wrapDocumentLiteralResult	wrapDocumentLiteralResult ifNil: [ wrapDocumentLiteralResult := self wrapDocumentLiteralResultValue ].	^wrapDocumentLiteralResult</body><body package="WSDLBinding">wrapDocumentLiteralResult: aBoolean	wrapDocumentLiteralResult := aBoolean</body><body package="WSDLBinding">wrapDocumentLiteralResultValue	^false</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding class</class-id> <category>private</category><body package="WSDLBinding">setUsePart1InSelector	^self usePart1InSelector printString asSymbol</body><body package="WSDLBinding">setUsePart1InSelector: aSymbol	self usePart1InSelector: (aSymbol = #true).</body><body package="WSDLBinding">usePart1InSelectorValueSymbol	^self usePart1InSelectorValue printString asSymbol</body></methods><methods><class-id>WebServices.RPCReturnEncoder</class-id> <category>api -- unmarshal</category><body package="SOAPBinding">canAcceptNode: aNodeTag		^aNodeTag tag namespace = 'http://www.w3.org/2003/05/soap-rpc'		and: [aNodeTag tag type = 'return' ]</body><body package="SOAPBinding">decodeAndUnmarshalFrom: marshalingContext do: aBlock</body><body package="SOAPBinding">unmarshalObjectFrom: marshalingContext  do: aBlock	| value |	value := BindingBuilder decodeQName: marshalingContext.	marshalingContext value: value.	aBlock value: marshalingContext</body></methods><methods><class-id>WebServices.RPCReturnEncoder</class-id> <category>printing</category><body package="SOAPBinding">printArgsOn: stream indentation: number</body></methods><methods><class-id>WebServices.RPCReturnEncoder</class-id> <category>initialization</category><body package="SOAPBinding">fromTag: aNode	tag := aNode.	relation := OneRelation new.	relation name: 'return'.</body></methods><methods><class-id>WebServices.RPCReturnEncoder</class-id> <category>api -- marshal</category><body package="SOAPBinding">marshalFrom: marshalingContext "&lt;m:chargeReservationResponse xmlns:rpc='http://www.w3.org/2003/05/soap-rpc' xmlns:m='http://travelcompany.example.org/'&gt;       &lt;rpc:result&gt;m:status&lt;/rpc:result&gt;       &lt;m:status&gt;confirmed&lt;/m:status&gt; "	| node  qualifier |	qualifier := (marshalingContext manager getExistingQualifierFor: SoapBinding soap12_rpc_uri ) ifNil: ['rpc'].	node := Element tag: (NodeTag new qualifier: qualifier ns: SoapBinding soap12_rpc_uri type: 'return').	node namespaceAt: qualifier put: SoapBinding soap12_rpc_uri.	node addNode:  (XML.Text text: (  (marshalingContext manager getExistingQualifierFor:  self tag namespace), ':', self tag type)).	marshalingContext addNode: node.	(marshalingContext manager getExistingQualifierFor: SoapBinding soap12_uri)		ifNotNil: [ :q | node parent addAttribute: ( XML.Attribute name: q, ':', 'encodingStyle' value: SoapBinding soap12_encoding_uri)]</body></methods><methods><class-id>WebServices.RPCReturnEncoder class</class-id> <category>instance creation</category><body package="SOAPBinding">fromTag: aNode	^self new		fromTag: aNode;		yourself</body></methods><methods><class-id>WebServices.SoapHeader</class-id> <category>accessing</category><body package="SOAPBinding">add: anObjectOrCollection	(anObjectOrCollection isKindOf: Collection)		ifTrue: [anObjectOrCollection do: [ :each | self addEntry: each]]		ifFalse: [self  addEntry: anObjectOrCollection ]</body><body package="SOAPBinding">addEntry: aHeaderEntry	headerEntries  add: aHeaderEntry.	^aHeaderEntry</body><body package="SOAPBinding">detect: aBlock1 ifNone: aBlock2	^self headerEntries detect: aBlock1 ifNone: aBlock2</body><body package="SOAPBinding">headerAt: aStringOrNodeTag ifAbsent: aBlock	^aStringOrNodeTag isString 		ifTrue: [self headerEntries detect: [ :entry | entry name type = aStringOrNodeTag asString ] ifNone: aBlock]		ifFalse: [ self headerEntries detect: [ :entry | entry name = aStringOrNodeTag ] ifNone: aBlock]</body><body package="SOAPBinding">headerAt: aStringOrNodeTag ifAbsentPut: aBlock	^self 		headerAt: aStringOrNodeTag 		ifAbsent: [ self addEntry: aBlock value ]</body><body package="SOAPBinding">headerAt: aString put: aHeaderEntry	aHeaderEntry name ifNil: [aHeaderEntry name: aString].	^self addEntry: aHeaderEntry</body><body package="SOAPBinding">headerEntries	^headerEntries</body><body package="SOAPBinding">headerEntries: aCollection	headerEntries := aCollection</body><body package="SOAPBinding">keysAndValuesDo: aBlock	self headerEntries do: [ :entry | aBlock value: entry name value: entry ]</body><body package="SOAPBinding">remove: aHeaderEntry	| entry |	entry := self headerAt: aHeaderEntry name ifAbsent: [^nil].	headerEntries remove: entry.</body><body package="SOAPBinding">removeKey: aSymbol ifAbsent: aBlock	| entry |	entry := self headerAt: aSymbol ifAbsent: [^aBlock value].	self headerEntries remove: entry.</body><body package="SOAPBinding">size 	^self headerEntries size</body></methods><methods><class-id>WebServices.SoapHeader</class-id> <category>initialize-release</category><body package="SOAPBinding">initialize	headerEntries := OrderedCollection new.</body></methods><methods><class-id>WebServices.SoapHeader</class-id> <category>testing</category><body package="SOAPBinding">isEmpty	^self headerEntries isEmpty</body><body package="SOAPBinding">notEmpty	^self isEmpty not</body></methods><methods><class-id>WebServices.SoapHeader</class-id> <category>printing</category><body package="SOAPBinding">printOn: aStream	aStream nextPutAll: 'SoapHeader entries: '.	headerEntries printOn: aStream</body></methods><methods><class-id>WebServices.SoapHeader class</class-id> <category>instance creation</category><body package="SOAPBinding">new	^super new initialize</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderBinding</class-id> <category>accessing</category><body package="WSDLBinding">entryMarshaler	^entryMarshaler</body><body package="WSDLBinding">entryMarshaler: anObject	entryMarshaler := anObject</body><body package="WSDLBinding">excMarshalerClasses	^excMarshalers notNil		ifTrue: [ excMarshalers keys collect: [ :cl | cl ]]		ifFalse: [ OrderedCollection new ].</body><body package="WSDLBinding">excMarshalers	^excMarshalers</body><body package="WSDLBinding">faultMarshalerForObject: aClass ifAbsent: aBlock	^excMarshalers		ifNil: aBlock		ifNotNil: [ :marshalers | marshalers at: aClass ifAbsent: aBlock ]</body><body package="WSDLBinding">faultTags	^faultTags</body><body package="WSDLBinding">faults	^faults</body><body package="WSDLBinding">faults: aColl	faults := aColl</body><body package="WSDLBinding">getSelector	^self partMarshalers first relation getSelector asSymbol</body><body package="WSDLBinding">headerTag	| tag |	tag := self partMarshalers first path.	(tag namespace isNil or: [tag namespace isEmpty ]) ifTrue: [  tag resetNamespaceTo: self namespace].	^tags first</body><body package="WSDLBinding">marshalers	| coll |	coll := self partMarshalers.	self faults ifNotNil: [ 	self faults do: [ :m | coll addAll: m marshalers ]].	^coll</body><body package="WSDLBinding">valueMarshaler	^self partMarshalers first typeMarshaler valueMarshaler</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderBinding</class-id> <category>api -- builder</category><body package="WSDLBinding">asPartMarshalersFrom: sortedAssocList binding: binding	sortedAssocList isEmpty ifTrue: 	[self error: ( #CannotResolveSoapHeaderParts &lt;&lt; #webservices &gt;&gt; 'Can not resolve Soap header parts') ].	partMarshalers := OrderedCollection new.	sortedAssocList do: [ :assoc | 		structMarshaler addElementMarshaler: (self buildHeaderEntryMarshalerFrom: assoc binding: binding) ].</body><body package="WSDLBinding">buildFaultMarshalersFor: message operation: operation from: headerDescriptor binding: binding"http://www.w3.org/TR/wsdl#_soap:headerThe use, encodingStyle and namespace attributes are all used in the same way as with soap:body only style='document' is assumed since headers do not contain parameters."	| faultBinding mx |	excMarshalers := Dictionary new. 	self faults: 		(headerDescriptor faults collect:			[ :faultDescriptor | 			faultBinding := SoapWsdl11HeaderFaultBinding new. 			faultBinding style: self style.			faultBinding entryMarshaler: entryMarshaler.			faultBinding				buildMarshalerFor: faultDescriptor message 				operation: operation 				from: faultDescriptor 				binding: binding. 			(mx := faultBinding partMarshaler relationMarshaler valueMarshaler) isComplexTypeMarshaler				ifTrue: [excMarshalers at: mx smalltalkClass put: faultBinding partMarshaler tag type -&gt;faultBinding partMarshalers ].			faultBinding ])</body><body package="WSDLBinding">buildHeaderEntryMarshalerFrom: anAssociation binding: binding	| headerMarshaler node |	"Header entry marshaler is already built and register in the binding "	(binding headerMarshalerFor: anAssociation value tag)		ifNotNil: [ :hMarshaler| partMarshalers add: hMarshaler.  ^hMarshaler].	node := self isRpc		ifTrue: [ namespace ifNil: [namespace := structName namespace].				 NodeTag qualifier: '' ns: self namespace type: anAssociation key type ]		ifFalse: [ anAssociation value tag  ].	(headerMarshaler := RelationMarshaler new) 		buildFromTag: node 		marshaler: anAssociation  value 		headerEntryMarshaler: self entryMarshaler.	self class headersBeOptional		ifTrue: [ headerMarshaler beOptional ]		ifFalse: [ headerMarshaler beMandatory].	self setEncodingStyleFor: headerMarshaler.	partMarshalers add: headerMarshaler.	binding addHeaderMarshaler: headerMarshaler.	^headerMarshaler.</body><body package="WSDLBinding">buildHeaderMarshalerFor: message operation: operation from: headerDescriptor binding: binding"http://www.w3.org/TR/wsdl#_soap:headerThe use, encodingStyle and namespace attributes are all used in the same way as with soap:body only style='document' is assumed since headers do not contain parameters."	self 		buildMarshalerFor: message 		operation: operation 		from: headerDescriptor 		binding: binding.	headerDescriptor faults notEmpty		ifTrue: 			[self 				buildFaultMarshalersFor: message				operation: operation 				from: headerDescriptor 				binding: binding ].	tags := OrderedCollection new.	tags add: self partMarshalers first tag.	faultTags := OrderedCollection new. 	self faults ifNotNil: [self faults do: [ :fx | faultTags add: fx headerTag ]].</body><body package="WSDLBinding">buildPartMarshalersFrom: assocList order: parameterOrderx binding: binding	partNames := assocList collect: [ :assoc | assoc key type asSymbol].	self asPartMarshalersFrom: assocList binding: binding.</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderBinding class</class-id> <category>defaults</category><body package="WSDLBinding">defaultHeadersBeOptional 	^false</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderBinding class</class-id> <category>accessing</category><body package="WSDLBinding">headersBeOptional	^HeadersBeOptional ifNil: [ self defaultHeadersBeOptional ]</body><body package="WSDLBinding">headersBeOptional: aBoolean	HeadersBeOptional := aBoolean</body></methods><methods><class-id>WebServices.FaultSubcode</class-id> <category>accessing</category><body package="SOAPBinding">subcode	^subcode</body><body package="SOAPBinding">subcode: aFaultSubcode	subcode := aFaultSubcode</body><body package="SOAPBinding">value	^value</body><body package="SOAPBinding">value: aNodeTag	value := aNodeTag</body></methods><methods><class-id>WebServices.SoapWsdl20FaultBinding</class-id> <category>accessing</category><body package="WSDLBinding">code	^code</body><body package="WSDLBinding">code: aNodeTag	code := aNodeTag</body><body package="WSDLBinding">name	^name</body><body package="WSDLBinding">name: anObject	name := anObject</body><body package="WSDLBinding">subcodes	^subcodes</body><body package="WSDLBinding">subcodes: collectionOfNodeTag	subcodes := collectionOfNodeTag</body></methods><methods><class-id>WebServices.SoapWsdl20FaultBinding</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream nextPutAll: self class name.	name ifNotNil: [		aStream 			nextPutAll: ' name=';			nextPutAll: name asString].</body></methods><methods><class-id>WebServices.SoapWsdl20FaultBinding</class-id> <category>api -- builder</category><body package="WSDLBinding">buildMarshalerFrom: faultMessage bindingFaults: faults binding: binding	partMarshalers := OrderedCollection new.	name := faultMessage at: #name ifAbsent: [nil].	self resolveElementNodeFrom: faultMessage  binding: binding.	( faults detect: [ :each | each name  =  name ] ifNone: [nil]) ifNotNil: 		[ :bindingFaultDescription | 		code := bindingFaultDescription soapFaultCode.		subcodes := bindingFaultDescription soapFaultSubcode.		bindingFaultDescription soapHeaders 			ifNotNil: [ :headerDescriptors | self buildHeaderMarshalersFrom: headerDescriptors binding: binding ]].</body></methods><methods><class-id>WebServices.MissingRequiredHeader class</class-id> <category>testing</category><body package="SOAPBinding">mayResume	^false</body></methods><methods><class-id>WebServices.UpgradeHeaderEntry</class-id> <category>accessing</category><body package="SOAPBinding">name	^'Upgrade'</body><body package="SOAPBinding">supportedEnvelopes	^supportedEnvelopes</body><body package="SOAPBinding">supportedEnvelopes: anObject	supportedEnvelopes := anObject</body></methods><methods><class-id>WebServices.UpgradeHeaderEntry</class-id> <category>printing</category><body package="SOAPBinding">printOn: aStream	aStream nextPutAll: self class name.	supportedEnvelopes ifNotNil: 		[aStream nextPutAll: ' Supported envelopes: '.		supportedEnvelopes printOn: aStream ]</body></methods><methods><class-id>WebServices.UpgradeHeaderEntry class</class-id> <category>instance creation</category><body package="SOAPBinding">supportedEnvelopes		^self new 		supportedEnvelopes: (SoapBinding supportedSoapVersions collect: [ : version | Struct new qname: (NodeTag new qualifier: '' ns: version type: 'Envelope' ) ]) asOrderedCollection; 		yourself</body></methods><methods><class-id>WebServices.Wsdl11BindingDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">binding11Type	^bindingType name type = 'binding11Type'		ifTrue: [ bindingType ]		ifFalse: [nil]</body><body package="WSDLDescriptors">binding12Type	^bindingType name type = 'binding12Type'		ifTrue: [ bindingType ]		ifFalse: [nil]</body><body package="WSDLDescriptors">bindingTransport	| transportName |	transportName := ( self bindingType at: #transportName ifAbsent: [WsdlParsingErrors raiseRequestErrorString: (#MissingRequiredAttributeTransportName &lt;&lt; #webservices &gt;&gt; 'Missing required attribute: transportName ')]).	^self  perform: 		(self class transports			at: transportName			ifAbsent: [WsdlParsingErrors raiseRequestErrorString: ((#UnknownTransport1s &lt;&lt; #webservices &gt;&gt; 'Unknown transport: &lt;1s&gt;') expandMacrosWith: transportName)])</body><body package="WSDLDescriptors">bindingType	^bindingType</body><body package="WSDLDescriptors">bindingType: aValue	bindingType := aValue</body><body package="WSDLDescriptors">configurationDescriptorClass	^Wsdl11ConfigurationDescriptor</body><body package="WSDLDescriptors">getBindingType	^bindingType ifNil: [bindingType := Struct new].</body><body package="WSDLDescriptors">soapHttpTransport	^soapTransportBinding ifNil: [		soapTransportBinding :=  (self bindingType name type = 'binding11Type'				ifTrue: [SoapWsdl11HttpBinding]				ifFalse: [Soap12Wsdl11HttpBinding]) default ]</body><body package="WSDLDescriptors">style	^self bindingType at: #style ifAbsent: [ self class defaultStyle]</body></methods><methods><class-id>WebServices.Wsdl11BindingDescriptor</class-id> <category>accessing http attributes</category><body package="WSDLDescriptors">getSoapHttpBindingSpec" is used in #wsdl11Specification"	^(soapTransportBinding notNil and: [soapTransportBinding verb = 'POST' ])		ifTrue: [nil ]		ifFalse: [soapTransportBinding]</body><body package="WSDLDescriptors">soapHttpBindingSpec" is used in #wsdl11Specification"	^soapTransportBinding</body><body package="WSDLDescriptors">soapHttpBindingSpec: aSoap11HttpBinding" is used in #wsdl11HttpBindingSpecification"	soapTransportBinding := aSoap11HttpBinding</body></methods><methods><class-id>WebServices.Wsdl11BindingDescriptor class</class-id> <category>accessing</category><body package="WSDLDescriptors">defaultStyle	^#document</body><body package="WSDLDescriptors">transports	^Dictionary new		at: 'http://schemas.xmlsoap.org/soap/http/' put: #soapHttpTransport;		at: WsdlBinding wsdl11_soap_http_uri  put: #soapHttpTransport;		yourself</body></methods><methods><class-id>WebServices.NotUnderstoodHeaderEntry</class-id> <category>accessing</category><body package="SOAPBinding">name	^'NotUnderstood'</body><body package="SOAPBinding">qname	^qname</body><body package="SOAPBinding">qname: anObject	qname := anObject</body></methods><methods><class-id>WebServices.NotUnderstoodHeaderEntry class</class-id> <category>instance creation</category><body package="SOAPBinding">qname: aNode	^self new		qname: aNode;		yourself</body></methods><methods><class-id>WebServices.Wsdl11ServiceDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">configurationDescriptorClass	^Wsdl11ConfigurationDescriptor</body><body package="WSDLDescriptors">getPorts	^ports</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">ports	^ports</body></methods><methods><class-id>WebServices.Wsdl11ServiceDescriptor</class-id> <category>initialize-release</category><body package="WSDLDescriptors">addPort: aPortDescriptor	^self ports add: aPortDescriptor</body><body package="WSDLDescriptors">name: aValue	name := aValue</body><body package="WSDLDescriptors">ports: aValue	ports := aValue</body></methods><methods><class-id>WebServices.Wsdl11ServiceDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	super printOn: aStream.	name ifNotNil: [aStream nextPutAll: ' name: ', name printString]</body></methods><methods><class-id>WebServices.Wsdl20ServiceDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">configurationDescriptorClass	^Wsdl20ConfigurationDescriptor</body><body package="WSDLDescriptors">endpoints	^self ports</body><body package="WSDLDescriptors">interface	^interface</body></methods><methods><class-id>WebServices.Wsdl20ServiceDescriptor</class-id> <category>initialize-release</category><body package="WSDLDescriptors">endpoints: aValue	self ports: aValue</body><body package="WSDLDescriptors">interface: anObject	interface := anObject</body></methods><methods><class-id>WebServices.WsdlEndpointDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addressString	^address</body><body package="WSDLDescriptors">addressString: aString	address := aString</body><body package="WSDLDescriptors">authenticationRealm	^authenticationRealm</body><body package="WSDLDescriptors">authenticationRealm: anObject	authenticationRealm := anObject</body><body package="WSDLDescriptors">authenticationScheme	^authenticationScheme</body><body package="WSDLDescriptors">authenticationScheme: anObject	authenticationScheme := anObject</body></methods><methods><class-id>WebServices.WsdlEndpointDescriptor</class-id> <category>initialize-release</category><body package="WSDLDescriptors">initialize	version := '1.2'</body></methods><methods><class-id>WebServices.WsdlSchemaLoader</class-id> <category>accessing</category><body package="WSDLBinding">bindDocuments	^bindDocuments</body><body package="WSDLBinding">bindDocuments: aOrderedCollection	bindDocuments := aOrderedCollection</body><body package="WSDLBinding">documents	^documents</body><body package="WSDLBinding">documents: aOrderedCollection	documents := aOrderedCollection</body><body package="WSDLBinding">parser	^parser</body><body package="WSDLBinding">schemaBindings	^self bindDocuments detect: [ :doc | doc root tag type = 'schemaBindings' ] ifNone: [ nil]</body><body package="WSDLBinding">wsdlServiceDoc	^wsdlServiceDoc</body></methods><methods><class-id>WebServices.WsdlSchemaLoader</class-id> <category>initialization</category><body package="WSDLBinding">initialize	documents := OrderedCollection new: 5.	bindDocuments := OrderedCollection new: 5.</body><body package="WSDLBinding">setXMLTypesParser: anXMLTypesParser	parser := anXMLTypesParser.	bindDocuments add: parser schemaBindings parent.</body><body package="WSDLBinding">useDefaultBinding	self setXMLTypesParser:  XMLTypesParser defaultBinding</body><body package="WSDLBinding">useObjectBinding	^self  useObjectBindingInNamespace: XMLObjectBindingPolicy defaultClassNamespace</body><body package="WSDLBinding">useObjectBindingInNamespace: aString	self  setXMLTypesParser:  (XMLTypesParser objectBindingInNamespace: aString)</body></methods><methods><class-id>WebServices.WsdlSchemaLoader</class-id> <category>import</category><body package="WSDLBinding">loadImportElement: importElem parentUrl: url ns: nsString 	| impUrl  |	impUrl := importElem  valueOfAttribute: 'location' ifAbsent: [^nil].	(url isKindOf: Stream) ifTrue: [ ^self error: (#CanNotResolveURI &lt;&lt; #webservices &gt;&gt; 'Can not resolve URI') ].	self loadXMLDocuments: url asURI, impUrl.</body><body package="WSDLBinding">loadImportElements:  anElement url: url	| xpath |	xpath := XPathParser new				xmlNode: anElement;				parse: 'child::import' as: #locationPath.	(xpath xpathValueFor: anElement  variables: nil) 		sortedNodes do: 			[ :el | 			self 				loadImportElement: el  				parentUrl: url 				ns:  anElement targetNamespace]</body></methods><methods><class-id>WebServices.WsdlSchemaLoader</class-id> <category>loading schema</category><body package="WSDLBinding">loadDocumentFrom:  urlOrStream	| doc  xmlParser|	xmlParser := XMLParser  on: urlOrStream.	[doc := xmlParser validate: false; scanDocument.	] 		on: XML.MalformedSignal		do:  [ :ex | 			ex errorString: ((#ErrorParsingXMLDoc &lt;&lt; #webservices &gt;&gt; 'Error parsing XML document: &lt;1s&gt;') expandMacrosWith: ex errorString).			ex parameter: xmlParser sourceWrapper stream contents.			ex pass ].	self documents addFirst: doc.	(wsdlServiceDoc isNil and: [ doc root tag type = 'definitions' ]) 		ifTrue: [ wsdlServiceDoc := doc ].	^doc</body><body package="WSDLBinding">loadFrom: aDataSource 	"The dataSource may be a URI, a Filename (or a String	which will be treated as a Filename), or an InputSource."	[baseURI := aDataSource asURI] on: Error do: [:ex | ].	Cursor wait showWhile: [self loadXMLDocuments: aDataSource  ].	(self parser notNil and: [ self parser schemaBindings realElements isEmpty ])		ifTrue: [ self bindDocuments remove: self parser schemaBindings parent ifAbsent: []].	^self bindDocuments</body><body package="WSDLBinding">loadXMLDocuments: aDataSource 	| dom |	dom := self loadDocumentFrom: aDataSource.	(dom root tag type = 'definitions'		or: [dom root tag type = 'description'			or: [dom root tag type = 'schemaBindings' ]]) 		ifTrue: [ self bindDocuments add: dom].	self loadImportElements: dom root url: aDataSource.	self addX2OBindingFor: dom</body></methods><methods><class-id>WebServices.WsdlSchemaLoader</class-id> <category>binding</category><body package="WSDLBinding">addX2OBindingFor: aDocument" Check if we have &lt;schemaBinding&gt; section and create binding if we need it " 	self parser ifNil: [ ^nil ].	(self needX2OBinding: aDocument) 		ifTrue: [self parser 					baseURI: baseURI;					readFrom: aDocument].</body><body package="WSDLBinding">needX2OBinding: aDocument	" Check if we have &lt;schemaBindings&gt; element "	| xpath nodes |	xpath := XPathParser new 				parse: 'schemaBindings' as: #locationPath.	(xpath xpathValueFor: aDocument root variables: nil) sortedNodes notEmpty		ifTrue: [^false].	xpath := XPathParser new 				parse: 'descendant-or-self::*[self::types or self::schema]' as: #locationPath.	(nodes := (xpath xpathValueFor: aDocument root variables: nil) sortedNodes) notEmpty		ifTrue: 			[ ^(nodes detect: [ :n | n realElements size &gt; 0] ifNone: [nil]) notNil ].		^false</body></methods><methods><class-id>WebServices.WsdlSchemaLoader class</class-id> <category>instance creation</category><body package="WSDLBinding">defaultReadFrom: aDataSource"The dataSource may be a URI, a Filename (or a String which will be treated as a Filename), or an InputSource.Loads a Wsdl schema and creates default binding"	^self new 		useDefaultBinding;		loadFrom: aDataSource</body><body package="WSDLBinding">new	^super new initialize</body><body package="WSDLBinding">objectReadFrom: aDataSource	^self new		useObjectBinding;		loadFrom: aDataSource</body><body package="WSDLBinding">objectReadFrom: aDataSource inNamespace: aString"The dataSource may be a URI, a Filename (or a String which will be treated as a Filename), or an InputSource.Loads a Wsdl schema and creates object binding"	^self new 		useObjectBindingInNamespace: aString;		loadFrom: aDataSource</body><body package="WSDLBinding">readFrom: aStream	^self defaultReadFrom: aStream</body><body package="WSDLBinding">url: url	^self readFrom:  url asURI</body></methods><methods><class-id>WebServices.Wsdl11MessagePartDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">elementName	^elementName</body><body package="WSDLDescriptors">elementName: aValue	elementName := aValue</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aValue	name := aValue</body><body package="WSDLDescriptors">stringName	^self name asString</body><body package="WSDLDescriptors">type	^self elementName notNil		ifTrue: [self  elementName]		ifFalse: [self  typeName ].</body><body package="WSDLDescriptors">type: anAssociation	anAssociation key = 'type'		ifTrue: [ self typeName: anAssociation value]		ifFalse: [ self elementName: anAssociation value]</body><body package="WSDLDescriptors">typeAttribute	^self elementName notNil		ifTrue: ['element']		ifFalse: ['type' ].</body><body package="WSDLDescriptors">typeName	^typeName</body><body package="WSDLDescriptors">typeName: aValue	typeName := aValue</body></methods><methods><class-id>WebServices.Wsdl11MessagePartDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	name ifNil: [ ^super printOn: aStream].	aStream nextPutAll: '&lt;part '.	name ifNotNil: [aStream nextPutAll: ' name="', name type, '"' ].	typeName ifNotNil: [aStream nextPutAll: ' type="', typeName asString, '"' ].	elementName ifNotNil: [aStream nextPutAll: ' element="', elementName asString, '"' ].	aStream nextPutAll: '&gt;&lt;/part&gt; '.</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>parsing</category><body package="WSDLDescriptors">resolveExtendedInterfaces	self interfaces do: [ :interface | 		interface extends ifNotNil: [ :qnames |			interface extends: ( self interfaces select: [ :int | qnames anySatisfy: [ :node | int name = node ] ]) ]]</body><body package="WSDLDescriptors">setBindingInterfaceDescriptor	| interfaceDescriptor bindingDescriptor |	super setBindingInterfaceDescriptor.	self resolveExtendedInterfaces.	self services isEmpty ifTrue: [ ^WsdlParsingErrors raiseRequestErrorString: (#ThereIsNoServiceDescriptionForWSDL &lt;&lt; #webservices &gt;&gt; 'There is no &lt;service&gt; description in WSDL')].	self services do: [ :service | 		interfaceDescriptor := self  interfaces 				detect: [ :each | each name = service interface ] 				ifNone: [ ^WsdlParsingErrors raiseRequestErrorString: (#ThereIsNoInterfaceDescriptorForService &lt;&lt; #webservices &gt;&gt; 'There is no interface descriptor for the service')].		service endpoints do: [ :endpoint | 			bindingDescriptor := self  bindings 				detect: [ :each | each name = endpoint binding ] 				ifNone: [ ^WsdlParsingErrors raiseRequestErrorString: (#ThereIsNoEndpointBindingDescriptorForService &lt;&lt; #webservices &gt;&gt; 'There is no endpoint binding descriptor')].			self validateInterfaceDescription: interfaceDescriptor for: bindingDescriptor. ]].</body><body package="WSDLDescriptors">validateInterfaceDescription: interfaceDescription for: bindingDescription	bindingDescription interfaceDescriptor 		ifNil: ["reusable binding"			"If a Binding component specifies any operation-specific binding details (by including Binding Operation components) or any fault binding details (by including Binding Fault  components), then it MUST specify an interface the Binding component applies to, so as to indicate which interface the operations come from."			(bindingDescription operations size ~= 0 or: [bindingDescription faults size ~= 0])				ifTrue:  [ ^WsdlParsingErrors raiseRequestErrorString: ((#BindingComponentSpecifiesOperationWithoutInterface1s &lt;&lt; #webservices &gt;&gt; 'The binding component &lt;1s&gt; specifies operation/fault specific binding details but the interface component is not specified.') expandMacrosWith: bindingDescription name printString )] ].	bindingDescription interfaceDescriptor: interfaceDescription.</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">configurationBuilderClass	^Wsdl20Configuration</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>wsdl schema</category><body package="WSDLDescriptors">portNodes	^self asWsdl realElements collect: [ :each | each tag type = 'interface' ]</body><body package="WSDLDescriptors">serviceInterfaceNodes	^self portNodes</body><body package="WSDLDescriptors">wsdlTargetNamespace	^'http://www.w3.org/ns/wsdl'</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor class</class-id> <category>accessing</category><body package="WSDLDescriptors">bindingUrl	^WsdlBinding wsdl20_uri</body><body package="WSDLDescriptors">manager	| manager |	manager := SoapMarshalingManager on: WsdlBinding wsdl20Binding.	manager qualifierMap		at: 'http://www.w3.org/ns/wsdl' put: '';		at: 'http://www.w3.org/2001/XMLSchema' put: 'xsd';		at: 'http://www.w3.org/ns/wsdl' put:  'wsdl' ;    		at: 'http://www.w3.org/ns/wsdl/soap' put:  'wsoap';		at: 'http://www.w3.org/ns/wsdl/http' put:  'whttp'.	^manager</body></methods><methods><class-id>WebServices.WsdlService</class-id> <category>api -- new request</category><body package="WSDLBinding">findOperationFor: aSoapRequest	| operation |	ports do: 		[ :port | (operation := port findOperationFor: aSoapRequest) notNil					ifTrue: [^operation]].	^nil</body></methods><methods><class-id>WebServices.WsdlService</class-id> <category>accessing</category><body package="WSDLBinding">addPort: aWsdlPort	ports isNil ifTrue: [ ports := OrderedCollection new ].	ports add: aWsdlPort.	^aWsdlPort</body><body package="WSDLBinding">endpoint	^self ports first</body><body package="WSDLBinding">endpoints	^self ports</body><body package="WSDLBinding">name	^self serviceDescriptor name</body><body package="WSDLBinding">port	^self ports first</body><body package="WSDLBinding">portAt: uri ifAbsent: aBlock	^ports detect: [ :port | port address = uri ] ifNone: aBlock</body><body package="WSDLBinding">portAtBinding: aNodeTag ifAbsent: aBlock	^ports 		detect: [ :port | port binding name = aNodeTag ]		ifNone: aBlock</body><body package="WSDLBinding">ports	^ports</body><body package="WSDLBinding">serviceDescriptor	^serviceDescriptor</body><body package="WSDLBinding">serviceDescriptor: aWsdlServiceDescriptor	serviceDescriptor := aWsdlServiceDescriptor</body></methods><methods><class-id>WebServices.WsdlService</class-id> <category>initialization</category><body package="WSDLBinding">name: aValue	self serviceDescriptor name: aValue</body><body package="WSDLBinding">ports: aValue	ports := aValue</body></methods><methods><class-id>WebServices.WsdlService</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream 		nextPutAll: ((#ServiceName &lt;&lt; #webservices &gt;&gt; 'WsdlService name=&lt;1s&gt;')					expandMacrosWith: self name) asString.	ports ifNotNil: 			[aStream nextPutAll: (#PortsList &lt;&lt; #webservices &gt;&gt; ' ports =') asString.			aStream print: ports]</body></methods><methods><class-id>WebServices.WsdlService class</class-id> <category>accessing</category><body package="WSDLBinding">portAt: uri binding: wsdlBinding ifAbsent: aBlock	" self 		portAt: 'http://uddi.microsoft.com/inquire' 		binding: WsdlBinding uddiBinding 		ifAbsent: [nil]	"	self registry do: 		[ :service | service ports do: 					[ :port | (port address = uri asURI and: [port binding == wsdlBinding])								ifTrue: [^port]]].	^aBlock value</body><body package="WSDLBinding">register: service	self registry at: service name put: service</body><body package="WSDLBinding">registry	^ServiceRegistry</body><body package="WSDLBinding">serviceAt: aString ifAbsent: aBlock	^self registry at: aString ifAbsent: aBlock</body><body package="WSDLBinding">servicesForBinding: aNodeTag	^self registry values select: [ :serv | serv ports anySatisfy: [ :port | port binding name = aNodeTag]]</body><body package="WSDLBinding">servicesForPorts: aWsdlPorts	| set |	set := Set new.	self registry values 		do: [ :serv | 			serv ports do: [ :px | (aWsdlPorts includes: px) ifTrue: [ set add: serv ]]].	^set</body></methods><methods><class-id>WebServices.WsdlService class</class-id> <category>class initialization</category><body package="WSDLBinding">initialize	self reset</body><body package="WSDLBinding">reset	ServiceRegistry := Dictionary new</body></methods><methods><class-id>WebServices.WsdlService class</class-id> <category>instance creation</category><body package="WSDLBinding">name: aString	^self new 		name: aString; 		yourself</body></methods><methods><class-id>WebServices.Soap12Wsdl11OperationBinding</class-id> <category>marshal response</category><body package="WSDLBinding">raiseAsUserHeaderError: anException		(UserHeader12Error exception: anException ) raise</body></methods><methods><class-id>WebServices.SoapWsdl11HttpBinding</class-id> <category>accessing</category><body package="WSDLBinding">headerEntryClass	^Soap11HeaderEntry</body><body package="WSDLBinding">operationBindingClass			^SoapWsdl11OperationBinding</body><body package="WSDLBinding">soapAction	^self action</body><body package="WSDLBinding">soapAction: aValue	self action: aValue</body><body package="WSDLBinding">soapVersion	^'1.1'</body><body package="WSDLBinding">uri	^'http://schemas.xmlsoap.org/soap/http' asURI</body><body package="WSDLBinding">verb	verb ifNil: [verb := 'POST' ].	^verb</body></methods><methods><class-id>WebServices.SoapWsdl11HttpBinding</class-id> <category>testing</category><body package="WSDLBinding">isSoap11	^true</body></methods><methods><class-id>WebServices.SoapWsdl11HttpBinding</class-id> <category>api -- new request</category><body package="WSDLBinding">soap11ActionFor: aSoapRequest 	^aSoapRequest operation action</body></methods><methods><class-id>WebServices.SoapWsdl11HttpBinding</class-id> <category>marshal faults</category><body package="WSDLBinding">marshalMustUnderstandFault: aFault with: aMarshalers" Marshal MustUnderstandFault object into XML Element "	| envelope |	envelope := self envelope new.	self mustUnderstandFaultString:  aFault.	envelope fault: aFault asSoapFault.	^self manager marshal: envelope with: self soapEnvelopeMarshaler</body><body package="WSDLBinding">marshalSoapFault: aFault with: aMarshaler" Marshal Fault object into XML Element "	| envelope manager  obj  |	envelope := self envelope new. 	envelope fault: aFault.	manager := self manager.	aFault detailContents ifNotNil: [ :contents | | m |		obj := contents first.			m := aMarshaler.		m 			ifNil: [m := XMLObjectBinding simpleMarshalerType: 'string'.				obj := contents first printString.				aFault detailContents: obj  ]			ifNotNil: [m relations do: [ :each | each qualified: true ]].		m qualified: true.		manager register: obj marshalWith: m ].	^manager marshal: envelope with: self soapEnvelopeMarshaler</body><body package="WSDLBinding">marshalUserHeaderError: anUserError with: aAssoc" Marshal UserHeaderFault object into XML Element. aMarshaler is nil means the exception was not described in X2O "	| envelope   |	aAssoc 		ifNil: [^self 			marshalSoapFault: ((Soap11Fault 								faultCode: anUserError faultTag 								faultString: (#HeaderError &lt;&lt; #webservices &gt;&gt;  'Header error: &lt;1s&gt;: &lt;2s&gt;' expandMacrosWith: anUserError detailContentFirst class name with: anUserError detailContentFirst description  ))								detail: nil;								parameter: anUserError parameter;								yourself )					with: nil.].	envelope := self envelope new. 	envelope headerAt: aAssoc key  put:((Soap11HeaderEntry name: aAssoc key ) 										value: anUserError detailContentFirst).		envelope fault: anUserError asSoapFault.	envelope fault detail: nil.	^self manager marshal: envelope with: self soapEnvelopeMarshaler</body></methods><methods><class-id>WebServices.SoapWsdl11HttpBinding class</class-id> <category>instance creation</category><body package="WSDLBinding">verb: verbString soapAction: soapActionString	^self new		verb: verbString;		soapAction: soapActionString;		yourself</body></methods><methods><class-id>WebServices.SoapWsdl11HttpBinding class</class-id> <category>defaults</category><body package="WSDLBinding">findOperationTagFrom: aHttpEntity 	^(aHttpEntity fieldValueAt: 'Soapaction')		ifNotNil: [ :value | |action |				action := value copyFrom: 2 to: value size - 1.				action isEmpty ifTrue: [nil] ifFalse: [action ]]</body></methods><methods><class-id>WebServices.Soap12Wsdl11HttpBinding</class-id> <category>accessing</category><body package="WSDLBinding">headerEntryClass	^Soap12HeaderEntry</body><body package="WSDLBinding">operationBindingClass			^Soap12Wsdl11OperationBinding</body><body package="WSDLBinding">soapVersion	^'1.2'</body></methods><methods><class-id>WebServices.Soap12Wsdl11HttpBinding</class-id> <category>api -- new request</category><body package="WSDLBinding">prepareRequestFor: aSoapRequest 	aSoapRequest transportEntity 		ifNil: [aSoapRequest transportEntity:  self newRequest.			  aSoapRequest transportEntity method: self verb url: aSoapRequest accessPoint].	^self prepareSoap11RequestFor: aSoapRequest</body><body package="WSDLBinding">prepareResponseFor: aSoapRequest 	self prepareTransportEntity: aSoapRequest transportEntity.	^aSoapRequest transportEntity</body></methods><methods><class-id>WebServices.Soap12Wsdl11HttpBinding</class-id> <category>testing</category><body package="WSDLBinding">isSoap11	^false</body><body package="WSDLBinding">isSoap12	^true</body></methods><methods><class-id>WebServices.Soap12Wsdl11HttpBinding</class-id> <category>marshal faults</category><body package="WSDLBinding">marshalUserHeaderError: anUserError with: aTypeMarshaler" Marshal UserHeaderFault object into XML Element. aMarshaler is nil means the exception was not described in X2O "	| envelope   fault |	fault := SenderFault new				faultString: anUserError faultString;				detail:  anUserError detail;				parameter: anUserError parameter;				reason: anUserError reason;				header: anUserError header;				yourself.	aTypeMarshaler ifNil: [^self marshalSoapFault: fault with: nil.].	envelope := self envelope new. 	envelope headerAt: aTypeMarshaler tag  put:((Soap12HeaderEntry name: aTypeMarshaler tag ) 												value: anUserError detailContentFirst).		envelope fault: fault.	envelope fault detail: nil.	^self manager marshal: envelope with: self soapEnvelopeMarshaler</body></methods><methods><class-id>WebServices.SoapMarshalingManager</class-id> <category>api -- marshal</category><body package="SOAPBinding">encodeHrefAttributeFor: aString"Soap 1.1A multi-reference simple or compound value is encoded as an independent element containing a local, unqualified attribute named 'id' and of type 'ID' per the XML Specification [7]. Each accessor to this value is an empty element having a local, unqualified attribute named 'href' and of type 'uri-reference' per the XML Schema Specification [11], with a 'href' attribute value of a URI fragment identifier referencing the corresponding independent element. Soap 1.23.1.5.2 ref Attribute Information ItemThe ref attribute information item has the following Infoset properties:   * A [local name] of ref .   * A [namespace name] of 'http://www.w3.org/2003/05/soap-encoding'The type of the ref attribute information item is xs:IDREF. The value of the ref attribute information item is a reference to a unique identifier defined by an id attribute information item "	^self refTag type = 'href' 		ifTrue: [ super encodeHrefAttributeFor: aString ]		ifFalse: [ Attribute name: (self idRefAttributeName: self refTag) value: aString]</body></methods><methods><class-id>WebServices.SoapMarshalingManager</class-id> <category>initialization</category><body package="SOAPBinding">initializeIdRefNodes	binding ifNil: [^super initializeIdRefNodes].	idTag :=  (binding idTag		ifNotNil: [binding idTag ]		ifNil: [binding isSoap11 ifTrue: [self class idTag11Value] ifFalse: [self class idTag12Value]]).	refTag := (binding refTag		ifNotNil: [binding refTag ]		ifNil: [ binding isSoap11 ifTrue: [self class refTag11Value] ifFalse: [self class refTag12Value ]]).</body></methods><methods><class-id>WebServices.SoapMarshalingManager</class-id> <category>api -- resolving</category><body package="SOAPBinding">refAttributeFrom: anXMLElement"A multi-reference simple or compound value is encoded as an independent element containing a local, unqualified attribute named 'id' and of type 'ID' per the XML Specification [7]. Each accessor to this value is an empty element having a local, unqualified attribute named 'href' and of type 'uri-reference' per the XML Schema Specification [11], with a 'href' attribute value of a URI fragment identifier referencing the corresponding independent element. "	^self refTag type = 'href' 		ifTrue: [super refAttributeFrom: anXMLElement]		ifFalse: [anXMLElement valueOfAttribute: self refTag ifAbsent: [nil]].</body></methods><methods><class-id>WebServices.SoapMarshalingManager class</class-id> <category>default values</category><body package="SOAPBinding">idTag11Value	^self idNodeDefaultValue</body><body package="SOAPBinding">idTag12Value	^NodeTag new qualifier: '' ns:'http://www.w3.org/2003/05/soap-encoding' type: 'id'; yourself</body><body package="SOAPBinding">refTag11Value	^self refNodeDefaultValue</body><body package="SOAPBinding">refTag12Value	^NodeTag new qualifier: '' ns:'http://www.w3.org/2003/05/soap-encoding' type: 'ref'; yourself</body><body package="SOAPBinding">selectStartPartBlock	^selectStartPartBlock ifNil: [self selectStartPartBlockDefault ]</body><body package="SOAPBinding">selectStartPartBlock: aBlock	selectStartPartBlock := aBlock</body><body package="SOAPBinding">selectStartPartBlockDefault"The methods finds the Soap message main part based on the spec:http://www.w3.org/TR/SOAP-attachments#SOAPMultipartA SOAP message package is constructed using the Multipart/Related media type, which is defined in RFC 2387. The rules for the construction of SOAP message packages are as follows:    The primary SOAP 1.1 message must be carried in the root body part of the Multipart/Related structure. Consequently the type parameter of the Multipart/Related media header will always equal the Content-Type header for the primary SOAP 1.1 message, i.e., text/xml.    Referenced MIME parts must contain either a Content-ID MIME header structured in accordance with RFC 2045, or a Content-Location MIME header structured in accordance with RFC 2557. "	^[ :httpEntity |		((httpEntity fieldValueAt: 'content-type') first paramAt: 'start')			ifNotNil: [ :start | 				httpEntity parts 						detect: [ :partx | start = (partx fieldAt: 'content-id' ifAbsent: ['' asValue] ) value  ] 						ifNone: [ httpEntity parts first ]]			ifNil: [httpEntity parts first] ]</body></methods><methods><class-id>WebServices.SoapMarshalingManager class</class-id> <category>utilities</category><body package="SOAPBinding">readDocumentFrom: httpEntity	| part  |	part := httpEntity isMultipart 		ifTrue: [self selectStartPartBlock value: httpEntity ]		ifFalse: [httpEntity].	^([(XMLParser on: part contents readStream) validate: false; scanDocument]			on: SAXParseException do: [ :ex | ex parameter: httpEntity. ex pass])</body></methods><methods><class-id>WebServices.SoapWsdl20HeaderBinding</class-id> <category>accessing</category><body package="WSDLBinding">headerTag	^self partMarshalers first tag</body><body package="WSDLBinding">mustUnderstand	^mustUnderstand</body><body package="WSDLBinding">mustUnderstand: anObject	mustUnderstand := anObject</body><body package="WSDLBinding">required	^self partMarshaler isMandatory</body></methods><methods><class-id>WebServices.SoapWsdl20HeaderBinding</class-id> <category>api -- builder</category><body package="WSDLBinding">buildMarshalersFrom: headerDescriptor binding: binding	| headerMarshaler soapHeaderEntry |	partMarshalers := OrderedCollection new.	self mustUnderstand: headerDescriptor mustUnderstand.	elementType := headerDescriptor element.	(binding headerMarshalerFor: elementType) 		ifNotNil: [ :hMarshaler  | partMarshalers := OrderedCollection with: hMarshaler. ^nil ].	self resolveElementNodeFrom: headerDescriptor binding: binding.	soapHeaderEntry := binding transport soapVersion = '1.1'		ifTrue: [binding marshalerForClass: Soap11HeaderEntry  ifAbsent: [nil]]		ifFalse: [binding marshalerForClass: Soap12HeaderEntry  ifAbsent: [nil]].	(headerMarshaler := RelationMarshaler new)		buildFromTag: self partMarshaler tag 		marshaler: self partMarshaler 		headerEntryMarshaler:soapHeaderEntry.	headerDescriptor required 		ifTrue: [ headerMarshaler beMandatory ]		ifFalse: [ headerMarshaler beOptional].	partMarshalers := OrderedCollection with: headerMarshaler.	binding addHeaderMarshaler: headerMarshaler.</body></methods><methods><class-id>WebServices.SoapWsdl20HeaderBinding class</class-id> <category>instance creation</category><body package="WSDLBinding">buildMarshalersFrom: headerDescriptor binding: binding	^self new buildMarshalersFrom: headerDescriptor binding: binding; yourself</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderFaultBinding</class-id> <category>accessing</category><body package="WSDLBinding">marshalers	^self partMarshalers</body><body package="WSDLBinding">partMarshaler	^self partMarshalers first</body><body package="WSDLBinding">smalltalkClass	^smalltalkClass</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderFaultBinding</class-id> <category>initialization</category><body package="WSDLBinding">asPartMarshalersFrom: assocList binding: binding	| valMarshaler |	assocList isEmpty ifTrue: [self error: ( #CannotResolveSoapHeaderFaultParts &lt;&lt; #webservices &gt;&gt; 'Can not resolve Soap header fault parts') ].	partMarshalers := OrderedCollection new.	assocList do: [ :assoc |  self buildHeaderEntryMarshalerFrom: assoc binding: binding  ].	(valMarshaler := self partMarshaler typeMarshaler valueMarshaler) isComplexTypeMarshaler		ifTrue: [ smalltalkClass := valMarshaler smalltalkClass ].	tags := partMarshalers collect: [ :marshaler | marshaler tag].</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderFaultBinding class</class-id> <category>accessing</category><body package="WSDLBinding">headersBeOptional	^true</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>accessing</category><body package="WSDLBinding">addHeaderMarshaler: aRelationMarshaler	(self headerMarshalerFor: aRelationMarshaler tag)		ifNil: [ self headerMarshalers add: aRelationMarshaler ]</body><body package="WSDLBinding">anyEncoding	^self operations first anyEncoding</body><body package="WSDLBinding">bindingDescriptor	^bindingDescriptor</body><body package="WSDLBinding">bindingDescriptor: aWsdlBindingDescriptor	bindingDescriptor := aWsdlBindingDescriptor</body><body package="WSDLBinding">faults	^faults</body><body package="WSDLBinding">faults: anObject	faults := anObject</body><body package="WSDLBinding">headerMarshalers	^headerMarshalers ifNil: [headerMarshalers := OrderedCollection new]</body><body package="WSDLBinding">idTag	^idTag</body><body package="WSDLBinding">idTag: aNodeTag	idTag := aNodeTag</body><body package="WSDLBinding">interfaceDescriptor	^bindingDescriptor interfaceDescriptor</body><body package="WSDLBinding">muValueOfAttribute: xmlElement	| anAttribute val |	anAttribute := self isSoap11 	ifTrue: [ self class mu11Attribute ] ifFalse: [ self class mu12Attribute ].	val := xmlElement  valueOfAttribute: anAttribute ifAbsent: [ ^false ].	^('true' match: val ) or: [val = '1' ]</body><body package="WSDLBinding">name	^bindingDescriptor name</body><body package="WSDLBinding">name: aNodeTag			bindingDescriptor name: aNodeTag</body><body package="WSDLBinding">newHeaderEntry		^self isSoap11		ifTrue: [Soap11HeaderEntry targetRecipientMU1 ]		ifFalse: [ Soap12HeaderEntry new]</body><body package="WSDLBinding">operations	^operations</body><body package="WSDLBinding">operations: anOrderedCollection	operations := anOrderedCollection.</body><body package="WSDLBinding">port	^port</body><body package="WSDLBinding">port: aWsdlPort	port := aWsdlPort</body><body package="WSDLBinding">portAddress	port ifNil: [self setPortIfAbsentDo: [ nil]].	^port ifNotNil: [ :p | p address]</body><body package="WSDLBinding">refTag	^refTag</body><body package="WSDLBinding">refTag: aNodeTag	refTag := aNodeTag</body><body package="WSDLBinding">roleValueOfAttribute: xmlElement	| anAttribute |	anAttribute := self isSoap11 	ifTrue: [ self class actorAttribute ] ifFalse: [ self class roleAttribute ].	^xmlElement  valueOfAttribute: anAttribute ifAbsent: [ nil ].</body><body package="WSDLBinding">schemaSource	^schemaSource</body><body package="WSDLBinding">schemaSource: aString	schemaSource := aString</body><body package="WSDLBinding">soapEnvelopeMarshaler	| ns |	ns := self transport soapVersion = '1.1' ifTrue: [ SoapBinding soap11_uri ] ifFalse: [ SoapBinding soap12_uri  ].	^self  typeMarshalerForTag: ( NodeTag qualifier: '' ns: ns type: 'Envelope' )</body><body package="WSDLBinding">soapFaultMarshaler	| ns |	ns := self transport soapVersion = '1.1' ifTrue: [ SoapBinding soap11_uri ] ifFalse: [ SoapBinding soap12_uri  ].	^self  elementMarshalerForTag: (NodeTag qualifier: '' ns: ns type: 'Fault' )</body><body package="WSDLBinding">soapHeaderEntryMarshaler	^self targetNamespace = SoapBinding soap11_uri		ifTrue: [self marshalerForClass: Soap11HeaderEntry  ifAbsent: [nil] ]		ifFalse: [self marshalerForClass: Soap12HeaderEntry  ifAbsent: [nil] ]</body><body package="WSDLBinding">transport	^transport</body><body package="WSDLBinding">transport: aTransportBinding	transport := aTransportBinding</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>operations</category><body package="WSDLBinding">addOperation: anOperationBinding	operations isNil ifTrue: [ operations := OrderedCollection new: 30].	operations addLast: anOperationBinding</body><body package="WSDLBinding">findOperationForSelector:  aSymbol	^self getServiceMap operationFor: aSymbol</body><body package="WSDLBinding">findSelectorForOperation:  aString	^self getServiceMap selectorFor: aString</body><body package="WSDLBinding">getOperation: aNode	^self operations detect: [ :bo | bo name type = aNode type ] ifNone: [nil].</body><body package="WSDLBinding">operationNamed: aString	^self operations detect: [ :bo | bo name type = aString ] ifNone: [nil].</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>testing</category><body package="WSDLBinding">isHttpBinding	^self transport isHttpBinding</body><body package="WSDLBinding">isSoap11	^self transport isSoap11</body><body package="WSDLBinding">isSoap12	^self transport isSoap12</body><body package="WSDLBinding">isSoapBinding	^(self isSoap11 or: [self isSoap12 ])</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>api -- translation</category><body package="WSDLBinding">findOperationFor: aSoapRequest	| op |	"First try from the selector map if there is any"	(op := self findOperationForSelector: aSoapRequest selector) ifNotNil: [^op].	^self operations 			detect: [ :operation | aSoapRequest accepts: operation]			ifNone: [nil]</body><body package="WSDLBinding">findOperationForTag: tagx httpPackage: anHttpEntity	^self findOperationForTag: tagx httpPackage: anHttpEntity ifNone: [nil]</body><body package="WSDLBinding">findOperationForTag: tagx httpPackage: anHttpEntity ifNone: aBlock	| searchBlock bodyDescription |	searchBlock := anHttpEntity isResponse						ifTrue: [anHttpEntity isSuccess									ifTrue: [ 	[ :op | op outputBodyMarshaler ] ]									ifFalse: [ [ :op | op faultMarshalers first ] ]]						ifFalse: [ [ :op | op inputBodyMarshaler ] ].	^operations 		detect: [ :operation |				bodyDescription := searchBlock value: operation.				operation isDocument					ifTrue: [ 	( bodyDescription partMarshalers								detect: [ :marshaler | marshaler tag = tagx ] ifNone: [nil]							) notNil ]					ifFalse: [ bodyDescription structMarshaler tag = tagx ] ] 		ifNone: aBlock</body><body package="WSDLBinding">headerMarshalerFor: aNodeTagOrString	| node |	node := ((aNodeTagOrString isKindOf: NodeTag) and: [aNodeTagOrString namespace isEmpty])		ifTrue: [aNodeTagOrString type]		ifFalse: [aNodeTagOrString].	^self headerMarshalers 		detect: [ :mx |			node isString				ifTrue: [mx tag type = node]				ifFalse: [ mx tag = node ]]		ifNone: [nil]</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>callbacks</category><body package="WSDLBinding">marshalMustUnderstandError:  aFault " When a SOAP node generates a fault with a Value of Code set to "env:MustUnderstand", it SHOULD provide NotUnderstood SOAP header blocks in the generated fault message. The NotUnderstood SOAP header blocks, as described below, detail the XML qualified names (per XML Schema [XML Schema Part 2]) of the particular SOAP header block(s) which were not understood.http://www.w3.org/TR/soap12-part1/#faultcodes "	^self halt.</body><body package="WSDLBinding">marshalVersionMismatchError:  aFault " When a SOAP node generates a fault with a Value of Code set to "env:VersionMismatch", it SHOULD provide an Upgrade SOAP header block in the generated fault message.http://www.w3.org/TR/soap12-part1/#faultcodes "	^self halt.</body><body package="WSDLBinding">unmarshal: httpEntity"Obsolete"	|  dom |	dom := SoapMessage readDocumentFrom: httpEntity.	^(SoapMarshalingManager on: self) unmarshal: dom root.</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>initialization</category><body package="WSDLBinding">initialize	super initialize.	"self setPortIfAbsentDo: [ nil]"</body><body package="WSDLBinding">setPortIfAbsentDo: aBlock	port := WsdlPort portForBinding: self  ifAbsent: [ ^aBlock value].	^port</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>xml schema support</category><body package="WSDLBinding">asXMLSchemaSpecification	^self importedBindings collect: [ :x2oBinding | x2oBinding  asXMLSchemaSpecification ]</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>wsdl schema support</category><body package="WSDLBinding">asWsdlComponent	bindingDescriptor ifNil: [ ^nil ].	^self asWsdlComponentUsing: bindingDescriptor configurationDescriptorClass manager</body><body package="WSDLBinding">asWsdlComponentUsing: aSoapMarshalingManager	|  bindingMarshaler mc |	bindingDescriptor ifNil: [ ^nil ].	aSoapMarshalingManager qualifierMap at: targetNamespace put: 'tns'.	bindingMarshaler := aSoapMarshalingManager binding marshalers detect: [ :m | m tag type = 'binding' ] ifNone: [nil].	(mc := MarshalingContext marshaler: bindingMarshaler)		manager: aSoapMarshalingManager;		value: self bindingDescriptor.	bindingMarshaler setNodeAndMarshalFrom: mc.	^mc source.</body><body package="WSDLBinding">asWsdlSchema	^WsdlConfiguration asWsdlAt: self targetNamespace</body><body package="WSDLBinding">asWsdlTypes	^XML.Element		tag: (NodeTag new qualifier: '' ns: '' type: 'types' )		elements: self asXMLSchemaSpecification</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream	aStream nextPutAll: 'WsdlBinding name='.	self name notNil ifTrue: [aStream nextPutAll: self name asString]."	aStream nextPutAll: ', '.	interface ifNotNil: [ interface printOn: aStream ]"</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>service map</category><body package="WSDLBinding">createDefaultServiceMap	self operations do: [ :opx | 		(self serviceMap selectorFor:  opx name) ifNil: [ 			 self serviceMap addOperation: opx name type selector: opx equivalentSmalltalkMessageName ]].	^self serviceMap</body><body package="WSDLBinding">getServiceMap	self serviceMap operations isEmpty ifTrue: [self createDefaultServiceMap].	^self serviceMap</body><body package="WSDLBinding">loadServiceMapFrom: aStream "Use the method to set selectors for the specified interface and service class. See ServiceMap comments"	| map |	aStream atEnd ifTrue: [aStream reset].	map := (ServiceMap loadFrom: aStream) first. 	map  interface = self interfaceDescriptor name ifTrue: [ self serviceMap: map  ].</body><body package="WSDLBinding">serviceClass	^self interfaceDescriptor serviceClass</body><body package="WSDLBinding">serviceClass: aClass	self interfaceDescriptor serviceClass: aClass</body><body package="WSDLBinding">serviceMap	^self interfaceDescriptor serviceMap</body><body package="WSDLBinding">serviceMap: aServiceMap	self interfaceDescriptor serviceMap: (aServiceMap asServiceMapWith: self)</body><body package="WSDLBinding">setSelector: aSymbol forOperation:  aNode	(self getOperation: aNode) ifNil: [^nil].	self serviceMap addOperation: aNode type selector: aSymbol</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>specification - uri</category><body package="WSDLBinding">soap11_envelope_uri	^'http://schemas.xmlsoap.org/soap/envelope/'</body><body package="WSDLBinding">wsd11_microsoft_extension_uri" Answer URI of WSDL extension binding "	^'http://schemas.microsoft.com/soap-toolkit/wsdl-extension'</body><body package="WSDLBinding">wsdl11_http_uri	^'http://schemas.xmlsoap.org/wsdl/http/'</body><body package="WSDLBinding">wsdl11_mime_uri" Answer URI of MIME binding for WSDL "	^'http://schemas.xmlsoap.org/wsdl/mime/'</body><body package="WSDLBinding">wsdl11_soap_http_uri"http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html5.6.2 HTTP TransportThe profile limits the underlying transport protocol to HTTP. A wsdl:binding element in a DESCRIPTION MUST specify the HTTP transport protocol with SOAP binding. Specifically, the transport attribute of its soapbind:binding child MUST have the value 'http://schemas.xmlsoap.org/soap/http' "	^'http://schemas.xmlsoap.org/soap/http'</body><body package="WSDLBinding">wsdl11_soap_uri	^'http://schemas.xmlsoap.org/wsdl/soap/'</body><body package="WSDLBinding">wsdl11_uri	^'http://schemas.xmlsoap.org/wsdl/'</body><body package="WSDLBinding">wsdl20_http_uri	^'http://www.w3.org/ns/wsdl/http'</body><body package="WSDLBinding">wsdl20_iri	^'http://www.w3.org/ns/wsdl/style/iri'</body><body package="WSDLBinding">wsdl20_mepDefault	^'http://www.w3.org/ns/wsdl/in-out'</body><body package="WSDLBinding">wsdl20_rpc_uri	^'http://www.w3.org/ns/wsdl/style/rpc'</body><body package="WSDLBinding">wsdl20_soap_envelope	^'http://www.w3.org/2003/05/soap-envelope'</body><body package="WSDLBinding">wsdl20_soap_http	^'http://www.w3.org/2003/05/soap/bindings/HTTP/'</body><body package="WSDLBinding">wsdl20_soap_mepDefault	^'http://www.w3.org/2003/05/soap/mep/request-response/'</body><body package="WSDLBinding">wsdl20_soap_uri	^'http://www.w3.org/ns/wsdl/soap'</body><body package="WSDLBinding">wsdl20_style_multipart	^'http://www.w3.org/ns/wsdl/style/multipart'</body><body package="WSDLBinding">wsdl20_uri	^'http://www.w3.org/ns/wsdl'</body><body package="WSDLBinding">wsdl_smalltalk_uri" Answer URI of SmalltalkWsdlBinding binding for WSDL "	^'urn:visualworks:SmalltalkWsdlBinding'</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>registry removing</category><body package="WSDLBinding">removeKey: aStringOrNode ifAbsent: aBlock	| key |	key := aStringOrNode isString		ifTrue: [ self wsdlBindings keys detect: [ :k | k type = aStringOrNode ] ifNone: [ nil ] ]		ifFalse: [ aStringOrNode ].	self wsdlBindings removeKey: key ifAbsent: aBlock</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>initialization</category><body package="WSDLBinding">configure	" ((self configure)) "	self wsdl11Binding  ifNil:		[^self error: ((#WSDLBindingIsNotFound &lt;&lt; #webservices &gt;&gt; 'WSDL Binding is not found at &lt;1s&gt;')							expandMacrosWith: self wsdl11_uri)].	self wsdl20Binding  ifNil:		[^self error: ((#WSDLBindingIsNotFound &lt;&lt; #webservices &gt;&gt; 'WSDL Binding is not found at &lt;1s&gt;')							expandMacrosWith: self wsdl20_uri)].</body><body package="WSDLBinding">initialize	" self initialize "	self reset.	self configure.</body><body package="WSDLBinding">reset"( self reset ) "	WsdlBindings := Dictionary new: 30.	WsdlPort reset.	WsdlService reset.</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>accessing bindings</category><body package="WSDLBinding">wsdl11Binding	^(XMLObjectBinding bindingAtNamespace: self wsdl11_uri) ifNil: 		[XMLObjectBinding loadFrom: self wsdl11Specification readStream].</body><body package="WSDLBinding">wsdl11ExtensionBinding	^XMLObjectBinding bindingAtNamespace: self wsd11_microsoft_extension_uri</body><body package="WSDLBinding">wsdl11HttpBinding	^XMLObjectBinding bindingAtNamespace: self wsdl11_http_uri</body><body package="WSDLBinding">wsdl11SoaplBinding	^XMLObjectBinding bindingAtNamespace: self wsdl11_soap_uri</body><body package="WSDLBinding">wsdl20Binding	^(XMLObjectBinding bindingAtNamespace: self wsdl20_uri)  ifNil: 		[XMLObjectBinding loadFrom: self wsdl20Specification readStream].</body><body package="WSDLBinding">wsdl20HttpBinding	^XMLObjectBinding bindingAtNamespace: self wsdl20_http_uri</body><body package="WSDLBinding">wsdl20SoaplBinding	^XMLObjectBinding bindingAtNamespace: self wsdl20_soap_uri</body><body package="WSDLBinding">wsdlSmalltalkBinding	^XMLObjectBinding bindingAtNamespace: self wsdl_smalltalk_uri</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>loading bindings</category><body package="WSDLBinding">loadWsdlBinding: aFilenameString	| stream |	stream :=  aFilenameString asFilename readStream.	^[self loadWsdlBindingFrom: stream]		ensure: [ stream close ].</body><body package="WSDLBinding">loadWsdlBindingFrom: domCollectionOrStream" dataSource: collection of XML.Document / Stream / URI "	^WsdlConfiguration defaultReadFrom: domCollectionOrStream</body><body package="WSDLBinding">objectLoadFromSource: aDataSource"The dataSource may be a URI, a Filename (or a String which will be treated as a Filename)""The method will load a wsdl schema, create XML to Object binding and register xml to object and wsdl bindings "	^WsdlConfiguration objectReadFrom: aDataSource inNamespace: XMLObjectBindingPolicy defaultClassNamespace.</body><body package="WSDLBinding">objectLoadFromSource: aDataSource inNamespace: aString"The dataSource may be a URI, a Filename (or a String which will be treated as a Filename)""The method will load a wsdl schema, create XML to Object binding and register xml to object and wsdl bindings. The classes will be created in the specified namespace "	^WsdlConfiguration objectReadFrom: aDataSource inNamespace:  aString.</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>accessing</category><body package="WSDLBinding">actorAttribute	^XML.NodeTag new 				qualifier: '' 				ns: WebServices.SoapBinding soap11_uri				type: 'actor'</body><body package="WSDLBinding">bindingAt: aNodeTagOrString ifAbsent: aBlock	(aNodeTagOrString isKindOf: NodeTag) ifTrue: [ ^self wsdlBindings at: aNodeTagOrString ifAbsent: aBlock].	^(self wsdlBindings associations 		detect:  [ :assoc | assoc key type = aNodeTagOrString or: [ assoc key namespace = aNodeTagOrString ]]		ifNone: [^aBlock value ]) value</body><body package="WSDLBinding">bindingAt: aNodeTag put: aBinding	^self wsdlBindings at: aNodeTag put: aBinding</body><body package="WSDLBinding">bindingsAtNamespace: aString 	^self wsdlBindings values select: [ :binding | binding targetNamespace = aString ].</body><body package="WSDLBinding">httpTransportUri	^self wsdl11_soap_http_uri</body><body package="WSDLBinding">mu11Attribute	^XML.NodeTag new 			qualifier: '' 			ns: WebServices.SoapBinding soap11_uri			type: 'mustUnderstand'</body><body package="WSDLBinding">mu12Attribute	^XML.NodeTag new 			qualifier: '' 			ns: WebServices.SoapBinding soap12_uri			type: 'mustUnderstand'</body><body package="WSDLBinding">roleAttribute	^XML.NodeTag new 				qualifier: '' 				ns: WebServices.SoapBinding soap12_uri				type: 'role'</body><body package="WSDLBinding">systemTargetNamespaces	^#()</body><body package="WSDLBinding">wsdlBindings	^WsdlBindings</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>utilities</category><body package="WSDLBinding">initializeRegistriesFor: aClass	| data x2oColl config |	((aClass  respondsTo: #x2oBinding ) 		and: [(data := aClass  x2oBinding) notNil and: [data notEmpty] ]) 		ifTrue: [ x2oColl := self loadBindings:  data readStream ].	((data := aClass wsdlSchema) notNil and: [ data isString 		and: [('*description*' match: data) or: [('*definitions*' match: data)]]]) 		ifTrue: [data := data readStream ].	data ifNotNil: 		[config := (WsdlConfigurationDescriptor loadAndParse: data) buildComponents.		aClass initializeBindingServiceMap: config x2oImports: x2oColl ].	^config</body><body package="WSDLBinding">loadWsdlBindingFrom: domCollectionOrStream usingServiceMap: aStream	| config |	config := self loadWsdlBindingFrom: domCollectionOrStream.	config bindings do: [ :bx | bx loadServiceMapFrom: aStream ].	^config</body></methods><methods><class-id>WebServices.WsdlBinding class</class-id> <category>specifications</category><body package="WSDLBinding">wsdl11Specification	^'&lt;?xml version ="1.0"?&gt;&lt;!-- WSDL Binding to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="WsdlBinding" 	useReference="false"	useXPath="true"	useTaggedObject="false"	defaultClassNamespace="WebServices"	targetNamespace="http://schemas.xmlsoap.org/wsdl/"	xmlns="http://schemas.xmlsoap.org/wsdl/" 	xmlns:st="urn:visualworks:VWSchemaBinding"	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"	xmlns:wsoap12="http://schemas.xmlsoap.org/wsdl/soap12/"	xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"	xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;&lt;simple name="urlEncodedType" id="urlEncoded"/&gt;&lt;object name="wsdl:documented" smalltalkClass="WsdlComponentDescriptor" abstract="true"&gt;	&lt;element name="documentation" ref="xsd:string" aspect="documentation" getSelector="xmlDocumentation" minOccurs = "0"/&gt;&lt;/object&gt;&lt;object name="importType" baseType="wsdl:documented" smalltalkClass="BindingImport" &gt;	&lt;attribute name="name" ref="xsd:string" aspect="namespace" minOccurs="0"/&gt;	&lt;attribute name="namespace" ref="xsd:string" aspect="namespace" minOccurs="0"/&gt;	&lt;attribute name="location" ref="xsd:string" aspect="location" minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="partType" baseType="wsdl:documented"  smalltalkClass="Wsdl11MessagePartDescriptor"&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs="1" aspect="name"/&gt;	&lt;attribute name="element" ref="xsd:QName" aspect="elementName" minOccurs="0"/&gt;	&lt;attribute name="type" ref="xsd:QName" aspect="typeName" minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="message" baseType="wsdl:documented" smalltalkClass="Wsdl11MessageDescriptor"&gt;	&lt;key name="messageKey"&gt;		&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;	&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;	&lt;element name="part" ref="partType" aspect="parts" minOccurs="0" maxOccurs="*" /&gt;&lt;/object&gt;	&lt;object name="interface_paramType" baseType="wsdl:documented" smalltalkClass="Wsdl11OperationParameterDescriptor"&gt;	&lt;attribute name="name" ref="xsd:NCName" aspect="name" minOccurs="0"/&gt;	&lt;attribute name="message" ref="xsd:QName" aspect="type" minOccurs="1"/&gt;&lt;/object&gt;&lt;object name="interface_OperationType" smalltalkClass="Wsdl11InterfaceOperationDescriptor"&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;	&lt;attribute name="parameterOrder" ref="xsd:NMTOKENS" aspect="parameterOrder" getSelector="getParameterOrder"   minOccurs="0"/&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation" getSelector="xmlDocumentation" minOccurs = "0"/&gt;		&lt;element name="input" ref="interface_paramType" aspect="input"/&gt;		&lt;element name="output" ref="interface_paramType" minOccurs="0" aspect="output"/&gt;		&lt;element name="fault" ref="interface_paramType" minOccurs="0" aspect="faults" maxOccurs="*"/&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="portType" baseType="wsdl:documented" smalltalkClass="WsdlInterfaceDescriptor"&gt;	&lt;key name="portTypeKey"&gt;&lt;attribute name="name" ref="xsd:NCName"/&gt;	&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;	&lt;element name="operation" ref="interface_OperationType" aspect="operations" maxOccurs="*"/&gt;&lt;/object&gt;&lt;object name="bindingParameterType" smalltalkClass="Wsdl11SoapOperationEnvelopeDescriptor"&gt;	&lt;all&gt;		&lt;element name="soap:header" ref="headerType" aspect="soap11Header" minOccurs="0"  maxOccurs="*" form="qualified"/&gt;		&lt;element name="wsoap12:header" ref="headerType" aspect="soap12Header" minOccurs="0"  maxOccurs="*" form="qualified"/&gt;		&lt;element name="soap:body" ref="bodyType" aspect="soap11Body" minOccurs="0" form="qualified"/&gt;		&lt;element name="wsoap12:body" ref="bodyType" aspect="soap12Body" minOccurs="0" form="qualified"/&gt;		&lt;element name="http:urlEncoded" ref="urlEncodedType" aspect="urlEncoded" minOccurs="0" form="qualified"/&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="bodyType" smalltalkClass="Wsdl11SoapBodyPartDescriptor"&gt;	&lt;attribute name="encodingStyle" aspect="encodingStyle" ref="xsd:string"/&gt;	&lt;attribute name="parts" ref="xsd:NMTOKENS"/&gt;	&lt;attribute name="use" ref="xsd:string"/&gt;	&lt;attribute name="namespace" aspect="namespace" ref="xsd:string"/&gt;&lt;/object&gt;&lt;object name="headerfaultType" smalltalkClass="Wsdl11SoapHeaderFaultDescriptor"&gt;	&lt;attribute name="message" getSelector="messageNode"  ref="xsd:QName" minOccurs="1"/&gt;	&lt;attribute name="part" ref="xsd:string" minOccurs="1"/&gt;	&lt;attribute name="use" ref="xsd:string" minOccurs="1"/&gt;	&lt;attribute name="encodingStyle" aspect="encodingStyle" ref="xsd:string"/&gt;	&lt;attribute name="namespace" aspect="namespace" ref="xsd:string"/&gt;&lt;/object&gt;&lt;object name="headerType" baseType="headerfaultType" smalltalkClass="Wsdl11SoapHeaderDescriptor"&gt;	&lt;sequence&gt;		&lt;choice aspect="faultChoice" minOccurs="0"&gt;			&lt;element name="soap:headerfault" aspect="faults11" ref="headerfaultType" minOccurs="0" maxOccurs="*"  form="qualified"/&gt;			&lt;element name="wsoap12:headerfault" aspect="faults12" ref="headerfaultType" minOccurs="0" maxOccurs="*"  form="qualified"/&gt;		&lt;/choice&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="bindingFaultType" smalltalkClass="Wsdl11SoapOperationFaultDescriptor"&gt;	&lt;attribute name="name" ref="xsd:string" minOccurs="0"/&gt;	&lt;choice aspect="faultChoice"&gt;		&lt;element name="soap:fault" ref="faultType" aspect="fault11" minOccurs="0"  form="qualified"/&gt;		&lt;element name="wsoap12:fault" ref="faultType" aspect="fault12" minOccurs="0" form="qualified"/&gt;	&lt;/choice&gt;&lt;/object&gt;&lt;object name="faultType" smalltalkClass="Wsdl11MessageEncodingDescriptor"&gt;	&lt;attribute name="name" ref="xsd:NMTOKEN"/&gt;	&lt;attribute name="encodingStyle" aspect="encodingStyle" ref="xsd:string" minOccurs="0" /&gt;	&lt;attribute name="use" ref="xsd:string"/&gt;	&lt;attribute name="namespace" aspect="namespace" ref="xsd:string" minOccurs="0" /&gt;&lt;/object&gt;&lt;object name="binding_OperationType" smalltalkClass="Wsdl11OperationBindingDescriptor"&gt;	&lt;attribute name="name" ref="xsd:NCName"/&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation" getSelector="xmlDocumentation" minOccurs = "0"/&gt;&lt;!-- SOAP 1.1 and 1.2 extensions --&gt;		&lt;element name="soap:operation" minOccurs="0" aspect="soapOperationDescriptor" getSelector="soap11OperationDescriptor" form="qualified"&gt;			&lt;struct name="operation11Type"&gt;				&lt;attribute name="soapAction" aspect="soapAction" ref="xsd:string"/&gt;				&lt;attribute name="style" aspect="style" conversionId="ByteSymbol" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="wsoap12:operation" minOccurs="0" aspect="soapOperationDescriptor"  getSelector="soap12OperationDescriptor"  form="qualified"&gt;			&lt;struct name="operation12Type"&gt;				&lt;attribute name="soapAction" aspect="soapAction" minOccurs="0"  ref="xsd:string"/&gt;				&lt;attribute name="soapActionRequired" aspect="soapActionRequired" minOccurs="0"  ref="xsd:boolean"/&gt;				&lt;attribute name="style" aspect="style" conversionId="ByteSymbol" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;&lt;!-- HTTP  extensions --&gt;		&lt;element name="http:operation" minOccurs="0" aspect="relativeUriHolder"  form="qualified"&gt;			&lt;object name="operationType" smalltalkClass="ValueHolder"&gt;				&lt;attribute name="location" ref="xsd:string" aspect="value" minOccurs="1"/&gt;			&lt;/object&gt;		&lt;/element&gt;		&lt;element name="input" aspect="input" ref="bindingParameterType"/&gt;		&lt;element name="output" aspect="output" ref="bindingParameterType"  minOccurs="0"/&gt;		&lt;element name="fault" aspect="faults" ref="bindingFaultType" maxOccurs="*"  minOccurs="0"  /&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="binding" smalltalkClass="Wsdl11BindingDescriptor"&gt;	&lt;key name = "bindingKey"&gt;&lt;attribute name="name" ref="xsd:NCName"/&gt;	&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs = "0"/&gt;&lt;!-- do not use keyref to resolve interface. it will not be resolved in case of imported documents --&gt;	&lt;attribute name="type" ref="xsd:QName"  aspect="interfaceDescriptor" getSelector="interfaceDescriptorName" minOccurs = "1"/&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation" getSelector="xmlDocumentation" minOccurs = "0"/&gt;&lt;!-- SOAP  extensions --&gt;		&lt;element name="soap:binding" aspect="bindingType"  getSelector="binding11Type" form="qualified" minOccurs="0"&gt;			&lt;struct name="binding11Type"&gt;				&lt;attribute name="transport" aspect="transportName" ref="xsd:string" minOccurs="1"/&gt;				&lt;attribute name="style" conversionId="ByteSymbol"  ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="wsoap12:binding" aspect="bindingType"  getSelector="binding12Type" form="qualified" minOccurs="0"&gt;			&lt;struct name="binding12Type"&gt;				&lt;attribute name="transport" aspect="transportName" ref="xsd:string" minOccurs="1"/&gt;				&lt;attribute name="style" conversionId="ByteSymbol"  ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;&lt;!-- HTTP  extensions --&gt;		&lt;element name="http:binding" aspect="soapHttpBindingSpec" getSelector="getSoapHttpBindingSpec"  form="qualified" minOccurs="0"&gt;			&lt;object name="bindingType" smalltalkClass="SoapWsdl11HttpBinding"&gt;				&lt;attribute name="verb" ref="xsd:string" aspect="verb" minOccurs="1"/&gt;			&lt;/object&gt;		&lt;/element&gt;		&lt;element name="operation" ref="binding_OperationType" aspect="operations" maxOccurs="*" /&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="port" smalltalkClass="Wsdl11PortDescriptor"&gt;	&lt;key name = "portKey"&gt;&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" aspect="name" minOccurs = "1"/&gt;	&lt;attribute name="binding" ref="xsd:QName" minOccurs = "1"/&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation" getSelector="xmlDocumentation" minOccurs = "0"/&gt;&lt;!-- SOAP  extensions --&gt;		&lt;element name="soap:address" ref="addressType" aspect="address" setSelector="soap11Address:" getSelector="soap11Address" minOccurs = "0" form="qualified"/&gt;		&lt;element name="wsoap12:address" ref="addressType" aspect="address" setSelector="soap12Address:"  getSelector="soap12Address" minOccurs = "0" form="qualified"/&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="addressType" smalltalkClass="ValueHolder"&gt;	&lt;attribute name="location" aspect="value" ref="xsd:string" minOccurs="1"/&gt;&lt;/object&gt;&lt;object name="service" baseType="wsdl:documented" smalltalkClass="Wsdl11ServiceDescriptor"&gt;	&lt;key name="serviceKey"&gt;&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs = "0"/&gt;	&lt;element ref="port" aspect="ports" minOccurs = "0"  maxOccurs = "*" /&gt;&lt;/object&gt;&lt;object name="definitions" smalltalkClass="Wsdl11ConfigurationDescriptor"&gt;	&lt;all&gt;		&lt;element name="import" ref="importType" aspect="imports" getSelector="getImports" minOccurs="0" maxOccurs="*"/&gt;		&lt;element name="schemaBindings" aspect="schemaBindings"  getSelector="getXMLSchemaBindings"  minOccurs="0" maxOccurs="*" ref="xsd:XMLNode" /&gt;		&lt;element name="types" aspect="types"  getSelector="getXMLTypes"  minOccurs="0" maxOccurs="*" ref="xsd:XMLNode" /&gt;		&lt;element ref="message" aspect="messages" maxOccurs="*" minOccurs="0" /&gt;		&lt;element ref="portType" aspect="interfaces" maxOccurs="*" minOccurs="0" /&gt;		&lt;element ref="binding" aspect="bindings" maxOccurs="*" minOccurs="0" /&gt;		&lt;element ref="service" aspect="services" maxOccurs="*" minOccurs="0"/&gt;	&lt;/all&gt;	&lt;attribute name="targetNamespace" ref="xsd:string" aspect="targetNamespace" minOccurs="0"/&gt;&lt;/object&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="WSDLBinding">wsdl20Specification"(XMLObjectBinding loadFrom: self wsdl20Specification readStream)"	^'&lt;?xml version ="1.0"?&gt;&lt;!-- WSDL Binding to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="Wsdl20Binding" 	defaultClassNamespace="WebServices"	targetNamespace="http://www.w3.org/ns/wsdl"	xmlns="http://www.w3.org/ns/wsdl"	useInlineType="false"	useReference="false"	useXPath="true"	useTaggedObject="false"	xmlns:st="urn:visualworks:VWSchemaBinding"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:wsdl="http://www.w3.org/ns/wsdl"    	xmlns:wsoap="http://www.w3.org/ns/wsdl/soap"	xmlns:whttp="http://www.w3.org/ns/wsdl/http"	xmlns:wrpc="http://www.w3.org/ns/wsdl/rpc"&gt;&lt;!-- Bindings for WSDL Binding types --&gt;&lt;object name="wsdl:documented" smalltalkClass="WsdlComponentDescriptor" abstract="true"&gt;	&lt;element name="documentation" ref="xsd:string" aspect="documentation"  getSelector="xmlDocumentation"  minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="importType" baseType="wsdl:documented" smalltalkClass="BindingImport" &gt;	&lt;attribute name="name" ref="xsd:string" aspect="namespace" minOccurs="0"/&gt;	&lt;attribute name="namespace" ref="xsd:string" aspect="namespace" minOccurs="1"/&gt;	&lt;attribute name="location" ref="xsd:string" aspect="location" minOccurs="0"/&gt;&lt;/object&gt;&lt;struct name="faultType" &gt;	&lt;attribute name="messageLabel" ref="xsd:string" aspect="messageLabel" minOccurs="0"/&gt;	&lt;attribute name="ref" ref="xsd:QName" aspect="name" minOccurs="1" /&gt;	&lt;element name="documentation" ref="xsd:string" aspect="documentation"  getSelector="xmlDocumentation"  minOccurs="0"/&gt;&lt;/struct&gt;&lt;struct name="paramType" &gt;	&lt;attribute name="messageLabel" ref="xsd:string" aspect="messageLabel" minOccurs="0"/&gt;	&lt;attribute name="element" ref="xsd:QName" aspect="element" minOccurs="1" &gt;		&lt;union&gt;   		     &lt;simple baseType="xsd:token"&gt;				  &lt;xsd:enumeration value="#any"/&gt;				  &lt;xsd:enumeration value="#none"/&gt;				  &lt;xsd:enumeration value="#other"/&gt;			&lt;/simple&gt;   		     &lt;simple baseType="xsd:QName"/&gt;  		&lt;/union&gt;	&lt;/attribute&gt;	&lt;element name="documentation" ref="xsd:string" aspect="documentation"  getSelector="xmlDocumentation"  minOccurs="0"/&gt;&lt;/struct&gt;&lt;object name="interface_OperationType" smalltalkClass="Wsdl20InterfaceOperationDescriptor"&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;	&lt;attribute name="pattern" ref="xsd:string" aspect="pattern"  minOccurs="0" /&gt;	&lt;attribute name="style" ref="xsd:string" aspect="style"  minOccurs="0" /&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation"  getSelector="xmlDocumentation"  minOccurs="0"/&gt;		&lt;element name="input" ref="paramType" aspect="input"  minOccurs="0"  maxOccurs="*"/&gt;		&lt;element name="output" ref="paramType" aspect="output"  minOccurs="0"   maxOccurs="*"/&gt;		&lt;element name="infault" ref="faultType" minOccurs="0" aspect="infaults" maxOccurs="*"/&gt;		&lt;element name="outfault" ref="faultType" minOccurs="0" aspect="outfaults" maxOccurs="*"/&gt;	&lt;/all&gt;&lt;!-- SOAP RPC operation attribute   --&gt;	&lt;attribute name="wrpc:signature" aspect="rpcSignature" ref="xsd:string" form="qualified"/&gt;&lt;/object&gt;&lt;!-- the wrpc:signature extension property of an WsdlOperationDescriptor --&gt;&lt;attribute name="wrpc:signature" aspect="rpcSignature" type="xsd:NCNames" form="qualified"/&gt;&lt;object name="interface" baseType="wsdl:documented" smalltalkClass="WsdlInterfaceDescriptor"&gt;	&lt;key name="interfaceKey"&gt;&lt;attribute name="name" ref="xsd:NCName"/&gt;	&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;	&lt;attribute name="styleDefault" ref="xsd:string" minOccurs="0"/&gt;	&lt;attribute name="extends" ref="xsd:QNames" minOccurs="0"/&gt;	&lt;element name="fault" ref="interfaceFaultType" aspect="faults" minOccurs="0" maxOccurs="*"/&gt;	&lt;element name="operation" ref="interface_OperationType" aspect="operations" maxOccurs="*"/&gt;&lt;/object&gt;&lt;struct name="interfaceFaultType"&gt;	&lt;attribute name="name" ref="xsd:NCName" aspect="name" minOccurs="1"/&gt;	&lt;attribute name="element"  aspect="element" minOccurs="1" ref="xsd:QName"/&gt;	&lt;element name="documentation" ref="xsd:string" aspect="documentation"  minOccurs="0"/&gt;&lt;/struct&gt;&lt;identityStruct name="bindingParameterType" &gt;	&lt;any namespace="##other" minOccurs="0" maxOccurs="*"/&gt;&lt;/identityStruct&gt;&lt;struct name="bindingFaultType"&gt;	&lt;any namespace="##other" minOccurs="0" maxOccurs="*"/&gt;&lt;/struct&gt;&lt;object name="binding_ParameterType" smalltalkClass="Wsdl20SoapOperationParameterDescriptor" &gt;	&lt;!--- SOAP operation input/output attributes --&gt;	&lt;attribute name="messageLabel" aspect="messageLabel" minOccurs="0" ref="xsd:string" /&gt;	&lt;element name="wsoap:header" aspect="soapHeaders" minOccurs="0" maxOccurs="*" ref="wsoap:soapHeaderType" form="qualified"/&gt;	&lt;element name="wsoap:module" ref="wsoap:moduleType" minOccurs="0" aspect="soapModule" form="qualified"/&gt;	&lt;!--- HTTP operation input/output attributes --&gt;	&lt;attribute name="whttp:contentEncoding"  aspect="httpContentEncoding" minOccurs="0"  ref="xsd:string" form="qualified"/&gt;	&lt;element name="whttp:header" aspect="httpHeader" minOccurs="0" maxOccurs="*" ref="httpHeaderType" form="qualified"/&gt;&lt;/object&gt;&lt;object name="binding_fault_type" smalltalkClass="Wsdl20SoapFaultDescriptor" &gt;	&lt;attribute name="ref" aspect="name" ref="xsd:QName" /&gt;	&lt;attribute name="wsoap:code" aspect="soapFaultCode" minOccurs="0" form="qualified"&gt;		&lt;union&gt;   		     &lt;simple baseType="xsd:token"&gt;				  &lt;xsd:enumeration value="#any"/&gt;			&lt;/simple&gt;   		     &lt;simple baseType="xsd:QName"/&gt;  		&lt;/union&gt;	&lt;/attribute&gt;	&lt;attribute name="wsoap:subcodes" aspect="soapFaultSubcode" minOccurs="0" form="qualified"&gt;		&lt;union&gt;   		     &lt;simple baseType="xsd:token"&gt;				  &lt;xsd:enumeration value="#any"/&gt;			&lt;/simple&gt;   		     &lt;simple baseType="xsd:QNames"/&gt;  		&lt;/union&gt;	&lt;/attribute&gt;	&lt;element name="wsoap:header" aspect="soapHeaders" minOccurs="0" maxOccurs="*" ref="wsoap:soapHeaderType" form="qualified"/&gt;	&lt;element name="wsoap:module" ref="wsoap:moduleType" minOccurs="0" aspect="soapModule" form="qualified"/&gt;&lt;/object&gt;&lt;struct name="binding_inOutFault" &gt;	&lt;attribute name="ref" aspect="name" ref="xsd:QName" /&gt;	&lt;attribute name="messageLabel" aspect="messageLabel" minOccurs="0" ref="xsd:string" /&gt;&lt;/struct&gt;&lt;object name="httpHeaderType" smalltalkClass="Wsdl20HttpHeaderDescriptor"&gt;	&lt;attribite name="name" ref="xsd:string"  minOccurs="1"/&gt;	&lt;attribite name="type" ref="xsd:QName"  minOccurs="0"/&gt;	&lt;attribite name="required" ref="xsd:boolean"  minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="wsoap:soapHeaderType" smalltalkClass="Wsdl20SoapHeaderDescriptor"&gt;	&lt;attribute name="element" ref="xsd:QName" minOccurs="1"/&gt;	&lt;attribute name="mustUnderstand" ref="xsd:boolean" minOccurs="0"/&gt;	&lt;attribute name="required" ref="xsd:boolean" minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="binding_OperationType"  smalltalkClass="Wsdl20OperationBindingDescriptor"&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation"  getSelector="xmlDocumentation"  minOccurs="0"/&gt;		&lt;attribute name="ref" aspect="name" ref="xsd:QName"  minOccurs="1"/&gt;		&lt;element name="input" aspect="input" ref="binding_ParameterType" minOccurs="0"   maxOccurs="*"/&gt;		&lt;element name="output" aspect="output" ref="binding_ParameterType" minOccurs="0"   maxOccurs="*"/&gt;		&lt;element name="infault" aspect="infaults" ref="binding_inOutFault" minOccurs="0"  maxOccurs="*"/&gt;		&lt;element name="outfault" aspect="outfaults" ref="binding_inOutFault" minOccurs="0"  maxOccurs="*"/&gt;	&lt;/all&gt;&lt;!-- SOAP WSDL operation attributes   --&gt;	&lt;attribute name="wsoap:mep" aspect="soapMep" getSelector="getSoapMep" ref="xsd:string" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="wsoap:action" aspect="soapAction"  ref="xsd:string" minOccurs="0" form="qualified"/&gt;&lt;!--- SOAP HTTP binding attributes  --&gt;	&lt;attribute name="whttp:location"  aspect="httpLocation"  ref="xsd:string" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="whttp:inputSerialization" aspect="httpInputSerialization" ref="xsd:string" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="whttp:outputSerialization"  aspect="httpOutputSerialization"  ref="xsd:string" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="whttp:faultSerialization"  aspect="httpFaultSerialization"  ref="xsd:string" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="whttp:queryParameterSeparator"  aspect="httpQueryParameterSeparator" getSelector="getHttpQueryParameterSeparator"  ref="xsd:string" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="whttp:contentEncodingDefault" aspect="httpContentEncoding" ref="xsd:string" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="whttp:ignoreUncited"  aspect="httpIgnoreUncited" getSelector="getHttpIgnoreUncited"  ref="xsd:boolean" minOccurs="0" form="qualified"/&gt;&lt;!---  HTTP binding attributes  --&gt;	&lt;attribute name="whttp:method"  aspect="httpMethod"  ref="xsd:string" minOccurs="0" form="qualified"/&gt;&lt;/object&gt;&lt;object name="binding"  smalltalkClass="Wsdl20BindingDescriptor"&gt;	&lt;key name = "bindingKey"&gt;&lt;attribute name="name" ref="xsd:NCName"/&gt;	&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs = "1"/&gt;&lt;!-- do not use keyref to resolve interface. it will not be resolved in case of imported documents --&gt;	&lt;attribute name="interface" ref="xsd:QName"  aspect="interfaceDescriptor" getSelector="interfaceDescriptorName" minOccurs = "0"/&gt;	&lt;attribute name="type" ref="xsd:string" aspect="type" minOccurs="1"/&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation"  getSelector="xmlDocumentation"  minOccurs="0"/&gt;		&lt;element name="fault" ref="binding_fault_type" aspect="faults" minOccurs="0" maxOccurs="*" /&gt;		&lt;element name="operation" ref="binding_OperationType" aspect="operations" minOccurs="0"   maxOccurs="*" /&gt;	&lt;/all&gt;&lt;!-- SOAP  extensions --&gt;	&lt;attribute name="wsoap:version" aspect="soapVersion" minOccurs="1" ref="xsd:string" form="qualified"/&gt;	&lt;attribute name="wsoap:protocol" aspect="protocol" minOccurs="1" ref="xsd:string" form="qualified"/&gt;	&lt;attribute name="wsoap:mepDefault"  aspect="soapMep" minOccurs="0" ref="xsd:string" form="qualified"/&gt;	&lt;element name="wsoap:module" aspect="soapModule" minOccurs="0" ref="wsoap:moduleType" form="qualified"/&gt;&lt;!-- HTTP extensions  --&gt;	&lt;attribute name="whttp:methodDefault" aspect="httpMethod" minOccurs="0" ref="xsd:string" form="qualified"/&gt;	&lt;attribute name="whttp:queryParameterSeparatorDefault"  aspect="httpQueryParameterSeparator" getSelector="getHttpQueryParameterSeparator" minOccurs="0" ref="xsd:string" form="qualified"/&gt;	&lt;attribute name="whttp:cookies" aspect="httpCookies" minOccurs="0"  ref="xsd:boolean" form="qualified"/&gt;	&lt;attribute name=" whttp:contentEncodingDefault"  aspect="httpContentEncoding" minOccurs="0" ref="xsd:string" form="qualified"/&gt;&lt;/object&gt;&lt;struct name="wsoap:moduleType"&gt; 	&lt;attribute name="ref" ref="xsd:QName"/&gt;	 &lt;attribute name="required" ref="xsd:boolean"/&gt;&lt;/struct&gt;&lt;object name="endpoint"  baseType="wsdl:documented" smalltalkClass="WsdlEndpointDescriptor"&gt;	&lt;key name = "portKey"&gt;&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" aspect="name" minOccurs = "1"/&gt;	&lt;attribute name="binding" ref="xsd:QName" minOccurs = "1"/&gt;	&lt;attribute name="address" ref="xsd:string" minOccurs = "0"/&gt;	&lt;!--- HTTP endpoint  attributes --&gt;	&lt;attribute name="whttp:authenticationScheme" ref="xsd:token" aspect="authenticationScheme" minOccurs="0" form="qualified"/&gt;	&lt;attribute name="whttp:authenticationRealm" ref="xsd:string" aspect="authenticationRealm" minOccurs="0" form="qualified"/&gt;&lt;/object&gt;&lt;object name="service"  baseType="wsdl:documented" smalltalkClass="Wsdl20ServiceDescriptor"&gt;	&lt;key name="serviceKey"&gt;&lt;attribute name="name" ref="xsd:NCName" minOccurs="1"/&gt;&lt;/key&gt;	&lt;attribute name="name" ref="xsd:NCName" minOccurs = "1"/&gt;	&lt;attribute name="interface" ref="xsd:QName" minOccurs = "1"/&gt;	&lt;element ref="endpoint" aspect="endpoints" minOccurs = "1"  maxOccurs = "*" /&gt;&lt;/object&gt;&lt;object name="description"  smalltalkClass="Wsdl20ConfigurationDescriptor"&gt;	&lt;all&gt;		&lt;element name="documentation" ref="xsd:string" aspect="documentation"  getSelector="xmlDocumentation"  minOccurs="0"/&gt;		&lt;element name="import" ref="importType" aspect="imports" minOccurs="0" maxOccurs="*"/&gt;		&lt;element name="schemaBindings" aspect="schemaBindings" getSelector="getXMLSchemaBindings" minOccurs="0" maxOccurs="*" ref="xsd:XMLNode" /&gt;		&lt;element name="types" aspect="types" getSelector="getXMLTypes" minOccurs="0" maxOccurs="*" ref="xsd:XMLNode" /&gt;		&lt;element ref="interface" aspect="interfaces" maxOccurs="*" minOccurs="0" /&gt;		&lt;element ref="binding" aspect="bindings" maxOccurs="*" minOccurs="0" /&gt;		&lt;element ref="service" aspect="services" maxOccurs="*" minOccurs="0"/&gt;	&lt;/all&gt;	&lt;attribute name="targetNamespace" ref="xsd:string" aspect="targetNamespace" minOccurs="1"/&gt;&lt;/object&gt;&lt;/xmlToSmalltalkBinding&gt;'</body></methods><methods><class-id>WebServices.Wsdl11OperationBindingDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addInputSoapHeader: aWsdl11SoapHeaderDescriptor	input ifNil: [input := Wsdl11SoapOperationEnvelopeDescriptor new].	input soapHeader add: aWsdl11SoapHeaderDescriptor.</body><body package="WSDLDescriptors">addOutputSoapHeader: aWsdl11SoapHeaderDescriptor	output ifNil: [output := Wsdl11SoapOperationEnvelopeDescriptor new].	output soapHeader add: aWsdl11SoapHeaderDescriptor.</body><body package="WSDLDescriptors">collectHeaderMessages	^(self collectHeaderMessagesFrom: self input), (self collectHeaderMessagesFrom: self output)</body><body package="WSDLDescriptors">collectHeaderMessagesFrom: inputOutput	| messages  |	messages := Set new.	(inputOutput notNil and: [ inputOutput soapHeader  notEmpty ]) 		ifTrue: [ inputOutput soapHeader do:[ :header | 					messages add: header message.					header faults do: [ :fault | messages add: fault message ]]].	^messages asOrderedCollection</body><body package="WSDLDescriptors">faults	^faults</body><body package="WSDLDescriptors">faults: aColl	faults := aColl</body><body package="WSDLDescriptors">input	^input</body><body package="WSDLDescriptors">input: aWsdl11SoapOperationEnvelopeDescriptor	input := aWsdl11SoapOperationEnvelopeDescriptor</body><body package="WSDLDescriptors">inputSoapBody	^self soapBodyFrom: self input</body><body package="WSDLDescriptors">inputSoapHeaders	^self soapHeadersFrom: self input</body><body package="WSDLDescriptors">output	^output</body><body package="WSDLDescriptors">output: aWsdl11SoapOperationEnvelopeDescriptor	output := aWsdl11SoapOperationEnvelopeDescriptor</body><body package="WSDLDescriptors">parameterOrder	^parameterOrder</body><body package="WSDLDescriptors">parameterOrder: aValue	parameterOrder := aValue</body><body package="WSDLDescriptors">parent	^parent</body><body package="WSDLDescriptors">parent: anObject	parent := anObject</body><body package="WSDLDescriptors">relativeUri	^relativeUriHolder value</body><body package="WSDLDescriptors">relativeUriHolder	^relativeUriHolder</body><body package="WSDLDescriptors">relativeUriHolder: aValueHolder	relativeUriHolder := aValueHolder</body><body package="WSDLDescriptors">selector	^selector</body><body package="WSDLDescriptors">selector: aValue	selector := aValue ifNotNil: [aValue asSymbol ] ifNil: [self halt.]</body><body package="WSDLDescriptors">setBindingDescriptor: aBindingDescriptor	self soapOperationDescriptor: aBindingDescriptor</body><body package="WSDLDescriptors">style	^self soapOperationDescriptor style</body></methods><methods><class-id>WebServices.Wsdl11OperationBindingDescriptor</class-id> <category>accessing soap attributes</category><body package="WSDLDescriptors">outputSoapBody	^self soapBodyFrom: self output</body><body package="WSDLDescriptors">outputSoapHeaders	^self soapHeadersFrom: self output</body><body package="WSDLDescriptors">soap11OperationDescriptor	^soapOperationDescriptor name type = 'operation11Type'		ifTrue: [soapOperationDescriptor]		ifFalse: [nil]</body><body package="WSDLDescriptors">soap12OperationDescriptor	^soapOperationDescriptor name type = 'operation12Type'		ifTrue: [soapOperationDescriptor]		ifFalse: [nil]</body><body package="WSDLDescriptors">soapAction	^self soapOperationDescriptor soapAction</body><body package="WSDLDescriptors">soapAction: aValue	self soapOperationDescriptor action: aValue</body><body package="WSDLDescriptors">soapActionRequired	^self soapOperationDescriptor at: #soapActionRequired ifAbsent: [true]</body><body package="WSDLDescriptors">soapActionRequired: aBoolean	^self soapOperationDescriptor at: #soapActionRequired put: aBoolean</body><body package="WSDLDescriptors">soapBodyFrom: aWsdl11SoapOperationEnvelopeDescriptor	aWsdl11SoapOperationEnvelopeDescriptor ifNil: [ ^nil].	^aWsdl11SoapOperationEnvelopeDescriptor soapBody</body><body package="WSDLDescriptors">soapHeadersFrom: aWsdl11SoapOperationEnvelopeDescriptor	aWsdl11SoapOperationEnvelopeDescriptor ifNil: [ ^nil].	^aWsdl11SoapOperationEnvelopeDescriptor soapHeader</body><body package="WSDLDescriptors">soapOperationDescriptor	^soapOperationDescriptor ifNil: [soapOperationDescriptor := Struct new]</body><body package="WSDLDescriptors">soapOperationDescriptor: aValue	soapOperationDescriptor := aValue</body><body package="WSDLDescriptors">soapStyle: aValue		self soapOperationDescriptor style: aValue</body></methods><methods><class-id>WebServices.Wsdl11OperationBindingDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">initialize	faults := OrderedCollection new: 5</body></methods><methods><class-id>WebServices.Wsdl11OperationBindingDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	aStream nextPutAll: self class name.	name ifNotNil: [aStream nextPutAll: ' name=', name type ].</body></methods><methods><class-id>WebServices.SoapHeaderMarshaler</class-id> <category>api -- unmarshal</category><body package="SOAPBinding">unmarshalElements: xmlElements from: marshalingContext	xmlElements do: [ :node | 		(self findSoapEntryHeaderMarshalerFor: node tag marshalingContext: marshalingContext) 			ifNotNil: [ :hMarshaler | 				(marshalingContext asPartMarshaler: hMarshaler source: node)					nodeContext: (OrderedCollection with: node);					acceptNodesAndUnmarshal: [ :mc | marshalingContext value add: mc value ]]].</body><body package="SOAPBinding">unmarshalElementsFrom: marshalingContext	self 		unmarshalElements: marshalingContext source realElements 		from: marshalingContext</body></methods><methods><class-id>WebServices.SoapHeaderMarshaler</class-id> <category>private</category><body package="SOAPBinding">findSoapEntryHeaderMarshalerFor: aNode marshalingContext: marshalingContext	| elemMarshaler |	(marshalingContext binding headerMarshalerFor: aNode) ifNotNil: [ :hrm | ^hrm ].	elemMarshaler :=  self binding elementMarshalerForTag: aNode ifAbsent: [^nil].	^(RelationMarshaler on: marshalingContext binding)		buildFromTag: elemMarshaler tag 		marshaler: elemMarshaler		headerEntryMarshaler: self binding soapHeaderEntryMarshaler;		yourself</body></methods><methods><class-id>WebServices.SoapHeaderMarshaler</class-id> <category>api -- marshal</category><body package="SOAPBinding">marshalElementsFrom: marshalingContext	(marshalingContext value isKindOf: SoapHeader) ifFalse: [self error: ((#WrongHeaderValueToMarshal &lt;&lt; #webservices &gt;&gt; 'Wrong header value to marshal: &lt;1s&gt;' ) expandMacrosWith: marshalingContext value class name) ].	marshalingContext value headerEntries do: [  :entry | 		(self findSoapEntryHeaderMarshalerFor: entry name marshalingContext: marshalingContext )			ifNotNil: [ :m | m setNodeAndMarshalFrom: (marshalingContext asPartMarshaler: m value: entry)]			ifNil: [self error: ((#ThereIsNoHeaderEntryMarshaler &lt;&lt; #webservices &gt;&gt; 'There is no header entry marshaler for: &lt;1s&gt; ') expandMacrosWith: entry name )]]</body></methods><methods><class-id>WebServices.Soap11HeaderEntry</class-id> <category>testing</category><body package="SOAPBinding">isNext	^self actor isNil 		ifTrue: [ false ]		ifFalse: [ self class nextRole match: self actor ]</body></methods><methods><class-id>WebServices.Soap11HeaderEntry</class-id> <category>initialization</category><body package="SOAPBinding">actor: aString	actor := aString</body></methods><methods><class-id>WebServices.Soap11HeaderEntry</class-id> <category>accessing</category><body package="SOAPBinding">actor	^actor</body></methods><methods><class-id>WebServices.Soap11HeaderEntry</class-id> <category>marshal </category><body package="SOAPBinding">getMustUnderstand	mustUnderstand ifNil: [^nil].	^mustUnderstand ifTrue: [1 ] ifFalse: [ nil ]</body><body package="SOAPBinding">setMustUnderstand: aNumber	aNumber = 1		ifTrue: [ mustUnderstand := true ]		ifFalse: [ mustUnderstand := false ]</body></methods><methods><class-id>WebServices.Soap11HeaderEntry</class-id> <category>printing</category><body package="SOAPBinding">printAttributesOn: aStream	super printAttributesOn: aStream.	self actor ifNotNil: [ aStream nextPutAll: '; actor: ', self actor ].</body></methods><methods><class-id>WebServices.Soap11HeaderEntry class</class-id> <category>instance creation</category><body package="SOAPBinding">targetRecipientMU0Value: anObject	^self 		value: anObject		mustUnderstand: false		actor: self nextRole</body><body package="SOAPBinding">targetRecipientMU1	^self new		mustUnderstand: true;		actor: self nextRole;		yourself</body><body package="SOAPBinding">targetRecipientMU1Value: anObject	^self 		value: anObject		mustUnderstand: true		actor: self nextRole</body><body package="SOAPBinding">targetRecipientValue: anObject	^self value: anObject actor: self nextRole</body><body package="SOAPBinding">value: anObject actor: aString	^self new		value: anObject;		actor: aString;		yourself</body><body package="SOAPBinding">value: anObject mustUnderstand: aBoolean actor: aString	^self new		value: anObject;		mustUnderstand: aBoolean;		actor: aString;		yourself</body></methods><methods><class-id>WebServices.Soap11HeaderEntry class</class-id> <category>constants</category><body package="SOAPBinding">nextRole	^'http://schemas.xmlsoap.org/soap/actor/next'</body><body package="SOAPBinding">roles	^#('next')</body></methods><methods><class-id>WebServices.WsdlExtensionDescriptor</class-id> <category>initialization</category><body package="WSDLDescriptors">preferredEncoding: aString	preferredEncoding := aString</body></methods><methods><class-id>WebServices.WsdlExtensionDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">preferredEncoding	^preferredEncoding</body></methods><methods><class-id>WebServices.WsdlParsingErrors class</class-id> <category>testing</category><body package="WSDLBinding">mayResume	^true</body></methods><methods><class-id>WebServices.Wsdl11MessageDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addPart: aWsdlMessagePartDescriptor	parts isNil 	ifTrue: [ parts := OrderedCollection new].	parts add: aWsdlMessagePartDescriptor</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aValue	name := aValue</body><body package="WSDLDescriptors">parts	^parts</body><body package="WSDLDescriptors">parts: aValue	parts := aValue</body></methods><methods><class-id>WebServices.Wsdl11MessageDescriptor</class-id> <category>printing</category><body package="WSDLDescriptors">printOn: aStream	aStream 		nextPutAll: self class name;		space;		nextPutAll: 'name';		nextPut: $=;		nextPutAll: name asString.	(parts notNil and: [ parts notEmpty ])		ifTrue:			[ aStream nextPutAll: ' parts= "'.			parts 					do: [ :part | aStream nextPutAll: part name asString]					separatedBy: [aStream nextPut: $,].			aStream nextPut: $"].</body></methods><methods><class-id>WebServices.Wsdl11MessageDescriptor</class-id> <category>comparing</category><body package="WSDLDescriptors">= aMessageDescriptor	^self name = aMessageDescriptor name</body><body package="WSDLDescriptors">hash	^name hash</body></methods><methods><class-id>WebServices.ClientMessageInterceptor</class-id> <category>processing callbacks</category><body package="WSDLBinding">receivingReply: aReply in: aTransport</body><body package="WSDLBinding">receivingReplyEnvelope: aReply in: aTransport</body><body package="WSDLBinding">sendingRequest: aRequest in: aTransport</body><body package="WSDLBinding">sendingRequestDOM: aDOM</body><body package="WSDLBinding">sendingRequestEnvelope: aRequest in: aTransport</body></methods><methods><class-id>WebServices.ClientMessageInterceptor</class-id> <category>printing</category><body package="WSDLBinding">printOn: aStream		aStream nextPutAll: self class name</body></methods><methods><class-id>WebServices.ClientMessageInterceptor</class-id> <category>accessing</category><body package="WSDLBinding">dispatcher	^dispatcher</body><body package="WSDLBinding">dispatcher: aSoapInterceptorDispatcher	dispatcher := aSoapInterceptorDispatcher</body></methods><methods><class-id>WebServices.ClientMessageInterceptor class</class-id> <category>accessing</category><body package="WSDLBinding">detectInterceptorNamed: aSymbol in: aNamespace	^ClientMessageInterceptor subclasses 		detect: [ :cl | 				(cl headerNames includes: aSymbol ) 					and: [ cl environment name = aNamespace ]]		ifNone: [nil]</body><body package="WSDLBinding">headerNames	^#()</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>accessing</category><body package="WSDLBinding">action	^self transport action</body><body package="WSDLBinding">inputFaultHeaderTags	| coll |	coll := OrderedCollection new.	self inputFaultMarshalers  do: [ :each | 		each headers ifNotNil: [ :headers | headers do: [ :mx | coll add: mx  headerTag ]]].	^coll</body><body package="WSDLBinding">inputFaultMarshalers	^inputFaultMarshalers</body><body package="WSDLBinding">inputFaultMarshalers: aCollSoapParameterMarshaler		inputFaultMarshalers := aCollSoapParameterMarshaler</body><body package="WSDLBinding">inputHeaderTags	^self inputBodyMarshaler headers		ifNotNil: [ :headers | headers collect: [ :mx | mx  headerTag ]]		ifNil: [#()].</body><body package="WSDLBinding">interfaceDescriptor	^interfaceDescriptor</body><body package="WSDLBinding">interfaceDescriptor: aWsdl20InterfaceOperationDescriptor 	interfaceDescriptor := aWsdl20InterfaceOperationDescriptor</body><body package="WSDLBinding">name	^interfaceDescriptor name</body><body package="WSDLBinding">name: aNodeTag	descriptor interfaceDescriptor name: aNodeTag</body><body package="WSDLBinding">outputFaultHeaderTags	| coll |	coll := OrderedCollection new.	self outputFaultMarshalers  do: [ :each | 		each headers ifNotNil: [ :headers | headers do: [ :mx | coll add: mx  headerTag ]]].	^coll</body><body package="WSDLBinding">outputFaultMarshalers	^outputFaultMarshalers</body><body package="WSDLBinding">outputFaultMarshalers: aCollSoapParameterMarshaler	outputFaultMarshalers := aCollSoapParameterMarshaler</body><body package="WSDLBinding">outputHeaderBindings	^self outputBodyMarshaler ifNotNil: [ :b | b  headers ]</body><body package="WSDLBinding">outputHeaderTags	^(self outputBodyMarshaler notNil and: [self outputBodyMarshaler headers notNil ])		ifTrue: [ | coll |				coll := OrderedCollection new.				self outputBodyMarshaler headers do: [ :mx | mx mustUnderstand ifTrue: [ coll add: mx  headerTag] ].				coll]		ifFalse: [#()]</body><body package="WSDLBinding">rpcSignature	^rpcSignature</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>testing</category><body package="WSDLBinding">isInOnly	^self interfaceDescriptor isInOnly</body><body package="WSDLBinding">isOneWay	^self interfaceDescriptor isOneWay</body><body package="WSDLBinding">isRobustInOnly	^self interfaceDescriptor isRobustInOnly</body><body package="WSDLBinding">isRpc	^style = WsdlBinding wsdl20_rpc_uri</body><body package="WSDLBinding">needsFaultHeader: aSymbol	outputFaultMarshalers ifNil: [^false].	outputFaultMarshalers do: [ :fault |		fault headers ifNotNil: [			[ (fault headers anySatisfy: [ :hbinding | hbinding partMarshaler relation getSelector = aSymbol asSymbol ]) ifTrue: [^true]]]].	^false</body><body package="WSDLBinding">needsInputHeader: aSymbol	^self inputBodyMarshaler headers 		ifNotNil: [ :headers | headers anySatisfy: [ :hbinding | hbinding partMarshaler relation getSelector = aSymbol asSymbol ]]		ifNil: [false]</body><body package="WSDLBinding">needsOutputHeader: aSymbol	^self outputBodyMarshaler headers 		ifNotNil: [ :headers | headers anySatisfy: [ :hbinding | hbinding partMarshaler relation getSelector = aSymbol asSymbol ]]		ifNil: [ false]</body><body package="WSDLBinding">usesIRIStyle	^'get' match: self transport verb</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>marshal request</category><body package="WSDLBinding">deserialize: aTransportEntity	^self transport transport			deserialize: aTransportEntity  url			marshalers: self inputBodyMarshaler partMarshaler 			endpoint: self binding port address</body><body package="WSDLBinding">inputHeaderBindings	^self inputBodyMarshaler headers</body><body package="WSDLBinding">marshalRequestIn: aTransportEntity with: smalltalkEntity header: aSoapHeader" Marshal Smalltalk object into something ready for transport "	aTransportEntity method = 'GET' ifTrue: [^self serialize: aTransportEntity with: smalltalkEntity arguments ].	^self 		marshalRequestWith: (self setRequestArgumentsFrom: smalltalkEntity ) asArray 		header: aSoapHeader.</body><body package="WSDLBinding">marshalRequestWith: anArguments header: header" Marshal Smalltalk object and header objects into XML Element"	| args m |	args := (self isRpc and: [ (m := self inputBodyMarshaler typeMarshaler) notNil])		ifTrue: [anArguments copyFrom: 1 to: m relations size ] 		ifFalse: [anArguments].	^self 		marshalArguments: args 		header: header 		bodyMarshaler: self inputBodyMarshaler		headerMarshaler: self inputBodyMarshaler headers</body><body package="WSDLBinding">prepareRequestFor: aSoapRequest		^self transport prepareRequestFor: aSoapRequest.</body><body package="WSDLBinding">serialize: aTransportEntity with: arguments" http://www.w3.org/TR/wsdl20-adjuncts/#_http_location_template    * either by enclosing the element name within curly braces. For example, temperature/{town}.     * or by enclosing the element name within exclamated-curly braces, to include the element without percent-encoding. For example, temperature/{!town}. "	| url |	url := self transport transport			serialize: arguments			marshalers: self inputBodyMarshaler partMarshaler 			into: aTransportEntity requestLine url copy.	aTransportEntity requestLine url: url.	^nil</body><body package="WSDLBinding">setRequestArgumentsFrom: aMessage 	|  argCollection   relations struct marshaler | 	argCollection := aMessage arguments.	(marshaler := self inputBodyMarshaler typeMarshaler) ifNil: [^argCollection].	^self  isRpc 		ifTrue: [( argCollection copyFrom: 1 to: marshaler relations size ) collect: [ :arg | arg evaluate ] ]		ifFalse: 	[ (self inputBodyMarshaler  isWrapped					and: [marshaler relations size = argCollection size ]) 				ifTrue: [ 	relations := marshaler relations.						struct := Struct new.						1 to: relations size do: [ :ind |							struct at: (( relations at: ind) relation name asSymbol) put: (argCollection at: ind)].						Array with: struct ]				 ifFalse: [argCollection]].</body><body package="WSDLBinding">smalltalkEntityFromRpcRequest: bodyContents selector: requestSelector" Opentalk callback"	|  args  |	args := Array new: requestSelector numArgs.	self rpcSignature   doWithIndex: [ :assoc :ind | 		assoc value = #in ifTrue: [ args at: ind put: ( bodyContents at: assoc key asSymbol)].		assoc value = #inout  ifTrue: [args at: ind put: ( bodyContents at: assoc key asSymbol) asOutputParameter].		assoc value = #out  ifTrue: [args at: ind put: nil asOutputParameter]].	^args</body><body package="WSDLBinding">unmarshalAsMessage: anXMLElement	" Opentalk callback"	^self inputBodyMarshaler elementType = '#none'		ifTrue: [Message selector: (self binding findSelectorForOperation: self name type) arguments: Array new ]		ifFalse: [super unmarshalAsMessage: anXMLElement ]</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>marshal response</category><body package="WSDLBinding">marshalResponseWith: anArguments header: header" Marshal Smalltalk object and header objects into XML Element"	^self 		marshalArguments: anArguments 		header: header 		bodyMarshaler: self outputBodyMarshaler		headerMarshaler: self outputBodyMarshaler headers</body><body package="WSDLBinding">outputFaultMarshalerFor: aFault	^aFault detailContents ifNotNil: [ :contents | 		outputFaultMarshalers 			detect: [ :faultBinding | faultBinding partMarshaler typeMarshaler smalltalkClass = contents first class] 			ifNone: [nil] ].</body><body package="WSDLBinding">raiseAsUserHeaderError: anException	(UserHeader12Error exception: anException ) raise</body><body package="WSDLBinding">resultFrom:  envelope arguments: arguments valueDo: aBlock faultDo: faultBlock"Opentalk-Soap callback."	| value bodyResult |	envelope isFault ifTrue: [ ^faultBlock value: (self processFault: envelope faultContents asSpecificFault)].	value := self isRpc 		ifTrue: [ self rpcValue: envelope bodyContents  requestArguments: arguments ]		ifFalse: [bodyResult := envelope bodyContents.				value := (bodyResult isStruct and: [bodyResult keys first = #result ]) ifTrue: [bodyResult values first] ifFalse: [bodyResult].				self class wrapDocumentLiteralResult ifTrue: [ OrderedCollection with: value ] ifFalse: [ value ] ].	aBlock value: envelope value: value.</body><body package="WSDLBinding">rpcValue: struct requestArguments: anArguments	| marshaler relation  value return |	marshaler := self outputBodyMarshaler  typeMarshaler.	self rpcSignature doWithIndex: [ :assoc :ind |		assoc value = #in			ifFalse: [ relation := marshaler relations detect: [ :each | each name type = assoc key ] ifNone: [  nil].					value := marshaler aspectImplementation  getAspect: relation relation  for: struct context: (MarshalingContext new)].		(assoc value = #out or: [assoc value = #inout]) ifTrue: [ (anArguments at: ind) value: value ].		assoc value = #return ifTrue: [ return := value ]].	^self class rpcResultAsStruct 		ifTrue: [ struct ]		ifFalse: [ return ]</body><body package="WSDLBinding">setOneWayResponseCode: anHttpResponse"http://www.w3.org/TR/2007/REC-wsdl20-adjuncts-20070626/#http-operation-decl-destFor successful responses, the HTTP response code MUST be:    202 when the MEP is 'http://www.w3.org/ns/wsdl/in-only'    204 when the MEP is 'http://www.w3.org/ns/wsdl/robust-in-only' " 	self isInOnly ifTrue: [ 		^anHttpResponse isSuccess 			ifTrue: [ anHttpResponse statusLine code: '202'  ]			ifFalse: [ anHttpResponse statusLine code: '500' ]].	"Failed code will be set when the fault will be marshaled "	(anHttpResponse isSuccess  and: [self isRobustInOnly]) 		ifTrue: [anHttpResponse statusLine code: '204'  ].</body><body package="WSDLBinding">setResponseArguments: anArguments value: reply"Opentalk-Soap callback. "	| coll m |	^self isRpc		ifTrue: [coll := OrderedCollection new.			self rpcSignature  doWithIndex: [ :assoc :ind |			(assoc value = #inout or: [ assoc value = #out]) ifTrue: [ coll add: (anArguments at: ind) ].			assoc value = #return ifTrue: [ coll addAll: reply ] ].			coll asArray]		ifFalse:[self isOneWay ifTrue: [^nil].				(m := self outputBodyMarshaler partMarshaler) ifNil: [^reply].				(self isMarshalerResultWrapper: m typeMarshaler)					ifTrue: [ 	Array with: (Struct new at: (m typeMarshaler relations first relation getSelector) put: reply first; yourself)]					ifFalse: [ reply ] ]</body><body package="WSDLBinding">unmarshalResponse: anXMLElement" Unmarshal XML Element in to Smalltalk object "	^self unmarshalSoapEnvelope: anXMLElement</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>wsdl -- initialization</category><body package="WSDLBinding">initializeFrom: aBindingDescriptor binding: aWsdlBinding	interfaceDescriptor ifNil: [ ^WsdlParsingErrors raiseRequestErrorString: (#ThereIsNoInterfaceDescriptorSet &lt;&lt; #webservices &gt;&gt; 'There is no interface descriptor set for the operation binding')].	binding := aWsdlBinding.	transport := aWsdlBinding transport copy.	(aBindingDescriptor operations			detect: [ :operationx | operationx name = interfaceDescriptor name] 			ifNone: [nil])  ifNotNil: [ :operationBindingDescriptor |		descriptor := operationBindingDescriptor.		transport setSpecificOptionsFrom: descriptor soapBinding.].	style := ( interfaceDescriptor style				ifNil: [ binding bindingDescriptor interfaceDescriptor styleDefault ]				ifNotNil: [ :interfaceStyle | interfaceStyle]).</body><body package="WSDLBinding">setRpcStyleFrom: interfaceOperationDescriptor	| tokens name type relation marshaler |	 "We need to add an additional relation to the part marshaler for the result reference. Let's create  the part marshaler copy"	self outputBodyMarshaler partMarshaler marshaler: self outputBodyMarshaler typeMarshaler copy.	(marshaler :=  self outputBodyMarshaler typeMarshaler) qualified: true.	marshaler relations do: [ :each | each qualified: true].	interfaceOperationDescriptor rpcSignature ifNotNil: 		[ :aString | 		tokens := Array readFrom: ( '#(',interfaceOperationDescriptor rpcSignature, ')' ) readStream.		rpcSignature :=OrderedCollection new.		1 to: tokens size  by: 2 do: [ :index |   			name := ( tokens at: index) asString.			type := tokens at: (index + 1).			type = #return				ifTrue: [relation := marshaler elementMarshalers 							detect: [ :rel | rel tag type = name ] 							ifNone: [self error: ((#NoMarshalerForRPCParameter1s &lt;&lt; #webservices &gt;&gt; ' There is no marshaler for RPC parameter: &lt;1s&gt;') expandMacrosWith: name) ].						marshaler addElementMarshaler:  (RPCReturnEncoder fromTag: relation tag)].			rpcSignature add: name -&gt; type  ]].</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>private creating script</category><body package="WSDLBinding">anyHeaderBinding	self inputBodyMarshaler headers ifNil: [^nil].	^(self inputBodyMarshaler headers collect: [ :hBinding | hBinding partMarshaler ])</body><body package="WSDLBinding">argumentMarshalers	| argMarshalers bodyMarshaler |	self inputBodyMarshaler hasInputParameters ifFalse: ["there is no input parameters" ^#() ].	argMarshalers := OrderedCollection new.	bodyMarshaler := self inputBodyMarshaler bodyMarshaler typeMarshaler.	(bodyMarshaler isObjectTypeMarshaler and: [bodyMarshaler isDictionaryType and: [bodyMarshaler relations notEmpty]])		ifTrue: [ (self selector tokensBasedOn: $: ) size - 1 = bodyMarshaler relations size					ifTrue: [ argMarshalers addAll: bodyMarshaler relations ]					ifFalse: [argMarshalers add: bodyMarshaler]]		ifFalse: [argMarshalers add: bodyMarshaler ].	^argMarshalers</body><body package="WSDLBinding">bodyExceptions	|  fmarshaler    excNames |	excNames  := OrderedCollection new.	self  outputFaultMarshalers isEmpty ifTrue: [^excNames ].	self outputFaultMarshalers 		do: [ :faultBinding |  			faultBinding partMarshalers				do: [ :marshaler |					fmarshaler := marshaler typeMarshaler. 					"Set exceptions for script "					(fmarshaler isComplexTypeMarshaler and: [fmarshaler smalltalkClassName ~= 'Struct'])						ifTrue: [ excNames add: fmarshaler smalltalkClass ].					fmarshaler isSimpleType ifTrue: [ excNames add: Soap12Fault ]]].	^excNames</body><body package="WSDLBinding">headerPartMarshalers	^self inputBodyMarshaler headers collect: [ :hBinding | hBinding partMarshaler ]</body><body package="WSDLBinding">printWsdlClientScriptOn: aStream marshalers: marshalers	aStream nextPutAll: 'args := Array with: ('.	(marshalers size = 1 and: [marshalers first isSimpleType])		ifTrue: [marshalers first  printArgsOn: aStream indentation: 3.				^aStream nextPutAll: ') '].	aStream cr;tab: 2; nextPutAll: 'Struct new'.	marshalers  do: [ :each |		aStream 			cr; tab: 3;			nextPutAll: 'at: #', each relation getSelector, ' put: '.		each  printArgsOn: aStream indentation: 3.		aStream nextPut: $;].	aStream cr; tab: 3; nextPutAll: 'yourself).'; crtab.</body><body package="WSDLBinding">returnMarshaler	(self outputBodyMarshaler isNil or: [self outputBodyMarshaler partMarshalers isEmpty] ) ifTrue: [^nil].	^self outputBodyMarshaler partMarshalers first</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>private</category><body package="WSDLBinding">validateHeaders: soapHeader with: headerBindings	headerBindings ifNil: [^nil].	headerBindings do: [ :headerBinding | 		headerBinding partMarshaler isMandatory ifTrue: [			soapHeader ifNil: [ MissingRequiredHeader raiseErrorString: (#ThereisNoRequiredSoapHeaderForMessage &lt;&lt; #webservices &gt;&gt;'There is no required SoapHeader for the message' )].			soapHeader headerAt: headerBinding headerTag type ifAbsent: [ MissingRequiredHeader raiseErrorString: (#MissingRequiredHeaderEntry &lt;&lt; #webservices &gt;&gt;'The SoapHeader is missing required header entry: &lt;1s&gt; ' expandMacrosWith: headerBinding headerTag type )]].			(soapHeader headerAt: headerBinding headerTag type ifAbsent: [nil]) 				ifNotNil: [ :headerValue | headerValue mu: headerBinding  mustUnderstand]].</body></methods><methods><class-id>WebServices.SelectorMap</class-id> <category>printing</category><body package="WSDLBinding">printBinding	| stream |	stream := String new writeStream.	stream 		nextPutAll: self bindingNS;		nextPut: $_;		nextPutAll: self bindingName.	^stream contents</body><body package="WSDLBinding">printMap	| stream |	stream := String new writeStream.	self printMapOn: stream.	^stream contents</body><body package="WSDLBinding">printMapOn: aStream	self asElement wsPrintOn: aStream depth: 0</body><body package="WSDLBinding">printOn: aStream	operations isNil		ifTrue: [aStream nextPutAll: self class name]		ifFalse: [aStream nextPutAll: operations printString ]</body></methods><methods><class-id>WebServices.SelectorMap</class-id> <category>accessing</category><body package="WSDLBinding">acceptBinding: aWsdlBinding		 ^self binding = aWsdlBinding name</body><body package="WSDLBinding">asServiceMapWith: aWsdlBinding	| map |	map := ServiceMap new.	aWsdlBinding serviceClass ifNotNil: [ :servClass | map serviceClass: servClass ].	aWsdlBinding interfaceDescriptor ifNotNil: [ :int | map interface: int name ].	self operations associationsDo: [ :assoc | map operations add: assoc ].	^map</body><body package="WSDLBinding">binding	^binding</body><body package="WSDLBinding">bindingNS	^self binding namespace</body><body package="WSDLBinding">bindingName	^self binding type</body><body package="WSDLBinding">operationFor: selSymbol 	^self operationFor: selSymbol ifAbsent: [nil]</body><body package="WSDLBinding">operationFor: selSymbol ifAbsent: aBlock	^operations keyAtValue: selSymbol ifAbsent: aBlock</body><body package="WSDLBinding">operations	^operations</body><body package="WSDLBinding">selectorFor: stringOrNode	^self selectorFor: stringOrNode ifAbsent: [ nil ]</body><body package="WSDLBinding">selectorFor: stringOrNode ifAbsent: aBlock	| str |	str := stringOrNode isString			ifTrue: [stringOrNode]			ifFalse: [stringOrNode type].	^operations at: str ifAbsent: aBlock</body></methods><methods><class-id>WebServices.SelectorMap</class-id> <category>initialize-release</category><body package="WSDLBinding">addOperation: aNode selector: aSymbol	self addOperationNamed: aNode type selector: aSymbol</body><body package="WSDLBinding">addOperationNamed: aString selector: aSymbol	operations ifNil: [ operations := Dictionary new].	operations at: aString put: aSymbol asSymbol</body><body package="WSDLBinding">bindingTag: aNodeTag	binding := aNodeTag</body><body package="WSDLBinding">setSelector: aSymbol forOperation: aNode	operations ifNil: [ operations := Dictionary new].	operations at: aNode type put: aSymbol</body></methods><methods><class-id>WebServices.SelectorMap</class-id> <category>utilities</category><body package="WSDLBinding">asElement	self class loadBinding.	^XMLObjectMarshalingManager		marshal: self 		atNamespace: self class targetNamespace.</body><body package="WSDLBinding">storeToClass: aClass	self storeToClass: aClass selector: 'selectorMap'</body><body package="WSDLBinding">storeToClass: aClass selector: aString	| stream category |	category := 'accessing'. 	stream  := (String new: 1024) writeStream.	stream reset.	stream 		nextPutAll: aString;		crtab;		nextPutAll: ' " WebServices.SelectorMap loadFromClass: ', aClass fullName, ' " ';		crtab;		nextPutAll: '^', self printMap printString.	aClass class compile: stream contents classified: category.</body></methods><methods><class-id>WebServices.SelectorMap</class-id> <category>marshaling</category><body package="WSDLBinding">getBinding	^Struct new			at: #name put: self bindingName; 			at: #namespace put: self bindingNS;			yourself</body><body package="WSDLBinding">getOperations	| aColl struct |	aColl := OrderedCollection new: operations size.	operations keysAndValuesDo: 		[ :key :value |		struct := Struct new					at: #name put: key;					at: #selector put: value;					yourself.		aColl add: struct ].	^aColl</body><body package="WSDLBinding">setBinding: aStruct	self bindingTag: (XML.NodeTag qualifier: '' ns: aStruct namespace  type: (aStruct at: #name))</body><body package="WSDLBinding">setOperations: aColl	operations := Dictionary new: aColl size.	aColl do: [ :struct | operations at: ( struct at: #name) put: (struct at: #selector ) ].</body></methods><methods><class-id>WebServices.SelectorMap class</class-id> <category>defaults</category><body package="WSDLBinding">targetNamespace	^'urn:visualworks:operationSelectors'</body><body package="WSDLBinding">x2oBinding"( WebServices.XMLObjectBinding loadFrom: self x2oBinding readStream) "^'&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding name="OperationSelectors" 	defaultClassNamespace="WebServices" 	useInlineType="false"	targetNamespace="', self targetNamespace,'" 	elementFormDefault="qualified" 	xmlns:tns="', self targetNamespace,'"  	xmlns:xsd="http://www.w3.org/2001/XMLSchema" 	xmlns="urn:visualworks:VWSchemaBinding"&gt;		&lt;object name="selectorMap" smalltalkClass="SelectorMap"&gt;			&lt;element name="binding" ref="tns:BindingStruct" setSelector="setBinding:" getSelector="getBinding"/&gt;			&lt;element name="operation" ref="tns:OperationStruct" maxOccurs="unbounded" setSelector="setOperations:"  getSelector="getOperations"/&gt;		&lt;/object&gt;		&lt;struct name="OperationStruct" smalltalkClass="Struct"&gt;			&lt;attribute name="name" ref="xsd:string" minOccurs="1"/&gt;			&lt;attribute name="selector" minOccurs="1"&gt;				&lt;simple name="string"  id="ByteSymbol"/&gt;			&lt;/attribute&gt;		&lt;/struct&gt;		&lt;struct name="BindingStruct" smalltalkClass="Struct"&gt;			&lt;attribute name="name" ref="xsd:string"/&gt;			&lt;attribute name="namespace" ref="xsd:string"/&gt;		&lt;/struct&gt;	&lt;sequence_of name="selectorMaps"&gt;		&lt;implicit  ref="selectorMap"/&gt;	&lt;/sequence_of&gt;	&lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.SelectorMap class</class-id> <category>class initialization</category><body package="WSDLBinding">initialize	" self initialize "	self loadBinding.</body><body package="WSDLBinding">loadBinding	^WebServices.XMLObjectBinding 		bindingAtNamespace: self targetNamespace		ifAbsent: [ WebServices.XMLObjectBinding loadFrom: self x2oBinding readStream].</body></methods><methods><class-id>WebServices.SelectorMap class</class-id> <category>load map</category><body package="WSDLBinding">loadFrom: aStream	| map |	self loadBinding.	map := XMLObjectMarshalingManager 					unmarshal: aStream 					atNamespace: self targetNamespace.	^map</body></methods><methods><class-id>WebServices.SelectorMap class</class-id> <category>instance creation</category><body package="WSDLBinding">binding: aNode	^self new		bindingTag: aNode;		yourself</body></methods><methods><class-id>WebServices.SelectorMap class</class-id> <category>accessing</category><body package="WSDLBinding">toolListIcon	^GeneralIcons deprecationWarning</body></methods><methods><class-id>WebServices.Wsdl11SoapOperationFaultDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">fault	^fault</body><body package="WSDLDescriptors">fault: anObject	fault := anObject</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: anObject	name := anObject</body><body package="WSDLDescriptors">version	^version</body><body package="WSDLDescriptors">version: anObject	version := anObject</body></methods><methods><class-id>WebServices.Wsdl11SoapOperationFaultDescriptor</class-id> <category>private</category><body package="WSDLDescriptors">faultChoice		| key |	key := (version =  '1.2' ifTrue: [ 'fault12' ] ifFalse: [ 'fault11' ]).	^key -&gt; fault</body><body package="WSDLDescriptors">faultChoice: anAssociation	| theAssociation |	(theAssociation := anAssociation) isStruct		ifTrue: [theAssociation := anAssociation associations first].	version := theAssociation key asString = 'fault12' ifTrue: [self setVersion12] ifFalse: [self setVersion11].	self fault: theAssociation value.</body><body package="WSDLDescriptors">setVersion11		version :=   '1.1'</body><body package="WSDLDescriptors">setVersion12		version :=   '1.2'</body></methods><methods><class-id>WebServices.ServiceMap</class-id> <category>initialize-release</category><body package="WSDLBinding">addOperation: aStringOrNode selector: aSymbol	| opName |	opName := aStringOrNode isString ifTrue: [ aStringOrNode ] ifFalse: [ aStringOrNode type ].	operations add: opName -&gt; aSymbol asSymbol</body><body package="WSDLBinding">addOperationNamed: aString selector: aSymbol	self addOperation: aString selector: aSymbol</body><body package="WSDLBinding">initialize	operations := OrderedCollection new.</body><body package="WSDLBinding">operationFor: aSymbol 	^self operationFor: aSymbol ifAbsent: [nil]</body><body package="WSDLBinding">operationFor: aSymbol ifAbsent: aBlock	^(self operations detect: [ :assoc | assoc value = aSymbol ] ifNone: [^aBlock value]) key</body><body package="WSDLBinding">selectorFor: anOperationName	^self selectorFor: anOperationName afAbsent: [nil]</body><body package="WSDLBinding">selectorFor: anOperationName afAbsent: aBlock	| opName |	opName := anOperationName isString ifTrue: [anOperationName] ifFalse: [anOperationName type].	^(self operations detect: [ :assoc | assoc key = opName ] ifNone: [^aBlock value]) value</body></methods><methods><class-id>WebServices.ServiceMap</class-id> <category>accessing</category><body package="WSDLBinding">asElement	self class loadBinding.	^XMLObjectMarshalingManager		marshal: self 		atNamespace: self class targetNamespace.</body><body package="WSDLBinding">asServiceMapWith: aWsdlBinding</body><body package="WSDLBinding">interface	^interface</body><body package="WSDLBinding">interface: aNodeTag	interface := aNodeTag</body><body package="WSDLBinding">operations	^operations</body><body package="WSDLBinding">operations: aCollection	operations := aCollection</body><body package="WSDLBinding">serviceClass	^serviceClass</body><body package="WSDLBinding">serviceClass: anObject	serviceClass := anObject</body><body package="WSDLBinding">serviceClassName	^serviceClass ifNotNil: [serviceClass  fullName]</body><body package="WSDLBinding">serviceClassName: aString	serviceClass := aString asSymbol asQualifiedReference valueOrDo: [ self error: ((#ThereIsNoSuchBindingReference &lt;&lt; #webservices &gt;&gt; 'There is no such binding reference: &lt;1s&gt; ') expandMacrosWith: aString)  ]</body></methods><methods><class-id>WebServices.ServiceMap</class-id> <category>utilities</category><body package="WSDLBinding">storeToClass: aClass	self storeToClass: aClass selector: 'serviceMap'</body><body package="WSDLBinding">storeToClass: aClass selector: aString	| stream category |	category := 'accessing'. 	stream  := (String new: 1024) writeStream.	stream reset.	stream 		nextPutAll: aString;		crtab;		nextPutAll: ' " WebServices.ServiceMap loadFrom: ', aClass name,' ', aString, ' readStream " ';		crtab;		nextPutAll: '^', self printMap printString.	aClass class compile: stream contents classified: category.</body></methods><methods><class-id>WebServices.ServiceMap</class-id> <category>testing</category><body package="WSDLBinding">acceptBinding: aWsdlBinding		 ^self interface = aWsdlBinding bindingDescriptor interfaceDescriptor name</body></methods><methods><class-id>WebServices.ServiceMap</class-id> <category>printing</category><body package="WSDLBinding">printMap	| stream |	stream := String new writeStream.	self printMapOn: stream.	^stream contents</body><body package="WSDLBinding">printMapOn: aStream	self asElement wsPrintOn: aStream depth: 0</body><body package="WSDLBinding">printOn: aStream	aStream nextPutAll: self class name.	interface ifNotNil: [ aStream cr; nextPutAll: interface expandedName, ' -&gt; '].	serviceClass ifNotNil: [ aStream nextPutAll:  serviceClass fullName].	aStream cr.	operations do: [:assoc | aStream nextPutAll: assoc key, '-&gt;#', assoc value asString; cr]</body></methods><methods><class-id>WebServices.ServiceMap class</class-id> <category>class initialization</category><body package="WSDLBinding">initialize	" self initialize "	self loadBinding</body><body package="WSDLBinding">loadBinding	" self loadBinding "	^WebServices.XMLObjectBinding 		bindingAtNamespace: self targetNamespace		ifAbsent: [ WebServices.XMLObjectBinding loadFrom: self x2oBinding readStream].</body></methods><methods><class-id>WebServices.ServiceMap class</class-id> <category>wsdl schema</category><body package="WSDLBinding">targetNamespace	^'urn:visualworks:serviceMap'</body><body package="WSDLBinding">x2oBinding"( WebServices.XMLObjectBinding loadFrom: self x2oBinding readStream) "^'&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding name="ServiceMap" 	defaultClassNamespace="WebServices" 	useInlineType="false"	targetNamespace="', self targetNamespace,'" 	elementFormDefault="qualified" 	xmlns:tns="', self targetNamespace,'"  	xmlns:xsd="http://www.w3.org/2001/XMLSchema" 	xmlns="urn:visualworks:VWSchemaBinding"&gt;		&lt;object name="serviceMap" smalltalkClass="ServiceMap"&gt;			&lt;element name="serviceClass" aspect="serviceClassName" ref="xsd:string" minOccurs="0"/&gt;			&lt;element name="interface" ref="xsd:QName"/&gt;			&lt;element name="operation" aspect="operations" minOccurs="0" maxOccurs="*"&gt;				&lt;object name="operation" smalltalkClass="Association"&gt;					&lt;attribute name="name" aspect="key" ref="xsd:string"/&gt;					&lt;attribute name="selector" aspect="value"&gt;						&lt;simple name="string"  id="ByteSymbol"/&gt;					&lt;/attribute&gt;				&lt;/object&gt;			&lt;/element&gt;		&lt;/object&gt;	&lt;sequence_of name="serviceMaps"&gt;		&lt;element name="serviceMap" ref="tns:serviceMap"/&gt;	&lt;/sequence_of&gt;	&lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.ServiceMap class</class-id> <category>utilities</category><body package="WSDLBinding">storeMaps: aCollection toClass: aClass selector: aString"self 	storeMaps: (OrderedCollection 					with:(( self fromServiceClass: WSSearchServices ) interface: (NodeTag qualifier: '' ns: 'myTargetNamespace' type: 'WSSearchServices')) 					with: (( self fromServiceClass: WSGeneralServices ) interface: (NodeTag qualifier: '' ns: 'myTargetNamespace' type: 'WSGeneralServices')) )	toClass: OpentalkServer 	selector: 'serviceMap'"	| stream  maps binding marshaler |	binding := self loadBinding.	marshaler := binding marshalers detect: [ :m | m path type = 'serviceMaps' ] ifNone: [nil].	maps := binding  marshal: aCollection with: marshaler.	stream  := (String new: 1024) writeStream.	stream 		nextPutAll: aString;		crtab;		nextPutAll: ' " WebServices.ServiceMap loadFrom: ', aClass name,' ', aString, ' readStream " ';		crtab;		nextPutAll: '^', maps printString printString.	aClass class compile: stream contents classified:  'accessing'</body></methods><methods><class-id>WebServices.ServiceMap class</class-id> <category>instance creation</category><body package="WSDLBinding">fromServiceClass: aClass"The method create a service map from a service class with operation pragmas. You need to specify interface node tag after the map is created "	"(( self fromServiceClass: WSSearchServices ) interface: (NodeTag qualifier: '' ns: 'myTargetNamespace' type: 'SearchInterface')) asElement " 	^self fromServiceClass: aClass protocol: #'public api'</body><body package="WSDLBinding">fromServiceClass: aClass protocol: aSymbol"The method create a service map from a service class with operation pragmas. You need to specify interface node tag after the map is created "	" self fromServiceClass: WSSearchServices protocol: #'public api' " 	| map |	map := self new.	map serviceClass: aClass.	aClass selectorsAndMethodsDo: [ :sel :meth | | pragmas px | 		(((px := aClass organization categoryOfItem: sel) = ClassOrganizer defaultProtocol or: [aSymbol match: px ])			and: [(pragmas := meth attributeMessages) notNil ])			ifTrue: [pragmas do: [ :message |  					message selector = #operationName:  ifTrue: [ map addOperation: message arguments first selector: sel ]]]].	^map</body><body package="WSDLBinding">loadFrom: aStream"ServiceMap loadFrom: '&lt;ns:serviceMap xmlns:ns='urn:visualworks:selectorMap' xmlns:ns0='myTargetNamespace'&gt;	&lt;ns:serviceClass&gt;WebServices.WSSearchServices&lt;/ns:serviceClass&gt;	&lt;ns:interface&gt;ns0:SearchInterface&lt;/ns:interface&gt;	&lt;ns:operations key='SearchByWord' value='searchByTitleWord:includeAffiliatedLibraries:'&gt;&lt;/ns:operations&gt;&lt;/ns:serviceMap&gt;' readStream."	| map |	self loadBinding.	map := XMLObjectBinding unmarshal: aStream atNamespace: self targetNamespace.	^map isSequenceable		ifTrue: [ map ]		ifFalse: [ OrderedCollection with: map ]</body><body package="WSDLBinding">new	^self basicNew initialize</body></methods><methods><class-id>WebServices.Wsdl20SoapFaultDescriptor</class-id> <category>accessing</category><body package="WSDLDescriptors">addSoapFaultCodeNamed: aString"http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#faultcodes"	(self class soapFaultCodes includes: aString asSymbol)		ifFalse: [self error: (#StringDoesnotMatchSoapFaultCodes &lt;&lt; #webservices &gt;&gt;'The string doesn''t match SOAP 1.2 Fault Codes. For more information see http://www.w3.org/TR/soap12-part1/#faultcodes ')].	soapFaultCode := (aString asSymbol = #any		ifTrue: [ '#any' ]		ifFalse: [ NodeTag qualifier: '' ns: WsdlBinding wsdl20_soap_envelope type: aString ])</body><body package="WSDLDescriptors">addSoapFaultSubcodeNamed: aString	soapFaultSubcode := (aString asSymbol = #any		ifTrue: [ '#any' ]		ifFalse: [  OrderedCollection with:  (NodeTag qualifier: '' ns: self targetNamespace type: aString) ])</body><body package="WSDLDescriptors">addSoapHeader: aSoapHeaderDescriptor	soapHeaders ifNil: [soapHeaders := OrderedCollection new].	soapHeaders add: aSoapHeaderDescriptor</body><body package="WSDLDescriptors">name	^name</body><body package="WSDLDescriptors">name: aNodeTag	name := aNodeTag</body><body package="WSDLDescriptors">soapFaultCode	^soapFaultCode</body><body package="WSDLDescriptors">soapFaultCode: aNodeTag	soapFaultCode := aNodeTag</body><body package="WSDLDescriptors">soapFaultSubcode	^soapFaultSubcode</body><body package="WSDLDescriptors">soapFaultSubcode: aColl	soapFaultSubcode :=		((aColl size = 1 and: [aColl first  = '#any'])			ifTrue: [ aColl first]			ifFalse: [ aColl ])</body><body package="WSDLDescriptors">soapHeaders	^soapHeaders ifNil: [soapHeaders := OrderedCollection new]</body><body package="WSDLDescriptors">soapHeaders: aCollection	soapHeaders := aCollection</body><body package="WSDLDescriptors">soapModule	^soapModule</body><body package="WSDLDescriptors">soapModule: anObject	soapModule := anObject</body><body package="WSDLDescriptors">targetNamespace	^targetNamespace</body><body package="WSDLDescriptors">targetNamespace: aString	targetNamespace := aString</body></methods><methods><class-id>WebServices.Wsdl20SoapFaultDescriptor class</class-id> <category>accessing</category><body package="WSDLDescriptors">soapFaultCodes		^soapFaultCodes ifNil: [ soapFaultCodes := self soapFaultCodesValue ]</body><body package="WSDLDescriptors">soapFaultCodes: aCollection		soapFaultCodes := aCollection</body><body package="WSDLDescriptors">soapFaultCodesValue		^#(#VersionMismatch #MustUnderstand #DataEncodingUnknown #Sender #Receiver #any)</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>api -- builder</category><body package="SOAPBinding">buildFromTag: aNodeTag marshaler: aMarshaler headerEntryMarshaler: entryMarshaler	self buildFromTag: aNodeTag.	marshaler := entryMarshaler copy.	marshaler buildFrom: self tag marshaler: aMarshaler.	self qualified: true.	binding ifNotNil: [ binding  addHeaderMarshaler: self ].</body></methods><methods><class-id>Core.Object</class-id> <category>soap</category><body package="SOAPBinding">isSoapEnvelope	^false</body><body package="SOAPBinding">isSoapFault	^false</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>api -- translation</category><body package="SOAPBinding">addHeaderMarshaler: aMarshaler</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>accessing</category><body package="SOAPBinding">findSoapEntryHeaderMarshalerFor: aHeaderEntry version: aString	| headerEntryMarshaler headerTag elemMarshaler |	headerTag := aHeaderEntry name.	(self headerMarshalerFor: headerTag) ifNotNil: [ :hrm | ^hrm ].	elemMarshaler :=  self 		elementMarshalerForTag: headerTag 		ifAbsent: [self 					marshalerForClass: aHeaderEntry value class 					ifAbsent: [^self error: (#HeaderEntryMarshalerNotFound &lt;&lt; #webservices &gt;&gt; 'The header entry marshaler not found' )]].	headerEntryMarshaler :=  aString = '1.1'			ifTrue: [self marshalerForClass: Soap11HeaderEntry  ifAbsent: [nil]]			ifFalse: [self marshalerForClass: Soap12HeaderEntry ifAbsent: [nil]]. 	^(RelationMarshaler on: self)		buildFromTag: elemMarshaler tag 		marshaler: elemMarshaler		headerEntryMarshaler: headerEntryMarshaler;		yourself</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>api -- translation</category><body package="SOAPBinding">headerMarshalerFor: aNodeTagOrString	^nil</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>testing</category><body package="SOAPBinding">idTag	^nil</body><body package="SOAPBinding">isSoap11	^true</body><body package="SOAPBinding">refTag	^nil</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>accessing</category><body package="SOAPBinding">soapHeaderEntryMarshaler	^self targetNamespace = SoapBinding soap11_uri		ifTrue: [self marshalerForClass: Soap11HeaderEntry  ifAbsent: [nil] ]		ifFalse: [self marshalerForClass: Soap12HeaderEntry  ifAbsent: [nil] ]</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>accessing</category><body package="WSDLBinding">resetTagNamespace"Hack for Soap RPC/encoded "	tag resetNamespaceTo: ''.	tag qualifier notEmpty ifTrue: [ tag resetQualifierTo: '' ].	xpath setXPathNode</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws marshaling</category><body package="SOAPBinding">ws6UseEmptyLengthForDimension	&lt;setting: #(webservices xmlObjectMarshaling useEmptyLengthForDimension)&gt;	^(BooleanSetting on: WebServices.SoapArrayMarshaler aspect: #useEmptyLengthForDimension)		default: WebServices.SoapArrayMarshaler useEmptyLengthForDimensionValue;		label: #UseEmptyLengthForDimension &lt;&lt; #webservices &gt;&gt; 'Use empty dimension for encoding a Soap Array with nil value';		helpText: #UseEmptyLengthForDimensionHelpText &lt;&lt; #webservices &gt;&gt; 'This option defines how to encode a Soap Array with the nil value. If the option is on a Soap Array with the nil value will be encoded using am empty dimension for the arrayType attribute. For example: &lt;varArray SOAP-ENC:arrayType="ns1:string[]" xsi:nil="true" xsi:type="SOAP-ENC:Array"&gt;. The default option is false. In this case the Soap Array with the nil value will be encoded as &lt;varArray xsi:nil="true"/&gt;';		yourself</body><body package="WSDLBinding">wsdl3WrapDocumentLiteralResult	&lt;setting: #(webservices  wrapDocumentLiteralResult)&gt;	^(BooleanSetting on: WebServices.SoapWsdl11OperationBinding aspect: #wrapDocumentLiteralResult)		default: WebServices.SoapWsdl11OperationBinding wrapDocumentLiteralResultValue;		label: #ReturnDocumentLiteralResult &lt;&lt; #webservices &gt;&gt; 'Return doc/literal results as a collection';		helpText: #WrapDocumentLiteralResultHelpText &lt;&lt; #webservices &gt;&gt; 'This option defines how to return results in document/literal style, bare or wrapped in a collection. The latter form used to be the behavior in previous releases. This option allows to restore the backward compatible behavior.';		yourself</body></methods><initialize><class-id>WebServices.SoapBinding</class-id></initialize><initialize><class-id>WebServices.WsdlPort</class-id></initialize><initialize><class-id>WebServices.WsdlService</class-id></initialize><initialize><class-id>WebServices.WsdlBinding</class-id></initialize><initialize><class-id>WebServices.SelectorMap</class-id></initialize><initialize><class-id>WebServices.ServiceMap</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>RelationMarshaler</name><environment>WebServices</environment><super>WebServices.XMLTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relation marshaler </inst-vars><class-inst-vars>defaultRefType </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><class><name>AnyRelationMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaces processContents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><class><name>XMLObjectMarshalingManager</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binding registeredObjects keyToObjectTable needToResolveList idMap idMapReverse significantNamespaces currentId qualifierMap suffixMap refTag idTag wildcardScope </inst-vars><class-inst-vars>refTagDefault idTagDefault </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><class><name>XMLObjectBinding</name><environment>WebServices</environment><super>WebServices.XMLMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshalers classMap targetNamespace registeredKeys importedBindings defaults imports useTaggedObject usePrefixedSchemaTags </inst-vars><class-inst-vars>useReference useInlineType useNilAttribute nillableDefault allowDerivedTypes nilNodeTag xmlEncoding defaultTargetNamespace useTaggedObject usePrefixedSchemaTags </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>XMLObjectBindingSignal</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><class><name>Struct</name><environment>WebServices</environment><super>Protocols.Struct</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><class><name>ComplexObjectMarshaler</name><environment>WebServices</environment><super>WebServices.ObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyMarshalers abstract anyAttributeMarshaler compositor textMarshaler attributeMarshalers baseType aspectImplementation </inst-vars><class-inst-vars>defaultCompositor </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class></st-source>