<?xml version="1.0"?><st-source><!-- Name: WebServicesDemoModelsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: The package includes classes and extensions to run Web services library demo.DbIdentifier: bear73DbTrace: 493913DbUsername: tkoganDbVersion: 8.3 - 0DevelopmentPrerequisites: #(#(#any 'Protocols-LibraryDemo' '') #(#any 'WebServicesNamespace' '') #(#any 'XMLObjectSupport' '') #(#any 'SOAP-Server' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #()PackageName: WebServicesDemoModelsParcel: #('WebServicesDemoModels')PrerequisiteDescriptions: #(#(#name 'Protocols-LibraryDemo') #(#name 'WebServicesNamespace') #(#name 'XMLObjectSupport') #(#name 'SOAP-Server' #componentType #package))PrerequisiteParcels: #(#('Protocols-LibraryDemo' '') #('WebServicesNamespace' '') #('XMLObjectSupport' '') #('SOAP-Server' ''))PrintStringCache: (8.3 - 0,tkogan)Version: 8.3 - 0Date: 2:31:39 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:39 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WSSearchServices</name><environment>WebServices</environment><super>Protocols.Library.SearchService</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WSSearchServices</class-id><body>WSSearchServices represents the library search services</body></comment><class><name>Address</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>street state zip city kind </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>(none)</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.Address</class-id><body>Address Instance Variables	street	&lt;String&gt; 	state	&lt;String&gt; 	zip	&lt;Integer&gt; </body></comment><class><name>ClientForAuthSearch11</name><environment>WebServices</environment><super>WebServices.WsdlClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.ClientForAuthSearch11</class-id><body>ClientForAuthenticatedSearchService client provides API to make search requests to the WSAuthenticationSearchService. The requests must have Soap headers.</body></comment><class><name>Confirmation</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>return </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.Confirmation</class-id><body>Confirmation represents a header processor typeInstance Variables:	return	&lt;String&gt;	string</body></comment><class><name>WSLibrary</name><environment>WebServices</environment><super>Protocols.Library.Library</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ownedHoldingsColl personalPatrons webSiteAddress </inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services-Demo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WSLibrary</class-id><body>WSLibrary loans its holdings and provides additional services to its patrons.Instance Variables:	ownedHoldingsColl	&lt;Collection of (Protocols.Library.Book)&gt;	 ownedHoldingsColl	personalPatrons	&lt;#Collection of (Protocols.Library.Person &gt;	personal patrons	webSiteAddress	&lt;String | URI &gt;	can be a string or url </body></comment><class><name>DemoHeaderInterceptor</name><environment>WebServices</environment><super>WebServices.SOAPMessageInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>status </inst-vars><class-inst-vars></class-inst-vars><imports>			private WebServices.Struct			</imports><category></category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.DemoHeaderInterceptor</class-id><body>DemoHeaderInterceptor is super class for the demo interceptors. It demonstrates how to create and add Soap headers to messages.Instance Variables	status	&lt;String&gt;	</body></comment><class><name>WrongPasswordException</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WebServicesDemo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WrongPasswordException</class-id><body>WrongPasswordException is raised by a responder header processor</body></comment><class><name>WSBook</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>acquisitionNumber statusId title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Demo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WSBook</class-id><body>WSBook is a short version of Protocols.Library.Book Instance Variables:	acquisitionNumber	&lt;LargeInterger&gt;	 acquisition number	statusId	&lt;Symbol&gt;	 status Id	title	&lt;String&gt; title of the book</body></comment><class><name>AuthSearchResponder11</name><environment>WebServices</environment><super>WebServices.SOAPResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.AuthSearchResponder11</class-id><body>AuthSearchServer11 is a responder that is using Wsdl 1.1. It is running services that require Soap headers for authentication</body></comment><class><name>AuthenticationTokenExceptionHeader</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WebServicesDemo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.AuthenticationTokenExceptionHeader</class-id><body>AuthenticationTokenExceptionHeader is Soap headers required for fault: AuthenticationTokenException in Wsdl 2.0 demoInstance Variables	description	&lt;String&gt;	</body></comment><class><name>AuthenticationToken</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userID password </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WebServicesDemo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.AuthenticationToken</class-id><body>AuthenticationToken is used as a header processor type. See HdprAuthenticationToken header processor class&gt;&gt;headerInstance Variables:	password	&lt;String&gt;	password string	userID	&lt;String&gt;	 userID string</body></comment><class><name>LibraryResponder</name><environment>WebServices</environment><super>WebServices.SOAPResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.LibraryResponder</class-id><body>The class represents the library responder.To start and stop a singleton instance, evaluate:	LibraryResponder addToServer.	LibraryResponder flushResponders.</body></comment><class><name>WSAuthenticatedSearchService</name><environment>WebServices</environment><super>Protocols.Library.SearchService</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services-Demo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WSAuthenticatedSearchService</class-id><body>WSAuthenticatedSearchService provides search services only if the Soap headers with authentication information are provided.</body></comment><class><name>DemoHeaderInterceptor20</name><environment>WebServices</environment><super>WebServices.DemoHeaderInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private WebServices.Struct			</imports><category></category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.DemoHeaderInterceptor20</class-id><body>Demo20HeaderProcessor is interceptor class for a client and responder. Uses Wsdl 2.0</body></comment><class><name>Customer</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id address rating </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>(none)</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.Customer</class-id><body>Customer Instance Variables	name	&lt;String&gt; 	id	&lt;Integer&gt; 	address	&lt;WebServices.Address&gt; </body></comment><class><name>ChoiceOfHoldings</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>choiceValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.ChoiceOfHoldings</class-id><body>ChoiceOfHoldings holds choice valueInstance Variables	choiceValue	&lt;Struct&gt;	 choiceValue</body></comment><class><name>DemoProcessingPolicy</name><environment>WebServices</environment><super>WebServices.SOAPProcessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessLevel userID password </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-SOAP</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.DemoProcessingPolicy</class-id><body>DemoProcessingPolicy holds information necessary to create Soap headers.Instance Variables	accessLevel	&lt;Number&gt;	 access level	password	&lt;String&gt;	 password	userID	&lt;String&gt; 		userID</body></comment><class><name>WSGeneralServices</name><environment>WebServices</environment><super>Protocols.Library.GeneralPublicService</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WSGeneralServices</class-id><body>WSGeneralServices provides free library services</body></comment><class><name>WrongConfirmationExc</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>(none)</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WrongConfirmationExc</class-id><body>WrongConfirmationExc exception is raised by a client header processor.</body></comment><class><name>ClientForAuthSearch20</name><environment>WebServices</environment><super>WebServices.WsdlClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.ClientForAuthSearch20</class-id><body>ClientForAuthenticatedSearchService20 client provides API to make search requests to the WSAuthenticationSearchService. The requests must have Soap headers. The client uses Wsdl 2.0 spec.</body></comment><class><name>AuthenticationTokenException</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userID password </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WebServicesDemo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.AuthenticationTokenException</class-id><body>AuthenticationTokenException is raised in the HdPrAuthenticationToken header processor while processing the AuthenticationHeader header.Instance Variables:	password	&lt;String&gt;	 password	userID	&lt;String&gt;	userID</body></comment><class><name>SpecialCustomer</name><environment>WebServices</environment><super>WebServices.Customer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>something1 something2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WebServicesDemoModels</package></attributes></class><class><name>DemoHeaderInterceptor11</name><environment>WebServices</environment><super>WebServices.DemoHeaderInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private WebServices.Struct			</imports><category></category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.DemoHeaderInterceptor11</class-id><body>Demo11HeaderInterceptor is interceptor class for a client and responder. Uses Wsdl 1.1</body></comment><class><name>CategoryType</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attr id sequenceValue sequenceValue1 end groupValue groupValue1 choiceValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tests</category><attributes><package>WebServicesDemoModels</package></attributes></class><class><name>WSPhysicalAddress</name><environment>WebServices</environment><super>Protocols.Library.PhysicalAddress</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services-Demo</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.WSPhysicalAddress</class-id><body>WSPhysicalAddress </body></comment><class><name>AuthSearchResponder20</name><environment>WebServices</environment><super>WebServices.SOAPResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services</category><attributes><package>WebServicesDemoModels</package></attributes></class><comment><class-id>WebServices.AuthSearchResponder20</class-id><body>AuthSearchServer20  is a responder that is using Wsdl 2.0. It is running services that require Soap headers for authentication</body></comment><methods><class-id>WebServices.WSSearchServices</class-id> <category>initialize-release</category><body package="WebServicesDemoModels">initialize	| affiliate |	affiliate := Library portNowhereMaritimeMuseumLibraryAndShipPlanArchive.	library := Library cityPublicLibrary.	library serviceApprovals: library serviceApprovals asOrderedCollection.	library addService: self.	library affiliatedLibraries add: affiliate.</body></methods><methods><class-id>WebServices.WSSearchServices</class-id> <category>private</category><body package="WebServicesDemoModels">searchServices: anOrderedCollection onAspect: aSymbol withMatchString: aString	| rd |	rd := OrderedCollection new.	anOrderedCollection do:		[ :srv | rd addAll: ( srv searchHoldingsOnAspect: aSymbol withMatchString: aString ) ].	^rd</body></methods><methods><class-id>WebServices.Address</class-id> <category>accessing</category><body package="WebServicesDemoModels">city	^city</body><body package="WebServicesDemoModels">city: anObject	city := anObject</body><body package="WebServicesDemoModels">kind	^kind</body><body package="WebServicesDemoModels">kind: anObject	kind := anObject</body><body package="WebServicesDemoModels">state	^state</body><body package="WebServicesDemoModels">street	^street</body><body package="WebServicesDemoModels">zip	^zip</body></methods><methods><class-id>WebServices.ClientForAuthSearch11</class-id> <category>public api</category><body package="WebServicesDemoModels">authenticatedSearchByTitle: aString 	| args |	args := Array with: aString.	^self executeSelector: #'AuthenticatedSearchByTitle' args: args.</body><body package="WebServicesDemoModels">authenticatedSearchByWord: aString 		| args |	args := Array with: aString.	^self executeSelector: #'AuthenticatedSearchByWord' args: args.</body><body package="WebServicesDemoModels">searchByTitle: aString 	| args |	args := Array with: aString.	^self executeSelector: #'SearchByTitle' args: args.</body></methods><methods><class-id>WebServices.ClientForAuthSearch11 class</class-id> <category>accessing</category><body package="WebServicesDemoModels">bindingName	^'WSAuthenticatedSearchService'</body><body package="WebServicesDemoModels">bindingTargetNamespace	^'urn:LibraryDemo/11/testSoapHeaders'</body><body package="WebServicesDemoModels">processingPolicy	^DemoProcessingPolicy new 		interceptorClasses: (OrderedCollection with: DemoHeaderInterceptor11) ; 		yourself</body><body package="WebServicesDemoModels">serviceMap	 " WebServices.ServiceMap loadFrom: self serviceMap readStream " 	^'&lt;ns:serviceMap xmlns:ns0="urn:LibraryDemo/11/testSoapHeaders" xmlns:ns="urn:visualworks:serviceMap"&gt;	&lt;ns:serviceClass&gt;WebServices.WSAuthenticatedSearchService&lt;/ns:serviceClass&gt;	&lt;ns:interface&gt;ns0:WSAuthenticatedSearchService&lt;/ns:interface&gt;	&lt;ns:operation name="SearchByTitle" selector="searchByTitle:"/&gt;	&lt;ns:operation name="AuthenticatedSearchByTitle" selector="authenticatedSearchByTitle:"/&gt;	&lt;ns:operation name="SearchByTitle" selector="searchByTitle:"/&gt;	&lt;ns:operation name="AuthenticatedSearchByWord" selector="authenticatedSearchByWord:"/&gt;&lt;/ns:serviceMap&gt;'</body></methods><methods><class-id>WebServices.ClientForAuthSearch11 class</class-id> <category>wsdl schema</category><body package="WebServicesDemoModels">wsdlSchema^'&lt;definitions targetNamespace="urn:LibraryDemo/11/testSoapHeaders" xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:ns="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders"&gt;	&lt;types&gt;		&lt;schema targetNamespace="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/11/testSoapHeaders" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;import namespace="urn:LibraryDemo/11/testSoapHeaders"&gt;&lt;/import&gt;			&lt;element name="SearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;complexType name="CollectionOfBook"&gt;				&lt;sequence&gt;					&lt;element maxOccurs="unbounded" minOccurs="0" name="Book" type="ns:Protocols.Library.Book"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;element name="SearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWord"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWordResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AccessLevel" type="xsd:string"&gt;&lt;/element&gt;			&lt;element name="AuthenticationToken" type="ns:AuthenticationToken"&gt;&lt;/element&gt;			&lt;element name="AuthenticationTokenException" type="ns:AuthenticationTokenException"&gt;&lt;/element&gt;			&lt;element name="WrongPasswordException" type="ns:WrongPasswordException"&gt;&lt;/element&gt;			&lt;element name="Confirmation" type="ns:Confirmation"&gt;&lt;/element&gt;		&lt;/schema&gt;		&lt;schema targetNamespace="urn:LibraryDemo/11/testSoapHeaders" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;complexType name="AuthenticationToken"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="AuthenticationTokenException"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Confirmation"&gt;				&lt;sequence&gt;					&lt;element name="return" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="WrongPasswordException"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Book"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.LoanedHolding"&gt;						&lt;sequence&gt;							&lt;element minOccurs="0" name="dueDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="acquisitionDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="language" type="xsd:string"&gt;&lt;/element&gt;							&lt;element maxOccurs="unbounded" minOccurs="0" name="authors" type="tns:Protocols.Library.AuthorialName"&gt;&lt;/element&gt;							&lt;element name="acquisitionNumber" type="xsd:positiveInteger"&gt;&lt;/element&gt;							&lt;element name="publisher" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="braille" type="xsd:boolean"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="catalogNumber" type="tns:Protocols.Library.CatalogNumber"&gt;&lt;/element&gt;							&lt;element name="pages" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="libraryName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="collectionId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="publicationYear" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="acquisitionCost" type="xsd:decimal"&gt;&lt;/element&gt;							&lt;element name="statusId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="largePrint" type="xsd:boolean"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.LoanedHolding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Holding"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Holding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AbstractRandom"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.CatalogNumber"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="part4" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part1" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part2" type="xsd:base64Binary"&gt;&lt;/element&gt;							&lt;element name="part3" type="xsd:double"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AuthorialName"&gt;				&lt;sequence&gt;					&lt;element name="name" type="tns:Protocols.Library.PersonName"&gt;&lt;/element&gt;					&lt;element name="authorialType" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.PersonName"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="middleNames" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="firstName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="lastName" type="xsd:string"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;		&lt;/schema&gt;	&lt;/types&gt;	&lt;message name="SearchByTitle"&gt;		&lt;part element="ns:SearchByTitle" name="parameter"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="SearchByTitleResponse"&gt;		&lt;part element="ns:SearchByTitleResponse" name="return"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByTitle"&gt;		&lt;part element="ns:AuthenticatedSearchByTitle" name="parameter"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByTitleResponse"&gt;		&lt;part element="ns:AuthenticatedSearchByTitleResponse" name="return"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByWord"&gt;		&lt;part element="ns:AuthenticatedSearchByWord" name="parameter"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByWordResponse"&gt;		&lt;part element="ns:AuthenticatedSearchByWordResponse" name="return"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AccessLevelHeader"&gt;		&lt;part element="ns:AccessLevel" name="AccessLevel"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="WrongPasswordExceptionHeader"&gt;		&lt;part element="ns:WrongPasswordException" name="WrongPasswordException"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticationTokenHeader"&gt;		&lt;part element="ns:AuthenticationToken" name="AuthenticationToken"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticationTokenExceptionHeader"&gt;		&lt;part element="ns:AuthenticationTokenException" name="AuthenticationTokenException"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="ConfirmationHeader"&gt;		&lt;part element="ns:Confirmation" name="Confirmation"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;portType name="WSAuthenticatedSearchService"&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:SearchByTitle"&gt;&lt;/input&gt;			&lt;output message="tns:SearchByTitleResponse"&gt;&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByTitle"&gt;			&lt;documentation&gt;The AuthenticatedSearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:AuthenticatedSearchByTitle"&gt;&lt;/input&gt;			&lt;output message="tns:AuthenticatedSearchByTitleResponse"&gt;&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByWord"&gt;			&lt;documentation&gt;To be able to make this request the message should include authentication token and access level. The AuthenticatedSearchByWord operation returns a collection of books or empty collection if no books found&lt;/documentation&gt;			&lt;input message="tns:AuthenticatedSearchByWord"&gt;&lt;/input&gt;			&lt;output message="tns:AuthenticatedSearchByWordResponse"&gt;&lt;/output&gt;		&lt;/operation&gt;	&lt;/portType&gt;	&lt;binding name="WSAuthenticatedSearchService" type="tns:WSAuthenticatedSearchService"&gt;		&lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"&gt;&lt;/soap:binding&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/testSoapHeaders#SearchByTitle" style="document"&gt;&lt;/soap:operation&gt;			&lt;input&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByTitle"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/testSoapHeaders#AuthenticatedSearchByTitle" style="document"&gt;&lt;/soap:operation&gt;			&lt;input&gt;				&lt;soap:header message="tns:AuthenticationTokenHeader" part="AuthenticationToken" use="literal"&gt;					&lt;soap:headerfault message="tns:AuthenticationTokenExceptionHeader" part="AuthenticationTokenException" use="literal"&gt;&lt;/soap:headerfault&gt;					&lt;soap:headerfault message="tns:WrongPasswordExceptionHeader" part="WrongPasswordException" use="literal"&gt;&lt;/soap:headerfault&gt;				&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByWord"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/testSoapHeaders#AuthenticatedSearchByWord" style="document"&gt;&lt;/soap:operation&gt;			&lt;input&gt;				&lt;soap:header message="tns:AuthenticationTokenHeader" part="AuthenticationToken" use="literal"&gt;					&lt;soap:headerfault message="tns:AuthenticationTokenExceptionHeader" part="AuthenticationTokenException" use="literal"&gt;&lt;/soap:headerfault&gt;					&lt;soap:headerfault message="tns:WrongPasswordExceptionHeader" part="WrongPasswordException" use="literal"&gt;&lt;/soap:headerfault&gt;				&lt;/soap:header&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:header message="tns:ConfirmationHeader" part="Confirmation" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/output&gt;		&lt;/operation&gt;	&lt;/binding&gt;	&lt;service name="TestLibraryServicesWithHeaders"&gt;		&lt;port binding="tns:WSAuthenticatedSearchService" name="WSAuthenticatedSearchService"&gt;			&lt;soap:address location="http://localhost:4444/testSoapHeadersServices"&gt;&lt;/soap:address&gt;		&lt;/port&gt;	&lt;/service&gt;&lt;/definitions&gt;'</body><body package="WebServicesDemoModels">x2oBinding	"self initializeRegistries"^'&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/11/testSoapHeaders" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations"&gt;		&lt;bindingImport namespace="urn:LibraryDemo/11/testSoapHeaders"/&gt;		&lt;element name="SearchByTitle"&gt;			&lt;struct name="SearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;sequence_of name="CollectionOfBook" smalltalkClass="OrderedCollection"&gt;			&lt;element name="Book" maxOccurs="unbounded" minOccurs="0" ref="ns:Protocols.Library.Book"/&gt;		&lt;/sequence_of&gt;		&lt;element name="SearchByTitleResponse"&gt;			&lt;struct name="SearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitle"&gt;			&lt;struct name="AuthenticatedSearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitleResponse"&gt;			&lt;struct name="AuthenticatedSearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWord"&gt;			&lt;struct name="AuthenticatedSearchByWord"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWordResponse"&gt;			&lt;struct name="AuthenticatedSearchByWordResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AccessLevel" ref="xsd:string"/&gt;		&lt;element name="AuthenticationToken" ref="ns:AuthenticationToken"/&gt;		&lt;element name="AuthenticationTokenException" ref="ns:AuthenticationTokenException"/&gt;		&lt;element name="WrongPasswordException" ref="ns:WrongPasswordException"/&gt;		&lt;element name="Confirmation" ref="ns:Confirmation"/&gt;	&lt;/xmlToSmalltalkBinding&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/11/testSoapHeaders" defaultClassNamespace="WebServices" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders"&gt;		&lt;object name="AuthenticationToken" smalltalkClass="AuthenticationToken"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenException" smalltalkClass="AuthenticationTokenException"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="Confirmation" smalltalkClass="Confirmation"&gt;			&lt;element name="return" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="WrongPasswordException" smalltalkClass="WrongPasswordException"/&gt;		&lt;object name="Protocols.Library.Book" smalltalkClass="Protocols.Library.Book" baseType="tns:Protocols.Library.LoanedHolding" constraint="extension"&gt;			&lt;element name="dueDate" minOccurs="0" ref="xsd:date"/&gt;			&lt;element name="acquisitionDate" ref="xsd:date"/&gt;			&lt;element name="language" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="authors" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.AuthorialName"/&gt;			&lt;element name="acquisitionNumber" ref="xsd:positiveInteger"/&gt;			&lt;element name="publisher" ref="xsd:string"/&gt;			&lt;element name="braille" ref="xsd:boolean"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="catalogNumber" ref="tns:Protocols.Library.CatalogNumber"/&gt;			&lt;element name="pages" ref="xsd:short"/&gt;			&lt;element name="libraryName" ref="xsd:string"/&gt;			&lt;element name="collectionId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="publicationYear" ref="xsd:short"/&gt;			&lt;element name="acquisitionCost" ref="xsd:decimal"/&gt;			&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="largePrint" ref="xsd:boolean"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.LoanedHolding" smalltalkClass="Protocols.Library.LoanedHolding" baseType="tns:Protocols.Library.Holding" constraint="extension"/&gt;		&lt;object name="Protocols.Library.Holding" smalltalkClass="Protocols.Library.Holding" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"/&gt;		&lt;object name="Protocols.Library.AbstractRandom" smalltalkClass="Protocols.Library.AbstractRandom"/&gt;		&lt;object name="Protocols.Library.CatalogNumber" smalltalkClass="Protocols.Library.CatalogNumber" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="part4" ref="xsd:string" conversionId="Character"/&gt;			&lt;element name="part1" ref="xsd:string"/&gt;			&lt;element name="part2" ref="xsd:base64Binary"/&gt;			&lt;element name="part3" ref="xsd:double"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.AuthorialName" smalltalkClass="Protocols.Library.AuthorialName"&gt;			&lt;element name="name" ref="tns:Protocols.Library.PersonName"/&gt;			&lt;element name="authorialType" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.PersonName" smalltalkClass="Protocols.Library.PersonName" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="middleNames" ref="xsd:string"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="firstName" ref="xsd:string"/&gt;			&lt;element name="lastName" ref="xsd:string"/&gt;		&lt;/object&gt;	&lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.Confirmation</class-id> <category>accessing</category><body package="WebServicesDemoModels">return	^return</body></methods><methods><class-id>WebServices.WSLibrary</class-id> <category>private</category><body package="WebServicesDemoModels">addLDHolding: aLDHolding"... adds a holding without adding a transaction or affecting the library account balance."	aLDHolding libraryName: libraryName.	ownedHoldingsColl add: aLDHolding.</body></methods><methods><class-id>WebServices.WSLibrary</class-id> <category>accessing</category><body package="WebServicesDemoModels">ownedHoldingsColl	^ownedHoldingsColl</body><body package="WebServicesDemoModels">personalPatrons	^personalPatrons</body><body package="WebServicesDemoModels">webSiteAddress	^webSiteAddress</body></methods><methods><class-id>WebServices.WSLibrary</class-id> <category>public api</category><body package="WebServicesDemoModels">searchHoldingsOnAspect: aSymbol withMatchString: aString	| rs |	rs := OrderedCollection new.	ownedHoldingsColl do:			[ :hb | ( hb perform: aSymbol ) do:							[ :item |	( aString match: item )										ifTrue: [ rs add: hb ]							]			].	^rs</body></methods><methods><class-id>WebServices.WSLibrary</class-id> <category>initialize-release</category><body package="WebServicesDemoModels">initialize	| p |	account := Account new.	borrowedHoldings := OrderedCollection new.	emailAddresses := Array new.	physicalAddress := PhysicalAddress randomLDDataPhysicalAddress.	serviceApprovals := self class randomServiceApprovals.	telephoneNumbers := OrderedCollection new.	ownedHoldingsColl := OrderedCollection new: 20.	personalPatrons := OrderedCollection new: 20.	telephoneNumbers := TelephoneNumber randomOrganizationalLDDataTelephoneNumbers asOrderedCollection.	affiliatedLibraries := OrderedCollection new.	libraryId := self class newLibraryId.	loanedHoldings := OrderedCollection new.	ownedHoldings := OrderedCollection new.	patrons := (SortedCollection sortBlock: Patron patronIdSortBlock) asOrderedCollection.	"requestBroker := nil."	reservedHoldings := OrderedCollection new.	services := IdentityDictionary new.	20 timesRepeat: 		[ p := Person randomLDPersonalPatron.		p borrowedHoldings: OrderedCollection new.		p serviceApprovals: p serviceApprovals asOrderedCollection.		p telephoneNumbers: p telephoneNumbers asOrderedCollection.		 personalPatrons add: p ].	(self class randomPositiveIntegerWithMax: 2) = 1		ifTrue: 			[ webSiteAddress := Struct new 									at: #text put: (#ThePageCannotBeDisplayed &lt;&lt; #webservices &gt;&gt; 'The page cannot be displayed') asString; 									yourself ]		ifFalse: [ webSiteAddress := Struct new at: #url put: (OS.URI fromString: 'http://library.com/wsdemo'); yourself  ].</body></methods><methods><class-id>WebServices.WSLibrary class</class-id> <category>accessing</category><body package="WebServicesDemoModels">libraryDepartments	^super libraryDepartments</body></methods><methods><class-id>WebServices.DemoHeaderInterceptor</class-id> <category>processing callbacks</category><body package="WebServicesDemoModels">processInputHeaderFrom: aSOAPRequest transport: aTransport	| headerEntry |	headerEntry := (aSOAPRequest headerAt: #AuthenticationToken ifAbsent: [nil]) value.	( headerEntry userID = 'ID#ABC' and: [  headerEntry password = 'password' ]) 		ifTrue: [ ^status := 'not confirmed' ].	( headerEntry userID = 'UserID' and: [ headerEntry password = 'password' ])		ifTrue: [	status := 'confirmed' ]		ifFalse: [AuthenticationTokenException new					userID:   headerEntry userID;					password:  headerEntry password;					raise].</body><body package="WebServicesDemoModels">receivingFailedReply: aReply</body><body package="WebServicesDemoModels">receivingReply: aReply in: aTransport		"Client: Validate received response headers and raise exceptions in case of fault messages"	| confirmation |	aReply hasFault ifTrue: [^self receivingFailedReply: aReply].	"The processor has to provide the operation validation "	aReply operation name type ~= 'AuthenticatedSearchByWord' ifTrue: [ ^nil ].	confirmation := (aReply headerAt: #Confirmation ifAbsent: [ ^WrongConfirmationExc raise ]) value.	confirmation return = 'not confirmed' ifTrue: [ WrongConfirmationExc raise]</body><body package="WebServicesDemoModels">receivingRequestEnvelope: aSOAPRequest in: aTransport	"Server: Validate received request headers"	(aSOAPRequest needsHeader: #AuthenticationToken) ifTrue: [ 		(aSOAPRequest headerAt: #AuthenticationToken ifAbsent: [ Error raiseSignal: 'missing authentication' ]) value.		self processInputHeaderFrom: aSOAPRequest transport: aTransport]</body><body package="WebServicesDemoModels">sendingFailedReply: aReply</body><body package="WebServicesDemoModels">sendingReply: aReply in: aTransport	"Server: Create and add response headers"	aReply failed ifTrue: [  ^self sendingFailedReply: aReply].	"There is no operation name for a fault reply!!!!!!"	aReply operation ifNil: [ ^nil].	"The processor has to provide headers validation "	(aReply needsHeader:  #'AccessLevel') ifTrue: [ 		(aReply headerFor: #'AccessLevel') ifNotNil: [ :header | header value: '9876' ]].	(aReply needsHeader:  #'Confirmation') ifTrue: [ 		(aReply headerFor: #'Confirmation') ifNotNil: [ :header | header value: (Confirmation new 	return: status; yourself)] ].</body><body package="WebServicesDemoModels">sendingRequest: aRequest in: aTransport	"Client: Using processing policy create and add Soap headers to the request "	(aRequest needsHeader: #AccessLevel ) ifTrue: [		"Add the #AccessLevel header to the request "		( aRequest headerFor: #'AccessLevel') value: self policy accessLevel].	(aRequest needsHeader: #AuthenticationToken ) ifTrue: [		( aRequest headerFor: #'AuthenticationToken')			value: ( WebServices.AuthenticationToken new					userID: self policy userID;					password: self policy password;					yourself). ]</body></methods><methods><class-id>WebServices.DemoHeaderInterceptor class</class-id> <category>accessing</category><body package="WebServicesDemoModels">headerNames	"Header names supported by this interceptor "	^OrderedCollection 			with: #Confirmation			with: #AuthenticationToken			with: #AccessLevel</body></methods><methods><class-id>WebServices.WSBook</class-id> <category>accessing</category><body package="WebServicesDemoModels">acquisitionNumber	^acquisitionNumber</body><body package="WebServicesDemoModels">statusId	^statusId</body><body package="WebServicesDemoModels">text	^self title</body><body package="WebServicesDemoModels">title	^title</body><body package="WebServicesDemoModels">title: aString	title := aString</body></methods><methods><class-id>WebServices.WSBook</class-id> <category>printing</category><body package="WebServicesDemoModels">printOn: aStream	title notNil		ifTrue: [aStream nextPutAll: title ]		ifFalse: [aStream nextPutAll: self class name ]</body></methods><methods><class-id>WebServices.AuthSearchResponder11 class</class-id> <category>wsdl schema</category><body package="WebServicesDemoModels">serviceMap	 " WebServices.ServiceMap loadFrom: AuthSearchServer serviceMap readStream " 	^'&lt;ns:serviceMaps xmlns:ns="urn:visualworks:serviceMap" xmlns:ns0="urn:LibraryDemo/11/testSoapHeaders"&gt;	&lt;ns:serviceMap&gt;		&lt;ns:serviceClass&gt;WebServices.WSAuthenticatedSearchService&lt;/ns:serviceClass&gt;		&lt;ns:interface&gt;ns0:WSAuthenticatedSearchService&lt;/ns:interface&gt;		&lt;ns:operation name="SearchByTitle" selector="searchByTitle:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="AuthenticatedSearchByTitle" selector="authenticatedSearchByTitle:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="AuthenticatedSearchByWord" selector="authenticatedSearchByWord:"&gt;&lt;/ns:operation&gt;	&lt;/ns:serviceMap&gt;&lt;/ns:serviceMaps&gt;'</body><body package="WebServicesDemoModels">wsdlSchema^'&lt;definitions targetNamespace="urn:LibraryDemo/11/testSoapHeaders" xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:ns="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders"&gt;	&lt;types&gt;		&lt;schema targetNamespace="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/11/testSoapHeaders" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;import namespace="urn:LibraryDemo/11/testSoapHeaders"&gt;&lt;/import&gt;			&lt;element name="SearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;complexType name="CollectionOfBook"&gt;				&lt;sequence&gt;					&lt;element maxOccurs="unbounded" minOccurs="0" name="Book" type="ns:Protocols.Library.Book"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;element name="SearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWord"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWordResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AccessLevel" type="xsd:string"&gt;&lt;/element&gt;			&lt;element name="AuthenticationToken" type="ns:AuthenticationToken"&gt;&lt;/element&gt;			&lt;element name="AuthenticationTokenException" type="ns:AuthenticationTokenException"&gt;&lt;/element&gt;			&lt;element name="WrongPasswordException" type="ns:WrongPasswordException"&gt;&lt;/element&gt;			&lt;element name="Confirmation" type="ns:Confirmation"&gt;&lt;/element&gt;		&lt;/schema&gt;		&lt;schema targetNamespace="urn:LibraryDemo/11/testSoapHeaders" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;complexType name="AuthenticationToken"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="AuthenticationTokenException"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Confirmation"&gt;				&lt;sequence&gt;					&lt;element name="return" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="WrongPasswordException"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Book"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.LoanedHolding"&gt;						&lt;sequence&gt;							&lt;element minOccurs="0" name="dueDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="acquisitionDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="language" type="xsd:string"&gt;&lt;/element&gt;							&lt;element maxOccurs="unbounded" minOccurs="0" name="authors" type="tns:Protocols.Library.AuthorialName"&gt;&lt;/element&gt;							&lt;element name="acquisitionNumber" type="xsd:positiveInteger"&gt;&lt;/element&gt;							&lt;element name="publisher" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="braille" type="xsd:boolean"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="catalogNumber" type="tns:Protocols.Library.CatalogNumber"&gt;&lt;/element&gt;							&lt;element name="pages" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="libraryName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="collectionId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="publicationYear" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="acquisitionCost" type="xsd:decimal"&gt;&lt;/element&gt;							&lt;element name="statusId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="largePrint" type="xsd:boolean"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.LoanedHolding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Holding"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Holding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AbstractRandom"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.CatalogNumber"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="part4" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part1" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part2" type="xsd:base64Binary"&gt;&lt;/element&gt;							&lt;element name="part3" type="xsd:double"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AuthorialName"&gt;				&lt;sequence&gt;					&lt;element name="name" type="tns:Protocols.Library.PersonName"&gt;&lt;/element&gt;					&lt;element name="authorialType" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.PersonName"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="middleNames" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="firstName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="lastName" type="xsd:string"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;		&lt;/schema&gt;	&lt;/types&gt;	&lt;message name="SearchByTitle"&gt;		&lt;part element="ns:SearchByTitle" name="parameter"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="SearchByTitleResponse"&gt;		&lt;part element="ns:SearchByTitleResponse" name="return"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByTitle"&gt;		&lt;part element="ns:AuthenticatedSearchByTitle" name="parameter"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByTitleResponse"&gt;		&lt;part element="ns:AuthenticatedSearchByTitleResponse" name="return"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByWord"&gt;		&lt;part element="ns:AuthenticatedSearchByWord" name="parameter"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticatedSearchByWordResponse"&gt;		&lt;part element="ns:AuthenticatedSearchByWordResponse" name="return"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AccessLevelHeader"&gt;		&lt;part element="ns:AccessLevel" name="AccessLevel"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="WrongPasswordExceptionHeader"&gt;		&lt;part element="ns:WrongPasswordException" name="WrongPasswordException"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticationTokenHeader"&gt;		&lt;part element="ns:AuthenticationToken" name="AuthenticationToken"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="AuthenticationTokenExceptionHeader"&gt;		&lt;part element="ns:AuthenticationTokenException" name="AuthenticationTokenException"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;message name="ConfirmationHeader"&gt;		&lt;part element="ns:Confirmation" name="Confirmation"&gt;&lt;/part&gt;	&lt;/message&gt;	&lt;portType name="WSAuthenticatedSearchService"&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:SearchByTitle"&gt;&lt;/input&gt;			&lt;output message="tns:SearchByTitleResponse"&gt;&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByTitle"&gt;			&lt;documentation&gt;The AuthenticatedSearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:AuthenticatedSearchByTitle"&gt;&lt;/input&gt;			&lt;output message="tns:AuthenticatedSearchByTitleResponse"&gt;&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByWord"&gt;			&lt;documentation&gt;To be able to make this request the message should include authentication token and access level. The AuthenticatedSearchByWord operation returns a collection of books or empty collection if no books found&lt;/documentation&gt;			&lt;input message="tns:AuthenticatedSearchByWord"&gt;&lt;/input&gt;			&lt;output message="tns:AuthenticatedSearchByWordResponse"&gt;&lt;/output&gt;		&lt;/operation&gt;	&lt;/portType&gt;	&lt;binding name="WSAuthenticatedSearchService" type="tns:WSAuthenticatedSearchService"&gt;		&lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"&gt;&lt;/soap:binding&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/testSoapHeaders#SearchByTitle" style="document"&gt;&lt;/soap:operation&gt;			&lt;input&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByTitle"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/testSoapHeaders#AuthenticatedSearchByTitle" style="document"&gt;&lt;/soap:operation&gt;			&lt;input&gt;				&lt;soap:header message="tns:AuthenticationTokenHeader" part="AuthenticationToken" use="literal"&gt;					&lt;soap:headerfault message="tns:AuthenticationTokenExceptionHeader" part="AuthenticationTokenException" use="literal"&gt;&lt;/soap:headerfault&gt;					&lt;soap:headerfault message="tns:WrongPasswordExceptionHeader" part="WrongPasswordException" use="literal"&gt;&lt;/soap:headerfault&gt;				&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByWord"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/testSoapHeaders#AuthenticatedSearchByWord" style="document"&gt;&lt;/soap:operation&gt;			&lt;input&gt;				&lt;soap:header message="tns:AuthenticationTokenHeader" part="AuthenticationToken" use="literal"&gt;					&lt;soap:headerfault message="tns:AuthenticationTokenExceptionHeader" part="AuthenticationTokenException" use="literal"&gt;&lt;/soap:headerfault&gt;					&lt;soap:headerfault message="tns:WrongPasswordExceptionHeader" part="WrongPasswordException" use="literal"&gt;&lt;/soap:headerfault&gt;				&lt;/soap:header&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:header message="tns:ConfirmationHeader" part="Confirmation" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"&gt;&lt;/soap:header&gt;				&lt;soap:body use="literal"&gt;&lt;/soap:body&gt;			&lt;/output&gt;		&lt;/operation&gt;	&lt;/binding&gt;	&lt;service name="TestLibraryServicesWithHeaders"&gt;		&lt;port binding="tns:WSAuthenticatedSearchService" name="WSAuthenticatedSearchService"&gt;			&lt;soap:address location="http://localhost:4444/testSoapHeadersServices"&gt;&lt;/soap:address&gt;		&lt;/port&gt;	&lt;/service&gt;&lt;/definitions&gt;'</body><body package="WebServicesDemoModels">x2oBinding	"self initializeRegistries"^'&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/11/testSoapHeaders" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations"&gt;		&lt;bindingImport namespace="urn:LibraryDemo/11/testSoapHeaders"/&gt;		&lt;element name="SearchByTitle"&gt;			&lt;struct name="SearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;sequence_of name="CollectionOfBook" smalltalkClass="OrderedCollection"&gt;			&lt;element name="Book" maxOccurs="unbounded" minOccurs="0" ref="ns:Protocols.Library.Book"/&gt;		&lt;/sequence_of&gt;		&lt;element name="SearchByTitleResponse"&gt;			&lt;struct name="SearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitle"&gt;			&lt;struct name="AuthenticatedSearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitleResponse"&gt;			&lt;struct name="AuthenticatedSearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWord"&gt;			&lt;struct name="AuthenticatedSearchByWord"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWordResponse"&gt;			&lt;struct name="AuthenticatedSearchByWordResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AccessLevel" ref="xsd:string"/&gt;		&lt;element name="AuthenticationToken" ref="ns:AuthenticationToken"/&gt;		&lt;element name="AuthenticationTokenException" ref="ns:AuthenticationTokenException"/&gt;		&lt;element name="WrongPasswordException" ref="ns:WrongPasswordException"/&gt;		&lt;element name="Confirmation" ref="ns:Confirmation"/&gt;	&lt;/xmlToSmalltalkBinding&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/11/testSoapHeaders" defaultClassNamespace="WebServices" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders"&gt;		&lt;object name="AuthenticationToken" smalltalkClass="AuthenticationToken"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenException" smalltalkClass="AuthenticationTokenException"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="Confirmation" smalltalkClass="Confirmation"&gt;			&lt;element name="return" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="WrongPasswordException" smalltalkClass="WrongPasswordException"/&gt;		&lt;object name="Protocols.Library.Book" smalltalkClass="Protocols.Library.Book" baseType="tns:Protocols.Library.LoanedHolding" constraint="extension"&gt;			&lt;element name="dueDate" minOccurs="0" ref="xsd:date"/&gt;			&lt;element name="acquisitionDate" ref="xsd:date"/&gt;			&lt;element name="language" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="authors" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.AuthorialName"/&gt;			&lt;element name="acquisitionNumber" ref="xsd:positiveInteger"/&gt;			&lt;element name="publisher" ref="xsd:string"/&gt;			&lt;element name="braille" ref="xsd:boolean"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="catalogNumber" ref="tns:Protocols.Library.CatalogNumber"/&gt;			&lt;element name="pages" ref="xsd:short"/&gt;			&lt;element name="libraryName" ref="xsd:string"/&gt;			&lt;element name="collectionId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="publicationYear" ref="xsd:short"/&gt;			&lt;element name="acquisitionCost" ref="xsd:decimal"/&gt;			&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="largePrint" ref="xsd:boolean"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.LoanedHolding" smalltalkClass="Protocols.Library.LoanedHolding" baseType="tns:Protocols.Library.Holding" constraint="extension"/&gt;		&lt;object name="Protocols.Library.Holding" smalltalkClass="Protocols.Library.Holding" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"/&gt;		&lt;object name="Protocols.Library.AbstractRandom" smalltalkClass="Protocols.Library.AbstractRandom"/&gt;		&lt;object name="Protocols.Library.CatalogNumber" smalltalkClass="Protocols.Library.CatalogNumber" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="part4" ref="xsd:string" conversionId="Character"/&gt;			&lt;element name="part1" ref="xsd:string"/&gt;			&lt;element name="part2" ref="xsd:base64Binary"/&gt;			&lt;element name="part3" ref="xsd:double"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.AuthorialName" smalltalkClass="Protocols.Library.AuthorialName"&gt;			&lt;element name="name" ref="tns:Protocols.Library.PersonName"/&gt;			&lt;element name="authorialType" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.PersonName" smalltalkClass="Protocols.Library.PersonName" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="middleNames" ref="xsd:string"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="firstName" ref="xsd:string"/&gt;			&lt;element name="lastName" ref="xsd:string"/&gt;		&lt;/object&gt;	&lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.AuthSearchResponder11 class</class-id> <category>accessing</category><body package="WebServicesDemoModels">interceptors	^OrderedCollection with: DemoHeaderInterceptor11</body></methods><methods><class-id>WebServices.AuthSearchResponder11 class</class-id> <category>instance creation</category><body package="WebServicesDemoModels">start	^self new start</body></methods><methods><class-id>WebServices.AuthenticationTokenExceptionHeader</class-id> <category>accessing</category><body package="WebServicesDemoModels">description	^description ifNil: [ description := 'Wrong authentication information']</body><body package="WebServicesDemoModels">description: aString	description := aString</body></methods><methods><class-id>WebServices.AuthenticationToken</class-id> <category>accessing</category><body package="WebServicesDemoModels">password	^password</body><body package="WebServicesDemoModels">userID	^userID</body></methods><methods><class-id>WebServices.LibraryResponder class</class-id> <category>wsdl schema</category><body package="WebServicesDemoModels">wsdlSchema"self initializeRegistries"^'&lt;definitions targetNamespace="urn:webservices/demo/libraryServices" xmlns:tns="urn:webservices/demo/libraryServices" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns="http://schemas.xmlsoap.org/wsdl/"&gt;	&lt;types&gt;		&lt;schema targetNamespace="urn:webservices/demo/libraryServices" elementFormDefault="qualified" xmlns:tns="urn:webservices/demo/libraryServices" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://www.w3.org/2001/XMLSchema"&gt;			&lt;complexType name="CollectionOfString"&gt;				&lt;sequence&gt;					&lt;element name="String" minOccurs="0" maxOccurs="unbounded" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfBook"&gt;				&lt;sequence&gt;					&lt;element name="Book" minOccurs="0" maxOccurs="unbounded" type="tns:Protocols.Library.Book"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="SearchByWordChoice"&gt;				&lt;sequence&gt;					&lt;choice&gt;						&lt;element name="book" type="tns:Protocols.Library.Book" minOccurs="0"/&gt;						&lt;element name="shipPlan" type="tns:Protocols.Library.ShipPlan" minOccurs="0"/&gt;					&lt;/choice&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfAuthorialName"&gt;				&lt;sequence&gt;					&lt;element name="AuthorialName" minOccurs="0" maxOccurs="unbounded" type="tns:Protocols.Library.AuthorialName"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfWSBook"&gt;				&lt;sequence&gt;					&lt;element name="WSBook" minOccurs="0" maxOccurs="unbounded" type="tns:WSBook"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfLibraryService"&gt;				&lt;sequence&gt;					&lt;element name="LibraryService" minOccurs="0" maxOccurs="unbounded" type="tns:Protocols.Library.LibraryService"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfByteSymbol"&gt;				&lt;sequence&gt;					&lt;element name="ByteSymbol" minOccurs="0" maxOccurs="unbounded" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="WSBook"&gt;				&lt;sequence&gt;					&lt;element name="title" type="xsd:string"/&gt;					&lt;element name="acquisitionNumber" type="xsd:positiveInteger"/&gt;					&lt;element name="statusId" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Agent"&gt;				&lt;sequence&gt;					&lt;element name="borrowedHoldings" type="tns:CollectionOfBook" minOccurs="0"/&gt;					&lt;element name="emailAddresses" type="tns:CollectionOfEmailAddress"/&gt;					&lt;element name="telephoneNumbers" type="tns:CollectionOfTelephoneNumber"/&gt;					&lt;element name="physicalAddress" type="tns:WSPhysicalAddress"/&gt;					&lt;element name="account" type="tns:Protocols.Library.Account"/&gt;					&lt;element name="serviceApprovals" type="tns:CollectionOfByteSymbol"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Library"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Agent"&gt;						&lt;sequence&gt;							&lt;element name="loanedHoldings" type="tns:CollectionOfBook" minOccurs="0"/&gt;							&lt;element name="ownedHoldings" type="tns:CollectionOfBook"/&gt;							&lt;element name="libraryId" type="xsd:string"/&gt;							&lt;element name="libraryName" type="xsd:string"/&gt;							&lt;element name="reservedHoldings" type="tns:CollectionOfBook" minOccurs="0"/&gt;							&lt;element name="affiliatedLibraries" type="tns:CollectionOfWSLibrary" minOccurs="0"/&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="WSLibrary"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Library"&gt;						&lt;sequence&gt;							&lt;element name="ownedHoldingsColl" type="tns:CollectionOfBook"/&gt;							&lt;element name="personalPatrons" type="tns:CollectionOfPerson"/&gt;							&lt;choice&gt;								&lt;element name="text" type="xsd:string" minOccurs="0"/&gt;								&lt;element name="url" type="xsd:anyURI" minOccurs="0"/&gt;							&lt;/choice&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfPerson"&gt;				&lt;sequence&gt;					&lt;element name="Person" maxOccurs="5" type="tns:Protocols.Library.Person"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfWSLibrary"&gt;				&lt;sequence&gt;					&lt;element name="WSLibrary" minOccurs="0" maxOccurs="unbounded" type="tns:WSLibrary"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfEmailAddress"&gt;				&lt;sequence&gt;					&lt;element name="EmailAddress" minOccurs="0" maxOccurs="unbounded" type="tns:Protocols.Library.EmailAddress"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="CollectionOfTelephoneNumber"&gt;				&lt;sequence&gt;					&lt;element name="TelephoneNumber" minOccurs="0" maxOccurs="unbounded" type="tns:Protocols.Library.TelephoneNumber"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.PhysicalAddress"&gt;				&lt;sequence&gt;					&lt;element name="streetAddress1" type="xsd:string"/&gt;					&lt;element name="country" type="xsd:string"/&gt;					&lt;element name="streetAddress2" type="xsd:string"/&gt;					&lt;element name="postalCode" type="xsd:string"/&gt;					&lt;element name="stateOrProvince" type="xsd:string"/&gt;					&lt;element name="city" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="WSPhysicalAddress"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.PhysicalAddress"&gt;						&lt;sequence&gt;							&lt;element name="streetAddress1" type="xsd:string"/&gt;							&lt;element name="country" type="xsd:string"/&gt;							&lt;element name="streetAddress2" type="xsd:string"/&gt;							&lt;element name="postalCode" type="xsd:string"/&gt;							&lt;element name="stateOrProvince" type="xsd:string"/&gt;							&lt;element name="city" type="xsd:string"/&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;element name="SearchByTitles"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="searchByExactTitles" type="tns:CollectionOfString"/&gt;						&lt;element name="includeAffiliatedLibraries" type="xsd:boolean"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="SearchByTitlesResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="SearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="searchByExactTitle" type="xsd:string"/&gt;						&lt;element name="includeAffiliatedLibraries" type="xsd:boolean"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="SearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="SearchByWord"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="searchByTitleWord" type="xsd:string"/&gt;						&lt;element name="includeAffiliatedLibraries" type="xsd:boolean"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="SearchByWordResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:SearchByWordChoice"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="LibraryServicesIdsResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfByteSymbol"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AvailableBooksResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfWSBook"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="HoldingByAcquisitionNumber"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="holdingByAcquisitionNumber" type="xsd:positiveInteger"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="HoldingByAcquisitionNumberResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:Protocols.Library.Book"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="ProvidesServicesResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="xsd:boolean"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="LibraryServicesCollectionResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfLibraryService"/&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;complexType name="Protocols.Library.Book"&gt;				&lt;sequence&gt;					&lt;element name="publicationYear" type="xsd:short"/&gt;					&lt;element name="publisher" type="xsd:string"/&gt;					&lt;element name="acquisitionCost" type="xsd:decimal"/&gt;					&lt;element name="pages" type="xsd:short"/&gt;					&lt;element name="acquisitionNumber" type="xsd:positiveInteger"/&gt;					&lt;element name="braille" type="xsd:boolean"/&gt;					&lt;element name="collectionId" type="xsd:string"/&gt;					&lt;element name="language" type="xsd:string"/&gt;					&lt;element name="statusId" type="xsd:string"/&gt;					&lt;element name="libraryName" type="xsd:string"/&gt;					&lt;element name="title" type="xsd:string"/&gt;					&lt;element name="catalogNumber" type="tns:Protocols.Library.CatalogNumber"/&gt;					&lt;element name="authors" type="tns:CollectionOfAuthorialName"/&gt;					&lt;element name="acquisitionDate" type="xsd:date"/&gt;					&lt;element name="dueDate" type="xsd:date" minOccurs="0"/&gt;					&lt;element name="largePrint" type="xsd:boolean"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.CatalogNumber"&gt;				&lt;sequence&gt;					&lt;element name="part3" type="xsd:double"/&gt;					&lt;element name="part2" type="xsd:base64Binary"/&gt;					&lt;element name="part1" type="xsd:string"/&gt;					&lt;element name="part4" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AuthorialName"&gt;				&lt;sequence&gt;					&lt;element name="name" type="tns:Protocols.Library.PersonName"/&gt;					&lt;element name="authorialType" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.PersonName"&gt;				&lt;sequence&gt;					&lt;element name="middleNames" type="xsd:string"/&gt;					&lt;element name="title" type="xsd:string"/&gt;					&lt;element name="lastName" type="xsd:string"/&gt;					&lt;element name="firstName" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.ShipPlan"&gt;				&lt;sequence&gt;					&lt;element name="scale" type="xsd:float"/&gt;					&lt;element name="architects" type="tns:CollectionOfAuthorialName"/&gt;					&lt;element name="yearDrawn" type="xsd:short"/&gt;					&lt;element name="shipName" type="xsd:string"/&gt;					&lt;element name="numberOfSheets" type="xsd:short"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.HoldingNotFound"/&gt;			&lt;complexType name="Protocols.Library.LibraryService"&gt;				&lt;sequence&gt;					&lt;element name="serviceCharge" type="xsd:decimal"/&gt;					&lt;element name="library" type="tns:WSLibrary"/&gt;					&lt;element name="serviceId" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.EmailAddress"&gt;				&lt;sequence&gt;					&lt;element name="description" type="xsd:string"/&gt;					&lt;element name="address" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.TelephoneNumber"&gt;				&lt;sequence&gt;					&lt;element name="description" type="xsd:string"/&gt;					&lt;element name="type" type="xsd:string"/&gt;					&lt;element name="number" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Account"&gt;				&lt;sequence&gt;					&lt;element name="balance" type="xsd:decimal"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Patron"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Agent"&gt;						&lt;sequence&gt;							&lt;element name="patronId" type="xsd:string"/&gt;							&lt;element name="patronName" type="tns:Protocols.Library.PersonName"/&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Person"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Patron"&gt;						&lt;sequence&gt;							&lt;element name="ssn" type="xsd:positiveInteger"/&gt;							&lt;element name="birthDate" type="xsd:date"/&gt;							&lt;element name="sex" type="xsd:string"/&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;		&lt;/schema&gt;	&lt;/types&gt;	&lt;message name="LibraryServicesIdsSoapIn"/&gt;	&lt;message name="LibraryServicesIdsSoapOut"&gt;		&lt;part name="return" element="tns:LibraryServicesIdsResponse"/&gt;	&lt;/message&gt;	&lt;message name="AvailableBooksSoapIn"/&gt;	&lt;message name="AvailableBooksSoapOut"&gt;		&lt;part name="return" element="tns:AvailableBooksResponse"/&gt;	&lt;/message&gt;	&lt;message name="HoldingByAcquisitionNumberSoapIn"&gt;		&lt;part name="parameter" element="tns:HoldingByAcquisitionNumber"/&gt;	&lt;/message&gt;	&lt;message name="HoldingByAcquisitionNumberSoapOut"&gt;		&lt;part name="return" element="tns:HoldingByAcquisitionNumberResponse"/&gt;	&lt;/message&gt;	&lt;message name="HoldingByAcquisitionNumberFaultHoldingNotFound"&gt;		&lt;part name="holdingNotFound" element="tns:Protocols.Library.HoldingNotFound"/&gt;	&lt;/message&gt;	&lt;message name="ProvidesServicesSoapIn"/&gt;	&lt;message name="ProvidesServicesSoapOut"&gt;		&lt;part name="return" element="tns:ProvidesServicesResponse"/&gt;	&lt;/message&gt;	&lt;message name="LibraryServicesCollectionSoapIn"/&gt;	&lt;message name="LibraryServicesCollectionSoapOut"&gt;		&lt;part name="return" element="tns:LibraryServicesCollectionResponse"/&gt;	&lt;/message&gt;	&lt;message name="SearchByTitlesSoapIn"&gt;		&lt;part name="parameter" element="tns:SearchByTitles"/&gt;	&lt;/message&gt;	&lt;message name="SearchByTitlesSoapOut"&gt;		&lt;part name="return" element="tns:SearchByTitlesResponse"/&gt;	&lt;/message&gt;	&lt;message name="SearchByTitleSoapIn"&gt;		&lt;part name="parameter" element="tns:SearchByTitle"/&gt;	&lt;/message&gt;	&lt;message name="SearchByTitleSoapOut"&gt;		&lt;part name="return" element="tns:SearchByTitleResponse"/&gt;	&lt;/message&gt;	&lt;message name="SearchByWordSoapIn"&gt;		&lt;part name="parameter" element="tns:SearchByWord"/&gt;	&lt;/message&gt;	&lt;message name="SearchByWordSoapOut"&gt;		&lt;part name="return" element="tns:SearchByWordResponse"/&gt;	&lt;/message&gt;	&lt;portType name="WSGeneralServices"&gt;		&lt;operation name="LibraryServicesIds"&gt;			&lt;documentation&gt;The LibraryServicesIds operation returns library services ids&lt;/documentation&gt;			&lt;input message="tns:LibraryServicesIdsSoapIn"/&gt;			&lt;output message="tns:LibraryServicesIdsSoapOut"/&gt;		&lt;/operation&gt;		&lt;operation name="AvailableBooks"&gt;			&lt;documentation&gt;The AvailableBooks returns available books&lt;/documentation&gt;			&lt;input message="tns:AvailableBooksSoapIn"/&gt;			&lt;output message="tns:AvailableBooksSoapOut"/&gt;		&lt;/operation&gt;		&lt;operation name="HoldingByAcquisitionNumber"&gt;			&lt;documentation&gt;The HoldingByAcquisitionNumber operation returns a holding or exception if the holding not found&lt;/documentation&gt;			&lt;input message="tns:HoldingByAcquisitionNumberSoapIn"/&gt;			&lt;output message="tns:HoldingByAcquisitionNumberSoapOut"/&gt;			&lt;fault name="holdingNotFound" message="tns:HoldingByAcquisitionNumberFaultHoldingNotFound"/&gt;		&lt;/operation&gt;		&lt;operation name="ProvidesServices"&gt;			&lt;documentation&gt;The ProvidesServices operation checks if the library has some services. Returns true or false &lt;/documentation&gt;			&lt;input message="tns:ProvidesServicesSoapIn"/&gt;			&lt;output message="tns:ProvidesServicesSoapOut"/&gt;		&lt;/operation&gt;		&lt;operation name="LibraryServicesCollection"&gt;			&lt;documentation&gt;The LibraryServicesCollection operation returns a collection of services&lt;/documentation&gt;			&lt;input message="tns:LibraryServicesCollectionSoapIn"/&gt;			&lt;output message="tns:LibraryServicesCollectionSoapOut"/&gt;		&lt;/operation&gt;	&lt;/portType&gt;	&lt;portType name="WSSearchServices"&gt;		&lt;operation name="SearchByTitles"&gt;			&lt;documentation&gt;The SearchByTitles operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:SearchByTitlesSoapIn"/&gt;			&lt;output message="tns:SearchByTitlesSoapOut"/&gt;		&lt;/operation&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:SearchByTitleSoapIn"/&gt;			&lt;output message="tns:SearchByTitleSoapOut"/&gt;		&lt;/operation&gt;		&lt;operation name="SearchByWord"&gt;			&lt;documentation&gt;The SearchByWord operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:SearchByWordSoapIn"/&gt;			&lt;output message="tns:SearchByWordSoapOut"/&gt;		&lt;/operation&gt;	&lt;/portType&gt;	&lt;binding name="WSGeneralServices" type="tns:WSGeneralServices"&gt;		&lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;		&lt;operation name="LibraryServicesIds"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#LibraryServicesIds" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AvailableBooks"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#AvailableBooks" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="HoldingByAcquisitionNumber"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#HoldingByAcquisitionNumber" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;			&lt;fault name="holdingNotFound"&gt;				&lt;soap:fault use="literal" name="holdingNotFound"/&gt;			&lt;/fault&gt;		&lt;/operation&gt;		&lt;operation name="ProvidesServices"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#ProvidesServices" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="LibraryServicesCollection"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#LibraryServicesCollection" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;	&lt;/binding&gt;	&lt;binding name="WSSearchServices" type="tns:WSSearchServices"&gt;		&lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;		&lt;operation name="SearchByTitles"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#SearchByTitles" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#SearchByTitle" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="SearchByWord"&gt;			&lt;soap:operation soapAction="urn:webservices/demo/libraryServices#SearchByWord" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;	&lt;/binding&gt;	&lt;service name="LibraryServices"&gt;		&lt;port name="WSSearchServices" binding="tns:WSSearchServices"&gt;			&lt;soap:address location="http://localhost:3340/SearchServices"/&gt;		&lt;/port&gt;		&lt;port name="WSGeneralServices" binding="tns:WSGeneralServices"&gt;			&lt;soap:address location="http://localhost:3340/GeneralServices"/&gt;		&lt;/port&gt;	&lt;/service&gt;&lt;/definitions&gt;'</body><body package="WebServicesDemoModels">x2oBinding"self initializeRegistries"^'&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding elementFormDefault="qualified" name="" targetNamespace="urn:webservices/demo/libraryServices" defaultClassNamespace="WebServices" xmlns:tns="urn:webservices/demo/libraryServices" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:visualworks:VWSchemaBinding"&gt;		&lt;sequence_of name="CollectionOfString"&gt;			&lt;element name="String" minOccurs="0" maxOccurs="unbounded" ref="xsd:string"/&gt;		&lt;/sequence_of&gt;		&lt;sequence_of name="CollectionOfBook"&gt;			&lt;element name="Book" minOccurs="0" maxOccurs="unbounded" ref="tns:Protocols.Library.Book"/&gt;		&lt;/sequence_of&gt;		&lt;struct name="SearchByWordChoice"&gt;			&lt;choice name="choiceValue"&gt;				&lt;element name="book" ref="tns:Protocols.Library.Book" minOccurs="0"/&gt;				&lt;element name="shipPlan" ref="tns:Protocols.Library.ShipPlan" minOccurs="0"/&gt;			&lt;/choice&gt;		&lt;/struct&gt;		&lt;sequence_of name="CollectionOfAuthorialName"&gt;			&lt;element name="AuthorialName" minOccurs="0" maxOccurs="unbounded" ref="tns:Protocols.Library.AuthorialName"/&gt;		&lt;/sequence_of&gt;		&lt;sequence_of name="CollectionOfWSBook"&gt;			&lt;element name="WSBook" minOccurs="0" maxOccurs="unbounded" ref="tns:WSBook"/&gt;		&lt;/sequence_of&gt;		&lt;sequence_of name="CollectionOfLibraryService"&gt;			&lt;element name="LibraryService" minOccurs="0" maxOccurs="unbounded" ref="tns:Protocols.Library.LibraryService"/&gt;		&lt;/sequence_of&gt;		&lt;sequence_of name="CollectionOfByteSymbol"&gt;			&lt;element name="ByteSymbol" minOccurs="0" maxOccurs="unbounded" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;/sequence_of&gt;		&lt;object name="WSBook" smalltalkClass="WSBook"&gt;			&lt;element name="title" ref="xsd:string" aspect="text"/&gt;			&lt;element name="acquisitionNumber" ref="xsd:positiveInteger" aspect="acquisitionNumber"/&gt;			&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol" aspect="statusId"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.Agent" smalltalkClass="Protocols.Library.Agent"&gt;			&lt;element name="borrowedHoldings" ref="tns:CollectionOfBook" minOccurs="0" aspect="borrowedHoldings"/&gt;			&lt;element name="emailAddresses" ref="tns:CollectionOfEmailAddress" aspect="emailAddresses"/&gt;			&lt;element name="telephoneNumbers" ref="tns:CollectionOfTelephoneNumber" aspect="telephoneNumbers"/&gt;			&lt;element name="physicalAddress" ref="tns:WSPhysicalAddress" aspect="physicalAddress"/&gt;			&lt;element name="account" ref="tns:Protocols.Library.Account" aspect="account"/&gt;			&lt;element name="serviceApprovals" ref="tns:CollectionOfByteSymbol" aspect="serviceApprovals"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.Library" smalltalkClass="Protocols.Library.Library" baseType="tns:Protocols.Library.Agent"&gt;			&lt;element name="loanedHoldings" ref="tns:CollectionOfBook" minOccurs="0" aspect="loanedHoldings"/&gt;			&lt;element name="ownedHoldings" ref="tns:CollectionOfBook" aspect="ownedHoldings"/&gt;			&lt;element name="libraryId" ref="xsd:string" conversionId="ByteSymbol" aspect="libraryId"/&gt;			&lt;element name="libraryName" ref="xsd:string" aspect="libraryName"/&gt;			&lt;element name="reservedHoldings" ref="tns:CollectionOfBook" minOccurs="0" aspect="reservedHoldings"/&gt;			&lt;element name="affiliatedLibraries" ref="tns:CollectionOfWSLibrary" minOccurs="0" aspect="affiliatedLibraries"/&gt;		&lt;/object&gt;		&lt;object name="WSLibrary" smalltalkClass="WSLibrary" baseType="tns:Protocols.Library.Library"&gt;			&lt;element name="ownedHoldingsColl" ref="tns:CollectionOfBook" aspect="ownedHoldingsColl"/&gt;			&lt;element name="personalPatrons" ref="tns:CollectionOfPerson" aspect="personalPatrons"/&gt;			&lt;choice name="webSiteAddress" aspect="webSiteAddress"&gt;				&lt;element name="text" ref="xsd:string" minOccurs="0"/&gt;				&lt;element name="url" ref="xsd:anyURI" minOccurs="0"/&gt;			&lt;/choice&gt;		&lt;/object&gt;		&lt;sequence_of name="CollectionOfPerson"&gt;			&lt;element name="Person" maxOccurs="5" ref="tns:Protocols.Library.Person"/&gt;		&lt;/sequence_of&gt;		&lt;sequence_of name="CollectionOfWSLibrary"&gt;			&lt;element name="WSLibrary" minOccurs="0" maxOccurs="unbounded" ref="tns:WSLibrary"/&gt;		&lt;/sequence_of&gt;		&lt;sequence_of name="CollectionOfEmailAddress"&gt;			&lt;element name="EmailAddress" minOccurs="0" maxOccurs="unbounded" ref="tns:Protocols.Library.EmailAddress"/&gt;		&lt;/sequence_of&gt;		&lt;sequence_of name="CollectionOfTelephoneNumber"&gt;			&lt;element name="TelephoneNumber" minOccurs="0" maxOccurs="unbounded" ref="tns:Protocols.Library.TelephoneNumber"/&gt;		&lt;/sequence_of&gt;		&lt;object name="Protocols.Library.PhysicalAddress" smalltalkClass="Protocols.Library.PhysicalAddress"&gt;			&lt;element name="streetAddress1" ref="xsd:string" aspect="streetAddress1"/&gt;			&lt;element name="country" ref="xsd:string" conversionId="ByteSymbol" aspect="country"/&gt;			&lt;element name="streetAddress2" ref="xsd:string" aspect="streetAddress2"/&gt;			&lt;element name="postalCode" ref="xsd:string" aspect="postalCode"/&gt;			&lt;element name="stateOrProvince" ref="xsd:string" conversionId="ByteSymbol" aspect="stateOrProvince"/&gt;			&lt;element name="city" ref="xsd:string" aspect="city"/&gt;		&lt;/object&gt;		&lt;object name="WSPhysicalAddress" smalltalkClass="WSPhysicalAddress" baseType="tns:Protocols.Library.PhysicalAddress"&gt;			&lt;element name="streetAddress1" ref="xsd:string" aspect="streetAddress1"/&gt;			&lt;element name="country" ref="xsd:string" conversionId="ByteSymbol" aspect="country"/&gt;			&lt;element name="streetAddress2" ref="xsd:string" aspect="streetAddress2"/&gt;			&lt;element name="postalCode" ref="xsd:string" aspect="postalCode"/&gt;			&lt;element name="stateOrProvince" ref="xsd:string" conversionId="ByteSymbol" aspect="stateOrProvince"/&gt;			&lt;element name="city" ref="xsd:string" aspect="city"/&gt;		&lt;/object&gt;		&lt;struct name="SearchByTitles" smalltalkClass="Struct"&gt;			&lt;element name="searchByExactTitles" ref="tns:CollectionOfString"/&gt;			&lt;element name="includeAffiliatedLibraries" ref="xsd:boolean"/&gt;		&lt;/struct&gt;		&lt;struct name="SearchByTitlesResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="tns:CollectionOfBook"/&gt;		&lt;/struct&gt;		&lt;struct name="SearchByTitle" smalltalkClass="Struct"&gt;			&lt;element name="searchByExactTitle" ref="xsd:string"/&gt;			&lt;element name="includeAffiliatedLibraries" ref="xsd:boolean"/&gt;		&lt;/struct&gt;		&lt;struct name="SearchByTitleResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="tns:CollectionOfBook"/&gt;		&lt;/struct&gt;		&lt;struct name="SearchByWord" smalltalkClass="Struct"&gt;			&lt;element name="searchByTitleWord" ref="xsd:string"/&gt;			&lt;element name="includeAffiliatedLibraries" ref="xsd:boolean"/&gt;		&lt;/struct&gt;		&lt;struct name="SearchByWordResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="tns:SearchByWordChoice"/&gt;		&lt;/struct&gt;		&lt;struct name="LibraryServicesIdsResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="tns:CollectionOfByteSymbol"/&gt;		&lt;/struct&gt;		&lt;struct name="AvailableBooksResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="tns:CollectionOfWSBook"/&gt;		&lt;/struct&gt;		&lt;struct name="HoldingByAcquisitionNumber" smalltalkClass="Struct"&gt;			&lt;element name="holdingByAcquisitionNumber" ref="xsd:positiveInteger"/&gt;		&lt;/struct&gt;		&lt;struct name="HoldingByAcquisitionNumberResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="tns:Protocols.Library.Book"/&gt;		&lt;/struct&gt;		&lt;struct name="ProvidesServicesResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="xsd:boolean"/&gt;		&lt;/struct&gt;		&lt;struct name="LibraryServicesCollectionResponse" smalltalkClass="Struct"&gt;			&lt;element name="result" ref="tns:CollectionOfLibraryService"/&gt;		&lt;/struct&gt;		&lt;object name="Protocols.Library.Book" smalltalkClass="Protocols.Library.Book"&gt;			&lt;element name="publicationYear" ref="xsd:short" aspect="publicationYear"/&gt;			&lt;element name="publisher" ref="xsd:string" aspect="publisher"/&gt;			&lt;element name="acquisitionCost" ref="xsd:decimal" aspect="acquisitionCost"/&gt;			&lt;element name="pages" ref="xsd:short" aspect="pages"/&gt;			&lt;element name="acquisitionNumber" ref="xsd:positiveInteger" aspect="acquisitionNumber"/&gt;			&lt;element name="braille" ref="xsd:boolean" aspect="braille"/&gt;			&lt;element name="collectionId" ref="xsd:string" conversionId="ByteSymbol" aspect="collectionId"/&gt;			&lt;element name="language" ref="xsd:string" conversionId="ByteSymbol" aspect="language"/&gt;			&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol" aspect="statusId"/&gt;			&lt;element name="libraryName" ref="xsd:string" aspect="libraryName"/&gt;			&lt;element name="title" ref="xsd:string" aspect="title"/&gt;			&lt;element name="catalogNumber" ref="tns:Protocols.Library.CatalogNumber" aspect="catalogNumber"/&gt;			&lt;element name="authors" ref="tns:CollectionOfAuthorialName" aspect="authors"/&gt;			&lt;element name="acquisitionDate" ref="xsd:date" aspect="acquisitionDate"/&gt;			&lt;element name="dueDate" ref="xsd:date" minOccurs="0" aspect="dueDate"/&gt;			&lt;element name="largePrint" ref="xsd:boolean" aspect="largePrint"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.CatalogNumber" smalltalkClass="Protocols.Library.CatalogNumber"&gt;			&lt;element name="part3" ref="xsd:double" aspect="part3"/&gt;			&lt;element name="part2" ref="xsd:base64Binary" aspect="part2"/&gt;			&lt;element name="part1" ref="xsd:string" aspect="part1"/&gt;			&lt;element name="part4" ref="xsd:string" conversionId="Character" aspect="part4"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.AuthorialName" smalltalkClass="Protocols.Library.AuthorialName"&gt;			&lt;element name="name" ref="tns:Protocols.Library.PersonName" aspect="name"/&gt;			&lt;element name="authorialType" ref="xsd:string" conversionId="ByteSymbol" aspect="authorialType"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.PersonName" smalltalkClass="Protocols.Library.PersonName"&gt;			&lt;element name="middleNames" ref="xsd:string" aspect="middleNames"/&gt;			&lt;element name="title" ref="xsd:string" aspect="title"/&gt;			&lt;element name="lastName" ref="xsd:string" aspect="lastName"/&gt;			&lt;element name="firstName" ref="xsd:string" aspect="firstName"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.ShipPlan" smalltalkClass="Protocols.Library.ShipPlan"&gt;			&lt;element name="scale" ref="xsd:float" aspect="scale"/&gt;			&lt;element name="architects" ref="tns:CollectionOfAuthorialName" aspect="architects"/&gt;			&lt;element name="yearDrawn" ref="xsd:short" aspect="yearDrawn"/&gt;			&lt;element name="shipName" ref="xsd:string" aspect="shipName"/&gt;			&lt;element name="numberOfSheets" ref="xsd:short" aspect="numberOfSheets"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.HoldingNotFound" smalltalkClass="Protocols.Library.HoldingNotFound"/&gt;		&lt;object name="Protocols.Library.LibraryService" smalltalkClass="Protocols.Library.LibraryService"&gt;			&lt;element name="serviceCharge" ref="xsd:decimal" aspect="serviceCharge"/&gt;			&lt;element name="library" ref="tns:WSLibrary" aspect="library"/&gt;			&lt;element name="serviceId" ref="xsd:string" conversionId="ByteSymbol" aspect="serviceId"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.EmailAddress" smalltalkClass="Protocols.Library.EmailAddress"&gt;			&lt;element name="description" ref="xsd:string" aspect="description"/&gt;			&lt;element name="address" ref="xsd:string" aspect="address"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.TelephoneNumber" smalltalkClass="Protocols.Library.TelephoneNumber"&gt;			&lt;element name="description" ref="xsd:string" aspect="description"/&gt;			&lt;element name="type" ref="xsd:string" conversionId="ByteSymbol" aspect="type"/&gt;			&lt;element name="number" ref="xsd:string" aspect="number"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.Account" smalltalkClass="Protocols.Library.Account"&gt;			&lt;element name="balance" ref="xsd:decimal" aspect="balance"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.Patron" smalltalkClass="Protocols.Library.Patron" baseType="tns:Protocols.Library.Agent"&gt;			&lt;element name="patronId" ref="xsd:string" conversionId="ByteSymbol" aspect="patronId"/&gt;			&lt;element name="patronName" ref="tns:Protocols.Library.PersonName" aspect="patronName"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.Person" smalltalkClass="Protocols.Library.Person" baseType="tns:Protocols.Library.Patron"&gt;			&lt;element name="ssn" ref="xsd:positiveInteger" aspect="ssn"/&gt;			&lt;element name="birthDate" ref="xsd:date" aspect="birthDate"/&gt;			&lt;element name="sex" ref="xsd:string" conversionId="Character" aspect="sex"/&gt;		&lt;/object&gt;	&lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.LibraryResponder class</class-id> <category>accessing</category><body package="WebServicesDemoModels">serviceMap	 " WebServices.ServiceMap loadFrom: LibraryServer serviceMap readStream " 	^'&lt;ns:serviceMaps xmlns:ns="urn:visualworks:serviceMap" xmlns:ns0="urn:webservices/demo/libraryServices"&gt;	&lt;ns:serviceMap&gt;		&lt;ns:serviceClass&gt;WebServices.WSSearchServices&lt;/ns:serviceClass&gt;		&lt;ns:interface&gt;ns0:WSSearchServices&lt;/ns:interface&gt;		&lt;ns:operation name="SearchByWord" selector="searchByTitleWord:includeAffiliatedLibraries:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="SearchByTitle" selector="searchByExactTitle:includeAffiliatedLibraries:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="SearchByTitles" selector="searchByExactTitles:includeAffiliatedLibraries:"&gt;&lt;/ns:operation&gt;	&lt;/ns:serviceMap&gt;	&lt;ns:serviceMap&gt;		&lt;ns:serviceClass&gt;WebServices.WSGeneralServices&lt;/ns:serviceClass&gt;		&lt;ns:interface&gt;ns0:WSGeneralServices&lt;/ns:interface&gt;		&lt;ns:operation name="AvailableBooks" selector="availableBooks"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="LibraryServicesCollection" selector="libraryServicesCollection"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="ProvidesServices" selector="providesServices"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="LibraryServicesIds" selector="libraryServicesIds"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="HoldingByAcquisitionNumber" selector="holdingByAcquisitionNumber:"&gt;&lt;/ns:operation&gt;	&lt;/ns:serviceMap&gt;&lt;/ns:serviceMaps&gt;'</body></methods><methods><class-id>WebServices.WSAuthenticatedSearchService</class-id> <category>initialize-release</category><body package="WebServicesDemoModels">initialize	library := Library cityPublicLibrary.	library serviceApprovals: library serviceApprovals asOrderedCollection.	library addService: self.</body></methods><methods><class-id>WebServices.DemoHeaderInterceptor20</class-id> <category>processing callbacks</category><body package="WebServicesDemoModels">receivingFailedReply: aReply	aReply 		headerAt: #AuthenticationTokenExceptionHeader 		ifAbsent: [ self error: 'There is no #AuthenticationTokenExceptionHeader header ' ].	"Raise an exception if the detail contents was unmarshaled as subclass of Exception "	^aReply raiseException</body><body package="WebServicesDemoModels">sendingFailedReply: aReply	"The fault reply should be created with headers. See Wsdl binding fault description:	&lt;fault ref='tns:AuthenticationTokenException' wsoap:code='SOAP-ENV:Sender' wsoap:subcodes='tns:WrongAuthenticationToken'&gt;		&lt;wsoap:header element='ns:AuthenticationTokenExceptionHeader' mustUnderstand='true' required='true'/&gt;	&lt;/fault&gt;"	(aReply hasException: AuthenticationTokenException)		ifTrue: [aReply reply headerAt: #AuthenticationTokenExceptionHeader put: AuthenticationTokenExceptionHeader new]</body></methods><methods><class-id>WebServices.Customer</class-id> <category>accessing</category><body package="WebServicesDemoModels">address	^address</body><body package="WebServicesDemoModels">id	^id</body><body package="WebServicesDemoModels">name	^name</body><body package="WebServicesDemoModels">rating	^rating</body><body package="WebServicesDemoModels">rating: anObject	rating := anObject</body></methods><methods><class-id>WebServices.ChoiceOfHoldings</class-id> <category>accessing</category><body package="WebServicesDemoModels">choiceValue	^choiceValue</body><body package="WebServicesDemoModels">choiceValue: aStruct	choiceValue := aStruct</body></methods><methods><class-id>WebServices.ChoiceOfHoldings class</class-id> <category>instance creation</category><body package="WebServicesDemoModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>WebServices.DemoProcessingPolicy</class-id> <category>accessing</category><body package="WebServicesDemoModels">accessLevel	^accessLevel</body><body package="WebServicesDemoModels">accessLevel: anObject	accessLevel := anObject</body><body package="WebServicesDemoModels">password	^password</body><body package="WebServicesDemoModels">password: anObject	password := anObject</body><body package="WebServicesDemoModels">userID	^userID</body><body package="WebServicesDemoModels">userID: anObject	userID := anObject</body></methods><methods><class-id>WebServices.WSGeneralServices</class-id> <category>initialize-release</category><body package="WebServicesDemoModels">initialize	library := WSLibrary cityPublicLibrary.	library serviceApprovals: library serviceApprovals asOrderedCollection.	library addService: self.</body></methods><methods><class-id>WebServices.ClientForAuthSearch20</class-id> <category>public api</category><body package="WebServicesDemoModels">authenticatedSearchByTitle: aString 		| args |	args := Array with: aString.	^self executeSelector: #'AuthenticatedSearchByTitle' args: args.</body><body package="WebServicesDemoModels">authenticatedSearchByWord: aString 		| args |	args := Array with: aString.	^self executeSelector: #'AuthenticatedSearchByWord' args: args.</body><body package="WebServicesDemoModels">searchByTitle: aString 		| args |	args := Array with: aString.	^self executeSelector: #'SearchByTitle' args: args.</body></methods><methods><class-id>WebServices.ClientForAuthSearch20 class</class-id> <category>accessing</category><body package="WebServicesDemoModels">bindingName	^'WSAuthenticatedSearchService'</body><body package="WebServicesDemoModels">bindingTargetNamespace	^'urn:LibraryDemo/20/testSoapHeaders'</body><body package="WebServicesDemoModels">processingPolicy	^DemoProcessingPolicy new 		interceptorClasses: (OrderedCollection with: DemoHeaderInterceptor20) ; 		yourself</body></methods><methods><class-id>WebServices.ClientForAuthSearch20 class</class-id> <category>wsdl schema</category><body package="WebServicesDemoModels">serviceMap	 " WebServices.ServiceMap loadFrom: WSAuthenticatedSearchServiceClient serviceMap readStream " 	^'&lt;ns:serviceMap xmlns:ns0="urn:LibraryDemo/20/testSoapHeaders" xmlns:ns="urn:visualworks:serviceMap"&gt;	&lt;ns:serviceClass&gt;WebServices.WSAuthenticatedSearchService&lt;/ns:serviceClass&gt;	&lt;ns:interface&gt;ns0:WSAuthenticatedSearchService&lt;/ns:interface&gt;	&lt;ns:operation name="SearchByTitle" selector="searchByTitle:"/&gt;	&lt;ns:operation name="AuthenticatedSearchByTitle" selector="authenticatedSearchByTitle:"/&gt;	&lt;ns:operation name="AuthenticatedSearchByWord" selector="authenticatedSearchByWord:"/&gt;&lt;/ns:serviceMap&gt;'</body><body package="WebServicesDemoModels">wsdlSchema^'&lt;description targetNamespace="urn:LibraryDemo/20/testSoapHeaders" xmlns="http://www.w3.org/ns/wsdl" xmlns:ns="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders" xmlns:wsoap="http://www.w3.org/ns/wsdl/soap"&gt;	&lt;types&gt;		&lt;schema targetNamespace="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/20/testSoapHeaders" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;import namespace="urn:LibraryDemo/20/testSoapHeaders"&gt;&lt;/import&gt;			&lt;element name="SearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;complexType name="CollectionOfBook"&gt;				&lt;sequence&gt;					&lt;element maxOccurs="unbounded" minOccurs="0" name="Book" type="ns:Protocols.Library.Book"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;element name="SearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWord"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWordResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticationTokenException" type="ns:AuthenticationTokenException"&gt;&lt;/element&gt;			&lt;element name="AuthenticationTokenExceptionHeader" type="ns:AuthenticationTokenExceptionHeader"&gt;&lt;/element&gt;			&lt;element name="AccessLevel" type="xsd:string"&gt;&lt;/element&gt;			&lt;element name="AuthenticationToken" type="ns:AuthenticationToken"&gt;&lt;/element&gt;			&lt;element name="Confirmation" type="ns:Confirmation"&gt;&lt;/element&gt;		&lt;/schema&gt;		&lt;schema targetNamespace="urn:LibraryDemo/20/testSoapHeaders" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;complexType name="AuthenticationToken"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;		&lt;complexType name="AuthenticationTokenExceptionHeader"&gt;			&lt;element name="description" type="xsd:string"&gt;&lt;/element&gt;		&lt;/complexType&gt;			&lt;complexType name="AuthenticationTokenException"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Confirmation"&gt;				&lt;sequence&gt;					&lt;element name="return" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="WrongPasswordException"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Book"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.LoanedHolding"&gt;						&lt;sequence&gt;							&lt;element minOccurs="0" name="dueDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="acquisitionDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="language" type="xsd:string"&gt;&lt;/element&gt;							&lt;element maxOccurs="unbounded" minOccurs="0" name="authors" type="tns:Protocols.Library.AuthorialName"&gt;&lt;/element&gt;							&lt;element name="acquisitionNumber" type="xsd:positiveInteger"&gt;&lt;/element&gt;							&lt;element name="publisher" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="braille" type="xsd:boolean"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="catalogNumber" type="tns:Protocols.Library.CatalogNumber"&gt;&lt;/element&gt;							&lt;element name="pages" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="libraryName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="collectionId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="publicationYear" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="acquisitionCost" type="xsd:decimal"&gt;&lt;/element&gt;							&lt;element name="statusId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="largePrint" type="xsd:boolean"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.LoanedHolding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Holding"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Holding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AbstractRandom"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.CatalogNumber"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="part4" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part1" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part2" type="xsd:base64Binary"&gt;&lt;/element&gt;							&lt;element name="part3" type="xsd:double"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AuthorialName"&gt;				&lt;sequence&gt;					&lt;element name="name" type="tns:Protocols.Library.PersonName"&gt;&lt;/element&gt;					&lt;element name="authorialType" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.PersonName"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="middleNames" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="firstName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="lastName" type="xsd:string"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;		&lt;/schema&gt;	&lt;/types&gt;	&lt;interface name="WSAuthenticatedSearchService"&gt;		&lt;fault element="ns:AuthenticationTokenException" name="AuthenticationTokenException"&gt;&lt;/fault&gt;		&lt;operation name="SearchByTitle" pattern="http://www.w3.org/ns/wsdl/in-out" style="http://www.w3.org/ns/wsdl/style/iri"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input element="ns:SearchByTitle" messageLabel="In"&gt;&lt;/input&gt;			&lt;output element="ns:SearchByTitleResponse" messageLabel="Out"&gt;&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByTitle" pattern="http://www.w3.org/ns/wsdl/in-out" style="http://www.w3.org/ns/wsdl/style/iri"&gt;			&lt;documentation&gt;The AuthenticatedSearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input element="ns:AuthenticatedSearchByTitle" messageLabel="In"&gt;&lt;/input&gt;			&lt;output element="ns:AuthenticatedSearchByTitleResponse" messageLabel="Out"&gt;&lt;/output&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByWord" pattern="http://www.w3.org/ns/wsdl/in-out" style="http://www.w3.org/ns/wsdl/style/iri"&gt;			&lt;documentation&gt;To be able to make this request the message should include authentication token and access level. The AuthenticatedSearchByWord operation returns a collection of books or empty collection if no books found&lt;/documentation&gt;			&lt;input element="ns:AuthenticatedSearchByWord" messageLabel="In"&gt;&lt;/input&gt;			&lt;output element="ns:AuthenticatedSearchByWordResponse" messageLabel="Out"&gt;&lt;/output&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;	&lt;/interface&gt;	&lt;binding interface="tns:WSAuthenticatedSearchService" name="WSAuthenticatedSearchService" type="http://www.w3.org/ns/wsdl/soap" wsoap:mepDefault="http://www.w3.org/2003/05/soap/mep/request-response/" wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/" wsoap:version="1.2"&gt;		&lt;fault ref="tns:AuthenticationTokenException" wsoap:code="SOAP-ENV:Sender" wsoap:subcodes="tns:WrongAuthenticationToken"&gt;			&lt;wsoap:header element="ns:AuthenticationTokenExceptionHeader" mustUnderstand="true" required="true"/&gt;		&lt;/fault&gt;		&lt;operation ref="tns:SearchByTitle" wsoap:action="urn:LibraryDemo/20/testSoapHeaders#SearchByTitle"&gt;			&lt;input&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/input&gt;		&lt;/operation&gt;		&lt;operation ref="tns:AuthenticatedSearchByTitle" wsoap:action="urn:LibraryDemo/20/testSoapHeaders#AuthenticatedSearchByTitle"&gt;			&lt;input&gt;				&lt;wsoap:header element="ns:AuthenticationToken" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/input&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;		&lt;operation ref="tns:AuthenticatedSearchByWord" wsoap:action="urn:LibraryDemo/20/testSoapHeaders#AuthenticatedSearchByWord"&gt;			&lt;input&gt;				&lt;wsoap:header element="ns:AuthenticationToken" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;wsoap:header element="ns:Confirmation" mustUnderstand="true" required="false"&gt;&lt;/wsoap:header&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/output&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;	&lt;/binding&gt;	&lt;service interface="tns:WSAuthenticatedSearchService" name="TestLibraryServicesWithHeaders"&gt;		&lt;endpoint address="http://localhost:4444/testSoapHeadersServices" binding="tns:WSAuthenticatedSearchService" name="WSAuthenticatedSearchService"&gt;&lt;/endpoint&gt;	&lt;/service&gt;&lt;/description&gt;'</body><body package="WebServicesDemoModels">x2oBinding	"self initializeRegistries"^'&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/20/testSoapHeaders" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations"&gt;		&lt;bindingImport namespace="urn:LibraryDemo/20/testSoapHeaders"/&gt;		&lt;element name="SearchByTitle"&gt;			&lt;struct name="SearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;sequence_of name="CollectionOfBook" smalltalkClass="OrderedCollection"&gt;			&lt;element name="Book" maxOccurs="unbounded" minOccurs="0" ref="ns:Protocols.Library.Book"/&gt;		&lt;/sequence_of&gt;		&lt;element name="SearchByTitleResponse"&gt;			&lt;struct name="SearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitle"&gt;			&lt;struct name="AuthenticatedSearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitleResponse"&gt;			&lt;struct name="AuthenticatedSearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWord"&gt;			&lt;struct name="AuthenticatedSearchByWord"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWordResponse"&gt;			&lt;struct name="AuthenticatedSearchByWordResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticationTokenException" ref="ns:AuthenticationTokenException"/&gt;		&lt;element name="AuthenticationTokenExceptionHeader" ref="ns:AuthenticationTokenExceptionHeader"/&gt;		&lt;element name="AccessLevel" ref="xsd:string"/&gt;		&lt;element name="AuthenticationToken" ref="ns:AuthenticationToken"/&gt;		&lt;element name="Confirmation" ref="ns:Confirmation"/&gt;	&lt;/xmlToSmalltalkBinding&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/20/testSoapHeaders" defaultClassNamespace="WebServices" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders"&gt;		&lt;object name="AuthenticationToken" smalltalkClass="AuthenticationToken"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenExceptionHeader" smalltalkClass="AuthenticationTokenExceptionHeader"&gt;			&lt;element name="description" type="xsd:string"&gt;&lt;/element&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenException" smalltalkClass="AuthenticationTokenException"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="Confirmation" smalltalkClass="Confirmation"&gt;			&lt;element name="return" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="WrongPasswordException" smalltalkClass="WrongPasswordException"/&gt;		&lt;object name="Protocols.Library.Book" smalltalkClass="Protocols.Library.Book" baseType="tns:Protocols.Library.LoanedHolding" constraint="extension"&gt;			&lt;element name="dueDate" minOccurs="0" ref="xsd:date"/&gt;			&lt;element name="acquisitionDate" ref="xsd:date"/&gt;			&lt;element name="language" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="authors" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.AuthorialName"/&gt;			&lt;element name="acquisitionNumber" ref="xsd:positiveInteger"/&gt;			&lt;element name="publisher" ref="xsd:string"/&gt;			&lt;element name="braille" ref="xsd:boolean"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="catalogNumber" ref="tns:Protocols.Library.CatalogNumber"/&gt;			&lt;element name="pages" ref="xsd:short"/&gt;			&lt;element name="libraryName" ref="xsd:string"/&gt;			&lt;element name="collectionId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="publicationYear" ref="xsd:short"/&gt;			&lt;element name="acquisitionCost" ref="xsd:decimal"/&gt;			&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="largePrint" ref="xsd:boolean"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.LoanedHolding" smalltalkClass="Protocols.Library.LoanedHolding" baseType="tns:Protocols.Library.Holding" constraint="extension"/&gt;		&lt;object name="Protocols.Library.Holding" smalltalkClass="Protocols.Library.Holding" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"/&gt;		&lt;object name="Protocols.Library.AbstractRandom" smalltalkClass="Protocols.Library.AbstractRandom"/&gt;		&lt;object name="Protocols.Library.CatalogNumber" smalltalkClass="Protocols.Library.CatalogNumber" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="part4" ref="xsd:string" conversionId="Character"/&gt;			&lt;element name="part1" ref="xsd:string"/&gt;			&lt;element name="part2" ref="xsd:base64Binary"/&gt;			&lt;element name="part3" ref="xsd:double"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.AuthorialName" smalltalkClass="Protocols.Library.AuthorialName"&gt;			&lt;element name="name" ref="tns:Protocols.Library.PersonName"/&gt;			&lt;element name="authorialType" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.PersonName" smalltalkClass="Protocols.Library.PersonName" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="middleNames" ref="xsd:string"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="firstName" ref="xsd:string"/&gt;			&lt;element name="lastName" ref="xsd:string"/&gt;		&lt;/object&gt;	&lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.AuthenticationTokenException</class-id> <category>accessing</category><body package="WebServicesDemoModels">password	^password</body><body package="WebServicesDemoModels">userID	^userID</body></methods><methods><class-id>WebServices.AuthenticationTokenException class</class-id> <category>accessing</category><body package="WebServicesDemoModels">headerName	^#AuthenticationToken</body></methods><methods><class-id>WebServices.SpecialCustomer</class-id> <category>accessing</category><body package="WebServicesDemoModels">something1: aValue	something1 := aValue</body><body package="WebServicesDemoModels">something2: aValue	something2 := aValue</body></methods><methods><class-id>WebServices.DemoHeaderInterceptor11</class-id> <category>processing callbacks</category><body package="WebServicesDemoModels">receivingFailedReply: aReply	(aReply 		headerAt: #AuthenticationTokenException 		ifAbsent: [ self error: 'There is no #AuthenticationTokenException header ' ]) ifNotNil: [ :header | header value raise ]</body><body package="WebServicesDemoModels">sendingFailedReply: aReply	 "Add Soap header for the reply from the fault details "	(aReply headerFor: #'AuthenticationTokenException') ifNotNil: [ :header | header value: aReply reply detail ]</body></methods><methods><class-id>WebServices.CategoryType</class-id> <category>accessing</category><body package="WebServicesDemoModels">attr	^attr</body><body package="WebServicesDemoModels">attr: anObject	attr := anObject</body><body package="WebServicesDemoModels">choiceValue	^choiceValue</body><body package="WebServicesDemoModels">choiceValue: anAssociation	choiceValue := anAssociation</body><body package="WebServicesDemoModels">end	^end</body><body package="WebServicesDemoModels">end: anObject	end := anObject</body><body package="WebServicesDemoModels">groupValue	^groupValue</body><body package="WebServicesDemoModels">groupValue1	^groupValue1</body><body package="WebServicesDemoModels">groupValue1: aStruct	groupValue1 := aStruct</body><body package="WebServicesDemoModels">groupValue: aStruct	groupValue := aStruct</body><body package="WebServicesDemoModels">id	^id</body><body package="WebServicesDemoModels">id: anObject	id := anObject</body><body package="WebServicesDemoModels">sequenceValue	^sequenceValue</body><body package="WebServicesDemoModels">sequenceValue1	^sequenceValue1</body><body package="WebServicesDemoModels">sequenceValue1: anObject	sequenceValue1 := anObject</body><body package="WebServicesDemoModels">sequenceValue: anObject	sequenceValue := anObject</body></methods><methods><class-id>WebServices.AuthSearchResponder20 class</class-id> <category>accessing</category><body package="WebServicesDemoModels">interceptors	^OrderedCollection with: DemoHeaderInterceptor20</body></methods><methods><class-id>WebServices.AuthSearchResponder20 class</class-id> <category>wsdl schema</category><body package="WebServicesDemoModels">serviceMap	 " WebServices.ServiceMap loadFrom: MyAuthSearchServer serviceMap readStream " 	^'&lt;ns:serviceMaps xmlns:ns="urn:visualworks:serviceMap" xmlns:ns0="urn:LibraryDemo/20/testSoapHeaders"&gt;	&lt;ns:serviceMap&gt;		&lt;ns:serviceClass&gt;WebServices.WSAuthenticatedSearchService&lt;/ns:serviceClass&gt;		&lt;ns:interface&gt;ns0:WSAuthenticatedSearchService&lt;/ns:interface&gt;		&lt;ns:operation name="SearchByTitle" selector="searchByTitle:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="AuthenticatedSearchByTitle" selector="authenticatedSearchByTitle:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="AuthenticatedSearchByWord" selector="authenticatedSearchByWord:"&gt;&lt;/ns:operation&gt;	&lt;/ns:serviceMap&gt;&lt;/ns:serviceMaps&gt;'</body><body package="WebServicesDemoModels">wsdlSchema^'&lt;description targetNamespace="urn:LibraryDemo/20/testSoapHeaders" xmlns="http://www.w3.org/ns/wsdl" xmlns:ns="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders" xmlns:wsoap="http://www.w3.org/ns/wsdl/soap"&gt;	&lt;types&gt;		&lt;schema targetNamespace="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/20/testSoapHeaders" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;import namespace="urn:LibraryDemo/20/testSoapHeaders"&gt;&lt;/import&gt;			&lt;element name="SearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;complexType name="CollectionOfBook"&gt;				&lt;sequence&gt;					&lt;element maxOccurs="unbounded" minOccurs="0" name="Book" type="ns:Protocols.Library.Book"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;element name="SearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitle"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByTitleResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWord"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="parameter" type="xsd:string"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticatedSearchByWordResponse"&gt;				&lt;complexType&gt;					&lt;sequence&gt;						&lt;element name="result" type="tns:CollectionOfBook"&gt;&lt;/element&gt;					&lt;/sequence&gt;				&lt;/complexType&gt;			&lt;/element&gt;			&lt;element name="AuthenticationTokenException" type="ns:AuthenticationTokenException"&gt;&lt;/element&gt;			&lt;element name="AuthenticationTokenExceptionHeader" type="ns:AuthenticationTokenExceptionHeader"&gt;&lt;/element&gt;			&lt;element name="AccessLevel" type="xsd:string"&gt;&lt;/element&gt;			&lt;element name="AuthenticationToken" type="ns:AuthenticationToken"&gt;&lt;/element&gt;			&lt;element name="Confirmation" type="ns:Confirmation"&gt;&lt;/element&gt;		&lt;/schema&gt;		&lt;schema targetNamespace="urn:LibraryDemo/20/testSoapHeaders" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;			&lt;complexType name="AuthenticationToken"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;		&lt;complexType name="AuthenticationTokenExceptionHeader"&gt;			&lt;element name="description" type="xsd:string"&gt;&lt;/element&gt;		&lt;/complexType&gt;			&lt;complexType name="AuthenticationTokenException"&gt;				&lt;sequence&gt;					&lt;element name="password" type="xsd:string"&gt;&lt;/element&gt;					&lt;element name="userID" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Confirmation"&gt;				&lt;sequence&gt;					&lt;element name="return" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="WrongPasswordException"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Book"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.LoanedHolding"&gt;						&lt;sequence&gt;							&lt;element minOccurs="0" name="dueDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="acquisitionDate" type="xsd:date"&gt;&lt;/element&gt;							&lt;element name="language" type="xsd:string"&gt;&lt;/element&gt;							&lt;element maxOccurs="unbounded" minOccurs="0" name="authors" type="tns:Protocols.Library.AuthorialName"&gt;&lt;/element&gt;							&lt;element name="acquisitionNumber" type="xsd:positiveInteger"&gt;&lt;/element&gt;							&lt;element name="publisher" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="braille" type="xsd:boolean"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="catalogNumber" type="tns:Protocols.Library.CatalogNumber"&gt;&lt;/element&gt;							&lt;element name="pages" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="libraryName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="collectionId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="publicationYear" type="xsd:short"&gt;&lt;/element&gt;							&lt;element name="acquisitionCost" type="xsd:decimal"&gt;&lt;/element&gt;							&lt;element name="statusId" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="largePrint" type="xsd:boolean"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.LoanedHolding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.Holding"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.Holding"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AbstractRandom"&gt;&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.CatalogNumber"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="part4" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part1" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="part2" type="xsd:base64Binary"&gt;&lt;/element&gt;							&lt;element name="part3" type="xsd:double"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.AuthorialName"&gt;				&lt;sequence&gt;					&lt;element name="name" type="tns:Protocols.Library.PersonName"&gt;&lt;/element&gt;					&lt;element name="authorialType" type="xsd:string"&gt;&lt;/element&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;			&lt;complexType name="Protocols.Library.PersonName"&gt;				&lt;complexContent&gt;					&lt;extension base="tns:Protocols.Library.AbstractRandom"&gt;						&lt;sequence&gt;							&lt;element name="middleNames" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="title" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="firstName" type="xsd:string"&gt;&lt;/element&gt;							&lt;element name="lastName" type="xsd:string"&gt;&lt;/element&gt;						&lt;/sequence&gt;					&lt;/extension&gt;				&lt;/complexContent&gt;			&lt;/complexType&gt;		&lt;/schema&gt;	&lt;/types&gt;	&lt;interface name="WSAuthenticatedSearchService"&gt;		&lt;fault element="ns:AuthenticationTokenException" name="AuthenticationTokenException"&gt;&lt;/fault&gt;		&lt;operation name="SearchByTitle" pattern="http://www.w3.org/ns/wsdl/in-out" style="http://www.w3.org/ns/wsdl/style/iri"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input element="ns:SearchByTitle" messageLabel="In"&gt;&lt;/input&gt;			&lt;output element="ns:SearchByTitleResponse" messageLabel="Out"&gt;&lt;/output&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByTitle" pattern="http://www.w3.org/ns/wsdl/in-out" style="http://www.w3.org/ns/wsdl/style/iri"&gt;			&lt;documentation&gt;The AuthenticatedSearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input element="ns:AuthenticatedSearchByTitle" messageLabel="In"&gt;&lt;/input&gt;			&lt;output element="ns:AuthenticatedSearchByTitleResponse" messageLabel="Out"&gt;&lt;/output&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;		&lt;operation name="AuthenticatedSearchByWord" pattern="http://www.w3.org/ns/wsdl/in-out" style="http://www.w3.org/ns/wsdl/style/iri"&gt;			&lt;documentation&gt;To be able to make this request the message should include authentication token and access level. The AuthenticatedSearchByWord operation returns a collection of books or empty collection if no books found&lt;/documentation&gt;			&lt;input element="ns:AuthenticatedSearchByWord" messageLabel="In"&gt;&lt;/input&gt;			&lt;output element="ns:AuthenticatedSearchByWordResponse" messageLabel="Out"&gt;&lt;/output&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;	&lt;/interface&gt;	&lt;binding interface="tns:WSAuthenticatedSearchService" name="WSAuthenticatedSearchService" type="http://www.w3.org/ns/wsdl/soap" wsoap:mepDefault="http://www.w3.org/2003/05/soap/mep/request-response/" wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/" wsoap:version="1.2"&gt;		&lt;fault ref="tns:AuthenticationTokenException" wsoap:code="SOAP-ENV:Sender" wsoap:subcodes="tns:WrongAuthenticationToken"&gt;			&lt;wsoap:header element="ns:AuthenticationTokenExceptionHeader" mustUnderstand="true" required="true"/&gt;		&lt;/fault&gt;		&lt;operation ref="tns:SearchByTitle" wsoap:action="urn:LibraryDemo/20/testSoapHeaders#SearchByTitle"&gt;			&lt;input&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/input&gt;		&lt;/operation&gt;		&lt;operation ref="tns:AuthenticatedSearchByTitle" wsoap:action="urn:LibraryDemo/20/testSoapHeaders#AuthenticatedSearchByTitle"&gt;			&lt;input&gt;				&lt;wsoap:header element="ns:AuthenticationToken" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/input&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;		&lt;operation ref="tns:AuthenticatedSearchByWord" wsoap:action="urn:LibraryDemo/20/testSoapHeaders#AuthenticatedSearchByWord"&gt;			&lt;input&gt;				&lt;wsoap:header element="ns:AuthenticationToken" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;wsoap:header element="ns:Confirmation" mustUnderstand="true" required="false"&gt;&lt;/wsoap:header&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"&gt;&lt;/wsoap:header&gt;			&lt;/output&gt;			&lt;outfault ref="tns:AuthenticationTokenException"&gt;&lt;/outfault&gt;		&lt;/operation&gt;	&lt;/binding&gt;	&lt;service interface="tns:WSAuthenticatedSearchService" name="TestLibraryServicesWithHeaders"&gt;		&lt;endpoint address="http://localhost:4444/testSoapHeadersServices" binding="tns:WSAuthenticatedSearchService" name="WSAuthenticatedSearchService"&gt;&lt;/endpoint&gt;	&lt;/service&gt;&lt;/description&gt;'</body><body package="WebServicesDemoModels">x2oBinding	"self initializeRegistries"^'&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/20/testSoapHeaders" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations"&gt;		&lt;bindingImport namespace="urn:LibraryDemo/20/testSoapHeaders"/&gt;		&lt;element name="SearchByTitle"&gt;			&lt;struct name="SearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;sequence_of name="CollectionOfBook" smalltalkClass="OrderedCollection"&gt;			&lt;element name="Book" maxOccurs="unbounded" minOccurs="0" ref="ns:Protocols.Library.Book"/&gt;		&lt;/sequence_of&gt;		&lt;element name="SearchByTitleResponse"&gt;			&lt;struct name="SearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitle"&gt;			&lt;struct name="AuthenticatedSearchByTitle"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByTitleResponse"&gt;			&lt;struct name="AuthenticatedSearchByTitleResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWord"&gt;			&lt;struct name="AuthenticatedSearchByWord"&gt;				&lt;element name="parameter" ref="xsd:string"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticatedSearchByWordResponse"&gt;			&lt;struct name="AuthenticatedSearchByWordResponse"&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/struct&gt;		&lt;/element&gt;		&lt;element name="AuthenticationTokenException" ref="ns:AuthenticationTokenException"/&gt;		&lt;element name="AuthenticationTokenExceptionHeader" ref="ns:AuthenticationTokenExceptionHeader"/&gt;		&lt;element name="AccessLevel" ref="xsd:string"/&gt;		&lt;element name="AuthenticationToken" ref="ns:AuthenticationToken"/&gt;		&lt;element name="Confirmation" ref="ns:Confirmation"/&gt;	&lt;/xmlToSmalltalkBinding&gt;	&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/20/testSoapHeaders" defaultClassNamespace="WebServices" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders"&gt;		&lt;object name="AuthenticationToken" smalltalkClass="AuthenticationToken"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenExceptionHeader" smalltalkClass="AuthenticationTokenExceptionHeader"&gt;			&lt;element name="description" type="xsd:string"&gt;&lt;/element&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenException" smalltalkClass="AuthenticationTokenException"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="Confirmation" smalltalkClass="Confirmation"&gt;			&lt;element name="return" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="WrongPasswordException" smalltalkClass="WrongPasswordException"/&gt;		&lt;object name="Protocols.Library.Book" smalltalkClass="Protocols.Library.Book" baseType="tns:Protocols.Library.LoanedHolding" constraint="extension"&gt;			&lt;element name="dueDate" minOccurs="0" ref="xsd:date"/&gt;			&lt;element name="acquisitionDate" ref="xsd:date"/&gt;			&lt;element name="language" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="authors" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.AuthorialName"/&gt;			&lt;element name="acquisitionNumber" ref="xsd:positiveInteger"/&gt;			&lt;element name="publisher" ref="xsd:string"/&gt;			&lt;element name="braille" ref="xsd:boolean"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="catalogNumber" ref="tns:Protocols.Library.CatalogNumber"/&gt;			&lt;element name="pages" ref="xsd:short"/&gt;			&lt;element name="libraryName" ref="xsd:string"/&gt;			&lt;element name="collectionId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="publicationYear" ref="xsd:short"/&gt;			&lt;element name="acquisitionCost" ref="xsd:decimal"/&gt;			&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;element name="largePrint" ref="xsd:boolean"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.LoanedHolding" smalltalkClass="Protocols.Library.LoanedHolding" baseType="tns:Protocols.Library.Holding" constraint="extension"/&gt;		&lt;object name="Protocols.Library.Holding" smalltalkClass="Protocols.Library.Holding" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"/&gt;		&lt;object name="Protocols.Library.AbstractRandom" smalltalkClass="Protocols.Library.AbstractRandom"/&gt;		&lt;object name="Protocols.Library.CatalogNumber" smalltalkClass="Protocols.Library.CatalogNumber" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="part4" ref="xsd:string" conversionId="Character"/&gt;			&lt;element name="part1" ref="xsd:string"/&gt;			&lt;element name="part2" ref="xsd:base64Binary"/&gt;			&lt;element name="part3" ref="xsd:double"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.AuthorialName" smalltalkClass="Protocols.Library.AuthorialName"&gt;			&lt;element name="name" ref="tns:Protocols.Library.PersonName"/&gt;			&lt;element name="authorialType" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;/object&gt;		&lt;object name="Protocols.Library.PersonName" smalltalkClass="Protocols.Library.PersonName" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;			&lt;element name="middleNames" ref="xsd:string"/&gt;			&lt;element name="title" ref="xsd:string"/&gt;			&lt;element name="firstName" ref="xsd:string"/&gt;			&lt;element name="lastName" ref="xsd:string"/&gt;		&lt;/object&gt;	&lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;'</body></methods><methods><class-id>Protocols.Library.Holding</class-id> <category>testing</category><body package="WebServicesDemoModels">isBook	^false</body><body package="WebServicesDemoModels">isShipPlan	^false</body></methods><methods><class-id>Protocols.Library.Book class</class-id> <category>instance creation</category><body package="WebServicesDemoModels">someBooks	"((( Book someBooks )))"	| coll nextAcquisitionNumber |	nextAcquisitionNumber := 536870912.	coll := OrderedCollection new.	libraryBookData do:		[ :each |		coll add: (( self 						authors: self someRandomAuthors					title: each value first asString )				collectionId: each key;				acquisitionNumber: (nextAcquisitionNumber := nextAcquisitionNumber + 1);				yourself)].	^coll</body></methods><methods><class-id>Protocols.Library.Book class</class-id> <category>utility</category><body package="WebServicesDemoModels">someRandomAuthors	| numericSpread n typeSpread coll |	numericSpread := #[ 1 1 1 1 1 1 1 1 2 2 2 3 3 4 ].	n := numericSpread at: ( self randomPositiveIntegerWithMax: numericSpread size ).	typeSpread := 		( ( self randomIntegerLessThan: 7 ) == 0 )			ifTrue:	[ #( #editor #editor #editor #translator ) ]			ifFalse:	[ #( #writer #writer #writer #writer #translator #translator #illustrator ) ].	coll := OrderedCollection new.	1 to: n do:		[ :ndx |	coll add: ( AuthorialName							authorialType: ( typeSpread at: ( 1 + ( self randomIntegerLessThan: typeSpread size ) ) )							name: ( PersonName randomLDDataPersonName ) )		].	^coll</body></methods><methods><class-id>Protocols.Library.Book</class-id> <category>accessing</category><body package="WebServicesDemoModels">authors	^authors asOrderedCollection</body></methods><methods><class-id>Protocols.Library.Book</class-id> <category>testing</category><body package="WebServicesDemoModels">isBook 	^true</body></methods><methods><class-id>Protocols.Library.ShipPlan</class-id> <category>testing</category><body package="WebServicesDemoModels">isShipPlan	^true</body></methods><methods><class-id>Protocols.Library.Library class</class-id> <category>instance creation</category><body package="WebServicesDemoModels">cityPublicLibrary	"((( self cityPublicLibrary )))"	| lib |	lib := ( self  new )			libraryName: (#CityPublicLibrary &lt;&lt; #librarydemo &gt;&gt; 'City Public Library') asString;			yourself.	"... fake up an account balance."	lib account balance: ( lib account balance + 11000 ).	"... add books to the library without touching the transaction record."	Book someBooks do: [ :bx |	lib addLDHolding: bx ].	"... add some patrons to the library without touching the transaction record."	20 timesRepeat: [ lib patrons add: Person randomLDPersonalPatron ].	"... add services."	lib 		addService: WeatherForecastService new;		addService:	SearchService new.	^lib</body></methods><methods><class-id>Protocols.Library.Library</class-id> <category>accessing</category><body package="WebServicesDemoModels">any	^ownedHoldings</body><body package="WebServicesDemoModels">any: anObject	ownedHoldings := anObject</body><body package="WebServicesDemoModels">anyAttribute	^libraryName</body><body package="WebServicesDemoModels">anyAttribute: anObject	libraryName := anObject</body></methods><methods><class-id>WebServices.WSSearchServices</class-id> <category>public api</category><body package="WebServicesDemoModels">searchByExactTitle: aString includeAffiliatedLibraries: aBoolean	&lt;operationName: #'SearchByTitle'&gt;	&lt;documentation: #'The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found'&gt;	&lt;addParameter: #'searchByExactTitle' type: #'String'&gt;	&lt;addParameter: #'includeAffiliatedLibraries' type: #'Boolean'&gt;	&lt;result: #( #Collection #'Protocols.Library.Book' )&gt;	^OrderedCollection with: (super searchByExactTitle: aString includeAffiliatedLibraries: aBoolean) first value</body><body package="WebServicesDemoModels">searchByExactTitles: aStrings includeAffiliatedLibraries: aBoolean	&lt;operationName: #'SearchByTitles'&gt;	&lt;documentation: #'The SearchByTitles operation returns a collection of holdings or empty collection if no holdings found'&gt;	&lt;addParameter: #'searchByExactTitles' type: #( #Collection #'String')&gt;	&lt;addParameter: #'includeAffiliatedLibraries' type: #'Boolean'&gt;	&lt;result: #( #Collection #'Protocols.Library.Book' )&gt;	| coll | 	coll := OrderedCollection new.	aStrings do: [ :str | coll add: (self searchByExactTitle: str includeAffiliatedLibraries: aBoolean) first ].	^coll</body><body package="WebServicesDemoModels">searchByTitleWord: aString includeAffiliatedLibraries: aBoolean	&lt;operationName: #'SearchByWord'&gt;	&lt;documentation: #'The SearchByWord operation returns a collection of holdings or empty collection if no holdings found'&gt;	&lt;addParameter: #'searchByTitleWord' type: #'String'&gt;	&lt;addParameter: #'includeAffiliatedLibraries' type: #'Boolean'&gt;	&lt;result: #'ChoiceOfHoldings'&gt;	|  choiceOfHoldings coll |	choiceOfHoldings := ChoiceOfHoldings new. 	choiceOfHoldings choiceValue: Struct new.	coll := (super searchByTitleWord: aString includeAffiliatedLibraries: aBoolean) 		collect: [ :each | each  value ].	coll last isBook ifTrue: [ choiceOfHoldings choiceValue: (#book -&gt; coll last)].	coll last isShipPlan	ifTrue: [  choiceOfHoldings choiceValue:  (#shipPlan -&gt; coll last) ].	choiceOfHoldings choiceValue ifNil: [ choiceOfHoldings choiceValue: ( #book -&gt; coll first )].	^choiceOfHoldings</body></methods><methods><class-id>WebServices.WSSearchServices class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">operationPragmas"Generated by WS Tool on #(February 18, 2003 5:09:00 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #documentation:;		add: #addException:type:;		add: #addParameter:type:;		add: #operationName:;		add: #result:;		yourself</body></methods><methods><class-id>WebServices.Address</class-id> <category>accessing</category><body package="WebServicesDemoModels">state: anObject"Generated by WS Tool on #(December 2, 2003 7:40:53 am)"	&lt;addAttribute: #state type: #String&gt;	state := anObject</body><body package="WebServicesDemoModels">street: anObject"Generated by WS Tool on #(December 2, 2003 7:40:53 am)"	&lt;addAttribute: #street type: #String&gt;	street := anObject</body><body package="WebServicesDemoModels">zip: anObject"Generated by WS Tool on #(December 2, 2003 7:40:53 am)"	&lt;addAttribute: #zip type: #Integer&gt;	zip := anObject</body></methods><methods><class-id>WebServices.Address class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(December 2, 2003 7:40:53 am)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.Confirmation</class-id> <category>accessing</category><body package="WebServicesDemoModels">return: aString	&lt;addAttribute: #return type: #String &gt;	return := aString</body></methods><methods><class-id>WebServices.Confirmation class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(April 8, 2005 12:01:36 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.WSLibrary</class-id> <category>accessing</category><body package="WebServicesDemoModels">ownedHoldingsColl: aCollBook	&lt;addAttribute: #ownedHoldingsColl type: #( #Collection #'Protocols.Library.Book' )&gt;	ownedHoldingsColl := aCollBook</body><body package="WebServicesDemoModels">personalPatrons: aCollOfPerson	&lt;addAttribute: #personalPatrons type: #( #Collection #'Protocols.Library.Person' #'1' #'5')&gt;	personalPatrons := aCollOfPerson</body><body package="WebServicesDemoModels">webSiteAddress: aStruct"Generated by WS Tool on #(February 18, 2003 5:09:24 pm)"	&lt;addAttribute: #webSiteAddress type: #( #Choice #( #text #String) #(#url #'OS.URI') )&gt;	webSiteAddress := aStruct</body></methods><methods><class-id>WebServices.WSLibrary class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:24 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.WSBook</class-id> <category>accessing</category><body package="WebServicesDemoModels">acquisitionNumber: aLargePositiveInteger	&lt;addAttribute: #acquisitionNumber type: #'LargePositiveInteger'&gt;	acquisitionNumber := aLargePositiveInteger</body><body package="WebServicesDemoModels">statusId: aByteSymbol	&lt;addAttribute: #statusId type: #'ByteSymbol'&gt;	statusId := aByteSymbol</body><body package="WebServicesDemoModels">text: aString	&lt;addAttribute: #title type: #'String'&gt;	self title: aString</body></methods><methods><class-id>WebServices.WSBook class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:15 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.AuthenticationToken</class-id> <category>accessing</category><body package="WebServicesDemoModels">password: aString	&lt;addAttribute: #password  type: #String&gt;	password := aString</body><body package="WebServicesDemoModels">userID: aString	&lt;addAttribute: #userID  type: #String&gt;	userID := aString</body></methods><methods><class-id>WebServices.AuthenticationToken class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:24 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.WSAuthenticatedSearchService</class-id> <category>public api</category><body package="WebServicesDemoModels">authenticatedSearchByTitle: aString 	&lt;operationName: #'AuthenticatedSearchByTitle'&gt;	&lt;documentation: #'The AuthenticatedSearchByTitle operation returns a collection of holdings or empty collection if no holdings found'&gt;	&lt;addParameter: #'title' type: #'String'&gt;	&lt;result: #( #Collection #'Protocols.Library.Book' )&gt;	| header |	header :=(ProcessEnvironment current 			at: #SoapHeader 			ifAbsent: [ self error: 'There is no such header in the ProcessEnvironment current']) headerAt: 'AuthenticationToken' ifAbsent: [nil].	header := header value.	(header userID = 'UserID' and: [header password = 'password' ]) 		ifFalse: [ ^(AuthenticationTokenException new					userID:   header userID;					password:  header password;					yourself)  raise ]. 	^(super searchByExactTitle: aString includeAffiliatedLibraries: false) values</body><body package="WebServicesDemoModels">authenticatedSearchByWord: aString 	&lt;operationName: #'AuthenticatedSearchByWord'&gt;	&lt;documentation: #'To be able to make this request the message should include authentication token and access level. The AuthenticatedSearchByWord operation returns a collection of books or empty collection if no books found'&gt;	&lt;addParameter: #'titleWord' type: #'String'&gt;	&lt;result: #( #Collection #'Protocols.Library.Book' )&gt;	^(self searchByTitleWord: aString includeAffiliatedLibraries: false) values.</body><body package="WebServicesDemoModels">searchByTitle: aString 	&lt;operationName: #'SearchByTitle'&gt;	&lt;documentation: #'The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found'&gt;	&lt;addParameter: #'title' type: #'String'&gt;	&lt;result: #( #Collection #'Protocols.Library.Book' )&gt;		^(super searchByExactTitle: aString includeAffiliatedLibraries: false)  values.</body></methods><methods><class-id>WebServices.WSAuthenticatedSearchService class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">operationPragmas"Generated by WS Tool on #(February 18, 2003 5:09:00 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #documentation:;		add: #addException:type:;		add: #addParameter:type:;		add: #operationName:;		add: #result:;		add: #inputHeader:;		add: #outputHeader:;		yourself</body></methods><methods><class-id>WebServices.Customer</class-id> <category>accessing</category><body package="WebServicesDemoModels">address: anObject"Generated by WS Tool on #(December 2, 2003 7:40:33 am)"	&lt;addAttribute: #address type: #'WebServices.Address'&gt;	address := anObject</body><body package="WebServicesDemoModels">id: anObject"Generated by WS Tool on #(December 2, 2003 7:40:33 am)"	&lt;addAttribute: #id type: #Integer&gt;	id := anObject</body><body package="WebServicesDemoModels">name: anObject"Generated by WS Tool on #(December 2, 2003 7:40:33 am)"	&lt;addAttribute: #name type: #String&gt;	name := anObject</body></methods><methods><class-id>WebServices.Customer class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(December 2, 2003 7:40:33 am)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.WSGeneralServices</class-id> <category>public api</category><body package="WebServicesDemoModels">availableBooks"Generated by WS Tool on #(December 17, 2003 5:17:23 pm)"	&lt;documentation: #'The AvailableBooks returns available books'&gt;	&lt;operationName: #AvailableBooks&gt;	&lt;result: #( #Collection #'WebServices.WSBook')&gt;	| coll |	coll := OrderedCollection new. 	library ownedHoldingsColl 		do: [ :holding | 			coll add: 				( WSBook new					title: holding title;					acquisitionNumber: holding acquisitionNumber;					statusId: holding statusId;					yourself)].	^coll</body><body package="WebServicesDemoModels">holdingByAcquisitionNumber: aNumber"Generated by WS Tool on #(January 24, 2003 10:33:21 am)"	&lt;operationName: #'HoldingByAcquisitionNumber'&gt;	&lt;documentation: #'The HoldingByAcquisitionNumber operation returns a holding or exception if the holding not found'&gt;	&lt;addParameter: #'holdingByAcquisitionNumber' type: #'LargePositiveInteger'&gt;	&lt;result: #'Protocols.Library.Book'&gt;	&lt;addException: #'holdingNotFound' type: #'Protocols.Library.HoldingNotFound'&gt;	^library ownedHoldingsColl		detect:	[ :x | x acquisitionNumber =  aNumber ]		ifNone:	[ HoldingNotFound 					raiseErrorString:	((#NoHoldingFoundWithAcquisitionNumber &lt;&lt; #webservices &gt;&gt; 'No holding found with acquisition number &lt;1s&gt;.')						expandMacrosWith: aNumber printString)				]</body><body package="WebServicesDemoModels">libraryServicesCollection"Generated by WS Tool on #(February 19, 2003 9:36:44 am)"	&lt;operationName: #LibraryServicesCollection&gt;	&lt;documentation: #'The LibraryServicesCollection operation returns a collection of services'&gt;	&lt;result: #( #Collection #'Protocols.Library.LibraryService' )&gt;	^self  libraryServicesDictionary values asOrderedCollection</body><body package="WebServicesDemoModels">libraryServicesIds"Generated by WS Tool on #(January 24, 2003 10:33:21 am)"	&lt;operationName: #'LibraryServicesIds'&gt;	&lt;documentation: #'The LibraryServicesIds operation returns library services ids'&gt;	&lt;result: #( #Collection #'ByteSymbol' )&gt;	^super libraryServicesIds asOrderedCollection</body></methods><methods><class-id>WebServices.WSGeneralServices</class-id> <category>accessing</category><body package="WebServicesDemoModels">serviceCharge: aFixedPoint"Generated by WS Tool on #(February 18, 2003 5:09:26 pm)"	&lt;addAttribute: #serviceCharge type: #'FixedPoint'&gt;	serviceCharge := aFixedPoint</body><body package="WebServicesDemoModels">serviceId: aSymbol"Generated by WS Tool on #(February 18, 2003 5:09:26 pm)"	&lt;addAttribute: #serviceId type: #'ByteSymbol'&gt;	serviceId := aSymbol</body></methods><methods><class-id>WebServices.WSGeneralServices class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">operationPragmas"Generated by WS Tool on #(February 18, 2003 5:08:56 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #documentation:;		add: #addException:type:;		add: #addParameter:type:;		add: #operationName:;		add: #result:;		yourself</body><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:20 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.AuthenticationTokenException</class-id> <category>accessing</category><body package="WebServicesDemoModels">password: aString	&lt;addAttribute: #password type: #String &gt;	password := aString</body><body package="WebServicesDemoModels">userID: aString	&lt;addAttribute: #userID type: #String &gt;	userID := aString</body></methods><methods><class-id>WebServices.AuthenticationTokenException class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:24 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>WebServices.SpecialCustomer</class-id> <category>accessing</category><body package="WebServicesDemoModels">something1	&lt;addAttribute: #something1 type: #String&gt;	^something1</body><body package="WebServicesDemoModels">something2	&lt;addAttribute: #something2 type: #Integer&gt;	^something2</body></methods><methods><class-id>WebServices.WSPhysicalAddress</class-id> <category>accessing</category><body package="WebServicesDemoModels">city: aByteString"Generated by WS Tool on #(February 18, 2003 5:09:20 pm)"	&lt;addAttribute: #city type: #'ByteString'&gt;	city := aByteString</body><body package="WebServicesDemoModels">country: aByteSymbol"Generated by WS Tool on #(February 18, 2003 5:09:20 pm)"	&lt;addAttribute: #country type: #'ByteSymbol'&gt;	country := aByteSymbol</body><body package="WebServicesDemoModels">postalCode: aByteString"Generated by WS Tool on #(February 18, 2003 5:09:20 pm)"	&lt;addAttribute: #postalCode type: #'ByteString'&gt;	postalCode := aByteString</body><body package="WebServicesDemoModels">stateOrProvince: aByteSymbol"Generated by WS Tool on #(February 18, 2003 5:09:20 pm)"	&lt;addAttribute: #stateOrProvince type: #'ByteSymbol'&gt;	stateOrProvince := aByteSymbol</body><body package="WebServicesDemoModels">streetAddress1: aString"Generated by WS Tool on #(February 18, 2003 5:09:19 pm)"	&lt;addAttribute: #streetAddress1 type: #'String'&gt;	streetAddress1 := aString</body><body package="WebServicesDemoModels">streetAddress2: aString"Generated by WS Tool on #(February 18, 2003 5:09:19 pm)"	&lt;addAttribute: #streetAddress2 type: #'String'&gt;	streetAddress2 := aString</body></methods><methods><class-id>WebServices.WSPhysicalAddress class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:19 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.AuthorialName class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:17 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.AuthorialName</class-id> <category>accessing</category><body package="WebServicesDemoModels">authorialType: aByteSymbol	&lt;addAttribute: #authorialType type: #'ByteSymbol'&gt;	authorialType := aByteSymbol</body><body package="WebServicesDemoModels">name: aPersonName 	&lt;addAttribute: #name type: #'Protocols.Library.PersonName'&gt;	name := aPersonName</body></methods><methods><class-id>Protocols.Library.Book class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:15 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.Book</class-id> <category>accessing</category><body package="WebServicesDemoModels">acquisitionCost: aFixedPoint	&lt;addAttribute: #acquisitionCost type: #'FixedPoint'&gt;	acquisitionCost := aFixedPoint</body><body package="WebServicesDemoModels">acquisitionDate: aDate	&lt;addAttribute: #acquisitionDate type: #'Date'&gt;	acquisitionDate := aDate</body><body package="WebServicesDemoModels">acquisitionNumber: aLargePositiveInteger	&lt;addAttribute: #acquisitionNumber type: #'LargePositiveInteger'&gt;	acquisitionNumber := aLargePositiveInteger</body><body package="WebServicesDemoModels">authors: aCollOfAuthorialName	&lt;addAttribute: #authors type: #( #Collection #'Protocols.Library.AuthorialName' )&gt;	authors := aCollOfAuthorialName</body><body package="WebServicesDemoModels">braille: aBoolean	&lt;addAttribute: #braille type: #'Boolean'&gt;	braille := aBoolean</body><body package="WebServicesDemoModels">catalogNumber: aCatalogNumber	&lt;addAttribute: #catalogNumber type: #'Protocols.Library.CatalogNumber'&gt;	catalogNumber := aCatalogNumber</body><body package="WebServicesDemoModels">collectionId: aCollectionId	&lt;addAttribute: #collectionId type: #'ByteSymbol'&gt;	collectionId := aCollectionId</body><body package="WebServicesDemoModels">dueDate: aDate	&lt;addAttribute: #( #dueDate #optional ) type: #'Date'&gt;	dueDate := aDate</body><body package="WebServicesDemoModels">language: aSymbol	&lt;addAttribute: #language type: #'ByteSymbol'&gt;	language := aSymbol</body><body package="WebServicesDemoModels">largePrint: aBoolean	&lt;addAttribute: #largePrint type: #'Boolean'&gt;	largePrint := aBoolean</body><body package="WebServicesDemoModels">libraryName: aString	&lt;addAttribute: #libraryName type: #'String'&gt;	libraryName := aString</body><body package="WebServicesDemoModels">pages: anInteger	&lt;addAttribute: #pages type: #'SmallInteger'&gt;	pages := anInteger</body><body package="WebServicesDemoModels">publicationYear: anInteger	&lt;addAttribute: #publicationYear type: #'SmallInteger'&gt;	publicationYear := anInteger</body><body package="WebServicesDemoModels">publisher: aString	&lt;addAttribute: #publisher type: #'String'&gt;	publisher := aString</body><body package="WebServicesDemoModels">statusId: aStatusId	&lt;addAttribute: #statusId type: #'ByteSymbol'&gt;	statusId := aStatusId</body><body package="WebServicesDemoModels">title: aString	&lt;addAttribute: #title type: #'String'&gt;	title := aString</body></methods><methods><class-id>Protocols.Library.Patron</class-id> <category>accessing</category><body package="WebServicesDemoModels">patronId: aByteSymbol	&lt;addAttribute: #patronId  type: #ByteSymbol&gt;	patronId := aByteSymbol</body><body package="WebServicesDemoModels">patronName: aPersonName	&lt;addAttribute: #patronName  type: #'Protocols.Library.PersonName'&gt;	patronName := aPersonName</body></methods><methods><class-id>Protocols.Library.Account class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:24 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.Account</class-id> <category>accessing</category><body package="WebServicesDemoModels">balance: aFixedPoint"Generated by WS Tool on #(February 18, 2003 5:09:26 pm)"	&lt;addAttribute: #balance type: #'FixedPoint'&gt;	balance := aFixedPoint</body></methods><methods><class-id>Protocols.Library.PersonName class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:18 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.PersonName</class-id> <category>accessing</category><body package="WebServicesDemoModels">firstName: aString	&lt;addAttribute: #firstName type: #'String'&gt;	firstName := aString</body><body package="WebServicesDemoModels">lastName: aString	&lt;addAttribute: #lastName type: #'String'&gt;	lastName := aString</body><body package="WebServicesDemoModels">middleNames: aString	&lt;addAttribute: #middleNames type: #'String'&gt;	middleNames := aString</body><body package="WebServicesDemoModels">title: aString	&lt;addAttribute: #title type: #'String'&gt;	title := aString</body></methods><methods><class-id>Protocols.Library.CatalogNumber class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:17 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.CatalogNumber</class-id> <category>accessing</category><body package="WebServicesDemoModels">part1: aString	&lt;addAttribute: #part1 type: #'String'&gt;	part1 := aString</body><body package="WebServicesDemoModels">part2: aByteArray	&lt;addAttribute: #part2 type: #'ByteArray'&gt;	part2 := aByteArray</body><body package="WebServicesDemoModels">part3: aDouble	&lt;addAttribute: #part3 type: #'Double'&gt;	part3 := aDouble</body><body package="WebServicesDemoModels">part4: aCharacter	&lt;addAttribute: #part4 type: #'Character'&gt;	part4 := aCharacter</body></methods><methods><class-id>Protocols.Library.TelephoneNumber class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:20 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.TelephoneNumber</class-id> <category>accessing</category><body package="WebServicesDemoModels">description: aString	&lt;addAttribute: #description type: #'String'&gt;	description := aString</body><body package="WebServicesDemoModels">number: aString	&lt;addAttribute: #number type: #'String'&gt;	number := aString</body><body package="WebServicesDemoModels">type: aByteSymbol	&lt;addAttribute: #type type: #'ByteSymbol'&gt;	type := aByteSymbol</body></methods><methods><class-id>Protocols.Library.LibraryService class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:26 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.LibraryService</class-id> <category>accessing</category><body package="WebServicesDemoModels">library: aWSLibrary	&lt;addAttribute: #library type: #'WebServices.WSLibrary'&gt;	library := aWSLibrary</body><body package="WebServicesDemoModels">serviceCharge: aFixedPoint	&lt;addAttribute: #serviceCharge type: #FixedPoint&gt;	serviceCharge := aFixedPoint</body><body package="WebServicesDemoModels">serviceId: aSymbol	&lt;addAttribute: #serviceId type: #ByteSymbol&gt;	serviceId := aSymbol</body></methods><methods><class-id>Protocols.Library.Agent class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:24 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.Agent</class-id> <category>accessing</category><body package="WebServicesDemoModels">account: anAccount	&lt;addAttribute: #account  type: #'Protocols.Library.Account'&gt;	account := anAccount</body><body package="WebServicesDemoModels">borrowedHoldings: aCollOfBook	&lt;addAttribute: #(#borrowedHoldings #optional)  type: #( #Collection #'Protocols.Library.Book' )&gt;	borrowedHoldings := aCollOfBook asOrderedCollection</body><body package="WebServicesDemoModels">emailAddresses: anEmailAddress	&lt;addAttribute: #emailAddresses  type: #( #Collection #'Protocols.Library.EmailAddress') &gt;	emailAddresses := anEmailAddress</body><body package="WebServicesDemoModels">physicalAddress: aWSPhysicalAddress	&lt;addAttribute: #physicalAddress  type: #'WebServices.WSPhysicalAddress'&gt;	physicalAddress := aWSPhysicalAddress</body><body package="WebServicesDemoModels">serviceApprovals: aByteSymbol"Generated by WS Tool on #(January 3, 2003 11:41:34 am)"	&lt;addAttribute: #serviceApprovals  type: #( #Collection #ByteSymbol)&gt;	serviceApprovals := aByteSymbol</body><body package="WebServicesDemoModels">telephoneNumbers: aCollOfTelephoneNumber	&lt;addAttribute: #telephoneNumbers  type: #( #Collection #'Protocols.Library.TelephoneNumber')&gt;	telephoneNumbers := aCollOfTelephoneNumber asOrderedCollection</body></methods><methods><class-id>Protocols.Library.EmailAddress class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:19 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.EmailAddress</class-id> <category>accessing</category><body package="WebServicesDemoModels">address: aString	&lt;addAttribute: #address type: #'String'&gt;	address := aString</body><body package="WebServicesDemoModels">description: aString	&lt;addAttribute: #description type: #'String'&gt;	description := aString</body></methods><methods><class-id>Protocols.Library.ShipPlan class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:15 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.ShipPlan</class-id> <category>accessing</category><body package="WebServicesDemoModels">architects: anArray	&lt;addAttribute: #architects type: #( #Collection #'Protocols.Library.AuthorialName' )&gt; 	^architects := anArray</body><body package="WebServicesDemoModels">numberOfSheets: aSmallInteger	&lt;addAttribute: #numberOfSheets type: #'SmallInteger'&gt;	numberOfSheets := aSmallInteger</body><body package="WebServicesDemoModels">scale: aFraction	&lt;addAttribute: #scale type: #Float&gt;	scale := aFraction</body><body package="WebServicesDemoModels">shipName: aString	&lt;addAttribute: #shipName type: #String&gt;	shipName := aString</body><body package="WebServicesDemoModels">yearDrawn: aSmallInteger	&lt;addAttribute: #yearDrawn type: #'SmallInteger'&gt;	yearDrawn := aSmallInteger</body></methods><methods><class-id>Protocols.Library.Library</class-id> <category>accessing</category><body package="WebServicesDemoModels">affiliatedLibraries: aCollOfWSLibrary	&lt;addAttribute: #(#affiliatedLibraries #optional) type: #( #Collection #'WebServices.WSLibrary')&gt;	affiliatedLibraries := aCollOfWSLibrary asOrderedCollection</body><body package="WebServicesDemoModels">libraryId: aByteSymbol	&lt;addAttribute: #libraryId  type: #ByteSymbol&gt;	libraryId := aByteSymbol</body><body package="WebServicesDemoModels">libraryName: aString	&lt;addAttribute: #libraryName  type: #String&gt;	libraryName := aString</body><body package="WebServicesDemoModels">loanedHoldings: aBook	&lt;addAttribute: #(#loanedHoldings #optional) type: #( #Collection #'Protocols.Library.Book')&gt;	loanedHoldings := aBook asOrderedCollection</body><body package="WebServicesDemoModels">ownedHoldings: aCollBook	&lt;addAttribute: #ownedHoldings  type: #(#Collection #'Protocols.Library.Book')&gt;	ownedHoldings := aCollBook asOrderedCollection</body><body package="WebServicesDemoModels">reservedHoldings: aBook	&lt;addAttribute: #(#reservedHoldings #optional)  type: #(#Collection #'Protocols.Library.Book')&gt;	reservedHoldings := aBook asOrderedCollection</body></methods><methods><class-id>Protocols.Library.Person</class-id> <category>accessing</category><body package="WebServicesDemoModels">birthDate: aDate	&lt;addAttribute: #birthDate  type: #Date&gt;	birthDate := aDate</body><body package="WebServicesDemoModels">sex: aCharacter	&lt;addAttribute: #sex  type: #Character&gt;	sex := aCharacter</body><body package="WebServicesDemoModels">ssn: aLargePositiveInteger	&lt;addAttribute: #ssn  type: #LargePositiveInteger&gt;	ssn := aLargePositiveInteger</body></methods><methods><class-id>Protocols.Library.PhysicalAddress class</class-id> <category>ws pragmas</category><body package="WebServicesDemoModels">typePragmas"Generated by WS Tool on #(February 18, 2003 5:09:19 pm)"	&lt;pragmas: #instance&gt;	^OrderedCollection new		add: #addAttribute:type:;		yourself</body></methods><methods><class-id>Protocols.Library.PhysicalAddress</class-id> <category>accessing</category><body package="WebServicesDemoModels">city: aByteString	&lt;addAttribute: #city type: #'ByteString'&gt;	city := aByteString</body><body package="WebServicesDemoModels">country: aByteSymbol	&lt;addAttribute: #country type: #'ByteSymbol'&gt;	country := aByteSymbol</body><body package="WebServicesDemoModels">postalCode: aByteString	&lt;addAttribute: #postalCode type: #'ByteString'&gt;	postalCode := aByteString</body><body package="WebServicesDemoModels">stateOrProvince: aByteSymbol	&lt;addAttribute: #stateOrProvince type: #'ByteSymbol'&gt;	stateOrProvince := aByteSymbol</body><body package="WebServicesDemoModels">streetAddress1: aString	&lt;addAttribute: #streetAddress1 type: #'String'&gt;	streetAddress1 := aString</body><body package="WebServicesDemoModels">streetAddress2: aString	&lt;addAttribute: #streetAddress2 type: #'String'&gt;	streetAddress2 := aString</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatalogNumber</name><environment>Protocols.Library</environment><super>Protocols.Library.AbstractRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars>part1 part2 part3 part4 </inst-vars><class-inst-vars>nextPart3 </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>Agent</name><environment>Protocols.Library</environment><super>Protocols.Library.AbstractRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars>account borrowedHoldings emailAddresses physicalAddress serviceApprovals telephoneNumbers </inst-vars><class-inst-vars>serviceApprovals </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>Patron</name><environment>Protocols.Library</environment><super>Protocols.Library.Agent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>patronId patronName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>PersonName</name><environment>Protocols.Library</environment><super>Protocols.Library.AbstractRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title firstName middleNames lastName </inst-vars><class-inst-vars>femaleTitles maleTitles femaleFirstNames maleFirstNames femaleMiddleNames maleMiddleNames lastNames </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>LibraryService</name><environment>Protocols.Library</environment><super>Protocols.Library.AbstractRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars>library serviceCharge serviceId </inst-vars><class-inst-vars>defaultServiceCharge defaultServiceId </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>GeneralPublicService</name><environment>Protocols.Library</environment><super>Protocols.Library.LibraryService</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>EmailAddress</name><environment>Protocols.Library</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>address description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>SOAPProcessingPolicy</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcherClass interceptorClasses processOptionalHeaders </inst-vars><class-inst-vars>defaultDispatcherClass defaultInterceptorClasses defaultProcessOptionalHeaders </class-inst-vars><imports></imports><category></category><attributes><package>SOAP-Server</package></attributes></class><class><name>Holding</name><environment>Protocols.Library</environment><super>Protocols.Library.AbstractRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars>acquisitionCost acquisitionDate acquisitionNumber catalogNumber collectionId dueDate libraryName statusId </inst-vars><class-inst-vars>nextHoldingId collectionIds statusIds </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>SOAPResponder</name><environment>WebServices</environment><super>SiouX.NetHttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processingPolicy environmentWithHeaders binding service </inst-vars><class-inst-vars>defaultProcessingPolicyClass defaultEnvironmentWithHeaders responders </class-inst-vars><imports>			private Net.*			private SiouX.*			</imports><category></category><attributes><package>SOAP-Server</package></attributes></class><class><name>SOAPMessageInterceptor</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SOAP-Server</package></attributes></class><class><name>AuthorialName</name><environment>Protocols.Library</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authorialType name </inst-vars><class-inst-vars>authorialTypes </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>SearchService</name><environment>Protocols.Library</environment><super>Protocols.Library.LibraryService</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>Book</name><environment>Protocols.Library</environment><super>Protocols.Library.LoanedHolding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authors braille coverPhoto language largePrint pages publicationYear publisher title </inst-vars><class-inst-vars>publishers libraryBookData archiveBookData </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>WsdlClient</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>port config wsdlUrl accessPoint header request response responseValue transport processingPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><class><name>Person</name><environment>Protocols.Library</environment><super>Protocols.Library.Patron</super><private>false</private><indexed-type>none</indexed-type><inst-vars>birthDate sex ssn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>TelephoneNumber</name><environment>Protocols.Library</environment><super>Protocols.Library.AbstractRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type description number </inst-vars><class-inst-vars>telephoneNumberTypes </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>Account</name><environment>Protocols.Library</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>balance transactionHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ShipPlan</name><environment>Protocols.Library</environment><super>Protocols.Library.RetainedHolding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>architects numberOfSheets scale sheetDimensions shipName yearDrawn </inst-vars><class-inst-vars>shipNames </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>Library</name><environment>Protocols.Library</environment><super>Protocols.Library.Agent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>affiliatedLibraries libraryId libraryName loanedHoldings ownedHoldings patrons reservedHoldings services </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class><class><name>PhysicalAddress</name><environment>Protocols.Library</environment><super>Protocols.Library.AbstractRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streetAddress1 streetAddress2 city stateOrProvince postalCode country </inst-vars><class-inst-vars>address1StreetNames address2Descriptions </class-inst-vars><imports></imports><category>LibraryDemo</category><attributes><package>Protocols-LibraryDemo</package></attributes></class></st-source>