<?xml version="1.0"?><st-source><!-- Name: WSDLToolNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Provides support for generating Smalltalk classes from a WSDL specification, and for generating a WSDL specification from service classes.OverviewThere are two main classes in this package:	1. WsdlBuilder -  uses WsdlConfigurationDescriptor to create the Wsdl document specification. For backward compatibility the class still can build Wsdl document from pragma descriptions. 	2. WsdlClassBuilder -  creates Smalltalk binding classes, service, server and client classes from a WSDL schema.UsageSee class comments for more information.Samples are provided in the WebServicesDemo package.DbIdentifier: bear73DbTrace: 500690DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'XMLObjectBindingTool' '') #(#any 'WSDL' '') #(#any 'SOAP-Server' ''))PackageName: WSDLToolParcel: #('WSDLTool')ParcelName: WSDLToolPrerequisiteDescriptions: #(#(#name 'XMLObjectBindingTool') #(#name 'WSDL' #componentType #bundle) #(#name 'SOAP-Server' #componentType #package))PrerequisiteParcels: #(#('XMLObjectBindingTool' '') #('WSDL' '') #('SOAP-Server' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:31:39 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:39 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WsdlInterceptorBuilder</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binding type operations serverInterceptorClass clientInterceptorClass classBuilder text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.WsdlInterceptorBuilder</class-id><body>WsdlInterceptorBuilder builds SOAP header interceptors.Instance Variables	binding	&lt;MessageBinding&gt;	 binding	classBuilder	&lt;BindingClassBuilder&gt;		clientInterceptorClass	&lt;ClientMessageInterceptor&gt;		operations	&lt;Set&gt;	operations the interceptor provides callbacks for	serverInterceptorClass	&lt;SOAPMessageInterceptor&gt;	type	&lt;Symbol&gt;	#in/#out</body></comment><class><name>Wsdl11InterceptorBuilder</name><environment>WebServices</environment><super>WebServices.WsdlInterceptorBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.Wsdl11InterceptorBuilder</class-id><body>Wsdl11InterceptorBuilder builds specific callbacks for WSDL 1.1 &lt;header&gt; elements</body></comment><class><name>Wsdl20FaultInterceptorBuilder</name><environment>WebServices</environment><super>WebServices.WsdlInterceptorBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.Wsdl20FaultInterceptorBuilder</class-id><body>Wsdl20FaultInterceptorBuilder builds specific callbacks for WSDL 2.0 &lt;fault&gt;  header elements</body></comment><class><name>WsdlClassBuilder</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>config dataSource descriptor serviceMaps bindingClassBuilder buildOptions soapHeaders typesParser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.WsdlClassBuilder</class-id><body>WsdlClassBuilder creates from Wsdl schema client, service and Opentalk server classes.  If the Wsdl schema has user defined types (&lt;types&gt; element) this element will be used to create XML to Smalltalk binding and classes from the complex elements. Binding classes are going to be created with accessors.  Service classes are created with return types. You will need to review the service classes and add implementation for the WS operations.Class Variables	defaultProxyClientPortNumber &lt;Number&gt; default port numberInstance Variables	serviceClasses	&lt;Collection of: Classes&gt; service provider classes created from  the Wsdl spec &lt;binding&gt; element.	config	&lt;WsdlConfiguration&gt; Wsdl config	dataSource	&lt;Association&gt; data source the wsdl schema is from	descriptor	&lt;WsdlConfigurationDescriptor&gt; descriptor	serviceMaps	&lt;ServiceMap&gt; maps operation names and method selectors	bindingClassBuilder	&lt;BindingClassBuilder&gt; builds binding classes	buildOptions	&lt;WsdlClassBuildOptions&gt; options to build classes	soapHeaders	&lt;Collection of: SoapEntryHeader&gt; 	typesParser	&lt;XMLTypesParser&gt; parser</body></comment><class><name>Wsdl11FaultInterceptorBuilder</name><environment>WebServices</environment><super>WebServices.WsdlInterceptorBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.Wsdl11FaultInterceptorBuilder</class-id><body>Wsdl11FaultInterceptorBuilder builds specific callbacks for WSDL 1.1 &lt;headerfault&gt; elements</body></comment><class><name>WsdlBuildOptions</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x2oBuilder serviceProtocol serviceName defaultClassNamespace useServerSuperclass schemaTargetNamespace addSuperClassType bindingBuilderClass elementFormDefault attributeFormDefault </inst-vars><class-inst-vars>defaultServiceProtocol useServerSuperclass elementFormDefault attributeFormDefault </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.WsdlBuildOptions</class-id><body>WsdlBuildOptions  is superclass for Wsdl schema build optionsInstance Variables	x2oBuilder	&lt;BindingBuilder&gt; builds object marshalers	serviceProtocol	&lt;String&gt; the method protocol in a service class. Default "public api"	serviceName	&lt;String&gt; name attribute for &lt;service&gt; node	defaultClassNamespace	&lt;String&gt; default class namespace to resolve type references	useServerSuperclass	&lt;Boolean&gt; if the option is set to true the builder will collect all operations from the service class superclass	schemaTargetNamespace	&lt;String&gt; XML Schema #targetNamespace attribute	addSuperClassType	&lt;Boolean&gt; defines if the type description should be added from the superclass	bindingBuilderClass	&lt;&lt;Class&gt; by default: BindingBuilder	elementFormDefault	&lt;Symbol&gt;  value for elementFormDefault attribute	attributeFormDefault	&lt;Symbol&gt;  value for attributeFormDefault attributeClass Instance Variables	defaultServiceProtocol	&lt;String&gt; default protocol "public api"	useServerSuperclass	&lt;Boolean&gt; default value	elementFormDefault	&lt;Symbol&gt; default value for elementFormDefault attribute	attributeFormDefault	&lt;Symbol&gt; default value for attributeFormDefault attribute</body></comment><class><name>Wsdl11BuildOptions</name><environment>WebServices</environment><super>WebServices.WsdlBuildOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soapStyle soapUse inputPartName outputPartName </inst-vars><class-inst-vars>soapStyle soapUse inputPartName outputPartName </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.Wsdl11BuildOptions</class-id><body>Represents WSDL 1.1 build optionsInstance Variables	soapStyle	&lt;String&gt; document or rpc	soapUse	&lt;String&gt; literal or encoded	inputPartName	&lt;String&gt; This option works for #document style WSDL only and allows customizing the part name attribute in an input message	outputPartName	&lt;String&gt; This option works for #document style WSDL only and allows customizing the part name attribute in an output messageClass Instance Variables	soapStyle	&lt;String&gt; default style	soapUse	&lt;String &gt; deafult use	inputPartName	&lt;String&gt; default value for the part name attribute in an input message	outputPartName	&lt;String&gt; default value for the part name attribute in an output message</body></comment><class><name>WsdlBuilder</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceClasses descriptor </inst-vars><class-inst-vars>defaultDescriptorClass </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.WsdlBuilder</class-id><body>WsdlBuilder uses WsdlConfigurationDescriptor to create the Wsdl document specification. For backward compatibility the class still can build Wsdl document from pragma descriptions. Instance Variables	descriptor &lt;WsdlConfigurationDescriptor&gt; holds all Wsdl spec information	serviceClasses &lt;OrderedCollection of Class&gt; service classes to create the wsdl schemaClass Instance Variables	defaultDescriptorClass &lt;Class&gt; Wsdl11ConfigurationDescriptor or Wsdl20ConfigurationDescriptor</body></comment><class><name>ClientClassExistExc</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WSDLTool</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.ClientClassExistExc</class-id><body>ClientClassExistExc will be raised while creating a Wsld client class if there is already a class with the same name but the super class different than WsdlClient. The default resume action creates a class with a new unique name.</body></comment><class><name>Wsdl20BuildOptions</name><environment>WebServices</environment><super>WebServices.WsdlBuildOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindingType httpVerb mep transportProtocol soapMep styleDefault </inst-vars><class-inst-vars>httpVerb mep bindingType transportProtocol soapMep styleDefault </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.Wsdl20BuildOptions</class-id><body>Represents options to build WSDL 2.0See detailshttp://www.w3.org/TR/wsdl20-adjuncts/#_operation_iri_style http://www.w3.org/TR/wsdl20-primer/#adv-get-vs-posthttp://www.w3.org/TR/wsdl20-adjuncts/#soap12-bindingInstance Variables	bindingType	&lt;String&gt; http://www.w3.org/ns/wsdl/soap	httpVerb	&lt;String&gt; 'POST'	mep	&lt;String&gt; http://www.w3.org/ns/wsdl/in-out	transportProtocol	&lt;String&gt; http://www.w3.org/2003/05/soap/bindings/HTTP/	soapMep	&lt;String&gt; http://www.w3.org/2003/05/soap/mep/request-response/	styleDefault	&lt;String&gt; http://www.w3.org/ns/wsdl/style/iriClass Instance Variables	httpVerb	&lt;String&gt; 	mep	&lt;String&gt; 	bindingType	&lt;String&gt; 	transportProtocol	&lt;String&gt; 	soapMep	&lt;String&gt; 	styleDefault	&lt;String&gt; </body></comment><class><name>WsdlClassBuildOptions</name><environment>WebServices</environment><super>WebServices.X2OClassBuildOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceNS responderNS clientNS clientPackage responderPackage servicePackage responderSuperclass serviceProtocol classNamespace clientClassMap serviceClassMap useExistingClassName clientMessageInterceptorClass responderMessageInterceptorClass clientProcessingPolicy clientProcessingPolicyClass responderName </inst-vars><class-inst-vars>defaultProxyClientPortNumber useExistingClassName </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.WsdlClassBuildOptions</class-id><body>Represents options to build classes from WSDL and X2O bindingsInstance Variables	responderName	&lt;String &gt; responder class name	serviceNS	&lt;String&gt; smalltalk namespace for service class	responderNS	&lt;String&gt; smalltalk namespace for responder class	clientNS	&lt;String&gt; smalltalk namespace fro client class	clientPackage	&lt;String&gt; package where the client is built	responderPackage	&lt;String&gt; package where the responder is built	servicePackage	&lt;String&gt; package where the service class is built	serviceProtocol	&lt;String&gt; default protocol to create service methods	classNamespace	&lt;String&gt; default classes namespace	clientClassMap	&lt;Dictionary&gt;  initially the key and value are WsdlPort name type. 	serviceClassMap	&lt;Dictionary&gt; initially the key and value are WsdlPortType/WsdlInterface name type. 	useExistingClassName	&lt;Boolean&gt; the option defines if the existing class names should be usedClass Instance Variables	useExistingClassName	&lt;Object&gt; the default option defines if the existing class names should be used</body></comment><class><name>ClientClassNoPortExc</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WSDLTool</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.ClientClassNoPortExc</class-id><body>ClientClassNoPortExc will be raise by the WsdlClassBuilder when the wsdl schema doesn't have &lt;port&gt; element to create #serverUrl for a client class.</body></comment><class><name>OperationParameters</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>WSDLTool</package></attributes></class><comment><class-id>WebServices.OperationParameters</class-id><body>OperationParameters helps to describe operation parameters when a WSDL configuration is created.Instance Variables	parameters	&lt;Collection&gt;	parametersExample:(interfaceOperation := descriptor addInterfaceOperationNamed: 'SearchByTitle' toInterface: searchServicesInterface)			selector: #searchByExactTitle:includeAffiliatedLibraries:;			documentation: 'The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found'."Describe input parameters "(parameters := descriptor newParameters)		addParameterNamed:  'searchByExactTitle'  type: String;		addParameterNamed:  'includeAffiliatedLibraries'  type: Boolean.descriptor addInputParameters: parameters toOperation: interfaceOperation."Describe return type "parameters := descriptor newParameters.parameters returnCollectionType: Protocols.Library.Book.descriptor addOutputParameters: parameters  toOperation: interfaceOperation.</body></comment><shared-variable><name>SoapEncoding</name><environment>WebServices.WsdlBuilder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>WSDLTool</package></attributes></shared-variable><shared-variable><name>UseType</name><environment>WebServices.WsdlBuilder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>WSDLTool</package></attributes></shared-variable><shared-variable><name>SoapVersion</name><environment>WebServices.WsdlBuilder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>WSDLTool</package></attributes></shared-variable><shared-variable><name>SoapStyle</name><environment>WebServices.WsdlBuilder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>WSDLTool</package></attributes></shared-variable><shared-variable><name>MessageExchangePattern</name><environment>WebServices.WsdlBuilder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>WSDLTool</package></attributes></shared-variable><shared-variable><name>SetOperationSelector</name><environment>WebServices.WsdlBuilder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>WSDLTool</package></attributes></shared-variable><shared-variable><name>BindingType</name><environment>WebServices.WsdlBuilder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>WSDLTool</package></attributes></shared-variable><methods><class-id>WebServices.WsdlInterceptorBuilder</class-id> <category>accessing</category><body package="WSDLTool">addOperation: anAssoc	self operations add: anAssoc</body><body package="WSDLTool">binding	^binding</body><body package="WSDLTool">binding: anObject	binding := anObject</body><body package="WSDLTool">classBuilder	^classBuilder</body><body package="WSDLTool">classBuilder: anObject	classBuilder := anObject</body><body package="WSDLTool">clientInterceptorClass	^clientInterceptorClass</body><body package="WSDLTool">clientInterceptorClass: aClass	clientInterceptorClass := aClass</body><body package="WSDLTool">headerName	^self marshaler relation name asSymbol</body><body package="WSDLTool">headerValueClassName	| cl |	cl  := self marshaler typeMarshaler valueMarshaler smalltalkClass.	^(cl environment name = #Smalltalk or: [cl environment name = #Core])		ifTrue: [cl name asString ] ifFalse: [cl fullName].</body><body package="WSDLTool">marshaler	^self binding partMarshaler</body><body package="WSDLTool">name	^self marshaler partMarshaler path</body><body package="WSDLTool">operations	^operations ifNil: [ operations := Set new ]</body><body package="WSDLTool">operations: anObject	operations := anObject</body><body package="WSDLTool">serverInterceptorClass	^serverInterceptorClass</body><body package="WSDLTool">serverInterceptorClass: aClass	serverInterceptorClass := aClass</body><body package="WSDLTool">type	^type</body><body package="WSDLTool">type: anObject	type := anObject</body></methods><methods><class-id>WebServices.WsdlInterceptorBuilder</class-id> <category>server methods</category><body package="WSDLTool">commentServerInterceptor	| comment |	comment := String new writeStream.	text := 'The server interceptor'.	('*in*' match: self type ) ifTrue: [text := text , ' verifies &lt;1s&gt; header from requests'].	('*out*' match: self type ) ifTrue: [text := text , ' adds &lt;1s&gt; header to responses'].	comment 		nextPutAll: (text expandMacrosWith: self headerName printString);		cr; cr; nextPutAll: 'Usage';		cr; nextPutAll: 'Add implementation to callbacks. '.	comment cr; nextPutAll: ( 'The interceptor can handle one or more SOAP headers. If you use the interceptor class for more than one SOAP header you need to update the #headerNames class method with these header names. The WsdlClassBuilder won''t create a new interceptor class for a header if the header name is found in the #headerNames in one of the subclasses of the &lt;1s&gt; class.' 			expandMacrosWith: self serverInterceptorClass superclass name).	self printOperationsOn: comment.	comment 		cr; cr; nextPutAll: 'For more information see WebServices documentation: Processing Policies and Message Interceptors.';		cr; nextPutAll: 'As an example of interceptor implementation see the DemoHeaderInterceptor class in WebServicesDemo '.	self serverInterceptorClass comment:  comment contents.</body><body package="WSDLTool">createHeaderNamesMethodFor: aClass	| str  |	str := String new writeStream.	str nextPutAll: '"Header names supported by this interceptor "'; cr.	str crtab; nextPutAll: '^OrderedCollection with: ', self headerName printString.	classBuilder 			addMethod: 'headerNames'			to: aClass class			methodText:  str contents			category: 'accessing'</body><body package="WSDLTool">createReceivingRequestCallback	| stream  |	stream := String new writeStream.	self printReceivingRequestCallbackCommentOn: stream.	self printReceivingRequestHeadersOn: stream. 	classBuilder		addMethod: 'receivingRequestEnvelope: aSoapRequest in: anHttpRequest'		to: self serverInterceptorClass		methodText: stream contents		category: 'processing callbacks'</body><body package="WSDLTool">createSendingReplyCallback	|  stream |	stream := String new writeStream.	self printSendingReplyCallbackCommentOn: stream.	self printSendingReplyHeadersOn: stream.	classBuilder 		addMethod: 'sendingReply: aSoapResponse in: anHttpResponse'		to: self serverInterceptorClass 		methodText:  stream contents		category: 'processing callbacks'.</body><body package="WSDLTool">createServerInterceptor: aString in: serverNS super: superClass		serverInterceptorClass := classBuilder 								createClassDefinition: aString								in: serverNS								instVars: ''								super: superClass.	self commentServerInterceptor.	self createHeaderNamesMethodFor: self serverInterceptorClass. 	('in*' match: self type) ifTrue: [self createReceivingRequestCallback ].	('*out*' match: self type) ifTrue: [self createSendingReplyCallback ].	^self serverInterceptorClass</body><body package="WSDLTool">printOperationsOn: aStream	| names |	names := Set new.	self operations do: [ :assoc | names add: assoc key].	aStream cr;cr; nextPutAll: ('&lt;1s&gt; SOAP header is required by the following operations:' expandMacrosWith: self headerName printString).	names do: [ :name | aStream crtab; nextPutAll: '#', name].</body><body package="WSDLTool">printReceivingRequestCallbackCommentOn: stream	stream nextPutAll: '"The server received aSoapRequest. In this callback you can validate ' , self headerName printString, ' request header. The SoapRequest #header contains all unmarshaled header entries. The request envelope body is not marshaled yet. The anHttpRequest parameter delivered the Soap message."'; cr</body><body package="WSDLTool">printReceivingRequestHeadersOn: aStream	aStream 		crtab; nextPutAll: '( aSoapRequest needsHeader: ' , self headerName printString, ') ifFalse: [^self].';		cr;crtab; nextPutAll: '(aSoapRequest headerAt: ' , self headerName printString, ' ifAbsent: [nil])';		cr; tab: 2; nextPutAll: 'ifNotNil: [ :headerEntry | " validate the header entry value " headerEntry value  ] '.</body><body package="WSDLTool">printSendingReplyCallbackCommentOn: aStream	aStream nextPutAll: '"The server is sending aSoapResponse. In this callback you should add ', self headerName printString, ' header to the reply. The SoapResponse #smalltalkEntity contains the reply object that will be marshaled into the SOAP envelope body. The anHttpResponse parameter will deliver the Soap message to the client"'.</body><body package="WSDLTool">printSendingReplyHeadersOn: aStream	aStream		cr; crtab; nextPutAll: '(aSoapResponse needsHeader: ', self headerName printString, ' ) ifFalse: [^self].';		cr; cr; tab; nextPutAll: '(aSoapResponse headerFor: ', self headerName printString, ')';		cr; tab: 2; nextPutAll: 'value: ', self headerValueClassName, ' new.' .</body></methods><methods><class-id>WebServices.WsdlInterceptorBuilder</class-id> <category>client methods</category><body package="WSDLTool">commentClientInterceptor	| comment |	comment := String new writeStream.	text := 'The client interceptor'.	('*in*' match: self type ) ifTrue: [text := text , ' adds &lt;1s&gt; header to requests'].	('*out*' match: self type ) ifTrue: [text := text , ' processes &lt;1s&gt; header from responses'].	comment 		nextPutAll: (text expandMacrosWith: self headerName printString);		cr; cr; nextPutAll: 'Usage';		cr; nextPutAll: 'Add implementation to callbacks. '.	comment cr; nextPutAll: ( 'The interceptor can handle one or more SOAP headers. If you use the interceptor class for more than one SOAP header you need to update the #headerNames class method with these header names. The WsdlClassBuilder won''t create a new interceptor class for a header if the header name is found in the #headerNames in one of the subclasses of the &lt;1s&gt; class.' 		expandMacrosWith:  self clientInterceptorClass superclass name).	self printOperationsOn: comment.	comment 		cr; cr; nextPutAll: 'For more information see WebServices documentation: Processing Policies and Message Interceptors.';		cr; nextPutAll: 'As an example of interceptor implementation see the DemoHeaderInterceptor class in WebServicesDemo '.	self clientInterceptorClass comment:  comment contents.</body><body package="WSDLTool">createClientInterceptor: aString in: clientNS super: superClass		clientInterceptorClass := classBuilder 								createClassDefinition: aString								in: clientNS								instVars: ''								super: superClass.	self commentClientInterceptor.	self createHeaderNamesMethodFor: self clientInterceptorClass.	('in*' match: self type) ifTrue: [self createSendingRequestCallback ].	('*out*' match: self  type) ifTrue: [self createReceivingReplyCallback].	^self clientInterceptorClass</body><body package="WSDLTool">createReceivingReplyCallback	| stream |	stream := String new writeStream.	self printReceivingReplyCallbackCommentOn: stream.	self printReceivingReplyHeaderOn: stream.	classBuilder 		addMethod: 'receivingReply: aSoapResponse in: anHttpResponse'		to: self clientInterceptorClass 		methodText:  stream contents		category: 'processing callbacks'.</body><body package="WSDLTool">createSendingRequestCallback	| stream  headerName |	headerName := self headerName printString.	stream := String new writeStream.	self printSendingRequestCallbackCommentOn: stream.	stream 		crtab; nextPutAll: '(aSoapRequest needsHeader: ' , headerName , ') ifFalse: [^self].'; cr;		crtab; nextPutAll: '(aSoapRequest headerFor: ' , headerName , ')'; cr;		tab: 2; nextPutAll: 'value: ' , self headerValueClassName , ' new'.	classBuilder		addMethod: 'sendingRequest: aSoapRequest in: aHttpRequest'		to: self clientInterceptorClass		methodText: stream contents		category: 'processing callbacks'.</body><body package="WSDLTool">printReceivingReplyCallbackCommentOn: aStream	aStream nextPutAll: '"The client received aSoapResponse. In this callback you can validate ', self headerName printString, ' header, raise an exception if  it is a fault message. The SoapResponse #smalltalkEntity contains unmarshaled SOAP envelope. The anHttpResponse parameter delivered the Soap message."'.</body><body package="WSDLTool">printReceivingReplyHeaderOn: aStream	| headerName |	headerName := self headerName printString.	aStream 		cr; crtab; nextPutAll: 'aSoapResponse hasFault ifTrue: [ "Process reply errors" ^self ].';		crtab; nextPutAll: '(aSoapResponse needsHeader: ', headerName, ') ifFalse: [^self].';		crtab; nextPutAll: '(aSoapResponse headerAt: ', headerName, ' ifAbsent: [nil])';		cr; tab: 2; nextPutAll: 'ifNotNil: [ :headerEntry | "Validate the header entry value " headerEntry value  ] '.</body><body package="WSDLTool">printSendingRequestCallbackCommentOn: aStream	aStream nextPutAll: '"The client is sending aSoapRequest. In this callback you can add ' , self headerName printString, ' header to the request. The anHttpRequest parameter will deliver the Soap message to the server "'; cr</body></methods><methods><class-id>WebServices.WsdlInterceptorBuilder</class-id> <category>comparing</category><body package="WSDLTool">= anInterceptorPrinter	self name = anInterceptorPrinter name</body><body package="WSDLTool">hash		^self name hash</body></methods><methods><class-id>WebServices.WsdlInterceptorBuilder</class-id> <category>initialize-release</category><body package="WSDLTool">from: aHeaderBinding	binding := aHeaderBinding</body></methods><methods><class-id>WebServices.WsdlInterceptorBuilder class</class-id> <category>instance creation</category><body package="WSDLTool">type: aSymbol	^self new		type: aSymbol;		yourself</body></methods><methods><class-id>WebServices.Wsdl11InterceptorBuilder</class-id> <category>server methods</category><body package="WSDLTool">printReceivingRequestHeadersOn: aStream	super printReceivingRequestHeadersOn: aStream.	self binding excMarshalers notNil		ifTrue: [aStream cr;crtab; nextPutAll: '"If the header validation is failed raise the header exceptions here'.				self binding excMarshalers keys do: [:cl | aStream crtab; nextPutAll: cl fullName , ' raise.'].				aStream crtab; nextPutAll: '"'. ].</body></methods><methods><class-id>WebServices.Wsdl20FaultInterceptorBuilder</class-id> <category>client methods</category><body package="WSDLTool">commentClientInterceptor	self commentClass: self clientInterceptorClass</body><body package="WSDLTool">printReceivingReplyCallbackCommentOn: aStream	aStream nextPutAll: '"The client received aSoapResponse with SOAP fault headers and body. In this callback you can validate the fault headers and raise the exception that was unmarshaled in to the fault detail contents. The anHttpResponse parameter delivered the Soap message."'.</body><body package="WSDLTool">printReceivingReplyHeaderOn: aStream	aStream cr;crtab; nextPutAll: 'aSoapResponse failed ifTrue: ['. 	self binding headers do: [ :headerBinding |		aStream 				cr;tab:2; nextPutAll: '(aSoapResponse headerAt: #', headerBinding partMarshaler path type, ' ifAbsent: [nil])';				cr; tab: 3; nextPutAll: 'ifNotNil: [ :headerEntry | "Validate the header entry value " headerEntry value  ].'. ].	aStream cr; cr;tab:2; nextPutAll: '"Raise an exception if the detail contents was unmarshaled as a subclass of Error "'.	aStream cr;tab:2; nextPutAll: 'aSoapResponse raiseException.'.	aStream nextPutAll: '].'.</body></methods><methods><class-id>WebServices.Wsdl20FaultInterceptorBuilder</class-id> <category>server methods</category><body package="WSDLTool">commentServerInterceptor	self commentClass: self serverInterceptorClass</body><body package="WSDLTool">createHeaderNamesMethodFor: aClass	| stream  |	stream := String new writeStream.	stream nextPutAll: '"Header names supported by this interceptor "'; cr.	stream crtab; nextPutAll: '^OrderedCollection new '.	self binding headers 		do: [ :headerBinding |			stream cr;tab:2; nextPutAll: 'add: ', headerBinding partMarshaler typeMarshaler valueMarshaler smalltalkClass fullName.			stream nextPut: $;].	stream cr;tab:2; nextPutAll: 'yourself.'. 	classBuilder 			addMethod: 'headerNames'			to: aClass class			methodText:  stream contents			category: 'accessing'</body><body package="WSDLTool">printSendingReplyCallbackCommentOn: aStream	aStream nextPutAll: '"The exception: ',self headerName printString, ' was raised in the application. The server is sending aSoapResponse with SOAP fault. In this callback you should add  the fault headers to the reply. The SoapResponse #smalltalkEntity contains the fault object that will be marshaled into the SOAP envelope body. The anHttpResponse parameter will deliver the Soap message to the client"'.</body><body package="WSDLTool">printSendingReplyHeadersOn: aStream	aStream crtab; nextPutAll: 'aSoapResponse failed ifTrue: ['. 	aStream cr;tab: 2; nextPutAll:  '(aSoapResponse hasException: ', self marshaler typeMarshaler smalltalkClass fullName, ') ifTrue: [ '.	self binding headers do: [ :headerBinding |		aStream cr;tab:3; nextPutAll: 'aSoapResponse  reply headerAt: #', headerBinding partMarshaler path type, ' put: ', headerBinding partMarshaler typeMarshaler valueMarshaler smalltalkClass fullName, ' new.' . ].	aStream nextPutAll: ']].'</body></methods><methods><class-id>WebServices.Wsdl20FaultInterceptorBuilder</class-id> <category>private</category><body package="WSDLTool">commentClass: aClass	| comment |	comment := String new writeStream.	comment 		nextPutAll: 'The interceptor provides callbacks for processing SOAP headers that were described in a SOAP fault: ', self headerName printString;		cr;cr; nextPutAll: 'See Web Services Description Language (WSDL) Version 2.0: http://www.w3.org/TR/wsdl20-adjuncts/#soap-binding';		cr; cr; nextPutAll: 'Usage';		cr; nextPutAll: 'Add implementation to callbacks. '.	comment 		cr; cr; nextPutAll: 'For more information see WebServices documentation: Processing Policies and Message Interceptors.';		cr; nextPutAll: 'As an example of interceptor implementation see the DemoHeaderInterceptor class in WebServicesDemo '.	aClass comment:  comment contents.</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>public api</category><body package="WSDLTool">createClasses"Creates service and client classes "	self createServiceClasses.	self createClientClasses.</body><body package="WSDLTool">createClientClass: aString from: aWsdlPort	"Creates Wsdl client class "	self buildOptions clientClassMap at: aWsdlPort name type put: aString.	^bindingClassBuilder 		createClassesInPackage: self clientPackage		do: 	[self createClientClassFrom: aWsdlPort  ]</body><body package="WSDLTool">createClientClasses"Creates the client class"	^self createClientClassesDo: [ :port | self createClientClassFrom: port ]</body><body package="WSDLTool">createResponderClass"Creates SOAPResponder subclass"	| responderClass |	bindingClassBuilder 		createClassesInPackage: self responderPackage		do:	[responderClass := BindingClassBuilder 				createClassDefinition: (self validateClassName: self buildOptions responderName in: self responderNS)				in: self responderNS				instVars: ''				classVars: ''				super: self buildOptions responderSuperclass fullName				imports: 'WebServices.*'				category: self buildOptions category. ].	self updateResponder: responderClass.	^responderClass</body><body package="WSDLTool">createServiceClassFrom: anInterface"Creates the service class from InterfaceDescriptor "	| servClass  result interfaceBindings  stream |	servClass := bindingClassBuilder 					createClassDefinition: ( self validateServiceClassNameFrom: anInterface) 					in: self serviceNS.	anInterface serviceClass: servClass.	interfaceBindings := self config bindings select: [ :b | b bindingDescriptor interfaceDescriptor  = anInterface ].	anInterface operations do: [ :intOperation | 		stream := String new writeStream.		"For each interface operation add a method with return result to a service class "		stream crtab; nextPutAll: '^self  "Add implementation here"'.		(self bindingOperationFrom: interfaceBindings for: intOperation) ifNotNil: [ :bindingOperation |			result := ((result := bindingOperation returnObject) notNil and: [ result notEmpty]) 				ifTrue: [ stream cr; nextPutAll: '"Result object:'; cr; nextPutAll: result, '"' ].			bindingClassBuilder 				addMethod: bindingOperation printMethodSelector 				to: servClass 				methodText: stream contents 				category: self buildOptions serviceProtocol.]].	^servClass</body><body package="WSDLTool">createServiceClasses"Creates the service classes"	bindingClassBuilder 		createClassesInPackage: self servicePackage		do: 	[self config interfaces do: [ :interface |  self createServiceClassFrom: interface ]].	^self serviceClasses</body><body package="WSDLTool">readSelectorsFrom: aStream	serviceMaps := SelectorMap loadFrom: aStream.	( serviceMaps isKindOf: OrderedCollection ) 		ifFalse: [ serviceMaps := OrderedCollection with: serviceMaps ].</body><body package="WSDLTool">readServiceMapFrom: aStream	serviceMaps := ServiceMap loadFrom: aStream.</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>accessing</category><body package="WSDLTool">bindingClassBuilder	^bindingClassBuilder</body><body package="WSDLTool">bindingClassBuilderClass	^BindingClassBuilder</body><body package="WSDLTool">bindingClassBuilderOptions	^bindingClassBuilder buildOptions</body><body package="WSDLTool">bindingNamespaceMap	^typesParser namespaceMap</body><body package="WSDLTool">bindingPackage		^bindingClassBuilder  package</body><body package="WSDLTool">bindingPackage: aString		bindingClassBuilder  package: aString</body><body package="WSDLTool">bindingPackageMap		^self bindingClassBuilder packageMap</body><body package="WSDLTool">buildOptions	^buildOptions</body><body package="WSDLTool">buildOptions: aWsdlClassBuildOptions	buildOptions := aWsdlClassBuildOptions</body><body package="WSDLTool">classNamespace		^self buildOptions  classNamespace</body><body package="WSDLTool">classNamespace: aString	self buildOptions classNamespace: aString.</body><body package="WSDLTool">clientMessageInterceptorClass	^self buildOptions clientMessageInterceptorClass</body><body package="WSDLTool">clientMessageInterceptorName	^self clientMessageInterceptorClass fullName</body><body package="WSDLTool">clientNS	^self buildOptions clientNS</body><body package="WSDLTool">clientNS: aString		self buildOptions clientNS: aString</body><body package="WSDLTool">clientPackage	^self buildOptions clientPackage</body><body package="WSDLTool">clientPackage: aString		self buildOptions clientPackage: aString</body><body package="WSDLTool">clientProcessingPolicyClass	^self buildOptions clientProcessingPolicyClass</body><body package="WSDLTool">config	config isNil ifTrue: [ self buildConfig ].	^config</body><body package="WSDLTool">config: aConfiguration	config := aConfiguration</body><body package="WSDLTool">dataSource	^dataSource</body><body package="WSDLTool">descriptor	^descriptor</body><body package="WSDLTool">namespaceForBindingClasses		^typesParser namespace</body><body package="WSDLTool">namespaceForBindingClasses: aString		typesParser namespace: aString</body><body package="WSDLTool">package	^self buildOptions package</body><body package="WSDLTool">package: aString	self buildOptions package: aString.	bindingClassBuilder buildOptions hasDefaultPackage		ifTrue: [ bindingClassBuilder package: aString ]</body><body package="WSDLTool">responderMessageInterceptorClass	^self buildOptions responderMessageInterceptorClass</body><body package="WSDLTool">responderMessageInterceptorName	^self responderMessageInterceptorClass fullName</body><body package="WSDLTool">responderNS	^self buildOptions responderNS</body><body package="WSDLTool">responderNS: aString		self buildOptions responderNS: aString</body><body package="WSDLTool">responderName	^self buildOptions responderName</body><body package="WSDLTool">responderName: aString		self buildOptions responderName: aString</body><body package="WSDLTool">responderPackage	^self buildOptions responderPackage</body><body package="WSDLTool">responderPackage: aString		self buildOptions responderPackage: aString</body><body package="WSDLTool">selectAllObjectElements	| coll xpath |	coll := OrderedCollection new.	xpath := XPathParser new parse: 'descendant-or-self::object' as: #locationPath.	self x2oDocuments do: [ :el | coll addAll: ( (xpath xpathValueFor: el variables: nil) sortedNodes )].	^coll</body><body package="WSDLTool">serviceClasses	| coll |	coll := OrderedCollection new.	descriptor interfaces collect: [ :interface | interface serviceClass ifNotNil: [coll add: interface serviceClass ]].	^coll</body><body package="WSDLTool">serviceNS	^self buildOptions serviceNS</body><body package="WSDLTool">serviceNS: aString	self buildOptions serviceNS: aString</body><body package="WSDLTool">servicePackage	^self buildOptions servicePackage</body><body package="WSDLTool">servicePackage: aString	self buildOptions servicePackage: aString</body><body package="WSDLTool">soapHeaders	soapHeaders isEmpty ifTrue: [ 		self config bindings do: [ :binding | 			binding operations do: [ :operation | operation collectSoapHeaderDescriptionIn: soapHeaders ]]].	^soapHeaders</body><body package="WSDLTool">x2oDocuments	^descriptor x2oDocuments</body><body package="WSDLTool">xmlTypesParserClass	^XMLTypesParser</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>utilities</category><body package="WSDLTool">saveDocument: anElement intoFile: fileName	XML.Document saveDocument: anElement intoFile: fileName</body><body package="WSDLTool">saveDocument: anElement intoMethod: methName class: aClass withComment: fromString 	XML.Document 		saveDocument: anElement		intoMethod: methName		class: aClass		withComment: fromString</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>private</category><body package="WSDLTool">bindingOperationFrom: interfaceBindings for: interfaceOperation	interfaceBindings do: [ :binding |  binding operations do: [ :op | op name type = interfaceOperation name type ifTrue: [^op]]].	^nil</body><body package="WSDLTool">createBindingNameMethodFor: aClientClass binding: binding portNumber: portNumber 	| methods  |	methods := OrderedCollection new.	methods 		add: (Array with: 'bindingName' with: '^' ,  binding name type printString);		add: (Array with: 'bindingTargetNamespace' with: '^',  binding name namespace printString).	portNumber &gt; 0		ifTrue:  [ methods add: (Array with: 'port' with: '^' , portNumber printString)].	self 		createMethods: methods		for: aClientClass class		category: 'accessing'.</body><body package="WSDLTool">createClientClassesDo: aBlock"Creates the Wsdl client and the Opentalk client classes"	| clientClasses |	self config services isEmpty ifTrue: [ ClientClassNoPortExc raiseRequest ].	clientClasses := OrderedCollection new.	bindingClassBuilder 		createClassesInPackage: self clientPackage		do: 	[ self config services	do: [ :service | 				service ports do: [ :port | port binding ifNotNil:[ clientClasses add: (aBlock value: port) ]]]].	^clientClasses</body><body package="WSDLTool">createMethods: aCollection for: aClass category: cString	| stream |	stream := (String new: 128) writeStream.		aCollection		do: [ :meth |			stream reset.			stream nextPutAll: meth last.			bindingClassBuilder addMethod: meth first				to: aClass 				methodText:  stream contents				category: cString].</body><body package="WSDLTool">createSchemaMethodFor:  aClass	| methodStream  x2o |	(x2o := self x2oDocuments) notEmpty		ifTrue: [self 					saveDocument:  x2o first					intoMethod:  #x2oBinding					class: aClass 					withComment: nil]. 	methodStream := (String new: 1024) writeStream.	methodStream nextPutAll: 'wsdlSchema';	cr; crtab.	methodStream nextPut: $^.	( dataSource isKindOf: Stream ) ifTrue: [methodStream print: dataSource contents. ].	(dataSource isKindOf: OS.URI)  ifTrue: [methodStream nextPutAll: dataSource asString printString, ' encodedStringAsURI'].	(dataSource isKindOf: Filename)  ifTrue: [methodStream nextPutAll: dataSource asString printString, ' asFilename asURI'].	dataSource isString ifTrue: [methodStream nextPutAll: dataSource asString printString ].	aClass class compile: methodStream contents classified: 'wsdl schema'.</body><body package="WSDLTool">defaultServiceClasstNameFrom: anInterface	^SystemUtils		validateClassName: anInterface  name type		confirm: [:msg :nm | true ]		warn: [:msg |]</body><body package="WSDLTool">privateReadFrom: aDataSource	dataSource := aDataSource.	descriptor := WsdlConfigurationDescriptor loadAndParse: aDataSource.	self setClientServiceMapsFrom: descriptor.	descriptor schemaBindings isEmpty 		ifTrue: [ ( typesParser namespaceMap isEmpty 					or: [ typesParser namespace = XMLObjectBindingPolicy defaultClassNamespace ])					ifTrue: [ typesParser namespace: self classNamespace ].				descriptor createX2OBindingUsing: typesParser baseURI: aDataSource].</body><body package="WSDLTool">setDescriptorFromWsdlBinding: aWsdlBinding	descriptor targetNamespace: aWsdlBinding targetNamespace.	self servicePackage: aWsdlBinding serviceClass package name.	descriptor 		initializeFromWsdlBinding: aWsdlBinding 		serviceClass: aWsdlBinding serviceClass</body><body package="WSDLTool">setExceptionClasses	"For all freshly generated exception classes for operations (faults) now set the superclass to Error.	Make sure to leave exceptions defined by other bindings untouched. Keep also XML-based class hierarchy definitions."	| allExceptionClasses abstract myExceptionClasses |	allExceptionClasses := Set new.	self config bindings do: [:aBinding | 		aBinding operations do: [:op | allExceptionClasses addAll: op exceptionClasses]].	"add abstract classes that are not directly used as exceptions"	abstract := allExceptionClasses				inject: Set new				into: [:supers :aClass | supers addAll: aClass allSuperclasses; yourself].	allExceptionClasses addAll: abstract.	"skip classes that are not freshly generated by this binding"	myExceptionClasses := allExceptionClasses copy.	allExceptionClasses do: [:aClass | 		(bindingClassBuilder bindingClasses includes: aClass) ifFalse: [myExceptionClasses remove: aClass]].	"if there is a superclass defined, assume that the superclass will be Error subclass"	(SystemUtils sortForLoading: myExceptionClasses) do: [:aClass | 		(aClass inheritsFrom: Error) 	ifFalse: 			[(aClass classBuilder)				currentClass: aClass;				superclass: Error;				instanceVariables: aClass instVarNames copy;				format: aClass format;				reviseSystem]]</body><body package="WSDLTool">setServiceClassFor: anInterface	|  serviceClass serviceClassName |	serviceClassName := (self validateServiceClassNameFrom: anInterface) asString.	serviceClass := self serviceClasses 			detect: [ :clx | clx name asString = serviceClassName ] 			ifNone: [(self classNamespace, '.', serviceClassName ) asQualifiedReference valueOrDo: [self createServiceClassFrom: anInterface]].	anInterface serviceClass: serviceClass.	^serviceClass</body><body package="WSDLTool">validateClassName: aName in: aNamespace	| newName ns reference theClass |	newName := XMLObjectBindingPolicy createSmalltalkClassNameFrom: aName inNamespace: aNamespace.	ns := BindingClassBuilder createNS: aNamespace inCategory: self buildOptions category.	reference := (ns fullyQualifiedReferenceOf: newName) fullName asStrictReference.	theClass := reference valueOrDo: [nil].	theClass isNil ifTrue: [^newName].	(self buildOptions useExistingClassName and: [ theClass isForClass not ])		ifTrue: [^XMLObjectBindingPolicy 					createUniqueClassNameFrom: newName 					inNamespace: aNamespace].	^newName</body><body package="WSDLTool">validateServiceClassNameFrom: aInterface	^self 		validateClassName: (self buildOptions serviceClassMap at: aInterface name type ifAbsent: [self defaultServiceClasstNameFrom: aInterface ]) 		in: self serviceNS.</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>private-client</category><body package="WSDLTool">buildClientHeaderInterceptors"If there are Soap headers assigned to operations we build interceptor classes to add and process these headers"	| interceptorName clName |	self soapHeaders isEmpty ifTrue: [^nil]. 	bindingClassBuilder 		createClassesInPackage: self clientPackage		do: [self soapHeaders values do: [ :builder |				interceptorName := builder headerName, 'ClientInterceptor'.				clName := XMLObjectBindingPolicy 						createSmalltalkClassNameFrom: interceptorName						inNamespace: self clientNS 						useExistingClassName: true.				((self clientNS, '.',clName asSymbol) asQualifiedReference valueOrDo: [nil])					ifNil: [builder classBuilder: bindingClassBuilder.						builder createClientInterceptor: interceptorName  in: self clientNS super: self clientMessageInterceptorName ]					ifNotNil: [ :cl | builder clientInterceptorClass ifNil: [ builder clientInterceptorClass: cl ]]]]</body><body package="WSDLTool">createClientClass: aString binding: aWsdlBinding	"Creates the client class"	| clientClass  |	self buildClientHeaderInterceptors.	clientClass := bindingClassBuilder class				createClassDefinition: aString				in: self clientNS				instVars: ''				classVars: ''				super: 'WebServices.WsdlClient'				imports: 'WebServices.*'				category: self buildOptions category.	" creating class methods"	self createBindingNameMethodFor: clientClass binding: aWsdlBinding portNumber: 0.	self updateClient: clientClass binding: aWsdlBinding.	^clientClass</body><body package="WSDLTool">createClientClassFrom: aWsdlPort 	"Creates the client class"	| name |	name := self 		validateClientName: (self buildOptions clientClassMap at: aWsdlPort name type  ifAbsent: [self defaultClientNameFrom: aWsdlPort])   		superclass: WsdlClient.	^self createClientClass: name  binding: aWsdlPort binding.</body><body package="WSDLTool">createClientMethodFor: aClass binding: aWsdlBinding do: aBlock	| stream  |	stream := (String new: 512) writeStream.	aWsdlBinding operations do: [ :op | 		stream reset. 			aBlock value: op value: stream.		bindingClassBuilder  			addMethod: op printMethodSelector 			to: aClass 			methodText: stream contents 			category: WsdlBuildOptions defaultServiceProtocol ]</body><body package="WSDLTool">createProcessingPolicyForClient: aClass		| stream |	(self soapHeaders select: [ :builder | builder clientInterceptorClass notNil ]) isEmpty ifTrue: [^nil].	stream := String new writeStream.	stream tab; nextPutAll: '| interceptors |'.	self printClientInterceptorCollectionOn: stream.	stream cr;crtab; nextPutAll: '^', self clientProcessingPolicyClass fullName, ' new 		interceptorClasses: interceptors;		yourself'.	bindingClassBuilder 		addMethod: 'processingPolicy'		to: aClass class		methodText:  stream contents		category: 'accessing'.</body><body package="WSDLTool">defaultClientNameFrom: aPort	^SystemUtils		validateClassName: aPort name type , 'Client'		confirm: [:msg :nm | true ]		warn: [:msg |]</body><body package="WSDLTool">printClientInterceptorCollectionOn: aStream	| interceptors |	interceptors := Set new.	self soapHeaders values do: [ :builder | builder clientInterceptorClass ifNotNil: [ :cl | interceptors add: cl] ].	aStream crtab; nextPutAll: '(interceptors := OrderedCollection new)'.	interceptors 		do: [ :interceptor | aStream cr; tab:2; nextPutAll: 'add: ', interceptor fullName ]		separatedBy: [aStream nextPut: $;].	aStream nextPut: $. .</body><body package="WSDLTool">setClientServiceMapsFrom: aConfigurationDescriptor	aConfigurationDescriptor services do: [ :service | 		service ports do: [ :port |  self buildOptions clientClassMap at: port name type put:  ( self defaultClientNameFrom: port ) ]].	aConfigurationDescriptor interfaces do: [ :interface |  self buildOptions serviceClassMap at: interface name type put: (self defaultServiceClasstNameFrom: interface)  ]</body><body package="WSDLTool">updateClient: clientClass binding: wsdlBinding	"Creates the client class"	self soapHeaders notEmpty ifTrue: [self createProcessingPolicyForClient: clientClass].	self createSchemaMethodFor: clientClass.		" creating class instance methods"	self 		createClientMethodFor: clientClass		binding: wsdlBinding		do: [:op :stream | op printClientMethodOn: stream].	^clientClass</body><body package="WSDLTool">updateClientClass: aClass do: aBlock	self clientPackage: aClass package name.	self clientNS: aClass environment shortName.	aClass selectors do: [ :sel | aClass removeSelector: sel ].	^aBlock value</body><body package="WSDLTool">validateClientName: aString superclass: superClass	| aName ref newName |	aName := self validateClassName: aString asSymbol 	in: self clientNS.	^((ref := (self clientNS, '.', aName)  asSymbol asStrictReference) isDefined		and: [ ref value superclass  ~= superClass])		ifTrue: 			[newName := ClientClassExistExc raiseRequestFrom: ref value name asString.			newName isNil				ifTrue: [aName]				ifFalse: [self validateClassName: newName in: self clientNS ]]		ifFalse: [aName] .</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>initialization</category><body package="WSDLTool">bindingNamespaceMap: aStringOrDictionary	typesParser namespace: aStringOrDictionary</body><body package="WSDLTool">bindingPackageMap: aDictionary		self bindingClassBuilder packageMap: aDictionary</body><body package="WSDLTool">buildConfig	((XPathParser new parse: '//child::object' as: #locationPath) 		xpathValueFor: descriptor schemaBindings first variables: nil) sortedNodes isEmpty		ifTrue: [bindingClassBuilder x2oBindings: (XMLObjectBinding buildBindings: descriptor schemaBindings first realElements )]		ifFalse: [ bindingClassBuilder createClassesFromBinding:  descriptor schemaBindings ].	descriptor schemaBindings: bindingClassBuilder x2oBindings.	config := descriptor configurationBuilder buildComponentsFrom: descriptor.	serviceMaps		ifNotNil: [ config bindings do: [ :binding | 					(serviceMaps detect: [ :map | map acceptBinding: binding ] ifNone: [nil])						ifNotNil: [ :map |  binding serviceMap: map ]]]		ifNil: [ config bindings do: [ :binding |  binding createDefaultServiceMap ] ].	self setExceptionClasses.</body><body package="WSDLTool">buildOptionsClass	^WsdlClassBuildOptions</body><body package="WSDLTool">dataSource: aDataSource	dataSource := aDataSource</body><body package="WSDLTool">descriptor: aConfigurationDescriptor	descriptor := aConfigurationDescriptor.</body><body package="WSDLTool">initialize		bindingClassBuilder := self bindingClassBuilderClass new.	buildOptions := self buildOptionsClass new.	soapHeaders := Dictionary new.	typesParser := self xmlTypesParserClass new.	self useObjectBinding.</body><body package="WSDLTool">initializeConfigFrom: aConfigurationDescriptor	descriptor := aConfigurationDescriptor.	config := descriptor complete.	dataSource := aConfigurationDescriptor asWsdl printString readStream.</body><body package="WSDLTool">readDocumentsWithDefaultBindingFrom:  aDataSource	self useDefaultBinding.	[self privateReadFrom: aDataSource.	] on: MappingUnboundedContentToStruct do: [ :ex | ex resume ]</body><body package="WSDLTool">readFrom: aDataSource	self useObjectBinding.	self privateReadFrom: aDataSource.</body><body package="WSDLTool">useDefaultBinding	typesParser setBindingPolicy: XMLDefaultBindingPolicy new.</body><body package="WSDLTool">useObjectBinding	typesParser setBindingPolicy: XMLObjectBindingPolicy new.</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>update responder &amp; client</category><body package="WSDLTool">initializeConfigFromResponder: aSOAPResponder	self responderPackage: aSOAPResponder package name.	config := WsdlBinding initializeRegistriesFor: aSOAPResponder.	descriptor := config descriptor.	dataSource := aSOAPResponder wsdlSchema.</body><body package="WSDLTool">initializeFromResponder: aResponder serviceClass: serviceClass	| wsdlBinding |	self initializeConfigFromResponder: aResponder.	wsdlBinding := self config bindings				detect: [:b | b serviceClass = serviceClass]				ifNone: 					[self error: ('Can not find WsdlBinding for the service class: &lt;1s&gt;'								expandMacrosWith: serviceClass name)].	self setDescriptorFromWsdlBinding: wsdlBinding</body><body package="WSDLTool">updateClientClass: aClass binding: aWsdlBinding	"Recreates Wsdl client class "	^self 		updateClientClass: aClass 		do: [self 				createClientClass: aClass name 				binding: aWsdlBinding ]</body><body package="WSDLTool">updateResponder: aSOAPResponder"Creates the responder class"	| maps |	bindingClassBuilder 		createClassesInPackage: self responderPackage		do: 	[self soapHeaders notEmpty ifTrue: [ 					self buildResponderHeaderInterceptors.				self createInterceptorsFor: aSOAPResponder ].			self createSchemaMethodFor:  aSOAPResponder.			"Check if there are service classes. If not we will create them "			maps :=  OrderedCollection new.			descriptor interfaces do: [ :interface | 				maps add: interface serviceMap.				interface serviceClass ifNil: [ self setServiceClassFor: interface ]].			"Create a method with service map"			ServiceMap 				storeMaps: maps				toClass: aSOAPResponder 				selector: 'serviceMap'. ].</body></methods><methods><class-id>WebServices.WsdlClassBuilder</class-id> <category>private-responder</category><body package="WSDLTool">buildResponderHeaderInterceptors"If there are Soap headers assigned to operations we build interceptor classes to add and process these headers"	| interceptorName clName | 	bindingClassBuilder		createClassesInPackage: self responderPackage		do: [self soapHeaders values do: [ :builder |				interceptorName := builder headerName, 'ResponderInterceptor'.				clName := XMLObjectBindingPolicy 						createSmalltalkClassNameFrom: interceptorName						inNamespace: self clientNS 						useExistingClassName: true.				((self responderNS, '.', clName asSymbol) asQualifiedReference valueOrDo: [nil])					ifNil: [builder classBuilder: bindingClassBuilder.						builder createServerInterceptor: clName in: self responderNS super: self responderMessageInterceptorName.]					ifNotNil: [ :cl | builder serverInterceptorClass: cl ] ]]</body><body package="WSDLTool">createInterceptorsFor: aSOAPResponder	| methodStream serverInterceptors |	(serverInterceptors := self soapHeaders select: [ :builder |  builder serverInterceptorClass notNil ]) isEmpty ifTrue: [^nil].	methodStream := (String new: 1024) writeStream.	methodStream 		nextPutAll: 'interceptors';	cr;		crtab; nextPutAll: '| interceptors |';		crtab; nextPutAll: '(interceptors := OrderedCollection new)'.	serverInterceptors 		do: [ :builder | methodStream cr; tab: 2; nextPutAll: 'add: ', builder serverInterceptorClass fullName ]		separatedBy: [ methodStream nextPut: $;].	methodStream nextPut: $.; cr.	methodStream cr;nextPutAll: '	^interceptors'.	aSOAPResponder class compile: methodStream contents classified: 'wsdl schema'.</body></methods><methods><class-id>WebServices.WsdlClassBuilder class</class-id> <category>defaults</category><body package="WSDLTool">removeAspectUnderscores	^XMLObjectBindingPolicy removeAspectUnderscores</body><body package="WSDLTool">removeAspectUnderscores:  aBoolean	XMLObjectBindingPolicy removeAspectUnderscores: aBoolean</body></methods><methods><class-id>WebServices.WsdlClassBuilder class</class-id> <category>instance creation</category><body package="WSDLTool">new	^self basicNew initialize</body><body package="WSDLTool">readDocumentsWithDefaultBindingFrom:  aDataSource"Loads the Wsdl schema  from a data source. The dataSource may be a Stream, a URI, a Filename or a String which will be treated as a Filename. All classes will be genereated in the default namespace. XML complex types will be represented as WebServices.Struct in the XML to object binding "	^self new 		readDocumentsWithDefaultBindingFrom:  aDataSource;		yourself.</body><body package="WSDLTool">readFrom: aDataSource "Loads the Wsdl schema  from a data source. The dataSource may be a Stream, a URI, a Filename or a String which will be treated as a Filename. All classes will be genereated in the default namespace."	^self readFrom: aDataSource inNamespace: XMLObjectBindingPolicy defaultClassNamespace</body><body package="WSDLTool">readFrom: aDataSource inNamespace: aString"Loads the Wsdl schema  from a data source. The dataSource may be a Stream, a URI, a Filename or a String which will be treated as a Filename. All classes will be genereated in the specified namespace. The namespace will be created if it doesn't exist"	^self new		classNamespace: aString;		bindingNamespaceMap: aString;		readFrom: aDataSource;		yourself.</body></methods><methods><class-id>WebServices.Wsdl11FaultInterceptorBuilder</class-id> <category>client methods</category><body package="WSDLTool">commentClientInterceptor	| comment |	comment := String new writeStream.	comment 		nextPutAll: ('The client interceptor proceses ', self headerName printString, ' SOAP header from &lt;soap:headerfault&gt; elements' );		cr; cr; nextPutAll: 'Usage';		cr; nextPutAll: 'Add implementation to callbacks. '.	comment cr; nextPutAll:  'The default receving fault reply callback raises an exception that was unmarshaled from the SOAP header value.'.	self printOperationsOn: comment.	comment 		cr; cr; nextPutAll: 'For more information see WebServices documentation: Processing Policies and Message Interceptors.';		cr; nextPutAll: 'As an example of interceptor implementation see the DemoHeaderInterceptor class in WebServicesDemo '.	self clientInterceptorClass comment:  comment contents.</body><body package="WSDLTool">printReceivingReplyCallbackCommentOn: aStream	aStream nextPutAll: '"The client received the response with fault body and headers described by &lt;soap:headerfault message=..&gt; elements. In this callback you can process ', self headerName printString, ' fault header and raise an exception which is unmarshaled in to the header entry value. The anHttpResponse parameter delivered the Soap message."'.</body><body package="WSDLTool">printReceivingReplyHeaderOn: aStream	aStream cr;crtab; nextPutAll: 'aSoapResponse failed ifTrue: ['. 	aStream 		cr;tab: 2; 		nextPutAll: ( '(aSoapResponse headerAt: #&lt;1s&gt; ifAbsent: [nil]) ifNotNil: [ :headerEntry | headerEntry value raise ]].' expandMacrosWith: self marshaler path type printString ).</body></methods><methods><class-id>WebServices.Wsdl11FaultInterceptorBuilder</class-id> <category>server methods</category><body package="WSDLTool">createServerInterceptor: aString in: serverNS super: superClass</body></methods><methods><class-id>WebServices.WsdlBuildOptions</class-id> <category>accessing</category><body package="WSDLTool">addSuperClassType	^addSuperClassType</body><body package="WSDLTool">addSuperClassType: aBoolean	addSuperClassType := aBoolean</body><body package="WSDLTool">attributeFormDefault	^attributeFormDefault</body><body package="WSDLTool">attributeFormDefault: aSymbol	attributeFormDefault := aSymbol.	x2oBuilder ifNotNil: [ x2oBuilder binding elementFormDefault: attributeFormDefault ].</body><body package="WSDLTool">bindingBuilderClass	^bindingBuilderClass ifNil: [BindingBuilder]</body><body package="WSDLTool">bindingBuilderClass: aClass	bindingBuilderClass := aClass</body><body package="WSDLTool">defaultClassNamespace	^defaultClassNamespace  ifNil: [ XMLObjectBindingPolicy defaultClassNamespace ]</body><body package="WSDLTool">defaultClassNamespace: aString	defaultClassNamespace := aString</body><body package="WSDLTool">elementFormDefault	^elementFormDefault</body><body package="WSDLTool">elementFormDefault: aSymbol	elementFormDefault := aSymbol.	x2oBuilder ifNotNil: [ x2oBuilder binding elementFormDefault: elementFormDefault ].</body><body package="WSDLTool">schemaTargetNamespace	^schemaTargetNamespace</body><body package="WSDLTool">schemaTargetNamespace: aString	schemaTargetNamespace := aString</body><body package="WSDLTool">serviceName	^serviceName</body><body package="WSDLTool">serviceName: aString	serviceName := aString</body><body package="WSDLTool">serviceProtocol	^serviceProtocol ifNil: [ self class defaultServiceProtocol]</body><body package="WSDLTool">serviceProtocol: aString	serviceProtocol := aString</body><body package="WSDLTool">soapVersionValue	^self class soapVersionValue</body><body package="WSDLTool">useServerSuperclass	^useServerSuperclass</body><body package="WSDLTool">useServerSuperclass: aBoolean	useServerSuperclass := aBoolean</body><body package="WSDLTool">x2oBuilder	^x2oBuilder</body><body package="WSDLTool">x2oBuilder: anXMLObjectBindingBuilder	x2oBuilder := anXMLObjectBindingBuilder</body></methods><methods><class-id>WebServices.WsdlBuildOptions</class-id> <category>testing</category><body package="WSDLTool">hasDefaultClassNamespace	^self defaultClassNamespace  = XMLObjectBindingPolicy defaultClassNamespace</body></methods><methods><class-id>WebServices.WsdlBuildOptions</class-id> <category>copying</category><body package="WSDLTool">postCopy	super postCopy.	self  x2oBuilder:  self x2oBuilder copy.</body></methods><methods><class-id>WebServices.WsdlBuildOptions</class-id> <category>initialize-release</category><body package="WSDLTool">initialize	serviceProtocol := self class defaultServiceProtocol.	useServerSuperclass := self class useServerSuperclass.	attributeFormDefault := self class attributeFormDefault.	elementFormDefault := self class elementFormDefault.</body><body package="WSDLTool">initializeX2OBuilder	self x2oBuilder: self bindingBuilderClass new.	self x2oBuilder addSuperClassType: self addSuperClassType.	self  x2oBuilder initializeBindingFor: self defaultClassNamespace targetNamespace: self schemaTargetNamespace.	self x2oBuilder binding elementFormDefault: self elementFormDefault.	self x2oBuilder binding attributeFormDefault: self attributeFormDefault.	^self x2oBuilder</body></methods><methods><class-id>WebServices.WsdlBuildOptions class</class-id> <category>default values</category><body package="WSDLTool">attributeFormDefaultValue	^#unqualified</body><body package="WSDLTool">defaultServiceProtocolValue	^'public api'</body><body package="WSDLTool">elementFormDefaultValue	^#unqualified</body><body package="WSDLTool">soapVersionValue	^#'1.1'</body><body package="WSDLTool">useServerSuperclassValue	^#true</body></methods><methods><class-id>WebServices.WsdlBuildOptions class</class-id> <category>defaults</category><body package="WSDLTool">attributeFormDefault	^attributeFormDefault ifNil: [ attributeFormDefault := self attributeFormDefaultValue ]</body><body package="WSDLTool">attributeFormDefault: aSymbol	attributeFormDefault := aSymbol</body><body package="WSDLTool">defaultServiceProtocol	^defaultServiceProtocol ifNil: [self defaultServiceProtocolValue ]</body><body package="WSDLTool">defaultServiceProtocol: aString	defaultServiceProtocol := aString</body><body package="WSDLTool">elementFormDefault	^elementFormDefault ifNil: [elementFormDefault := self elementFormDefaultValue ]</body><body package="WSDLTool">elementFormDefault: aSymbol	elementFormDefault := aSymbol</body><body package="WSDLTool">setUseServerSuperclass	^self useServerSuperclass  printString asSymbol</body><body package="WSDLTool">setUseServerSuperclass: aSymbol	aSymbol = #true		ifTrue: [ useServerSuperclass := true ]		ifFalse: [ useServerSuperclass := false ].	^useServerSuperclass</body><body package="WSDLTool">useServerSuperclass	useServerSuperclass isNil		ifTrue: [ self setUseServerSuperclass: self useServerSuperclassValue ].	^useServerSuperclass</body><body package="WSDLTool">useServerSuperclass: aBoolean	useServerSuperclass := aBoolean</body></methods><methods><class-id>WebServices.WsdlBuildOptions class</class-id> <category>instance creation</category><body package="WSDLTool">new	^super new initialize</body></methods><methods><class-id>WebServices.Wsdl11BuildOptions</class-id> <category>accessing</category><body package="WSDLTool">inputPartName	^inputPartName ifNil: [inputPartName := self class inputPartName ]</body><body package="WSDLTool">inputPartName: aString	inputPartName := aString</body><body package="WSDLTool">outputPartName	^outputPartName ifNil: [outputPartName := self class outputPartName]</body><body package="WSDLTool">outputPartName: aString	outputPartName := aString</body><body package="WSDLTool">soapStyle	^soapStyle</body><body package="WSDLTool">soapStyle: anObject	soapStyle := anObject</body><body package="WSDLTool">soapUse	^soapUse</body><body package="WSDLTool">soapUse: aSymbol	soapUse := aSymbol</body><body package="WSDLTool">useType	^soapUse</body><body package="WSDLTool">useType: aSymbol	soapUse := aSymbol</body></methods><methods><class-id>WebServices.Wsdl11BuildOptions</class-id> <category>initialize-release</category><body package="WSDLTool">initialize	super initialize.	soapStyle := self class soapStyle.	soapUse := self class soapUse.</body><body package="WSDLTool">setOptionsFromBinding: aWsdlBinding		self  soapStyle: aWsdlBinding operations first style asSymbol.	self  useType: aWsdlBinding operations first anyEncoding asSymbol</body></methods><methods><class-id>WebServices.Wsdl11BuildOptions class</class-id> <category>default values</category><body package="WSDLTool">soapStyleValue	^#document</body><body package="WSDLTool">soapUseValue	^#literal</body><body package="WSDLTool">soapVersionValue	^'1.1'</body></methods><methods><class-id>WebServices.Wsdl11BuildOptions class</class-id> <category>defaults</category><body package="WSDLTool">inputPartName	^inputPartName ifNil: [inputPartName := self inputPartNameValue ]</body><body package="WSDLTool">inputPartName: aString	inputPartName := aString</body><body package="WSDLTool">inputPartNameValue	^'parameter'</body><body package="WSDLTool">outputPartName	^outputPartName ifNil: [self outputPartNameValue ]</body><body package="WSDLTool">outputPartName: aString	outputPartName := aString</body><body package="WSDLTool">outputPartNameValue	^'return'</body><body package="WSDLTool">soapStyle	^soapStyle ifNil: [ self  soapStyleValue ]</body><body package="WSDLTool">soapStyle: aString	soapStyle := aString</body><body package="WSDLTool">soapUse	^soapUse ifNil: [ self  soapUseValue ]</body><body package="WSDLTool">soapUse: aSymbol	soapUse := aSymbol</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>testing</category><body package="WSDLTool">isDocumentStyle	^('document' match: self soapStyle)</body><body package="WSDLTool">isRpcStyle	^self isDocumentStyle not</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>private</category><body package="WSDLTool">bindingForService: aClass	^self descriptor bindings 		detect: [ :bx | bx name type = aClass name asString ] 		ifNone: [self error: ((#ThereIsNoServiceClassDefined &lt;&lt; #webservices &gt;&gt; 'There is no services class:&lt;1s&gt; defined in the configuration') expandMacrosWith: aClass fullName)].</body><body package="WSDLTool">saveIntoMethod: methName class: aClass comment: commentString do: aBlock 	WsdlClient 		saveIntoMethod: methName		class: aClass		comment: commentString		do: aBlock</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>accessing</category><body package="WSDLTool">asClassBuilder	^self asClassBuilderIn:  XMLObjectBindingPolicy defaultClassNamespace</body><body package="WSDLTool">asClassBuilderIn: aClassNamespace	| aClassBuilder |	self serviceClasses isEmpty ifTrue: [ ^nil].	(aClassBuilder := WsdlClassBuilder new)		initializeConfigFrom: descriptor;		classNamespace: aClassNamespace;		serviceNS: self serviceClasses first environment fullName.	#{Store.Registry} isDefined		ifTrue: [ 	aClassBuilder package: (Store.Registry packagesContaining: self serviceClasses first) first name].	^aClassBuilder</body><body package="WSDLTool">buildOptions			^self descriptor buildOptions</body><body package="WSDLTool">descriptor	^descriptor ifNil: [descriptor := self class defaultDescriptorClass new]</body><body package="WSDLTool">descriptor: aConfigurationDescriptor	descriptor := aConfigurationDescriptor</body><body package="WSDLTool">serviceClasses	^serviceClasses ifNil: [ serviceClasses := OrderedCollection new]</body><body package="WSDLTool">serviceClasses: aCollectionOfClasses	serviceClasses := aCollectionOfClasses</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>creating specification nodes</category><body package="WSDLTool">createBindingNode		^self descriptor bindingNodes</body><body package="WSDLTool">createDefinitionNode	^self descriptor asWsdl</body><body package="WSDLTool">createMessageNodes		^self descriptor messageNodes</body><body package="WSDLTool">createPortTypesNode		^self descriptor asWsdl portNodes</body><body package="WSDLTool">createServiceMapNode	| node ns |	ns := ServiceMap targetNamespace.	node := XML.Element tag: (NodeTag qualifier: 'vw' ns: ns type:  'serviceMaps').	node namespaces: Dictionary new.	node namespaces at: 'vw' put: ns.	self serviceMaps do: [ :map | node addNode: map asElement].	^node</body><body package="WSDLTool">createServiceNode		^self descriptor serviceNodes</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>printing</category><body package="WSDLTool">printServiceMapOn: aStream	self createServiceMapNode		wsPrintOn: aStream depth: 0</body><body package="WSDLTool">printSmalltalkBindingOn: aStream	self descriptor printX2OSpecificationOn: aStream</body><body package="WSDLTool">printSpecOn: aStream	self descriptor printSpecOn: aStream</body><body package="WSDLTool">printSpecWithSmalltalkBindingOn: aStream	self createSpecWithSmalltalkBinding wsPrintOn: aStream depth: 0</body><body package="WSDLTool">printX2OSpecificationOn: aStream	self descriptor printX2OSpecificationOn: aStream</body><body package="WSDLTool">printXMLSchemaSpecificationOn: aStream	self descriptor printXMLSchemaSpecificationOn: aStream</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>creating specification</category><body package="WSDLTool">createServiceImplementation: locationString	^self descriptor serviceNodes</body><body package="WSDLTool">createServiceInterface	^self descriptor serviceInterfaceNodes</body><body package="WSDLTool">createSpec		^self createDefinitionNode</body><body package="WSDLTool">createSpecWithSmalltalkBinding	^self createSpec		addNode: ( Element tag: (NodeTag qualifier: '' ns: '' type: 'schemaBindings' )					elements: ( OrderedCollection with: self x2oBuilder asX2OSpecification));		yourself</body><body package="WSDLTool">createX2OSpecification		^self x2oBuilder binding  asX2OSpecification</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>set port address</category><body package="WSDLTool">setPortAddress: addressString 	self serviceClasses isEmpty ifTrue: [ self error: #ThereIsNoServiceClass &lt;&lt;#webservices &gt;&gt; 'There is no service class'].	self setPortAddress: addressString for: self serviceClasses first</body><body package="WSDLTool">setPortAddress: addressString for: aClass	self descriptor setPortAddress: addressString for: aClass</body><body package="WSDLTool">setPortAddress: addressString forBindingNamed: aString	self descriptor setPortAddress: addressString forBindingNamed: aString</body><body package="WSDLTool">setPortAddress: addressString forBindingNamed: bindingName wsdlServiceNamed: aServiceName	self wsdlServiceName: aServiceName.	self descriptor setPortAddress: addressString forBindingNamed: bindingName</body><body package="WSDLTool">setPortDescription: aString for: aClass"The method sets WsdlPort&gt;&gt;documentation. The documentation will be added to the service &lt;port&gt; element in a WSDL schema   "	self descriptor services do: [ :service |		(service ports detect: [ :port | port binding  type = aClass name asString  ] ifNone: [nil]) 			ifNotNil: [ :port | port  documentation: aString ]]</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>properties</category><body package="WSDLTool">addSuperClassType: aBoolean		self buildOptions addSuperClassType: aBoolean</body><body package="WSDLTool">defaultClassNamespace	^self descriptor defaultClassNamespace</body><body package="WSDLTool">defaultClassNamespace: aString	self descriptor defaultClassNamespace: aString</body><body package="WSDLTool">protocol	^self buildOptions serviceProtocol</body><body package="WSDLTool">protocol: aSymbol	self buildOptions serviceProtocol: aSymbol</body><body package="WSDLTool">schemaTargetNamespace		^self descriptor schemaTargetNamespace</body><body package="WSDLTool">schemaTargetNamespace: aString		self descriptor schemaTargetNamespace: aString</body><body package="WSDLTool">soapStyle	^self buildOptions soapStyle</body><body package="WSDLTool">soapStyle: aString		self buildOptions soapStyle: aString</body><body package="WSDLTool">targetNamespace	^self descriptor targetNamespace</body><body package="WSDLTool">targetNamespace: nsString	self descriptor targetNamespace: nsString</body><body package="WSDLTool">wsdlServiceName	^self buildOptions serviceName</body><body package="WSDLTool">wsdlServiceName: aString	self buildOptions serviceName: aString</body><body package="WSDLTool">x2oBuilder	^self buildOptions x2oBuilder</body><body package="WSDLTool">x2oBuilder: anXMLObjectBindingBuilder	self buildOptions x2oBuilder: anXMLObjectBindingBuilder</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>initialization</category><body package="WSDLTool">build11				descriptor := Wsdl11ConfigurationDescriptor new</body><body package="WSDLTool">build20				descriptor := Wsdl20ConfigurationDescriptor new</body><body package="WSDLTool">buildFromResponder: aSOAPResponderClass 	self 		buildFromResponder: aSOAPResponderClass 		classNamespace: nil		targetNamespace: nil</body><body package="WSDLTool">buildFromResponder: aSOAPResponderClass classNamespace: clString 	self buildFromResponder: aSOAPResponderClass classNamespace: clString targetNamespace: nil</body><body package="WSDLTool">buildFromResponder: aSOAPResponderClass classNamespace: clString targetNamespace: tnsString	descriptor := (WsdlBinding initializeRegistriesFor: aSOAPResponderClass) descriptor.	serviceClasses := descriptor interfaces collect: [ :int | int serviceMap serviceClass ]</body><body package="WSDLTool">buildFromResponder: aSOAPResponderClass targetNamespace: tnsString	self 		buildFromResponder: aSOAPResponderClass 		classNamespace: nil		targetNamespace: tnsString</body><body package="WSDLTool">buildFromService: aServiceClass classNamespace: clString	self buildFromServices: (OrderedCollection with:  aServiceClass) classNamespace: clString targetNamespace: XMLObjectBinding defaultTargetNamespace</body><body package="WSDLTool">buildFromService: aServiceClass classNamespace: clString targetNamespace: tnsString	self wsdlServiceName ifNil: [ self wsdlServiceName: aServiceClass name asString ].	self 		buildFromServices: (OrderedCollection with: aServiceClass)		classNamespace: clString 		targetNamespace: tnsString</body><body package="WSDLTool">buildFromServices: aCollServiceClasses classNamespace: clString	self buildFromServices: aCollServiceClasses classNamespace: clString targetNamespace: XMLObjectBinding defaultTargetNamespace</body><body package="WSDLTool">buildFromServices: aCollOfServiceClasses classNamespace: clString targetNamespace: tnsString"Create the Wsdl spec from service class operations. Operation description are provided by pragmas ""The Wsdl spec is not going to include access point to the service "	serviceClasses := aCollOfServiceClasses.	self descriptor buildFromServices: aCollOfServiceClasses classNamespace: clString targetNamespace: tnsString</body><body package="WSDLTool">initializeDescriptorFor: nsString	descriptor := WsdlConfigurationDescriptor initializeFor: nsString.</body><body package="WSDLTool">useDocument	self descriptor useDocument</body><body package="WSDLTool">useRPC	self buildOptions soapStyle: #rpc</body></methods><methods><class-id>WebServices.WsdlBuilder</class-id> <category>service map</category><body package="WSDLTool">serviceMapFor: aClass		| coll |	coll := (WsdlBinding wsdlBindings values select: [ :each | each targetNamespace = descriptor targetNamespace])		select: [ :binding | binding serviceClass = aClass ].	^coll size = 1 ifTrue: [coll first] ifFalse: [coll]</body><body package="WSDLTool">serviceMaps	^(WsdlBinding wsdlBindings values select: [ :each | each targetNamespace = descriptor targetNamespace])		collect: [ :binding | binding serviceMap ]</body></methods><methods><class-id>WebServices.WsdlBuilder class</class-id> <category>private</category><body package="WSDLTool">saveIntoMethod: methName class: aClass comment: commentString do: aBlock 	XML.Document 		saveIntoMethod: methName		class: aClass		comment: commentString		do: aBlock</body></methods><methods><class-id>WebServices.WsdlBuilder class</class-id> <category>accessing</category><body package="WSDLTool">defaultDescriptorClass	^defaultDescriptorClass ifNil: [Wsdl11ConfigurationDescriptor]</body><body package="WSDLTool">defaultDescriptorClass: aClass	defaultDescriptorClass := aClass</body></methods><methods><class-id>WebServices.WsdlBuilder class</class-id> <category>instance creation</category><body package="WSDLTool">build11	^self new build11</body><body package="WSDLTool">build11FromServices: aCollOfServiceClasses classNamespace: clString targetNamespace: tnsString"Create the Wsdl spec from service class operations. Operation descriptions are provided by pragmas ""The Wsdl spec is not going to include access point to the service "	^self new		descriptor: Wsdl11ConfigurationDescriptor new;		buildFromServices: aCollOfServiceClasses 		classNamespace: clString 		targetNamespace: tnsString;		yourself</body><body package="WSDLTool">build20	^self new build20</body><body package="WSDLTool">build20FromServices: aCollOfServiceClasses classNamespace: clString targetNamespace: tnsString"Create the Wsdl 2.0 spec from service class operations. Operation descriptions are provided by pragmas ""The Wsdl spec is not going to include access point to the service "	^self new		descriptor: Wsdl20ConfigurationDescriptor new;		buildFromServices: aCollOfServiceClasses 		classNamespace: clString 		targetNamespace: tnsString;		yourself</body><body package="WSDLTool">buildFromResponder: aServerClass "Create the Wsdl spec from server class interface description. "	^self new		buildFromResponder: aServerClass;		yourself</body><body package="WSDLTool">buildFromService: aServiceClass "Create the Wsdl spec from service class operations. Operation descriptions are provided by pragmas "	^self 		buildFromServices: (OrderedCollection with: aServiceClass )		classNamespace: XMLObjectBindingPolicy defaultClassNamespace		targetNamespace: XMLObjectBinding defaultTargetNamespace</body><body package="WSDLTool">buildFromService: aServiceClass classNamespace: clString targetNamespace: tnsString"Create the Wsdl spec from service class operations. Operation descriptions are provided by pragmas ""The Wsdl spec is not going to include access point to the service "	^self new		buildFromServices: (OrderedCollection with: aServiceClass )		classNamespace: clString 		targetNamespace: tnsString;		yourself</body><body package="WSDLTool">buildFromServices: aCollOfServiceClasses"Create the Wsdl spec from service class operations. Operation descriptions are provided by pragmas "	^self 		buildFromServices: aCollOfServiceClasses 		classNamespace: XMLObjectBindingPolicy defaultClassNamespace		targetNamespace: XMLObjectBinding defaultTargetNamespace</body><body package="WSDLTool">buildFromServices: aCollOfServiceClasses classNamespace: clString targetNamespace: tnsString"Create the Wsdl spec from service class operations. Operation descriptions are provided by pragmas ""The Wsdl spec is not going to include access point to the service "	^self new		buildFromServices: aCollOfServiceClasses 		classNamespace: clString 		targetNamespace: tnsString;		yourself</body><body package="WSDLTool">initializeDescriptorFor: namespaceString	^self new		initializeDescriptorFor: namespaceString;		yourself</body></methods><methods><class-id>WebServices.ClientClassExistExc</class-id> <category>private</category><body package="WSDLTool">defaultMessageText	^(#ClientClassExistExc &lt;&lt; #webservices &gt;&gt; 'Error creating client class: &lt;1s&gt;. The class exists.' expandMacrosWith: self parameter) asString</body></methods><methods><class-id>WebServices.ClientClassExistExc</class-id> <category>constants</category><body package="WSDLTool">defaultResumeValue	"Answer the default value to resume with."	"We can not use the existing class let's create a new one"	| suffix nm |	suffix := 0.	nm := self parameter, '1'.	[nm asQualifiedReference isDefined]		whileTrue: 			[nm := nm, (suffix printStringRadix: 16).			suffix := suffix + 1].	^nm</body></methods><methods><class-id>WebServices.ClientClassExistExc class</class-id> <category>testing</category><body package="WSDLTool">mayResume	^true</body></methods><methods><class-id>WebServices.Wsdl20BuildOptions</class-id> <category>accessing</category><body package="WSDLTool">bindingType	^bindingType</body><body package="WSDLTool">bindingType: anObject	bindingType := anObject</body><body package="WSDLTool">httpVerb	^httpVerb</body><body package="WSDLTool">httpVerb: anObject	httpVerb := anObject</body><body package="WSDLTool">mep	^mep</body><body package="WSDLTool">mep: anObject	mep := anObject</body><body package="WSDLTool">soapMep	^soapMep</body><body package="WSDLTool">soapMep: anObject	soapMep := anObject</body><body package="WSDLTool">styleDefault	^styleDefault</body><body package="WSDLTool">styleDefault: anObject	styleDefault := anObject</body><body package="WSDLTool">styleDefaultTail	^self styleDefault asURI tail</body><body package="WSDLTool">transportProtocol	^transportProtocol</body><body package="WSDLTool">transportProtocol: aSymbol	transportProtocol := aSymbol</body></methods><methods><class-id>WebServices.Wsdl20BuildOptions</class-id> <category>initialize-release</category><body package="WSDLTool">initialize	super initialize.	bindingType := self class bindingType.	httpVerb := self class httpVerb.	mep := self class mep. 	soapMep := self class soapMep. 	transportProtocol := self class transportProtocol.	styleDefault := self class styleDefault</body><body package="WSDLTool">setOptionsFromBinding: aWsdlBinding</body></methods><methods><class-id>WebServices.Wsdl20BuildOptions class</class-id> <category>defaults</category><body package="WSDLTool">bindingType	^bindingType  ifNil: [ self bindingTypeValue]</body><body package="WSDLTool">bindingType: anObject	bindingType := anObject</body><body package="WSDLTool">httpVerb	^httpVerb ifNil: [self httpVerbValue]</body><body package="WSDLTool">httpVerb: anObject	httpVerb := anObject</body><body package="WSDLTool">mep	^mep</body><body package="WSDLTool">mep: anObject	mep := anObject</body><body package="WSDLTool">soapMep	^soapMep ifNil: [ self soapMepValue ]</body><body package="WSDLTool">soapMep: aString	soapMep := aString</body><body package="WSDLTool">soapMep_SoapResponse"When HTTP is used as the underlying transport protocol  the wsoap:mep attribute also controls whether GET or POST will be used as the underlying HTTP method. In this case, the use of wsoap:mep='http://www.w3.org/2003/05/soap/mep/soap-response' causes GET to be used by default. See http://www.w3.org/TR/wsdl20-primer/#adv-get-vs-post "	^'http://www.w3.org/2003/05/soap/mep/soap-response'</body><body package="WSDLTool">styleDefault	^styleDefault</body><body package="WSDLTool">styleDefault: aString	styleDefault := aString</body><body package="WSDLTool">supportedMEP	^#('request-response' 'one-way' )</body><body package="WSDLTool">transportProtocol	^transportProtocol ifNil: [ self transportProtocolValue ]</body><body package="WSDLTool">transportProtocol: aString		transportProtocol := aString</body></methods><methods><class-id>WebServices.Wsdl20BuildOptions class</class-id> <category>default values</category><body package="WSDLTool">bindingTypeValue" http://www.w3.org/TR/wsdl20-adjuncts/#soap12-binding "	^WsdlBinding wsdl20_soap_uri</body><body package="WSDLTool">httpVerbValue	^'POST'</body><body package="WSDLTool">rpcStyle" http://www.w3.org/TR/2007/REC-wsdl20-20070626/#InterfaceOperationStylehttp://www.w3.org/TR/2007/REC-wsdl20-adjuncts-20070626/#RPCStyle "	^WsdlBinding wsdl20_rpc_uri</body><body package="WSDLTool">soapMepValue" http://www.w3.org/TR/2007/REC-soap12-part2-20070427/#singlereqrespmep "	^WsdlBinding wsdl20_soap_mepDefault</body><body package="WSDLTool">soapVersionValue	^'1.2'</body><body package="WSDLTool">transportProtocolValue" http://www.w3.org/TR/wsdl20-adjuncts/#soap-protocol "	^WsdlBinding wsdl20_soap_http</body></methods><methods><class-id>WebServices.WsdlClassBuildOptions</class-id> <category>accessing</category><body package="WSDLTool">classNamespace	classNamespace isNil		ifTrue: [ classNamespace := XMLObjectBindingPolicy defaultClassNamespace].	^classNamespace</body><body package="WSDLTool">classNamespace: anObject	classNamespace := anObject</body><body package="WSDLTool">clientClassMap	^clientClassMap ifNil: [clientClassMap := Dictionary new]</body><body package="WSDLTool">clientClassMap: aDictionary	clientClassMap := aDictionary</body><body package="WSDLTool">clientMessageInterceptorClass	^clientMessageInterceptorClass ifNil: [ clientMessageInterceptorClass := self clientMessageInterceptorClassDefault ]</body><body package="WSDLTool">clientMessageInterceptorClass: aClass	clientMessageInterceptorClass := aClass</body><body package="WSDLTool">clientMessageInterceptorClassDefault	^ClientMessageInterceptor</body><body package="WSDLTool">clientNS	^clientNS isNil		ifTrue: [ self classNamespace]		ifFalse: [ clientNS ]</body><body package="WSDLTool">clientNS: aString	clientNS := aString</body><body package="WSDLTool">clientPackage	^clientPackage isNil		ifTrue: [ self package ]		ifFalse: [ clientPackage ]</body><body package="WSDLTool">clientPackage: aString	clientPackage := aString</body><body package="WSDLTool">clientProcessingPolicyClass	^clientProcessingPolicyClass ifNil: [ clientProcessingPolicyClass := self clientProcessingPolicyClassDefault ]</body><body package="WSDLTool">clientProcessingPolicyClass: aClass	^clientProcessingPolicyClass := aClass</body><body package="WSDLTool">clientProcessingPolicyClassDefault	^ClientProcessingPolicy</body><body package="WSDLTool">defaultResponderClass	^SOAPResponder</body><body package="WSDLTool">responderMessageInterceptorClass	^responderMessageInterceptorClass ifNil: [ responderMessageInterceptorClass := self responderMessageInterceptorClassDefault ]</body><body package="WSDLTool">responderMessageInterceptorClass: aClass	responderMessageInterceptorClass := aClass</body><body package="WSDLTool">responderMessageInterceptorClassDefault	^SOAPMessageInterceptor</body><body package="WSDLTool">responderNS	^responderNS isNil		ifTrue: [ self classNamespace]		ifFalse: [ responderNS ]</body><body package="WSDLTool">responderNS: aString	responderNS := aString</body><body package="WSDLTool">responderName	^responderName ifNil: [ 'WSResponder' ]</body><body package="WSDLTool">responderName: aString	responderName := aString</body><body package="WSDLTool">responderPackage	^responderPackage isNil		ifTrue: [ self package ]		ifFalse: [ responderPackage]</body><body package="WSDLTool">responderPackage: aString	responderPackage := aString</body><body package="WSDLTool">responderSuperclass	^responderSuperclass ifNil: [ self defaultResponderClass ]</body><body package="WSDLTool">responderSuperclass: anObject	responderSuperclass := anObject</body><body package="WSDLTool">serviceClassMap	^serviceClassMap ifNil: [serviceClassMap := Dictionary new]</body><body package="WSDLTool">serviceClassMap: aDictionary	serviceClassMap := aDictionary</body><body package="WSDLTool">serviceNS	^serviceNS isNil		ifTrue: [ self classNamespace]		ifFalse: [ serviceNS ]</body><body package="WSDLTool">serviceNS: aString	serviceNS := aString</body><body package="WSDLTool">servicePackage	^servicePackage isNil		ifTrue: [ self package ]		ifFalse: [ servicePackage ]</body><body package="WSDLTool">servicePackage: aString	servicePackage := aString</body><body package="WSDLTool">serviceProtocol	^serviceProtocol ifNil: [ WsdlBuildOptions defaultServiceProtocol ]</body><body package="WSDLTool">serviceProtocol: anObject	serviceProtocol := anObject</body><body package="WSDLTool">useExistingClassName	^useExistingClassName ifNil: [ useExistingClassName := self class useExistingClassName ]</body><body package="WSDLTool">useExistingClassName: aBoolean	useExistingClassName := aBoolean</body></methods><methods><class-id>WebServices.WsdlClassBuildOptions class</class-id> <category>default values</category><body package="WSDLTool">defaultPackageValue	^'WSServicePackage'</body><body package="WSDLTool">useExistingClassNameValue	^false</body></methods><methods><class-id>WebServices.WsdlClassBuildOptions class</class-id> <category>defaults</category><body package="WSDLTool">setUseExistingClassName	^self useExistingClassName  printString asSymbol</body><body package="WSDLTool">setUseExistingClassName: aSymbol	self useExistingClassName: (aSymbol = #true )</body><body package="WSDLTool">setUseExistingClassNameValue	^self useExistingClassNameValue printString asSymbol</body><body package="WSDLTool">useExistingClassName	^useExistingClassName ifNil: [ useExistingClassName := self useExistingClassNameValue]</body><body package="WSDLTool">useExistingClassName: aBoolean	useExistingClassName := aBoolean</body></methods><methods><class-id>WebServices.ClientClassNoPortExc</class-id> <category>private</category><body package="WSDLTool">defaultMessageText	^(#ErrorCreatingClientClassNoServiceComponent &lt;&lt; #webservices &gt;&gt; 'Error creating client class. The wsdl schema doesn''t have &lt;service&gt; component.' ) asString</body></methods><methods><class-id>WebServices.ClientClassNoPortExc class</class-id> <category>testing</category><body package="WSDLTool">mayResume	^true</body></methods><methods><class-id>WebServices.OperationParameters</class-id> <category>accessing</category><body package="WSDLTool">addParameterNamed: aString collectionType: aClass	parameters add: ( Array with: aString with:  (Array with: #Collection with: aClass fullName))</body><body package="WSDLTool">addParameterNamed: aString type: aClass	parameters add: (Array with: aString with: aClass fullName )</body><body package="WSDLTool">addReturnCollectionType: aClass	parameters add:  (Array with: #Collection with: aClass fullName)</body><body package="WSDLTool">addReturnType: aClass	parameters add:  aClass fullName</body><body package="WSDLTool">parameters	^parameters</body></methods><methods><class-id>WebServices.OperationParameters</class-id> <category>initialize-release</category><body package="WSDLTool">initialize	parameters := OrderedCollection new.</body></methods><methods><class-id>WebServices.OperationParameters class</class-id> <category>instance creation</category><body package="WSDLTool">new 	^super new initialize</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>creating interceptors</category><body package="WSDLTool">collectSoapHeaderDescriptionIn: aDictionary	| builder |	super collectSoapHeaderDescriptionIn: aDictionary.	self inputHeaderBindings do: [ :headerBinding | 		headerBinding faults notNil ifTrue: [ 			headerBinding faults do: [ :fault |				builder := aDictionary 							at: fault partMarshaler path 							ifAbsentPut: [ fault asInterceptorPrinterType: #out ].				builder operations add: (self name type -&gt;#out) ]]]</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>accessing</category><body package="WSDLTool">exceptionClasses	| coll |	coll := OrderedCollection new.	self  faultMarshalers 		do: [ :fm | 			fm partMarshalers do: [ :pm | coll add: pm typeMarshaler smalltalkClass ]].	self inputHeaderBindings notNil		ifTrue: [self inputHeaderBindings do: [ :hm | coll addAll: hm excMarshalerClasses ]].	self outputHeaderBindings notNil		ifTrue: [self outputHeaderBindings do: [ :hm | coll addAll: hm excMarshalerClasses ]].	^coll</body></methods><methods><class-id>WebServices.SoapWsdl11OperationBinding</class-id> <category>tool</category><body package="WSDLTool">returnObject	|   objMarshaler return |	(outputBodyMarshaler isNil or: [outputBodyMarshaler partMarshalers isEmpty ]) ifTrue: [^nil ].	outputBodyMarshaler partMarshalers do: [ :marshaler |		objMarshaler :=  marshaler typeMarshaler. 		( descriptor interfaceDescriptor parameterOrder includes: objMarshaler name type )			ifFalse: 	[objMarshaler :=  (self isRpc  or: [objMarshaler isSimpleType or: [objMarshaler isObjectType]])						ifTrue: [objMarshaler]						ifFalse:	[objMarshaler relations notEmpty ifTrue: [objMarshaler relations first typeMarshaler.]].					return := self setReturnObject: objMarshaler ]].	^return</body><body package="WSDLTool">usePart1InSelector	^self class usePart1InSelector</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>creating interceptors</category><body package="WSDLTool">collectHeadersFrom: headerBindings in: aDictionary  type: aSymbol do: aBlock	| str |	headerBindings ifNil: [^nil].	headerBindings do: [ :headerBinding | 		(aDictionary at: headerBinding partMarshaler path ifAbsent: [nil]) 			ifNotNil: [ :struct | 				struct type ~= aSymbol ifTrue: [ struct type: #inout].				aBlock value: struct ]			ifNil: [ 				aDictionary 					at: headerBinding partMarshaler path					put: (str := Struct new 							type: aSymbol; 							binding: headerBinding;							marshaler: headerBinding partMarshaler;							yourself).				aBlock value: str ]].</body><body package="WSDLTool">collectSoapHeaderDescriptionIn: aDictionary	self collectSoapOperationHeaders: self  inputHeaderBindings  in: aDictionary type: #in.	self collectSoapOperationHeaders: self  outputHeaderBindings  in: aDictionary type: #out.</body><body package="WSDLTool">collectSoapOperationHeaders: headerBindings in: aDictionary type: aSymbol	| builder |	headerBindings ifNil: [^nil].	headerBindings do: [ :headerBinding | 		builder := aDictionary at: headerBinding partMarshaler path ifAbsent: [nil].		builder 			ifNil: [ aDictionary at: headerBinding partMarshaler path put: (builder := headerBinding asInterceptorPrinterType: aSymbol)]			ifNotNil: [ builder type ~= aSymbol ifTrue: [ builder type: 'inout']].		builder operations add: (self name type -&gt;aSymbol) ].</body></methods><methods><class-id>WebServices.SoapOperationBinding</class-id> <category>tool</category><body package="WSDLTool">newParam: aString dict: aDictionary	| ind |	ind := aDictionary at: aString ifAbsent: [ -1 ].	aDictionary at: aString put: (ind := ind + 1).	^ind = 0		ifTrue: [ aString ]		ifFalse: [ aString, ind printString ]</body><body package="WSDLTool">printClientDocMethodOn: aStream	| aDict p marshaler argMarshalers |	argMarshalers := self argumentMarshalers. 	argMarshalers isEmpty ifTrue: [ ^aStream crtab; nextPutAll:  'args := Array new.' ].	argMarshalers size &gt; 1 		ifTrue: [aStream crtab; nextPutAll:  'args := Array with: (', Struct fullName, ' new '.				aDict := Dictionary new.				1 to: argMarshalers size do: [ :ind |  					marshaler := argMarshalers at: ind.					p := self newParam: marshaler selectorType dict: aDict. 					aStream cr;tab: 3; nextPutAll: marshaler tag type, ': ', p, ';' ].					aStream cr;tab:3; nextPutAll: 'yourself).'. ]		ifFalse: 	[aStream crtab; nextPutAll: 'args := Array with: ', argMarshalers first selectorType, '.']</body><body package="WSDLTool">printClientMethodOn: aStream	aStream crtab; nextPutAll: '| args |'.	self isRpc		ifTrue: [self printClientRpcMethodOn: aStream ]		ifFalse:[self printClientDocMethodOn: aStream ].	aStream		crtab; 		nextPutAll: '^self executeSelector: #', self name type printString , ' args: args.'.</body><body package="WSDLTool">printClientRpcMethodOn: aStream	| aDict parameter marshalers |	aDict := Dictionary new.	marshalers := self argumentMarshalers.	marshalers isEmpty ifTrue: [ ^aStream crtab; nextPutAll:  'args := Array new.'  ].	aStream crtab; nextPutAll:  'args := Array new: ', marshalers size  printString, '.'.	1 to: marshalers size do: [ :ind |  		parameter := self newParam: (marshalers at: ind) selectorType dict: aDict.		aStream crtab; nextPutAll: 'args at: ', ind printString, ' put: ', parameter, '.' ]</body><body package="WSDLTool">printMethodSelector	| aDict sel selTokens parameter aStream argMarshalers |	aStream := String new writeStream.	selTokens := self selector tokensBasedOn: $:.	argMarshalers := self argumentMarshalers. 	argMarshalers isEmpty ifTrue: [aStream nextPutAll:  selTokens first asString. ^aStream contents ].	aDict := Dictionary new.	1 to: argMarshalers size do: [ :ind |  		sel := selTokens at: ind. 		parameter := self newParam: ( argMarshalers at: ind) selectorType dict: aDict.		aStream nextPutAll: sel;				nextPutAll: ': ', parameter, ' '].	^aStream contents</body><body package="WSDLTool">printProxyMethodOn: aStream	aStream crtab; nextPutAll:  '^proxy '.	aStream nextPutAll: self printMethodSelector</body><body package="WSDLTool">returnObject	^self subclassResponsibility</body></methods><methods><class-id>WebServices.Wsdl11InterfaceOperationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">removeOperationMarshalersDo: aBlock	self input ifNotNil: [ :inputx | inputx  message parts do: [ :part | aBlock value: part elementName]].	self output ifNotNil: [ :outputx | outputx  message parts do: [ :part | aBlock value: part elementName]].</body></methods><methods><class-id>WebServices.Wsdl11InterfaceOperationDescriptor</class-id> <category>tool</category><body package="WSDLTool">validateAndFixMessageMarshalers: aOperationParameterDescriptor builder: aBindingBuilder	(aOperationParameterDescriptor notNil and: [ aOperationParameterDescriptor message parts size &gt; 0 ]) ifTrue: 		[ aOperationParameterDescriptor message parts do: [ :part | 			part elementName ifNotNil: [ :tag | 				aBindingBuilder binding elementMarshalerForTag: tag ifAbsent: [					(aBindingBuilder binding typeMarshalerForTag: tag ifAbsent: [nil]) ifNotNil: 						[ :typeMarshaler |  | attributes |						attributes := aBindingBuilder nameAttribute: tag type.						attributes add: (Attribute name: 'ref' value: (aBindingBuilder tagReference: typeMarshaler path)).						aBindingBuilder createBindingFor: 'element' attributes: attributes   ]]]]].</body><body package="WSDLTool">validateAndFixOperationMarshalers: aBindingBuilder	self validateAndFixMessageMarshalers: input builder: aBindingBuilder.	self validateAndFixMessageMarshalers: output builder: aBindingBuilder.</body></methods><methods><class-id>WebServices.Wsdl11MessagePartDescriptor</class-id> <category>accessing</category><body package="WSDLTool">marshalerName	^self elementName notNil		ifTrue: [self elementName ]		ifFalse: [ self typeName ].</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor class</class-id> <category>accessing</category><body package="WSDLTool">buildOptions	^Wsdl20BuildOptions</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">addFaultBindingFor: interfaceFault toBinding: bindingDescriptor	| fault |	fault := self defaultFaultBindingFor:  (interfaceFault at: #name) type.	bindingDescriptor faults add: fault. 	^fault</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">addFaultNamed: faultName type: aClassOrString  toOperation: interfaceOperation	self addOutfaultNamed: faultName toOperation: interfaceOperation</body><body package="WSDLTool">addInfaultNamed: faultName toOperation: interfaceOperationDescriptor 	interfaceOperationDescriptor faults add: (WebServices.Struct new											at: #name put: (NodeTag qualifier: '' ns: self targetNamespace type: faultName asString);											yourself )</body><body package="WSDLTool">addOutfaultNamed: faultName toOperation: interfaceOperationDescriptor 	interfaceOperationDescriptor outfaults add: (WebServices.Struct new												at: #name put: (NodeTag qualifier: '' ns: self targetNamespace type: faultName asString);												yourself )</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">addServiceForInterface: interfaceDescriptor"The address will be used to set soap:address  &lt;service name='reservationService' interface='tns:reservationInterface'&gt;     &lt;endpoint name='reservationEndpoint'               binding='tns:reservationSOAPBinding'               address ='http://localhost:6688/reservation'/&gt;  &lt;/service&gt;"	^self addServiceNamed: self buildOptions serviceName  interface: interfaceDescriptor</body><body package="WSDLTool">addServiceNamed: aString interface: interfaceDescriptor"The address will be used to set soap:address  &lt;service name='reservationService' interface='tns:reservationInterface'&gt;     &lt;endpoint name='reservationEndpoint'               binding='tns:reservationSOAPBinding'               address ='http://localhost:6688/reservation'/&gt;  &lt;/service&gt;"	| service |	^self  services		detect: [ :servicex | servicex name type = aString and: [ servicex interface = interfaceDescriptor name ]] 		ifNone: [ self services add: (service := Wsdl20ServiceDescriptor new 										name: (NodeTag qualifier: '' ns: self targetNamespace type: aString); 										interface: interfaceDescriptor name;										ports: OrderedCollection new;										yourself).				service ]</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">addSoapFaultNamed: aString toBinding: aBinding		| fault |	aBinding interfaceDescriptor faults 		detect: [ :faultx | (faultx at: #name) type = aString ] 		ifNone: [ ^self error: ((#ThereIsNoInterafecFaultNamed1s &lt;&lt; #webservices &gt;&gt;'There is no interface fault named: &lt;1s&gt; ' ) expandMacrosWith: aString)].	(aBinding faults detect: [ :faultx | faultx name type = aString ] 	ifNone: [ nil])		ifNotNil: [ :faultx | aBinding faults remove: faultx ].	fault := self soapFaultNamed: aString.	aBinding faults add: fault.	^fault</body><body package="WSDLTool">bindingDescriptor	^Wsdl20BindingDescriptor new		type: self buildOptions bindingType;		protocol: self buildOptions transportProtocol;		soapVersion: self buildOptions soapVersionValue;		soapMep:  self buildOptions  soapMep;		yourself</body><body package="WSDLTool">buildOperationBindingDescriptorFor: interfaceOperation	| bindingOperation |	(bindingOperation := Wsdl20OperationBindingDescriptor new)		name: interfaceOperation name;		input: OrderedCollection new;		output: OrderedCollection new;		soapMep:   self buildOptions  soapMep;		soapAction: (self soapActionFor: bindingOperation).	bindingOperation infaults: (interfaceOperation infaults collect: [ :infault | 		WebServices.Struct new			at: #name put: (infault at: #name);			yourself ]).	bindingOperation outfaults: (interfaceOperation outfaults collect: [ :outfault |		WebServices.Struct new			at: #name put: (outfault at: #name);			yourself   ]).	^bindingOperation</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">createEndpointNamed: aString address: urlOrString binding: bindingDescriptor	| url |	[url := urlOrString asURI] 			on:Error 			do: [self error: ((#WrongURL &lt;&lt; #webservices &gt;&gt; 'Wrong url:&lt;1s&gt;') expandMacrosWith: urlOrString)].	^WsdlEndpointDescriptor new  				name: (NodeTag qualifier: '' ns: self  targetNamespace type: aString); 				binding: bindingDescriptor name; 				address:  url asString; 				yourself</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">createSoapHeaderNamed: headerName type: aClassOrString	| structMarshaler  header |	header := Wsdl20SoapHeaderDescriptor new.	header		mustUnderstand: true;		required: true.	structMarshaler :=self x2oBuilder addElementMarshalerName: headerName asString refClass: (self classFrom: aClassOrString).	header element: structMarshaler name.	^header</body><body package="WSDLTool">createSoapInfaultNamed: aString		^WebServices.Struct new		at: #name put:  (NodeTag  qualifier: '' ns: self targetNamespace type: aString);		yourself</body><body package="WSDLTool">createSoapOutfaultNamed: aString		^WebServices.Struct new		at: #name put:  (NodeTag  qualifier: '' ns: self targetNamespace type: aString);		yourself</body><body package="WSDLTool">defaultFaultBindingFor: aString	| fault |	fault := self soapFaultNamed: aString.	fault		soapFaultCode: '#any';		soapFaultSubcode: (OrderedCollection with: '#any');		targetNamespace:  self targetNamespace.	^fault</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">interfaceOperationDescriptor	^Wsdl20InterfaceOperationDescriptor new		infaults: OrderedCollection new;		outfaults: OrderedCollection new;		input: OrderedCollection new;		output: OrderedCollection new;		pattern: self buildOptions mep;		style:  self buildOptions styleDefault;		yourself</body><body package="WSDLTool">removeFaultNamed: faultName fromOperation: interfaceOperation fromInterface: interfaceDescriptor	self removeFaultNamed: faultName fromOperation: interfaceOperation.</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">setExceptions: faultParameters interfaceOperation: interfaceOperation 	faultParameters do: [ :faultParameter |		self addFaultNamed: faultParameter first type: faultParameter last toInterface: self interfaces last.		 self addOutfaultNamed: faultParameter first toOperation: interfaceOperation.]</body><body package="WSDLTool">setInputParameters: parameters interfaceOperation: interfaceOperation	| input |	input := WebServices.Struct new.	input messageLabel: 'In'.	input element: (parameters notEmpty 		ifTrue: [ (self addOperationMarshalerName: interfaceOperation name type  type: parameters) name]		ifFalse: ['#none']).	interfaceOperation input: (OrderedCollection with: input).</body><body package="WSDLTool">setOutputParameter: anArray interfaceOperation: interfaceOperation	| output messageType |	interfaceOperation isOneWay ifTrue: [ ^nil].	output := Struct new.	output messageLabel: 'Out'.	messageType := anArray notEmpty 		ifTrue: [	(self 					addOperationMarshalerName: interfaceOperation name type, 'Response'  					type: (Array with: (Array with: 'result' with: anArray first))) name]		ifFalse: [ '#none' ].	output element: messageType.	interfaceOperation output:  (OrderedCollection with: output).</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">setPortAddress: addressString for: aServiceClass	| service nm |	self interfaces do: [ :int | 		int serviceClass = aServiceClass			ifTrue: [nm := self buildOptions serviceName ifNil: [aServiceClass name asString].				service := self addServiceNamed: nm interface: int.				(self bindings detect: [ :binding | binding interfaceDescriptor = int  ] ifNone: [nil] ) ifNotNil: [ :binding |					service ports add: (self createEndpointNamed: aServiceClass name address: addressString binding: binding) ]]].</body><body package="WSDLTool">setPortAddress: addressString forBindingNamed: aString		self error: (#ForWSDL20UseSetPortFor &lt;&lt;#webservices &gt;&gt; 'For WSDL 2.0 use #setPortAddress:for: method instead ')</body></methods><methods><class-id>WebServices.Wsdl20ConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">soapFaultNamed: aString 	^Wsdl20SoapFaultDescriptor new 		name:  (NodeTag  qualifier: '' ns: self targetNamespace type: aString);		targetNamespace: self targetNamespace;		yourself.</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>creating interceptors</category><body package="WSDLTool">collectSoapFaultHeaders: faultBindings in: aDictionary type: aSymbol		| builder |	(faultBindings isNil or: [faultBindings isEmpty]) ifTrue: [^nil].	faultBindings do: [ :faultBinding |		builder := aDictionary 				at: faultBinding partMarshaler path 				ifAbsentPut: [ faultBinding asInterceptorPrinterType: aSymbol ].		builder operations add: (self name type -&gt;aSymbol) ]</body><body package="WSDLTool">collectSoapHeaderDescriptionIn: aDictionary		super collectSoapHeaderDescriptionIn: aDictionary.	self collectSoapFaultHeaders: self inputFaultMarshalers in: aDictionary type: #in.	self collectSoapFaultHeaders: self outputFaultMarshalers in: aDictionary type: #out.</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>accessing</category><body package="WSDLTool">exceptionClasses	| coll |	coll := OrderedCollection new.	(self  inputFaultMarshalers, self  outputFaultMarshalers )		do: [ :fm | fm partMarshalers do: [ :pm | pm typeMarshaler isObjectType ifTrue: [ coll add: pm typeMarshaler smalltalkClass] ]].	^coll</body></methods><methods><class-id>WebServices.SoapWsdl20OperationBinding</class-id> <category>tool</category><body package="WSDLTool">returnObject	outputBodyMarshaler partMarshalers isEmpty ifTrue: [^nil ].	^self setReturnObject: outputBodyMarshaler partMarshaler typeMarshaler</body></methods><methods><class-id>WebServices.MessageBinding</class-id> <category>accessing</category><body package="WSDLTool">asInterceptorPrinterType: aSymbol	^(self interceptorBuilder type: aSymbol) from: self</body><body package="WSDLTool">interceptorBuilder	^WsdlInterceptorBuilder</body></methods><methods><class-id>WebServices.Wsdl20SoapFaultDescriptor</class-id> <category>testing</category><body package="WSDLTool">hasReferenceTo:  aMarshaler	^self soapHeaders anySatisfy: [ :h | h element = aMarshaler path ]</body></methods><methods><class-id>WebServices.SoapWsdl20FaultBinding</class-id> <category>accessing</category><body package="WSDLTool">interceptorBuilder	^Wsdl20FaultInterceptorBuilder</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderBinding</class-id> <category>accessing</category><body package="WSDLTool">interceptorBuilder	^Wsdl11InterceptorBuilder</body></methods><methods><class-id>WebServices.Wsdl20InterfaceOperationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">removeOperationMarshalersDo: aBlock	self input do: [ :inputx | inputx element = '#none'  ifFalse: [ aBlock value: inputx element ]].	self output do: [ :outputx | outputx element = '#none' ifFalse: [ aBlock value: outputx element ]].</body></methods><methods><class-id>WebServices.SoapWsdl11HeaderFaultBinding</class-id> <category>accessing</category><body package="WSDLTool">interceptorBuilder	^Wsdl11FaultInterceptorBuilder</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">removeOperationMarshalersDo: aBlock</body></methods><methods><class-id>WebServices.WsdlInterfaceOperationDescriptor</class-id> <category>tool</category><body package="WSDLTool">validateAndFixOperationMarshalers: aBindingBuilder</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor class</class-id> <category>accessing</category><body package="WSDLTool">buildOptions	^Wsdl11BuildOptions</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">addFaultMessage: faultParameter interfaceOperation: interfaceOperation 	| faultTypeTag fault faultName |	faultName := faultParameter first asString.	faultName := faultName first asUppercase asSymbol, (faultName copyFrom: 2 to: faultName size ).	faultTypeTag := NodeTag qualifier: '' ns: self  targetNamespace type: ( faultName, 'Fault' ).	(fault := self operationParameterDescriptor)		name: (NodeTag qualifier: '' ns: self  targetNamespace type: faultParameter first asString );		type: faultTypeTag.	interfaceOperation faults add: fault.	self createMessageDescriptorFor: fault.	^fault</body><body package="WSDLTool">addFaultNamed: faultName type: aClassOrString toOperation: interfaceOperationDescriptor "http://www.ws-i.org/Profiles/BasicProfile-1.1-2006-04-10.html4.4.2 Bindings and FaultsThere are several interpretations for how wsdl:part elements that describe soapbind:fault, soapbind:header, and soapbind:headerfault may be defined.R2205 A wsdl:binding in a DESCRIPTION MUST refer, in each of its soapbind:header, soapbind:headerfault and soapbind:fault elements, only to wsdl:part element(s) that have been defined using the element attribute.Because faults and headers do not contain parameters, soapbind:fault, soapbind:header and soapbind:headerfault assume, per WSDL 1.1, that the value of the style attribute is 'document'. R2204 requires that all wsdl:part elements with a style attribute whose value is 'document' that are bound to soapbind:body be defined using the element attribute. This requirement does the same for soapbind:fault, soapbind:header and soapbind:headerfault elements." 	| fault part path faultType faultClass |	faultClass :=  self classFrom: aClassOrString.	faultType := faultClass fullName.	fault := self addFaultMessage: (Array with: faultName with: faultType) interfaceOperation: interfaceOperationDescriptor.	fault message parts add: (part := Wsdl11MessagePartDescriptor new 											name: ( NodeTag qualifier: '' ns: self targetNamespace type:  faultName );											yourself).	path := (self x2oBuilder 				addMarshalerForElement: (self x2oBuilder nameAttribute: faultName) 				type: faultType ) path.	part elementName: path.</body><body package="WSDLTool">addInputParameterNamed: paramName type:  aClass  toOperation: interfaceOperation	^self setInputParameters: (Array with: (Array with: paramName with: aClass fullName)) interfaceOperation: interfaceOperation</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">addServiceNamed: aString "The address will be used to set soap:address&lt;service name=''WsdlServiceName''&gt;		&lt;port name=''InteropTestClass'' binding=''tns:InteropTestClass''&gt;			&lt;soap:address location=''http://www.cincomsmalltalk.com/r2groupb/interop''/&gt;		&lt;/port&gt;&lt;/service&gt;"	| service |	^self services 		detect: [ :servicex | servicex name type = aString ] 		ifNone: [self  services add: (service := Wsdl11ServiceDescriptor new 										name: (NodeTag qualifier: '' ns: self targetNamespace type: aString); 										ports: OrderedCollection new;										yourself).				service]</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">bindingDescriptor	| binding |	binding := Wsdl11BindingDescriptor new.	binding  soapHttpBindingSpec: (SoapWsdl11HttpBinding new verb: 'POST'; yourself).	binding bindingType: (Struct new							name: (NodeTag qualifier: '' ns: '' type: 'binding11Type');							transportName: WsdlBinding wsdl11_soap_http_uri;							style: self buildOptions soapStyle;							yourself).	^binding</body><body package="WSDLTool">buildOperationBindingDescriptorFor: interfaceOperation	| bindingOperation ns |	bindingOperation := self  operationBindingDescriptor.	bindingOperation name: interfaceOperation name.	(self buildOptions soapUse asSymbol = #literal and: [self buildOptions soapStyle asSymbol = #rpc])		ifTrue: [ns := self targetNamespace].	bindingOperation input: (Wsdl11SoapOperationEnvelopeDescriptor new 			soapBody: (WebServices.Wsdl11SoapBodyPartDescriptor new						use: self buildOptions soapUse;						namespace: ns;						yourself )).	interfaceOperation output ifNotNil: [		bindingOperation output: (Wsdl11SoapOperationEnvelopeDescriptor new 			soapBody: (WebServices.Wsdl11SoapBodyPartDescriptor new						use: self buildOptions soapUse;						namespace: ns;						yourself ))].	bindingOperation soapOperationDescriptor: (Struct new			name: ( NodeTag qualifier: '' ns: '' type: 'operation11Type' );			soapAction: (self soapActionFor: bindingOperation);			style:self buildOptions soapStyle;			yourself).	interfaceOperation faults do: [ :fault | 		bindingOperation faults add: (Wsdl11SoapOperationFaultDescriptor new									setVersion11;									name: fault key type;									fault: (Wsdl11MessageEncodingDescriptor new											name: fault key type;											use: self buildOptions useType;											yourself );									yourself)].	^bindingOperation</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLTool">completeDescription"The interface operations can be changed and we need to update operation messages  "	| messagesx |	messagesx :=  Struct new.	self interfaces do: [ :interface |		interface operations do: [ :operation |			operation input ifNotNil: [messagesx at: operation input message name put: operation input message].			operation output ifNotNil: [messagesx at: operation output message name put: operation output message].			operation faults do: [ :fault | messagesx at: fault name put: fault message  ]]].	self bindings do: [ :binding |		binding operations do: [ :operation |			operation collectHeaderMessages do: [ :mess | messagesx at: mess key put: mess value ]]].		messages := messagesx values.</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">createEndpointNamed: aString address: urlString binding: interfaceBinding "The address will be used to set soap:address	&lt;port name=''InteropTestClass'' binding=''tns:InteropTestClass''&gt;		&lt;soap:address location=''http://www.cincomsmalltalk.com/r2groupb/interop''/&gt;&lt;/service&gt;"	| url |	[url := urlString asURI] 			on:Error 			do: [self error: ((#WrongURL &lt;&lt; #webservices &gt;&gt; 'Wrong url:&lt;1s&gt;') expandMacrosWith: urlString)].	^Wsdl11PortDescriptor new  		name: (NodeTag qualifier: '' ns: self  targetNamespace type: aString); 		binding: interfaceBinding name; 		address: (ValueHolder with: url asString); 		yourself</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">createMessageDescriptorFor: parameterDescriptor	parameterDescriptor message: (Wsdl11MessageDescriptor new 							name: parameterDescriptor type; 							parts: OrderedCollection new; 							yourself ).</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">createSoapHeaderFaultNamed: headerFaultName type: aClassOrString	^self createSoapMessageDescriptorFor: Wsdl11SoapHeaderFaultDescriptor named: headerFaultName type: aClassOrString</body><body package="WSDLTool">createSoapHeaderNamed: headerName type: aClassOrString	^(self createSoapMessageDescriptorFor: Wsdl11SoapHeaderDescriptor named: headerName type: aClassOrString)		use: self buildOptions soapUse;		faults: OrderedCollection new;		yourself</body><body package="WSDLTool">createSoapMessageDescriptorFor: aClass named: headerFaultName type: aClassOrString	| structMarshaler  header node |	header := aClass new.	header parts: headerFaultName.	header use: self buildOptions soapUse.	structMarshaler :=self x2oBuilder addElementMarshalerName: headerFaultName asString refClass: (self classFrom: aClassOrString).	node := NodeTag qualifier: '' ns: self targetNamespace type: headerFaultName, 'Header'.	header message: (node -&gt; (Wsdl11MessageDescriptor  new 					name: node; 					parts: OrderedCollection new;					yourself)).	header message value parts add: (Wsdl11MessagePartDescriptor new								name:  (NodeTag qualifier: '' ns: self targetNamespace type: headerFaultName);								elementName: structMarshaler name;								yourself ).		^header</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">documentStyleOperationParametersFor: aPartDescriptor	self buildOptions soapStyle = #document		ifTrue: [(self x2oBuilder binding marshalerForTag: aPartDescriptor elementName ifAbsent: [nil])					ifNotNil: [ :m | m typeMarshaler isStructMarshaler ifTrue: [^m typeMarshaler elementMarshalers ]]].	^OrderedCollection new</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">interfaceOperationDescriptor	^Wsdl11InterfaceOperationDescriptor new		faults: OrderedCollection new;		yourself</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">operationBindingDescriptor	^Wsdl11OperationBindingDescriptor new		faults: OrderedCollection new;		yourself</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">operationParameterDescriptor	^Wsdl11OperationParameterDescriptor new</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>printing</category><body package="WSDLTool">printX2OSpecificationOn: aStream	aStream nextPutAll: XMLObjectBinding prolog; cr.	self x2oBuilder asX2OSpecification wsPrintOn: aStream depth: 0</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">setElementMessage: parameters partName: aString parameterDescriptor: parameterDescriptor 	|  elementMarshaler |	(parameters last asSymbol asQualifiedReference valueOrDo: [ nil])		ifNil: [self error: ((#ThereIsNoClass &lt;&lt; #webservices &gt;&gt; 'There is no class: &lt;1s&gt;') expandMacrosWith: parameters last)]		ifNotNil: [ : theClass | elementMarshaler :=   self x2oBuilder addElementMarshalerName: aString refClass: theClass.].	parameterDescriptor message parts add: (Wsdl11MessagePartDescriptor new 											name: ( NodeTag qualifier: '' ns: self targetNamespace type:   aString );											elementName:  elementMarshaler name;											yourself).</body><body package="WSDLTool">setExceptions: faultParameters interfaceOperation: interfaceOperation 	| fault |	faultParameters do: [ :faultParameter |		fault := self addFaultMessage: faultParameter interfaceOperation: interfaceOperation.		self setElementMessage: faultParameter partName: faultParameter first asString parameterDescriptor: fault ].</body><body package="WSDLTool">setInputParameters: parameters interfaceOperation: interfaceOperation	| inputTypeTag |	inputTypeTag := NodeTag qualifier: '' ns: self targetNamespace type:  interfaceOperation name type.	interfaceOperation input:  self operationParameterDescriptor .	interfaceOperation input type: inputTypeTag.	self createMessageDescriptorFor: interfaceOperation input.	self buildOptions soapStyle asSymbol = #rpc 		ifTrue: [self setRpcMessage: parameters parameterDescriptor: interfaceOperation input.				interfaceOperation input message parts notEmpty					ifTrue: [ 	interfaceOperation parameterOrder: OrderedCollection new.							interfaceOperation input message parts do: [ :part | 								interfaceOperation parameterOrder add: part name type ]]]		ifFalse: [ self 					setWrappedDocumentMessage: parameters 					partName: self buildOptions inputPartName					parameterDescriptor:  interfaceOperation input].	^interfaceOperation input message parts</body><body package="WSDLTool">setOutputParameter: anArray interfaceOperation: interfaceOperation	| outputTypeTag  params |	outputTypeTag := NodeTag qualifier: '' ns: self  targetNamespace type: ( interfaceOperation name type,  'Response').	interfaceOperation output: self operationParameterDescriptor.	interfaceOperation output type: outputTypeTag.	self createMessageDescriptorFor: interfaceOperation output.	params := anArray isEmpty 		ifTrue: [anArray]		ifFalse: [Array with: (Array with: 'result' with: anArray first)].	^self buildOptions soapStyle asSymbol = #rpc 		ifTrue: [ self setRpcMessage: params parameterDescriptor: interfaceOperation output ]		ifFalse: [ self 					setWrappedDocumentMessage: params 					partName: self buildOptions outputPartName					parameterDescriptor:  interfaceOperation output].</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">setPortAddress: addressString for: aServiceClass"The address will be used to set soap:address&lt;service name=''WsdlServiceName''&gt;		&lt;port name=''InteropTestClass'' binding=''tns:InteropTestClass''&gt;			&lt;soap:address location=''http://www.cincomsmalltalk.com/r2groupb/interop''/&gt;		&lt;/port&gt;		&lt;port name=''InteropTest1Class'' binding=''tns:InteropTest1Class''&gt;			&lt;soap:address location=''http://www.cincomsmalltalk.com/r2groupb/interop1''/&gt;		&lt;/port&gt;&lt;/service&gt;"	| service |	self buildOptions serviceName ifNil: [self buildOptions serviceName: aServiceClass name asString].	service := self addServiceNamed: self buildOptions serviceName. 	self  bindings do: [ :aBinding |		(self interfaces detect: [ :int | int = aBinding interfaceDescriptor ] ifNone: [ nil]) ifNotNil: [ :interface | 			interface serviceClass = aServiceClass 				ifTrue: [ service ports add: (self createEndpointNamed: aServiceClass name address: addressString binding: aBinding)  ]]].</body><body package="WSDLTool">setPortAddress: addressString forBindingNamed: aString	self 		setPortAddress: addressString 		inService: (self addServiceNamed: self buildOptions serviceName) 		forBindingNamed: aString</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">setRpcMessage: parameters parameterDescriptor: parameterDescriptor	parameters do: [ :coll | | marshaler |		marshaler := self createTypeParameterMarshaler: coll first type: coll last.		parameterDescriptor message parts add: (Wsdl11MessagePartDescriptor new 											name: ( NodeTag qualifier: '' ns: self targetNamespace type: coll first );											typeName: marshaler path;											yourself) ].	^parameterDescriptor message parts</body><body package="WSDLTool">setWrappedDocumentMessage: parameters partName: aString parameterDescriptor: parameterDescriptor"Creating parameters for doc/lit in wrapped style	http://www.ibm.com/developerworks/webservices/library/ws-whichwsdl/	 http://www.ibm.com/developerworks/websphere/library/techarticles/0505_flurry/0505_flurry.html "	| elementMarshaler  part |	^parameters notEmpty		ifTrue: [	elementMarshaler :=self  addOperationMarshalerName: parameterDescriptor type type  type: parameters.			parameterDescriptor message parts add: (part :=Wsdl11MessagePartDescriptor new 											name: ( NodeTag qualifier: '' ns: self targetNamespace type:  aString );											elementName:  elementMarshaler name;											yourself).				part]		ifFalse: [nil]</body></methods><methods><class-id>WebServices.Wsdl11ConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">useDocument	self buildOptions soapStyle: #document</body><body package="WSDLTool">useRpc	self buildOptions soapStyle: #rpc</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor class</class-id> <category>accessing</category><body package="WSDLTool">buildOptions	^self subclassResponsibility</body><body package="WSDLTool">defaultClassNamespace	^self buildOptions defaultClassNamespace</body><body package="WSDLTool">defaultClassNamespace: aString	self buildOptions defaultClassNamespace: aString</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">addBindingNamed: aStringOrNode for: interface	| binding name |	name := aStringOrNode isString ifTrue: [NodeTag qualifier: '' ns: self targetNamespace type: aStringOrNode ] ifFalse: [aStringOrNode].	(binding := self bindingDescriptor ) 				name: name;				interfaceDescriptor: interface.	self  bindings add: binding.	^binding</body><body package="WSDLTool">addFaultBindingFor: interfaceFault toBinding: binding</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">addFaultNamed: faultName type: aClassOrString toInterface: interfaceDescriptor	| structMarshaler  fault faultClass |	faultClass :=  self classFrom: aClassOrString.	fault := Struct new.	fault at: #name put: (NodeTag qualifier: '' ns: self targetNamespace type: faultName asString ).	structMarshaler :=self x2oBuilder addElementMarshalerName: faultName asString refClass: faultClass.	fault element: structMarshaler path.	interfaceDescriptor faults add: fault.	^fault</body><body package="WSDLTool">addFaultNamed: faultName type: aClass toOperation: interfaceOperationDescriptor</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLTool">addImportedX2OBinding: anXMLObjectBinding	self x2oBuilder addImportedBinding: anXMLObjectBinding.</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">addInfaultNamed: faultName toOperation: interfaceOperationDescriptor</body><body package="WSDLTool">addInputParameterNamed: aString type:  aClass  toOperation: interfaceOperation	^self setInputParameters: (Array with: (Array with: aString with: aClass fullName asSymbol)) interfaceOperation: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">addInputParameters: operationParameters toOperation: interfaceOperation	self setInputParameters: operationParameters parameters asArray interfaceOperation: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">addInputParameterType:  aClass  toOperation: interfaceOperation	^self addInputParameterNamed:  'parameter'  type:  aClass  toOperation: interfaceOperation</body><body package="WSDLTool">addInterfaceForServiceClass: aServiceClass	^self addInterfaceNamed: aServiceClass name asString serviceClass: aServiceClass</body><body package="WSDLTool">addInterfaceNamed: aString	| interface |	interface := self interfaceDescriptor.	interface name: (NodeTag qualifier: '' ns: self targetNamespace type: aString).	self interfaces add: interface.	^interface</body><body package="WSDLTool">addInterfaceNamed: aString serviceClass: aServiceClass	| interface |	interface := self addInterfaceNamed: aString.	interface serviceClass: aServiceClass.	^interface</body><body package="WSDLTool">addInterfaceOperationNamed: aString toInterface: interface	| operation |	operation := self interfaceOperationDescriptor.	operation name: (NodeTag qualifier: '' ns: self targetNamespace type: aString).	"Create empty input and output parameters description. The parameters can be described later.  "	self setInputParameters: #() interfaceOperation: operation.	interface addOperation: operation.	^operation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">addOperationBindingFor: interfaceOperation toBinding: interfaceBinding	| operationBinding |	operationBinding := self buildOperationBindingDescriptorFor: interfaceOperation.	operationBinding parent: interfaceBinding.	interfaceBinding  addOperation: operationBinding.	^operationBinding</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">addOperationMarshalerName: aString  type: typeArray" typeArray:  #(#string #String) #(#int #Integer)) "	| attributes elemMarshaler typeMarshalers operationMarshaler |	self x2oBuilder current ~= self x2oBuilder binding ifTrue: [	self x2oBuilder pushCurrent: self x2oBuilder binding ].	(self x2oBuilder binding marshalers select: [:m | m name type = aString asString and: [m isRelationMarshaler or: [m isStructMarshaler ]]] ) 		do: [ :marshalerx | self x2oBuilder binding marshalers  remove: marshalerx].	typeMarshalers := typeArray collect: [ :paramType | self createTypeParameterMarshaler: paramType first type: paramType last ].	attributes := self x2oBuilder nameAttribute: aString.	self  x2oBuilder  startObjectBinding: 'element' attributes: attributes.	operationMarshaler := self  x2oBuilder  current.	self x2oBuilder startObjectBinding: 'struct'  attributes: attributes.	typeArray with: typeMarshalers do: [ :paramType :typeMarshaler |		self  x2oBuilder startObjectBinding: 'element' attributes: (self x2oBuilder nameAttribute: paramType first asString).		elemMarshaler := self  x2oBuilder  current.		elemMarshaler attributes at: (NodeTag qualifier: '' ns: '' type: 'ref') put: typeMarshaler name.		elemMarshaler typeMarshaler:  typeMarshaler.		self  x2oBuilder  endObjectBinding: 'element'].	self x2oBuilder endObjectBinding: 'struct'.	self  x2oBuilder  endObjectBinding: 'element'.	^operationMarshaler</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>updating</category><body package="WSDLTool">addOperationNamed: operationName selector: selectorSymbol to:  anInterface	(anInterface serviceClass includesSelector: selectorSymbol)		ifFalse: [ anInterface serviceClass 					compile: (self  newSourceForSelector: selectorSymbol) 					classified: self buildOptions serviceProtocol ].	( self addInterfaceOperationNamed: operationName  toInterface: anInterface) 		selector: selectorSymbol; 		beInOut.</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">addOutfaultNamed: faultName toOperation: interfaceOperationDescriptor</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">addOutputParameters: operationParameters toOperation: interfaceOperation	self setOutputParameter: operationParameters parameters asArray interfaceOperation: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">addOutputParameterType:  aClass  toOperation: interfaceOperation	^self  setOutputParameter: ( Array with: aClass fullName asSymbol )  interfaceOperation: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">addServiceNamed: aString	^self subclassResponsibility</body><body package="WSDLTool">addServiceNamed: aString interface: interfaceDescriptor	^self addServiceNamed: aString</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>updating</category><body package="WSDLTool">addUndescribedOperationsFromClassMethods:  aClass"Collect all operations that are not described by the descriptor "	| allSelectors stream |	allSelectors := Dictionary new.	self collectProtocolSelectorsFrom: aClass  in: allSelectors.	allSelectors keysAndValuesDo: [ :aclass :selectors | 		(self interfaces detect: [ :int | int serviceClass = aclass ] ifNone: [nil]) ifNotNil: [ :interface |			selectors do: [ :selector |				interface operations 					detect: [ :op | op selector = selector] 					ifNone: [ | size |						stream := String new writeStream.						selector keywords do: [ :token | 							size := (token last = $: ifTrue: [ token size - 1 ] ifFalse: [token size]).							stream 								nextPut: token first asUppercase; 								nextPutAll: (token copyFrom: 2 to: size )].						self addOperationNamed: stream contents selector: selector to:  interface  ]]]].</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">addXMLTypes		self types: (OrderedCollection with: (XML.Element				tag: (NodeTag new qualifier: '' ns: '' type: 'types' )				elements:  (OrderedCollection with: self x2oBuilder binding asXMLSchemaSpecification) ))</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">bindingDescriptor</body><body package="WSDLTool">buildDefaultBindingDescriptorFor: interface	| binding bindingName |	bindingName := (WsdlBinding wsdlBindings 			detect: [ :bindingx | bindingx targetNamespace = self targetNamespace  and: [bindingx serviceClass = interface serviceClass]]			ifNone: [nil])		ifNil: [interface name]		ifNotNil: [ :bindingx | bindingx name ].	binding := self addBindingNamed: bindingName for: interface.	interface faults do: [ :interfaceFault | self addFaultBindingFor: interfaceFault toBinding: binding].	interface operations do: [ :interfaceOperation | self addOperationBindingFor: interfaceOperation toBinding: binding ].	^binding</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLTool">buildFromServices: aCollOfServiceClasses "Create the Wsdl spec from service class operations. Operation description are provided by pragmas ""The Wsdl spec is not going to include access point to the service "	aCollOfServiceClasses do: [ :aServiceClass | self  buildInterfaceDescriptorFor: aServiceClass].	"Build binding components"	self  interfaces do: [ :interface | self  buildDefaultBindingDescriptorFor: interface ].	"Add class refererences from parameter types to XMLObjectBinding "	" if there is existing binding provided let's use it to resolve references"	"use type pragmas if the rest of not-resolved classes have them "	self x2oBuilder linkClassReferences.	"Validate and register WsdlBinding"	self complete.</body><body package="WSDLTool">buildFromServices: aCollOfServiceClasses classNamespace: clString targetNamespace: tnsString"Create the Wsdl spec from service class operations. Operation description are provided by pragmas ""The Wsdl spec is not going to include access point to the service "	self targetNamespace: tnsString.	self  		defaultClassNamespace: clString;		schemaTargetNamespace: tnsString.	self buildFromServices: aCollOfServiceClasses.</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building from pragmas</category><body package="WSDLTool">buildInterfaceDescriptorFor: aServiceClass	| interface interfaceOperation  |	interface := self newInterfaceDescriptorForService: aServiceClass.	self		readOperationPragmas: aServiceClass 		messagesDo: [ :parameters | 			interfaceOperation := self interfaceOperationDescriptor.			interface addOperation: interfaceOperation.			self buildInterfaceOperationDescriptor: interfaceOperation fromPragmas: parameters ].	^interface</body><body package="WSDLTool">buildInterfaceOperationDescriptor: interfaceOperation fromPragmas: parameters" Building operations from pragmas"	(parameters at: #selector ifAbsent: [nil ]) ifNotNil: [ :selector | interfaceOperation selector: selector ].	"#operationName:  "	(parameters 		at: #operationName 		ifAbsent: [ Array with: (SystemUtils validateStaticVariableName:  interfaceOperation selector asString confirm: [ :m :newName | true] warn: [ :v |])]) 			ifNotNil: [ :operationName | interfaceOperation name:  (NodeTag qualifier: '' ns: self targetNamespace type: operationName first asString)].	"#documentation:  "	(parameters at: #documentation ifAbsent: [nil ]) ifNotNil: [ :doc | interfaceOperation documentation: doc ].	"Set input parameters #addParameter:type:  "	self 		setInputParameters: (parameters at: #input ifAbsent: [OrderedCollection new ])		interfaceOperation: interfaceOperation.	"Set output parameter #result:  "	self 		setOutputParameter: (parameters at: #output ifAbsent: [OrderedCollection new  ]) 		interfaceOperation: interfaceOperation.		"Set exceptions #addException:type:  "						self 		setExceptions: (parameters at: #exceptions ifAbsent: [OrderedCollection new ]) 		interfaceOperation: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">buildOperationBindingDescriptorFor: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">buildOptions	^buildOptions ifNil: [ buildOptions := self class buildOptions new ]</body><body package="WSDLTool">buildOptions: aWsdlBuildOptions	buildOptions := aWsdlBuildOptions</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">classFrom: aClassOrString	^aClassOrString isString 		ifTrue: [ aClassOrString asQualifiedReference valueOrDo:[self error: (#ThereIsNoSuchClass &lt;&lt; #webservices &gt;&gt; 'There is no such class: &lt;1s&gt;' expandMacrosWith: aClassOrString) ]] 		ifFalse: [ aClassOrString].</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>reading pragmas</category><body package="WSDLTool">collectMethodPragmas: aMethod selector: aSymbol messagesDo: aBlock	|  operation |		(aMethod attributeMessages) ifNotNil: [ :pragmas |		operation :=  Struct new.				pragmas do: [ :message | 			message selector = #operationName:  ifTrue: [ operation at: #operationName put: message arguments ].			message selector = #documentation: ifTrue: [ operation at: #documentation put: message arguments first ].			message selector = #addParameter:type: ifTrue: [ (operation at: #input ifAbsentPut: [OrderedCollection new]) add: message arguments].			message selector = #result:  ifTrue: [ operation at: #output put: message arguments  ].			message selector = #addException:type: ifTrue: [ (operation at: #exceptions ifAbsentPut: [OrderedCollection new]) add: message arguments]].		operation notEmpty ifTrue: [				operation at: #selector put: aSymbol. 				aBlock value: operation ] ]</body><body package="WSDLTool">collectOperationsSelectors: aClass in: aCollection	self 		readOperationPragmas: aClass 		messagesDo: [ :struct | aCollection add: struct operationName first asString -&gt; struct selector]</body><body package="WSDLTool">collectProtocolSelectorsFrom: aClass in: aDictionary	aDictionary at: aClass ifAbsentPut: [OrderedCollection new].	aClass selectorsAndMethodsDo: [ :sel :meth | |  px | 		((px := aClass organization categoryOfItem: sel) = ClassOrganizer defaultProtocol 			or: [self buildOptions serviceProtocol match: px ])			ifTrue: [(aDictionary at: aClass) add: sel ]].	(self buildOptions useServerSuperclass		and: [(#(Object Exception Error Model UIModel) includes: aClass superclass name ) not			and: [aClass superclass respondsTo: #selectorsAndMethodsDo: ]])					ifTrue: [self collectProtocolSelectorsFrom:  aClass superclass in: aDictionary ]</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLTool">complete"This is the last step in building the configuration descriptor "	| config |	"To complete version specific components "	self completeDescription.	"Validate and register XMLObjectBinding "	self x2oBuilder finish.	"Set schema bindings to create Wsdl &lt;types&gt;&lt;schema&gt; components. Collect imported bindings"	self schemaBindings: OrderedCollection new.	self x2oBuilder binding marshalers notEmpty ifTrue: [self schemaBindings add: self x2oBuilder binding ].	self schemaBindings addAll: self x2oBuilder binding importedBindings.	"Validate and register WsdlBinding"	 config := self buildComponents.	"Collect selectors in serviceMap for interfaces "	config interfaces do: [ :interface | interface addOperationsToServiceMap].	^config</body><body package="WSDLTool">completeDescription</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">createCollectionParameterMarshaler: aSymbol type: aType parameters: parameters"Expected descriptions:&lt;addParameter: #echoArray type:#(#Array #String '1' '20' ) &gt;&lt;addParameter: #echoCollection type: #(#Collection #String '1' '20' ) &gt;"	|  nameAttribute  typeName |	typeName := parameters first  isTypeMarshaler		ifTrue: [parameters first typeName]		ifFalse: [(parameters first asString tokensBasedOn: $.) last].	aType = #Array ifTrue: 		[nameAttribute := self x2oBuilder nameAttribute: ( 'ArrayOf', typeName).		^self x2oBuilder createArrayMarshaler: nameAttribute type: parameters.].	aType  = #Collection ifTrue: 		[nameAttribute := self x2oBuilder nameAttribute: ( 'CollectionOf', typeName).		^self x2oBuilder createCollectionMarshaler: nameAttribute type: parameters.].</body><body package="WSDLTool">createComplexTypeParameterMarshaler: aSymbol type: typeArrayOrSymbol"Expected descriptions:&lt;addParameter: #echoChoice type: #(#Choice #(#string #String) #(#int #Integer)) &gt;&lt;addParameter: #echoCollection type: #(#Collection #String '1' '20' ) &gt;&lt;addParameter: #echoStruct type: #(#Struct #(#string #String) #(#int #Integer)) &gt;"	| parameters nameAttribute  |	parameters := typeArrayOrSymbol copyFrom: 2 to: typeArrayOrSymbol size.	(typeArrayOrSymbol first = #Array 		or: [typeArrayOrSymbol first = #Collection])		ifTrue: [ ^self createCollectionParameterMarshaler: aSymbol type: typeArrayOrSymbol first parameters: parameters ].	nameAttribute := self x2oBuilder nameAttribute: (aSymbol asString,  typeArrayOrSymbol first).	typeArrayOrSymbol first = #Choice ifTrue: [		^self x2oBuilder createStructWithChoiceMarshaler: nameAttribute type:  parameters.].	typeArrayOrSymbol first = #Struct ifTrue: [		^self x2oBuilder createStructMarshaler: nameAttribute type: parameters].	self error: ((#CannotCreateMarshalerFor1s &lt;&lt; #webservices &gt;&gt; 'Can not create marshaler for: &lt;1s&gt;') expandMacrosWith: aSymbol)</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building from pragmas</category><body package="WSDLTool">createElementParameterMarshaler: aSymbol type: typeArrayOrSymbol	| attributes |	^(typeArrayOrSymbol isMemberOf: Array)		ifTrue: [self x2oBuilder mapPragmaDescription: aSymbol type: typeArrayOrSymbol ]		ifFalse: [ (XMLObjectBinding simpleXMLTypeFor: typeArrayOrSymbol ifAbsent: [nil]) 					ifNil: [ (typeArrayOrSymbol asQualifiedReference valueOrDo: [ nil])						ifNotNil: [ :aclass |  								self x2oBuilder buildObjectMarshalerFor: aclass.								attributes := self x2oBuilder nameAttribute: aSymbol asString.								self x2oBuilder addMarshalerForElement: attributes type: aclass name asString]						ifNil: [typeArrayOrSymbol]]					ifNotNil: [attributes := self x2oBuilder nameAttribute: aSymbol asString.							self x2oBuilder addMarshalerForElement:  attributes type: typeArrayOrSymbol ]].</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">createEndpointNamed: aString address: addressString binding: aBinding</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">createSoapHeaderNamed: headerName type: aClassOrString	^self subclassResponsibility</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">createTypeParameterMarshaler: aSymbol type: typeArrayOrSymbol	typeArrayOrSymbol isTypeMarshaler ifTrue: [^typeArrayOrSymbol].	(typeArrayOrSymbol isMemberOf: Array) ifTrue: [^self createComplexTypeParameterMarshaler: aSymbol type: typeArrayOrSymbol. ].		^(XMLObjectBinding simpleXMLTypeFor: typeArrayOrSymbol ifAbsent: [nil]) 		ifNil: [ (typeArrayOrSymbol asQualifiedReference valueOrDo: [ nil])				ifNotNil: [ :aclass |  self x2oBuilder buildObjectMarshalerFor: aclass ]				ifNil: [self error: ( 'There is no marshaler for ', typeArrayOrSymbol ) ]]		ifNotNil: [ :assoc | XMLObjectBinding typeMarshalerForTag: assoc key ifAbsent: [self error: ( 'There is no marshaler for ', typeArrayOrSymbol )] ]</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">defaultClassNamespace	^self buildOptions defaultClassNamespace</body><body package="WSDLTool">defaultClassNamespace: aString	self buildOptions defaultClassNamespace: aString</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLTool">importedX2OBindings	^(OrderedCollection with: self x2oBuilder binding) 		addAll: self x2oBuilder binding importedBindings;		yourself</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>updating</category><body package="WSDLTool">initializeFromWsdlBinding: wsdlBinding serviceClass: serviceClass 	self targetNamespace: wsdlBinding targetNamespace.	"Initialize X2O builder and set operation binding "	self initializeX2OBuilderFrom: wsdlBinding serviceClass: serviceClass.	"Check each operation part marshaler. If the part is resolved using the element attribute (#document style) and there is no ElementMarshaler defined in this X2O binding this is a case of an old and wrong X2O spec. To fix it we create here an ElementMarshaler for the part element references. "	wsdlBinding interfaceDescriptor operations do: [ :operation | operation validateAndFixOperationMarshalers: self x2oBuilder ].	"We need to find a selector for each operation "	self setSelectorsForOperations: wsdlBinding</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLTool">initializeX2OBuilder	| x2oBuilder |	self buildOptions x2oBuilder ifNotNil: [ :builder | ^builder ].	self schemaTargetNamespace 		ifNil: [ "Create special binding for operation parameter, return, faults and headers marshalers "			 self schemaTargetNamespace: self wsdlOperationsTargetNamespace.			"The #defaultClassNamespace: sets the namespace for operation parameters.			Expected classes in this binding are Structs and Collections only that is why the Smalltalk namespace is hard-coded.			If we don't provide Smalltalk the tool generates the operation binding with WSDefault namespace"			self defaultClassNamespace: 'Smalltalk' ].	x2oBuilder := self buildOptions initializeX2OBuilder.	^x2oBuilder</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>updating</category><body package="WSDLTool">initializeX2OBuilderFrom: wsdlBinding serviceClass: serviceClass	| x2oBuilder  |	"Wsdl doc/rpc/lit/encoded/iri. "	self  buildOptions setOptionsFromBinding: wsdlBinding.	x2oBuilder := BindingBuilder new.	self buildOptions x2oBuilder: x2oBuilder.	wsdlBinding importedBindings do: [ :binding | XMLObjectBinding bindingAtNamespace: binding targetNamespace ifAbsent: [binding register ]].	x2oBuilder namespaceMap 		at: '' put: XMLBuildingPolicy uriVWBinding;		at: 'xsd' put: XMLBuildingPolicy defaultUriXsd.	x2oBuilder defaultNamespace: wsdlBinding targetNamespace.	"Assume that the binding with #wsdlOperationTargetNamespace holds operation marshalers "	(wsdlBinding importedBindings 		detect: [ :binding | 			binding targetNamespace = self wsdlOperationsTargetNamespace				or: [binding targetNamespace = self targetNamespace ]] 		ifNone: [nil]) 			ifNotNil: [ :binding | 				self x2oBuilder binding: binding. 				self x2oBuilder pushCurrent: binding.				x2oBuilder namespaceMap at: 'tns'  put:  binding targetNamespace. ]			ifNil: [self x2oBuilder 					initializeBindingFor: serviceClass environment name asString  					targetNamespace: self wsdlOperationsTargetNamespace.				x2oBuilder namespaceMap at: 'tns'  put:  self wsdlOperationsTargetNamespace.				wsdlBinding importedBindings do: [ :binding | self x2oBuilder addImportedBinding: binding ].           			wsdlBinding importBinding: self x2oBuilder binding].</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">interfaceDescriptor	^WsdlInterfaceDescriptor new		faults: OrderedCollection new;		yourself</body><body package="WSDLTool">interfaceOperationDescriptor	^WsdlInterfaceOperationDescriptor new		faults: OrderedCollection new;		yourself</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building from pragmas</category><body package="WSDLTool">newInterfaceDescriptorForService: aServiceClass	| interface str |	(interface := self interfaceDescriptor ) 		name: (NodeTag qualifier: '' ns: self targetNamespace type: aServiceClass name asString).	self interfaces add: interface.	interface serviceClass: aServiceClass.	(str := aServiceClass comment ) notEmpty ifTrue: [ interface documentation: str asString ].	^interface</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">newParameters	^OperationParameters new</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>updating</category><body package="WSDLTool">newSourceForSelector: selectorSymbol 	| tokens stream index |	tokens  := selectorSymbol asSymbol keywords. 	stream := String new writeStream.	index := 0.	tokens		do: [ :token | 			stream nextPutAll: token.			token last = $: ifTrue: [			 index := index + 1. 			stream nextPutAll:  ' parameter', index printString] ]		separatedBy: [stream nextPut: Character space].	^stream contents</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">operationParameterDescriptor</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">portAddressForBindingNamed: aString	| port |	self services isEmpty ifTrue: [ ^nil].	self services 		detect: [ :service | (port := service ports detect: [ :portx | portx binding type = aString ] ifNone: [nil]) notNil]		ifNone: [^nil].	^port addressString</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>copying</category><body package="WSDLTool">postCopy	super postCopy.	interfaces := interfaces collect: [ :int | int copy].	self buildOptions: self buildOptions copy.</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>printing</category><body package="WSDLTool">printX2OSpecificationOn: aStream	aStream nextPutAll: XMLObjectBinding prolog; cr.	self x2oBuilder asX2OSpecification wsPrintOn: aStream depth: 0</body><body package="WSDLTool">printXMLSchemaSpecificationOn: aStream	aStream nextPutAll: XMLObjectBinding prolog; cr.	self x2oBuilder asXMLSchemaSpecification wsPrintOn: aStream depth: 0</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>initialization</category><body package="WSDLTool">readImportedX2OBindingFrom: aStream	self x2oBuilder addImportedBinding: (XMLObjectBinding loadFrom: aStream).</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>reading pragmas</category><body package="WSDLTool">readOperationPragmas: aClass messagesDo: aBlock	aClass selectorsAndMethodsDo: [ :sel :meth | |  px | 		((px := aClass organization categoryOfItem: sel) = ClassOrganizer defaultProtocol 			or: [self buildOptions serviceProtocol match: px ])			ifTrue: [self collectMethodPragmas: meth selector: sel messagesDo: aBlock]].	(self buildOptions useServerSuperclass		and: [(#(Object Exception Error Model UIModel) includes: aClass superclass name ) not			and: [aClass superclass respondsTo: #selectorsAndMethodsDo: ]])					ifTrue: [self readOperationPragmas:  aClass superclass messagesDo: aBlock ]</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building interface</category><body package="WSDLTool">removeFaultNamed: faultName fromOperation: interfaceOperation	(interfaceOperation faults detect: [ :fault | fault name type = faultName ] ifNone: [ nil]) ifNotNil:		[ :fault | interfaceOperation faults remove: fault ].</body><body package="WSDLTool">removeFaultNamed: faultName fromOperation: interfaceOperation fromInterface: interfaceDescriptor	self removeFaultNamed: faultName fromOperation: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>updating</category><body package="WSDLTool">removeOperation: anOperation from:  anInterface includingMethod: aBoolean"Remove operation from interface and binding descriptors,remove a corresponding selector from the service class,remove part element marshaler"	anInterface operations remove: anOperation.	aBoolean ifTrue: [ anInterface serviceClass removeSelector: anOperation selector ].	(self bindings select: [ :b | b interfaceDescriptor = anInterface]) do: [ :b | 		(b operations detect: [ :opb | opb name type = anOperation name type ] ifNone: [nil]) ifNotNil: [ :opb |			b operations remove: opb ]].	self removeOperationMarshalers: anOperation</body><body package="WSDLTool">removeOperationMarshalers: operation	operation removeOperationMarshalersDo: [ :tag | tag ifNotNil: [			(self x2oBuilder binding marshalers select: [:m | m name = tag ] ) 			do: [ :marshaler | self x2oBuilder binding marshalers remove: marshaler ]]]</body><body package="WSDLTool">removeOperationNamed: aString from:  anInterface includingMethod: aBoolean"Remove operation from interface and binding descriptors,remove a corresponding selector from the service class"	(anInterface operations detect: [ :op | op name type = aString ] ifNone: [nil]) ifNotNil: [ :opi |		self removeOperation: opi from: anInterface includingMethod: aBoolean.].</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">schemaTargetNamespace	^self buildOptions schemaTargetNamespace</body><body package="WSDLTool">schemaTargetNamespace: aString	self buildOptions schemaTargetNamespace: aString</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building from pragmas</category><body package="WSDLTool">serviceClass: clSymbol bindingNamed: bindingName targetNamespace: nsString	| struct aclass |	struct := Struct new.		aclass := clSymbol asQualifiedReference valueOrDo: 								[self error: (#ThereIsNoQulifiedRef &lt;&lt; #webservices &gt;&gt; 'There is no qualified reference for: &lt;1s&gt;' 									expandMacrosWith: clSymbol asString)].	struct at: #serviceClass put: aclass.	struct at: #wsdlBinding put: (NodeTag qualifier: '' ns: nsString type: bindingName ).	^struct</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building operation parameters</category><body package="WSDLTool">setExceptions: parameters interfaceOperation: interfaceOperation</body><body package="WSDLTool">setInputParameters: parameters interfaceOperation: interfaceOperation</body><body package="WSDLTool">setMessage: parameters parameterDescriptor: parameterDescriptor</body><body package="WSDLTool">setOutputParameter: anArray interfaceOperation: interfaceOperation</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building services</category><body package="WSDLTool">setPortAddress: addressString forBindingNamed: aString</body><body package="WSDLTool">setPortAddress: addressString inService: aService forBindingNamed: aString	|  port |	(self  bindings detect: [ :aBinding | aBinding name type = aString] ifNone: [nil])		ifNotNil: [ :aBinding  | 				(aService ports detect: [ :portx | portx binding = aBinding name ] ifNone: [nil])					ifNotNil: [ :portx | portx addressString: addressString. port := portx]					ifNil: [aService ports add: (port := self createEndpointNamed: aString address: addressString binding: aBinding)]].	^port</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>updating</category><body package="WSDLTool">setSelectorsForOperations: wsdlBinding 	| interfaceDescriptor selectors  |	interfaceDescriptor := wsdlBinding interfaceDescriptor.	"Collect selectors from operation pragmas. Just in case of old mapping if there is no service map "	selectors := OrderedCollection new.	self collectOperationsSelectors: wsdlBinding serviceClass in: selectors.	interfaceDescriptor operations do: [ :op | 		op pattern ifNil: [ op isOneWay ifTrue: [op beRobustInOnly] ifFalse: [op beInOut]].		op selector 			ifNil: [op selector: (( interfaceDescriptor serviceMap selectorFor: op name type)								ifNotNil: [ :sel | sel]								ifNil: [(selectors 											detect: [ :assoc | assoc key = op name type ]											ifNone: [nil]) ifNotNil: [ :assoc | assoc value]])]]</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>building binding</category><body package="WSDLTool">soapActionFor: bindingOperation	^self targetNamespace, '#', bindingOperation name  asString</body></methods><methods><class-id>WebServices.WsdlConfigurationDescriptor</class-id> <category>accessing</category><body package="WSDLTool">wsdlOperationsTargetNamespace	^self targetNamespace, '_WSDLOperations'</body><body package="WSDLTool">x2oBuilder	self buildOptions x2oBuilder ifNil: [ self initializeX2OBuilder].	^self buildOptions x2oBuilder</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>accessing</category><body package="WSDLTool">interface	^bindingDescriptor interfaceDescriptor</body><body package="WSDLTool">interface: aWsdlInterfaceDescriptor	bindingDescriptor interfaceDescriptor: aWsdlInterfaceDescriptor</body><body package="WSDLTool">transportUri	^bindingDescriptor bindingType at: #transportName ifAbsent: [self error: (#MissingRequiredAttributeTransportName &lt;&lt; #webservices &gt;&gt; 'Missing required attribute: transportName ')]</body><body package="WSDLTool">transportUri: aValue	^bindingDescriptor bindingType at: #transportName put: aValue</body></methods><methods><class-id>WebServices.WsdlBinding</class-id> <category>utilities</category><body package="WSDLTool">updateX2OBinding"This method can be used to fix old X2O specs for #document style Wsdl schemas. There are possible that Wsdl message parts resolved via element references don't have element marshalers defined in X2O spec. This method will add &lt;element&gt; node for operation parts. The WsdlBinding and XMLObjectBinding instances have to be registered. "	| descr |	(descr := WsdlConfigurationDescriptor initializeFor: self targetNamespace )		initializeFromWsdlBinding: self			serviceClass: self serviceClass.	^descr schemaBindings</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="WSDLTool">webServicesWsdlBuilderPage	&lt;settingsPage: #(webservices wsdlBuilder)&gt;	^ModularSettingsPage new		label: #WebServicesWsdlBuilder &lt;&lt; #webservices &gt;&gt; 'Wsdl Builder';		icon: (ListIconLibrary visualFor: #web);		addAllSettings: 			(self settingsWithPrefix: #(webservices wsdlBuilder )				except: #(webservices wsdlBuilder useServerSuperclassMethods));		useRadioButtonsForEnumerations;		addSetting:			(self settingWithId: #(webservices wsdlBuilder useServerSuperclassMethods));		yourself</body><body package="WSDLTool">webServicesWsdlBuilderSoapBindingPage	&lt;settingsPage: #(webservices wsdlBuilder wsdl11Binding)&gt;	| soapStyle inputParam outputParam useType |	soapStyle := EnumerationSettingModule on: (self settingWithId: #(webservices wsdlBuilder wsdl11Binding soapStyle)).	useType := EnumerationSettingModule on: (self settingWithId: #(webservices wsdlBuilder wsdl11Binding useType)).	inputParam := StringSettingModule on: (self settingWithId: #(webservices wsdlBuilder wsdl11Binding inputPartName)).	outputParam := StringSettingModule on: (self settingWithId: #(webservices wsdlBuilder wsdl11Binding outputPartName)).	^ModularSettingsPage new		label: #WebServicesWsdlBuilderSoapBinding &lt;&lt; #webservices &gt;&gt; 'WSDL 1.1 Binding';		icon: (ListIconLibrary visualFor: #web);		addModule: soapStyle;		addModule: useType;		addModule: inputParam;		addModule: outputParam;		when: soapStyle valueHolder valueSatisfies: [:v | v  = #document ] enable: inputParam;		when: soapStyle valueHolder valueSatisfies: [:v | v = #document ] enable: outputParam;		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws-classbuilder</category><body package="WSDLTool">ws1DefaultServicePackage	&lt;setting: #(webservices classBuilder defaultServicePackage ) position: 30&gt;	^(StringSetting on: WebServices.WsdlClassBuildOptions aspect: #defaultPackage)		label: #DefaultServicePackage &lt;&lt; #webservices &gt;&gt; 'Default service package';		default: WebServices.WsdlClassBuildOptions defaultPackageValue;		helpText: #DefaultServicePackageHelpText &lt;&lt; #webservices &gt;&gt; 'The package in which client, server and service classes that are generated from a WSDL schema are placed, by default. If the package name does not exist in the system, it will be created. ';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws wsdlbuilder</category><body package="WSDLTool">ws2DefaultTargetNamespace	&lt;setting: #(webservices wsdlBuilder defaultTargetNamespace)&gt;	^(StringSetting on: WebServices.XMLObjectBinding aspect: #defaultTargetNamespace )		label: #DefaultTargetNamespace &lt;&lt; #webservices &gt;&gt; 'Default target namespace';		default: WebServices.XMLObjectBinding defaultTargetNamespaceValue;		helpText: #DefaultTargetNamespaceHelpText &lt;&lt; #webservices &gt;&gt; 'The URN for the default namespace of the service being defined by the target WSDL schema.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws-classbuilder</category><body package="WSDLTool">ws5UsePart1InSelector	&lt;setting: #(webservices classBuilder usePart1InSelector) position: 100&gt;	^((EnumerationSetting 		choices: #(#true #false)		labels: (				Array 					with: (#UsePart1InSelector &lt;&lt; #webservices &gt;&gt; 'Use operation name and all message parts') 					with: (#DontUsePart1InSelector &lt;&lt; #webservices &gt;&gt; 'Don''t use the first message part')))	on: WebServices.SoapWsdl11OperationBinding aspect: #setUsePart1InSelector)		label: #WhileGeneratingClassSelectors &lt;&lt; #webservices &gt;&gt; 'While generating service and client selectors:';		default: WebServices.SoapWsdl11OperationBinding usePart1InSelectorValueSymbol;		helpText: #WhileGeneratingClassSelectorsHelpText &lt;&lt; #webservices &gt;&gt; 'Depending on this setting, the tool does the following:- If "Use operation name and all message parts" is selected, then the Wsdl Class Builder will generate the service and client class selectors as following: selector := operationNamePart1:part2:part3:.. For example: the BabelFish schema has operation name as #BabelFish and parts as #Translationmode and #Sourcedata. With this option on the selector will be created aClient&gt;&gt;babelFishTranslationmode:sourcedata:- If "Don''t use the first message part" is selected, selectors will be generated as following: selector := operationName:part2:part3:... This is the default option. For example: aClient&gt;&gt;babelFish:sourcedata: ';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws wsdlbuilder</category><body package="WSDLTool">ws5XmlEncoding	&lt;setting: #(webservices wsdlBuilder xmlEncoding)&gt;	^((EnumerationSetting 				choices: #(#'utf-8')				labels: (Array with: (#utf8 &lt;&lt; #webservices &gt;&gt; 'utf-8')  ))			on: WebServices.XMLObjectBinding aspect: #xmlEncoding )		default: WebServices.XMLObjectBinding xmlEncodingValue;		label: #XMLEncoding&lt;&lt; #webservices &gt;&gt; 'XML encoding';		helpText: (#XMLEncodingHelpText &lt;&lt; #webservices &gt;&gt; 'Specifies the default XML document encoding');		yourself</body><body package="WSDLTool">ws8UseServerSuperclassMethods	&lt;setting: #(webservices wsdlBuilder useServerSuperclassMethods)&gt;	^((EnumerationSetting 		choices: #(#true #false)		labels: (				Array 					with: (#UseServerSuperMethods &lt;&lt; #webservices &gt;&gt; 'Add the service super class methods') 					with: (#UseOnlyServerMethods &lt;&lt; #webservices &gt;&gt; 'Use only the service class methods')))	on: WebServices.WsdlBuildOptions aspect: #setUseServerSuperclass)		label: #WhileGeneratingSchema &lt;&lt; #webservices &gt;&gt; 'While generating the schema:';		default: WebServices.WsdlBuildOptions useServerSuperclassValue;		helpText: #WhileGeneratingSchemaHelpText &lt;&lt; #dialogs &gt;&gt; 'Depending on this setting, the tool does the following:- If "Add the service super class methods" is selected, then the Wsdl schema will be generated from the service class and its super classes annotated methods. This is the default option.- If "Use only the service class methods" is selected, the schema will be generated only from the service class methods';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws-classbuilder</category><body package="WSDLTool">wsdl2DefaultServiceProtocol	&lt;setting: #(webservices defaultServiceProtocol)&gt;	^(StringSetting on: WebServices.WsdlBuildOptions aspect: #defaultServiceProtocol )		label: #defaultServiceProtocol &lt;&lt; #webservices &gt;&gt; 'Default service protocol';		default: WebServices.WsdlBuildOptions defaultServiceProtocolValue;		helpText: #defaultServiceProtocolHelpText &lt;&lt; #webservices &gt;&gt; 'The protocol (class category) in which all web service interface stub methods are created, by default. While generating a Wsdl shema the methods from this protocol are used to create Wsdl operations';		yourself</body><body package="WSDLTool">wsdlUseExistingClassNames	&lt;setting: #(webservices classBuilder useExistingClassNames)  position: 130&gt;	^((EnumerationSetting 		choices: #(#true #false)		labels: (				Array 					with: (#UseExistingNames &lt;&lt; #webservices &gt;&gt; 'Use the existing class names') 					with: (#NotUseExistingNames &lt;&lt; #webservices &gt;&gt; 'Create a new unique class name')))		on: WebServices.WsdlClassBuildOptions aspect: #setUseExistingClassName)		label: #UsingExistingName &lt;&lt; #webservices &gt;&gt; 'If the client, service or server class name to be created already exists:';		default: WebServices.WsdlClassBuildOptions setUseExistingClassNameValue;		helpText: #UseExistingClientServiceNamesHelpText &lt;&lt; #dialogs &gt;&gt; 'Depending on this setting, the tool does the following:- If "Use the existing class name" is selected, then if a class with this name is already in the system, the class name is not generated and the existing class name is used for the binding. - If "Create a new unique class name" is selected, new class names are always generated in the namespace where the classes are defined.Unique names are created by appending an integer to the class name. For example, if the specified namespace already has the class Document and the XML attribute is name=Document, then the binding object name will be set to Document1. This is the default option.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws wsdl1.1  builder</category><body package="WSDLTool">wsSoap2SoapStyle	&lt;setting: #(webservices wsdlBuilder wsdl11Binding soapStyle)&gt;	^((EnumerationSetting 				choices: #(rpc document)				labels: (Array with: (#rpc &lt;&lt; #webservices &gt;&gt; 'rpc') with: (#document &lt;&lt; #webservices &gt;&gt; 'document') ))			on: WebServices.Wsdl11BuildOptions aspect: #soapStyle)		default:  WebServices.Wsdl11BuildOptions soapStyleValue;		label: #StyleAttribute&lt;&lt; #webservices &gt;&gt; 'Style attribute';		helpText: #SoapStyleHelpText &lt;&lt; #webservices &gt;&gt; 'Specifies the default SOAP message style (either "rpc" or "document").';		yourself</body><body package="WSDLTool">wsSoap3UseType	&lt;setting: #(webservices wsdlBuilder wsdl11Binding useType)&gt;	^((EnumerationSetting 				choices: #(literal encoded)				labels: (Array with: (#literal &lt;&lt; #webservices &gt;&gt; 'literal') with: (#encoded &lt;&lt; #webservices &gt;&gt; 'encoded') ))			on: WebServices.Wsdl11BuildOptions aspect: #soapUse)		default: WebServices.Wsdl11BuildOptions soapUseValue;		label: #UseAttribute&lt;&lt; #webservices &gt;&gt; 'Use attribute';		helpText: #UseTypeHelpText &lt;&lt; #webservices &gt;&gt; 'Specifies the default "use" attribute in the SOAP body binding description (either "literal" or "encoded").';		yourself</body><body package="WSDLTool">wsSoap4InputPartName	&lt;setting: #(webservices wsdlBuilder wsdl11Binding inputPartName)&gt;	^(StringSetting on: WebServices.Wsdl11BuildOptions aspect: #inputPartName )		label: #InputPartName &lt;&lt; #webservices &gt;&gt; 'Input part name';		default: WebServices.Wsdl11BuildOptions inputPartNameValue;		helpText: #InputPartNameHelpText &lt;&lt; #webservices &gt;&gt; 'This option works for #document style WSDL only and allows customizing the part name attribute in an input message. For example setting "parameters" value will result in the following input message description:&lt;message name="someRequest"&gt;    &lt;part name="parameters" element="tns:search"/&gt;&lt;/message&gt;';		yourself</body><body package="WSDLTool">wsSoap5OutputPartName	&lt;setting: #(webservices wsdlBuilder wsdl11Binding outputPartName)&gt;	^(StringSetting on: WebServices.Wsdl11BuildOptions aspect: #outputPartName )		label: #outputPartName &lt;&lt; #webservices &gt;&gt; 'Output part name';		default: WebServices.Wsdl11BuildOptions outputPartNameValue;		helpText: #outputPartNameHelpText &lt;&lt; #webservices &gt;&gt; 'This option works for #document style WSDL only and  allows customizing the part name attribute in an output message.For example setting "parameters" value will result in the following output message description:&lt;message name="someResponse"&gt;    &lt;part name="parameters" element="tns:searchResult"/&gt;&lt;/message&gt;';		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MessageBinding</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace style structMarshaler partMarshalers structName isWrapped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><class><name>SoapWsdl20FaultBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl20MessageBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code subcodes name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><class><name>X2OClassBuildOptions</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>category packageMap </inst-vars><class-inst-vars>defaultCategory defaultPackage </class-inst-vars><imports></imports><category>Web Services-Tools</category><attributes><package>XMLObjectBindingTool</package></attributes></class><class><name>WsdlInterfaceOperationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name input output faults style selector pattern </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>Wsdl20InterfaceOperationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlInterfaceOperationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outfaults rpcSignature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SoapWsdl11HeaderBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl11PartBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>faults excMarshalers tags faultTags entryMarshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><class><name>SoapWsdl11HeaderFaultBinding</name><environment>WebServices</environment><super>WebServices.SoapWsdl11HeaderBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><class><name>WsdlConfigurationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetNamespace imports interfaces bindings services schemaBindings types buildOptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>Wsdl20ConfigurationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlConfigurationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>Wsdl11MessagePartDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name typeName elementName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>Wsdl11ConfigurationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlConfigurationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages soapEncoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>Wsdl11InterfaceOperationDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlInterfaceOperationDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>WsdlBinding</name><environment>WebServices</environment><super>WebServices.XMLObjectBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transport operations bindingDescriptor schemaSource faults port idTag refTag headerMarshalers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLBinding</package></attributes></class><class><name>Wsdl20SoapFaultDescriptor</name><environment>WebServices</environment><super>WebServices.WsdlComponentDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name targetNamespace soapFaultCode soapFaultSubcode soapHeaders soapModule </inst-vars><class-inst-vars>soapFaultCodes </class-inst-vars><imports></imports><category>Web Services-WSDL</category><attributes><package>WSDLDescriptors</package></attributes></class><class><name>SoapOperationBinding</name><environment>WebServices</environment><super>WebServices.OperationBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>rpcResultAsStruct </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><class><name>SoapWsdl11OperationBinding</name><environment>WebServices</environment><super>WebServices.SoapOperationBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputHeaderBindings inputHeaderMarshaler outputHeaderMarshaler outputHeaderBindings faultMarshalers </inst-vars><class-inst-vars>usePart1InSelector defaultUseOldDocStyleInvocation wrapDocumentLiteralResult </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class><class><name>SoapWsdl20OperationBinding</name><environment>WebServices</environment><super>WebServices.SoapOperationBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputFaultMarshalers inputFaultMarshalers interfaceDescriptor style rpcSignature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>WSDLBinding</package></attributes></class></st-source>