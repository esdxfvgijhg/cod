<?xml version="1.0"?><st-source><!-- Name: XMLObjectMarshalersNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: XMLObjectMarshalers provides support for the XML-To-Object Framework. XML Marshalers convert XML elements and/or their parts to Smalltalk objects and vice versa. OverviewThe XML-to-object mechanism supports marshaling for:- simple types to simple types;- simple types with attributes to complex objects;- complex elements to complex objects;- elements, attributes, or text to aspects of Smalltalk objects.The XML-to-object mechanism supports several important object marshaling alternatives. For instance, it can marshal XML either as an object with aspects or as a "struct" that is, marshal to a Struct (similar to a Dictionary), handling aspects with #at:, #at:put: messages. This allows marshaling objects for which no specific domain class has yet been defined, permitting experimentation with an intermediate implementation and then gradually refining it. Collections can also be used in this way. Aspects can be defined easily. Both scalar aspects and repeating groups (collection-valued aspects) are supported.The XML to object framework supports a number of common primitive types, including strings, numbers, token lists, URI references, namespace-qualified names and name references, etc. Marshaling blocks are used to resolve primitive types, and for serialization and deserialization. The blocks are stored in BindingBuilder class registries.BindingBuilder is responsible for generating bindings from binding specification documents, maintaining a registry of mappings from XML tags to prototype marshalers, and blocks for resolving primitive types. XMLObjectBinding maintains another registry, a registry of bindings for specific schemas. It responds to requests to find a marshaler for a specific XML tag or Smalltalk object.For more information see "XML to Smalltalk Mapping" chapter from WebServices documentation.DbIdentifier: bear73DbTrace: 493889DbUsername: tkoganDbVersion: 8.3 - 0DevelopmentPrerequisites: #(#(#any 'XMLObjectSupport' '') #(#any 'XPath' '') #(#any 'XMLSchemaMapping' ''))PackageName: XMLObjectMarshalersParcel: #('XMLObjectMarshalers')ParcelName: XMLObjectMarshalersPrerequisiteDescriptions: #(#(#name 'XMLObjectSupport') #(#name 'XPath') #(#name 'XMLSchemaMapping' #componentType #package))PrerequisiteParcels: #(#('XMLObjectSupport' '') #('XPath' '') #('XMLSchemaMapping' ''))PrintStringCache: (8.3 - 0,tkogan)Version: 8.3 - 0Date: 2:31:37 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:37 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>XMLMarshaler</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag name documentation params attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.XMLMarshaler</class-id><body>This class is the base class for all XML-to-Smalltalk marshalers. Instance Variables	tag	&lt;NodeTag&gt; as it is going to be in XML tag.  Almost always is the same as #name	name	&lt;NodeTag&gt; name attribute. 	documentation	&lt;String&gt; documentation	params	&lt;Dictionary&gt; default parameters	attributes	&lt;Dictionary&gt; X2O binding attributes</body></comment><class><name>XMLTypeMarshaler</name><environment>WebServices</environment><super>WebServices.XMLMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xpath keyRefMarshaler qualified binding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.XMLTypeMarshaler</class-id><body>This class is the base class for all type marshalers. It mainly publishes three protocols:	api -- marshal	api -- unmarshal	api -- builderThe former two are used to marshal Smalltalk objects to or from XML nodes. The latter one is used by binding builder when it parses binding spec and creates a network of type marshaler to implement this spec.There are two groups of marshalers to marshal/unmarshal between XML and Smalltalk:- Type marshalers- Relation marshalers- Type marshalers correspond to XML types and convert XML to/from Smalltalk object. - Relation marshalers correspond to XML elements and to relations between two Smalltalk objects and are concerned with orchestrating constructing objects from parts unmarshaled as types; or deconstructing object to parts that are marshaled as types. Relation marshalers are parts of complex object marshaler. Relation marshalers themselves contain marshaler for the far side of the relation and description of the relation (cardinality, getter, setter and aspect implementation) Type marshalers are further divided into simple and complex object marshalers.- Simple type marshalers (SimpleObjectMarshaler) represent terminal nodes in object graph and in XML document. They correspond to the objects which have opaque structure and are serialized/deserialized 'magically' (examples are most simple Smalltalk objects -- strings, measurements, etc). Some complex objects that cannot be unmarshaled by the rules fall into this category as well. - Complex types that have parts which are connected to the parent object via relations. These correspond to structured XML nodes and Smalltalk objects. XML nodes corresponding to complex object are usually element noides (although text or attribute or other nodes are also possible), so for example a simple XML node with attributes can be marshaled into structured Smalltalk object. ComplexObjectMarshaler is used to marshal complex objects Each marshaler matches some XML node or collection of nodes. Therefore, each marshaler has an associated XPath expression and XPath parser for this expression. Since XPath is kind of thing in itself, there is a 'bridge' between marshaler and XPath parser -- XMLMarshalerProxy.See more info in 'documentation' categoryInstance Variables	xpath	&lt;XMLMarshalerProxy&gt; Implements XPath (parsing and composing XML) for the marshaler	keyRefMarshaler	&lt;KeyRefObjectMarshaler&gt; Key ref marshaler associated with this marshaler	qualified	&lt;Boolean&gt; defines whether or the node tag should have qualifier	binding	&lt;XMLObjectBinding&gt; the marshaler binding</body></comment><class><name>CompositorMarshaler</name><environment>WebServices</environment><super>WebServices.XMLTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relation marshalers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.CompositorMarshaler</class-id><body>The clas is the super class for marshalers that define how XML nodes are selected  while unmarshaling.Instance Variables	relation	&lt;Relation&gt; 	marshalers	&lt;Collection of: XMLTypeMarshaler&gt; </body></comment><class><name>SequentialMarshaler</name><environment>WebServices</environment><super>WebServices.CompositorMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aspectImplementation inheritedIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.SequentialMarshaler</class-id><body>The class represents a marshaler for sequential processing XML nodes while unmarshaling. A complex object marshaler uses XPath to select all subelements then this collection is suggested to each sequential marshaler. If the marshaler accepts a node (nodes) the node is unmarshaled and removed from the collection. By default this marshaler is created for &lt;sequence&gt; model group schema component</body></comment><class><name>GroupMarshaler</name><environment>WebServices</environment><super>WebServices.SequentialMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.GroupMarshaler</class-id><body>Relation marshaler that represents a reference to ModelGroupMarshalerWhen we create XML to Object Binding we map the #attributeGroup and #group element as following:1. elements with name are mapped to #struct type2. elements with ref are mapped to #groupFor example:The XML schema below: &lt;xsd:group name="myGroup"&gt;     &lt;xsd:sequence&gt;       &lt;xsd:element name="group1" type="xsd:string"/&gt;     &lt;/xsd:sequence&gt;   &lt;/xsd:group&gt; &lt;xsd:attributeGroup name="myAttrs"&gt;     &lt;xsd:attribute name="grAttr1" type="xsd:string"/&gt;      &lt;xsd:attribute name="grAttr2" type="xsd:string"/&gt;  &lt;/xsd:attributeGroup&gt; &lt;xsd:element name="Item"&gt; &lt;xsd:complexType&gt;       &lt;xsd:sequence&gt;       &lt;xsd:group ref="myGroup"/&gt;         &lt;xsd:element name="aaa"&gt;           &lt;xsd:complexType&gt;             &lt;xsd:attributeGroup ref="myAttrs"/&gt; 		&lt;xsd:attribute name="aaaName" type="xsd:string"/&gt;          &lt;/xsd:complexType&gt;         &lt;/xsd:element&gt;       &lt;/xsd:sequence&gt;     &lt;/xsd:complexType&gt;   &lt;/xsd:element&gt; will be mapped to:&lt;xmlToSmalltalkBinding ..&gt;		&lt;struct name="myAttrs"&gt;			&lt;attribute name="grAttr1" ref="xsd:string"/&gt;			&lt;attribute name="grAttr2" ref="xsd:string"/&gt;		&lt;/struct&gt;		&lt;struct name="myGroup"&gt;			&lt;element name="group2" ref="xsd:string"/&gt;		&lt;/struct&gt;		&lt;struct name="Item" tag="Item"&gt;			&lt;group name="myGroup" ref="tns:myGroup"/&gt;			&lt;element ref="tns:Item_aaa" tag="aaa"/&gt;		&lt;/struct&gt;		&lt;struct name="Item_aaa" tag="aaa"&gt;			&lt;group name="myAttrs" ref="tns:myAttrs"/&gt;			&lt;attribute name="aaaName" ref="xsd:string"/&gt;		&lt;/struct&gt;&lt;/xmlToSmalltalkBinding&gt;The request arguments for the XML to Object binding above should be prepared as:	anObj := WebServices.Struct new.	anObj 		group1:'astring';		aaa: (WebServices.Struct new 				grAttr1: 'grAttr1';				grAttr2: 'grAttr2';				aaaName: 'aaName';				yourself).</body></comment><class><name>ObjectMarshaler</name><environment>WebServices</environment><super>WebServices.XMLTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ObjectMarshaler</class-id><body>ObjectMarshaler super class for marshal/unmarshal complex objectsInstance Variables:	smalltalkClass	&lt;Class&gt;	smalltalkClass, the XML element is mapped to	relations	&lt;(SequenceableCollection of: RelationMarshaler)&gt;	relations	aspectImplementation	&lt;AspectImplementation&gt;	instance of AspectImplementation	baseType	&lt;Class&gt;	super class, if the base type is specified its relations are added to the marshaler Shared Variables:	RaiseMissingValueException &lt;Boolean&gt; setting this option to true will raise the MissingValueSignal for optional and mandatory values. Default is false and the exception will be raised only in case of missing mandatory value</body></comment><class><name>SoapArrayMarshaler</name><environment>WebServices</environment><super>WebServices.ObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementMarshaler </inst-vars><class-inst-vars>useEmptyLengthForDimension </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.SoapArrayMarshaler</class-id><body>SoapArrayMarshaler unmarshals/marshals the soap array element item. If the soap array is declared as multidimensional, it creates array of arrays. The marshaler is used only for RPC/encoded style.Instance Variables	elementMarshaler	&lt;ElementMarshaler&gt; item marshalerClass Instance Variables	useEmptyLengthForDimension	&lt;Boolean&gt; allows to set SOAP-ENC:arrayType='ns1:string[]' for nil arrays</body></comment><class><name>ComplexObjectMarshaler</name><environment>WebServices</environment><super>WebServices.ObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyMarshalers abstract anyAttributeMarshaler compositor textMarshaler attributeMarshalers baseType aspectImplementation </inst-vars><class-inst-vars>defaultCompositor </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ComplexObjectMarshaler</class-id><body>ComplexObjectMarshaler converts  XML complex elements and/or their parts to Smalltalk objects and vice versa. The marshaler converts objects with parts such as: sequence-of -- homogeneous collections with a known type or type ANY (#add: protocol for parts) struct -- dictionaries (at: protocol for parts) object -- general objects with aspects (accessor methods) (perform: protocol for parts) Instance Variables	keyMarshalers	&lt;(Collection of: KeyObjectMarshaler)&gt; key marshalers	abstract	&lt;Boolean&gt; defines if the compex type defined as abstract	anyAttributeMarshaler	&lt;AnyAttributeMarshaler&gt; marshaler for &lt;anyAttribute&gt; 	compositor	&lt;CompositorMarshaler&gt; the marshaler defines how the XML nodes are unmarshaled. UnorderedMarshaler uses XPath to select nodes. SequentialMarshaler processes nodes sequetialy.	textMarshaler	&lt;TextMarshaler&gt; 	attributeMarshalers	&lt;Collection of: AttributeMarshaler&gt; 	baseType	&lt;ComplexObjectMarshaler&gt;  base typeClass Instance Variables	defaultCompositor	&lt;CompositorMarshaler&gt; in case of old X2O mappings where &lt;sequence&gt; or &lt;all&gt; elements where not defined this default value will be used.</body></comment><class><name>ModelGroupMarshaler</name><environment>WebServices</environment><super>WebServices.ComplexObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ModelGroupMarshaler</class-id><body>Complex type that includes relations from xml &lt;group&gt;  </body></comment><class><name>ModelAttributeGroupMarshaler</name><environment>WebServices</environment><super>WebServices.ModelGroupMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ModelAttributeGroupMarshaler</class-id><body>Complex type that includes relations from xml &lt;attributeGroup&gt;  </body></comment><class><name>RelationMarshaler</name><environment>WebServices</environment><super>WebServices.XMLTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relation marshaler </inst-vars><class-inst-vars>defaultRefType </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.RelationMarshaler</class-id><body>Relation marshaler unmarshals/marshals the far side of the relation  and collaborates with its parent marshaler to get/set the value to the parent object. In other words, relation marshaler does marshaling/unmarshaling, that is, produces unmarshaled value; and provides info for the parent marshaler. It does not, however, gets/sets value in the parent, only the parent does.Since relations can be one-sided and many-sided and implementation of marshaling is reasonably different, I chose to represent those differences in a separate class -- subclass of Relation.Instance Variables	relation	&lt;Relation&gt; marshaler for the actual relation	marshaler	&lt;XMLTypeMarshaler&gt; marshaler for the far sideClass Instance Variables	defaultRefType	&lt;NodeTag&gt; default type for relation type marshalerRelation marshaler takes care of nil elements. XML Schema Structures introduces a mechanism for signaling that an element should be accepted as valid when it has no content despite a content type which does not require or even necessarily allow empty content. An element may be valid without content if it has the attribute xsi:nil with the value true. An element so labeled must be empty.Relation marshaler creates an element with xsi:nil='true' attribute for nil value if the XMLObjectMarshalingManager useNilAttribute is set to true and the element description has the nillable='true'  attribute:&lt;xsd:element name='shipDate' type='xsd:date' nillable='true'/&gt;&lt;shipDate xsi:nil='true'&gt;&lt;/shipDate&gt;"In other cases the MissingValueSignal will be raised. The default exception handling for MissingValueSignal will not create any XML element for the value nil.When relation marshaler unmarshals an XML empty element that has xsi:nil='true' it will return nil as a value. If the XML element was described with nillable='false' the NilValueNotAllowed exception will be raised. The default exception handling will pass the value nil to a corresponding marshaler for deserialization.</body></comment><class><name>AttributeMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fixed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.AttributeMarshaler</class-id><body>Relation marshaler that marshals/unmarshals an attribute</body></comment><class><name>ImplicitAttributeMarshaler</name><environment>WebServices</environment><super>WebServices.AttributeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ImplicitAttributeMarshaler</class-id><body>Relation marshaler that marshals/unmarshals an attribute reference (&lt;attribute ref="tns:mustUnderstand"/&gt;</body></comment><class><name>RPCEncRelationMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useInlineType </inst-vars><class-inst-vars>nillableDefault </class-inst-vars><imports></imports><category>Web Services-SOAP</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.RPCEncRelationMarshaler</class-id><body>RPCEncRelationMarshaler  sets  the marshaling context class for the RPC/encoded styleInstance Variables	useInlineType	&lt;Boolean&gt; defines if an inline type should be usedClass Instance Variables	nillableDefault	&lt;Boolean&gt; false as default</body></comment><class><name>MarshalingContext</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent marshaler source nodeContext value manager keys keyRefs aspect temp isReference tag useInlineType aspectImplementation shouldEncodeValue </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.*			</imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.MarshalingContext</class-id><body>This class is used by XML-to-Smalltalk marshalers to marshal and unmarshal between XML nodes and Smalltalk objects. Picture it as a sort of assembly board where parts have to be present at the same time. It contains XML node, corresponding Smalltalk value, marshaler for there and link to the parent marshaled value. It also holds on to the manager which may be needed in some cases i.e. to look up type registry, namespaces, etc.During marshaling marshaler converts Smalltalk value into XML node and store it as marshaled value's source. It may also consult parent, usually to set parent of the marshaled node.During unmarshaling the unmarshaler converts XML node to Smalltalk value. It may also consult marshaled value's parent to properly set the value in it's parent object.When marshaling/unmarshaling complex objects marshalers create child marshaled values and let them handle object parts.Instance Variables	parent	&lt;MarshalingContext&gt; My parent marshaled value	marshaler	&lt;XMLTypeMarshaler&gt; Marshaler or unmarshaler	source	&lt;XML.Element&gt; XML node being marshaled or unmarshaled	nodeContext	&lt;Collection of XML.Element&gt; source elements to marshal or unmarshal	value	&lt;Object&gt; Smalltalk value being marshaled or unmarshaled	manager	&lt;XMLObjectMarshalingManager&gt; Manager	keys	&lt;Collection of KeyObjectMarshaler&gt; holds object's keys if any	keyRefs	&lt;Collection of KeyObjectMarshaler&gt; holds keyRefs	aspect	&lt;Symbol&gt; aspect implementation	temp	&lt;Number&gt; is used to set/get data from SequenceableCollection  implementation aspect	isReference	&lt;Boolean&gt; defines where or not an object being unmarshaled is reference if it has been resolved through key reference	tag	&lt;NodeTag&gt; the marshaled value tag	useInlineType	&lt;Boolean&gt; use inline type option	aspectImplementation	&lt;Object&gt; the aspect implementation to retrieve the marshaling valueShared Variables	UnresolvedValue	&lt;Object&gt; the default value for unmarshaled XML source</body></comment><class><name>RPCEncMarshalingContext</name><environment>WebServices</environment><super>WebServices.MarshalingContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SOAP</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.RPCEncMarshalingContext</class-id><body>RPCEncMarshalingContext class is used by XML-to-Smalltalk marshalers to marshal and unmarshal the RPC/encoded style.</body></comment><class><name>CollectionObjectMarshaler</name><environment>WebServices</environment><super>WebServices.ObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementMarshaler </inst-vars><class-inst-vars>defaultSmalltalkClass </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.CollectionObjectMarshaler</class-id><body>CollectionObjectMarshaler  converts XML sequence elements and/or their parts to Smalltalk collection objects and vice versa.Instance Variables	elementMarshaler	&lt;ElementMarshaler&gt; item marshalerClass Instance Variables	defaultSmalltalkClass	&lt;String&gt; default collection class name</body></comment><class><name>SimpleTypeMarshaler</name><environment>WebServices</environment><super>WebServices.XMLTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.SimpleTypeMarshaler</class-id><body>The class  is super class for simple object marshalersInstance Variables	attributes &lt;OrderedCollection of: XML.Attribute&gt; XML attributes the marshaler was created from</body></comment><class><name>ChoiceMarshaler</name><environment>WebServices</environment><super>WebServices.SequentialMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>useStructAsChoiceValue </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ChoiceMarshaler</class-id><body>ChoiceMarshaler unmarshals/marshals the xml choice element item to a dictionary. The marshaler holds all possible element marshalers and while unmarshaling/marshaling replaces the marshaler in MarshalingContext by the real one. Class Instance Variables	useStructAsChoiceValue	&lt;Boolean&gt; if the option is set to true the choice marshaler wil unmarshal the result as Struct. Default value is false and the unmarshaled result value will be an ordered collection of associations</body></comment><class><name>ElementMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ElementMarshaler</class-id><body>Relation marshaler that marshals/unmarshals a named element   (&lt;element name="customer"  type="tns:Customer"/&gt;</body></comment><class><name>StructMarshaler</name><environment>WebServices</environment><super>WebServices.ComplexObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.StructMarshaler</class-id><body>The marshaler converts  XML complex elements and/or their parts to Struct and vice versa. </body></comment><class><name>IdentityStructMarshaler</name><environment>WebServices</environment><super>WebServices.StructMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.IdentityStructMarshaler</class-id><body>The marshaler converts  XML complex elements and/or their parts to IdentityDictionary and vice versa. </body></comment><class><name>AspectImplementation</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name getBlock setBlock validateBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.AspectImplementation</class-id><body>This class encapsulates implementation of object parts. In other words, it implements object part access protocol. Examples are: dictionary aspects (at:/at:put: protocol), object aspects (perform:/perform:with protocol), collection (at:/at:put: protocol), stream (next, nextPut: protocol and more. It is used by XML-to-object marshalers to provide 'glue' connecting type marshalers with their part (relation) marshalers but can be used in other scenarios where objects have to be assembled/disassembled based on meta-information. The implementation consists simply of three blocks to initialize, get and set aspect. Arguments are object representing relation (it has to respond to messages #getSelector and #setSelector); parent object, value to be set and context. The latter one can be used to contain temporary values such as index for populating collection, etc). Instance Variables	name	&lt;String&gt; name of aspect implementation. Only used for descriptive purposes	getBlock	&lt;BlockContext&gt; Three-argument block:	setBlock	&lt;BlockContext&gt; Four-argument block	validateBlock	&lt;BlockContext&gt; Three-argument blockShared Variables	AssociationAspects	&lt;BlockContext&gt; aspect implementation for associations (#key:value:)	DictionaryAspects	&lt;Dictionary&gt; Registry of aspect implementations	IdentityDictionaryAspects	&lt;BlockContext&gt; aspect implementation for identity dictionaries (at:/at:put:)	ObjectAspects	&lt;BlockContext&gt; aspect implementation for objects (perform:/perform:with:)	SequenceableCollectionAspects	&lt;BlockContext&gt; aspect implementation for dictionaries (at:/at:put:)	StreamAspects	&lt;BlockContext&gt; aspect implementation for streams (next/nextPut:)Where:	object -- object whose relation is to be get or set	relation -- should respond to #getSelector/#setSelector although other implementations are possible	value -- value which is about to be set for specified relation	marshalingContext -- provides context. Currently only used for collection aspects</body></comment><class><name>BindingBuilder</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextStack binding needToResolveList needToResolveTypes oldBinding addSuperClassType </inst-vars><class-inst-vars>numberPolicy doublePrintPolicy floatPrintPolicy decimalPrintPolicy schemaParser createBindingForSchema xmlStringLegalCharacters xmlBooleanLegalCharacters excludedSupers addSuperClassType </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.BindingBuilder</class-id><body>This class builds XML-to-object bindings from marshaler prototypes stored in the Registry. A number of the prototypes are simple object marshalers that marshal strings, numbers, etc. These use conversion blocks to serialize and deserialize values. The blocks are stored in dictionaries keyed by conversion id. All errors raised while encoding/decoding are subclasses of XMLDatatypeError. The BindingBuilder enforces XML datatype restrictions. For backward-compatibility the decoding errors implement a default action allowing the technically invalid values to decode anyway. However for encoding the datatype restrictions will be strictly enforced. The encoding restrictions can be by-passed by resuming the exceptions with encoded string representation of the value.Encoding simple types is based on http://www.w3.org/TR/xmlschema-2/	Implementation Notes:When building a binding from its XML specification, the BindingBuilder maintains a stack of marshalers allowing it to link marshalers together. Marshalers refer to other marshaler using 'ref' attribute. Forward reference are possible, so the builder maintains a needToResolve list which should be empty when the binding has been built.Each marshaler should respond to	setAttributes:in:	validate	add:	addTo:methodsInstance Variables	contextStack	&lt;List of Dictionary&gt; context stack	binding	&lt;XMLObjectBinding&gt; binding (usually root element)	needToResolveList	&lt;OrderedCollection&gt; list of forward references	needToResolveTypes	&lt;OrderedCollection&gt; list of forward references to types	oldBinding	&lt;XMLObjectBinding&gt; the builder saves the old binding until a new one is loaded. If the builder is not able to load a new binding it will restore the old one.	addSuperClassType	&lt;Boolean&gt; is used to create the binding from type pragma descriptions. If option is set to true all super classes will be added to the binding.Class Instance Variables	numberPolicy	&lt;NumberPrintPolicy&gt; 	doublePrintPolicy	&lt;NumberPrintPolicy&gt; 	floatPrintPolicy	&lt;NumberPrintPolicy&gt; 	decimalPrintPolicy	&lt;NumberPrintPolicy&gt; 	schemaParser	&lt;XMLTypeParser&gt; 	createBindingForSchema	&lt;Boolean&gt; option if true default x2o binding will be created for inline &lt;schema&gt; element	xmlStringLegalCharacters	&lt;Array&gt; Array with: Character tab with: Character cr with:  Character lf	xmlBooleanLegalCharacters	&lt;Array&gt; Array with: 'true' with: 'false' with: '1' with: '0'	excludedSupers	&lt;Collection&gt; list of classes that are not added as super classes to a binding while reading type pragmas	addSuperClassType	&lt;Boolean&gt; default for including super classes while reading type pragmasShared Variables	Deserializers	&lt;OrderedCollection&gt; collection of deserializers that converts XML datatypes to Smalltalk objects	Registry	&lt;Dictionary&gt; XML element to marshaler mapping	Serializers	&lt;OrderedCollection&gt; collection of serializers that converts Smalltalk objects to XML datatypesClass Variables	numberPolicy &lt;NumberPrintPolicy&gt; is used to serialize decimal, float and double types	doublePrintPolicy &lt;Array&gt; print format to serialize doubles	decimalPrintPolicy &lt;Array&gt; print format to serialize decimals	floatPrintPolicy &lt;Array&gt; print format to serialize floats	schemaParser &lt;XMLTypesParser&gt; default types parser that creates XML to object binding specification	createBindingForSchema &lt;Boolean&gt; defines whether or not to create XML to object binding while decoding &lt;schema&gt; element. Setting this option to true will allow to create default XML to object binding for the schema element and unmarshal the DiffGram format. Default is false and decoder will return the XML schema element.	xmlStringLegalCharacters &lt;Array&gt; list of valid XML string characters such as cr, lf and tab	xmlBooleanLegalCharacters &lt;Array&gt; list of valid XML boolean values such as true, false. 1, 0</body></comment><class><name>UnresolvedPragmaReferences</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WSPragmaSupport</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>UnresolvedPragmaReferences</class-id><body>The exception is raised BindingBuilder if there is any unresolved references while reading type pragmas</body></comment><class><name>ListMarshaler</name><environment>WebServices</environment><super>WebServices.SimpleTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ListMarshaler</class-id><body>ListMarshaler represents the XML list type marshaler.http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#list-datatypeshttp://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#element-listInstance Variables	marshaler	&lt;SimpleObjectMarshaler &gt; the list item marshaler	itemTypeMarshaler	&lt;SimpleObjectMarshaler&gt; </body></comment><class><name>KeyObjectMarshaler</name><environment>WebServices</environment><super>WebServices.ComplexObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.KeyObjectMarshaler</class-id><body>KeyObjectMarshaler represents marshaler for object key. Together with KeyRefObjectMarshaler the marshaler resolves object identityInstance Variables	relations	&lt;OrderedCollection of RelationMarshaler&gt; the key marshaler relations</body></comment><class><name>KeyRefObjectMarshaler</name><environment>WebServices</environment><super>WebServices.KeyObjectMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.KeyRefObjectMarshaler</class-id><body>KeyRefObjectMarshaler represents marshaler for object key reference. Together with KeyObjectMarshaler the marshaler resolves object identityInstance Variables:	keyRef	&lt;KeyObjectMarshaler&gt;	marshaler for the &lt;keyRef&gt; Node Tag</body></comment><class><name>AttributeGroupMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.AttributeGroupMarshaler</class-id><body>Relation marshaler that represents a reference to ModelAttributeGroupMarshaler</body></comment><class><name>HrefMarshaler</name><environment>WebServices</environment><super>WebServices.XMLTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value source numberRefs hrefAttributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.HrefMarshaler</class-id><body>HrefMarshaler represents a value holder for multi-referenced Smalltalk objects and XML elements. Instance Variables:	hrefAttributes	&lt;OrderedCollection&gt;	 href attribute 	numberRefs	&lt;ArithmeticValue&gt;	number referencies to the object	source	&lt;XML.Element&gt;	XML element with id attribute	value	&lt; MarshalingContext&gt; instance of MarshalingContext</body></comment><class><name>AnyRelationMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaces processContents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.AnyRelationMarshaler</class-id><body>AnyRelationMarshaler marshal/unmarshal XML element &lt;any&gt;http://www.w3.org/TR/xmlschema-1/#Wildcard_detailsInstance Variables	namespaces	&lt;String&gt; one of: ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)	processContents	&lt;Symbol&gt; (lax | skip | strict)</body></comment><class><name>Relation</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name getSelector setSelector minOccurs maxOccurs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.Relation</class-id><body>This class represents a relation between an object and its part. In other words, it represents an aspect of an object. A relation has a descriptive name, get- and set- 'selector' and cardinality constraints. Note that the meaning of get- and set-selector totally depends on aspect implementation for that relation. For object aspects, for example, it represents real selectors; for dictionary aspects these ar keys for at: and at:put: methods.Instance Variables	name	&lt;XML.NodeTag&gt;	relation name	getSelector	&lt;Symbol&gt;	get selector	setSelector	&lt;Symbol&gt;	set selector	minOccurs	&lt;Integer&gt;	min cardinality	maxOccurs	&lt;Integer&gt;	max cardinality</body></comment><class><name>ManyRelation</name><environment>WebServices</environment><super>WebServices.Relation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collectionClass </inst-vars><class-inst-vars>useExactCollectionType </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ManyRelation</class-id><body>Many relation is implemented as a collection of values and used to marshal repreating groups and contents of a sequenceInstance Variables	collectionClass	&lt;Class&gt; collection classClass Instance Variables	useExactCollectionType	&lt;Boolean&gt; if the option is set true the marshaler will validate a collection class against #smalltalkClass inst var. If the class is different WrongObjectType exception  will be raised</body></comment><class><name>UnionMarshaler</name><environment>WebServices</environment><super>WebServices.SimpleTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshalers memberTypeMarshalers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.UnionMarshaler</class-id><body>The marshaler unmarshals/marshals the xml union element. The marshaler holds union member type marshalers and tries to use them  in the order in which they appear in the definition until a match is found. The evaluation order can be overridden with the use of xsi:type. Instance Variables	marshalers &lt;OrderedCollection&gt; union member type marshalers	memberTypeMarshalers &lt;Array&gt; temp collection of 'memberType" attribute marshalers. The collection is used to preserve the definition order.http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#element-unionhttp://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#union-datatypes</body></comment><class><name>TaggedObject</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace type value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.TaggedObject</class-id><body>The class is used to pass an object to AnyRelationMarshaler and AnyAttributeMarshaler. The namespace and type define a tag that is used to find relational marshaler to marshal an object in value.Instance Variables	namespace	&lt;String&gt; relational marshaler tag namespace 	type	&lt;String&gt; relational marshaler tag type 	value	&lt;Object&gt; object to marshal or unmarshaled object</body></comment><class><name>TextMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.TextMarshaler</class-id><body>The marshaler that marshalrs/unmarshals an element text value xpath::text()</body></comment><class><name>OneRelation</name><environment>WebServices</environment><super>WebServices.Relation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.OneRelation</class-id><body>OneRelation implements relations with cardinality 0 or 1 and its result is a scalar value.Instance Variables:</body></comment><class><name>AnyCollectionMarshaler</name><environment>WebServices</environment><super>WebServices.AnyRelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.AnyCollectionMarshaler</class-id><body>The class is deprecated. Use AnyRelationMarshaler with defined cardinality instead. &lt;any aspect="someAspect" maxOccurs="unbounded"/&gt;</body></comment><class><name>ChoiceRelation</name><environment>WebServices</environment><super>WebServices.ChoiceMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ChoiceRelation</class-id><body>ChoiceRelation is deprecated. Use ChoiceMarshaler instead.</body></comment><class><name>XMLMarshalerProxy</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent xpathPrefix xpathSuffix xpathExpression xpathNode namespaceFilter namespaces allNamespaces requiredAttributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.XMLMarshalerProxy</class-id><body>This class is a 'bridge' between XML marshaler and XPath parser. It is responsible for preparing information and delegating to XPath.Instance Variables:	parent	&lt;XMLTypeMarshaler&gt;	description of variable's function	xpathPrefix	&lt;String&gt;	prefix of xpath expression i.e. 'self::'	xpathSuffix	&lt;String&gt;	suffix of xpath expression i.e. 'text()'	xpathExpression	&lt;String&gt;	actual expression used	xpathNode	&lt;XPathStep&gt;	xpath parser that does parsing/generation	namespaceFilter	&lt;Symbol&gt;		hack to screen off by namespace (mostly for ##other)	namespaces	&lt;Dictionary&gt;	map of namespaces for this node	allNamespaces	&lt;Dictionary&gt;	map of all namespaces in scope	requiredAttributes	&lt;Dictionary&gt;	allows to add attributes while marshaling. key: XML attribute key, value: XML attribute value	namespaceRequired	&lt;Boolean&gt;	specifies where or not the namespace is required for the element</body></comment><class><name>RestrictionMarshaler</name><environment>WebServices</environment><super>WebServices.XMLTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>restrictionType fixed id value parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.RestrictionMarshaler</class-id><body>RestrictionMarshaler sets validation rules for the simple type marshaler value. Right now supported only enumeration values.Instance Variables	restrictionType	&lt;String&gt; restriction type. 	 fixed 	&lt;Boolean&gt;  boolean : false	id 		&lt;String&gt;  ID type 	value     &lt;Object&gt;  restriction value&lt;restriction  base = QName  id = ID  {any attributes with non-schema namespace . . .}&gt;  Content: (annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))&lt;/restriction&gt;http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#rf-facets</body></comment><class><name>BindingImport</name><environment>WebServices</environment><super>WebServices.XMLMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace location </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.BindingImport</class-id><body>BindingImport represents location of import binding.Instance Variables	namespace	&lt;String&gt; import binding  namespace	location	&lt;String&gt; import binding location</body></comment><class><name>UnorderedMarshaler</name><environment>WebServices</environment><super>WebServices.CompositorMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.UnorderedMarshaler</class-id><body>The class uses XPath to collect child nodes to unmarshal a complex type. By default this marshaler is created for &lt;all&gt; model group schema component</body></comment><class><name>ImplicitMarshaler</name><environment>WebServices</environment><super>WebServices.RelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.ImplicitMarshaler</class-id><body>Relation marshaler that marshals/unmarshals an element reference (&lt;element ref="tns:Customer"/&gt;</body></comment><class><name>XMLObjectBinding</name><environment>WebServices</environment><super>WebServices.XMLMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshalers classMap targetNamespace registeredKeys importedBindings defaults imports useTaggedObject usePrefixedSchemaTags </inst-vars><class-inst-vars>useReference useInlineType useNilAttribute nillableDefault allowDerivedTypes nilNodeTag xmlEncoding defaultTargetNamespace useTaggedObject usePrefixedSchemaTags </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.XMLObjectBinding</class-id><body>This class serves as marshalers repository for a specified target namespace. The class can create X2O and XML Schema specifications. It can respond to requests to find marshaler for specified XML node or Smalltalk object. Bindings may import other bindings. If a binding can't properly translate XML or object to marshaler, it will ask its imported bindings and then the global repository (XMLBindingRegistry).An instance of the create is created by Binding Builder from X2O specification. To create X2O specification see XMLTypeParser.Instance Variables	marshalers	&lt;OrderedCollection of: XMLTypeMarshaler&gt; all marshalers	classMap	&lt;IdentityDictionary&gt; key -- Smalltalk class, value -- XMLNodeTag. Used to locate marshaler for Smalltalk object by its class	targetNamespace	&lt;String&gt; attribute #targetNamespace of this binding	registeredKeys	&lt;OrderedCollection of: KeyObjectMarshaler&gt; all key object marshalers	importedBindings	&lt;OrderedCollection of: XMLObjectBinding&gt; imported bindings	defaults	&lt;Dictionary&gt; holds some binding defaults such as  #attributeFormDefault/#elementFormDefault/#defaultQualifier	imports	&lt;OrderedCollection of:BindingImport&gt; is used to create X2O specification	useTaggedObject	&lt;Boolean&gt; if the option is set to false the AnyRelationMarshaler will try to find an object marshaler by the object class name which doesn't guarantee creating correct XML node. By default the option is true.	usePrefixedSchemaTags	&lt;Boolean&gt; the option defines if XML nodes should be encoded explicitly qualifiedClass Instance Variables	useReference	&lt;Boolean&gt; This option chooses whether or not to use multi-reference encoding for identical objects (id/href attributes) which means that the only object will be encoded with some id attribute. The rest of the identical objects will be encoded as a reference (href) to this id. Choosing this option preserves object identity.	useInlineType	&lt;Boolean&gt; This option chooses whether or not to add the inline type to a node when a message is marshaled.	useNilAttribute	&lt;Boolean&gt; This option chooses whether or not to encode nil objects. The default is false which means that a nil object won''t be encoded or in other words the element will be skipped while writing XML. A	nillableDefault	&lt;Boolean&gt; This option allows to change the XML schema default for nillable attribute.	allowDerivedTypes	&lt;Boolean&gt; Setting this option to on will allow marshaling derived objects when a type is described with a superclass marshaler. The default option is false. The marshaling manager will search a marshaler for each collection item instead of reusing an item marshaler.	nilNodeTag	&lt;NodeTag&gt; 	xmlEncoding	&lt;String&gt; is used in XML prolog	defaultTargetNamespace	&lt;String&gt; default target namespace	useTaggedObject	&lt;Boolean&gt; if the option is set to false the AnyRelationMarshaler will try to find an object marshaler by the object class name which doesn't guarantee creating correct XML node. By default the option is true.	usePrefixedSchemaTags	&lt;Boolean&gt; the default option defines if XML nodes should be encoded explicitly qualifiedShared Variables	Sm2XMLTypeRegistry	&lt;Dictionary&gt; simple Smalltalk types mapping to xml types	XMLBindingRegistry	&lt;Dictionary&gt; xml to object binding registry</body></comment><class><name>AnyAttributeMarshaler</name><environment>WebServices</environment><super>WebServices.AnyRelationMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.AnyAttributeMarshaler</class-id><body>The marshaler marshal/unmarshal XML attribute described as &lt;anyAttribute&gt;</body></comment><class><name>XMLObjectMarshalingManager</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binding registeredObjects keyToObjectTable needToResolveList idMap idMapReverse significantNamespaces currentId qualifierMap suffixMap refTag idTag wildcardScope </inst-vars><class-inst-vars>refTagDefault idTagDefault </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.XMLObjectMarshalingManager</class-id><body>This class serves as a manager during marshaling and unmarshaling XML messages. At any point during either marshaling or unmarshaling a specific element marshaler may find out that it does not have enough information to compute sub-element marshaler and need to consult the manager.Instance Variables	binding	&lt;XMLObjectBinding&gt; master binding	registeredObjects	&lt;Dictionary&gt; Dictionary of (registered object-&gt;marshaler). Old implementation used registeredObjects to hold marshales for &lt;any&gt;.  The registry is still used to check for specific marshaler but expected that marshaler information for &lt;any&gt; is provided by TaggedObject. For more information see documentation for AnyRelationMarshaler.	keyToObjectTable	&lt;Dictionary&gt; Dictionary or ((KeyObjectMarshaler-&gt;OrderedCollection or key fields))-&gt;key value	needToResolveList	&lt;OrderedCollection&gt; OrderedCollection of (XMLNodeTag-&gt;aBlock) these represent forward references (unresolved XML Node tags  refs for which there are no corresponding marshalers yet)	idMap	&lt;Dictionary&gt; key is id string and value is HrefMarshaler	idMapReverse	&lt;Dictionary&gt; key is HrefMarshaler value  and value is HRefMarshaler	significantNamespaces	&lt;Dictionary&gt; Dictionary of namespaces to add to Soap envelope	currentId	&lt;Number&gt; is used to create unique id	qualifierMap	&lt;Dictionary&gt; holds existing qualifiers.The key is a namespace, the value is the namespace qualifier	suffixMap	&lt;Dictionary&gt; the key is a namespace qualifier prefix and the value a count for the qualifier	refNode	&lt;NodeTag&gt; ref or href node is used with #id to resolve object identity	idNode	&lt;NodeTag&gt; id node	wildcardScope	&lt;Collection of: XMLObjectBinding&gt; defines X2O bindings where the marshalers for AnyRelationMarshaler will be searched. It is a good idea to limit an element marshaler search scope if AnyRelationMarshaler namespace id defined as #anyClass Instance Variables	refNodeDefault	&lt;NodeTag&gt; default node tag with type "href" is used in identifying node refences	idNodeDefault	&lt;NodeTag&gt; default node tag with type "id" is used in identifying node refences</body></comment><class><name>SimpleObjectMarshaler</name><environment>WebServices</environment><super>WebServices.SimpleTypeMarshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conversionId serializationBlock deserializationBlock baseType smalltalkClass restrictions validate </inst-vars><class-inst-vars>validate </class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.SimpleObjectMarshaler</class-id><body>The class  converts simple XML elements and/or their parts to Smalltalk objects and vice versa. The simple XML elements correspond to the objects which have opaque structure and are serialized/deserialized 'magically' (examples are most simple Smalltalk objects -- strings, measurements, etc). While marshaling/unmarshaling can validate enumeration values.Instance Variables	conversionId	&lt;String&gt;	conversionId to find deserializationBlock/serializationBlock	serializationBlock	&lt;BlockClosure&gt;  serializationBlock Smalltalk object to converts XML type	deserializationBlock	&lt;BlockClosure&gt;	 deserializationBlock converts XML type to Smalltalk object	baseType &lt;XMLTypeMarshaler&gt; the super type	smalltalkClass &lt;Class&gt; simple type  class is set from the smalltalkClass attribute if present or from conversionId	restrictions &lt;OrderedCollection of RestrictionMarshaler&gt; </body></comment><class><name>UnresolvedReferenceSignal</name><environment>WebServices</environment><super>WebServices.XMLObjectBindingSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.UnresolvedReferenceSignal</class-id><body>UnResolvedReferenceSignal is error signaling that the XML element reference was not mapped to a Smalltalk object</body></comment><class><name>XMLObjectDriver</name><environment>WebServices</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-To-Object</category><attributes><package>XMLObjectMarshalers</package></attributes></class><comment><class-id>WebServices.XMLObjectDriver</class-id><body>XML SAX driver for parsing X2O specifications.Instance Variables	builder	&lt;BindingBuilder&gt; </body></comment><shared-variable><name>Registry</name><environment>WebServices.BindingBuilder</environment><private>false</private><constant>false</constant><category>registries</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>Deserializers</name><environment>WebServices.BindingBuilder</environment><private>false</private><constant>false</constant><category>registries</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>Serializers</name><environment>WebServices.BindingBuilder</environment><private>false</private><constant>false</constant><category>registries</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>ObjectAspects</name><environment>WebServices.AspectImplementation</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>AssociationAspects</name><environment>WebServices.AspectImplementation</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>DictionaryAspects</name><environment>WebServices.AspectImplementation</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>IdentityDictionaryAspects</name><environment>WebServices.AspectImplementation</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>StreamAspects</name><environment>WebServices.AspectImplementation</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>SequenceableCollectionAspects</name><environment>WebServices.AspectImplementation</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>Restrictions</name><environment>WebServices.RestrictionMarshaler</environment><private>false</private><constant>false</constant><category>restrictions</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>RaiseMissingValueException</name><environment>WebServices.ObjectMarshaler</environment><private>false</private><constant>false</constant><category>default</category><initializer>nil</initializer><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>UnresolvedValue</name><environment>WebServices.MarshalingContext</environment><private>false</private><constant>false</constant><category>unresolved value</category><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>XMLBindingRegistry</name><environment>WebServices.XMLObjectBinding</environment><private>false</private><constant>false</constant><category>accessing bindings</category><initializer>Dictionary new</initializer><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><shared-variable><name>Sm2XMLTypeRegistry</name><environment>WebServices.XMLObjectBinding</environment><private>false</private><constant>false</constant><category>accessing bindings</category><initializer>nil</initializer><attributes><package>XMLObjectMarshalers</package></attributes></shared-variable><methods><class-id>WebServices.XMLMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">attributes	^attributes isNil		ifTrue: [ attributes := Dictionary new ]		ifFalse: [ attributes ]</body><body package="XMLObjectMarshalers">attributes: anObject	^attributes := anObject</body><body package="XMLObjectMarshalers">attributesAt: anAttributeName put: aValue	^self attributes at: anAttributeName put: aValue</body><body package="XMLObjectMarshalers">documentation	^documentation</body><body package="XMLObjectMarshalers">documentation: aString	documentation := aString</body><body package="XMLObjectMarshalers">name	^name</body><body package="XMLObjectMarshalers">name: aNodeTag	name := aNodeTag</body><body package="XMLObjectMarshalers">params	^params isNil 		ifTrue: [ params := Dictionary new]		ifFalse: [ params ]</body><body package="XMLObjectMarshalers">params: aDictionary 	params := aDictionary</body><body package="XMLObjectMarshalers">parent 	^nil</body><body package="XMLObjectMarshalers">path	^name == nil ifTrue: [ tag] ifFalse: [name]</body><body package="XMLObjectMarshalers">tag	^tag</body><body package="XMLObjectMarshalers">tag: aNodeTag	tag := aNodeTag</body></methods><methods><class-id>WebServices.XMLMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">add: aMarshaler" Add sub-marshaler. Do it via double dispatch because sub-marshaler knows how to plug itself to its parent -- distinguishes element and attribute marshaler "	aMarshaler addTo: self</body><body package="XMLObjectMarshalers">add: aMarshaler to: aParentMarshaler" Add sub-marshaler. Do it via double dispatch because sub-marshaler knows how to plug itself to its parent -- distinguishes element and attribute marshaler "	aMarshaler addTo: self</body><body package="XMLObjectMarshalers">addElementMarshaler: aMarshaler</body><body package="XMLObjectMarshalers">addTo: aParentMarshaler" Add myself to my parent. This method is overridden in attribute resolver so that we distinguish between element resolvers and attribute resolvers "	aParentMarshaler addElementMarshaler: self.</body><body package="XMLObjectMarshalers">detect: attrName in: attributesx	^(attributesx keys detect: [ :k | [k type =  attrName] on: Error do: [ :ex | ex return: false]] ifNone: [nil])</body><body package="XMLObjectMarshalers">findDomainValue: attrName in: attributesx	^(self detect: attrName in: attributesx) ifNotNil: [ :attr | attributesx at: attr ]</body><body package="XMLObjectMarshalers">findValue: attrName in: attributesx	| attr  |	(attr := self detect: attrName in: attributesx) notNil		ifTrue: [ attr := attributesx at: attr ].	^(attr notNil and: [attr isKindOf: NodeTag]) 		ifTrue:  [ attr type]		ifFalse: [ attr ]</body><body package="XMLObjectMarshalers">finish	" Do nothing, validate yourself and throw an exception if not valid "</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder	attributesx keysAndValuesDo: [ :key :val | self attributesAt: key put: val].	self setLocalAttributesFrom: attributesx in: builder</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	name := self findDomainValue: 'name' in: attributesx.	(tag := self findDomainValue: 'tag' in: attributesx) 		ifNil: [ tag := name ifNil: [tag := self findDomainValue: 'ref' in: attributesx ]].</body></methods><methods><class-id>WebServices.XMLMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	params := self params copy.	attributes := self attributes copy.</body></methods><methods><class-id>WebServices.XMLMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">newProxyFor: aString</body></methods><methods><class-id>WebServices.XMLMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlName	^self name ifNotNil: [ self name type ]</body></methods><methods><class-id>WebServices.XMLMarshaler</class-id> <category>enumeration</category><body package="XMLObjectMarshalers">nodesDo: aBlock 	self nodesDo: aBlock withRegistry: IdentitySet new</body><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet</body></methods><methods><class-id>WebServices.XMLMarshaler class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">new	^super new initialize</body><body package="XMLObjectMarshalers">newProxyFor: aString	^self new		newProxyFor: aString;		yourself</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	^self subclassResponsibility</body><body package="XMLObjectMarshalers">createInstanceFor: marshalingContext" Callback from the manager. Invoked when object is to be resolved by creating a new instance of the object. Can be overridden i.e. by collection marshalers. "	^[self smalltalkClass new] 		on: Error do: [ :ex | self smalltalkClass basicNew]</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext	self 		decodeAndUnmarshalFrom: marshalingContext 		do: [ :mc | ^mc value ].	self error: (#FailedToUnmarshalForwardRef &lt;&lt; #webservices &gt;&gt; 'Failed to unmarshal (forward reference?)')</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext do: aBlock	|  nodes  |	nodes := self getSourceFrom: marshalingContext. 	marshalingContext nodeContext: nodes. 	self unmarshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">getRealMarshaler: marshalingContext unmarshal: anElement	"Returns self. ComplexObjectMarshaler can return marshaler for derived types  "	^self</body><body package="XMLObjectMarshalers">getSourceFrom: marshalingContext	^xpath getSourceFrom: marshalingContext</body><body package="XMLObjectMarshalers">newInstanceFor: marshalingContext" Callback from the manager. Invoked when object is to be resolved by creating a new instance of the object. Can be overridden i.e. by collection marshalers. If smalltalkClass is not specified, returns Unresolved value. The effect is that somebody else will have to resolve object "	 self smalltalkClass isNil ifTrue: [ ^MarshalingContext unresolvedValue].	^self createInstanceFor: marshalingContext</body><body package="XMLObjectMarshalers">resolveFrom: marshalingContext do: aBlock	self unmarshalKeyRefFrom: marshalingContext.	marshalingContext manager 		resolveFrom: marshalingContext 		do: [ :object | 			marshalingContext value: object.			aBlock value: object].</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext	self 		unmarshalFrom: marshalingContext 		do: [ :object | ^object ].	self error: (#FailedToUnmarshalForwardRef &lt;&lt; #webservices &gt;&gt; 'Failed to unmarshal (forward reference?)')</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	^self subclassResponsibility</body><body package="XMLObjectMarshalers">unmarshalHRefFrom: aMarshalingContext	^false</body><body package="XMLObjectMarshalers">unmarshalKeyRefFrom: marshaledValue	| childMc |	keyRefMarshaler notNil		ifTrue:			[childMc := marshaledValue parent copy.			childMc marshaler: keyRefMarshaler.			childMc nodeContext: (OrderedCollection with: childMc source).			keyRefMarshaler 				unmarshalFrom: childMc 				do: [ :mc |					childMc value first 						ifNotNil: [marshaledValue keyRef: ((keyRefMarshaler keyRef)-&gt;(childMc value))]]]</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">canBeMultiref	^false</body><body package="XMLObjectMarshalers">inheritsFrom: aTypeMarshaler	^false</body><body package="XMLObjectMarshalers">isAbstract	^false</body><body package="XMLObjectMarshalers">isAnyAttributeMarshaler	^false</body><body package="XMLObjectMarshalers">isAnyRelationMarshaler	^false</body><body package="XMLObjectMarshalers">isAttribute	^false</body><body package="XMLObjectMarshalers">isAttributeGroup	^false</body><body package="XMLObjectMarshalers">isAttributeMarshaler	^false</body><body package="XMLObjectMarshalers">isChoiceMarshaler	^false</body><body package="XMLObjectMarshalers">isCollectionType	^false</body><body package="XMLObjectMarshalers">isComplexTypeMarshaler	^false</body><body package="XMLObjectMarshalers">isCompositorMarshaler	^false</body><body package="XMLObjectMarshalers">isElement	^false</body><body package="XMLObjectMarshalers">isGlobal	^false</body><body package="XMLObjectMarshalers">isGroup	^false</body><body package="XMLObjectMarshalers">isImplicit	^false</body><body package="XMLObjectMarshalers">isLike: anXmlNodeTag	| ref |	^(ref := self path) notNil 		and: [anXmlNodeTag isString				ifTrue: [ref type = anXmlNodeTag]				ifFalse: [ref isLike: anXmlNodeTag]]</body><body package="XMLObjectMarshalers">isListType	^false</body><body package="XMLObjectMarshalers">isLocalType	^self params at: #isLocalType ifAbsent: [false]</body><body package="XMLObjectMarshalers">isModelAttributeGroup	^false</body><body package="XMLObjectMarshalers">isModelGroup	^false</body><body package="XMLObjectMarshalers">isObjectType	^false</body><body package="XMLObjectMarshalers">isObjectTypeMarshaler	^false</body><body package="XMLObjectMarshalers">isRelationMarshaler	^false</body><body package="XMLObjectMarshalers">isSimpleType	^false</body><body package="XMLObjectMarshalers">isStructMarshaler	^false</body><body package="XMLObjectMarshalers">isText	^false</body><body package="XMLObjectMarshalers">isType	^self symbolSpace = #type</body><body package="XMLObjectMarshalers">isTypeMarshaler			^true</body><body package="XMLObjectMarshalers">isUnionType	^false</body><body package="XMLObjectMarshalers">qualified	^qualified == nil		ifTrue: [ self binding ifNotNil: [ self binding elementQualified] ifNil: [false] ]		ifFalse: [qualified ]</body><body package="XMLObjectMarshalers">shouldBeQualified	^self qualified</body><body package="XMLObjectMarshalers">unqualified	^self qualified not</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">attributesAt: anAttributeName put: aValue	^self attributes at: anAttributeName put: aValue</body><body package="XMLObjectMarshalers">binding	^binding</body><body package="XMLObjectMarshalers">compositor	^nil</body><body package="XMLObjectMarshalers">inlineTypeNode</body><body package="XMLObjectMarshalers">key	^self symbolSpace-&gt;self tag</body><body package="XMLObjectMarshalers">keyRefMarshaler	^keyRefMarshaler</body><body package="XMLObjectMarshalers">marshalingContextClass	^nil</body><body package="XMLObjectMarshalers">qualified: aBoolean	qualified := aBoolean</body><body package="XMLObjectMarshalers">relation" Everybody except relation marshalers answers nil. This plays a role when unmarshaling ANY. If actual marshaler does not represent a relation but type, ANY marshaler may provide aspect info instead (see AnyRelationMarshaler&gt;&gt;unmarshalFrom: marshalingContext do: aBlock"	^nil</body><body package="XMLObjectMarshalers">smalltalkClass	^nil</body><body package="XMLObjectMarshalers">symbolSpace	^nil</body><body package="XMLObjectMarshalers">typeMarshaler" Answer object marshaler that represents a type, not relation. This means either simple type or complex object. Relation marshaler answer type marshaler of their real marshaler "	^self</body><body package="XMLObjectMarshalers">useInlineType	^self params at: #useInlineType ifAbsent: [nil ]</body><body package="XMLObjectMarshalers">xpath	^xpath</body><body package="XMLObjectMarshalers">xpath: anXMLMarshalerProxy	xpath := anXMLMarshalerProxy</body><body package="XMLObjectMarshalers">xpathExpression	^xpath xpathExpression</body><body package="XMLObjectMarshalers">xpathPrefix	^xpath notNil 		ifTrue: [ xpath xpathPrefix ] 		ifFalse: [ nil]</body><body package="XMLObjectMarshalers">xpathSuffix	^xpath xpathSuffix</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addKeyRefMarshaler: aMarshaler	keyRefMarshaler notNil		ifTrue: [self error: (#MultipleKeyRefsAreNotAllowed &lt;&lt; #webservices &gt;&gt; 'Multliple key refs are not allowed')].	keyRefMarshaler := aMarshaler</body><body package="XMLObjectMarshalers">addType: anXmlTypeMarshaler tag: aNodeTag" Add type marshaler. We don't care, only bindings do "</body><body package="XMLObjectMarshalers">registerWith: xmlObjectBinding</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder	super setAttributesFrom: attributesx in: builder.	xpath ifNotNil: [ xpath setAttributesFrom: attributesx in: builder for: self].	builder current ifNotNil: [:parent | parent add: self].	binding := builder binding.</body><body package="XMLObjectMarshalers">setIsLocalType	self params at: #isLocalType put: true</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	super setLocalAttributesFrom: attributesx in: builder.	"Added only to suppress inline style for body marshaler when wsdl binding has rpc/encoded.	As soon as rpc/encoded will be removed from support the option should be removed "	(self findDomainValue: 'useInlineType' in: attributesx) ifNotNil: [ :inline | 		self params at: #useInlineType put: (Boolean readFrom: inline readStream )].</body><body package="XMLObjectMarshalers">setNewNamespaceForTag: aNamespaceString qualifier: aQualifierString	self tag: 		(NodeTag  			qualifier: aQualifierString			ns: aNamespaceString 			type: self tag type)</body><body package="XMLObjectMarshalers">setXPathNode	xpath setXPathNode.</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	xpath := XMLMarshalerProxy new.</body><body package="XMLObjectMarshalers">on: aBinding	binding := aBinding</body><body package="XMLObjectMarshalers">typeMarshaler: aMarshaler	self shouldNotImplement</body><body package="XMLObjectMarshalers">xpathExpression: aString	xpath xpathExpression: aString</body><body package="XMLObjectMarshalers">xpathPrefix: aString	xpath xpathPrefix: aString</body><body package="XMLObjectMarshalers">xpathSuffix: aString	xpath xpathSuffix: aString</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>public</category><body package="XMLObjectMarshalers">visit: anObject	^self visit: anObject with: nil</body><body package="XMLObjectMarshalers">visit: anObject with: anObject1</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getRealMarshalerMarshal: aMarshalingContext" Answer self. ComplexObjectMarshaler can return a marshaler for derived types "	aMarshalingContext useInlineType		ifTrue: [self setInlineTypeFor: aMarshalingContext source marshalingContext: aMarshalingContext ].	^self</body><body package="XMLObjectMarshalers">inlineTypeKey	"returns  xsi:type "  	^NodeTag  		qualifier: 'xsi' 		ns: XMLObjectBinding defaultUriSchemaInstance 		type: 'type'</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext			^self subclassResponsibility</body><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext" Overridden in subclasses "	marshalingContext value == nil ifTrue: [MissingValueNotification raiseWith: self xpath xpathExpression].</body><body package="XMLObjectMarshalers">requiredAttributes	^xpath requiredAttributes</body><body package="XMLObjectMarshalers">setInlineTypeFor: anElement marshalingContext: aMarshalingContext	| key val str q |  	anElement isElement ifFalse: [^nil].	key := self inlineTypeKey. 	val := self inlineTypeNode.	q := aMarshalingContext addQualifierForTag: val.	str := q,':', val type asString.	anElement addAttribute: (Attribute name:  key value: str).	aMarshalingContext addNamespace: key namespace  qualifier: key qualifier</body><body package="XMLObjectMarshalers">setNodeAndMarshalFrom: marshalingContext" Create appropriate node(s) and then marshal contents "	marshalingContext value isNil		ifTrue: [MissingValueNotification raiseWith: self xpath xpathExpression].	^xpath 		setNodeAndMarshalFrom: marshalingContext 		do: [self privateMarshalFrom: marshalingContext ]</body><body package="XMLObjectMarshalers">setRequiredAttribute: aNode value: aNodeOrString	xpath requiredAttributes at: aNode put: aNodeOrString</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">selectXMLMarshalerFrom: xmlMarshalers	^xmlMarshalers size = 1		ifTrue: [xmlMarshalers first]		ifFalse: [ nil ]</body><body package="XMLObjectMarshalers">smalltalkClassName	^nil</body><body package="XMLObjectMarshalers">xmlType	^self tag</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	super postCopy.	xpath := xpath copy.	keyRefMarshaler := keyRefMarshaler copy.</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: aStream indentation: number</body><body package="XMLObjectMarshalers">printClassName: aClass on: stream		stream			nextPut: $" ;		nextPutAll: aClass name asString; 		nextPut: $"</body><body package="XMLObjectMarshalers">printOn: aStream	aStream		nextPutAll: self class name;		space.	xpath ifNotNil: [ xpath printOn: aStream ]</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>comparing</category><body package="XMLObjectMarshalers">= aMarshaler	aMarshaler class = self class ifFalse: [ ^ false ].	^self tag = aMarshaler tag</body><body package="XMLObjectMarshalers">hash	^self tag hash</body></methods><methods><class-id>WebServices.XMLTypeMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue:[^self].	anIdentitySet add: self.	xpath ifNotNil: [xpath nodesDo: aBlock withRegistry: anIdentitySet].	keyRefMarshaler		ifNotNil: [keyRefMarshaler nodesDo: aBlock withRegistry: anIdentitySet].	aBlock value: self</body></methods><methods><class-id>WebServices.XMLTypeMarshaler class</class-id> <category>documentation</category><body package="XMLObjectMarshalers">bindings" XML-to-object marshaling is performed by individual marshalers. These marshalers are usually grouped in Bindings. A binding describes a mapping of an XML schema or DTD to Smalltalk. IT IS NOT A SCHEMA. Therefore, given a schema, one should develop a binding for it so that xml documents generated according to this schema can be automatically converted to/from Smalltalk. Each binding has a target namespace (uri) and an optional name. All NCNAMEs defined in this binding belong to their target namespace. Each binding is represented by an instance of XMLObjectBinding or its subclass. The main purpose of a this class is to serve requests to loop up marshaler by its name (tag). Named bindings register themselves in XMLObjectBinding class-side binding registry. These bindings can be obtained by their name or namespace.Bindings are built from XML binding specs. A number of base bindings are published in WSDLBinding class&gt;&gt;defaults protocol. XMLTypesParser generates bindings from the XML schema. By default XMLTypesParser class&gt;&gt;readFrom: maps all XML complex types to smalltalk dictionaries (struct). The XMLTypesParser class&gt;&gt;useObjectBindingReadFrom: creates binding with mapping XML complex types to smalltalk classes. The smalltalk class name is defined from the XML element name. The binding created by the XMLTypesParser should be reviewed and customized if necessary. The BindingClassBuilder class&gt;&gt;createClassesFromBinding: loads the binding and creates Smalltalk classes from xmlToSmalltalk bindings."</body><body package="XMLObjectMarshalers">buildingBindings" Marshalers are mostly built from the XML binding specs. These are processed by BindingBuilder. Binding builder is a SAX application. This application maintains a context stack of marshalers and their namespaces. On start of new element, the builder tries to obtain an appropriate marshaler for this node. If found, binding builder then sends it message 	marshaler setAttributes: attrs in: selfMarshaler then initializes itself, its xpath marshaling proxy, etc. Marshaler invoke builder to link itself to its parent and to resolve qualifiers/namespaces. Marshalers use a  very simple double-dispatch scheme to links themselves together. Parents know their children but childrent do not keep pointer to their parent. Every marshaler registers itself by sending the builder message register:. The builder then sends message #add: to the marshaler on top of the context stack (to be parent of marshaler being processed). That marshaler turns around and send message #addTo: to the marshaler being processed. Message #addTo: is subclassed, that is, marshalers know how to add themselves to their parents. This way key marshalers will end up in different list then element marshalers; import 'marshaler' will add import record, etc.The top element on the stack is supposed to be a binding, so all top-levbel marshaler will add regiter themselves with the bindings.All registered marshaler types are stored in static variable Registry inside BindingBuilder. An application may register its own marshalers. An important point is regitry contains preconfigured instances of marshalers, not classes, it is prototype based. To create a new instance of marshaler we make a copy of entry in the registry. One can view registry entries as macros of sort. This allows to have a very small set of highly configurable marshaler types. This is convenient if you remember that every marshaler is a potentially small cluster of objects -- marshaler itself, its XPath proxy and parser and potentially relation description, aspect implementation and marshaler for the far side of the relation. An instance of RelationMarshaler can be configure to marshal elements, attributes or text; complex object marshaler can be configures to marshal objects, dictionaries, collections or streams. On top of it, xpath expression can be specified that would define rules of xml parsing/composition.To make it usable, the registry contains some of the most frequent and useful configurations (i.e. 'object' and 'struct', 'sequence_of', 'element', 'attribute', 'text', etc. These are not only preconfigured, but implicitly create xpath expression based on values of other attributes. See BindingBuilder&gt;&gt;initializePrototypeMarshalers"</body><body package="XMLObjectMarshalers">marshaling"Just like unmarshaling, marshaling of a node may invoke more than one marshaler. I.e. if a node represents element (which is association between tag and a type), a relation marshaler would set node tag, but type marshaler would complete marshaling of the contents. If a value that corresponds to the type would be marshaled alone, the type marshaler would have to do both parts. Therefore, a marshaler may be invoked in two different ways -- to set node and marshal and to just marshal contents. Before marshaling, marshalingContext&gt;&gt;value should contain the Smalltalk value to be marshaled. #setNodeAndMarshalFrom: marshalingContext	Sets node's tag and marshals contents.#marshalFrom: marshalingContext	Uses pre-set tag and marshals contentsMarshaling contents inolves generating XML and 'stitching' XML nodes together. All XML generation and stitching is done in xpath. XPath may have to create element node so that children can be marshaled. This should be done before marshaling contents. There are also things that can only be done AFTER marshaling contents (i.e. setting attribute value, adding text node). For this reason, this is done by xpath controlling execution and invoking callback block to marshal contents so it can then complete XML generation. After marshaling, marshalingContext&gt;&gt;source contains generated XML node, if any"</body><body package="XMLObjectMarshalers">metamodel" Marshaling from Smalltalk generates XML nodes; unmarshaling from XML yields Smalltalk object.Set of marshalers defines metamodel. This metamodel is as follows:There are two kinds of objects that can be marshaled to/from XML:- Simple objects 		Are identified by their conversion ID and are 'magically' marshaled/unmarshaled. Examples are numbers, strings, byte arrays, etc.- Objects with relations (Complex objects). These objects are described by their type and set of their relations with other objects. Relations can be implemented in a number of different ways and are a generalization of such notions as attributes, aspects, members of a collection, etc. Complex object knows how to get/set value for specific relation.- Relations are characterized by their name, implementation, cardinality and type of the far side. Implementation of a relation is represented by an instance of AspectImplementation. Examples are object aspects (perform:/perform:with: protocol), dictionary aspects (at:/at:put: protocol), etc. Relation provides enough info for the parent object that it can get/set value of this relation. "</body><body package="XMLObjectMarshalers">objectIdentityModel" Umarshaling process occurs in the following sequence:	1. Get source nodes	2. Resolve Smalltalk target (find instance of Smalltalk object corresponding to unmarshaled source)	3. Unmarshal source into targetStep 1 is responsibility of XPath parser. Step 2 typically involves creation of new instance of smalltalk class stored in the marshaler. However, in some cases we would like to relate xml node to already existing object. This is important in case of multi-reference nodes and other scenarios. These are resolved using approach that mimics XMLSchema approach using keys and key references. It is as follows:A TYPE may have zero or more keys. A key may consist of one or more fields. Each field maybe any XPath expression, although current implementation limits key generation to a simple XPath expression consisting of element or attribute name. Each key has a name. Key name is a qualified name whose namespace is target namespace of the binding. Since keys consist of parts, they are similar in their structure to complex types and use the same notation.A RELATION may have zero or one key ref marshaler. Key ref references key it corresponds to and must have the same number of fields as the corresponding key so that the fileds match in their respective types.In the presence of keys and key references object identity is resolved as follows:	1. When a type is being unmarshaled, its keys are computed and registered with marshaling manager. The manager stored each key in a dictionary where key is association (key marshaler-&gt;key fields) and value is the target Smalltalk object.	2. When a relation is being unmarshaled and marshaler contains key reference, this key reference is unmarshaled first and then marshaler calls marshaling manager to find value for association (key reference's key, unmarshaled fields). If match is fould, its value is used as a target. Otherwise, marshaling manager places this association in the list of actions waiting for resolution. Every time a new key is registered, this list is rescanned. When a match is finally found, a callback is evaluated the same way as if match was found right away. This way we can handle forward references.	3. If the relation does not have key references, marshaling manager resolves object identity by invoking method #newInstanceFor: on the marshaler. Most marshalers would then answer a new instance of smalltalk class stored in it. This way the default resolution behavior if creating new instance of the class. "</body><body package="XMLObjectMarshalers">unmarshaling"Unmarshaling of a node may invoke more than one marshaler. I.e. if a node represents element (which is association between tag and a type), a relation marshaler would decode marshaler tag, but type marshaler would complete unmarshling of the contents. If a node that corresponds to the type would be unmarshaled, the type marshaler would have to do both parts. Therefore, a marshaler may be invoked in two different ways -- to decode and unmarshal and to just unmarshal contents. #decodeAndUnmarshalFrom: marshalingContext do: aBlock	Before unmarshaling, marshalingContext&gt;&gt;source should contain the reference node. This invokes xpath parser to compute result of xpath expression. Since xpath result is generally an ordered collection of nodes, these nodes are then stored in marshalingContext&gt;&gt;nodeContext and #unmarshalFrom:do: is invoked.#unmarshalFrom: marshalingContext do: aBlock	Before invocation, marshalingContext&gt;&gt;nodeContext contains ordered collection of nodes. unmarshal:do: resolves the target (see objectIdentityModel) and invokes aBlock. This callback may not happen immediately if there is a forward reference! Target object is saved as marshalingContext&gt;&gt;value and is passed as argument of the block. unmarshal:do: may return before unmarshaling is complete!! It is because there might be a forward reference. Unmarshaling is complete only after aBlock returns.unmarshaling inside aBlock depends of kind of marshaler. See comments to subclasses of XMLTypeMarshaler for more details"</body></methods><methods><class-id>WebServices.XMLTypeMarshaler class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">newProxy	^self new</body><body package="XMLObjectMarshalers">on: aBinding	^self new on: aBinding; yourself</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">aspectRelations	| aspectRelations |	aspectRelations := OrderedCollection new.	(self  relation isManyRelation and: [self smalltalkClass isVariable])		ifTrue: [^aspectRelations].	self marshalers do: [ :mx | mx addAspectRelationTo: aspectRelations].	^aspectRelations</body><body package="XMLObjectMarshalers">elementMarshalers	^self marshalers</body><body package="XMLObjectMarshalers">marshalers	^marshalers</body><body package="XMLObjectMarshalers">marshalers: aCollection	marshalers := aCollection</body><body package="XMLObjectMarshalers">relation	^relation</body><body package="XMLObjectMarshalers">relation: aRelation	relation := aRelation</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addElementMarshaler: aTypeMarshaler	self marshalers add: aTypeMarshaler</body><body package="XMLObjectMarshalers">extendFromSuper: aCompositor	| newMarshalers inheritedNames index |	newMarshalers := aCompositor class = self class				ifTrue: [OrderedCollection withAll: aCompositor marshalers]				ifFalse: [OrderedCollection with: aCompositor].	inheritedNames := OrderedCollection new.	"There is possible to have nil tag in AnyRelationMarshaler. Skipp them for now"	newMarshalers do: [:each | each tag ifNotNil: [inheritedNames add: each tag]].		self marshalers do: 		[:elementMarshaler |		(inheritedNames detect: [:tagx | tagx = elementMarshaler tag] ifNone: [nil])			ifNotNil: 				["Put existing my marshaler in to the collection"				newMarshalers at: (inheritedNames indexOf: elementMarshaler tag) put: elementMarshaler]			ifNil: 				["AR#70299. Check if there is AnyRelationMarshaler (with nil tags). Replace it or add my marshaler to the collection"				index := newMarshalers indexOf: elementMarshaler.				index &gt; 0					ifTrue: [newMarshalers at: index put: elementMarshaler]					ifFalse: [newMarshalers addLast: elementMarshaler]]].					marshalers := newMarshalers</body><body package="XMLObjectMarshalers">finish	self marshalers do: [ :m | m finish ].</body><body package="XMLObjectMarshalers">restrictFromSuper: aCompositor	| newMarshalers  inheritedNames |	newMarshalers := OrderedCollection withAll: aCompositor marshalers.	inheritedNames := OrderedCollection new.	aCompositor marshalers do: [  :each | each tag ifNotNil: [inheritedNames add: each tag]].	self marshalers do: [ :elementMarshaler | 		newMarshalers 			at: (inheritedNames indexOf: elementMarshaler tag) 			put: elementMarshaler].	marshalers := newMarshalers</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder	relation := Relation fromAttributes:  attributesx from: self.	super setAttributesFrom: attributesx in: builder.</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isCompositorMarshaler	^true</body><body package="XMLObjectMarshalers">isEmpty	^marshalers isEmpty</body><body package="XMLObjectMarshalers">isMandatory	^relation isMandatory</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream	super printOn: aStream.	marshalers 		do: [ :each |each printOn: aStream]		separatedBy: [ aStream nextPut: Character space ]</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	marshalers := OrderedCollection new.	relation := OneRelation new.</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>tool</category><body package="XMLObjectMarshalers">addAspectRelationTo: aCollection		aCollection add: self</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">asCompositorTypeStruct	^Struct new</body><body package="XMLObjectMarshalers">complexTypeContentAspect	^self subclassResponsibility</body><body package="XMLObjectMarshalers">xmlAspect	self isEmpty ifTrue: [ ^nil ].	^self xmlContentAspect -&gt;self</body><body package="XMLObjectMarshalers">xmlContentAspect</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalFrom: marshalingContext implementation: aspectImplementation	self marshalers do: [ :elMarshaler |		marshalingContext marshalRelation: elMarshaler implementation: aspectImplementation ]</body></methods><methods><class-id>WebServices.CompositorMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	super postCopy.	marshalers :=  marshalers collect: [ :r | r copy].	relation := self relation copy.</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">finish	| anyMarshaler relMarshaler |	super finish.	self marshalers size &lt; 2 ifTrue: [^self ]."XML DTDs and W3C XML Schema have a rule that requires schemas to have deterministic content models. From the XML 1.0 specification,For example, the content model ((b, c) | (b, d)) is non-deterministic, because given an initial b the XML processor cannot know which b in the model is being matched without looking ahead to see which element follows the b. Be Deterministic rule: Use of wildcards MUST be deterministic. Location of wildcards, namespace of wildcard extensions, minOccurs and maxOccurs values are constrained, and type restriction is controlled."	1 to: self marshalers size do: [ :ind |		anyMarshaler := self marshalers at: ind.		anyMarshaler isAnyRelationMarshaler 			ifTrue: [ "- Wildcards with ##any, where minOccurs does not equal maxOccurs, are not allowed before an element declaration. An instance of the element would be valid for the ##any or the element. ##other could be used.- The element before a wildcard with ##any must have cardinality of maxOccurs equals its minOccurs. If these were different, say minOccurs=1 and maxOccurs=2, then the optional occurrences could match either the element definition or the ##any. As a result of this rule, the minOccurs must be greater than zero."				ind &gt; 1 ifTrue: [ relMarshaler := self marshalers at:  ind - 1 ].				(( ind &lt; self marshalers size and: [ anyMarshaler relation requiredOneNode not ])					or: [relMarshaler notNil and: [ relMarshaler relation requiredOneNode not ]])						ifTrue: [ NonDeterministicContentModel raiseRequestWith: self ]]]</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	aspectImplementation := AspectImplementation newDictionaryAspects</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	self relation isManyRelation ifTrue: [stream nextPutAll: 'OrderedCollection with: ('].	self printStructArgsOn: stream indentation: number.	self relation isManyRelation ifTrue: [stream nextPutAll: ')'].</body><body package="XMLObjectMarshalers">printStructArgsOn: stream indentation: number	| n aspectRelations |	stream nextPutAll: 'WebServices.Struct new '.	n := number + 2.	aspectRelations := OrderedCollection new.	self marshalers do: [ :mx | mx addAspectRelationTo: aspectRelations].	aspectRelations	do: [ :r | 		stream cr; tab: n; nextPutAll: 'at: #', r relation name, ' put: ('.		r printArgsOn: stream indentation: n.		stream nextPutAll: ');' ].	stream cr; tab: n; nextPutAll: 'yourself'.</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">asCompositorTypeStruct	^Struct new		at: #xmlMaxOccurs put: self xmlMaxOccurs;		at: #xmlMinOccurs put: self xmlMinOccurs;		yourself</body><body package="XMLObjectMarshalers">complexTypeContentAspect	^#xmlSequence</body><body package="XMLObjectMarshalers">x2oName	^self relation name ifNotNil: [ :n | n asString ]</body><body package="XMLObjectMarshalers">xmlContentAspect	^#xmlSequence</body><body package="XMLObjectMarshalers">xmlMaxOccurs	^self relation ifNotNil: [ :r | r xmlMaxOccurs ]</body><body package="XMLObjectMarshalers">xmlMinOccurs	^self relation ifNotNil: [ :r | r xmlMinOccurs ]</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">aspectImplementation	^aspectImplementation</body><body package="XMLObjectMarshalers">smalltalkClass	^Struct</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	(self newChildFrom: marshalingContext do: aBlock) ifNotNil: [ :child |		self relation unmarshalFrom: child relationMarshaler: self do: aBlock ]</body><body package="XMLObjectMarshalers">canAcceptNode: aNodeTag		^self marshalers anySatisfy: [ :each | each canAcceptNode: aNodeTag  ]</body><body package="XMLObjectMarshalers">collectNodesFrom: marshalingContext	| myNodes nodes |	myNodes := OrderedCollection new.	[nodes := OrderedCollection new.	self marshalers do: [ :each | nodes addAll: (each collectNodesFrom: marshalingContext)].	nodes notEmpty]		whileTrue: [myNodes addAll: nodes].	^myNodes</body><body package="XMLObjectMarshalers">detectChoiceFrom: aMarshalingContext ifFound: aBlock"The sequence is the choice particle. Current implementation accepts the sequence nodes as a choice only when all nodes are present (mandatory). If there are some optional elements and they are skipped the method won''t work. This case is not implemented yet "	| accept |	self marshalers size &gt; aMarshalingContext nodeContext size ifTrue: [^nil].	accept := true.	1 to: self marshalers size do: [ :ind |		((self marshalers at: ind) canAcceptNode: (aMarshalingContext nodeContext at: ind))  			ifFalse: [accept := false]].	accept ifTrue: [aBlock value: self]</body><body package="XMLObjectMarshalers">missingValueNotification: aBlock	"For backward compatibility we need to return an empty collection if there is no nodes for maxOccurs&gt;1 "	self relation isManyRelation ifTrue: [aBlock value: ( MarshalingContext new 																aspect: self relation; 																value: self relation createInstance; 																yourself)].	MissingValueNotification raiseWith: self missingValueText</body><body package="XMLObjectMarshalers">missingValueText	| stream |	stream := String new writeStream.	stream nextPutAll: '&lt;sequence: '.	self marshalers 		do: [ :each | stream nextPutAll: (each path ifNil: [each relation name] ifNotNil: [ :p | p type])]		separatedBy: [stream nextPut: Character space].	stream nextPut: $&gt;.	^stream contents</body><body package="XMLObjectMarshalers">newChildFrom: marshalingContext 	^marshalingContext newChild		aspect: self relation;		source: marshalingContext source;		nodeContext: marshalingContext nodeContext;		value: marshalingContext value;		yourself.</body><body package="XMLObjectMarshalers">newChildFrom: marshalingContext do: aBlock	| child nodes |	self marshalers isEmpty ifTrue: [ ^nil ].	marshalingContext nodes isEmpty ifTrue: [^self missingValueNotification: aBlock].	nodes := self collectNodesFrom: marshalingContext.	nodes isEmpty ifTrue: [^self missingValueNotification: aBlock].	child := self newChildFrom: marshalingContext.	child nodeContext: nodes.	^child</body><body package="XMLObjectMarshalers">unmarshalCollectionFrom: marshalingContext do: aBlock	| coll |	coll := OrderedCollection new.	[self unmarshalObjectFrom: marshalingContext do: [ :mc | coll add: mc value  ].	(marshalingContext node notNil 		and: [ self canAcceptNode: marshalingContext node ])	 ] whileTrue.	marshalingContext value: coll.			aBlock value: marshalingContext</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	self marshalers isEmpty ifTrue: [ ^nil ].	self relation isOneRelation 		ifTrue: [self marshalers do: [ :relMarshaler | 					marshalingContext 						marshaler: relMarshaler;						acceptNodesAndUnmarshal: aBlock ] ]		ifFalse: [self unmarshalIndexedVariables: marshalingContext do: aBlock ].</body><body package="XMLObjectMarshalers">unmarshalIndexedVariables: marshalingContext do: aBlock	| ind struct child |		(child := marshalingContext newChild)				source: marshalingContext source;				nodeContext: marshalingContext nodeContext.	ind := 1.	[ child nodeContext notEmpty ]		whileTrue: 			[struct := Struct new.			self marshalers do: [ :relMarshaler | 				child 					marshaler: relMarshaler;					acceptNodesAndUnmarshal: [ :mc | struct at: mc aspect name put: mc value ]].			marshalingContext value at: ind put: struct.			ind := ind + 1. ]</body><body package="XMLObjectMarshalers">unmarshalObjectFrom: marshalingContext  do: aBlock 		| child |	(child := marshalingContext newChild) 		source: marshalingContext source;		value: self smalltalkClass new;		nodeContext: marshalingContext nodeContext.	self marshalers do: [ :relMarshaler | 		child 			marshaler: relMarshaler;			acceptNodesAndUnmarshal: [ :mc | child value at: mc aspect name put: mc value ]].	child aspect: self relation.	aBlock value: child.</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getChoiceValueFrom: anObject implementation: anAspectImplementation marshalingContext: marshalingContext"anObject parameter is an association where key is the sequence relation and value is a Struct "	^(anAspectImplementation validateAspect: self relation for: anObject context: marshalingContext)		ifTrue: [self -&gt; (anAspectImplementation 						getAspect: self relation 						for:  anObject 						context: marshalingContext)]		ifFalse: [ nil ]</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext 	| child |	child := marshalingContext asPartMarshaler: self. 	child 		source: marshalingContext source;		value: (marshalingContext getValueFor: self relation).	self privateMarshalFrom: child</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext implementation: anAspectImplementation	self relation isOneRelation		ifTrue: [ super marshalFrom: marshalingContext implementation: anAspectImplementation ]		ifFalse: [self marshalFromIndexedVariables: marshalingContext ].</body><body package="XMLObjectMarshalers">marshalFromIndexedVariables: marshalingContext 	| values |	marshalingContext value class isVariable		ifFalse: [WrongObjectType new					messageText: ((#ExpectedIndexableObject1s &lt;&lt; #webservices &gt;&gt; 'Expected indexable object for: &lt;1s&gt;') expandMacrosWith: self tag type);					parameter: marshalingContext value;					raise].	values := OrderedCollection new.	1 to: marshalingContext value size do: [ :ind |( marshalingContext value  at: ind) ifNotNil: [ :val | values add: val ]].	(values size = 0		and: [self relation isMandatory ])		ifTrue: [ MissingValueSignal new				errorString: ((#Type1sIsMissingMandatoryIndexedVariables &lt;&lt; #webservices &gt;&gt; '&lt;1s&gt; is missing mandatory indexed variables')				expandMacrosWith: marshalingContext value class fullName );				parameter:  marshalingContext value;				raise].	self privateMarshalFrom: ( marshalingContext newChild						source: marshalingContext source;						value: values)</body><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext 	relation 		marshalFrom: marshalingContext		do: [ :value |  			value isNil ifTrue: [^MissingValueNotification raiseWith: self relation getSelector printString].			value isStruct ifFalse: [ WrongObjectType new							messageText: ((#ObjectIsNotStructType &lt;&lt; #webservices &gt;&gt; 'The object is not an Struct type: &lt;1s&gt;') expandMacrosWith: value printString);							parameter: value;							raise].			self marshalers do: [ :marshaler |				(marshalingContext newChildFor: marshaler)					source: marshalingContext source;					value: value;					marshalRelation: marshaler implementation: self aspectImplementation ]]</body></methods><methods><class-id>WebServices.SequentialMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue:[^self].	anIdentitySet add: self.	self marshalers do: [:m | m nodesDo: aBlock withRegistry: anIdentitySet].	aBlock value: self</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock		aBlock value: self</body><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue: [^self].	anIdentitySet add: self.	aBlock value: self</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isGroup	^true</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addElementMarshaler: aTypeMarshaler</body><body package="XMLObjectMarshalers">extendFromSuper: aCompositor</body><body package="XMLObjectMarshalers">finish		self marshaler finish</body><body package="XMLObjectMarshalers">localNameString	" is used by choice marshaler to create xpath " 	| stream |	stream := String new writeStream.	self marshalers		do: [ :each | stream nextPutAll:  each localNameString ]		separatedBy: [ stream nextPutAll:  ' or '].	^stream contents</body><body package="XMLObjectMarshalers">restrictFromSuper: aCompositor</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder	| ref group |	super setAttributesFrom: attributesx in: builder.	(ref := self findDomainValue: 'ref' in: attributesx) ifNil: [		^self error: (#CannotResolveGroupReference &lt;&lt; #webservices &gt;&gt; 'Can not resolve group reference' )].	builder 		resolve: ref		do: [ :resolved | 			group := resolved 						detect: [ :m | m isModelGroup ] 						ifNone: [ self error: (#CannotResolveGroupReference &lt;&lt; #webservices &gt;&gt; 'Can not resolve group reference' )].			self marshaler: group ]</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getChoiceValueFrom: anObject implementation: anAspectImplementation marshalingContext: marshalingContext	self marshalers do: [ :rel |		(rel			getChoiceValueFrom: anObject			implementation: anAspectImplementation			marshalingContext: marshalingContext) ifNotNil: [:assoc | ^assoc]].	^nil</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext	self relation isOneRelation		ifTrue: [ 	self marshaler aspectImplementation: marshalingContext aspectImplementation. 				self marshaler marshalElementsFrom: marshalingContext ]		ifFalse: [super marshalFrom: marshalingContext ]</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	(self newChildFrom: marshalingContext do: aBlock) ifNotNil: [ :child |		self relation isOneRelation			ifTrue: [ self marshaler acceptNodesAndUnmarshal: child do: aBlock ]			ifFalse: [ self relation unmarshalFrom: child relationMarshaler: self do: aBlock ]]</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext do: aBlock	self marshaler decodeAndUnmarshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">detectChoiceFrom: aMarshalingContext  ifFound: aBlock	^self marshaler detectChoiceFrom: aMarshalingContext  ifFound: aBlock</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	self relation isOneRelation 		ifTrue: [self marshaler compositor unmarshalFrom: marshalingContext do: aBlock ]		ifFalse: [self unmarshalIndexedVariables: marshalingContext do: aBlock ].</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">marshaler 	^marshalers isEmpty		ifTrue: [ nil ] 		ifFalse: [ marshalers first ]</body><body package="XMLObjectMarshalers">marshaler: aModelGroupMarshaler	marshalers add:  aModelGroupMarshaler</body><body package="XMLObjectMarshalers">marshalers		^marshalers isEmpty		ifTrue: [OrderedCollection new]		ifFalse: [marshalers first relations ]</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>tool</category><body package="XMLObjectMarshalers">addAspectRelationTo: aCollection		self relation isManyRelation		ifTrue: [ aCollection add: self]		ifFalse: [ self marshalers do: [ :each | each addAspectRelationTo: aCollection ]]</body></methods><methods><class-id>WebServices.GroupMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlContentAspect	^#xmlGroup</body><body package="XMLObjectMarshalers">xmlRef	^(self findDomainValue: 'ref' in: attributes ) ifNotNil: [ :v | v ]</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">canBeMultiref	^true</body><body package="XMLObjectMarshalers">isObjectTypeMarshaler	^true</body><body package="XMLObjectMarshalers">isResolved	^smalltalkClass notNil</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	xpath xpathPrefix: 'self::'.</body><body package="XMLObjectMarshalers">setDefaultAspectImplementation</body><body package="XMLObjectMarshalers">smalltalkClass: anObject	smalltalkClass := anObject</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream	super printOn: aStream.	smalltalkClass notNil		ifTrue: [aStream nextPutAll: ' class ='. 				smalltalkClass printOn: aStream].</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">inlineTypeNode	^self tag</body><body package="XMLObjectMarshalers">raiseMissingValueException	^self class raiseMissingValueException</body><body package="XMLObjectMarshalers">smalltalkClass	^smalltalkClass</body><body package="XMLObjectMarshalers">smalltalkClassName	^self smalltalkClass fullName</body><body package="XMLObjectMarshalers">symbolSpace	^#type</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">buildFromTag: aNodeTag" This is 'backdoor' initialization shortcut that is used to build struct marshalers based solely on tag. It is used in WSDL because for RPC-style methods we need to create a wrapper structure with accessors for each parameter. This way we build structure marshaler. Direct use of xpath is somewhat suspect but it should be easy to encapsulate it later "	tag := aNodeTag.	xpath buildFrom: aNodeTag xpath: aNodeTag asString for: self.</body><body package="XMLObjectMarshalers">buildFromTag: aNodeTag smalltalkClass: aClass	smalltalkClass := aClass.	self buildFromTag: aNodeTag.</body><body package="XMLObjectMarshalers">finish	smalltalkClass ifNil: [self error: (#ClassNameIsNotSpecified &lt;&lt; #webservices &gt;&gt; 'Class name is not specified')].</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	super setLocalAttributesFrom: attributesx in: builder. 	self setSmalltalkClassFrom: attributesx in: builder.</body><body package="XMLObjectMarshalers">setSmalltalkClassFrom: attributesx in: builder	| className |	(self findValue: 'smalltalkClass' in: attributesx) ifNotNil:		[ :aString | 			className := aString.		((className indexOf: $.) = 0 			and: [builder binding defaultClassNamespace notNil]) 				ifTrue: [className := builder binding defaultClassNamespace , '.' , className].		smalltalkClass := className asSymbol asQualifiedReference 					valueOrDo: [self raiseClassIsNotDefinedNamed: className]]</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>private</category><body package="XMLObjectMarshalers">raiseClassIsNotDefinedNamed: className 	^(ClassIsNotDefinedSignal new)		messageText: (#SmalltalkClassIsNotDefined &lt;&lt; #webservices 					&gt;&gt; 'Smalltalk class &lt;1s&gt; is not defined' expandMacrosWith: className);		parameter: className;		raiseRequest</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">extensionType		^nil</body><body package="XMLObjectMarshalers">x2oAttributes		^OrderedCollection new</body><body package="XMLObjectMarshalers">x2oBaseType	^nil</body><body package="XMLObjectMarshalers">x2oContents	^'object'</body><body package="XMLObjectMarshalers">x2oName	^self name type</body><body package="XMLObjectMarshalers">x2oSmalltalkClass	^(self findDomainValue: 'smalltalkClass' in: attributes) = self smalltalkClass name asString		ifTrue: [self smalltalkClass name asString]		ifFalse: [self  smalltalkClassName ]</body><body package="XMLObjectMarshalers">xmlAbstract	^nil</body><body package="XMLObjectMarshalers">xmlAttributeGroup	^OrderedCollection new</body><body package="XMLObjectMarshalers">xmlAttributes	^OrderedCollection new</body><body package="XMLObjectMarshalers">xmlComplexTypeContentChoice	^nil</body><body package="XMLObjectMarshalers">xmlContents	^'complexType'</body><body package="XMLObjectMarshalers">xmlName	^self isLocalType ifTrue: [ nil ]  ifFalse: [self name type]</body><body package="XMLObjectMarshalers">xmlText	^nil</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">copyFrom: anotherMarshaler	smalltalkClass := anotherMarshaler smalltalkClass.</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalFrom: marshalingContext	^xpath 		marshalFrom: marshalingContext 		do: [self privateMarshalFrom: marshalingContext]</body></methods><methods><class-id>WebServices.ObjectMarshaler</class-id> <category>comparing</category><body package="XMLObjectMarshalers">= aMarshaler	^self tag = aMarshaler tag and: [ aMarshaler isObjectTypeMarshaler ]</body></methods><methods><class-id>WebServices.ObjectMarshaler class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">raiseMissingValueException	^RaiseMissingValueException ifNil: [ RaiseMissingValueException := self raiseMissingValueExceptionValue ]</body><body package="XMLObjectMarshalers">raiseMissingValueException: aBoolean	RaiseMissingValueException := aBoolean</body><body package="XMLObjectMarshalers">raiseMissingValueExceptionValue 	^false</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">defaultSmalltalkClassName	^'Array'</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder" Set any attributes we are interested in "	| ref val  attrTag | 	super setLocalAttributesFrom: attributesx in: builder.	(ref := self findDomainValue: 'ref' in: attributesx) == nil		ifTrue: [self error: (#ExpectArrayTypeRef &lt;&lt; #webservices &gt;&gt; 'Expect array type ref')].	attrTag := NodeTag 					qualifier:  'SOAP-ENC'					ns:  'http://schemas.xmlsoap.org/soap/encoding/'					type: 'arrayType'.	self arrayType: (attrTag -&gt; ref ).	self qualified: true.	self dimension: 			((val := self findDomainValue: 'dimension' in: attributesx) notNil				ifTrue: [ val asNumber ]				ifFalse: [1]).	self dimSize: 			((val := self findDomainValue: 'dimSize' in: attributesx) ~~ nil				ifTrue: [ val asNumber ]				ifFalse: ['*']).	self offset: 			((val := self findDomainValue: 'offset' in: attributesx) ~~ nil				ifTrue: [ val asNumber ]				ifFalse: [1]).	builder 		resolveType: ref 		do: [ :typeMarshaler | 			elementMarshaler := RPCEncRelationMarshaler 				manyRelationFrom:  ref				partMarshaler: typeMarshaler.				elementMarshaler useInlineType: false.			elementMarshaler relation collectionClass: self smalltalkClass.			(val := self findValue: 'elementTag' in: attributesx) ~~ nil				ifTrue: [elementMarshaler tag: ( NodeTag qualifier: '' ns: '' type: val)]				ifFalse: [elementMarshaler tag: ( NodeTag qualifier: '' ns: '' type: 'item')]].</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">createInstanceFor: marshalingContext	 ^self smalltalkClass withSize: marshalingContext nodes size</body><body package="XMLObjectMarshalers">createMultidimArrayFrom: anArray using: anAttributeCollection	| type  array |	self dimension = 1 ifTrue: [ ^anArray].	anArray size == 0		ifTrue: 			[array := Array new: self dimension.			 1 to: self dimension do: [ :ind | array at: ind put:  Array new]. 			^array].	type := (anAttributeCollection detect: [ :attr | attr key type = 'arrayType' ] ifNone: [^nil]) value.	^(type occurrencesOf: $[ ) = 1 		ifTrue: 			[(anArray size rem: self dimension) ~= 0 				ifTrue: [ self error: (#WrongCollectionSize &lt;&lt; #webservices &gt;&gt; 'Wrong collection size')].			self setMultidimArray: anArray dim: self dimension size: anArray size // self dimension ]		ifFalse: 			[self 				setJaggedArray: anArray				dim: self dimension				rank: (type copyFrom: (type indexOf: $]) + 1  to: type size).].</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: aMarshalingContext do: aBlock	self unmarshalFrom: aMarshalingContext do: aBlock</body><body package="XMLObjectMarshalers">setJaggedArray: aCollection dim: dimNumber rank: rankString"int[][5]  int[,][3,5]   jagged arrays - no tests on the Interop Lab "	| stream str array tokens index v error |  	stream := rankString readStream.	array := Array new: dimNumber.	stream upTo: $[.	str := stream upTo: $].	tokens := str tokensBasedOn: $,.	index := 0.	error := [self error: #'Mismatch number of array elements and specified array rank'].	1 to: dimNumber 		do: [ :ind | 			v := (ind &gt; tokens size				ifTrue: [ tokens first asNumber ]				ifFalse: [ ( tokens at: ind ) asNumber]).			index + v &gt; aCollection size 					ifTrue: 						[error value.						v := aCollection size - index].			array at: ind put: ( aCollection copyFrom: (index +1) to: ( index := index + v )) asArray].	index ~= aCollection size ifTrue: [ error value].	^array</body><body package="XMLObjectMarshalers">setMultidimArray: aCollection dim: dimNumber size: sizeNumber" xsd:string[2,3]  - Interop tests 2-dim array with 3 elems"	| array index |	array := Array new: dimNumber .	index := 0.	1 to: dimNumber 		do: 	[ :ind | 			array at: ind put: ( aCollection copyFrom: (index + 1) to: (index := index + sizeNumber)) asArray].	^array</body><body package="XMLObjectMarshalers">unmarshalFrom: aMarshalingContext do: aBlock	aMarshalingContext			marshaler: self elementMarshaler; 		decodeAndUnmarshal: [ :mc |  | value | 			value :=  self createMultidimArrayFrom: mc value  using: aMarshalingContext source attributes.			aMarshalingContext value: value.			aBlock value: aMarshalingContext ]</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">arrayType	^self params at: #arrayType ifAbsent: [nil]</body><body package="XMLObjectMarshalers">arrayType: anXMLAttribute	self params at: #arrayType put: anXMLAttribute</body><body package="XMLObjectMarshalers">dimSize	^self params at: #dimSize ifAbsent: [nil]</body><body package="XMLObjectMarshalers">dimSize: aNumber	self params at: #dimSize put: aNumber</body><body package="XMLObjectMarshalers">dimension	^self params at: #dimension ifAbsent: [1]</body><body package="XMLObjectMarshalers">dimension: aNumber	self params at: #dimension put: aNumber</body><body package="XMLObjectMarshalers">elementMarshaler	^elementMarshaler</body><body package="XMLObjectMarshalers">elementMarshalers	^OrderedCollection with: elementMarshaler</body><body package="XMLObjectMarshalers">offset	^self params at: #offset ifAbsent: [nil]</body><body package="XMLObjectMarshalers">offset: aNumber	^self params at: #offset put: aNumber</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isCollectionType	^true</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">addAttributeNode: anAttribute marshalingContext: aMarshalingContext	aMarshalingContext  addAttributeNode: anAttribute. 	aMarshalingContext 		addNamespace: anAttribute tag namespace 		qualifier: anAttribute tag qualifier</body><body package="XMLObjectMarshalers">privateMarshalFrom: aMarshalingContext	| child coll newColl attr |	coll := aMarshalingContext value.	self dimension &gt; 1		ifTrue: 			[newColl := OrderedCollection new: coll size. 			 coll do: [ :each | newColl addAll: each ]]		ifFalse: [ newColl := coll ].		child := aMarshalingContext 				asPartMarshaler: self elementMarshaler					value: newColl.	[self elementMarshaler setNodeAndMarshalFrom: child.	] on: MissingValueSignal do: [ :ex | ex proceed ].	" Add arrayType  attributes "	attr := self 			typeAttributeFor: aMarshalingContext 			dimensionString: (self setDimension: self dimension for: coll).	aMarshalingContext  addAttributeNode: attr.	self setArrayTypeFor: aMarshalingContext typeAttribute: attr key.</body><body package="XMLObjectMarshalers">setArrayTypeFor: aMarshalingContext typeAttribute: aNodeTag	| attType  value |	value :=  aNodeTag qualifier, ':Array'.	(attType := aMarshalingContext source attributes detect: [ :attrx | attrx key type = 'type'] ifNone: [nil]) ~~ nil		ifTrue: [ attType value: value]		ifFalse: 			[self 				addAttributeNode: (Attribute name: self inlineTypeKey value: value) 				marshalingContext: aMarshalingContext]</body><body package="XMLObjectMarshalers">setDimension: aNumber for: aCollection  	| stream |	stream := (String new: 16) writeStream. 	stream nextPut: $[.	stream nextPutAll: aCollection size printString.	1 to: aNumber - 1 do: 		[ :num |  		stream nextPut: $,.		stream nextPutAll: (aCollection at: num) size printString ].	stream nextPut: $].	^stream contents</body><body package="XMLObjectMarshalers">setInlineTypeFor: anElement marshalingContext: aMarshalingContext"http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Ref4777957010SOAP arrays MUST contain a SOAP-ENC:arrayType attribute whose value specifies the type of the contained elements as well as the dimension(s) of the array. The value of the SOAP-ENC:arrayType attribute is defined as follows:arrayTypeValue = atype asizeatype          = QName *( rank )rank           = '[' *( ',' ) ']'asize          = '[' #length ']'length         = 1*DIGITThe 'atype' construct is the type name of the contained elements expressed as a QName as would appear in the 'type' attribute of an XML Schema element declaration and acts as a type constraint (meaning that all values of contained elements are asserted to conform to the indicated type; that is, the type cited in SOAP-ENC:arrayType must be the type or a supertype of every array member). In the case of arrays of arrays or 'jagged arrays', the type component is encoded as the 'innermost' type name followed by a rank construct for each level of nested arrays starting from 1. Multi-dimensional arrays are encoded using a comma for each dimension starting from 1.""VW implementation tried to follow the spec and doesn't create  arrayType attribute for the nil arrays  but there are some poor servers that expect empty length for those arrays (SOAP-ENC:arrayType='ns1:string[]' )If you need to communicate this type of server, set #useEmptyLengthForDimension class variable to true"	| attr |	(aMarshalingContext value isNil		and: [ self class useEmptyLengthForDimension])		ifTrue: 			[attr := self typeAttributeFor: aMarshalingContext dimensionString: '[]'.			self addAttributeNode: attr marshalingContext: aMarshalingContext.			self setArrayTypeFor: aMarshalingContext typeAttribute: attr key].</body><body package="XMLObjectMarshalers">typeAttributeFor: aMarshalingContext dimensionString: aString	| qx soapEnc |	qx := aMarshalingContext  addQualifierForTag: self arrayType value.	soapEnc := aMarshalingContext addQualifierForTag: self arrayType key.  	self arrayType key resetQualifierTo: soapEnc.	^Attribute 		name: self arrayType key 		value: (qx, ':', self arrayType value type, aString )</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oDimension	^self dimension printString</body><body package="XMLObjectMarshalers">x2oRef	^self arrayType value</body><body package="XMLObjectMarshalers">xmlAttributeGroup	^OrderedCollection new</body><body package="XMLObjectMarshalers">xmlAttributes	^OrderedCollection new</body><body package="XMLObjectMarshalers">xmlComplexTypeContentChoice	| relation encRelation |	encRelation :=  self elementMarshaler.	relation := ElementMarshaler relation: encRelation relation marshaler: encRelation typeMarshaler.	relation name: encRelation typeMarshaler tag.	relation attributes at: (NodeTag new qualifier: '' ns: '' type: 'ref') put: encRelation typeMarshaler tag.	^#xmlSequence-&gt;( Struct new at: #marshalers put: (OrderedCollection with: relation); yourself )</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	smalltalkClass := Array.</body></methods><methods><class-id>WebServices.SoapArrayMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	| clName |	self elementMarshaler notNil		ifTrue: [ stream nextPutAll: ' ', self smalltalkClass name, ' with: ('.				stream nextPutAll: ' '.				clName := 	self elementMarshaler typeMarshaler smalltalkClass								ifNotNil: [ :cl | cl name ]								ifNil: ['Object'].				stream nextPutAll: clName, ' new)' ]		ifFalse: [stream nextPutAll: ' ', self smalltalkClass name, ' new.' ].</body></methods><methods><class-id>WebServices.SoapArrayMarshaler class</class-id> <category>default values</category><body package="XMLObjectMarshalers">useEmptyLengthForDimensionValue	^false</body></methods><methods><class-id>WebServices.SoapArrayMarshaler class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">useEmptyLengthForDimension	^useEmptyLengthForDimension ifNil: [useEmptyLengthForDimension := self useEmptyLengthForDimensionValue ]</body><body package="XMLObjectMarshalers">useEmptyLengthForDimension: aBoolean	useEmptyLengthForDimension := aBoolean</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">aspectImplementation: aValue	aspectImplementation := aValue</body><body package="XMLObjectMarshalers">beDictionaryAspects	aspectImplementation := AspectImplementation dictionaryAspects</body><body package="XMLObjectMarshalers">beIdentityDictionaryAspects	aspectImplementation := AspectImplementation identityDictionaryAspects</body><body package="XMLObjectMarshalers">beObjectAspects	aspectImplementation := AspectImplementation objectAspects</body><body package="XMLObjectMarshalers">initialize	super initialize.	attributeMarshalers := OrderedCollection new.	aspectImplementation := AspectImplementation objectAspects.</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">abstract	^abstract ifNil: [false]</body><body package="XMLObjectMarshalers">abstract: aBoolean	abstract := aBoolean</body><body package="XMLObjectMarshalers">allRelations	| coll |	^baseType 		ifNotNil: [coll := OrderedCollection withAll: baseType allRelations.				 	coll addAll: (self relations reject: [ :m | coll includes: m]) .					coll  ]		ifNil: [ self relations ]</body><body package="XMLObjectMarshalers">anyAttributeMarshaler	^anyAttributeMarshaler</body><body package="XMLObjectMarshalers">aspectImplementation	^aspectImplementation</body><body package="XMLObjectMarshalers">attributeMarshalers	^attributeMarshalers</body><body package="XMLObjectMarshalers">attributeMarshalers: aCollection	attributeMarshalers := aCollection</body><body package="XMLObjectMarshalers">baseType	^baseType</body><body package="XMLObjectMarshalers">compositor	^compositor ifNil: [self setDefaultCompositor]</body><body package="XMLObjectMarshalers">defaultCompositor	^self class defaultCompositor new</body><body package="XMLObjectMarshalers">elementMarshalers	^self compositor elementMarshalers</body><body package="XMLObjectMarshalers">elementMarshalers: aCollection		self compositor marshalers: aCollection</body><body package="XMLObjectMarshalers">keyMarshalers	^keyMarshalers</body><body package="XMLObjectMarshalers">relations	| relations |	relations := OrderedCollection withAll: self elementMarshalers.	textMarshaler ifNotNil: [relations add: textMarshaler ].	relations addAll: self attributeMarshalers.	anyAttributeMarshaler ifNotNil: [relations add: anyAttributeMarshaler].	^relations</body><body package="XMLObjectMarshalers">setDefaultCompositor	compositor := self defaultCompositor.	^compositor</body><body package="XMLObjectMarshalers">simpleContentBaseType	^textMarshaler simpleContentBaseType</body><body package="XMLObjectMarshalers">textMarshaler	^textMarshaler</body><body package="XMLObjectMarshalers">textMarshaler: anObject	^textMarshaler := anObject</body><body package="XMLObjectMarshalers">useUnorderedMarshaler	compositor := UnorderedMarshaler new</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">inheritsFrom: aTypeMarshaler	^self baseType notNil		and: [aTypeMarshaler = self baseType				or: [self baseType inheritsFrom:  aTypeMarshaler ]]</body><body package="XMLObjectMarshalers">isAbstract	^self abstract</body><body package="XMLObjectMarshalers">isAbstractAnyType"The type that is defined as an extension to anyType:&lt;xs:element name='auxData' type='auxDataProperties'/&gt;&lt;xs:complexType name='auxDataProperties'&gt;	&lt;xs:complexContent&gt;			&lt;xs:extension base='xs:anyType'/&gt;	&lt;/xs:complexContent&gt;&lt;/xs:complexType&gt;"		^(self compositor isEmpty 		and: [ self attributeMarshalers isEmpty			and: [ textMarshaler isNil				and: [baseType notNil 					and: [baseType isSimpleType 						and: [baseType tag type = 'anyType'							and: [XMLObjectBinding defaultUriXsd = baseType tag namespace ]]]]]])</body><body package="XMLObjectMarshalers">isComplexTypeMarshaler	^true</body><body package="XMLObjectMarshalers">isDictionaryType	^self aspectImplementation isDictionary</body><body package="XMLObjectMarshalers">isObjectType	^self aspectImplementation isObject</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addBaseType: aTypeMarshaler	| newRelations |	baseType := aTypeMarshaler.	newRelations := baseType allRelations copy.	self x2oRelations do: [ :elementMarshaler | newRelations add: elementMarshaler].	self attributeMarshalers: OrderedCollection new.	self compositor marshalers: OrderedCollection new.	newRelations do: [ :each | self addElementMarshaler: each ].</body><body package="XMLObjectMarshalers">addElementMarshaler: aTypeMarshaler	(aTypeMarshaler isCompositorMarshaler and: [compositor isNil] ) 		ifTrue: [^compositor := aTypeMarshaler].	(aTypeMarshaler isAttribute or: [aTypeMarshaler isAttributeGroup]) ifTrue: [		aTypeMarshaler isAnyAttributeMarshaler ifTrue: [ ^anyAttributeMarshaler := aTypeMarshaler ].		^self attributeMarshalers add: aTypeMarshaler ].	aTypeMarshaler isText ifTrue: [^textMarshaler :=  aTypeMarshaler].		self compositor addElementMarshaler: aTypeMarshaler</body><body package="XMLObjectMarshalers">addKeyMarshaler: aMarshaler	keyMarshalers == nil		ifTrue: [keyMarshalers := OrderedCollection with: aMarshaler]		ifFalse: [keyMarshalers add: aMarshaler]</body><body package="XMLObjectMarshalers">copyFromSuper	"Final work on &lt;extension&gt; or &lt;restriction&gt; of a complexType:	Copy all aspects which have not been defined by the extension itself. 	Take special care for relations inherited from baseType but refined by restriction. These must replace the inherited relations.	Make sure to keep relation order. Account for 'wild' order of schema definer.	New x2o mapping has the #constraint attribute with value: #extension or #restriction. If there is no the constraint attribute we will try to calculate the contraint type. "	|  constraintType  |	"If the #baseType is a simple type this complex type represents simple contents with TextMarshaler to encode/decode the contents value "	baseType isSimpleType ifTrue: [^self].	constraintType := (self findDomainValue: 'constraint' in: attributes) 		ifNil: [ | newRelations |			 newRelations := baseType allRelations copy.			( self relations reject: [ :rx | newRelations includes: rx]) notEmpty ifTrue: [#extension] ifFalse: [#restriction]]		ifNotNil: [ :type | type asSymbol].	compositor 		ifNil: [compositor := baseType compositor ]		ifNotNil: [constraintType = #extension ifTrue: [ compositor extendFromSuper: baseType compositor].				constraintType = #restriction ifTrue: [ compositor restrictFromSuper: baseType compositor ]].	baseType attributeMarshalers reverseDo: [ :attrMarshaler | 		attributeMarshalers 			detect: [ :m | m tag = attrMarshaler tag ] 			ifNone: [ attributeMarshalers addFirst: attrMarshaler ]].	anyAttributeMarshaler ifNil: [ anyAttributeMarshaler := baseType anyAttributeMarshaler ].	textMarshaler 	ifNil: [ textMarshaler := baseType textMarshaler ].	aspectImplementation ifNil: [aspectImplementation := baseType aspectImplementation].	smalltalkClass ifNil: [smalltalkClass := baseType smalltalkClass]</body><body package="XMLObjectMarshalers">defaultAspectImplementationFor: class	(class includesBehavior: Dictionary)		ifTrue: [^AspectImplementation dictionaryAspects].	(class includesBehavior: SequenceableCollection)		ifTrue: [^AspectImplementation sequenceableCollectionAspects].	(class includesBehavior: Collection)		ifTrue: [^AspectImplementation streamAspects].	^AspectImplementation objectAspects</body><body package="XMLObjectMarshalers">finish	baseType ifNotNil: ["COPY relations from the super" 	self copyFromSuper  ].	super finish.	self attributeMarshalers do: [ :attrMarshaler |  attrMarshaler finish ].	anyAttributeMarshaler ifNotNil: [ anyAttributeMarshaler finish ].	textMarshaler ifNotNil: [textMarshaler finish ].	self compositor finish.</body><body package="XMLObjectMarshalers">registerWith: xmlObjectBinding	(aspectImplementation isObject and: [ smalltalkClass notNil ]) ifTrue: [ xmlObjectBinding registerClassMarshaler: self ]</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	super setLocalAttributesFrom: attributesx in: builder. 	(self findDomainValue: 'baseType' in: attributesx) ifNotNil: [ :base | 		builder 			resolveType: base			do: 	[ :resolved | "DO NOT COPY relations from the super type here" 				baseType := resolved.]].	"Use #abstract attribute to to force substitution for a particular type. 	When a type is declared to be #abstract, it cannot be used in an instance document. 	Declaring a type as abstract simply requires the use of a type derived from it (and identified by the xsi:type attribute) in the instance document."	(self findDomainValue: 'abstract' in: attributesx) ifNotNil: [ :value | abstract := Boolean readFrom: value readStream ].	(aspectImplementation isObject and: [ smalltalkClass notNil ]) ifTrue: [ builder binding registerClassMarshaler: self ].</body><body package="XMLObjectMarshalers">setNewNamespaceForTag: aNamespaceString qualifier: aQualifierString	self tag namespace = aNamespaceString ifTrue: [ ^nil].	super 		setNewNamespaceForTag: aNamespaceString 		qualifier: aQualifierString.	(self relations ~~ nil and: [ self relations isEmpty not])		ifTrue: 			[ self relations do: 					[ :marshaler | 						marshaler 							setNewNamespaceForTag: aNamespaceString 							qualifier: aQualifierString ]]</body><body package="XMLObjectMarshalers">setSmalltalkClassFrom: attributesx in: builder	super setSmalltalkClassFrom: attributesx in: builder.	self smalltalkClass isNil		ifTrue: 			[ClassIsNotDefinedSignal new				messageText: (#SmalltalkClassIsNotSpecified &lt;&lt; #webservices &gt;&gt; 'Smalltalk class is not specified');				parameter: ( OrderedCollection with: self with: attributesx );				raiseRequest].	(self smalltalkClass ~~ nil and: [ aspectImplementation == nil ])		ifTrue: [aspectImplementation := self defaultAspectImplementationFor: self smalltalkClass].</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock"The method is called from AnyRelationMarshaler when the any marshaler was not able to find ElementMarshaler to unmarshal the nodes "	| child |	child :=  marshalingContext asPartMarshaler: self source: marshalingContext node.	child nodeContext: (OrderedCollection with: marshalingContext node).	self 		unmarshalFrom: child 		do: [ :mc | 			marshalingContext nodes remove: marshalingContext node.			aBlock value: mc  ]</body><body package="XMLObjectMarshalers">createInstanceFor: marshalingContext" Callback from the manager. Invoked when object is to be resolved by creating a new instance of the object. Can be overridden i.e. by collection marshalers. "	^[self smalltalkClass isVariable 		ifTrue: [self smalltalkClass new: (marshalingContext node realElements size / self elementMarshalers size ) rounded ]		ifFalse: [self smalltalkClass new] 	]		on: Error do: [ :ex | self smalltalkClass basicNew]</body><body package="XMLObjectMarshalers">getRealMarshaler: marshalingContext unmarshal: anElement	"ComplexObjectMarshaler can return a real marshaler for derived types  "	| typeMarshaler inlineType |	"If #href/ref attribute is found we use this reference to resolve the value "	(self binding useReference 		and: [(anElement valueOfAttribute: marshalingContext manager refTag ifAbsent: [nil]) notNil ])		ifTrue: [^self].	"Find  xsi:type attribute value "	inlineType := marshalingContext manager 					elementTypeFrom: anElement  					attributeKey: 'type' 					ns: XMLObjectBinding defaultUriSchemaInstance. 	(self isAbstract not and: [ inlineType isNil ]) ifTrue: [^self].	typeMarshaler := inlineType 		ifNil: [ "http://www.w3.org/TR/xmlschema-0/#abstract.				When an element's corresponding type definition is declared as abstract, all instances of that element must use xsi:type to indicate a derived type that is not abstract.  "				self isAbstract ifTrue: [ MissingTypeAttribute new					messageText: ((#ElementIsMissingRequiredTypeAttribute &lt;&lt; #webservices &gt;&gt; 'Attribute xsi:type is required in element &lt;1s&gt;. Its expected type &lt;2s&gt; is declared as abstract complex type.')					expandMacrosWith: anElement tag printString with: self path printString );					parameter: anElement;					raiseRequest ]]		ifNotNil: [ marshalingContext manager binding 					typeMarshalerForTag: inlineType 					ifAbsent: [ ^self ]].	(self isAbstract not and: [ typeMarshaler = self ]) ifTrue: [^typeMarshaler].	((self isAbstract and: [ typeMarshaler = self ])		or: [(typeMarshaler inheritsFrom: self) not ]) 		ifTrue: [typeMarshaler := NoMarshalerSignal new				messageText: ((#FoundMarshaler1sExceptedMarshalerDerived &lt;&lt; #webservices &gt;&gt; 'Found marshaler:  &lt;1s&gt; for &lt;2s&gt;. Expected a marshaler derived from the abstract type: &lt;3s&gt;')				expandMacrosWith: typeMarshaler path printString with: anElement tag printString with: self path printString );				parameter: anElement;				raiseRequest ].	typeMarshaler notNil ifTrue: [ ^typeMarshaler ].	^marshalingContext 		notifyNoMarshalerFor: marshalingContext nodes 		text: marshalingContext nodes first simpleDescription.</body><body package="XMLObjectMarshalers">setRelation: relation for: target to: object context: marshalingContext	aspectImplementation 		setAspectFrom: relation		for: target 		to: object 		context: marshalingContext</body><body package="XMLObjectMarshalers">unmarshalAttributesFrom: marshalingContext do: aBlock		| child |	(child := marshalingContext newChild)		source: marshalingContext source;		nodeContext: marshalingContext source attributes asOrderedCollection.	self attributeMarshalers do: [ :attrMarshaler | 		child 			marshaler: attrMarshaler;			acceptNodesAndUnmarshal: aBlock ].	(child nodes notEmpty and: [ anyAttributeMarshaler notNil ])		ifTrue: [child 					marshaler: anyAttributeMarshaler;					acceptNodesAndUnmarshal: aBlock ].</body><body package="XMLObjectMarshalers">unmarshalContentModelFrom: marshalingContext do: aBlock		| child |	self unmarshalAttributesFrom: marshalingContext do: aBlock.	child := marshalingContext newChild		source: marshalingContext source;		nodeContext: marshalingContext source realElements asOrderedCollection;		value: marshalingContext value;		yourself.	self compositor unmarshalFrom: child do: aBlock .	"If there is a text marshaler use xpath to find all text nodes "	textMarshaler ifNotNil: [ 		marshalingContext 			marshaler: textMarshaler;			decodeAndUnmarshal: aBlock ].</body><body package="XMLObjectMarshalers">unmarshalElementsFrom: aMarshalingContext		self 		unmarshalContentModelFrom: aMarshalingContext 		do: [ :mc |			aspectImplementation 				setAspectFrom: mc aspect				for: aMarshalingContext value 				to: mc value 				context: aMarshalingContext ]</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock" Unmarshal complex object which is comprised of relations. By this time node context should be a one-node collection. If there is no node, a MissingValue notification is raised. Note this can happen in a situation where object was resolved via keyRef. In this case marshalingContext already contains the object and is set to be Reference kind. Therefore, MissingValue notification will simply end further object marshaling, which is what we want anyway "	marshalingContext marshaler: self.	marshalingContext node == nil ifTrue: [MissingValueNotification raiseWith: marshalingContext source tag type].	self 		resolveFrom: marshalingContext 		do: [ :object |			object isStruct ifTrue: [ object structName: self tag].			marshalingContext notReference				ifTrue: 					["Patch for resolving references to a type that is defined as an extension to anyType without any attributes or elements.					Returning XML element since we have no clue how to unmarshal the this element content"					self isAbstractAnyType						ifTrue: [marshalingContext value: marshalingContext source.							^aBlock value: marshalingContext ].					self unmarshalElementsFrom: marshalingContext.					self unmarshalKeysFrom: marshalingContext.					marshalingContext manager registerKeysFrom: marshalingContext.].			marshalingContext isUnresolved 				ifTrue: [marshalingContext value: (ObjectNotResolvedSignal raiseRequestWith: marshalingContext source)].			(marshalingContext value respondsTo: #_complete)				ifTrue: [marshalingContext value _complete].			aBlock value: marshalingContext]</body><body package="XMLObjectMarshalers">unmarshalHRefFrom: aMarshalingContext	^aMarshalingContext manager 			resolveHReference: aMarshalingContext 			fromElement: aMarshalingContext node</body><body package="XMLObjectMarshalers">unmarshalKeysFrom: marshalingContext	| val collection |	keyMarshalers notNil		ifTrue: 			[collection := OrderedCollection new.			(keyMarshalers do: 						[ :keyMarshaler | 						val := keyMarshaler decodeAndUnmarshalFrom: marshalingContext copy.						(val size = 1 and: [val first isNil]) ifFalse: [collection add: keyMarshaler-&gt;val]]).			collection isNotEmpty ifTrue: [marshalingContext keys: collection]]</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>tool</category><body package="XMLObjectMarshalers">aspectRelations	| relations |	relations := self compositor aspectRelations.	textMarshaler ifNotNil: [relations add: textMarshaler ].	self attributeMarshalers do: [ :marshaler | marshaler addAspectRelationTo:  relations ].	anyAttributeMarshaler ifNotNil: [relations add: anyAttributeMarshaler].	^relations</body><body package="XMLObjectMarshalers">baseType: aTypeMarshaler	baseType := aTypeMarshaler</body><body package="XMLObjectMarshalers">spawnWith: aBindingBuilder	| copy |	copy := super spawnWith: aBindingBuilder.	aBindingBuilder binding marshalers 		detect: [ :aMarshaler |  aMarshaler  path = copy path and: [ aMarshaler isObjectTypeMarshaler ]]		ifNone: [aBindingBuilder binding marshalers  add: copy].	copy relations: (self relations collect: [ :each | each spawnWith: aBindingBuilder]).	self baseType ifNotNil: [copy baseType: (self baseType spawnWith: aBindingBuilder )].	^copy</body><body package="XMLObjectMarshalers">typeDescription	^self smalltalkClass name</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">addXMLComplexContent	| struct  extensionType compositorStruct extensions |	extensionType := self extensionType.	struct := Struct new 				at: #base put: baseType tag;				at: #attributes put: self x2oAttributes;				at: #attributeGroup put: self x2oAttributeGroup;				yourself.	(extensions := self elementConstraints) notEmpty 		ifTrue: [ compositorStruct := self compositor asCompositorTypeStruct.				compositorStruct at: #marshalers put: extensions.				struct at: self compositor complexTypeContentAspect  put: compositorStruct ].	^#xmlComplexContent-&gt;(Struct new xmlChoiceValue: (extensionType -&gt; struct); yourself)</body><body package="XMLObjectMarshalers">addXMLSimpleContent	| struct base |	self textMarshaler ifNotNil: [ :rel |  base := rel typeMarshaler tag ].	struct :=  Struct new 				at: #base put: base;				at: #attributes put: self  x2oAttributes;				at: #attributeGroup put: self  x2oAttributeGroup;				yourself.	^#xmlSimpleContent-&gt;(Struct new xmlChoiceValue: self extensionType -&gt; struct; yourself)</body><body package="XMLObjectMarshalers">constraints	|  extensionType  extensions selfRelations baseRelations |	selfRelations := self relations.	baseType ifNil: [^selfRelations ].	baseRelations := self baseType isSimpleType ifTrue: [ #() ] ifFalse: [ self baseType relations ].	extensionType := self extensionType.	extensionType = #extension 	ifTrue: [ extensions :=  selfRelations reject: [ :rx | baseRelations includes: rx]].	extensionType = #restriction ifTrue: [ extensions := selfRelations ].	^extensions</body><body package="XMLObjectMarshalers">elementConstraints	^self constraints select: [ :marshaler | marshaler isAttribute not and: [marshaler isAttributeGroup not ]].</body><body package="XMLObjectMarshalers">extensionType	| selfRelations baseRelations |	baseType ifNil: [^nil].	selfRelations := self relations.	baseRelations := self baseType isSimpleType ifTrue: [#() ] ifFalse: [self baseType relations].	^(self findDomainValue: 'constraint' in: attributes) 		ifNil: [ ( selfRelations reject: [ :rx | baseRelations includes: rx]) notEmpty ifTrue: [#extension] ifFalse: [#restriction]]		ifNotNil: [ :type | type asSymbol].</body><body package="XMLObjectMarshalers">isSimpleContents	"simpleContent: there are no elements only attributes and text "	^self textMarshaler notNil</body><body package="XMLObjectMarshalers">x2oAttributeGroup	^self constraints select: [ :marshaler | marshaler isAttributeGroup].</body><body package="XMLObjectMarshalers">x2oAttributes	^self constraints select: [ :marshaler | marshaler isAttribute ]</body><body package="XMLObjectMarshalers">x2oBaseType	^self baseType ifNotNil: [ self baseType tag]</body><body package="XMLObjectMarshalers">x2oComplexTypeContentChoice	| marshalers |	self isSimpleContents ifTrue: [^nil].	(self compositor isChoiceMarshaler or: [ self compositor isGroup ])		ifTrue: [^self compositor xmlContentAspect -&gt;self compositor].	^(marshalers := self elementConstraints) notEmpty		ifTrue: [self compositor xmlContentAspect -&gt;(self compositor asCompositorTypeStruct											at: #marshalers put: marshalers;											yourself )]		ifFalse: [nil]</body><body package="XMLObjectMarshalers">x2oRelations	^self constraints</body><body package="XMLObjectMarshalers">xmlAbstract	^abstract</body><body package="XMLObjectMarshalers">xmlAttributeGroup	(baseType notNil or: [self isSimpleContents]) ifTrue: [^OrderedCollection new].	^self x2oAttributeGroup</body><body package="XMLObjectMarshalers">xmlAttributes	(textMarshaler notNil or: [ baseType notNil ]) ifTrue: [^OrderedCollection new].	^self x2oAttributes</body><body package="XMLObjectMarshalers">xmlComplexTypeContentChoice	"simpleContent: there are no elements only attributes and text "	| marshalers |	self isSimpleContents ifTrue: [^self addXMLSimpleContent. ].	(self compositor isChoiceMarshaler or: [self compositor isGroup])		ifTrue: [^self compositor xmlContentAspect -&gt;self compositor].	"complexContents: extension or restriction "	baseType ifNotNil: [^self addXMLComplexContent].	"sequence: no base type "	^(marshalers := self elementConstraints) notEmpty		ifTrue: [self compositor xmlContentAspect -&gt;(self compositor asCompositorTypeStruct												at: #marshalers put: marshalers;												yourself )]		ifFalse: [nil]</body><body package="XMLObjectMarshalers">xmlCompositor	^self compositor</body><body package="XMLObjectMarshalers">xmlText	^(baseType notNil and: [ baseType isComplexTypeMarshaler ])		ifTrue: [ nil ]		ifFalse: [ textMarshaler ]</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>private</category><body package="XMLObjectMarshalers">relations: aCollection	aCollection do: [ :each | self addElementMarshaler: each].</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getRealMarshalerMarshal: aMarshalingContext"ComplexObjectMarshaler can return a marshaler for derived types.http://www.w3.org/TR/xmlschema-0/#abstractXML Schema provides a mechanism to force substitution for a particular element or type. When an element or type is declared to be abstract, it cannot be used in an instance document. When an element is declared to be abstract, a member of that element's substitution group must appear in the instance document. When an element's corresponding type definition is declared as abstract, all instances of that element must use xsi:type to indicate a derived type that is not abstract. "	| realMarshaler |	((self smalltalkClass == aMarshalingContext value class) and: [self isAbstract not ])		ifTrue: [aMarshalingContext useInlineType ifTrue: [self setInlineTypeFor: aMarshalingContext source marshalingContext: aMarshalingContext ].				^self ].	(self isAbstract and: [self smalltalkClass == aMarshalingContext value class])		ifTrue: [WrongObjectType new					messageText: ((#TheComplexTypeIsDeclaredAsAbstract &lt;&lt; #webservices &gt;&gt; 'The complex type &lt;1s&gt; is declared to be "abstract", and an instance of this class can not be used in XML document') expandMacrosWith: self smalltalkClass name asString);					parameter: aMarshalingContext value;					raise ].	realMarshaler := aMarshalingContext manager 					marshalerForObject: aMarshalingContext value					ifAbsent: [ ^self ].	(realMarshaler inheritsFrom: self )		ifFalse: [realMarshaler := NoMarshalerSignal new				messageText: ((#FoundMarshaler1sExceptedMarshalerDerived &lt;&lt; #webservices &gt;&gt; 'Found marshaler:  &lt;1s&gt; for &lt;2s&gt;. Expected a marshaler derived from the abstract type: &lt;3s&gt;')				expandMacrosWith: realMarshaler path printString with: aMarshalingContext value printString with: self path printString );				parameter: aMarshalingContext value;				raiseRequest ].	realMarshaler setInlineTypeFor: aMarshalingContext source marshalingContext: aMarshalingContext.	^realMarshaler</body><body package="XMLObjectMarshalers">marshalElement: marshaler from: marshalingContext	^marshalingContext marshalRelation: marshaler implementation: self aspectImplementation</body><body package="XMLObjectMarshalers">marshalElementsFrom: marshalingContext	keyMarshalers ifNotNil: [ self registerKeysFrom: marshalingContext].	self attributeMarshalers do: [ :attrMarshaler | self marshalElement: attrMarshaler from: marshalingContext ].	anyAttributeMarshaler ifNotNil: [ self marshalElement: anyAttributeMarshaler from: marshalingContext].	textMarshaler ifNotNil: [self marshalElement: textMarshaler from: marshalingContext ].	self compositor marshalFrom: marshalingContext implementation: self aspectImplementation</body><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext	super privateMarshalFrom: marshalingContext.	self marshalElementsFrom: marshalingContext.</body><body package="XMLObjectMarshalers">registerKeysFrom: marshalingContext	| coll |	keyMarshalers do: [ :keym |		coll := keym relations collect: [ :relMarshaler | 			aspectImplementation 				getAspect: relMarshaler relation 				for: marshalingContext value 				context: marshalingContext ].		marshalingContext  manager addKey: (keym-&gt;coll) value: marshalingContext value].</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	| n |	number &gt; 4 		ifTrue: [ | clName |				clName := self aspectImplementation isDictionary 					ifTrue: [ self smalltalkClass fullName ] 					ifFalse: [self smalltalkClassName].				^stream nextPutAll: ' ', clName, ' new '.].	n := number + 1. 	(self compositor relation isManyRelation and: [self smalltalkClass isVariable])		ifTrue: [self printIndexedVarsOn: stream indentation: n ]		ifFalse: [stream nextPutAll: self smalltalkClassName, ' new'.				self printAspectsOn: stream indentation: n ].	self relations notEmpty		ifTrue: [ 	stream cr; tab: n; nextPutAll: 'yourself' ].</body><body package="XMLObjectMarshalers">printAspectsOn: stream indentation: number	self aspectRelations 		do: [ :r |  			stream cr; tab: number; nextPutAll: r relation setSelector, ' ('. 			r printArgsOn: stream indentation: number.			stream nextPutAll: ');' ].</body><body package="XMLObjectMarshalers">printIndexedVarsOn: stream indentation: number	stream nextPutAll: '(', self smalltalkClassName, ' new: 1 )'.	self printAspectsOn: stream indentation: number.	stream cr; tab: number; nextPutAll: 'at: 1 put: ('.	self compositor printStructArgsOn: stream indentation: number.	stream nextPutAll: ');'</body><body package="XMLObjectMarshalers">printObjectRelation: aTypeMarshaler on: stream indentation: number	(aTypeMarshaler isKindOf: AnyRelationMarshaler) ifTrue: [ ^aTypeMarshaler printArgsOn: stream indentation: number + 1 ].	aTypeMarshaler typeMarshaler ifNotNil: [ :type | 		number &gt; 4 ifTrue: 			[type isSimpleType ifTrue: [^type printArgsOn: stream indentation: number].			^stream nextPutAll: ' ',type smalltalkClass name, ' new '.].		type printArgsOn: stream indentation: number + 1 ]</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">copyFrom: anotherMarshaler"This method is used to copy relations from a super class. If a subtype is an extension to a base type where the base type group model is a sequence the elements order has to be preserved. First should be base type elements and then extensions"	super copyFrom: anotherMarshaler.	aspectImplementation := anotherMarshaler aspectImplementation.	anotherMarshaler elementMarshalers reverseDo:		 [ :elementMarshaler |self compositor marshalers addFirst: elementMarshaler ].	anotherMarshaler attributeMarshalers reverseDo:		 [ :elementMarshaler | self  attributeMarshalers addFirst: elementMarshaler ].	textMarshaler := anotherMarshaler textMarshaler.	keyMarshalers := anotherMarshaler keyMarshalers.</body><body package="XMLObjectMarshalers">postCopy	super postCopy.	aspectImplementation := aspectImplementation copy.	attributeMarshalers :=  attributeMarshalers collect: [ :r | r copy].	anyAttributeMarshaler := anyAttributeMarshaler copy.	keyMarshalers := ((keyMarshalers ~~nil and: [keyMarshalers notEmpty ])						ifTrue: [keyMarshalers collect: [ :m | m copy]]						ifFalse: [keyMarshalers copy]).	textMarshaler := textMarshaler copy.	compositor := compositor copy.</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue: [^self].	super nodesDo: aBlock withRegistry: anIdentitySet.	anyAttributeMarshaler		ifNotNil: [anyAttributeMarshaler nodesDo: aBlock withRegistry: anIdentitySet].	self compositor marshalers		do: [:m | m nodesDo: aBlock withRegistry: anIdentitySet].	textMarshaler		ifNotNil: [textMarshaler nodesDo: aBlock withRegistry: anIdentitySet].	self attributeMarshalers		ifNotNil: 			[attributeMarshalers				do: [:attr | attr nodesDo: aBlock withRegistry: anIdentitySet]].	keyMarshalers notNil		ifTrue: 			[keyMarshalers do: [:m | m nodesDo: aBlock withRegistry: anIdentitySet]]</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">newDictionary	^StructMarshaler new</body><body package="XMLObjectMarshalers">newIdentityDictionary	^StructMarshaler new		beIdentityDictionaryAspects;		yourself</body><body package="XMLObjectMarshalers">newObject	^self new		beObjectAspects;		yourself</body><body package="XMLObjectMarshalers">newStruct	^self newDictionary</body><body package="XMLObjectMarshalers">newUnorderedMarshaler	^self new			useUnorderedMarshaler;			yourself</body></methods><methods><class-id>WebServices.ComplexObjectMarshaler class</class-id> <category>accessing</category><body package="XMLObjectMarshalers">defaultCompositor	^defaultCompositor ifNil: [ defaultCompositor := SequentialMarshaler  ]</body><body package="XMLObjectMarshalers">defaultCompositor: aCompositorMarshaler	defaultCompositor := aCompositorMarshaler</body></methods><methods><class-id>WebServices.ModelGroupMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	self beDictionaryAspects.	smalltalkClass := aspectImplementation name asSymbol asQualifiedReference valueOrDo: [nil].</body></methods><methods><class-id>WebServices.ModelGroupMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isModelGroup	^true</body></methods><methods><class-id>WebServices.ModelGroupMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">setSmalltalkClassFrom: attributesx in: builder</body></methods><methods><class-id>WebServices.ModelGroupMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	self compositor unmarshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">detectChoiceFrom: aMarshalingContext  ifFound: aBlock	self relations do: [ :each | each detectChoiceFrom: aMarshalingContext  ifFound: aBlock  ]</body></methods><methods><class-id>WebServices.ModelAttributeGroupMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oRelations	^super x2oRelations</body><body package="XMLObjectMarshalers">xmlAttributes	^self relations</body></methods><methods><class-id>WebServices.ModelAttributeGroupMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isModelAttributeGroup	^true</body></methods><methods><class-id>WebServices.ModelAttributeGroupMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	self unmarshalAttributesFrom: marshalingContext do: aBlock</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">beMandatory	self relation minOccurs: 1</body><body package="XMLObjectMarshalers">beMany	relation isManyRelation ifFalse: [relation := ManyRelation from: relation].	^relation</body><body package="XMLObjectMarshalers">beNillable	self params at: #nillable put: true</body><body package="XMLObjectMarshalers">beOptional 	self relation minOccurs: 0</body><body package="XMLObjectMarshalers">defaultValue	^self params at: #defaultValue ifAbsent: [nil]</body><body package="XMLObjectMarshalers">defaultValue: aValue	self params at: #defaultValue put: aValue.</body><body package="XMLObjectMarshalers">dontBeNillable	self params at: #nillable put: false</body><body package="XMLObjectMarshalers">inlineTypeNode	^self typeMarshaler inlineTypeNode</body><body package="XMLObjectMarshalers">isGlobal: aBoolean	self params at: #isGlobal put: aBoolean</body><body package="XMLObjectMarshalers">relation	^relation</body><body package="XMLObjectMarshalers">smalltalkClass	^nil"	^marshaler smalltalkClass"</body><body package="XMLObjectMarshalers">smalltalkClassName	^marshaler isNil		ifTrue: [ #Object ]		ifFalse: [ marshaler smalltalkClass name asString ]</body><body package="XMLObjectMarshalers">symbolSpace	^#element</body><body package="XMLObjectMarshalers">typeMarshaler" Answer object marshaler that represents a type, not relation. This means either simple type or complex object. Relation marshaler answer type marshaler of their real marshaler "	^marshaler notNil 		ifTrue: [marshaler typeMarshaler ]		ifFalse: [ nil ]</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">aspect: aString	relation name: aString</body><body package="XMLObjectMarshalers">marshaler: aMarshaler	marshaler := aMarshaler</body><body package="XMLObjectMarshalers">relation: aRelation	relation := aRelation</body><body package="XMLObjectMarshalers">resetRelationTo: aString	relation		name: aString;		setSelector: (aString, ':') asSymbol;		getSelector: aString asSymbol.</body><body package="XMLObjectMarshalers">typeMarshaler: aMarshaler	marshaler := aMarshaler</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">acceptMarshaler: resolvedMarshalers" The marshaler can be type marshaler or ImplicitMarshaler"	^resolvedMarshalers 		detect: [ :resolved | resolved isType or: [resolved isImplicit] ] 		ifNone: [ nil ]</body><body package="XMLObjectMarshalers">addElementMarshaler: aSimpleOrObjectTypeMarshaler"If we set a marshaler here the marshaler is local type      &lt;s:element name='GetLifeExpectancy'&gt;        &lt;s:complexType&gt;          &lt;s:sequence&gt;            &lt;s:element  name='Age' type='s:int' /&gt;          &lt;/s:sequence&gt;        &lt;/s:complexType&gt;      &lt;/s:element&gt; "	aSimpleOrObjectTypeMarshaler isRelationMarshaler		ifTrue: [ self error: 'There is something with XML to Object binding if we come here with a RelationMarshaler' ]		ifFalse: [ marshaler := aSimpleOrObjectTypeMarshaler.				marshaler setIsLocalType ]</body><body package="XMLObjectMarshalers">addEnumValues: collectionOfValue	"Enhance the type marshaler to ensure the use of enumeration values in &lt;collectionOfValue&gt;."	| simple |	(simple := self relationMarshaler) isSimpleType		ifFalse: [self error: (#OnlySimpleTypeCanBeRefined &lt;&lt; #webservices &gt;&gt; 'Only simple types can be refined')].	simple addEnumValues: collectionOfValue</body><body package="XMLObjectMarshalers">addRestriction: restrictionType value: aValue	"Enhance the type marshaler to guard the given restriction."	| simple |	(simple := self relationMarshaler) isSimpleType		ifFalse: [self error: (#OnlySimpleTypeCanBeRefined &lt;&lt; #webservices &gt;&gt; 'Only simple types can be refined')].	simple addRestriction: restrictionType value: aValue</body><body package="XMLObjectMarshalers">buildEmptyFromTag: aNodeTag	tag := aNodeTag.	relation := OneRelation new.	relation 		minOccurs: 0;		maxOccurs: 0;		name: tag type.	xpath buildFrom: aNodeTag xpath: aNodeTag asString for: self.</body><body package="XMLObjectMarshalers">buildFromTag: aNodeTag	self buildFromTag: aNodeTag xpath: aNodeTag asString</body><body package="XMLObjectMarshalers">buildFromTag: aNodeTag marshaler: aMarshaler" This is 'backdoor' initialization shortcut that is used to build one-sided relations based solely on tag. It is used in WSDL because for RPC-style methods we need to create a wrapper structure with accessors for each parameter. This way we build parameter marshalers "	self buildFromTag: aNodeTag.	aMarshaler isRelationMarshaler ifTrue: [relation := aMarshaler relation ].	marshaler := aMarshaler.</body><body package="XMLObjectMarshalers">buildFromTag: aNodeTag relation: aRelation marshaler: aMarshaler	tag := aNodeTag.	relation := aRelation.	xpath buildFrom: aNodeTag xpath: '*' for: self.	marshaler := aMarshaler</body><body package="XMLObjectMarshalers">buildFromTag: aNodeTag xpath: xpathExpression" This is 'backdoor' initialization shortcut that is used to build one-sided relations based solely on tag. It is used in WSDL because for RPC-style methods we need to create a wrapper structure with accessors for each parameter. This way we build parameter marshalers "	tag := aNodeTag.	relation := OneRelation new.	relation 		minOccurs: 1;		maxOccurs: 1;		name: tag type.	xpath buildFrom: aNodeTag xpath: xpathExpression for: self.</body><body package="XMLObjectMarshalers">finish	"Still not resolved. Use default if the ref attribute is not specified"	marshaler 		ifNil: [ |ref |			ref := self findDomainValue: 'ref' in: attributes.			(ref isNil and: [self class defaultRefType notNil ])				ifTrue: [marshaler := XMLObjectBinding typeMarshalerForTag:  self class defaultRefType ifAbsent: [nil]]]		ifNotNil: [ (marshaler isRelationMarshaler and: [marshaler typeMarshaler notNil ])  ifTrue: [marshaler := marshaler typeMarshaler.]].			marshaler ifNotNil: [		"Save the default value. The value has to be deserialized from string to real type."		(self findDomainValue: 'default' in: self attributes) ifNotNil: [ :defaultAsString |			"A Simple marshaler may not be resolved yet"			marshaler finish.			self defaultValue: ( marshaler deserializationBlock 								value: MarshalingContext new 								value: defaultAsString 								value: marshaler smalltalkClass) ]]</body><body package="XMLObjectMarshalers">localNameString	" is used by choice marshaler to create xpath " 		^( 'local-name() = "', self tag type, '"' )</body><body package="XMLObjectMarshalers">resolveTypeMarshalerFrom: attributesx in: builder	| ref |	(ref := self findDomainValue: 'ref' in: attributesx) ifNil: [^nil].	builder 		resolve:  ref		do: [ :resolved | 			(marshaler := self acceptMarshaler: resolved) ifNotNil: 				[ (self findValue: 'conversionId' in: attributesx) ifNotNil: 					[ :id | "We need the copy in case of shortcut binding:					&lt;attribute name='selector' ref='xsd:string' conversionId='ByteSymbol'/&gt;								or the binding can be:					&lt;attribute name='selector'&gt;						&lt;simple name='string'  id='ByteSymbol'/&gt;					&lt;/attribute&gt;"				marshaler := marshaler copy setBlocksForId: id ]].				marshaler]</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder	self isGlobal: builder current == builder binding.	self setRelationFrom: attributesx in: builder.	super setAttributesFrom: attributesx in: builder.	self resolveTypeMarshalerFrom: attributesx in: builder.</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	super setLocalAttributesFrom: attributesx in: builder.	(self findDomainValue: 'nillable' in: attributesx ) ifNotNil: [ :value |  		self params at: #nillable put: (Boolean readFrom: value readStream)].	self setQualified: attributesx in: builder.	"If marshaler is still nil it can be resolved later by  by anonymous(local) type  	or in #validate using default marshaler"</body><body package="XMLObjectMarshalers">setNewNamespaceForTag: aNamespaceString qualifier: aQualifierString	super 		setNewNamespaceForTag: aNamespaceString 		qualifier: aQualifierString.	marshaler notNil		ifTrue: 			[ marshaler 				setNewNamespaceForTag: aNamespaceString 				qualifier: aQualifierString ]</body><body package="XMLObjectMarshalers">setQualified: attributesx in: builder	(self findDomainValue: 'form' in: attributesx) 		ifNotNil: [ :form | self qualified: ( 'qualified' match: form )]</body><body package="XMLObjectMarshalers">setRelationFrom: attributesx in: builder	relation := Relation fromAttributes:  attributesx from: self.</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	super postCopy.	relation := relation copy.	marshaler := marshaler copy.</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">canBeMultiref	^marshaler canBeMultiref</body><body package="XMLObjectMarshalers">canBeNillable: aMarshalingContext	^self params at: #nillable ifAbsent: [false ]</body><body package="XMLObjectMarshalers">isAnyAttributeMarshaler	^false</body><body package="XMLObjectMarshalers">isAnyRelationMarshaler	^false</body><body package="XMLObjectMarshalers">isGlobal	^self params at: #isGlobal ifAbsent: [false]</body><body package="XMLObjectMarshalers">isMandatory	^relation isMandatory</body><body package="XMLObjectMarshalers">isNilNode: xmlElement 	^(xmlElement notNil 		and: [ xmlElement isElement 			and: [(xmlElement attributes detect: [ :attr | attr tag = XMLObjectBinding nilNodeTag ] ifNone: [nil]) notNil				and: [ xmlElement elements isEmpty ]]] )</body><body package="XMLObjectMarshalers">isRelationMarshaler	^true</body><body package="XMLObjectMarshalers">isResolved	^marshaler notNil</body><body package="XMLObjectMarshalers">shouldBeQualified	^self qualified or: [self isGlobal ]</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	| myNodes child |	marshalingContext nodes isEmpty ifTrue: [^self missingValueNotification: aBlock].	myNodes := self collectNodesFrom: marshalingContext.	myNodes isEmpty  ifTrue: [^self missingValueNotification: aBlock].	child := marshalingContext asPartMarshaler: self source: marshalingContext source.	child 		aspect: self relation;		nodeContext: myNodes.	self unmarshalFrom: child do: aBlock</body><body package="XMLObjectMarshalers">canAcceptNode: aNodeTag		^self qualified		ifTrue: [ self path  = aNodeTag tag ]		ifFalse: [ xpath xpathNode baseTest match: aNodeTag ]</body><body package="XMLObjectMarshalers">collectNodesFrom: marshalingContext	^self relation collectNodesFrom: marshalingContext do: [ :node  | self canAcceptNode: node ].</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext do: aBlock	|  nodes  |	nodes := self getSourceFrom: marshalingContext. 	nodes isEmpty  ifTrue: [^self missingValueNotification: aBlock].	marshalingContext 		aspect: self relation;		nodeContext: nodes. 	self unmarshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">detectChoiceFrom: aMarshalingContext ifFound: aBlock	(self canAcceptNode: aMarshalingContext node  ) 		ifTrue: [aMarshalingContext marshaler: self.				aBlock value: self]</body><body package="XMLObjectMarshalers">getRealMarshaler: marshalingContext unmarshal: anElement	^self typeMarshaler getRealMarshaler: marshalingContext unmarshal: anElement</body><body package="XMLObjectMarshalers">missingValueNotification: aBlock	"For backward compatibility we need to return an empty collection if there is no nodes for maxOccurs&gt;1 "	self relation isManyRelation ifTrue: [aBlock value: ( MarshalingContext new 																aspect: self relation; 																value: self relation createInstance; 																yourself)].	MissingValueNotification raiseWith: self missingValueText</body><body package="XMLObjectMarshalers">missingValueText	^'&lt;' , self path type , '&gt;'</body><body package="XMLObjectMarshalers">unmarshalCollectionFrom: marshalingContext do: aBlock	|  child |	marshalingContext nodes keysAndValuesDo: 			[:idx :item | 			child := marshalingContext asPartMarshaler: self source: marshalingContext source.			child nodeContext: (OrderedCollection with: item).			self 				unmarshalObjectFrom: child 				do: [ :mc |					marshalingContext value isSequenceable 						ifTrue: [ marshalingContext value at: idx put: mc value ]						ifFalse: [ marshalingContext value add: mc value ]]].	aBlock value: marshalingContext.</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	self relation unmarshalFrom: marshalingContext relationMarshaler: self do: aBlock.</body><body package="XMLObjectMarshalers">unmarshalHRefFrom: aMarshalingContext	^relation isOneRelation 		ifTrue: 			[aMarshalingContext manager 				resolveHReference: aMarshalingContext 				fromElement: aMarshalingContext node]		ifFalse: [ false ]</body><body package="XMLObjectMarshalers">unmarshalObjectFrom: marshalingContext  do: aBlock	marshalingContext nodes isEmpty ifTrue: [^self missingValueNotification: aBlock].	self 		resolveFrom: marshalingContext 		do: [ :object |			" If target object was resolved through key reference, marshaling context			contains the actual target and no further marshaling is done."			marshalingContext isReference 				ifTrue: [marshalingContext aspect: self relation. 						^aBlock value: marshalingContext ].							self 			validateNode: marshalingContext node 			for: marshalingContext			onDefaultValue: [:mc| ^aBlock value: mc ].				(self isNilNode: marshalingContext node ) 	ifTrue: [ marshalingContext value: nil. ^aBlock value: marshalingContext ].		marshalingContext nodes do: [ :node |			marshalingContext 				marshaler: (self getRealMarshaler: marshalingContext unmarshal: node);				source: node;				nodeContext: (OrderedCollection with: node);				unmarshalDo: [ :mc | 					marshalingContext 						aspect: self relation;						value: mc value.					aBlock value: marshalingContext ]]].</body><body package="XMLObjectMarshalers">validateNode: aNode for: marshalingContext onDefaultValue: aBlock						self defaultValue ifNotNil: [ :val | 		marshalingContext node isEmpty 	ifTrue: [			marshalingContext 				aspect: self relation;				value: val.			^aBlock value: marshalingContext  ]].					((self isNilNode: aNode) and: [(self canBeNillable: marshalingContext) not ])		ifTrue: [NilValueNotAllowed new				messageText: ((#NilValueNotAllowed1s &lt;&lt; #webservices &gt;&gt; 'There is a nil value for element: &lt;1s&gt;  that has been described with nillable="false" ') expandMacrosWith: aNode  tag type);				parameter: aNode;				raiseRequest ].</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>private</category><body package="XMLObjectMarshalers">relationMarshaler	^marshaler</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	self relation isManyRelation ifTrue: [stream nextPutAll: self relation collectionClass name, ' with: (' ].	marshaler ifNotNil: [marshaler  printArgsOn: stream indentation: number].	self relation isManyRelation 	ifTrue: [stream nextPut: $) ]</body><body package="XMLObjectMarshalers">printOn: aStream	super printOn: aStream.	relation notNil		ifTrue: [aStream space. relation printOn: aStream]</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oConversionId	^( self findDomainValue: 'conversionId' in: attributes ) ifNotNil: [ :val |  val ].</body><body package="XMLObjectMarshalers">x2oLocalContents	self typeMarshaler ifNil: [^nil].	^self typeMarshaler isLocalType		 ifTrue: [self typeMarshaler x2oContents asSymbol -&gt; self typeMarshaler ]		ifFalse: [ nil ]</body><body package="XMLObjectMarshalers">x2oType	^self xmlType</body><body package="XMLObjectMarshalers">xmlAspect	self relation name ifNil: [^nil].	^(self xmlName isNil or: [self relation name asString ~= self xmlName asString])		ifTrue: [self relation name asString]		ifFalse: [ nil]</body><body package="XMLObjectMarshalers">xmlDefaultValue	"Answer the encoded string for the #defaultValue for printing in XML schemas and bindings."	| dv tm |	(dv := self defaultValue) isNil ifTrue: [^nil].	^(tm := self typeMarshaler) serializationBlock		value: (MarshalingContext new value: dv)		value: tm smalltalkClass</body><body package="XMLObjectMarshalers">xmlLocalContents	^(self typeMarshaler notNil and: [ self typeMarshaler isLocalType ])		 ifTrue: [OrderedCollection with: self typeMarshaler ]		ifFalse: [OrderedCollection new]</body><body package="XMLObjectMarshalers">xmlMaxOccurs	^self relation xmlMaxOccurs</body><body package="XMLObjectMarshalers">xmlMinOccurs	^self relation xmlMinOccurs</body><body package="XMLObjectMarshalers">xmlNillable	^(self params at: #nillable ifAbsent: [^nil ]) printString</body><body package="XMLObjectMarshalers">xmlRef	^nil</body><body package="XMLObjectMarshalers">xmlType	^(( self findDomainValue: 'ref' in: attributes ) notNil		and: [self typeMarshaler notNil ])  ifTrue: [ self typeMarshaler tag ].</body><body package="XMLObjectMarshalers">xmlUnion	^(self typeMarshaler isLocalType and: [ self typeMarshaler isUnionType ])		 ifTrue: [self typeMarshaler ]		ifFalse: [ nil ]</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>tool</category><body package="XMLObjectMarshalers">addAspectRelationTo: aCollection	aCollection add: self</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getChoiceValueFrom: anObject implementation: aspectImplementation marshalingContext: marshalingContext	^(aspectImplementation validateAspect: self relation for: anObject context: marshalingContext)		ifTrue: [self -&gt;(aspectImplementation 						getAspect: self relation 						for:  anObject 						context: marshalingContext)]		ifFalse: [ nil ]</body><body package="XMLObjectMarshalers">marshalDefaultValueFrom: marshalingContext"http://www.w3.org/TR/xmlschema-0/#cardinalityTable(0, 1) -, 37	element may appear once; if it does not appear it is not provided; if it does appear and it is empty, its value is 37; otherwise its value is that givenMarshal element as empty "	marshalingContext shouldEncodeValue: false.	xpath setNodeAndMarshalFrom: marshalingContext do: []</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext	| child |	child := marshalingContext asPartMarshaler: self 	value: (marshalingContext getValueFor: self relation).	self setNodeAndMarshalFrom: child.</body><body package="XMLObjectMarshalers">privateMarshalFrom: aMarshalingContext	aMarshalingContext value isNil ifTrue: [^nil].	self keyRefMarshaler notNil		ifTrue: [self keyRefMarshaler marshalFrom: aMarshalingContext]		ifFalse:			[self typeMarshaler notNil				ifTrue: [ (self typeMarshaler getRealMarshalerMarshal: aMarshalingContext) 							marshalFrom: aMarshalingContext.]				ifFalse: [ ^aMarshalingContext notifyNoMarshalerFor: self tag ]]</body><body package="XMLObjectMarshalers">setInlineTypeFor: anElement marshalingContext: aMarshalingContext</body><body package="XMLObjectMarshalers">setNodeAndMarshalFrom: marshalingContext 	| default |	relation marshalFrom: marshalingContext		do: 			[:value |			"complain about nil mandatory values if the node is defined as not nillable  "			value ifNil: [relation handleNilValueFor: marshalingContext nillable: (self canBeNillable: marshalingContext )].			"if nil and nillable=true we will encode an empty element with xsi:nil='true'  attribute"			marshalingContext source: nil; tag: nil; value: value; resetReference.			((default := self defaultValue) notNil				and: [default = marshalingContext value ]) 					ifTrue: ["If the element was described with a default value and the marshaling context has the same value 						we create an empty element. "						^self marshalDefaultValueFrom: marshalingContext].			xpath setNodeAndMarshalFrom: marshalingContext do: [self privateMarshalFrom: marshalingContext]]</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>comparing</category><body package="XMLObjectMarshalers">= aMarshaler	^self tag = aMarshaler tag and: [ aMarshaler isRelationMarshaler ]</body></methods><methods><class-id>WebServices.RelationMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue:[^self].	relation nodesDo: aBlock withRegistry: anIdentitySet.	(marshaler notNil		and: [marshaler params at: #isLocalType ifAbsent: [false]])			ifTrue: [marshaler nodesDo: aBlock withRegistry: anIdentitySet].	super nodesDo: aBlock withRegistry: anIdentitySet</body></methods><methods><class-id>WebServices.RelationMarshaler class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">emptyRelationFrom: aNodeTag 	^self new buildEmptyFromTag: aNodeTag</body><body package="XMLObjectMarshalers">manyRelationFrom: aNodeTag	^self manyRelationFrom: aNodeTag partMarshaler: nil</body><body package="XMLObjectMarshalers">manyRelationFrom: aNodeTag partMarshaler: aMarshaler 	| rel |	rel := ManyRelation  new 			name: aNodeTag type; 			minOccurs: 1;			maxOccurs: -1;			yourself.	^self new			buildFromTag: aNodeTag			relation: rel			marshaler: aMarshaler;			yourself</body><body package="XMLObjectMarshalers">oneRelationFrom: aNodeTag 	^self new buildFromTag: aNodeTag</body><body package="XMLObjectMarshalers">relation: aRelation	^self new		relation: aRelation;		yourself</body><body package="XMLObjectMarshalers">relation: aRelation marshaler: aMarshaler	^self new		relation: aRelation;		marshaler: aMarshaler;		yourself</body></methods><methods><class-id>WebServices.RelationMarshaler class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">defaultRefType	^defaultRefType ifNil: [ NodeTag 							qualifier: ''							ns: XMLObjectBinding defaultUriXsd							type: 'anyType' ]</body><body package="XMLObjectMarshalers">defaultRefType: aNodeTag	defaultRefType := aNodeTag</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isAttribute	^true</body><body package="XMLObjectMarshalers">isAttributeMarshaler	^true</body><body package="XMLObjectMarshalers">qualified	^qualified == nil		ifTrue: [ self binding ifNotNil: [ self binding attributeQualified] ifNil: [false] ]		ifFalse: [qualified ]</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oSimpleContent	^self typeMarshaler isLocalType		ifTrue: [self typeMarshaler x2oContents -&gt;self typeMarshaler]		ifFalse: [ nil ]</body><body package="XMLObjectMarshalers">xmlSimpleContent	^self typeMarshaler isLocalType		ifTrue: [self typeMarshaler]		ifFalse: [ nil ]</body><body package="XMLObjectMarshalers">xmlUse	| use |	use := self findValue: 'use' in: attributes.	^use = 'optional'		ifTrue: [ nil  ]		ifFalse: [ use ]</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">symbolSpace	^#attribute</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: aMarshalingContext do: aBlock	(aMarshalingContext nodes 		detect: [ :attr | (attr key = self path) or: [attr key namespace isEmpty and: [attr key type = self path type]]] 		ifNone: [nil])			ifNotNil: [ :attr | | child |				aMarshalingContext nodes remove: attr.				(child := aMarshalingContext asPartMarshaler: self source: aMarshalingContext source)					nodeContext: (OrderedCollection with: attr).				self unmarshalFrom: child do: aBlock ]			ifNil: [ self defaultValue ifNotNil: [ :val | 						aMarshalingContext 							aspect: self relation;							value: val.						^aBlock value: aMarshalingContext].								self relation isMandatory ifTrue: [				MissingValueSignal new					errorString: ((#ComplexType1sMissingRequiredAttribute &lt;&lt; #webservices &gt;&gt; 'Complex type: &lt;1s&gt; is missing required attribute: &lt;2s&gt;')					expandMacrosWith: aMarshalingContext parent source tag printString  with: self path type );					parameter: aMarshalingContext parent source;					raiseSignal]].</body><body package="XMLObjectMarshalers">getRealMarshaler: marshalingContext unmarshal: anElement	^marshaler</body><body package="XMLObjectMarshalers">validateNode: aNode for: marshalingContext onDefaultValue: aBlock	fixed ifNotNil: [		(self attributes associations detect: [ :assoc| assoc key type = 'fixed'] ifNone: [nil]) ifNotNil: [ :assoc |			assoc value = aNode value ifFalse: [ 				^WrongObjectType new					messageText: ((#AttributeHasWrongFixedValue &lt;&lt; #webservices &gt;&gt; 'The attribute &lt;1s&gt; has a wrong fixed value: &lt;2s&gt;. Expected &lt;3s&gt;') expandMacrosWith: self tag printString with: aNode value  with: fixed printString );					parameter: aNode;					raise ]]]</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	xpath xpathPrefix: '@'.</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalDefaultValueFrom: marshalingContext" Skip marshaling for attribute default values.http://www.w3.org/TR/xmlschema-0/#cardinalityTableoptional, -, 37	attribute may appear once; if it does not appear its value is 37, otherwise its value is that given "</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext	| child value |	[value := marshalingContext getValueFor: self relation]		on: MissingValueNotification		do: [ :ex | 			fixed 				ifNotNil: [value := fixed]				ifNil: [ex pass]].	(fixed notNil and: [value ~= fixed]) ifTrue: [		^WrongObjectType new			messageText: ((#WrongFixedValue &lt;&lt; #webservices &gt;&gt; 'Wrong attribute fixed value. Expected &lt;1s&gt; for: #&lt;2s&gt;') expandMacrosWith: fixed printString with: self relation getSelector);			parameter: self;			raise  ].	child := marshalingContext  asPartMarshaler: self value: value.	self setNodeAndMarshalFrom: child.</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	fixed ifNotNil: [^stream nextPutAll: fixed printString].	super printArgsOn: stream indentation: number.</body></methods><methods><class-id>WebServices.AttributeMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">finish	(fixed notNil and: [marshaler isNil])		ifTrue: ["Let's use string to encode/decode the fixed value"				marshaler := XMLObjectBinding 							typeMarshalerForTag: (NodeTag qualifier: '' ns: XMLObjectBinding defaultUriXsd type: 'string' )							ifAbsent: [nil]].	super finish.</body><body package="XMLObjectMarshalers">resolveTypeMarshalerFrom: attributesx in: builder	super resolveTypeMarshalerFrom: attributesx in: builder.	(fixed notNil and: [marshaler notNil])		ifTrue: [ 	fixed := marshaler deserializationBlock 							value: (MarshalingContext new value: fixed)  							value: fixed  							value: marshaler smalltalkClass]</body><body package="XMLObjectMarshalers">setRelationFrom: attributesx in: builder	| minOccurs |	 fixed := ( self findValue: 'fixed' in: attributesx) 		ifNotNil: [ :fValue | fixed := fValue ].		 minOccurs := ( self findValue: 'use' in: attributesx) 		ifNil: ["Check minOccurs in case of old mapping " 			 ( self findValue: 'minOccurs' in: attributesx) 				ifNil: [ 0 ]				ifNotNil: [ Relation minOccursFromAttributes: attributesx from: self ]]		ifNotNil: [ :use | use = 'required' ifTrue: [1] ifFalse: [ 0 ] ].	(relation := OneRelation new)		minOccurs: minOccurs;		maxOccurs: 1;		setAttributes:  attributesx from: self.	^relation</body></methods><methods><class-id>WebServices.ImplicitAttributeMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">acceptMarshaler: resolvedMarshalers	^resolvedMarshalers 		detect: [ :resolved | resolved isAttribute ] 		ifNone: [ nil ]</body><body package="XMLObjectMarshalers">finish	super finish.	" If 'ref' attribute is not present,we resolved the marshaler by its local type and we need  inherit its path "	(xpath xpathNode isNil and: [ marshaler notNil]) ifTrue: [ xpath := marshaler xpath ]</body><body package="XMLObjectMarshalers">resolveTypeMarshalerFrom: attributesx in: builder" If 'ref' attribute is present,we resolve marshaler by its ref name and copy xpath prefix and suffix from the resolved marshaler. This way we inherit its 'bias', that is, if the resolved marshaler was looking for child nodes, we will inherit that.  ""The key should #element but for backward compatibility we need to check both #element and #type "	(self findDomainValue: 'ref' in: attributesx) ifNotNil: [ :ref |		builder 			resolve: ref			do: [ :resolved | 				marshaler := self acceptMarshaler: resolved.				marshaler ifNotNil: [					"Implicit marshaler inherits aspect name and selectors  from the resolved marshaler "					self relation							name: marshaler relation name;						setSelector: marshaler relation setSelector;						getSelector: marshaler relation getSelector.					self qualified: marshaler qualified.					self isGlobal: marshaler isGlobal.					(self xpathPrefix isNil and: [self xpathSuffix isNil])						ifTrue: [marshaler xpathPrefix ifNotNil: [self xpathPrefix: marshaler xpathPrefix].							marshaler xpathSuffix ifNotNil: [self xpathSuffix: marshaler xpathSuffix]].					self xpathExpression: marshaler xpath xpathNode baseTest type.					self setXPathNode.					marshaler ]]]</body></methods><methods><class-id>WebServices.ImplicitAttributeMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oSimpleContent	^nil</body><body package="XMLObjectMarshalers">x2oType	^self xmlRef</body><body package="XMLObjectMarshalers">xmlAspect	^nil</body><body package="XMLObjectMarshalers">xmlRef	^self tag</body><body package="XMLObjectMarshalers">xmlSimpleContent	^nil</body><body package="XMLObjectMarshalers">xmlType	^nil</body></methods><methods><class-id>WebServices.RPCEncRelationMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">canBeNillable: aMarshalingContext	^self params at: #nillable ifAbsent: [self class  nillableDefault  ]</body><body package="XMLObjectMarshalers">isElement	^true</body></methods><methods><class-id>WebServices.RPCEncRelationMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">marshalingContextClass	^RPCEncMarshalingContext</body><body package="XMLObjectMarshalers">nillable: aBoolean	self params at: #nillable put: aBoolean</body><body package="XMLObjectMarshalers">useInlineType	^useInlineType ifNil: [true]</body><body package="XMLObjectMarshalers">useInlineType: anObject	useInlineType := anObject</body></methods><methods><class-id>WebServices.RPCEncRelationMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">privateMarshalFrom: aMarshalingContext	self useInlineType ifTrue: [ aMarshalingContext useInlineType: true].	super privateMarshalFrom: aMarshalingContext</body></methods><methods><class-id>WebServices.RPCEncRelationMarshaler class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">nillableDefault	^nillableDefault ifNil: [ self nillableDefaultValue ]</body><body package="XMLObjectMarshalers">nillableDefault: aBoolean	nillableDefault := aBoolean</body></methods><methods><class-id>WebServices.RPCEncRelationMarshaler class</class-id> <category>default values</category><body package="XMLObjectMarshalers">nillableDefaultValue	^false</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>accessing</category><body package="XMLObjectMarshalers">aspect	^aspect</body><body package="XMLObjectMarshalers">aspect: aRelation	aspect := aRelation</body><body package="XMLObjectMarshalers">aspectImplementation	^aspectImplementation</body><body package="XMLObjectMarshalers">aspectImplementation: anAspectImplementation	aspectImplementation := anAspectImplementation</body><body package="XMLObjectMarshalers">beReference" Object being unmarshaled is reference if it has been resolved through key reference "	isReference := true</body><body package="XMLObjectMarshalers">binding	^manager binding</body><body package="XMLObjectMarshalers">elementsNamed: elementName" A hack to mask the fact we can have a collection of elements or an element "	| elements |	elements := (source isKindOf: Node)				ifTrue: [source elements]				ifFalse: [source].	^elementName isString		ifTrue: [elements select: [ :e | e isElement and: [e tag isLike: elementName]]]		ifFalse: [elements select: 					[ :e | e isElement and:							[(e namespace = elementName namespace) 								and: [e tag type = elementName type]]]]</body><body package="XMLObjectMarshalers">index	^temp</body><body package="XMLObjectMarshalers">keyRef	^(keyRefs isNil or: [keyRefs isEmpty])		ifTrue: [nil]		ifFalse: [keyRefs first]</body><body package="XMLObjectMarshalers">keyRef: aValue	keyRefs := OrderedCollection with: aValue</body><body package="XMLObjectMarshalers">keys	^keys</body><body package="XMLObjectMarshalers">keys: aCollection	keys := aCollection</body><body package="XMLObjectMarshalers">manager	^manager</body><body package="XMLObjectMarshalers">manager: anObject	manager := anObject</body><body package="XMLObjectMarshalers">marshaler	^marshaler</body><body package="XMLObjectMarshalers">marshaler: anObject	marshaler := anObject</body><body package="XMLObjectMarshalers">next	^temp next</body><body package="XMLObjectMarshalers">nextIndex	temp isNil		ifTrue: [temp := 0].	^temp := temp + 1.</body><body package="XMLObjectMarshalers">nextPut: anObject	^temp nextPut: anObject</body><body package="XMLObjectMarshalers">node	^nodeContext size &gt; 0		ifTrue: [nodeContext first]		ifFalse: [(nodeContext isKindOf: Node)				ifTrue: [nodeContext]				ifFalse: [nil]]</body><body package="XMLObjectMarshalers">nodeContext	^nodeContext</body><body package="XMLObjectMarshalers">nodeContext: aValue	nodeContext := aValue</body><body package="XMLObjectMarshalers">nodes	^nodeContext</body><body package="XMLObjectMarshalers">parent	^parent</body><body package="XMLObjectMarshalers">parent: anObject	parent := anObject</body><body package="XMLObjectMarshalers">resetReference	isReference := nil</body><body package="XMLObjectMarshalers">setSelectorTo: aSymbol	aspect isNil ifTrue: [aspect := aSymbol]</body><body package="XMLObjectMarshalers">shouldEncodeValue	^shouldEncodeValue ifNil: [true]</body><body package="XMLObjectMarshalers">shouldEncodeValue: aBoolean	shouldEncodeValue := aBoolean</body><body package="XMLObjectMarshalers">source	^source</body><body package="XMLObjectMarshalers">source: anXmlNode	source := anXmlNode</body><body package="XMLObjectMarshalers">tag	^tag</body><body package="XMLObjectMarshalers">tag: aValue	tag := aValue</body><body package="XMLObjectMarshalers">useInlineType	useInlineType ifNotNil: [^useInlineType].	^marshaler useInlineType 		ifNil: [ self binding useInlineType]</body><body package="XMLObjectMarshalers">useInlineType: anObject	useInlineType := anObject</body><body package="XMLObjectMarshalers">value	^value</body><body package="XMLObjectMarshalers">value: anObject	value := anObject</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>marshaling</category><body package="XMLObjectMarshalers">addAttributeNode: anAttributeNode	source notNil		ifTrue: 			[anAttributeNode parent: source.			source addAttribute: anAttributeNode]</body><body package="XMLObjectMarshalers">addNode: anXmlNode	source addNode: anXmlNode.	anXmlNode parent: source.</body><body package="XMLObjectMarshalers">addTextValue	| m |	self  source: Text new.	(m := self marshaler typeMarshaler) ifNotNil: [ m	marshalFrom: self].	self source text:  self value.	self value: nil</body><body package="XMLObjectMarshalers">getValueFor: aRelation	^aspectImplementation getAspect: aRelation for: self value  context: self</body><body package="XMLObjectMarshalers">marshal	 ^self marshaler marshalFrom: self</body><body package="XMLObjectMarshalers">marshalRelation: aTypeMarshaler implementation: anAspectImplementation	aspectImplementation := anAspectImplementation.	^[aTypeMarshaler marshalFrom: self 	]		on: MissingValueNotification, ValidationNotification		do: [ :ex | 			(ValidationNotification handles: ex) ifTrue: [^self validationError: ex text: self value class fullName ].			aTypeMarshaler isMandatory 				ifTrue: [ ex resignalAs: 						(MissingValueSignal new							errorString: ((#IsMissingMandatoryValueFor &lt;&lt; #webservices &gt;&gt; '&lt;1s&gt; is missing mandatory value for: &lt;2s&gt;')							expandMacrosWith: self value class fullName  with: ex parameter);							parameter:  self value;							yourself)]				ifFalse: [ex return]]</body><body package="XMLObjectMarshalers">setAttributesFor:  anElement	| str |	(anElement isElement) ifFalse: [^nil]. 	self value isNil ifTrue: [ self setNilAttributeFor: anElement].	(self marshaler notNil and: [self marshaler requiredAttributes size &gt; 0]) 		ifTrue:			[self marshaler requiredAttributes 				keysAndValuesDo: 					[ :node :v | 					str := (v isString not and: [v qualifier notEmpty])						ifTrue: [ (self setQualifierForTag: v),':', v type.]						ifFalse: [v asString ].					node qualifier notEmpty						ifTrue: [self addNamespace: node namespace  qualifier: node qualifier].				anElement addAttribute: (Attribute name: node  value:  str). ]]</body><body package="XMLObjectMarshalers">setHRefNode: anXmlElement	self value ifNotNil: [ self manager setHRefNode: anXmlElement for: self].	^anXmlElement</body><body package="XMLObjectMarshalers">setNilAttributeFor: anElement	| key q |	key := XMLObjectBinding nilNodeTag.	(q := self getExistingQualifierFor: key) isNil		ifTrue: 			[q := self qualifierFor: key qualifier namespace: key namespace default: 'xsi'.			self addNamespace: key namespace  qualifier: q.].	anElement addAttribute: 				(Attribute 					name:  (NodeTag qualifier: q ns: key namespace type: key type)					value: 'true')</body><body package="XMLObjectMarshalers">setNode: anXmlElement	| tagx node q |	tagx :=  anXmlElement tag.  	q := self setQualifierForTag: tagx.	q ~= tagx qualifier ifTrue: [ tagx resetQualifierTo: q ].	node := (self binding useReference and: [ self marshaler canBeMultiref ])		ifTrue: [self setHRefNode: anXmlElement]		ifFalse: 	[anXmlElement].	parent notNil ifTrue: [self parent addNode: node].	source := node.</body><body package="XMLObjectMarshalers">setNodeAndMarshal	 ^self marshaler setNodeAndMarshalFrom: self</body><body package="XMLObjectMarshalers">setSourceAttributes		self setAttributesFor: source</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>api -- translation</category><body package="XMLObjectMarshalers">marshalerForTag: anXmlTag	^self 		marshalerForTag: anXmlTag 		ifAbsent: [self notifyNoMarshalerFor: anXmlTag ]</body><body package="XMLObjectMarshalers">marshalerForTag: anXmlTag ifAbsent: aBlock	^marshaler marshalerForTag: anXmlTag ifAbsent: aBlock</body><body package="XMLObjectMarshalers">notifyNoMarshalerFor: anObject	^self manager notifyNoMarshalerFor: anObject</body><body package="XMLObjectMarshalers">notifyNoMarshalerFor: anObject text: aString	^self manager notifyNoMarshalerFor: anObject text: aString</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">asPartMarshaler: partMarshaler 	^(self newChildFor: partMarshaler)		marshaler: partMarshaler;		yourself</body><body package="XMLObjectMarshalers">asPartMarshaler: anXMLTypeMarshaler source: anXmlNode	^(self asPartMarshaler: anXMLTypeMarshaler)		source: anXmlNode 		yourself</body><body package="XMLObjectMarshalers">asPartMarshaler: partMarshaler value: anObject	^(self asPartMarshaler: partMarshaler)		value: anObject;		resetReference;		yourself</body><body package="XMLObjectMarshalers">newChild	^self species new		parent: self;		manager: manager;		yourself</body><body package="XMLObjectMarshalers">newChildFor: aTypeMarshaler	| m cl |	m := (cl := aTypeMarshaler marshalingContextClass) notNil		ifTrue: [cl new]		ifFalse: [self species new].	m		parent: self;		manager: manager.	^m</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>testing</category><body package="XMLObjectMarshalers">isReference" Object being unmarshaled is reference if it has been resolved through key reference "	^isReference == true</body><body package="XMLObjectMarshalers">isResolved	^self isUnresolved not</body><body package="XMLObjectMarshalers">isUnresolved	^value == self class unresolvedValue</body><body package="XMLObjectMarshalers">makeUnresolved	value := self class unresolvedValue</body><body package="XMLObjectMarshalers">notReference" Object being unmarshaled is reference if it has been resolved through key reference "	^self isReference not</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream	aStream nextPutAll: 'Marshaling Context on '.	marshaler printOn: aStream</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>namespaces</category><body package="XMLObjectMarshalers">addNamespace: aString qualifier: aQualifierString" Add namespace to the dictionary of namespaces. Answer qualifier "	aQualifierString notEmpty ifTrue: [ manager recordNamespace: aString qualifier: aQualifierString].	^aQualifierString</body><body package="XMLObjectMarshalers">addQualifierForTag: aNodeTag 	| q |	^((q := self getExistingQualifierFor: aNodeTag ) == nil		or: [ q isEmpty ])		ifTrue: 			[self 				addNamespace: aNodeTag namespace 				qualifier: ( self 							qualifierFor: aNodeTag qualifier 							namespace: aNodeTag namespace 							default: (self defaultQualifierForTag: aNodeTag) )]		ifFalse: [ q]</body><body package="XMLObjectMarshalers">defaultQualifierForTag: aNodeTag	| b |	^(b := XMLObjectBinding bindingAtNamespace: aNodeTag namespace) == nil		ifTrue: [nil]		ifFalse: [b defaultQualifier ]</body><body package="XMLObjectMarshalers">getExistingQualifierFor: aNode	^self manager getExistingQualifierFor: aNode namespace</body><body package="XMLObjectMarshalers">namespace	^source notNil 		ifTrue: [source tag namespace]		ifFalse: [nil]</body><body package="XMLObjectMarshalers">qualifierFor: aProposedQualifier namespace: aString default: defaultQualifier" Obtain qualifier for given namespace. Answer qualifier of this namespace if it can be found in namespace map. Otherwise manufacture a new qualifier in such a way that it does not match any of qualifiers in eiher namespaces or in namespace map "	^self manager qualifierFor: aProposedQualifier namespace: aString default: defaultQualifier</body><body package="XMLObjectMarshalers">setQualifierForAttributeNode: aNodeTag	self setQualifierForAttributeNode: aNodeTag marshaler: marshaler</body><body package="XMLObjectMarshalers">setQualifierForAttributeNode: aNodeTag marshaler: aTypeMarshaler	| default q  |	aTypeMarshaler shouldBeQualified ifFalse: [^aNodeTag resetQualifierTo: '' ].	"The attribute has to be qualified "	aNodeTag namespace isEmpty ifTrue:  [aNodeTag resetNamespaceTo: aTypeMarshaler tag namespace].	(self manager getExistingQualifierFor: aNodeTag namespace) ifNotNil: [ :qx | ^aNodeTag resetQualifierTo: qx ].	(XMLObjectBinding bindingAtNamespace: aNodeTag namespace) ifNotNil: [ : b | default := b defaultQualifier ].	q := self 		addNamespace: aNodeTag namespace 		qualifier: (self 					qualifierFor: aNodeTag qualifier 					namespace: aNodeTag namespace 					default: default).	aNodeTag qualifier ~= q ifTrue: [ aNodeTag resetQualifierTo: q].</body><body package="XMLObjectMarshalers">setQualifierForTag: aNodeTag "http://www.xfront.com/HideVersusExpose.htmlTechnical Requirements for Hiding (Localizing) NamespacesThere are two requirements on an element for its namespace to be hidden from instance documents:[1] The value of elementFormDefault must be 'unqualified'.[2] The element must not be globally declared. For example:    &lt;?xml version='1.0'?&gt;    &lt;xsd:schema ...&gt;        &lt;xsd:element name='foo'&gt;        ...    &lt;/xsd:schema ...&gt;The element foo can never have its namespace hidden from instance documents, regardless of the value of elementFormDefault. foo is a global element (i.e., an immediate child of &lt;schema&gt;) and therefore must always be qualified. To enable namespace hiding the element must be a local element."	| q |	q := aNodeTag qualifier.	aNodeTag namespace = '' ifTrue: [^q].  	^self marshaler shouldBeQualified		ifTrue: [ self binding usePrefixedSchemaTags				ifTrue: [ 	self addQualifierForTag: aNodeTag]				ifFalse: ['']]		ifFalse: [ '' ].</body><body package="XMLObjectMarshalers">shouldAddNs: aNodeTag"a namespace is added to an element if the element tag namespace is different than its  parent tag namespace"	marshaler qualified ifFalse: [^false].	^(aNodeTag qualifier isEmpty 		and: [self parent isNil or: [self parent source isNil 			or: [self parent source tag namespace  ~= aNodeTag namespace ]]])</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	value := self class unresolvedValue</body><body package="XMLObjectMarshalers">resetKeys	keys := nil.</body></methods><methods><class-id>WebServices.MarshalingContext</class-id> <category>unmarshaling</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: aBlock	aspect := marshaler relation.	self unmarshal: 		[ marshaler acceptNodesAndUnmarshal: self do: aBlock]</body><body package="XMLObjectMarshalers">decodeAndUnmarshal: aBlock	aspect := marshaler relation.	self unmarshal: 		[self marshaler decodeAndUnmarshalFrom: self do: aBlock]</body><body package="XMLObjectMarshalers">processUnmarshalingError:  exception 	exception resignalAs: 		(MissingValueSignal new			errorString: ((#ComplexType1sMissingMandatoryNode2s &lt;&lt; #webservices &gt;&gt; 'Complex type: &lt;1s&gt; is missing mandatory node: &lt;2s&gt;')					expandMacrosWith: self source tag printString  with: exception parameter);			parameter: self source;			yourself   ).</body><body package="XMLObjectMarshalers">unmarshal	self unmarshalDo: [ :mc | ^mc value ].	^ObjectNotResolvedSignal raiseRequestWith: self</body><body package="XMLObjectMarshalers">unmarshal: aBlock	[aBlock value	]	on: MissingValueNotification, ValidationNotification	do: [ :ex | 		" If the object we are unmarshaling have been resolved through keyRef,		it's real content may be missing and is all optional. The actual object 		has been placed set as the value of child's marshaling context, so we will 		simply return it. Otherwise, marshaling context's value is nil "		(ValidationNotification handles: ex) ifTrue: [^self validationError: ex text: self source tag printString ].		(self marshaler  isMandatory and: [self isReference not])			ifTrue: [ self  processUnmarshalingError:  ex]			ifFalse: [ex return: self value]]</body><body package="XMLObjectMarshalers">unmarshalDo: aBlock	 ^marshaler unmarshalFrom: self do: aBlock</body><body package="XMLObjectMarshalers">validationError:  exception text:  aString	exception  resignalAs: (		ValidationError new			errorString: ((#ValidationFailedFor &lt;&lt; #webservices &gt;&gt; 'Validation failed for: &lt;1s&gt;. &lt;2s&gt;')				expandMacrosWith: aString  with: exception errorString);			parameter: exception parameter;			yourself )</body></methods><methods><class-id>WebServices.MarshalingContext class</class-id> <category>constants</category><body package="XMLObjectMarshalers">unresolvedValue	^UnresolvedValue</body></methods><methods><class-id>WebServices.MarshalingContext class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">manager: anXMLObjectMarshalingManager	^self new		manager: anXMLObjectMarshalingManager;		yourself</body><body package="XMLObjectMarshalers">marshaler: aTypeMarshaler	^self new		marshaler: aTypeMarshaler;		yourself</body><body package="XMLObjectMarshalers">new	^super new initialize</body></methods><methods><class-id>WebServices.MarshalingContext class</class-id> <category>class initialization</category><body package="XMLObjectMarshalers">initialize	" self initialize "	UnresolvedValue := Object new.</body></methods><methods><class-id>WebServices.RPCEncMarshalingContext</class-id> <category>namespaces</category><body package="XMLObjectMarshalers">shouldAddNs: aNodeTag	"Hack to skip namespaces for the rpc/encoded children. See  SoapParameterMarshaler&gt;&gt;asRpcFrom:"	(aNodeTag namespace isEmpty or: [ aNodeTag qualifier isEmpty ])		ifTrue: [ ^false ].		^(self parent isNil or: [self parent source isNil 			or: [self parent source tag namespace  ~= aNodeTag namespace]])</body></methods><methods><class-id>WebServices.RPCEncMarshalingContext</class-id> <category>marshaling</category><body package="XMLObjectMarshalers">setNilAttributeFor: anElement		super setNilAttributeFor: anElement.	"Soap Array patch:VW implementation tried to follow the spec and doesn't create  arrayType attribute for the nil arrays  but there are some poor servers that expect empty length for those arrays (SOAP-ENC:arrayType='ns1:string[]' )47662: case 363685. Soap array type for nil value is not consistent"	(self marshaler isRelationMarshaler and: [ self marshaler typeMarshaler isKindOf: SoapArrayMarshaler ])		ifTrue: [ self marshaler typeMarshaler setInlineTypeFor: source marshalingContext: self  ]</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">elementMarshaler	^elementMarshaler</body><body package="XMLObjectMarshalers">elementMarshalers	^OrderedCollection with: elementMarshaler</body><body package="XMLObjectMarshalers">smalltalkClassName	^self smalltalkClass name asString</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">acceptClass: theClass	^self smalltalkClass notNil		and: [self smalltalkClass == theClass			or: [theClass  inheritsFrom: self smalltalkClass ]]</body><body package="XMLObjectMarshalers">isCollectionType	^true</body><body package="XMLObjectMarshalers">isResolved	^self elementMarshaler notNil</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">createInstanceFor: marshalingContext	^[self smalltalkClass new: marshalingContext nodes size] 		on: Error 		do: [ :ex | self smalltalkClass basicNew]</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext do: aBlock	self elementMarshaler decodeAndUnmarshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	marshalingContext newChild		marshaler: self elementMarshaler;		nodeContext: marshalingContext nodeContext;		source: marshalingContext source;		decodeAndUnmarshal:  [ :mc | 			marshalingContext value: mc value.			aBlock value: marshalingContext ]</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addElementMarshaler: relationMarshaler	relationMarshaler beMany.	relationMarshaler relation collectionClass: self smalltalkClass.	(relationMarshaler xpath xpathPrefix notNil		and: ['child*' match: relationMarshaler xpath xpathPrefix ])		ifFalse: [relationMarshaler xpathPrefix: 'child::'; setXPathNode ].	relationMarshaler isElement 		ifTrue: [ elementMarshaler := relationMarshaler ]		ifFalse: [ self error: ( #CollectionMarshalerExpectsInstaceOfElement &lt;&lt; #webservices &gt;&gt; 'CollectionObjectMarshaler expects an instance of ElementMarshaler or ImplicitMarshaler. Received: &lt;1s&gt;' expandMacrosWith: relationMarshaler printString )].</body><body package="XMLObjectMarshalers">defaultSmalltalkClassName	^self class defaultSmalltalkClass</body><body package="XMLObjectMarshalers">finish	elementMarshaler ifNil: [self error: (#NoMarshalerForCollection &lt;&lt; #webservices &gt;&gt; 'No element marshaler for collection')]</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder" Set any attributes we are interested in "	super setAttributesFrom: attributesx in: builder.	" If collection element is referenced here by means of 'ref=xxx', 	create a dummy '&lt;implicit ref=xxx/&gt;' element "	(self findValue: 'ref' in: attributesx ) notNil		ifTrue: 			[builder pushCurrent: self.			(builder newResolverAt: 'implicit') 				setAttributesFrom: attributesx copy in: builder.			builder popCurrent].</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext	| child |	marshalingContext value isNil		ifTrue: [ MissingValueNotification raiseWith: (#Collection &lt;&lt; #webservices &gt;&gt; '[collection:&lt;1s&gt;]' expandMacrosWith: marshalingContext source tag type) ].	child := marshalingContext 				asPartMarshaler: self elementMarshaler					value: marshalingContext value.	^self elementMarshaler setNodeAndMarshalFrom: child</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">isSimpleContents	^false</body><body package="XMLObjectMarshalers">x2oContents	^'sequence_of'</body><body package="XMLObjectMarshalers">xmlComplexTypeContentChoice	^#xmlSequence-&gt;( Struct new at: #marshalers put: (OrderedCollection with: self elementMarshaler); yourself )</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	smalltalkClass := self class defaultSmalltalkClass asQualifiedReference valueOrDo: [nil]</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	self elementMarshaler notNil		ifTrue: [self elementMarshaler printArgsOn: stream indentation: number + 1]		ifFalse: [stream nextPutAll: ' ', self smalltalkClass name, ' new.' ]</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue:[^self].	super nodesDo: aBlock withRegistry: anIdentitySet.	self elementMarshaler nodesDo: aBlock withRegistry: anIdentitySet</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler class</class-id> <category>accessing</category><body package="XMLObjectMarshalers">defaultSmalltalkClass	^defaultSmalltalkClass ifNil: [defaultSmalltalkClass := self defaultSmalltalkClassValue]</body><body package="XMLObjectMarshalers">defaultSmalltalkClass: anObject	defaultSmalltalkClass := anObject</body></methods><methods><class-id>WebServices.CollectionObjectMarshaler class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">defaultSmalltalkClassValue	^'OrderedCollection'</body></methods><methods><class-id>WebServices.SimpleTypeMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">acceptClass: theClass	^true</body><body package="XMLObjectMarshalers">canBeMultiref	^false"	^self conversionId = 'String'"</body><body package="XMLObjectMarshalers">isAbstract	^false</body><body package="XMLObjectMarshalers">isSimpleType	^true</body></methods><methods><class-id>WebServices.SimpleTypeMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	super setLocalAttributesFrom: attributesx in: builder.	tag ifNil:		[(self findDomainValue: 'baseType' in: attributesx ) ifNotNil: [:base | tag := NodeTag qualifier: '' ns: base namespace type: base type].		tag ifNil: [tag := builder current tag].		xpath xpathExpression:  tag type asString ].</body><body package="XMLObjectMarshalers">setNewNamespaceForTag: aNamespaceString qualifier: aQualifierString</body></methods><methods><class-id>WebServices.SimpleTypeMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	self unmarshalFrom: marshalingContext do: aBlock.	marshalingContext nodeContext remove: marshalingContext node.</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext do: aBlock	marshalingContext nodeContext: marshalingContext source.	self unmarshalFrom: marshalingContext do: aBlock</body></methods><methods><class-id>WebServices.SimpleTypeMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oContents	^'simple'</body><body package="XMLObjectMarshalers">xmlContents	^'simpleType'</body><body package="XMLObjectMarshalers">xmlEnumeration	^nil</body><body package="XMLObjectMarshalers">xmlList	^nil</body><body package="XMLObjectMarshalers">xmlName	^(self isLocalType or: [ name isNil ] ) ifTrue: [ nil ]  ifFalse: [self name type]</body><body package="XMLObjectMarshalers">xmlRestriction	^nil</body><body package="XMLObjectMarshalers">xmlUnion	^nil</body></methods><methods><class-id>WebServices.SimpleTypeMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">elementMarshalers	^#()</body><body package="XMLObjectMarshalers">simpleContentBaseType</body><body package="XMLObjectMarshalers">symbolSpace	^#type</body></methods><methods><class-id>WebServices.SimpleTypeMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalFrom: marshalingContext	^xpath 		marshalFrom: marshalingContext 		do: [self privateMarshalFrom: marshalingContext]</body></methods><methods><class-id>WebServices.SimpleTypeMarshaler</class-id> <category>comparing</category><body package="XMLObjectMarshalers">= aMarshaler	^self tag = aMarshaler tag and: [ aMarshaler isSimpleType ]</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isChoiceMarshaler	^true</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">aspectRelations	^OrderedCollection with: self</body><body package="XMLObjectMarshalers">elementMarshalers		^OrderedCollection with: self</body><body package="XMLObjectMarshalers">smalltalkClass	^self relation isManyRelation ifTrue: [OrderedCollection ] ifFalse: [ WebServices.Struct ]</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">finish	| |	super finish."	stream := String new writeStream.	stream nextPutAll:  '*[' .	self marshalers 		do: [ :each | stream nextPutAll: each localNameString ]		separatedBy: [ stream nextPutAll: ' or ' ].	stream nextPutAll:  ' ]'.	 	xpath 		buildFrom: xpath parent tag 		xpath: stream contents 		for: xpath parent."</body><body package="XMLObjectMarshalers">localNameString	" is used by choice marshaler to create xpath " 	| stream |	stream := String new writeStream.	self marshalers		do: [ :each | stream nextPutAll:  each localNameString ]		separatedBy: [ stream nextPutAll:  ' or '].	^stream contents</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder	super setAttributesFrom: attributesx in: builder</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	super setLocalAttributesFrom: attributesx in: builder.	tag := NodeTag qualifier: '' ns: '' type: 'choice'.</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">asCompositorTypeStruct</body><body package="XMLObjectMarshalers">complexTypeContentAspect	^#xmlChoice</body><body package="XMLObjectMarshalers">xmlContentAspect	^#xmlChoice</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	| n |	self relation isManyRelation ifTrue: [ stream nextPutAll: 'OrderedCollection with: ('.].	stream nextPutAll: '"&lt;choice of associations&gt;"'; cr.	n := number + 1.	self marshalers		do: [ :mx | 			stream tab: n; nextPutAll: '#', mx  relation name, ' -&gt; '.			mx printArgsOn: stream indentation: n.			stream cr].	stream tab: number + 1; nextPutAll: '"&lt;/choice of associations&gt;"'.	self relation isManyRelation ifTrue: [ stream nextPutAll: ')' ].</body><body package="XMLObjectMarshalers">printOn: aStream	aStream		nextPutAll: self class name, ' of:';		space.	self marshalers 		do: [ :each | each printOn: aStream]		separatedBy: [ aStream nextPutAll: ' or ' ]</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>private</category><body package="XMLObjectMarshalers">privateAdd: marshalerx" Add choice sub-marshaler. If there is already marshaler defined raise an error "	| copy |	(self marshalers anySatisfy: [ :m | m tag = marshalerx tag ] )		ifTrue: [self error: ((#TheMarshalerHasBeingDefined &lt;&lt; #webservices &gt;&gt; 'The marshaler for the &lt;1s&gt; node has being already defined.')				expandMacrosWith: marshalerx tag printString)].	(self relation isManyRelation and: [marshalerx relation isOneRelation])		ifTrue:			[copy := self relation copy.			copy 				name: marshalerx relation name;				setSelector: marshalerx relation setSelector;				getSelector: marshalerx relation getSelector.				marshalerx relation: copy].	self marshalers add: marshalerx</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">collectNodesFrom: marshalingContext	| myNodes nodes |	myNodes := OrderedCollection new.	[nodes := OrderedCollection new.	self marshalers do: [ :each | nodes addAll: (each collectNodesFrom: marshalingContext)].	nodes notEmpty]		whileTrue: [myNodes addAll: nodes].	^myNodes</body><body package="XMLObjectMarshalers">detectChoiceFrom: aMarshalingContext  ifFound: aBlock		self marshalers do: [ :each | each detectChoiceFrom: aMarshalingContext  ifFound: aBlock ]</body><body package="XMLObjectMarshalers">missingValueText	| stream |	stream := String new writeStream.	stream nextPutAll: '&lt;choice: '.	marshalers 		do: [ :each | stream nextPutAll: (each path ifNil: [each relation name] ifNotNil: [ :p | p type])]		separatedBy: [stream nextPut: Character space].	stream nextPut: $&gt;.	^stream contents</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	| child |	child := self newChildFrom: marshalingContext.	child nodes isEmpty ifTrue: [		self relation isManyRelation ifTrue: [aBlock value: ( MarshalingContext new 																aspect: self relation; 																value: self relation createInstance; 																yourself)].		^self isMandatory ifTrue: [ MissingValueNotification raiseWith: self missingValueText, ' in ', marshalingContext source tag printString ]].	self 		acceptNodesAndUnmarshal: child 		do: [ :mc |			mc aspect: self relation.			aBlock value: mc. ].</body><body package="XMLObjectMarshalers">unmarshalObjectFrom: marshalingContext  do: aBlock	| choiceValue |	marshalingContext node ifNil: [^nil].	self 		detectChoiceFrom: marshalingContext   		ifFound: [ :mx | 			mx 				acceptNodesAndUnmarshal: marshalingContext 				do: [ :mc | 					choiceValue := self class useStructAsChoiceValue 						ifTrue: [ Struct new add: mc aspect name -&gt; mc value; yourself ]						ifFalse: [mc aspect name -&gt; mc value ].					marshalingContext value: choiceValue.					aBlock value: marshalingContext  ].			^nil ].	^nil</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize."	xpath := XMLMarshalerProxy new."</body></methods><methods><class-id>WebServices.ChoiceMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getChoiceValueFrom: anObject implementation: anAspectImplementation marshalingContext: marshalingContext	self marshalers do: [:each |		(each			getChoiceValueFrom: anObject			implementation: anAspectImplementation			marshalingContext: marshalingContext) ifNotNil: [:assoc | ^assoc]].	^nil</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext 	| value assoc implementation child |	value := marshalingContext getValueFor: self relation.	self validateValue: value.	self relation		marshalFrom: (marshalingContext asPartMarshaler: self value: value)		do:  [:val |			assoc := val isStruct						ifTrue: [val associations]						ifFalse: [OrderedCollection with: val].			implementation := AspectImplementation associationAspects.			assoc do: [:assocx |				assocx key 	ifNotNil: [ self marshalers do: [:mx |						(mx							getChoiceValueFrom: assocx							implementation: implementation							marshalingContext: marshalingContext) ifNotNil: [ :mv | 								child := marshalingContext newChildFor: mv key.								child									source: marshalingContext source;									value: assocx;									marshalRelation: mv key implementation: implementation]]]]]</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext implementation: anAspectImplementation	marshalingContext marshalRelation: self implementation: anAspectImplementation.</body><body package="XMLObjectMarshalers">raiseMissingValue	| str |	str := (#ChoiceOf &lt;&lt; #webservices &gt;&gt;'choice: ') asString.	self marshalers do: [ :mx | str := str, (mx tag ifNotNil: [ :t | t type] ifNil: [mx relation name]), ' ' ] .	 MissingValueNotification raiseWith: '&lt;',str, '&gt;'</body><body package="XMLObjectMarshalers">validateValue: aValue	| item |	item := (aValue isKindOf: Collection)		ifTrue: [(self relation isManyRelation and: [aValue isEmpty])				ifTrue: [self raiseMissingValue].				aValue first]		ifFalse: [aValue ].	item := item isStruct ifTrue: [item associations first] ifFalse: [item].	(item notNil and: [ (item isKindOf: Association) not ])		ifTrue: [WrongObjectType new					messageText: ((#WrongChoiceValue1s &lt;&lt; #webservices &gt;&gt; 'Wrong choice value &lt;1s&gt;. The object is not a Dictionary, or Struct, or Association') expandMacrosWith: aValue class name);					parameter: aValue;					raise].	(self isMandatory  and: [item isNil or: [item key isNil] ] ) ifTrue: [self raiseMissingValue]</body></methods><methods><class-id>WebServices.ChoiceMarshaler class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">useStructAsChoiceValue	^useStructAsChoiceValue ifNil: [self useStructAsChoiceValueValue]</body><body package="XMLObjectMarshalers">useStructAsChoiceValue: aBoolean	useStructAsChoiceValue := aBoolean</body><body package="XMLObjectMarshalers">useStructAsChoiceValueValue	^false</body></methods><methods><class-id>WebServices.ElementMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isElement	^true</body></methods><methods><class-id>WebServices.ElementMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	xpath xpathPrefix: 'child::'.</body></methods><methods><class-id>WebServices.StructMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oContents	^'struct'</body><body package="XMLObjectMarshalers">x2oSmalltalkClass	^nil</body><body package="XMLObjectMarshalers">xmlContents	^'struct'</body></methods><methods><class-id>WebServices.StructMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isStructMarshaler	^true</body></methods><methods><class-id>WebServices.StructMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">beDictionaryAspects	aspectImplementation := AspectImplementation dictionaryAspects</body><body package="XMLObjectMarshalers">beIdentityDictionaryAspects	aspectImplementation := AspectImplementation identityDictionaryAspects</body><body package="XMLObjectMarshalers">initialize	super initialize.	aspectImplementation := AspectImplementation dictionaryAspects.	smalltalkClass := aspectImplementation name asSymbol asQualifiedReference valueOrDo: [nil]</body></methods><methods><class-id>WebServices.StructMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">createInstanceFor: marshalingContext" Callback from the manager. Invoked when object is to be resolved by creating a new instance of the object. Can be overridden i.e. by collection marshalers. "	^self smalltalkClass new</body><body package="XMLObjectMarshalers">getRealMarshaler: marshalingContext unmarshal: anElement	^self</body></methods><methods><class-id>WebServices.StructMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getRealMarshalerMarshal: aMarshalingContext	(aMarshalingContext value  isStruct or: [ aMarshalingContext value isKindOf: Dictionary ]) 		ifFalse: [^WrongObjectType new			messageText: ((#WrongObjectSelector1sShouldReturnInstance &lt;&lt; #webservices &gt;&gt; 'Wrong object. Selector: #&lt;1s&gt; should return an instance of: &lt;2s&gt;. Received: &lt;3s&gt;') 							expandMacrosWith:  aMarshalingContext marshaler relation getSelector							with: self smalltalkClass name 							with:  aMarshalingContext value class name );			parameter: aMarshalingContext value;			raise ].	aMarshalingContext useInlineType ifTrue: [self setInlineTypeFor: aMarshalingContext source marshalingContext: aMarshalingContext ].	^self</body></methods><methods><class-id>WebServices.StructMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">setSmalltalkClassFrom: attributesx in: builder"The class is set in #initialize "</body></methods><methods><class-id>WebServices.StructMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	| n rel |	number &gt; 4 	ifTrue: [ 	^stream nextPutAll: self smalltalkClass fullName, ' new'.].	n := number + 1. 	stream nextPutAll: self smalltalkClass fullName, ' new'.	rel := self aspectRelations.	rel do: [ :r | stream cr;tab: n; nextPutAll: 'at: #', r relation name, ' put: ('.			r printArgsOn: stream indentation: n + 2.			stream nextPutAll: ');' ].	rel notEmpty ifTrue: [ stream cr; tab: n; nextPutAll: 'yourself ' ].</body></methods><methods><class-id>WebServices.IdentityStructMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oContents	^'identityStruct'</body></methods><methods><class-id>WebServices.IdentityStructMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	aspectImplementation := AspectImplementation identityDictionaryAspects.	smalltalkClass := aspectImplementation name asSymbol asQualifiedReference valueOrDo: [nil]</body></methods><methods><class-id>WebServices.AspectImplementation</class-id> <category>testing</category><body package="XMLObjectMarshalers">isAssociation	^name = 'Association'</body><body package="XMLObjectMarshalers">isDictionary	^name = 'WebServices.Struct'</body><body package="XMLObjectMarshalers">isObject	^name = 'Object'</body><body package="XMLObjectMarshalers">isStruct	^self isDictionary</body></methods><methods><class-id>WebServices.AspectImplementation</class-id> <category>initialization</category><body package="XMLObjectMarshalers">getBlock: aValue	getBlock := aValue</body><body package="XMLObjectMarshalers">name: aValue	name := aValue</body><body package="XMLObjectMarshalers">setBlock: aValue	setBlock := aValue</body><body package="XMLObjectMarshalers">validateBlock: aValue	validateBlock := aValue</body></methods><methods><class-id>WebServices.AspectImplementation</class-id> <category>accessing</category><body package="XMLObjectMarshalers">name	^name</body><body package="XMLObjectMarshalers">validateBlock	^validateBlock</body></methods><methods><class-id>WebServices.AspectImplementation</class-id> <category>api</category><body package="XMLObjectMarshalers">getAspect: aspect for: object context: marshalingContext	^getBlock value: object value: aspect value: marshalingContext</body><body package="XMLObjectMarshalers">setAspectFrom: relation for: object to: value context: marshalingContext	^setBlock valueWithArguments:			(Array with: object with: relation with: value with: marshalingContext)</body><body package="XMLObjectMarshalers">validateAspect: aspect for: object context: marshalingContext	^validateBlock value: object value: aspect value: marshalingContext</body></methods><methods><class-id>WebServices.AspectImplementation</class-id> <category>private</category><body package="XMLObjectMarshalers">getBlock	^getBlock</body><body package="XMLObjectMarshalers">setBlock	^setBlock</body></methods><methods><class-id>WebServices.AspectImplementation</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream	aStream nextPutAll: 'Aspect Implementation for '; nextPutAll: name.</body></methods><methods><class-id>WebServices.AspectImplementation class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">associationAspects	^AssociationAspects</body><body package="XMLObjectMarshalers">dictionaryAspects	^DictionaryAspects</body><body package="XMLObjectMarshalers">identityDictionaryAspects	^IdentityDictionaryAspects</body><body package="XMLObjectMarshalers">newAssociationAspects	^self new			name: 'Association';			getBlock: [ :object :relation :marshalingContext | 						[object key asSymbol = relation getSelector ifTrue: [object value] ifFalse: [nil]]							on: Object messageNotUnderstoodSignal 							do: [:ex | WrongObjectType new							messageText: ((#ObjectNotAssociation &lt;&lt; #webservices &gt;&gt; 'The object is not an Association type: &lt;1s&gt;') expandMacrosWith: object printString);							parameter: object;							raise]];			setBlock: [ :object :relation :value :marshalingContext | 						[object key: relation getSelector value: value]							on: Object messageNotUnderstoodSignal 							do: [:ex | WrongObjectType new							messageText: ((#ObjectNotAssociation &lt;&lt; #webservices &gt;&gt; 'The object is not an Association type: &lt;1s&gt;') expandMacrosWith: object printString);							parameter: object;							raise] ];			validateBlock: [ :object :relation :marshalingContext | 						object key asSymbol  = relation getSelector].</body><body package="XMLObjectMarshalers">newDictionaryAspects	^self new			name: 'WebServices.Struct';			getBlock: [ :object :relation :marshalingContext | 						[object at: relation getSelector ifAbsent: [^MissingValueNotification raiseWith: relation getSelector printString]]							on: Object messageNotUnderstoodSignal 							do: [:ex | WrongObjectType new							messageText: ((#ObjectNotDictionaryOrStruct &lt;&lt; #webservices &gt;&gt; 'The object is not a Dictionary or Struct type: &lt;1s&gt;') expandMacrosWith: object printString);							parameter: object;							raise]];			setBlock: [ :object :relation :value :marshalingContext | 						[object at: relation getSelector put: value]							on: Object messageNotUnderstoodSignal 							do: [:ex | WrongObjectType new							messageText: ((#ObjectNotDictionaryOrStruct &lt;&lt; #webservices &gt;&gt; 'The object is not a Dictionary or Struct type: &lt;1s&gt;') expandMacrosWith: object printString);							parameter: object;							raise] ];			validateBlock: [ :object :relation :marshalingContext | 						object includesKey: relation getSelector].</body><body package="XMLObjectMarshalers">newIdentityDictionaryAspects	^self new 		name: 'IdentityDictionary';		getBlock: [ :object :relation :marshalingContext | 					[object at: relation getSelector asString ifAbsent: [^MissingValueNotification raiseWith: relation getSelector printString]]						on: Object messageNotUnderstoodSignal 						do: [ :ex | WrongObjectType new							messageText: ((#ObjectNotIdentityDictionary &lt;&lt; #webservices &gt;&gt; 'The object is not an IdentityDictionary type: &lt;1s&gt;') expandMacrosWith: object printString);							parameter: object;							raise]];		setBlock: [ :object :relation :value :marshalingContext | 					[object at: relation getSelector asString put: value]						on: Object messageNotUnderstoodSignal 						do: [ :ex | WrongObjectType new							messageText: ((#ObjectNotIdentityDictionary &lt;&lt; #webservices &gt;&gt; 'The object is not an IdentityDictionary type: &lt;1s&gt;') expandMacrosWith: object printString);							parameter: object;							raise]];		validateBlock: [ :object :relation :marshalingContext |						 object includesKey: relation getSelector asString ].</body><body package="XMLObjectMarshalers">newObjectAspects	^self new			name: 'Object';			getBlock: [ :object :relation :marshalingContext | 						[object perform: relation getSelector]							on: Object messageNotUnderstoodSignal 							do: [ :ex |  WrongObjectType new									messageText: ((#DetectedWrongObject &lt;&lt; #webservices &gt;&gt; 'Detected a wrong object. Sending &lt;1s&gt; to &lt;2s&gt;') expandMacrosWith: relation getSelector  printString with: object class fullName);									parameter: object;									raise ]];			setBlock: [ :object :relation :value :marshalingContext | 						[object perform: relation setSelector with: value]							on: Object messageNotUnderstoodSignal 							do: [ :ex |   WrongObjectType new									messageText: ((#DetectedWrongObject &lt;&lt; #webservices &gt;&gt; 'Detected a wrong object. Sending &lt;1s&gt; to &lt;2s&gt;') expandMacrosWith: relation setSelector  printString with: object class fullName);									parameter: object;									raise]];			validateBlock: [ :object :relation :marshalingContext | 							object respondsTo: relation getSelector].</body><body package="XMLObjectMarshalers">newSequenceableCollectionAspects	^self new			name: 'Sequenceable';			getBlock: [ :object :relation :marshalingContext | object at: marshalingContext nextIndex ];			setBlock: [ :object :relation :value :marshalingContext | object at: marshalingContext nextIndex put: value ];			validateBlock: [ :object :relation :marshalingContext | object at: marshalingContext nextIndex ifAbsent: [false]].</body><body package="XMLObjectMarshalers">newStreamAspects	^self new			name: 'Stream';			getBlock: [ :object :relation :marshalingContext | marshalingContext next ];			setBlock: [ :object :relation :value :marshalingContext | marshalingContext nextPut: value ];			validateBlock: [ :object :relation :marshalingContext | marshalingContext respondsTo: #next ]</body><body package="XMLObjectMarshalers">object</body><body package="XMLObjectMarshalers">objectAspects	^ObjectAspects</body><body package="XMLObjectMarshalers">sequenceableCollectionAspects	^SequenceableCollectionAspects</body><body package="XMLObjectMarshalers">setDictionaryAspects: aDictionaryAspect	aDictionaryAspect			getBlock: [ :object :relation :marshalingContext | 						[object at: relation getSelector ifAbsent: [^MissingValueNotification raiseWith: relation getSelector printString] ] 							on: Error do: [ :ex | self error: (#WrongParameterOrXMLSchema &lt;&lt; #webservices &gt;&gt; 'Wrong parameter or XML schema type')]];			setBlock: [ :object :relation :value :marshalingContext | 						[object at: relation getSelector put: value ] 							on: Error do: [ :ex | self error: (#WrongParameterOrXMLSchema &lt;&lt; #webservices &gt;&gt; 'Wrong parameter or XML schema type')]];			validateBlock: [ :object :relation :marshalingContext | object includesKey: relation getSelector].</body><body package="XMLObjectMarshalers">streamAspects	^StreamAspects</body></methods><methods><class-id>WebServices.AspectImplementation class</class-id> <category>accessing</category><body package="XMLObjectMarshalers">associationAspects: aValue	AssociationAspects := aValue</body><body package="XMLObjectMarshalers">dictionaryAspects: aValue	DictionaryAspects := aValue</body><body package="XMLObjectMarshalers">identityDictionaryAspects: aValue	IdentityDictionaryAspects := aValue</body><body package="XMLObjectMarshalers">objectAspects: aValue	ObjectAspects := aValue</body><body package="XMLObjectMarshalers">sequenceableCollectionAspects: aValue	SequenceableCollectionAspects := aValue</body><body package="XMLObjectMarshalers">streamAspects: aValue	StreamAspects := aValue</body></methods><methods><class-id>WebServices.AspectImplementation class</class-id> <category>class initialization</category><body package="XMLObjectMarshalers">initialize	"(self initialize)"	ObjectAspects := self newObjectAspects.	DictionaryAspects := self newDictionaryAspects.	SequenceableCollectionAspects := self newSequenceableCollectionAspects.	StreamAspects := self newStreamAspects.	IdentityDictionaryAspects := self newIdentityDictionaryAspects.	AssociationAspects	:= self newAssociationAspects.</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>accessing</category><body package="XMLObjectMarshalers">addSuperClassType	^addSuperClassType ifNil: [ self class addSuperClassType ]</body><body package="XMLObjectMarshalers">addSuperClassType: anObject	addSuperClassType := anObject</body><body package="XMLObjectMarshalers">allNamespaces" Answer combined map of all namespaces "	| dict map |	dict := Dictionary new: 8.	self contextDo: [ :contextFrame |		map := contextFrame at: #namespaceMap ifAbsent: [nil].		map notNil			ifTrue: [map keysAndValuesDo: [ :q :ns | dict at: q ifAbsentPut: [ns]]]].	^dict</body><body package="XMLObjectMarshalers">binding	^binding</body><body package="XMLObjectMarshalers">binding: anXMLObjectBinding	binding := anXMLObjectBinding</body><body package="XMLObjectMarshalers">current	^self context at: #current ifAbsent: [ nil ]</body><body package="XMLObjectMarshalers">current: anObject	^self context at: #current put: anObject</body><body package="XMLObjectMarshalers">defaultClassNamespace	^self binding defaultClassNamespace</body><body package="XMLObjectMarshalers">defaultNamespace	^self context at: #defaultNamespace ifAbsentPut: [ nil ]</body><body package="XMLObjectMarshalers">defaultNamespace: aURLString	^self context at: #defaultNamespace put: aURLString</body><body package="XMLObjectMarshalers">deserializationBlockFor: conversionId 	^self class deserializationBlockFor: conversionId</body><body package="XMLObjectMarshalers">document	^self binding</body><body package="XMLObjectMarshalers">namespaceAt: aString" Find namespace map moving up context stack "	^self namespaceAt: aString ifAbsent: [nil]</body><body package="XMLObjectMarshalers">namespaceAt: aString ifAbsent: aBlock" Find namespace map moving up context stack "	| namespace |	self contextDo: [ :contextFrame |		namespace := (contextFrame 							at: #namespaceMap 							ifAbsentPut: [Dictionary new])							at: aString ifAbsent: [nil].		namespace notNil 			ifTrue: [^namespace]].	^aBlock value</body><body package="XMLObjectMarshalers">namespaceMap	^self context at: #namespaceMap ifAbsentPut: [ Dictionary new ]</body><body package="XMLObjectMarshalers">namespaceMap: aDictionary	^self context at: #namespaceMap put: aDictionary</body><body package="XMLObjectMarshalers">needToResolveList	^needToResolveList</body><body package="XMLObjectMarshalers">needToResolveTypes	^needToResolveTypes</body><body package="XMLObjectMarshalers">oldBinding	^oldBinding</body><body package="XMLObjectMarshalers">serializationBlockFor: conversionId	^self class serializationBlockFor: conversionId</body><body package="XMLObjectMarshalers">targetNamespace	^self binding isNil		ifTrue: ['']		ifFalse: [self binding targetNamespace ifNil: ['']]</body><body package="XMLObjectMarshalers">unresolvedMessages	| errorMessages message selector |	errorMessages := OrderedCollection new.	message := (#UnresolvedReference1sFrom2s &lt;&lt;#webservices &gt;&gt; 'Unresolved reference &lt;1s&gt;  from selector: #&lt;2s&gt;').	(self needToResolveList asOrderedCollection, self needToResolveTypes asOrderedCollection) do: [ :assoc  |		selector := (((assoc value copiedValues isKindOf: Collection)			ifTrue: [assoc value copiedValues first]			ifFalse: [assoc value copiedValues]) relation )				ifNotNil: [ :rel | rel setSelector]				ifNil: [assoc value copiedValues printString].		errorMessages add: (message  expandMacrosWith: assoc key type with: selector ) ].	^errorMessages</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>private</category><body package="XMLObjectMarshalers">newResolverAt: name	^self class newResolverAt: name</body><body package="XMLObjectMarshalers">prepareAttributes: aCollection	| dict types |	(aCollection detect: [ :attribute | attribute tag type = 'targetNamespace'] ifNone: [nil]) 		ifNotNil: [ :a | self namespaceMap at: '' put: a value ].	dict := Dictionary new: aCollection size.	types := #( 'name' 'ref' 'type' 'baseType' 'tag' 'itemType').	aCollection do: 		[ :attribute | 		( types includes: attribute tag type )			ifTrue: [ dict at: attribute tag put: ( self tagForName: attribute value)]			ifFalse: [dict at: attribute tag put: attribute value]].	^dict</body><body package="XMLObjectMarshalers">selectPragmasFrom: aClass	| coll |	coll := OrderedCollection new.	aClass selectorsAndMethodsDo: 		[ :sel :meth | 		meth attributeMessages ifNotNil: [ :pragmas | 			pragmas do: [:msg |				(self class canUnderstand: msg selector) ifTrue: [ coll add: msg-&gt;sel ]]]].	^coll</body><body package="XMLObjectMarshalers">tagForName: aStringOrNodeTag	| q typex ns tokens |	aStringOrNodeTag isString ifFalse: [^aStringOrNodeTag].	tokens := aStringOrNodeTag tokensBasedOn: $:.	tokens size &gt; 1 			ifTrue: 				[q := tokens first. 				typex := tokens last.				ns := self namespaceAt: tokens first ifAbsent: [nil ]]			ifFalse:				[q := ''. 				ns := self targetNamespace.				typex := aStringOrNodeTag].	(('xml' match: q) and: [ns isNil]) ifTrue: [ns :=  XML_URI ].	^NodeTag qualifier: q ns: ns type: typex</body><body package="XMLObjectMarshalers">tagForName: localName namespace: namespace	^NodeTag qualifier: '' ns: namespace type: localName</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>context</category><body package="XMLObjectMarshalers">context	^contextStack isEmpty		ifTrue: [contextStack add: (IdentityDictionary new: 4)]		ifFalse: [contextStack first]</body><body package="XMLObjectMarshalers">contextDo: aBlock	contextStack do: aBlock</body><body package="XMLObjectMarshalers">popContext		contextStack notEmpty ifTrue: [ contextStack removeFirst ]</body><body package="XMLObjectMarshalers">popCurrent	^self 		popContext;		linkTypeReferences</body><body package="XMLObjectMarshalers">pushContext	^contextStack addFirst: (IdentityDictionary new: 4)</body><body package="XMLObjectMarshalers">pushCurrent: anObject	self 		pushContext;		current: anObject</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>initialization</category><body package="XMLObjectMarshalers">_complete	self linkTypeReferences.	self needToResolve ifTrue: [UnresolvedReferenceSignal signalWith: self ].	self binding ifNotNil: [self binding _complete].</body><body package="XMLObjectMarshalers">finish	self _complete.	self popContext</body><body package="XMLObjectMarshalers">initialize	contextStack := OrderedCollection new: 5.	needToResolveList := IdentitySet new: 64.	needToResolveTypes := IdentitySet new: 64.</body><body package="XMLObjectMarshalers">initializeBindingFor: defaultClassNamespaceString targetNamespace: targetNamespaceString	| attributes |	self namespaceMap at: '' put: XMLBuildingPolicy uriVWBinding.	self namespaceMap at: 'tns'  put:  targetNamespaceString.	self namespaceMap at: 'xsd'  put:  XMLBuildingPolicy defaultUriXsd.	self defaultNamespace: targetNamespaceString.	attributes := OrderedCollection		with: ( Attribute name: 'defaultClassNamespace' value: defaultClassNamespaceString)		with:  ( Attribute name: 'targetNamespace' value: targetNamespaceString).	self startObjectBinding:  'xmlToSmalltalkBinding' attributes: attributes</body><body package="XMLObjectMarshalers">start	self pushContext</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>actions</category><body package="XMLObjectMarshalers">createBindingFor: aString attributes: attributes	| marshaler |	self startObjectBinding: aString attributes: attributes.	marshaler := self current.	self endObjectBinding: aString.	^marshaler</body><body package="XMLObjectMarshalers">endObjectBinding:  localName	self popCurrent</body><body package="XMLObjectMarshalers">linkTypeReferences	|  resolved |	resolved := needToResolveList select: [ :assoc |  		(self binding findMarshalersLike: assoc key ifAbsent: [nil]) 			ifNotNil: [ :marshalers | (assoc value value: marshalers) notNil ]			ifNil: [false]].	needToResolveList removeAll: resolved.	resolved := needToResolveTypes select: [ :assoc |  		(self binding typeMarshalerForTag: assoc key ifAbsent: [nil])			ifNil: [ false ]			ifNotNil: [ :marshaler | assoc value value: marshaler. true]].	needToResolveTypes removeAll: resolved.</body><body package="XMLObjectMarshalers">register: marshaler	self current notNil		ifTrue: [self current add: marshaler]</body><body package="XMLObjectMarshalers">resolve: aNodeTag do: aBlock	| tag  |	tag := self tagForName: aNodeTag.	(self binding findMarshalersLike: tag ifAbsent: [nil])		ifNil: [ needToResolveList add: tag -&gt; aBlock ]		ifNotNil: [ :marshalers | (aBlock value: marshalers) ifNil: [needToResolveList add: tag -&gt; aBlock] ]</body><body package="XMLObjectMarshalers">resolveType: aNodeTag do: aBlock	| tag |	tag := self tagForName: aNodeTag.	(self binding typeMarshalerForTag: tag ifAbsent: [nil])		ifNil: [ needToResolveTypes add: (tag -&gt; aBlock)]		ifNotNil: [ :marshaler | aBlock value: marshaler]</body><body package="XMLObjectMarshalers">startObjectBinding: name attributes: attributes	| marshaler  |	(marshaler := self newResolverAt: name) ifNotNil:		[marshaler setAttributesFrom: (self  prepareAttributes: attributes) in: self.		name = 'xmlToSmalltalkBinding' ifTrue: [self startXMLToSmalltalkBinding: marshaler]].  	self pushCurrent: marshaler</body><body package="XMLObjectMarshalers">startXMLToSmalltalkBinding: aMarshaler		binding := aMarshaler. 	binding targetNamespace ifNil: [^nil].	(oldBinding := XMLObjectBinding bindingAtNamespace: binding targetNamespace)		ifNotNil: [XMLObjectBinding removeBinding: oldBinding ].</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>build XMLObjectBinding</category><body package="XMLObjectMarshalers">addImportedBinding: anXMLObjectBinding	| ind qualifier |	binding importBinding: anXMLObjectBinding.	ind := 0.	qualifier := 'ns'.	[(self allNamespaces at: qualifier ifAbsent: [nil]) isNil ] 		whileFalse: [ qualifier := qualifier, (ind + 1) printString.].	self namespaceMap at: qualifier put: anXMLObjectBinding targetNamespace</body><body package="XMLObjectMarshalers">buildFromClasses: aCollOfClasses classNamespace: aString targetNamespace: targetNamespaceString	| unresolved |	unresolved := OrderedCollection new.	[self		buildX2OFrom: aCollOfClasses 		classNamespace: aString 		targetNamespace: targetNamespaceString.	]  	on: UnresolvedReferenceSignal		do: [ :ex | unresolved add: ex parameter unresolvedMessages. ex proceed ].	unresolved notEmpty ifTrue: [UnresolvedPragmaReferences raiseRequestFrom:  unresolved ].	self binding elementFormDefault: #qualified.	^self binding</body><body package="XMLObjectMarshalers">buildX2OFrom: aCollectionOfClasses classNamespace: defaultClassNamespaceString  targetNamespace: targetNamespaceString	self start.	self initializeBindingFor: defaultClassNamespaceString targetNamespace: targetNamespaceString.	aCollectionOfClasses do: [ :theClass | self buildObjectMarshalerFor: theClass  ].	self linkClassReferences.	self popCurrent.	self finish.	^self binding</body><body package="XMLObjectMarshalers">linkClassReferences"The method is called from schema builders "	(needToResolveList isEmpty and: [ needToResolveTypes isEmpty]) ifTrue: [^nil].	self linkClasses: self missingClasses.</body><body package="XMLObjectMarshalers">linkClasses: classes	| cls |	classes isEmpty ifTrue: [^nil].	self current = self binding ifFalse: [ self pushCurrent: self binding].	classes do: [ :aClass | self buildObjectMarshalerFor: aClass].	self linkTypeReferences.	(cls := self missingClasses) notEmpty ifTrue: [self linkClasses: cls]</body><body package="XMLObjectMarshalers">missingClasses"The method is called from schema builders "	| defaultNamespace className missingClasses |	defaultNamespace := self binding defaultClassNamespace ifNil: [XMLObjectBindingPolicy defaultClassNamespace].	missingClasses := IdentitySet new.	(self needToResolveList asOrderedCollection, self needToResolveTypes asOrderedCollection) do: [ :assoc |		className := ((assoc key type tokensBasedOn: $.) includes: defaultNamespace)			ifTrue: [assoc key type] 			ifFalse: [ defaultNamespace, '.', assoc key type].		(className asSymbol asQualifiedReference valueOrDo: [nil])			ifNotNil: [ :aClass | missingClasses add: aClass]].	^missingClasses</body><body package="XMLObjectMarshalers">resetImportedBindingTo: xmlObjectBindings	binding resetImports.	xmlObjectBindings do: [ :aBinding | aBinding = binding ifFalse: [ self addImportedBinding: aBinding ]].</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>creating specification nodes</category><body package="XMLObjectMarshalers">createSchemaNode	^self binding createSchemaNode</body><body package="XMLObjectMarshalers">createTypesNode	^self binding createTypesNode</body><body package="XMLObjectMarshalers">createXML2SmBindingNode		^self binding createXML2SmBindingNode</body><body package="XMLObjectMarshalers">createXMLObjectBinding	^self binding createXMLObjectBinding</body><body package="XMLObjectMarshalers">printSmalltalkBindingOn: aStream	self binding printSmalltalkBindingOn: aStream</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>specifications </category><body package="XMLObjectMarshalers">asX2OSpecification	^binding asX2OSpecification</body><body package="XMLObjectMarshalers">asXMLSchemaSpecification	^binding asXMLSchemaSpecification</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	| |	super postCopy.	contextStack := contextStack collect: [ :each | each copyWithCopiedValues ]</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>testing</category><body package="XMLObjectMarshalers">needToResolve		^(needToResolveList notEmpty or: [ needToResolveTypes notEmpty])</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>create marshalers</category><body package="XMLObjectMarshalers">addAttribute: anArrayOrSymbol type: typeArrayOrSymbol"Don't remove. Reads type pragmas "	self mapPragmaDescription: anArrayOrSymbol type: typeArrayOrSymbol</body><body package="XMLObjectMarshalers">addElementMarshalerName: aString refClass: theClass	| attributes marshaler type |	marshaler := (XMLObjectBinding simpleTypes includes: theClass )		ifTrue: [type := XMLObjectBinding simpleXMLTypeFor: theClass ifAbsent: [nil].				XMLObjectBinding simpleMarshalerType: type key conversionId: type value ]		ifFalse: [ self buildObjectMarshalerFor: theClass ].	(self binding marshalers 		detect: [:m | m isRelationMarshaler and: [m name type = aString asString ]] 		ifNone: [nil]) ifNotNil: [ :marshalerx | self binding marshalers  remove: marshalerx].	attributes := OrderedCollection new.	attributes 		add: ( Attribute name: 'name' value: aString);		add: ( Attribute name: 'ref' value: (self tagReference: marshaler name)).	^self createBindingFor: 'element' attributes: attributes</body><body package="XMLObjectMarshalers">addMarshalerFor: aString attributes: anXMLAttributes simpleMarshaler: aSimpleObjectMarshaler	self namespaceMap at: 'xsd' put: aSimpleObjectMarshaler tag namespace. 	anXMLAttributes add: ( Attribute name: 'ref' value: 'xsd:', aSimpleObjectMarshaler tag type ).	^self createBindingFor: aString attributes: anXMLAttributes.</body><body package="XMLObjectMarshalers">addMarshalerForArray: xmlAttributes type:  typeArray"typeArray:  #('Float' '1')  The dimention parameter is ignored""Support for SoapArray will be dropped. We encode #Array type as &lt;sequence_of&gt;. "	|   marshaler |	self startObjectBinding: 'element' attributes: xmlAttributes.	marshaler := self createArrayMarshaler: xmlAttributes type:  typeArray.	self endObjectBinding:  'element'.	^marshaler</body><body package="XMLObjectMarshalers">addMarshalerForChoice: xmlAttributes type:  typeArray"typeArray: #(#(#firstChoice #String) #(#secondChoice #Integer)) "	| marshaler relation |	relation :=  'choice'.	self startObjectBinding: relation attributes: xmlAttributes.	typeArray do: [ :coll |self addMarshalerForElement: ( self nameAttribute: coll first) type: coll last  ].	marshaler := self current.	self endObjectBinding: relation.	^marshaler</body><body package="XMLObjectMarshalers">addMarshalerForCollection: anXMLAttributes type:  typeArray"typeArray: #(#'Protocols.Library.Book' '0' '5') "	anXMLAttributes addAll: ( self collectionAttributesFrom:  typeArray).	^self addMarshalerForElement: anXMLAttributes type: typeArray first</body><body package="XMLObjectMarshalers">addMarshalerForElement: anXMLAttributes type: aSymbolOrMarshaler	| type elemMarshaler |	(aSymbolOrMarshaler isKindOf: SimpleObjectMarshaler)		ifTrue: [ ^self addMarshalerFor: 'element' attributes: anXMLAttributes simpleMarshaler: aSymbolOrMarshaler].	type := ((aSymbolOrMarshaler isTypeMarshaler and: [ aSymbolOrMarshaler isComplexTypeMarshaler])		ifTrue: [aSymbolOrMarshaler isObjectType ifTrue: [ aSymbolOrMarshaler smalltalkClass fullName] ifFalse: [nil]]		ifFalse: [aSymbolOrMarshaler]).	type ifNotNil: [ anXMLAttributes addAll: (self xmlTypeFor: type)].	elemMarshaler := self createBindingFor: 'element' attributes: anXMLAttributes.	type ifNil: [ elemMarshaler addElementMarshaler: aSymbolOrMarshaler ].	^elemMarshaler</body><body package="XMLObjectMarshalers">addMarshalerForStruct: xmlAttributes  type: typeArray" typeArray:  #(#string #String) #(#int #Integer)) "	| marshaler |	self startObjectBinding: 'element' attributes: xmlAttributes.	marshaler := self createStructMarshaler: xmlAttributes  type: typeArray.	self endObjectBinding: 'element'.	^marshaler</body><body package="XMLObjectMarshalers">baseTypeFor: aClass 	(self class excludedSupers includes: aClass superclass name ) ifTrue: [^#()].	^self addSuperClassType		ifTrue: [OrderedCollection 				with: ( Attribute name: 'baseType' value: (self classNameFor: aClass superclass) ) 				with: ( Attribute name: 'constraint' value: 'extension')]		ifFalse: [ #() ]</body><body package="XMLObjectMarshalers">cardinalityAttribute: anArrayOrSymbol	| attrDesc |	attrDesc := (anArrayOrSymbol isMemberOf: Array)			ifTrue: [ anArrayOrSymbol last  ]			ifFalse: [#required ].	attrDesc = 'optional' 	ifTrue: [ ^( Attribute name: 'minOccurs' value: '0' ) ].	^nil</body><body package="XMLObjectMarshalers">classNameFor: theClass	| nsName |	self binding defaultClassNamespace ifNil: [self binding defaultClassNamespace: XMLObjectBindingPolicy defaultClassNamespace].	nsName := theClass environment fullName asSymbol.	^((nsName = #Smalltalk		or: [nsName = #Core 			or: [nsName = self binding defaultClassNamespace asSymbol]])		ifTrue: [ theClass name ] 		ifFalse: [ theClass fullName]) asString</body><body package="XMLObjectMarshalers">collectionAttributesFrom:  typeArray"typeArray: #(#'Protocols.Library.Book' '0' '5') " 	| xmlAttributes min max |	xmlAttributes := OrderedCollection new.	min := (typeArray size &gt; 1 		ifTrue: [  (typeArray at: 2) asString ]		ifFalse: [ '0' ]).	xmlAttributes add: ( Attribute name: 'minOccurs' value: min ).	max := (typeArray size &gt; 2 		ifTrue: [ typeArray last asString ]		ifFalse: [ '*' ]).	xmlAttributes add: ( Attribute name: 'maxOccurs' value: max).	^xmlAttributes</body><body package="XMLObjectMarshalers">createArrayMarshaler: xmlAttributes type:  typeArray"typeArray:  #('Float' '1')  The dimention parameter is ignored""Support for SoapArray will be dropped. We encode #Array type as &lt;sequence_of&gt;. "	|   attributes marshaler |	attributes := xmlAttributes copy.	attributes add: ( Attribute name: 'smalltalkClass' value: 'Array').	self startObjectBinding: 'sequence_of' attributes: attributes.	marshaler := self current.	self addMarshalerForElement: (OrderedCollection with: ( Attribute name: 'name' value: 'item')) type: typeArray first.	self endObjectBinding:  'sequence_of'.	^marshaler</body><body package="XMLObjectMarshalers">createCollectionMarshaler: xmlAttributes type: typeArrayOrSymbol"&lt;addParameter: #echoCollection type: #(#Collection #String '1' '20' ) &gt;"	|  marshaler itemName |	self  startObjectBinding: 'sequence_of'  attributes: xmlAttributes.	marshaler := self  current.	itemName := typeArrayOrSymbol first isTypeMarshaler		ifTrue: [typeArrayOrSymbol first smalltalkClass name ]		ifFalse: [ (typeArrayOrSymbol first asString tokensBasedOn: $.) last].	self  		addMarshalerForCollection:  ( self  nameAttribute: itemName)  		type:  typeArrayOrSymbol.	self endObjectBinding: 'sequence_of'.	^marshaler</body><body package="XMLObjectMarshalers">createSimpleMarshalerNamed: aString basedOn: aSimpleObjectMarshaler	"Create a new SimpleObjectMarshaler with given name and baseType.	Add the new type to the marshalers of this binding and answer it."	| attributes |	self namespaceMap at: 'xsd' put: aSimpleObjectMarshaler tag namespace. 	attributes := OrderedCollection new.	attributes 		add: ( Attribute name: 'baseType' value: 'xsd:', aSimpleObjectMarshaler tag type );		add: ( Attribute name: 'name' value: aString ).	^self createBindingFor: 'simple' attributes: attributes.</body><body package="XMLObjectMarshalers">createStructMarshaler: xmlAttributes  type: typeArray" typeArray:  #(#string #String) #(#int #Integer)) "	| marshaler |	self startObjectBinding: 'struct'  attributes: xmlAttributes.	marshaler := self current.	marshaler setDefaultCompositor.	typeArray do: [ :coll |self addMarshalerForElement: ( self nameAttribute: coll first) type: coll last  ].	self endObjectBinding: 'struct'.	^marshaler</body><body package="XMLObjectMarshalers">createStructWithChoiceMarshaler: xmlAttributes type:  typeArray"typeArray: #(#(#firstChoice #String) #(#secondChoice #Integer)) "	| marshaler |	self startObjectBinding: 'struct'  attributes: xmlAttributes.	marshaler := self current.	self addMarshalerForChoice: xmlAttributes type:  typeArray.	self endObjectBinding: 'struct'.	^marshaler</body><body package="XMLObjectMarshalers">nameAttribute: anArrayOrSymbol	| attrDesc attributes |	attributes := OrderedCollection new.	attrDesc := (anArrayOrSymbol isMemberOf: Array)			ifTrue: [ attributes add: ( Attribute name: 'minOccurs' value: '0' ).					anArrayOrSymbol first ]			ifFalse: [ anArrayOrSymbol   ].	attributes addFirst: ( Attribute name: 'name' value: attrDesc asString ).	^attributes</body><body package="XMLObjectMarshalers">tagReference: aNodeTag	| assoc |	assoc := self allNamespaces associations detect: [ :assocx | aNodeTag namespace = assocx value ]  ifNone: [nil].	self namespaceMap at: assoc key  put:  assoc value.	^assoc key, ':',  aNodeTag type</body><body package="XMLObjectMarshalers">xmlTypeFor: aString	| attributes   theClass |	attributes := OrderedCollection new.	(XMLObjectBinding simpleXMLTypeFor: aString ifAbsent: [nil])		ifNotNil: [ :type |			self namespaceMap at: type key qualifier  put: type key namespace. 			attributes add: ( Attribute name: 'ref' value: type key asString).			type value ifNotNil: [ attributes add: ( Attribute name: 'conversionId' value:  type value asString)] ]		ifNil: [ |  reference |			self namespaceMap at: 'tns'  put: self targetNamespace. 			theClass := aString asSymbol asQualifiedReference valueOrDo: [				(self defaultClassNamespace, '.',aString) asSymbol asQualifiedReference valueOrDo: [					UnresolvedPragmaReferences raiseWith: ((#CannotResolveClassReference1s &lt;&lt; #webservices &gt;&gt; 'Can not resolve class reference from the string: &lt;1s&gt;') expandMacrosWith: aString)]].			reference := self xmlTypeReferenceForClass:  theClass.			attributes add: ( Attribute name: 'ref' value: reference ) ].	^attributes</body><body package="XMLObjectMarshalers">xmlTypeReferenceForClass: aClass	(binding importedBindings isEmpty or: [aClass isNil]) 		ifTrue: [ ^'tns:',(self classNameFor:  aClass) asString ].	^(binding localMarshalerForClass: aClass ifAbsent: [nil])		ifNotNil: [ :marshaler | self tagReference: marshaler name  ]		ifNil: [ 'tns:',(self classNameFor:  aClass) asString ]</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>modify marshalers</category><body package="XMLObjectMarshalers">forClass: aClass element: elementName addEnumValues: collectionOfValue	"Modify the marshaler for &lt;aClass&gt;. The type marshaler for the specified element 	shall ensure the use of enumeration values in &lt;collectionOfValue&gt;."	^(self getRelationMarshalerNamed: elementName fromClass: aClass )		addEnumValues: collectionOfValue</body><body package="XMLObjectMarshalers">forClass: aClass element: elementName addRestriction: restrictionType value: aValue	"Modify the marshaler for &lt;aClass&gt;.	The type marshaler for the specified element shall guard the given restriction."	^(self getRelationMarshalerNamed: elementName fromClass: aClass )		addRestriction: restrictionType value: aValue</body><body package="XMLObjectMarshalers">forClass: aClass element: elementName refineSimpleTypeAs: newSimpleTypeName	"Modify the marshaler for &lt;aClass&gt;. The type marshaler for the specified element 	shall use a refined simple type named &lt;newSimpleTypeName&gt;, based on the current type.	Answer the new refined type (a SimpleTypeMarshaler)."	| relMarshaler simple newMarshaler |	relMarshaler := self getRelationMarshalerNamed: elementName fromClass: aClass.	(simple := relMarshaler relationMarshaler) isSimpleType		ifFalse: [self error: (#OnlySimpleTypeCanBeRefined &lt;&lt; #webservices &gt;&gt; 'Only simple types can be refined')].	simple tag type = newSimpleTypeName ifTrue: [^simple].	"Convert the associated simple type to a new simple type based on the current.	Answer the refined type marshaler (a SimpleTypeMarshaler)."	self pushCurrent: self binding.	newMarshaler := self createSimpleMarshalerNamed: newSimpleTypeName basedOn: simple.	relMarshaler typeMarshaler: newMarshaler.	^newMarshaler</body><body package="XMLObjectMarshalers">getRelationMarshalerNamed: aString fromClass: aClass 	| aMarshaler  |	aMarshaler := self binding 					localMarshalerForClass: aClass					ifAbsent: [self error: ((#ObjectMarshalerNotFoundFor1s &lt;&lt; #webservices &gt;&gt; 'Object marshaler is not found for &lt;1s&gt;') expandMacrosWith: aClass name)].	^aMarshaler relations				detect: [:each | each xmlName = aString]				ifNone: [self error: ((#RelationalMarshalerNotFoundFor1s &lt;&lt; #webservices &gt;&gt;'Relational marshaler for the element found') expandMacrosWith: aClass name)].</body></methods><methods><class-id>WebServices.BindingBuilder</class-id> <category>build from pragmas</category><body package="XMLObjectMarshalers">buildObjectMarshalerFor: theClass	| className attributes marshaler baseType |	"Check if the marshaler already exists "	(self binding localMarshalerForClass: theClass ifAbsent: [nil]) ifNotNil: [ :marshalerx | ^marshalerx].	className := self classNameFor: theClass.	" if default class namespace is different, use fully-qualified class names for #name attribute. These names will be use to find classes and build marshalers for them "	attributes := OrderedCollection with: ( Attribute name: 'name' value: className) with: ( Attribute name: 'smalltalkClass' value: className).	attributes addAll: (baseType := self baseTypeFor: theClass).	self startObjectBinding: 'object' attributes: attributes.	marshaler := self current.	marshaler setDefaultCompositor.	(self selectPragmasFrom: theClass) do: [ :assoc | 		self mapPragmaDescription: assoc type: assoc key arguments last.].	self endObjectBinding: 'object'.	baseType notEmpty ifTrue: [ self buildObjectMarshalerFor: theClass superclass ].	^marshaler</body><body package="XMLObjectMarshalers">mapPragmaDescription: anAssoc  type: typeArrayOrSymbol"Parameters:#( #dueDate #optional )  type:  #'Date#acquisitionNumber type: #'LargePositiveInteger'#(#borrowedHoldings #optional)  type: #( #Collection #'Protocols.Library.Book' )#setStruct type: #(#Struct #(#string #String) #(#int #Integer))#myArray type: #(#Array 'Float' '1')#myChoice type: #(#Choice #(#firstChoice #String) #(#secondChoice #Integer))"	| attributes type arguments arrayOrSymbol methodSelector |	arrayOrSymbol := anAssoc key arguments first.	attributes := self nameAttribute: arrayOrSymbol.	methodSelector := anAssoc value last = $:		ifTrue: [anAssoc value copyFrom: 1 to: anAssoc value size - 1]		ifFalse: [anAssoc value].	attributes first value  =  methodSelector		ifFalse: [attributes add: (Attribute name: 'aspect' value: methodSelector )].	(self cardinalityAttribute: arrayOrSymbol ) ifNotNil: [ :attribute | attributes add: attribute ].	(typeArrayOrSymbol isMemberOf: Array)		ifTrue: [type :=typeArrayOrSymbol first asSymbol.				arguments := typeArrayOrSymbol copyFrom: 2 to: typeArrayOrSymbol size ]		ifFalse: [type := #Element.				arguments := typeArrayOrSymbol].	^self  		perform: ('addMarshalerFor', type, ':type:') asSymbol 		with: attributes 		with:  arguments</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>accessing</category><body package="XMLObjectMarshalers">decimalPrintPolicy	^decimalPrintPolicy ifNil: 		[decimalPrintPolicy := NumberPrintPolicy formatTokensFor: '0.0################' ]</body><body package="XMLObjectMarshalers">defaultDeserializationBlock	^[:marshalingContext :aString :class | class readFrom: aString readStream]</body><body package="XMLObjectMarshalers">defaultInitializationBlock	"should this return some kind of XML string "	^[:marshaler :attributes  | ]</body><body package="XMLObjectMarshalers">defaultSerializationBlock	^[:mv :class | mv value printString ]</body><body package="XMLObjectMarshalers">deserializationBlockFor: conversionId 	^self deserializers at: conversionId ifAbsent: [self defaultDeserializationBlock]</body><body package="XMLObjectMarshalers">deserializers	^Deserializers</body><body package="XMLObjectMarshalers">doublePrintPolicy	^doublePrintPolicy ifNil: 		[doublePrintPolicy := NumberPrintPolicy formatTokensFor: '0.0##############E###0' ]</body><body package="XMLObjectMarshalers">floatPrintPolicy	^floatPrintPolicy ifNil: 		[floatPrintPolicy := NumberPrintPolicy formatTokensFor: '0.0#####E##0' ]</body><body package="XMLObjectMarshalers">newResolverAt: aString	^(self registry at: aString ifAbsent: [^nil]) newProxyFor: aString</body><body package="XMLObjectMarshalers">numberPolicy	^numberPolicy ifNil: [numberPolicy := (Locale named: #C) numberPolicy]</body><body package="XMLObjectMarshalers">registry	^Registry</body><body package="XMLObjectMarshalers">resetPolicies	"Reset all formatting policies."	numberPolicy := nil.	floatPrintPolicy := nil.	doublePrintPolicy := nil.	decimalPrintPolicy := nil.</body><body package="XMLObjectMarshalers">serializationBlockFor: conversionId	^self serializers at: conversionId ifAbsent: [self defaultSerializationBlock].</body><body package="XMLObjectMarshalers">serializers	^Serializers</body><body package="XMLObjectMarshalers">xmlBooleanLegalCharacters	^xmlBooleanLegalCharacters ifNil: [xmlBooleanLegalCharacters := Array with: 'true' with: 'false' with: '1' with: '0' ]</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>default values</category><body package="XMLObjectMarshalers">addSuperClassType	^addSuperClassType ifNil: [ addSuperClassType := self addSuperClassTypeValue]</body><body package="XMLObjectMarshalers">addSuperClassType: aBoolean	addSuperClassType := aBoolean</body><body package="XMLObjectMarshalers">addSuperClassTypeValue	^true</body><body package="XMLObjectMarshalers">createBindingForSchemaValue	^false</body><body package="XMLObjectMarshalers">excludedSupersValue	^#(Object Exception Error Model UIModel Magnitude ValueModel) asOrderedCollection</body><body package="XMLObjectMarshalers">schemaParserValue	^(#'WebServices.XMLTypesParser'  asQualifiedReference valueOrDo: [^nil])</body><body package="XMLObjectMarshalers">useAddSuperClassTypeValue	^#false</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">createBindingForSchema	^createBindingForSchema ifNil: [createBindingForSchema := self  createBindingForSchemaValue]</body><body package="XMLObjectMarshalers">createBindingForSchema: aBoolean	"(((self createBindingForSchema: true)))"	createBindingForSchema := aBoolean</body><body package="XMLObjectMarshalers">excludedSupers	^self excludedSupersHolder value</body><body package="XMLObjectMarshalers">excludedSupers: aCollection	self excludedSupersHolder value: aCollection</body><body package="XMLObjectMarshalers">excludedSupersHolder	^excludedSupers ifNil: [ excludedSupers := self excludedSupersValue asValue ]</body><body package="XMLObjectMarshalers">schemaParser	^schemaParser ifNil: [schemaParser := self schemaParserValue ]</body><body package="XMLObjectMarshalers">schemaParser: anXMLTypesParser	schemaParser := anXMLTypesParser</body><body package="XMLObjectMarshalers">setAddSuperClassType	^self addSuperClassType  printString asSymbol</body><body package="XMLObjectMarshalers">setAddSuperClassType: aSymbol	aSymbol = #true		ifTrue: [ 	addSuperClassType := true ]		ifFalse: [ addSuperClassType := false ].</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">buildBindingFromElements: anXMLElements	^XMLObjectDriver buildBindingFromElements: anXMLElements</body><body package="XMLObjectMarshalers">buildFromClasses: aCollOfClasses	^self buildFromClasses: aCollOfClasses classNamespace: XMLObjectBindingPolicy defaultClassNamespace</body><body package="XMLObjectMarshalers">buildFromClasses: aCollOfClasses classNamespace: aString	^self 		buildFromClasses: aCollOfClasses 		classNamespace: aString 		targetNamespace: XMLObjectBinding defaultTargetNamespace</body><body package="XMLObjectMarshalers">buildFromClasses: aCollOfClasses classNamespace: aString targetNamespace: targetNamespaceString	^self new		buildFromClasses: aCollOfClasses classNamespace: aString targetNamespace: targetNamespaceString;		yourself</body><body package="XMLObjectMarshalers">load: filenameString	^XMLObjectDriver load: filenameString</body><body package="XMLObjectMarshalers">loadFrom: aStream	^XMLObjectDriver loadFrom: aStream</body><body package="XMLObjectMarshalers">new	^super new initialize</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>class initialization</category><body package="XMLObjectMarshalers">initialize	" ((self initialize)) "	self initializeSerializationBlocks.	self initializePrototypeMarshalers.</body><body package="XMLObjectMarshalers">initializePrototypeMarshalers	" ((self initializePrototypeMarshalers)) "	Registry := Dictionary new: 15.	Registry	at: 'xmlToSmalltalkBinding' put: XMLObjectBinding;	at: 'bindingImport' put: BindingImport;	at: 'key' put: KeyObjectMarshaler;	at: 'keyRef' put: KeyRefObjectMarshaler;	at: 'object' put: ComplexObjectMarshaler;	at: 'struct' put: StructMarshaler;	at: 'identityStruct' put: IdentityStructMarshaler;	at: 'sequence_of' put: CollectionObjectMarshaler;	at: 'sequence' put: SequentialMarshaler;	at: 'all' put: UnorderedMarshaler;	at: 'choice' put: ChoiceMarshaler;	at: 'choiceRelation' put: ChoiceMarshaler;	at: 'element' put: ElementMarshaler;	at: 'implicit' put: ImplicitMarshaler;	at: 'attribute' put: AttributeMarshaler;	at: 'implicitAttribute' put: ImplicitAttributeMarshaler;	at: 'text' put: TextMarshaler;	at: 'any' put: AnyRelationMarshaler;	at: 'anyAttribute' put: AnyAttributeMarshaler;	at: 'anyCollection' put: AnyCollectionMarshaler;	at: 'soapArray' put: SoapArrayMarshaler;	at: 'modelGroup' put: ModelGroupMarshaler;	at: 'group' put: GroupMarshaler;	at: 'modelAttributeGroup' put: ModelAttributeGroupMarshaler;	at: 'attributeGroup' put: AttributeGroupMarshaler;	at: 'simple' put: SimpleObjectMarshaler;	at: 'union' put: UnionMarshaler;	at: 'list' put: ListMarshaler;	at: 'enumeration' put: RestrictionMarshaler;	at: 'length' put:  RestrictionMarshaler;	at: 'minLength' put:  RestrictionMarshaler;	at: 'maxLength' put:  RestrictionMarshaler;	at: 'pattern' put:  RestrictionMarshaler;	at: 'whiteSpace' put:  RestrictionMarshaler;	at: 'minExclusive' put:  RestrictionMarshaler;	at: 'maxExclusive' put:  RestrictionMarshaler;	at: 'maxInclusive' put:  RestrictionMarshaler;	at: 'minInclusive' put:  RestrictionMarshaler;	at: 'totalDigits' put:  RestrictionMarshaler;	at: 'fractionDigits' put:  RestrictionMarshaler.	^Registry</body><body package="XMLObjectMarshalers">initializeSerializationBlocks	" self initializeSerializationBlocks "		Serializers := Dictionary new.	Deserializers := Dictionary new.	Deserializers at: 'String' put: [:mv :string :aclass | self decodeString: string class: aclass  ].	Serializers at: 'String' put: [:mv :aclass | self encodeString: mv value class: aclass].	Deserializers at: 'TwoByteString' put: [:mv :string :aclass | self decodeString: string class: aclass  ].	Serializers at: 'TwoByteString' put: [:mv :aclass | self encodeString: mv value class: aclass].	Deserializers at: 'FourByteString' put: [:mv :string :aclass | self decodeString: string class: aclass  ].	Serializers at: 'FourByteString' put: [:mv :aclass | self encodeString: mv value class: aclass].	Deserializers at: 'NormalizedString' put: [:mv :string :aclass | self decodeNormalizedString: string class: aclass].	Serializers at: 'NormalizedString' put: [:mv  :aclass  | self encodeNormalizedString: mv value class: aclass].	Deserializers at: 'Token' put: [:mv :string  :aclass  | self decodeToken: string  class: aclass ].	Serializers at: 'Token' put: [:mv  :aclass  | self encodeToken: mv value class: aclass].	Deserializers at: 'Character' put: [:mv :string  :aclass  | self decodeCharacter: string class: aclass ].	Serializers at: 'Character' put: [:mv  :aclass  | self encodeCharacter: mv value class: aclass].	Deserializers at: 'ByteSymbol' put: [:mv :string  :aclass  | self decodeByteSymbol: string class: aclass ].	Serializers at: 'ByteSymbol' put: [:mv  :aclass  | self encodeByteSymbol: mv value class:aclass ].	Deserializers at: 'TwoByteSymbol' put: [:mv :string  :aclass  | self decodeByteSymbol: string class: aclass ].	Serializers at: 'TwoByteSymbol' put: [:mv  :aclass  | self encodeByteSymbol: mv value class:aclass ].	Deserializers at: 'FourByteSymbol' put: [:mv :string  :aclass  | self decodeByteSymbol: string class: aclass ].	Serializers at: 'FourByteSymbol' put: [:mv  :aclass  | self encodeByteSymbol: mv value class:aclass ].	Deserializers at: 'base64' put: [:mv :string  :aclass  | self decodeBase64: string].	Serializers at: 'base64' put: [:mv  :aclass  | self encodeBase64: mv value].	Deserializers at: 'anyType' put: [:mv :string  :aclass  | self decodeAnyType: mv ].	Serializers at: 'anyType' put: [:mv  :aclass  | self encodeAnyType: mv ].	Deserializers at: 'anySimpleType' put: [:mv :string  :aclass  | self decodeAnySimpleType: mv ].	Serializers at: 'anySimpleType' put: [:mv  :aclass  | self encodeAnySimpleType: mv ].	Deserializers at: 'Decimal' put: [:mv :string  :aclass  | self decodeDecimal: string class: aclass].	Serializers at: 'Decimal' put: [:mv  :aclass  | self encodeDecimal: mv value ].	Deserializers at: 'Double' put: [:mv :string  :aclass  | self decodeDouble: string class: aclass].	Serializers at: 'Double' put: [:mv  :aclass | self encodeDouble: mv value ].	Deserializers at: 'Float' put: [:mv :string  :aclass  | self decodeFloat: string class: aclass ].	Serializers at: 'Float' put: [:mv  :aclass  | self encodeFloat: mv value class: aclass].	Deserializers at: 'Integer' put: [:mv :string  :aclass  | self decodeInteger: string class: aclass].	Serializers at: 'Integer' put: [:mv  :aclass  | self encodeInteger: mv value class: aclass].	Deserializers at: 'Int' put: [:mv :string  :aclass  | self decodeInt: string class: aclass ].	Serializers at: 'Int' put: [:mv  :aclass  | self encodeInt: mv value class: aclass].	Deserializers at: 'PositiveInteger' put: [:mv :string  :aclass  | self decodePositiveInteger: string  class: aclass ].	Serializers at: 'PositiveInteger' put: [:mv  :aclass  | self encodePositiveInteger: mv value  class: aclass].	Deserializers at: 'NonPositiveInteger' put: [:mv :string  :aclass  | self decodeNonPositiveInteger: string  class: aclass ].	Serializers at: 'NonPositiveInteger' put: [:mv  :aclass  | self encodeNonPositiveInteger: mv value  class: aclass].	Deserializers at: 'NegativeInteger' put: [:mv :string  :aclass  | self decodeNegativeInteger: string  class: aclass ].	Serializers at: 'NegativeInteger' put: [:mv  :aclass  | self encodeNegativeInteger: mv value  class: aclass].	Deserializers at: 'NonNegativeInteger' put: [:mv :string  :aclass  | self decodeNonNegativeInteger: string  class: aclass ].	Serializers at: 'NonNegativeInteger' put: [:mv  :aclass  | self encodeNonNegativeInteger: mv value  class: aclass].	Deserializers at: 'UnsignedLong' put: [:mv :string  :aclass  | self decodeUnsignedLong: string  class: aclass ].	Serializers at: 'UnsignedLong' put: [:mv  :aclass  | self encodeUnsignedLong: mv value  class: aclass].	Deserializers at: 'UnsignedInt' put: [:mv :string  :aclass  | self decodeUnsignedInt: string  class: aclass ].	Serializers at: 'UnsignedInt' put: [:mv  :aclass  | self encodeUnsignedInt: mv value  class: aclass].	Deserializers at: 'UnsignedShort' put: [:mv :string  :aclass  | self decodeUnsignedShort: string  class: aclass ].	Serializers at: 'UnsignedShort' put: [:mv  :aclass  | self encodeUnsignedShort: mv value  class: aclass].	Deserializers at: 'UnsignedByte' put: [:mv :string  :aclass  | self decodeUnsignedByte: string  class: aclass ].	Serializers at: 'UnsignedByte' put: [:mv  :aclass  | self encodeUnsignedByte: mv value  class: aclass].	Deserializers at: 'Long' put: [:mv :string  :aclass  | self decodeLong:  string  class: aclass ].	Serializers at: 'Long' put: [:mv  :aclass  | self encodeLong: mv value  class: aclass].	Deserializers at: 'Short' put: [:mv :string  :aclass  | self decodeShort: string   class: aclass].	Serializers at: 'Short' put: [:mv  :aclass  | self encodeShort: mv value  class: aclass].	Deserializers at: 'Byte' put: [:mv :string  :aclass  | self decodeByte: string  class: aclass ].	Serializers at: 'Byte' put: [:mv  :aclass  | self encodeByte: mv value  class: aclass].	Deserializers at: 'ncname' put: [:mv :string  :aclass  | self decodeNCName: mv ].	Serializers at: 'ncname' put: [:mv  :aclass  | self encodeNCName: mv ].	Deserializers at: 'qnames' put: [:mv :string  :aclass  | self decodeQNames: mv ].	Serializers at: 'qnames' put: [:mv  :aclass  | self encodeQNames: mv ].	Deserializers at: 'qname' put: [:mv :string  :aclass  | self decodeQName: mv ].	Serializers at: 'qname' put: [:mv  :aclass  | self encodeQName: mv ].	Deserializers at: 'id' put: [:mv :string  :aclass  | self decodeId: mv ].	Serializers at: 'id' put: [:mv  :aclass  | self encodeId: mv   ].	Deserializers at: 'idrefs' put: [:mv :string  :aclass  | self decodeIdrefs: string ].	Serializers at: 'idrefs' put: [:mv  :aclass  | self encodeIdrefs: mv value  ].	Deserializers at: 'URI' put: [:mv :string  :aclass  | self decodeURI: string  ].	Serializers at: 'URI'  put: [:mv  :aclass  | self encodeURI: mv value  class: aclass ].	Deserializers at: 'NMTOKENS' put: [:mv :string  :aclass  | self decodeNMTOKENS: string  ].	Serializers at: 'NMTOKENS' put: [:mv  :aclass  | self encodeNMTOKENS: mv value ].	Deserializers at: 'Boolean'  put: [:mv :string  :aclass  | self decodeBoolean: string  ].	Serializers at: 'Boolean' put: [:mv  :aclass  |  self encodeBoolean: mv value   ].	Deserializers at: 'unmarshalXML'  put: [:mv :string  :aclass  | self decodeBinding: mv  ].	Serializers at: 'unmarshalXML'  put: [:mv  :aclass  | #NotYetImplemented &lt;&lt; #webservices &gt;&gt; 'Not yet implemented'].	Deserializers at: 'nil' 	put: [:mv :string  :aclass  | ].	Serializers at: 'nil' put: [:mv  :aclass  | ].	Deserializers at: 'hexBinary' put: [:mv :string  :aclass  | self decodeHexBinary: string  ].	Serializers at: 'hexBinary' put: [:mv  :aclass  | self encodeHexBinaryFrom: mv value ].	Deserializers at: 'binary' put: [:mv :string  :aclass  | string asByteArray].	Serializers at: 'binary' put: [:mv  :aclass | mv value asString].	Deserializers at: 'urlEncoded' put: [:mv :string  :aclass  | true].	Serializers at: 'urlEncoded' put: [:mv  :aclass | self error: #NotYetImplemented &lt;&lt; #webservices &gt;&gt; 'Not yet implemented'].	Deserializers at: 'Timestamp' put: [:mv :string  :aclass  | self decodeTimestampFrom: string ].	Serializers at: 'Timestamp' put: [:mv  :aclass  | self encodeTimestamp: mv value  ].	Deserializers at: 'Time' put: [:mv :string  :aclass  | self decodeTimeFrom: string ].	Serializers at: 'Time' put: [:mv  :aclass | self encodeTime:  mv value  ].	Deserializers at: 'Date' put: [:mv :string  :aclass  | self decodeDateFrom: string ].	Serializers at: 'Date' 	put: [:mv  :aclass  | self encodeDate: mv value ].	Deserializers at: 'Schema' put: [:mv :string  :aclass  | self decodeSchema: mv ].	Serializers at: 'Schema' put: [:mv  :aclass  | self error: #NotYetImplemented &lt;&lt; #webservices &gt;&gt; 'Not yet implemented'].	Deserializers at: 'XMLNode' put: [:mv :string  :aclass  | self decodeXMLNode: mv   ].	Serializers at: 'XMLNode' put: [:mv  :aclass  | self encodeXMLNode: mv ]</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>conversion - decoding</category><body package="XMLObjectMarshalers">decodeAnySimpleType: aMarshalingContext	^self decodeAnyType: aMarshalingContext</body><body package="XMLObjectMarshalers">decodeAnyType: aMarshalingContext	| node  |	aMarshalingContext nodes size &gt; 1 ifTrue: [self canNotDecode:  aMarshalingContext source  from: aMarshalingContext].	node := aMarshalingContext nodes first. 	(aMarshalingContext manager 			resolveHReference: aMarshalingContext 			fromElement: node)		ifTrue: [ ^aMarshalingContext value ].	(aMarshalingContext manager findMarshalerForAnyType:  node) 		ifNil: [ self canNotDecode: node from: aMarshalingContext ]		ifNotNil: [ :marshaler |			(aMarshalingContext asPartMarshaler: marshaler source: node)				nodeContext: (OrderedCollection with: node);				unmarshalDo: [ :mc | ^mc value ]]</body><body package="XMLObjectMarshalers">decodeBase64: aString " self decodeByteArray: 'SvZyZyAzIA=='  = #[74 246 114 103 32 51 32] "	| stream |	[stream := DecodedStream 				on: aString readStream 				encodedBy: B64StreamDecoder asEncoder. 	^stream contents	] on: Error do: [ :ex | ex return].	^XMLDecodingError new		messageText: ((#CantDecodeXsdBase64 &lt;&lt; #webservices &gt;&gt; 'Can not decode "xsd:base64Binary" from: &lt;1s&gt; ')		expandMacrosWith: aString);		parameter: aString;		xmlDatatype: #base64;		raiseSignal</body><body package="XMLObjectMarshalers">decodeBinding: marshalingContext	^self buildBindingFromElements: marshalingContext node realElements.</body><body package="XMLObjectMarshalers">decodeBoolean: aString " An instance of a datatype that is defined as Â·booleanÂ· can have the following legal literals {true, false, 1, 0}."	self xmlBooleanLegalCharacters 		detect: [ :xmlstring | xmlstring = aString ]		ifNone: [^XMLDecodingError new					messageText: ((#CantDecodeBooleanString &lt;&lt; #webservices &gt;&gt; 'Can not decode "xsd:boolean" from: &lt;1s&gt;')						expandMacrosWith: aString);					parameter: aString;					xmlDatatype: #boolean;					raiseSignal ].	^aString first == $t or: [ aString asNumber = 1 ]</body><body package="XMLObjectMarshalers">decodeByte: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #byte ].	(self isByte: anInteger )		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#ByteTypeInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:byte" type decoded from: &lt;1s&gt; is in a wrong range '								expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeByteSymbol: aString class: aClass	^(self decodeString: aString class: aClass) asSymbol</body><body package="XMLObjectMarshalers">decodeCharacter: aString  class: aClass	^(self decodeString: aString class: aClass) first</body><body package="XMLObjectMarshalers">decodeDateFrom: aString  "BindingBuilder decodeDateFrom: '11999-05-31'  ""BindingBuilder decodeDateFrom: '1999-05--03'  ""BindingBuilder decodeDateFrom: '-1999-05--03'  ""BindingBuilder decodeDateFrom: 'QQQ-1999-05--03'  ""http://www.w3.org/TR/xmlschema-2/#dateTimeThe Â·lexical spaceÂ· of dateTime consists of finite-length sequences of characters of the form: '-'? yyyy '-' mm '-' dd 'T' hh ':' mm ':' ss ('.' s+)? (zzzzzz)?,"	|date dateStr year month day isNegative negative str |	[dateStr := aString readStream.	negative := dateStr peekFor: $-.	year := (str := dateStr upToAll: '-') asNumber. "'-'? yyyy is a four-or-more digit optionally negative-signed numeral"	(str ~= '0' and: [str size &gt; 0 and: [year = 0]]) ifTrue: [ Error raiseSignal]. "Not numeral. Allow for backward compatibility: str = 0. There is possible existing services that may return &lt;Time now asTimestamp&gt; where the year is 0. "	negative ifTrue: [year := year negated].	dateStr peekFor: $-.	month := (str := dateStr next: 2) asNumber. "the first mm is a two-digit numeral that represents the month"	(str size &gt; 0 and: [month = 0]) ifTrue: [ Error raiseSignal]. "Not numeral."	dateStr next.	isNegative := false.	(dateStr peekFor: $-)		ifTrue: [ isNegative := true ]		ifFalse: [ dateStr peekFor: $+ ].	day := (str := dateStr next: 2) asNumber. "dd is a two-digit numeral that represents the day"	(str size &gt; 0 and: [day = 0]) ifTrue: [Error raiseSignal].  "Not numeral."	isNegative		ifTrue: 			[date := Date 				newDay: 1				monthNumber: month   				year: year . 			date := date subtractDays: day]		ifFalse:			[ date := Date 				newDay: day				monthNumber: month 				year: year].	^date	] on: Error do: [ :ex | ex return].	^XMLDecodingError new		messageText: ((#CantDecodeDate &lt;&lt; #webservices &gt;&gt; 'Can not decode Date from: &lt;1s&gt;')		expandMacrosWith: aString);		parameter: aString;		xmlDatatype: #date;		raiseSignal</body><body package="XMLObjectMarshalers">decodeDecimal: aString class: aClass	^self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #decimal ].</body><body package="XMLObjectMarshalers">decodeDouble: aString class: aClass	"(BindingBuilder decodeDouble: 'NaN' class: nil)	(BindingBuilder decodeDouble: '-INF' class: nil)"	| isNaN isInf |	(isNaN := 'NaN' match: aString)		ifTrue: [#{NotANumber} ifDefinedDo: [:class | ^class new]].	(isInf := ('INF' match: aString) or: ['-INF' match: aString])		ifTrue: [#{Infinity} ifDefinedDo: [:class | ^class negative: aString first = $-]].	isNaN | isInf		ifTrue: [ ^XMLDecodingError 					raiseRequestWith: aString					errorString: ((#NotSupportedDoubleRepresentation &lt;&lt; #webservices &gt;&gt; 'The double representation "&lt;1s&gt;" not supported yet' )							expandMacrosWith: aString )].	^self 		decodeArith: aString asLowercase		using: aClass 		allowed:  'e' 		onError: [ self decodeArithError: aString datatype: #double ]</body><body package="XMLObjectMarshalers">decodeFloat: aString class: aClass	^self 		decodeArith: aString 		using: aClass 		allowed: 'eE' 		onError: [ self decodeArithError: aString datatype: #float ]</body><body package="XMLObjectMarshalers">decodeHexBinary: aString 	^[ByteArray  fromHexString: aString  ]		on: Error 		do: [ :ex | XMLDecodingError new			messageText: ((#CantDecodeHexBinary &lt;&lt; #webservices &gt;&gt; 'Can not decode "xsd:hexBinary" from: &lt;1s&gt;') expandMacrosWith: aString);			parameter: aString;			xmlDatatype: #hexBinary;			raiseSignal ]</body><body package="XMLObjectMarshalers">decodeId: marshaledValue	^self decodeString: marshaledValue node characterData</body><body package="XMLObjectMarshalers">decodeIdrefs: aString 	^(self tokensFromSpaceSeparatedString: aString)			collect: [ :idref | self decodeId: idref  ]</body><body package="XMLObjectMarshalers">decodeInt: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #int ].	(self isInt: anInteger)		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#IntTypeInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:int" type decoded from: &lt;1s&gt; is in a wrong range '								expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeInteger: aString class: aClass	^self decodeArith: aString using: aClass  onError: [ self decodeArithError: aString datatype: #integer ].</body><body package="XMLObjectMarshalers">decodeLong: aString class: aClass	| anInteger |	anInteger := self  decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #long ].	(self isLong: anInteger) 		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#LongTypeInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:long" type decoded from: &lt;1s&gt; is in a wrong range '								expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeNCName: marshaledValue "XML Namespace NCName, i.e. a QName without the prefix and colon"	| node |	node := marshaledValue node.	(node characterData tokensBasedOn: $: ) size &gt; 1		ifTrue: [XMLDecodingError new				messageText: ((#ErrorDecodingNCName &lt;&lt; #webservices &gt;&gt; 'Error decoding NCName type. The value should not include colon &lt;1s&gt; ') expandMacrosWith: node characterData);				parameter: marshaledValue;				xmlDatatype: #NCName;				raiseSignal].	^NodeTag 		qualifier: '' 		ns: (node targetNamespace ifNil: [String new]) 		type: node characterData</body><body package="XMLObjectMarshalers">decodeNMTOKENS: aString	^(self tokensFromSpaceSeparatedString: aString)</body><body package="XMLObjectMarshalers">decodeNegativeInteger: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass  onError: [ ^self decodeArithError: aString datatype: #negativeInteger].	( self isNegativeInteger: anInteger )		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#NegativeIntegerTypeInWrongRange &lt;&lt; #webservices &gt;&gt; '"xsd:negativeInteger" type decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeNonNegativeInteger: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #nonNegativeInteger].	(self isNonNegativeInteger: anInteger)		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#NonNegativeIntegerTypeInWrongRange &lt;&lt; #webservices &gt;&gt; '"xsd:nonNegativeInteger" decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeNonPositiveInteger: aString class: aClass	| anInteger |	anInteger :=self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #nonPositiveInteger].	(self isNonPositiveInteger: anInteger)		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#NonPositiveIntegerTypeInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:nonPositiveInteger" decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeNormalizedString: aString class: aClass		(self validateNormalizedString: aString)		ifNotNil: [ ^DecodedInvalidString 					raiseRequestWith: aString					errorString:	((#InvalidCharactersInXMLNormalizedString &lt;&lt; #webservices &gt;&gt; 'Invalid characters in XML normalized string:  &lt;1s&gt;')							expandMacrosWith: aString) asString ].	^aString</body><body package="XMLObjectMarshalers">decodePositiveInteger: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #positiveInteger].	( self isPositiveInteger:  anInteger )		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#PositiveIntegerTypeInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:positiveInteger" decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeQName: marshaledValue 	^(self decodeQNames: marshaledValue) first</body><body package="XMLObjectMarshalers">decodeQNames: marshaledValue 	| node  q ns  tokens typex |	node := marshaledValue node.	q := ns := ''.	^(self tokensFromSpaceSeparatedString: node characterData)		collect: [ :string | 		tokens := string tokensBasedOn: $:.		tokens size &gt; 1 			ifTrue: 				[typex := tokens last. q := tokens first.				(node isElement) ifFalse: [node := node parent].				ns := node findNamespaceAt: q]			ifFalse: 				[typex := string. 				(ns := node targetNamespace) isNil					ifTrue: [ ns := node namespaceAtQualifier: 'tns' ifAbsent: [nil]]].		ns isNil ifTrue: [ns := ''].		q isNil ifTrue: [q := ''].	NodeTag qualifier: q ns: ns asString type: typex ]</body><body package="XMLObjectMarshalers">decodeSchema: aMarshalingContext	| binding bindingElement parser |	(self createBindingForSchema		and: [ (parser := self schemaParser ) notNil ])		ifTrue: 			[[ bindingElement := parser defaultBinding readFrom: aMarshalingContext node printString readStream.			binding := (self buildBindingFromElements: (Array with: bindingElement)) first.			aMarshalingContext manager addBinding: binding.			^aMarshalingContext node-&gt;binding			] on: Error do: [ :ex | ex return].].	^aMarshalingContext node-&gt;nil</body><body package="XMLObjectMarshalers">decodeShort: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #short].	( self isShort: anInteger)		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#ShortTypeInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:short" decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeString: aString		(self validateString: aString)		ifNotNil: [ ^DecodedInvalidString new					messageText: ((#InvalidCharactersInXMLString &lt;&lt; #webservices &gt;&gt; 'Invalid characters in XML string:  &lt;1s&gt;')							expandMacrosWith: aString) asString;					parameter: aString;					raiseSignal ].	^aString</body><body package="XMLObjectMarshalers">decodeString: aString class: aClass		(self validateString: aString)		ifNotNil: [ ^DecodedInvalidString new					messageText: ((#InvalidCharactersInXMLString &lt;&lt; #webservices &gt;&gt; 'Invalid characters in XML string:  &lt;1s&gt;')							expandMacrosWith: aString) asString;					parameter: aString;					raiseSignal ].	^aString</body><body package="XMLObjectMarshalers">decodeTimeFrom: aString  "BindingBuilder decodeTimeFrom: '21:12:13.0001-07:00'  ""BindingBuilder decodeTimeFrom: '21:12:13.0001Z'  ""BindingBuilder decodeTimeFrom: '21:12:13-07:00'  ""BindingBuilder decodeTimeFrom: '12:22:41.0000000-08:00'  ""BindingBuilder decodeTimeFrom: '12:22:41.0000234-08:00'  ""BindingBuilder decodeTimeFrom: '03:36:46.0000099-08:00'  "	^(self decodeTimeFrom: aString using: Timestamp now) asTime</body><body package="XMLObjectMarshalers">decodeTimestampFrom: aString"BindingBuilder decodeTimestampFrom: '1999-05-31T13:20:00.333'  ""BindingBuilder decodeTimestampFrom: '1999-05--03T13:20:00'  ""BindingBuilder decodeTimestampFrom: '1999-05-31T13:20:00-05:00'  ""BindingBuilder decodeTimestampFrom: '2002-11-02T15:20:00-05:00'  ""BindingBuilder decodeTimestampFrom: '2002-08-02T13:20:00-05:00'  ""BindingBuilder decodeTimestampFrom: '2002-08-02T19:44:00Z'  ""BindingBuilder decodeTimestampFrom: '1999-05-31T13:20:00-09:00'  ""BindingBuilder decodeTimestampFrom: '1999-05-+31'  ""002-01-11T10:31:47   BindingBuilder decodeTimestampFrom: '2002-01-11T07:31:47.0000000-08:00' "	|stream  timestamp strDate strTime |	stream := aString readStream. 	timestamp := Timestamp new.	strDate := stream upTo: $T.	strTime := stream upToEnd.	strDate notEmpty		ifTrue: [timestamp := (self decodeDateFrom: strDate ) asTimestamp ].	strTime notEmpty		ifTrue: [ timestamp := self decodeTimeFrom: strTime using: timestamp ].	^timestamp</body><body package="XMLObjectMarshalers">decodeToken: aString class: aClass		(self validateToken: aString)		ifNotNil: [ ^DecodedInvalidString new					messageText: ((#InvalidCharactersInXMLToken &lt;&lt; #webservices &gt;&gt; 'Invalid "xsd:token" characters in &lt;1s&gt;')							expandMacrosWith: aString) asString;					parameter: aString;					raiseSignal ].	^aString</body><body package="XMLObjectMarshalers">decodeURI: aString 	[^aString asURI	] on: Error do: [ :ex | ex return].	^XMLDecodingError new		messageText: ((#CantDecodeURI &lt;&lt; #webservices &gt;&gt; 'Can not decode URI from: &lt;1s&gt; ')		expandMacrosWith: aString);		parameter: aString;		xmlDatatype: #url;		raiseSignal</body><body package="XMLObjectMarshalers">decodeUnsignedByte: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #unsignedByte].	( self isUnsignedByte: anInteger )		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#UnsignedByteInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:unsignedByte" decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeUnsignedInt: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #unsignedInt].	( self isUnsignedInt: anInteger)		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#UnsignedIntInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:unsignedInt". decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeUnsignedLong: aString class: aClass	| anInteger |	anInteger := self  decodeArith: aString using: aClass onError: [ ^self decodeArithError: aString datatype: #unsignedLong].	( self isUnsignedLong: anInteger)		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#UnsignedLongInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:unsignedLong". decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeUnsignedShort: aString class: aClass	| anInteger |	anInteger := self decodeArith: aString using: aClass  onError: [ ^self decodeArithError: aString datatype: #unsignedShort].	(self isUnsignedShort: anInteger)		ifFalse: [ ^DecodedIntegerOutOfRange new					messageText: (#UnsignedShortInWrongRange &lt;&lt; #webservices &gt;&gt; ' "xsd:unsignedShort". decoded from: &lt;1s&gt; is in a wrong range' expandMacrosWith: aString);					parameter: aString;					decodedInteger: anInteger;					raiseSignal].	^anInteger</body><body package="XMLObjectMarshalers">decodeXMLNode: aMarshalingContext	^ aMarshalingContext node</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>conversion - encoding</category><body package="XMLObjectMarshalers">encodeAnySimpleType: aMarshalingContext 	^self encodeAnyType: aMarshalingContext</body><body package="XMLObjectMarshalers">encodeAnyType: aMarshalingContext 	| value m q1 attr |	value := aMarshalingContext value.	m := aMarshalingContext binding 				marshalerForAnyType: value 			ifAbsent: [ ^aMarshalingContext 						notifyNoMarshalerFor: value						text: (#EncodingAnyType &lt;&lt; #webservices &gt;&gt; ' encoding anyType &lt;1s&gt;' expandMacrosWith: value printString)].	(aMarshalingContext  binding useReference and: [m canBeMultiref ])		ifTrue: 			[aMarshalingContext setHRefNode: aMarshalingContext source.			aMarshalingContext isReference ifTrue: [^nil]. ].	aMarshalingContext marshaler: m; marshal.	q1 := aMarshalingContext addQualifierForTag: m tag.	(attr := aMarshalingContext source 		attributeNamed: m inlineTypeKey 		ifAbsent: [nil]) 			ifNil: [ m 					setInlineTypeFor: aMarshalingContext source 					marshalingContext: aMarshalingContext ]			ifNotNil: [attr value: q1 , ':' , m tag type].		^nil</body><body package="XMLObjectMarshalers">encodeBase64: aByteArray" 3.2.16 base64Binary[Definition:]   base64Binary represents Base64-encoded arbitrary binary data. The Â·value spaceÂ· of base64Binary is the set of finite-length sequences of binary octets. For base64Binary data the entire binary stream is encoded using the Base64 Content-Transfer-Encoding defined in Section 6.8 of [RFC 2045]. "" ((BindingBuilder encodeBase64: 'Keith_Moore' asByteArray ) =  'S2VpdGhfTW9vcmU=' )"	| output stream |	(self ensureClass: ByteArray for: aByteArray) ifNotNil: [ :value | ^value].	^[	output := (ByteString new: 64) writeStream.		stream := DecodedStream on: output encodedBy: B64StreamDecoder asEncoder.		stream nextPutAll: aByteArray.		stream close.		stream encodedContents	] on:Error do: [ :ex |		XMLEncodingError new			messageText:  ((#CanntEncodeBase64Value &lt;&lt; #webservices &gt;&gt;'Can not encode: &lt;1s&gt; into "xsd:base64Binary" ') 									expandMacrosWith: aByteArray printString );			parameter: aByteArray;			raiseSignal ]</body><body package="XMLObjectMarshalers">encodeBoolean: aBoolean "3.2.2.1 Lexical representationAn instance of a datatype that is defined as Â·booleanÂ· can have the following legal literals {true, false, 1, 0}. 3.2.2.2 Canonical representationThe canonical representation for boolean is the set of literals {true, false}. "	(self ensureClass: Boolean for: aBoolean) ifNotNil: [ :value | ^value].						^aBoolean printString</body><body package="XMLObjectMarshalers">encodeByte: anInteger class: aClass	"3.3.19 byte[Definition:]   byte is Â·derivedÂ· from short by setting the value of Â·maxInclusiveÂ· to be 127 and Â·minInclusiveÂ· to be -128. The Â·base typeÂ· of byte is short. 3.3.19.1 Lexical representationbyte has a lexical representation consisting of an optional sign followed by a finite-length sequence of decimal digits (#x30-#x39). If the sign is omitted, '+' is assumed. For example: -1, 0, 126, +100. 3.3.19.2 Canonical representationThe canonical representation for byte is defined by prohibiting certain options from the Lexical representation (Â§3.3.19.1). Specifically, the the optional '+' sign is prohibited and leading zeroes are prohibited. "		(self ensureClass: aClass for: anInteger) ifNotNil: [:value | ^value].	(self isByte: anInteger )		ifFalse: [ ^EncodingIntegerOutOfRange new					messageText: (#CanntEncodeByteType &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:byte".  Wrong range'								expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeByteSymbol: aByteSymbol 	^self encodeString: aByteSymbol asString class: String</body><body package="XMLObjectMarshalers">encodeByteSymbol: aByteSymbol class: aClass	^self encodeString: aByteSymbol asString class: String</body><body package="XMLObjectMarshalers">encodeCharacter: aCharacter class: aClass		^self encodeString: aCharacter asSymbol asString class: String</body><body package="XMLObjectMarshalers">encodeDate: aDate "BindingBuilder encodeDate: Date today "	|stream |	(self ensureClass: Date for: aDate) ifNotNil: [ :value | ^value].			stream := (String new: 64) writeStream.	self encodeDate: aDate on: stream.	^stream contents</body><body package="XMLObjectMarshalers">encodeDate: aDate on: stream	aDate year printOn: stream.	stream nextPut: $-.	aDate monthIndex printOn: stream paddedWith: $0 to: 2 base: 10.	stream nextPut: $-. 	(aDate day - aDate firstDayOfMonth + 1) printOn: stream paddedWith: $0 to: 2 base: 10.</body><body package="XMLObjectMarshalers">encodeDecimal: aNumber "[Definition:]  decimal represents arbitrary precision decimal numbers. The Â·value spaceÂ· of decimal is the set of the values i Ã 10^-n, where i and n are integers such that n &gt;= 0. The Â·order-relationÂ· on decimal is: x &lt; y iff y - x is positive. [Definition:]   The Â·value spaceÂ· of types derived from decimal with a value for Â·totalDigitsÂ· of p is the set of values i Ã 10^-n, where n and i are integers such that p &gt;= n &gt;= 0 and the number of significant decimal digits in i is less than or equal to p. [Definition:]   The Â·value spaceÂ· of types derived from decimal with a value for Â·fractionDigitsÂ· of s is the set of values i Ã 10^-n, where i and n are integers such that 0 &lt;= n &lt;= s. NOTE: All Â·minimally conformingÂ· processors Â·mustÂ· support decimal numbers with a minimum of 18 decimal digits (i.e., with a Â·totalDigitsÂ· of 18). However, Â·minimally conformingÂ· processors Â·mayÂ· set an application-defined limit on the maximum number of decimal digits they are prepared to support, in which case that application-defined maximum number Â·mustÂ· be clearly documented. 3.2.3.1 Lexical representationdecimal has a lexical representation consisting of a finite-length sequence of decimal digits (#x30-#x39) separated by a period as a decimal indicator. If Â·totalDigitsÂ· is specified, the number of digits must be less than or equal to Â·totalDigitsÂ·. If Â·fractionDigitsÂ· is specified, the number of digits following the decimal point must be less than or equal to the Â·fractionDigitsÂ·. An optional leading sign is allowed. If the sign is omitted, + is assumed. Leading and trailing zeroes are optional. If the fractional part is zero, the period and following zero(es) can be omitted. For example: -1.23, 12678967.543233, +100000.00, 210. 3.2.3.2 Canonical representationThe canonical representation for decimal is defined by prohibiting certain options from the Lexical representation (Â§3.2.3.1). Specifically, the preceding optional + sign is prohibited. The decimal point is required. Leading and trailing zeroes are prohibited subject to the following: there must be at least one digit to the right and to the left of the decimal point which may be a zero. "	(self ensureClass: Number for: aNumber) ifNotNil: [ :value | ^value].			^aNumber printDecimalUsing: self</body><body package="XMLObjectMarshalers">encodeDouble: aNumber "3.2.5 double[Definition:]  The double datatype corresponds to IEEE double-precision 64-bit floating point type [IEEE 754-1985]. The basic Â·value spaceÂ· of double consists of the values m Ã 2^e, where m is an integer whose absolute value is less than 2^53, and e is an integer between -1075 and 970, inclusive. In addition to the basic Â·value spaceÂ· described above, the Â·value spaceÂ· of double also contains the following special values: positive and negative zero, positive and negative infinity and not-a-number. The Â·order-relationÂ· on double is: x &lt; y iff y - x is positive. Positive zero is greater than negative zero. Not-a-number equals itself and is greater than all double values including positive infinity. A literal in the Â·lexical spaceÂ· representing a decimal number d maps to the normalized value in the Â·value spaceÂ· of double that is closest to d; if d is exactly halfway between two such values then the even value is chosen. This is the best approximation of d ([Clinger, WD (1990)], [Gay, DM (1990)]), which is more accurate than the mapping required by [IEEE 754-1985]. 3.2.5.1 Lexical representationdouble values have a lexical representation consisting of a mantissa followed, optionally, by the character E or e, followed by an exponent. The exponent Â·mustÂ· be an integer. The mantissa must be a decimal number. The representations for exponent and mantissa must follow the lexical rules for integer and decimal. If the E or e and the following exponent are omitted, an exponent value of 0 is assumed. The special values positive and negative zero, positive and negative infinity and not-a-number have lexical representations 0, -0, INF, -INF and NaN, respectively. For example, -1E4, 1267.43233E12, 12.78e-2, 12 and INF are all legal literals for double. 3.2.5.2 Canonical representationThe canonical representation for double is defined by prohibiting certain options from the Lexical representation (Â§3.2.5.1). Specifically, the exponent must be indicated by E. Leading zeroes and the preceding optional + sign are prohibited in the exponent. For the mantissa, the preceding optional + sign is prohibited and the decimal point is required. For the exponent, the preceding optional + sign is prohibited. Leading and trailing zeroes are prohibited subject to the following: number representations must be normalized such that there is a single digit to the left of the decimal point and at least a single digit to the right of the decimal point."	(self ensureClass: Number for: aNumber) ifNotNil: [ :value | ^value].			^(self numberPolicy		print: aNumber		policy: self doublePrintPolicy) string</body><body package="XMLObjectMarshalers">encodeFloat: aNumber class: aClass"3.2.4 float[Definition:]  float corresponds to the IEEE single-precision 32-bit floating point type [IEEE 754-1985]. The basic Â·value spaceÂ· of float consists of the values m Ã 2^e, where m is an integer whose absolute value is less than 2^24, and e is an integer between -149 and 104, inclusive. In addition to the basic Â·value spaceÂ· described above, the Â·value spaceÂ· of float also contains the following special values: positive and negative zero, positive and negative infinity and not-a-number. The Â·order-relationÂ· on float is: x &lt; y iff y - x is positive. Positive zero is greater than negative zero. Not-a-number equals itself and is greater than all float values including positive infinity. A literal in the Â·lexical spaceÂ· representing a decimal number d maps to the normalized value in the Â·value spaceÂ· of float that is closest to d in the sense defined by [Clinger, WD (1990)]; if d is exactly halfway between two such values then the even value is chosen. 3.2.4.1 Lexical representationfloat values have a lexical representation consisting of a mantissa followed, optionally, by the character E or e, followed by an exponent. The exponent Â·mustÂ· be an integer. The mantissa must be a decimal number. The representations for exponent and mantissa must follow the lexical rules for integer and decimal. If the E or e and the following exponent are omitted, an exponent value of 0 is assumed. The special values positive and negative zero, positive and negative infinity and not-a-number have lexical representations 0, -0, INF, -INF and NaN, respectively. For example, -1E4, 1267.43233E12, 12.78e-2, 12 and INF are all legal literals for float. 3.2.4.2 Canonical representationThe canonical representation for float is defined by prohibiting certain options from the Lexical representation (Â§3.2.4.1). Specifically, the exponent must be indicated by E. Leading zeroes and the preceding optional + sign are prohibited in the exponent. For the mantissa, the preceding optional + sign is prohibited and the decimal point is required. For the exponent, the preceding optional + sign is prohibited. Leading and trailing zeroes are prohibited subject to the following: number representations must be normalized such that there is a single digit to the left of the decimal point and at least a single digit to the right of the decimal point. "	(self ensureClass: Number for: aNumber) ifNotNil: [ :value | ^value].			^(self numberPolicy		print: aNumber		policy: self floatPrintPolicy) string</body><body package="XMLObjectMarshalers">encodeHexBinaryFrom: aByteArray	(self ensureClass: ByteArray for: aByteArray ) ifNotNil: [ :value | ^value].			^aByteArray asHexString</body><body package="XMLObjectMarshalers">encodeId: aMarshalingContext" ID represents the ID attribute type from [XML 1.0 (Second Edition)]. The Â·value spaceÂ· of ID is the set of all strings that Â·matchÂ· the NCName production in [Namespaces in XML]. The Â·lexical spaceÂ· of ID is the set of all strings that Â·matchÂ· the NCName production in [Namespaces in XML]. The Â·base typeÂ· of ID is NCName. Validity constraint: IDValues of type ID must match the Name production. A name must not appear more than once in an XML document as a value of this type; i.e., ID values must uniquely identify the elements which bear them."	^aMarshalingContext value</body><body package="XMLObjectMarshalers">encodeIdrefs: aCollection 	(self ensureClass: SequenceableCollection for: aCollection) ifNotNil: [ :value | ^value].				^self spaceSeparatedStringFromTokens: aCollection</body><body package="XMLObjectMarshalers">encodeInt: anInteger class: aClass"3.3.17 int[Definition:]   int is Â·derivedÂ· from long by setting the value of Â·maxInclusiveÂ· to be 2147483647 and Â·minInclusiveÂ· to be -2147483648. The Â·base typeÂ· of int is long. 3.3.17.1 Lexical representationint has a lexical representation consisting of an optional sign followed by a finite-length sequence of decimal digits (#x30-#x39). If the sign is omitted, + is assumed. For example: -1, 0, 126789675, +100000. 3.3.17.2 Canonical representationThe canonical representation for int is defined by prohibiting certain options from the Lexical representation (Â§3.3.17.1). Specifically, the the optional + sign is prohibited and leading zeroes are prohibited "	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		(self isInt: anInteger)		ifFalse: [ ^EncodingIntegerOutOfRange new					messageText: (#CanntEncodeXsdInt &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:int". Wrong range ' expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeInteger: anInteger class: aClass"3.3.13 integer[Definition:]   integer is Â·derivedÂ· from decimal by fixing the value of Â·fractionDigitsÂ· to be 0. This results in the standard mathematical concept of the integer numbers. The Â·value spaceÂ· of integer is the infinite set {...,-2,-1,0,1,2,...}. The Â·base typeÂ· of integer is decimal. 3.3.13.1 Lexical representationinteger has a lexical representation consisting of a finite-length sequence of decimal digits (#x30-#x39) with an optional leading sign. If the sign is omitted, + is assumed. For example: -1, 0, 12678967543233, +100000. 3.3.13.2 Canonical representationThe canonical representation for integer is defined by prohibiting certain options from the Lexical representation (Â§3.3.13.1). Specifically, the preceding optional + sign is prohibited and leading zeroes are prohibited. "	(self ensureClass: Integer for: anInteger) ifNotNil: [ :value | ^value].		^anInteger printString</body><body package="XMLObjectMarshalers">encodeLong: anInteger class: aClass"3.3.16 long[Definition:]   long is Â·derivedÂ· from integer by setting the value of Â·maxInclusiveÂ· to be 9223372036854775807 and Â·minInclusiveÂ· to be -9223372036854775808. The Â·base typeÂ· of long is integer. 3.3.16.1 Lexical representationlong has a lexical representation consisting of an optional sign followed by a finite-length sequence of decimal digits (#x30-#x39). If the sign is omitted, + is assumed. For example: -1, 0, 12678967543233, +100000. 3.3.16.2 Canonical representationThe canonical representation for long is defined by prohibiting certain options from the Lexical representation (Â§3.3.16.1). Specifically, the the optional + sign is prohibited and leading zeroes are prohibited "	(self ensureClass: Integer for: anInteger) ifNotNil: [ :value | ^value].		(self isLong: anInteger) 		ifFalse: [ ^(EncodingIntegerOutOfRange new)					messageText: (#CanntEncodeLong &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:long". Wrong range ' 	expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeNCName: aMarshalingContext"XML Namespace NCName, i.e. a QName without the prefix and colon""http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName 	NCName 	::= 	(Letter | '_') (NCNameChar)*	/* 	An XML Name, minus the ':' */ 	NCNameChar 	::= 	Letter | Digit | '.' | '-' | '_' | CombiningChar | ExtenderCombining characters are characters that are intended to modify other characters. The most common combining characters in the Latin script are the combining diacritical marks (including combining accents).   	Extender	   ::=   	#x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 | #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] | [#x309D-#x309E] | [#x30FC-#x30FE] "	^aMarshalingContext value type</body><body package="XMLObjectMarshalers">encodeNMTOKENS: aCollection " 3.3.5 NMTOKENS[Definition:]   NMTOKENS represents the NMTOKENS attribute type from [XML 1.0 (Second Edition)]. The Â·value spaceÂ· of NMTOKENS is the set of finite, non-zero-length sequences of Â·NMTOKENÂ·s. The Â·lexical spaceÂ· of NMTOKENS is the set of white space separated lists of tokens, of which each token is in the Â·lexical spaceÂ· of NMTOKEN. The Â·itemTypeÂ· of NMTOKENS is NMTOKEN. "	(self ensureClass: SequenceableCollection for: aCollection) ifNotNil: [ :value | ^value].		^(self  spaceSeparatedStringFromTokens:  aCollection)</body><body package="XMLObjectMarshalers">encodeNegativeInteger: anInteger class: aClass"3.3.15 negativeInteger[Definition:]   negativeInteger is Â·derivedÂ· from nonPositiveInteger by setting the value of Â·maxInclusiveÂ· to be -1. This results in the standard mathematical concept of the negative integers. The Â·value spaceÂ· of negativeInteger is the infinite set {...,-2,-1}. The Â·base typeÂ· of negativeInteger is nonPositiveInteger. 3.3.15.1 Lexical representationnegativeInteger has a lexical representation consisting of a negative sign (-) followed by a finite-length sequence of decimal digits (#x30-#x39). For example: -1, -12678967543233, -100000. 3.3.15.2 Canonical representationThe canonical representation for negativeInteger is defined by prohibiting certain options from the Lexical representation (Â§3.3.15.1). Specifically, leading zeroes are prohibited. "	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		( self isNegativeInteger: anInteger )		ifFalse: [ ^EncodingIntegerOutOfRange new					messageText: (#CanntEncodeNegativeInteger &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:negativeInteger" type. Wrong range ' expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeNonNegativeInteger: anInteger class: aClass"3.3.20 nonNegativeInteger[Definition:]   nonNegativeInteger is Â·derivedÂ· from integer by setting the value of Â·minInclusiveÂ· to be 0. This results in the standard mathematical concept of the non-negative integers. The Â·value spaceÂ· of nonNegativeInteger is the infinite set {0,1,2,...}. The Â·base typeÂ· of nonNegativeInteger is integer. 3.3.20.1 Lexical representationnonNegativeInteger has a lexical representation consisting of an optional sign followed by a finite-length sequence of decimal digits (#x30-#x39). If the sign is omitted, + is assumed. For example: 1, 0, 12678967543233, +100000. 3.3.20.2 Canonical representationThe canonical representation for nonNegativeInteger is defined by prohibiting certain options from the Lexical representation (Â§3.3.20.1). Specifically, the the optional + sign is prohibited and leading zeroes are prohibited. ""self encodeNonNegativeInteger: -1 "	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		(self isNonNegativeInteger: anInteger)		ifFalse: [ ^EncodingIntegerOutOfRange new					messageText: (#CanntEncodeNonNegativeInteger &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:nonNegativeInteger".  Wrong range ' expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeNonPositiveInteger: anInteger class: aClass"3.3.14 nonPositiveInteger[Definition:]   nonPositiveInteger is Â·derivedÂ· from integer by setting the value of Â·maxInclusiveÂ· to be 0. This results in the standard mathematical concept of the non-positive integers. The Â·value spaceÂ· of nonPositiveInteger is the infinite set {...,-2,-1,0}. The Â·base typeÂ· of nonPositiveInteger is integer. 3.3.14.1 Lexical representationnonPositiveInteger has a lexical representation consisting of a negative sign (-) followed by a finite-length sequence of decimal digits (#x30-#x39). If the sequence of digits consists of all zeros then the sign is optional. For example: -1, 0, -12678967543233, -100000. 3.3.14.2 Canonical representationThe canonical representation for nonPositiveInteger is defined by prohibiting certain options from the Lexical representation (Â§3.3.14.1). Specifically, the negative sign (-) is required with the token 0 and leading zeroes are prohibited. "	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		(self isNonPositiveInteger: anInteger)		ifFalse: [ ^(EncodingIntegerOutOfRange new)					messageText: (#CanntEncodeNonPositiveInteger &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:nonPositiveInteger". Wrong range ' expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeNormalizedString: aString class: aClass	(self ensureClass: aClass for: aString) ifNotNil: [ :value | ^value].		(self validateNormalizedString: aString) ifNotNil: 		[^EncodingInvalidString 			raiseRequestWith: aString			errorString:	((#InvalidCharactersInXMLNormalizedString &lt;&lt; #webservices &gt;&gt; 'Invalid characters in XML normalized string:  &lt;1s&gt;')					expandMacrosWith: aString) asString  ].	^aString</body><body package="XMLObjectMarshalers">encodePositiveInteger: anInteger class: aClass"3.3.25 positiveInteger[Definition:]   positiveInteger is Â·derivedÂ· from nonNegativeInteger by setting the value of Â·minInclusiveÂ· to be 1. This results in the standard mathematical concept of the positive integer numbers. The Â·value spaceÂ· of positiveInteger is the infinite set {1,2,...}. The Â·base typeÂ· of positiveInteger is nonNegativeInteger. 3.3.25.1 Lexical representationpositiveInteger has a lexical representation consisting of an optional positive sign (+) followed by a finite-length sequence of decimal digits (#x30-#x39). For example: 1, 12678967543233, +100000. 3.3.25.2 Canonical representationThe canonical representation for positiveInteger is defined by prohibiting certain options from the Lexical representation (Â§3.3.25.1). Specifically, the optional + sign is prohibited and leading zeroes are prohibited. "	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		( self isPositiveInteger:  anInteger )		ifFalse: [ ^EncodingIntegerOutOfRange new					messageText: (#CanntEncodePositiveInteger &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:positiveInteger".  Wrong range '								expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeQName: aMarshalingContext 	| stream |	stream := String new writeStream.	self encodeQName: aMarshalingContext value marshalingContext: aMarshalingContext on: stream.	^stream contents</body><body package="XMLObjectMarshalers">encodeQName: aNodeTag marshalingContext: aMarshalingContext on: stream	|  q |	q := aMarshalingContext addQualifierForTag:  aNodeTag.	stream nextPutAll: (q, ':', aNodeTag type)</body><body package="XMLObjectMarshalers">encodeQNames: aMarshalingContext 	| stream |	stream := String new writeStream.	aMarshalingContext value 		do: [ :node |  self encodeQName: node marshalingContext: aMarshalingContext on: stream.]		separatedBy: [ stream nextPut: Character space ].	^stream contents</body><body package="XMLObjectMarshalers">encodeShort: anInteger class: aClass"3.3.18 short[Definition:]   short is Â·derivedÂ· from int by setting the value of Â·maxInclusiveÂ· to be 32767 and Â·minInclusiveÂ· to be -32768. The Â·base typeÂ· of short is int. 3.3.18.1 Lexical representationshort has a lexical representation consisting of an optional sign followed by a finite-length sequence of decimal digits (#x30-#x39). If the sign is omitted, + is assumed. For example: -1, 0, 12678, +10000. 3.3.18.2 Canonical representationThe canonical representation for short is defined by prohibiting certain options from the Lexical representation (Â§3.3.18.1). Specifically, the the optional + sign is prohibited and leading zeroes are prohibited."	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		( self isShort: anInteger)		ifFalse: [ ^EncodingIntegerOutOfRange new					messageText: (#CanntEncodeShort &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into: "xsd:short". Wrong range '								expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeString: aString class: aClass	| char |	(self ensureClass: aClass for: aString) ifNotNil: [ :value | ^value].		(char := self validateString: aString) ifNotNil: 		[^EncodingInvalidString 			raiseRequestWith: char asInteger printString			errorString:	((#InvalidXsdStringCharacter1p &lt;&lt; #webservices &gt;&gt; 'Invalid "xsd:string".  Character value: &lt;1p&gt;')					expandMacrosWith: char asInteger) asString  ].	^aString</body><body package="XMLObjectMarshalers">encodeTime: aTime"BindingBuilder encodeTime: Timestamp now "	|stream  adjTime aTimestamp |	(self ensureClass: Time for: aTime) ifNotNil: [ :value | ^value].			aTimestamp := Timestamp fromDate: Date today andTime: aTime.	adjTime := Timestamp fromSeconds: ( TimeZone reference convertLocalSecondsToGMT: aTimestamp asSeconds).	adjTime 		milliseconds: aTime milliseconds;		partialNanosecond: aTime partialNanosecond.		stream := (String new: 64) writeStream.	self encodeTime: adjTime on: stream.	^stream contents</body><body package="XMLObjectMarshalers">encodeTime: aTimestamp on: aStream	"BindingBuilder encodeTime: Time now "	"http://www.w3.org/TR/xmlschema-2/#dateTime"	"The Â·lexical spaceÂ· of dateTime consists of finite-length sequences of characters of the form: '-'? yyyy '-' mm '-' dd 'T' hh ':' mm ':' ss ('.' s+)? (zzzzzz)?"		aTimestamp hour printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $:.	aTimestamp minute printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $:.	aTimestamp second printOn: aStream paddedWith: $0 to: 2 base: 10.		((aTimestamp milliseconds ~= 0)		or: [aTimestamp partialNanosecond ~= 0]) ifTrue: [			| partial lastDigit |			partial := String new writeStream.			aTimestamp millisecond printOn: partial paddedWith: $0 to: 3 base: 10.			aTimestamp partialNanosecond ~= 0 ifTrue: [				aTimestamp partialNanosecond printOn: partial paddedWith: $0 to: 6 base: 10 ].			partial := partial contents.			lastDigit := partial size.			[ (partial at: lastDigit) = $0 and: [lastDigit &gt; 0]] whileTrue: [ lastDigit := lastDigit - 1].						aStream nextPut: $. .			aStream nextPutAll: (partial copyFrom: 1 to: lastDigit)].			aStream nextPut: $Z.</body><body package="XMLObjectMarshalers">encodeTimestamp: aTimestamp	"2002-01-16T01:24:54Z from: January 15, 2002 20:32:17.000 and  time zone -5"	"BindingBuilder encodeTimestamp: Timestamp now"	"BindingBuilder encodeTimestamp: (Timestamp now addSeconds: ( -90 * 86400))"	|stream adjTime  | 	(self ensureClass: Timestamp for: aTimestamp) ifNotNil: [ :value | ^value].		adjTime := Timestamp fromSeconds: (  TimeZone default convertLocalSecondsToGMT: (aTimestamp asSeconds)).	stream := (String new: 64) writeStream.	self encodeDate: adjTime asDate on: stream.	stream nextPut: $T.	adjTime 		millisecond: aTimestamp millisecond; 		partialNanosecond: aTimestamp partialNanosecond.	self encodeTime: adjTime on: stream.	^stream contents</body><body package="XMLObjectMarshalers">encodeToken: aString class: aClass	(self ensureClass: aClass for: aString) ifNotNil: [ :value | ^value].		(self validateToken: aString) ifNotNil: 		[^EncodingInvalidString 			raiseRequestWith: aString			errorString:	((#InvalidCharactersInXMLToken &lt;&lt; #webservices &gt;&gt; 'Invalid "xsd:token" characters in &lt;1s&gt;')					expandMacrosWith: aString) asString  ].	^aString</body><body package="XMLObjectMarshalers">encodeURI: anURI class: aClass		(self ensureClass: aClass for: anURI) ifNotNil: [ :value | ^value].		^anURI asString</body><body package="XMLObjectMarshalers">encodeUnsignedByte: anInteger class: aClass"3.3.24 unsignedByte[Definition:]   unsignedByte is Â·derivedÂ· from unsignedShort by setting the value of Â·maxInclusiveÂ· to be 255. The Â·base typeÂ· of unsignedByte is unsignedShort. 3.3.24.1 Lexical representationunsignedByte has a lexical representation consisting of a finite-length sequence of decimal digits (#x30-#x39). For example: 0, 126, 100. 3.3.24.2 Canonical representationThe canonical representation for unsignedByte is defined by prohibiting certain options from the Lexical representation (Â§3.3.24.1). Specifically, leading zeroes are prohibited"		(self ensureClass: aClass for: anInteger) ifNotNil: [:value | ^value].	( self isUnsignedByte: anInteger)		ifFalse: [ ^(EncodingIntegerOutOfRange new)					messageText: (#CanntEncodeUnsignedByteType &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:unsignedByte". Wrong range '								expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeUnsignedInt: anInteger class: aClass"3.3.22 unsignedInt[Definition:]   unsignedInt is Â·derivedÂ· from unsignedLong by setting the value of Â·maxInclusiveÂ· to be 4294967295. The Â·base typeÂ· of unsignedInt is unsignedLong. 3.3.22.1 Lexical representationunsignedInt has a lexical representation consisting of a finite-length sequence of decimal digits (#x30-#x39). For example: 0, 1267896754, 100000. 3.3.22.2 Canonical representationThe canonical representation for unsignedInt is defined by prohibiting certain options from the Lexical representation (Â§3.3.22.1). Specifically, leading zeroes are prohibited. "	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		( self isUnsignedInt: anInteger)		ifFalse: [ ^(EncodingIntegerOutOfRange new)					messageText: (#CanntEncodeUnsignedInt&lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:unsignedInt". Wrong range '								expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeUnsignedLong: anInteger class: aClass"3.3.21 unsignedLong[Definition:]   unsignedLong is Â·derivedÂ· from nonNegativeInteger by setting the value of Â·maxInclusiveÂ· to be 18446744073709551615. The Â·base typeÂ· of unsignedLong is nonNegativeInteger. 3.3.21.1 Lexical representationunsignedLong has a lexical representation consisting of a finite-length sequence of decimal digits (#x30-#x39). For example: 0, 12678967543233, 100000. 3.3.21.2 Canonical representationThe canonical representation for unsignedLong is defined by prohibiting certain options from the Lexical representation (Â§3.3.21.1). Specifically, leading zeroes are prohibited. "	(self ensureClass: Integer for: anInteger) ifNotNil: [ :value | ^value].		(self isUnsignedLong: anInteger)		ifFalse: [ ^(EncodingIntegerOutOfRange new)					messageText: (#CanntEncodeUnsignedLong &lt;&lt; #webservices &gt;&gt; 'Can not encode: ,1s&gt; into "xsd:unsignedLong". Wrong range '								expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeUnsignedShort: anInteger class: aClass" 3.3.23 unsignedShort[Definition:]   unsignedShort is Â·derivedÂ· from unsignedInt by setting the value of Â·maxInclusiveÂ· to be 65535. The Â·base typeÂ· of unsignedShort is unsignedInt. 3.3.23.1 Lexical representationunsignedShort has a lexical representation consisting of a finite-length sequence of decimal digits (#x30-#x39). For example: 0, 12678, 10000. 3.3.23.2 Canonical representationThe canonical representation for unsignedShort is defined by prohibiting certain options from the Lexical representation (Â§3.3.23.1). Specifically, the leading zeroes are prohibited"	(self ensureClass: aClass for: anInteger) ifNotNil: [ :value | ^value].		(self isUnsignedShort: anInteger)		ifFalse: [ ^EncodingIntegerOutOfRange new					messageText: (#CanntEncodeUnsignedShort &lt;&lt; #webservices &gt;&gt; 'Can not encode: &lt;1s&gt; into "xsd:unsignedShort". Wrong range ' expandMacrosWith: anInteger printString);					parameter: anInteger;					raiseSignal].	^anInteger printString</body><body package="XMLObjectMarshalers">encodeXMLNode: aMarshalingContext	aMarshalingContext value isElement		ifTrue: [ 	aMarshalingContext source					attributes: aMarshalingContext value attributes;					elements: aMarshalingContext value realElements ].	aMarshalingContext value isText		ifTrue: [ 	aMarshalingContext source addNode: aMarshalingContext value ].</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>private conversion</category><body package="XMLObjectMarshalers">canNotDecode:  aNode from: aMarshalingContext	aMarshalingContext 		notifyNoMarshalerFor: aNode 		text: ((#DecodingAnyType &lt;&lt; #webservices &gt;&gt; ' decoding anyType &lt;1s&gt;') expandMacrosWith: aNode tag expandedName)</body><body package="XMLObjectMarshalers">decodeArith: aString using: aClass allowed: allowed onError: aBlock	| allowedChars | 	allowedChars :=  '+-.', allowed.	aString do: [:c | (c isDigit or: [ allowedChars includes: c ]) ifFalse: [^aBlock value ]].	^aClass readFrom: aString readStream</body><body package="XMLObjectMarshalers">decodeArith: aString using: aClass onError: aBlock	^self decodeArith: aString using: aClass allowed: '' onError: aBlock</body><body package="XMLObjectMarshalers">decodeArithError: aString datatype: aSymbol	^XMLDecodingError new		messageText: ( #CantDecodeNumberFrom &lt;&lt; #webservices &gt;&gt; ('Can not decode "xsd:&lt;1s&gt;"  from: &lt;2s&gt;')				expandMacrosWith: aSymbol asString with: aString);		parameter: aString;		xmlDatatype: aSymbol;		raiseSignal</body><body package="XMLObjectMarshalers">ensureClass: aClass for: aValue	(aValue isKindOf: aClass) 		ifFalse: [  ^XMLEncodingError new					messageText:  ((#CanntEncodeValue &lt;&lt; #webservices &gt;&gt;'Can not encode: &lt;1s&gt; expected class: &lt;2s&gt;') 										expandMacrosWith: aValue printString with: aClass name);					parameter: aValue;					expectedClass: aClass;					raiseSignal ].	^nil</body><body package="XMLObjectMarshalers">isInvalidCharacter: char	^char asInteger &lt; 32		and: [(self xmlStringLegalCharacters includes: char) not].</body><body package="XMLObjectMarshalers">printAsDecimal: aNumber	^(self numberPolicy		print: aNumber		policy: self decimalPrintPolicy) string</body><body package="XMLObjectMarshalers">printDecimal: decimal	| scale denom n quo rem aStream |	aStream := String new writeStream.	scale := decimal scale.	denom := 10 ** scale.	n := decimal numerator * denom + (decimal denominator bitShift: -1) // decimal denominator.	decimal numerator &lt; 0		ifTrue:			[aStream nextPut: $-.			n := n negated].	quo := n // denom.	rem := n \\ denom.	quo printOn: aStream.	aStream nextPut: $..	scale &gt; 0		ifTrue:			[scale timesRepeat:				[rem := rem*10.				aStream nextPut: (Character digitValue: rem//denom).				rem := rem \\ denom]].	^aStream contents</body><body package="XMLObjectMarshalers">spaceSeparatedStringFromTokens: tokens	|stream|	stream := (String new: 32) writeStream.	tokens do: [ :token | stream nextPutAll: token ]			separatedBy: [ stream space].	^self encodeToken: stream contents class: String</body><body package="XMLObjectMarshalers">tokensFromSpaceSeparatedString: string	^(string tokensBasedOn: Character space) 		collect: [ :token | self encodeToken: token trimBlanks class: String]</body><body package="XMLObjectMarshalers">validateNormalizedString: aString"3.3.1 normalizedString[Definition:]   normalizedString represents white space normalized strings. The Â·value spaceÂ· of normalizedString is the set of strings that do not contain the carriage return (#xD), line feed (#xA) nor tab (#x9) characters. The Â·lexical spaceÂ· of normalizedString is the set of strings that do not contain the carriage return (#xD) nor tab (#x9) characters. The Â·base typeÂ· of normalizedString is string. "	^aString 		detect: [:char | (char asInteger &lt; 32) and: [char ~= Character lf ] ]		ifNone: [^nil].</body><body package="XMLObjectMarshalers">validateString: aString"The string datatype represents character strings in XML. The Â·value spaceÂ· of string is the set of finite-length sequences of characters (as defined in [XML 1.0 (Second Edition)]A character is an atomic unit of text as specified by ISO/IEC 10646 [ISO/IEC 10646] [E67](see also [ISO/IEC 10646-2000]). Legal characters are tab, carriage return, line feed, and the legal characters of Unicode and ISO/IEC 10646. [E69]The versions of these standards cited in A.1 Normative References were current at the time this document was prepared. New characters may be added to these standards by amendments or new editions. Consequently, XML processors must accept any character in the range specified for Char. The use of 'compatibility characters', as defined in section 6.8 of [Unicode] [E67](see also D21 in section 3.6 of [Unicode3]), is discouraged.]Character Range[2]    Char    ::=    #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]  /* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */  "	^aString detect: [:char | self isInvalidCharacter: char ] ifNone: [nil].</body><body package="XMLObjectMarshalers">validateToken: aString"3.3.2 token[Definition:]   token represents tokenized strings. The Â·value spaceÂ· of token is the set of strings that do not contain the line feed (#xA) nor tab (#x9) characters, that have no leading or trailing spaces (#x20) and that have no internal sequences of two or more spaces. The Â·lexical spaceÂ· of token is the set of strings that do not contain the line feed (#xA) nor tab (#x9) characters, that have no leading or trailing spaces (#x20) and that have no internal sequences of two or more spaces. The Â·base typeÂ· of token is normalizedString. "	^aString 		detect: [:char | 	char asInteger &lt; 32 ]		ifNone: [^nil].</body><body package="XMLObjectMarshalers">xmlStringLegalCharacters		^xmlStringLegalCharacters ifNil: 		[ xmlStringLegalCharacters := Array with: Character tab with: Character cr with:  Character lf. ].</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>testing</category><body package="XMLObjectMarshalers">isByte: anInteger	^anInteger between: -16r80 and: 16r7F</body><body package="XMLObjectMarshalers">isInt: anInteger		^anInteger between: -16r80000000 and: 16r7FFFFFFF</body><body package="XMLObjectMarshalers">isLong: anInteger 	^anInteger between: -16r8000000000000000 and: 16r7FFFFFFFFFFFFFFF</body><body package="XMLObjectMarshalers">isNegativeInteger: anInteger	^anInteger &lt; 0</body><body package="XMLObjectMarshalers">isNonNegativeInteger: anInteger		^anInteger &gt;= 0</body><body package="XMLObjectMarshalers">isNonPositiveInteger: anInteger	^anInteger &lt;= 0</body><body package="XMLObjectMarshalers">isPositiveInteger: anInteger	^anInteger &gt; 0</body><body package="XMLObjectMarshalers">isShort: anInteger		^(anInteger between: -16r8000 and: 16r7FFF )</body><body package="XMLObjectMarshalers">isUnsignedByte: anInteger	^anInteger between: 0 and: 16rFF</body><body package="XMLObjectMarshalers">isUnsignedInt: anInteger	^anInteger between: 0 and: 16rFFFFFFFF</body><body package="XMLObjectMarshalers">isUnsignedLong: anInteger	^anInteger between: 0 and: 16rFFFFFFFFFFFFFFFF</body><body package="XMLObjectMarshalers">isUnsignedShort: anInteger	^anInteger between: 0 and: 16rFFFF</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>fileIn/Out</category><body package="XMLObjectMarshalers">prerequisitesForLoading	^super prerequisitesForLoading		add: AspectImplementation;		yourself</body></methods><methods><class-id>WebServices.BindingBuilder class</class-id> <category>conversion</category><body package="XMLObjectMarshalers">decodeTimeFrom: aString using: aTimestamp"BindingBuilder decodeTimeFrom: '21:12:13.0001-07:00'  ""BindingBuilder decodeTimeFrom: '21:12:13.0001'  ""BindingBuilder decodeTimeFrom: '21:12:13-07:00'  ""BindingBuilder decodeTimeFrom: '21:12:13Z'  ""BindingBuilder decodeTimeFrom: '12:22:41.0000000-08:00'  ""BindingBuilder decodeTimeFrom: '12:22:41.0000234-08:00'  ""BindingBuilder decodeTimeFrom: '03:36:46.0000099-08:00'  "	| stream time tzd localTimestamp  |	stream := aString readStream.	[time := stream atEnd 		ifTrue: [Time fromSeconds: 0] 		ifFalse: [(Locale named: #C) timePolicy reader readLatinTimeFrom: stream].	"Answered instance of time has milliseconds and partialNanosecond if available from the input data."	aTimestamp 		hour: time hours; 		minute: time minutes; 		second: time seconds; 		milliseconds: time milliseconds; 		partialNanosecond: time partialNanosecond.	localTimestamp := ('Z+-' includes: (tzd := stream next))		ifTrue:			["Timezone adaption if time zone designator (TZD) specified"			| secondsFromGMT gmtSeconds localSeconds nanosecond |			secondsFromGMT := tzd = $Z 				ifTrue: [0] 				ifFalse: [((Locale named: #C) timePolicy reader readLatinTimeFrom: stream) asSeconds].			tzd = $- ifTrue: [secondsFromGMT := secondsFromGMT negated].			gmtSeconds := aTimestamp asSeconds - secondsFromGMT.			localSeconds := TimeZone default convertGMTSecondsToLocal: gmtSeconds.			aTimestamp partialNanosecond isNil 				ifTrue: [ nanosecond := 0 ] 				ifFalse: [ nanosecond := aTimestamp partialNanosecond ].			( Timestamp fromSeconds: localSeconds ) 				milliseconds: aTimestamp milliseconds; 				partialNanosecond: nanosecond;				yourself ]		ifFalse: [aTimestamp].	^localTimestamp		] on: Error do: [ :ex | ex return ].	^XMLDecodingError new		messageText: ((#CantDecodeTime &lt;&lt; #webservices &gt;&gt; 'Can not decode Time from: &lt;1s&gt; ')		expandMacrosWith: aString);		parameter: aString;		xmlDatatype: #time;		raiseSignal</body></methods><methods><class-id>UnresolvedPragmaReferences class</class-id> <category>testing</category><body package="XMLObjectMarshalers">mayResume	^true</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isListType	^true</body><body package="XMLObjectMarshalers">isResolved	^marshaler  isResolved</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">add: aTypeMarshaler	marshaler :=  aTypeMarshaler</body><body package="XMLObjectMarshalers">finish	marshaler  finish</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder" Set any attributes we are interested in "	super setAttributesFrom: attributesx in: builder.	(self findDomainValue: 'itemType' in: attributesx) 		ifNotNil: [ :itemType | 				builder 			 		resolveType: itemType 					do: 	[ :resolved | marshaler :=  resolved  ]]</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oContents	^'list'</body><body package="XMLObjectMarshalers">xmlContents	^'list'</body><body package="XMLObjectMarshalers">xmlItemType	^(self attributes associations detect: [ :assoc |  assoc key type = 'itemType' ] ifNone: [ nil])		ifNotNil: [  marshaler path ]</body><body package="XMLObjectMarshalers">xmlList	| struct |	struct := Struct new.	self xmlItemType		ifNotNil: [ :node | struct at: #itemType put: node ]		ifNil: [  struct at: #simpleType put: marshaler ].	^struct</body><body package="XMLObjectMarshalers">xmlSimpleType		^self xmlItemType		ifNil: [marshaler]		ifNotNil: [nil]</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext	| mc values stream |	(marshalingContext value isKindOf: SequenceableCollection) ifFalse: [ 		^WrongObjectType new				messageText: (#WrongListType &lt;&lt; #webservices &gt;&gt; 'Wrong list type: #&lt;1s&gt;. Selector: #&lt;2s&gt; should return SequenceableCollection.' 						expandMacrosWith: marshalingContext value class name 						with: marshalingContext marshaler relation getSelector );				parameter: marshalingContext value;				raiseRequest].	values := marshalingContext value collect: [ :each | 		marshaler privateMarshalFrom: ( mc := MarshalingContext new value: each; yourself ).		mc value].	stream := String new writeStream.	values do: [ :string | stream nextPutAll: string  ] separatedBy: [stream nextPut: Character space].	marshalingContext value:  stream contents</body><body package="XMLObjectMarshalers">setInlineTypeFor: anElement marshalingContext: aMarshalingContext</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>tool</category><body package="XMLObjectMarshalers">selectorType	| stream |	stream := String new writeStream.	stream  nextPut: $a.	stream nextPutAll: (marshaler smalltalkClassName tokensBasedOn: $.) last.	^stream contents</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	super postCopy.	marshaler := marshaler copy</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	stream			nextPut: $" ;		nextPutAll: 'OrderedCollection of ', marshaler smalltalkClassName; 		nextPut: $"</body><body package="XMLObjectMarshalers">printOn: aStream	aStream nextPutAll: 'List item: '.	marshaler ifNotNil: [aStream nextPutAll: self tag printString].	aStream nextPutAll: ' type: '.	marshaler ifNotNil: [ marshaler printOn: aStream].</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">marshaler	^marshaler</body></methods><methods><class-id>WebServices.ListMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	| val  tokens | 	tokens := marshalingContext node characterData tokensBasedOn: Character space.	val := tokens collect: [ :token |		marshaler validateValue: (				marshaler deserializationBlock 					value: marshalingContext  					value: token  					value: marshaler smalltalkClass)].	marshalingContext value:  val.	aBlock value: marshalingContext</body></methods><methods><class-id>WebServices.KeyObjectMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addElementMarshaler: relationMarshaler	(relationMarshaler isRelationMarshaler ) 		ifTrue: [relations add: relationMarshaler]		ifFalse: [ self error: ( #WrongTypeOfElementMarshaler &lt;&lt; #webservices &gt;&gt; 'Wrong type of the element marshaler: &lt;1s&gt;. Expected RelationMarshaler' expandMacrosWith: relationMarshaler printString )].</body><body package="XMLObjectMarshalers">addTo: aParentMarshaler" Add myself to my parent. This method is overridden in attribute resolver so that we distinguish between element resolvers and attribute resolvers "	aParentMarshaler addKeyMarshaler: self.</body><body package="XMLObjectMarshalers">finish</body><body package="XMLObjectMarshalers">privateSetAttributesFrom: attributesx in: builder	builder binding add: self</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder" Set any attributes we are interested in "	attributesx at: (NodeTag qualifier: '' ns: '' type: 'xpath') put: '*'.	super setAttributesFrom: attributesx in: builder.	self privateSetAttributesFrom: attributesx in: builder.</body></methods><methods><class-id>WebServices.KeyObjectMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">createInstanceFor: marshalingContext	^[smalltalkClass withSize: marshalingContext nodes size]		on: Error		do: [ :ex | ex return: (smalltalkClass new: marshalingContext nodes size)]</body><body package="XMLObjectMarshalers">unmarshalElement: aMarshaler from: marshalingContext	| child |	child := (marshalingContext asPartMarshaler: aMarshaler source: marshalingContext node).	child 		decodeAndUnmarshal: [ :mc |			aspectImplementation 				setAspectFrom: mc aspect 				for: marshalingContext value 				to: mc value				context: marshalingContext ]</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock" A simplified version of generic unmarshaling which assumes thattarget is always a new instance of our Smalltalk class "	| target |	target := self newInstanceFor: marshalingContext.	marshalingContext value: target. 	relations do: [ :marshaler | self unmarshalElement: marshaler from: marshalingContext ].	aBlock value: marshalingContext</body></methods><methods><class-id>WebServices.KeyObjectMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">relations	^relations</body></methods><methods><class-id>WebServices.KeyObjectMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">copyFrom: anotherMarshaler	anotherMarshaler relations reverseDo:		 [ :elementMarshaler |			(elementMarshaler isRelationMarshaler ) 				ifTrue: [relations addFirst: elementMarshaler]				ifFalse: [ self error: (#WrongMarshalerType &lt;&lt; #webservices &gt;&gt; 'Wrong marshaler type')]].	smalltalkClass := anotherMarshaler smalltalkClass.</body><body package="XMLObjectMarshalers">postCopy	super postCopy.	relations := relations collect: [ :r | r copy].</body></methods><methods><class-id>WebServices.KeyObjectMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalElementsFrom: marshalingContext	relations do: 		[ :element | 		self marshalElement: element from: marshalingContext ].</body><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext	super privateMarshalFrom: marshalingContext.	self marshalElementsFrom: marshalingContext.</body></methods><methods><class-id>WebServices.KeyObjectMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	relations := OrderedCollection new.	smalltalkClass := OrderedCollection.	aspectImplementation := AspectImplementation sequenceableCollectionAspects</body></methods><methods><class-id>WebServices.KeyObjectMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue:[^self].	super nodesDo: aBlock withRegistry: anIdentitySet.	relations do: [:relation | relation nodesDo: aBlock withRegistry: anIdentitySet]</body></methods><methods><class-id>WebServices.KeyRefObjectMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addTo: aParentMarshaler" Add myself to my parent. This method is overridden in attribute resolver so that we distinguish between element resolvers and attribute resolvers "	aParentMarshaler addKeyRefMarshaler: self.</body><body package="XMLObjectMarshalers">finish	keyRef isNil		ifTrue: [self error: (#CantResolveKeyReference &lt;&lt; #webservices &gt;&gt; 'Can''t resolve key reference')].	super finish</body><body package="XMLObjectMarshalers">privateSetAttributesFrom: attributesx in: builder	| ref keyTag |	 (ref := self findDomainValue: 'ref' in: attributesx) notNil		ifTrue:			[keyTag := ref copy. 			keyRef := builder binding							keyForTag: #type -&gt;keyTag 							ifAbsent: 								[self error: ((#KeyNotFound &lt;&lt; #webservices &gt;&gt; 'Key &lt;1s&gt; not found')											expandMacrosWith: keyTag asString)]].</body></methods><methods><class-id>WebServices.KeyRefObjectMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalFrom: marshalingContext	marshalingContext 		value: (marshalingContext manager 				findKeyRefValueFor: marshalingContext value 				ifNone: [^self error: 'No keyRef value for: ', marshalingContext value printString ]) first.</body></methods><methods><class-id>WebServices.KeyRefObjectMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isResolved	^keyRef notNil and: [ super isResolved]</body></methods><methods><class-id>WebServices.KeyRefObjectMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">keyRef	^keyRef</body></methods><methods><class-id>WebServices.AttributeGroupMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isAttributeGroup	^true</body><body package="XMLObjectMarshalers">isGroup	^false</body></methods><methods><class-id>WebServices.AttributeGroupMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">acceptMarshaler: resolvedMarshalers" Accepted only ModelAttributeGroupMarshaler" 	^resolvedMarshalers 		detect: [ :resolved | resolved isModelAttributeGroup ] 		ifNone: [ self error: (#CannotResolveAttributeGroupReference &lt;&lt; #webservices &gt;&gt; 'Can not resolve attribute group reference' )]</body><body package="XMLObjectMarshalers">localNameString	" is used by choice marshaler to create xpath " 	| stream |	stream := String new writeStream.	marshaler relations		do: [ :each | stream nextPutAll:  each localNameString ]		separatedBy: [ stream nextPutAll:  ' or '].	^stream contents</body><body package="XMLObjectMarshalers">resolveTypeMarshalerFrom: attributesx in: builder	(self findDomainValue: 'ref' in: attributesx) ifNil: [		^self error: (#CannotResolveGroupReference &lt;&lt; #webservices &gt;&gt; 'Can not resolve group reference' )].	super resolveTypeMarshalerFrom: attributesx in: builder</body><body package="XMLObjectMarshalers">setRelationFrom: attributesx in: builder"&lt;attributeGroup  id = ID  name = NCName  ref = QName  Content: (annotation?, ((attribute | attributeGroup)*, anyAttribute?))&lt;/attributeGroup&gt;"	relation := Relation fromAttributes:  attributesx from: self.	"There is no cardinality in attributeGroup definition"	relation minOccurs: 0.</body></methods><methods><class-id>WebServices.AttributeGroupMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	marshaler acceptNodesAndUnmarshal: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">canAcceptNode: aNodeTag		^marshaler relations anySatisfy: [ :each | each canAcceptNode: aNodeTag ]</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext do: aBlock	marshaler decodeAndUnmarshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">detectChoiceFrom: aMarshalingContext  ifFound: aBlock	^marshaler detectChoiceFrom: aMarshalingContext  ifFound: aBlock</body></methods><methods><class-id>WebServices.AttributeGroupMarshaler</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock		aBlock value: self</body><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue: [^self].	anIdentitySet add: self.	aBlock value: self</body></methods><methods><class-id>WebServices.AttributeGroupMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlRef	^(self findDomainValue: 'ref' in: attributes ) ifNotNil: [ self typeMarshaler xmlType ]</body></methods><methods><class-id>WebServices.AttributeGroupMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalFrom: marshalingContext 	marshaler aspectImplementation: marshalingContext aspectImplementation. 	marshaler marshalElementsFrom: marshalingContext</body></methods><methods><class-id>WebServices.AttributeGroupMarshaler</class-id> <category>tool</category><body package="XMLObjectMarshalers">addAspectRelationTo: aCollection		marshaler relations do: [ :each | each addAspectRelationTo: aCollection ]</body></methods><methods><class-id>WebServices.HrefMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isResolved	^(self value notNil and: [ self value isResolved])</body></methods><methods><class-id>WebServices.HrefMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream	aStream		nextPutAll: self class name;		space;		nextPutAll: ((#ReferencesHref &lt;&lt; #webservices &gt;&gt; 'References: &lt;1s&gt;')						expandMacrosWith: numberRefs printString).	value notNil 		ifTrue: 			[ aStream nextPutAll: ((#ValueHref &lt;&lt; #webservices &gt;&gt; ' Value: &lt;1s&gt;')									expandMacrosWith: value printString) ].</body></methods><methods><class-id>WebServices.HrefMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">getValue	^value notNil		ifTrue: [ value ]		ifFalse: [nil]</body><body package="XMLObjectMarshalers">source	^source</body><body package="XMLObjectMarshalers">source: anXMLElement	source := anXMLElement</body><body package="XMLObjectMarshalers">value	^value</body><body package="XMLObjectMarshalers">value: anObject	value := anObject</body></methods><methods><class-id>WebServices.HrefMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	numberRefs := 1</body></methods><methods><class-id>WebServices.HrefMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">setReferenceFor: anXMLElement manager: aMarshalingMananger	| idAttr |	numberRefs = 1		ifTrue: 			["&lt;idx id='idx' .... /&gt;"			idAttr := aMarshalingMananger encodeIdAttributeFor: self tag type.			idAttr := self source attributes 				detect: [ :attr | attr key = idAttr key ]				ifNone: [ self source attributes: (self source attributes asOrderedCollection 	addLast: idAttr; yourself).						idAttr].			hrefAttributes := OrderedCollection with: (aMarshalingMananger encodeHrefAttributeFor: idAttr value )].	numberRefs := numberRefs + 1.	"&lt;nodex href='#idx' /&gt;"	anXMLElement attributes: hrefAttributes. 	^anXMLElement</body></methods><methods><class-id>WebServices.HrefMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: aMarshalingContext do: aBlock	(self setReferencedValueFor: aMarshalingContext)		ifFalse: [self unmarshalFrom: aMarshalingContext ].	^aBlock value: aMarshalingContext</body><body package="XMLObjectMarshalers">setReferencedValueFor: aMarshalingContext	self isResolved 		ifTrue: [aMarshalingContext value: self getValue value.				aMarshalingContext 	beReference.				^true].	^false</body><body package="XMLObjectMarshalers">unmarshalFrom: aMarshalingContext 	aMarshalingContext source: self source. 	aMarshalingContext  nodeContext: (Array with: self source).  	aMarshalingContext marshaler: ( aMarshalingContext marshaler getRealMarshaler: aMarshalingContext unmarshal: aMarshalingContext node ).	aMarshalingContext unmarshal.	aMarshalingContext 	beReference.	value :=  aMarshalingContext.</body></methods><methods><class-id>WebServices.HrefMarshaler class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">id: idRefString value: anObject source: anXMLElement	^self new 		value: anObject;		tag:  (NodeTag qualifier: '' ns: '' type: idRefString);		source: anXMLElement;		yourself</body><body package="XMLObjectMarshalers">source: anXMLElement	^self new 		source: anXMLElement;		yourself</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">finish</body><body package="XMLObjectMarshalers">localNameString	" is used by choice marshaler to create xpath " 		^( 'local-name() = "*"' )</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	namespaces := OrderedCollection new.	(self findDomainValue: 'namespace' in: attributesx) 		ifNotNil: [ :nss | (nss tokensBasedOn: Character space) do: [ :ns | ns isNotEmpty ifTrue: [namespaces add: ns asSymbol ]]]		ifNil: [namespaces add:  #'##any' ].	processContents := ((self findDomainValue: 'processContents' in: attributesx)		ifNotNil: [ :pc | pc ]		ifNil: [ 'strict' ]) asSymbol.</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isAnyRelationMarshaler	^true</body><body package="XMLObjectMarshalers">isElement	^true</body><body package="XMLObjectMarshalers">useTaggedObject: marshalingContext	^marshalingContext manager useTaggedObject</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlNamespaceFilter	^self xpath namespaceFilter ifNotNil: [ :ns | ns asString ]</body><body package="XMLObjectMarshalers">xmlProcessContents	^(processContents isNil or: [	processContents = #strict ]) 		ifTrue: [ nil ]		ifFalse: [ processContents ]</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: aStream indentation: number	self relation setSelector isNil ifTrue: [^nil].	self relation isManyRelation ifTrue: [ aStream nextPutAll: 'OrderedCollection with: (' ].	self processContents = #skip		ifTrue: [ aStream nextPutAll: 'WebServices.TaggedObject element: (XML.Element tag: aNodeTag elements: elements) ' ]		ifFalse: [ aStream nextPutAll: 'WebServices.TaggedObject ns: marshalerNamespace type: marshalerType value: anObject' ].	self relation isManyRelation ifTrue: [ aStream nextPut: $) ].</body><body package="XMLObjectMarshalers">printOn: aStream 	aStream		nextPutAll: self class name;		space.	relation ifNotNil: [aStream nextPutAll: ' aspect=', relation name; space ].	processContents ifNotNil: [aStream nextPutAll: ' processContents=', processContents ].	namespaces ifNotNil: [		aStream nextPutAll: ' namespaces="'.		namespaces 			do: [ :ns | aStream nextPutAll: ns  ]			separatedBy: [ aStream nextPutAll: Character space ].			aStream nextPutAll: '"'. ]</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	^(marshalingContext nodes notEmpty		and: [self 					canAcceptNode: marshalingContext node tag 				targetNamespace: marshalingContext binding targetNamespace])		ifTrue: [ relation unmarshalFrom: marshalingContext relationMarshaler: self do: aBlock ]		ifFalse: [self missingValueNotification]</body><body package="XMLObjectMarshalers">canAcceptNode: aNodeTag	^self canAcceptNode: aNodeTag targetNamespace: binding targetNamespace</body><body package="XMLObjectMarshalers">canAcceptNode: aNodeTag targetNamespace: targetNamespace	| aNamespace |	aNamespace := aNodeTag namespace.	^(self namespaces includes: #'##any') 		or: [((self namespaces includes: #'##local') and: [aNamespace isEmpty]) 			or: [((self namespaces includes: #'##targetNamespace') and: [aNamespace = targetNamespace ]) 				or: [(self namespaces includes: aNamespace asSymbol)					or: [ ((self namespaces includes: #'##other') and: [ aNamespace ~= targetNamespace ]) ]]]]</body><body package="XMLObjectMarshalers">missingValueNotification	MissingValueNotification raiseWith: ((#MissingWildcardElement &lt;&lt; #webservices &gt;&gt; '&lt;1s&gt;') expandMacrosWith: self printString)</body><body package="XMLObjectMarshalers">unmarshalCollectionFrom: marshalingContext do: aBlock	|  mc coll |	coll := OrderedCollection new.	[(mc := self unmarshalFrom: marshalingContext ) notNil ]		whileTrue: [ coll add: mc value ].	marshalingContext value: coll.	aBlock value: marshalingContext</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext	| node unmarshaler aMarshalingContext |	marshalingContext nodes isEmpty ifTrue: [^nil].	node := marshalingContext nodes first.	(self canAcceptNode: node tag targetNamespace: binding targetNamespace) ifFalse: [^nil ].	((unmarshaler := self findRelationMarshalerForTag: node tag marshalingContext: marshalingContext) isNil		and: [ processContents ~= #skip ])		ifTrue: [unmarshaler :=  marshalingContext binding marshalerForTag: node tag ifAbsent: [nil] ].	^unmarshaler 		ifNotNil: [	unmarshaler typeMarshaler tag type = 'anyType'					ifTrue: [self error: #CannotUseXMLAnyType &lt;&lt; #webservices &gt;&gt; 'Can not use a marshaler with XML type #anyType in AnyRelationMarshaler. It can cause recursion' ].					unmarshaler 						acceptNodesAndUnmarshal: marshalingContext 						do: [ :mc | aMarshalingContext := mc.							self  useTaggedObject								ifTrue: [aMarshalingContext value: (TaggedObject ns: node tag namespace type: node tag type value: mc value) ].							aMarshalingContext aspect: self relation. 							(self relation setSelector isNil								and: [unmarshaler relation setSelector notNil]) 								ifTrue: [aMarshalingContext aspect: unmarshaler relation ]].					aMarshalingContext]		ifNil: [ | object |			 processContents = #strict ifTrue: [^self missingMarshalerFor: marshalingContext node ].		 	(processContents = #lax or: [processContents = #skip])				ifTrue: [object := self useTaggedObject							ifTrue: [TaggedObject 										ns: marshalingContext node tag namespace 										type: marshalingContext node tag type 										value: marshalingContext node ]							ifFalse: [ marshalingContext node ].						marshalingContext nodes remove: marshalingContext node.						MarshalingContext new 							aspect: self relation; 							value: object; 							yourself ]]</body><body package="XMLObjectMarshalers">unmarshalObjectFrom: marshalingContext  do: aBlock 	(self unmarshalFrom: marshalingContext ) ifNotNil: [ :mc | aBlock value: mc ]</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">addNamespaceToSource: marshalingContext 	self binding ifNil: [^false].	(self binding targetNamespace = 'urn:visualworks:VWSchemaBinding/Mapping'		or: [self binding targetNamespace = 'http://www.w3.org/2001/XMLSchema/Mapping' 							or: [marshalingContext marshaler qualified]]) ifTrue: [^nil].	marshalingContext parent source tag namespace ~= marshalingContext source tag namespace		ifTrue: [ 	marshalingContext source namespaceAt: '' put: marshalingContext source tag namespace ]</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext	^(marshalingContext getValueFor: self relation) 		ifNil: [self relation isMandatory ifTrue: [self missingValueNotification]]		ifNotNil: [ :value |			self setNodeAndMarshalFrom: (marshalingContext asPartMarshaler: self  value: value)]</body><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext</body><body package="XMLObjectMarshalers">realMarshalerFor: anObject marshalingContext: marshalingContext	( marshalingContext manager registeredObjects  at: anObject ifAbsent: [nil] ) ifNotNil: [ :m | ^m ].				^(self valueFrom: anObject marshalingContext: marshalingContext)		ifNotNil: [ :val | 			anObject isTaggedObject				ifTrue: [(self findRelationMarshalerForTag: anObject nodeTag marshalingContext: marshalingContext) ifNotNil: [ :m | m ] ]				ifFalse: [marshalingContext binding marshalerForClass: val class ifAbsent:  [nil] ]].</body><body package="XMLObjectMarshalers">setNodeAndMarshalFrom: marshalingContext	relation 		marshalFrom: marshalingContext 		do: [ :value |			value ifNil: [^MissingValueNotification raiseWith: self relation getSelector printString].			( self realMarshalerFor: value marshalingContext: marshalingContext ) 				ifNotNil: [ :realMarshaler |					marshalingContext						value: (value isTaggedObject ifTrue: [value value] ifFalse: [value]);						marshaler: realMarshaler;						tag: realMarshaler tag.					realMarshaler setNodeAndMarshalFrom: marshalingContext.					self addNamespaceToSource: marshalingContext ]				ifNil: [ processContents = #strict ifTrue: [ self missingMarshalerFor: value ]]]</body><body package="XMLObjectMarshalers">valueFrom: anObject marshalingContext: marshalingContext	| val |	(self useTaggedObject and: [anObject isTaggedObject not])		ifTrue: [ self error: ((#TheValueForAnyRelationMarshalerTaggedObject &lt;&lt; #webservices &gt;&gt; 'The value for &lt;1s&gt; has to be an instance of TaggedObject') expandMacrosWith: self class name) ].	val := anObject isTaggedObject ifTrue: [anObject value] ifFalse: [anObject]. 	(val isKindOf: Element)		ifTrue: [^(processContents = #lax or: [processContents = #skip])					ifTrue: [marshalingContext parent source addNode: val. nil]					ifFalse: [self error: (#AnXMLElementShouldNotBeValueForStrict &lt;&lt;#webservices &gt;&gt; 'An XML Element should not be provided as a value for #strict processContents ')]].	processContents = #skip ifTrue: [^nil].	^val</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">namespaces	^namespaces</body><body package="XMLObjectMarshalers">namespaces: aString	namespaces := aString</body><body package="XMLObjectMarshalers">processContents	^processContents</body><body package="XMLObjectMarshalers">processContents: aSymbol	processContents := aSymbol</body><body package="XMLObjectMarshalers">useTaggedObject	^self binding useTaggedObject</body></methods><methods><class-id>WebServices.AnyRelationMarshaler</class-id> <category>private</category><body package="XMLObjectMarshalers">canAcceptMarshaler: aTypeMarshaler	^aTypeMarshaler isRelationMarshaler</body><body package="XMLObjectMarshalers">findBindingsFor: aNodeTag marshalingContext: marshalingContext	| ns targetNamespace registry bindings |	ns := aNodeTag namespace.	((self namespaces includes: #'##local') and: [ns isEmpty]) 		ifTrue: [^marshalingContext  binding importedBindings select: [ :b | b targetNamespace isEmpty] ].	targetNamespace := self binding targetNamespace.	((self namespaces includes: #'##targetNamespace') and: [ns = targetNamespace ])  		ifTrue: [^OrderedCollection with: self binding ].	registry := marshalingContext manager wildcardScope notEmpty		ifTrue: [marshalingContext manager wildcardScope ] 		ifFalse: [XMLObjectBinding registry values].	(self namespaces includes: #'##any') ifTrue: [^registry ].	bindings := OrderedCollection new.	registry do: [ :b |		((self namespaces includes: ns asSymbol)			and: [b targetNamespace = ns]) ifTrue: [bindings add: b].		((self namespaces includes: #'##other') 			and: [ b targetNamespace ~= targetNamespace ]) ifTrue: [bindings add: b]]. 	^bindings</body><body package="XMLObjectMarshalers">findRelationMarshalerForTag: aNodeTag marshalingContext: marshalingContext	 processContents = #skip ifTrue: [^nil].	(self findBindingsFor: aNodeTag marshalingContext: marshalingContext) do: [ :aBinding | 		(aBinding marshalers detect: [ :m |( m isLike: aNodeTag) and: [self canAcceptMarshaler: m ]] ifNone: [nil])			ifNotNil: [ :m | ^m ]].	^nil</body><body package="XMLObjectMarshalers">missingMarshalerFor: value 	NoMarshalerSignal new		messageText: (#AnyRelationMarshalerMarshalerIsNotFound &lt;&lt; #webservices &gt;&gt; 'AnyRelationMarshaler:  Marshaler is not found for: &lt;1s&gt;' expandMacrosWith: value printString );		parameter: value;		raiseRequest</body></methods><methods><class-id>WebServices.Relation</class-id> <category>accessing</category><body package="XMLObjectMarshalers">getSelector	^getSelector</body><body package="XMLObjectMarshalers">maxOccurs	^maxOccurs</body><body package="XMLObjectMarshalers">minOccurs	^minOccurs</body><body package="XMLObjectMarshalers">name	^name</body><body package="XMLObjectMarshalers">setSelector	^setSelector</body></methods><methods><class-id>WebServices.Relation</class-id> <category>testing</category><body package="XMLObjectMarshalers">finish</body><body package="XMLObjectMarshalers">isMandatory	^minOccurs &gt; 0</body><body package="XMLObjectMarshalers">isManyRelation	^false</body><body package="XMLObjectMarshalers">isOneRelation	^false</body><body package="XMLObjectMarshalers">requiredOneNode	^self isMandatory and: [self isOneRelation]</body></methods><methods><class-id>WebServices.Relation</class-id> <category>initialization</category><body package="XMLObjectMarshalers">getSelector: aValue	getSelector := aValue</body><body package="XMLObjectMarshalers">maxOccurs: aValue	maxOccurs := aValue</body><body package="XMLObjectMarshalers">minOccurs: aValue	minOccurs := aValue</body><body package="XMLObjectMarshalers">name: aString	name := aString.	name notNil		ifTrue: 			[getSelector isNil ifTrue: [getSelector := name asSymbol].			setSelector isNil ifTrue: [setSelector := (name, ':') asSymbol]].</body><body package="XMLObjectMarshalers">setAttributes: attributesx from: aBuilder	| nm sel |	(nm := aBuilder findValue: 'aspect' in: attributesx) isNil		 ifTrue: [(nm := aBuilder findValue: 'tag' in: attributesx) isNil					ifTrue: [(nm := aBuilder findValue: 'name' in: attributesx) isNil							ifTrue: [nm := aBuilder findValue: 'ref' in: attributesx ]]].	nm notNil ifTrue: [self name: nm asSymbol].	sel := aBuilder findValue: 'getSelector'   in: attributesx.	sel notNil ifTrue: [self getSelector: sel asSymbol].	sel := aBuilder findValue: 'setSelector'   in: attributesx.	sel notNil ifTrue: [self setSelector: sel asSymbol].</body><body package="XMLObjectMarshalers">setSelector: aValue	setSelector := aValue</body></methods><methods><class-id>WebServices.Relation</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number</body><body package="XMLObjectMarshalers">printOn: aStream	aStream nextPutAll: self class name.	name isNil not		ifTrue: [aStream nextPutAll: ' name='; nextPutAll: name].</body></methods><methods><class-id>WebServices.Relation</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock	aBlock value: self</body><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anObject	aBlock value: self</body></methods><methods><class-id>WebServices.Relation</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">collectNodesFrom: marshalingContext do: acceptBlock	^self subclassResponsibility</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext relationMarshaler: aMarshaler do: aBlock	self subclassResponsibility</body></methods><methods><class-id>WebServices.Relation</class-id> <category>converting</category><body package="XMLObjectMarshalers">newRelationFrom: aRelation	| rel |	rel := ((aRelation maxOccurs &lt; 0 or: [aRelation maxOccurs &gt; 1]) 			ifTrue: [ManyRelation] 			ifFalse: [OneRelation]).	^rel new		name: self name;		getSelector: self getSelector;		setSelector: self setSelector;		minOccurs: aRelation maxOccurs;		maxOccurs: aRelation maxOccurs;		yourself</body></methods><methods><class-id>WebServices.Relation</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">registerWith: xmlObjectBinding</body></methods><methods><class-id>WebServices.Relation</class-id> <category>tools</category><body package="XMLObjectMarshalers">xmlMaxOccurs	self maxOccurs ifNil: [ ^nil].	^self maxOccurs = -1 		ifTrue: ['unbounded']		ifFalse: [ self maxOccurs = 1 ifTrue: [ nil] ifFalse: [ self maxOccurs printString ]]</body><body package="XMLObjectMarshalers">xmlMinOccurs	^(self minOccurs = 1 or: [self minOccurs isNil])		ifTrue: [nil]		ifFalse: [ self minOccurs printString ]</body></methods><methods><class-id>WebServices.Relation</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalFrom: marshalingContext do: aBlock	^self subclassResponsibility</body></methods><methods><class-id>WebServices.Relation class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">from: anotherRelation	^self new		name: anotherRelation name;		getSelector: anotherRelation getSelector;		setSelector: anotherRelation setSelector;		minOccurs: anotherRelation minOccurs;		maxOccurs: anotherRelation maxOccurs;		yourself</body><body package="XMLObjectMarshalers">fromAttributes: attributesx from: marshaler	| minOccurs maxOccurs  |	" Determine cardinality "	minOccurs := self minOccursFromAttributes: attributesx from: marshaler.	maxOccurs := self maxOccursFromAttributes: attributesx from: marshaler.	^((maxOccurs &lt; 0 or: [maxOccurs &gt; 1]) 		ifTrue: [ManyRelation] 		ifFalse: [OneRelation]) 			new			minOccurs: minOccurs;			maxOccurs: maxOccurs;			setAttributes: attributesx from: marshaler;			yourself</body><body package="XMLObjectMarshalers">maxOccursFromAttributes: attributesx from: marshaler	| v |	^(v := marshaler findValue: 'maxOccurs' in: attributesx) ~~ nil		ifTrue: 			[( v = '*' or: [ v = 'unbounded'])				ifTrue: [ -1 ]				ifFalse: [ v asNumber ]]		ifFalse: [1].</body><body package="XMLObjectMarshalers">minOccursFromAttributes: attributesx from: marshaler	" Determine cardinality "	"for element"	^(self minOccursValueFrom: attributesx marshaler: marshaler) 		ifNotNil: [ :minOccurs | minOccurs ]		ifNil: [1 ]</body><body package="XMLObjectMarshalers">minOccursValueFrom: attributesx marshaler: marshaler	| v |	^(v := marshaler findValue: 'minOccurs' in: attributesx)  notNil		ifTrue: [ v asNumber]		ifFalse: [nil].</body></methods><methods><class-id>WebServices.ManyRelation</class-id> <category>accessing</category><body package="XMLObjectMarshalers">unbounded	maxOccurs := -1</body></methods><methods><class-id>WebServices.ManyRelation</class-id> <category>testing</category><body package="XMLObjectMarshalers">isManyRelation	^true</body></methods><methods><class-id>WebServices.ManyRelation</class-id> <category>initialization</category><body package="XMLObjectMarshalers">collectionClass	^collectionClass</body><body package="XMLObjectMarshalers">collectionClass: aValue	collectionClass := aValue</body><body package="XMLObjectMarshalers">initialize	collectionClass := OrderedCollection</body><body package="XMLObjectMarshalers">setAttributes: attributesx from: aBuilder	super setAttributes: attributesx from: aBuilder.	self setCollectionClassFrom: attributesx builder: aBuilder</body><body package="XMLObjectMarshalers">setCollectionClassFrom: attributesx builder: aBuilder	| cl class |	(cl := aBuilder findValue:  'smalltalkClass' in: attributesx) notNil		ifTrue: 			[class := cl asSymbol asQualifiedReference 				valueOrDo: [(ClassIsNotDefinedSignal new)							messageText: (#SmalltalkClassIsNotDefined &lt;&lt; #webservices &gt;&gt; 'Smalltalk class &lt;1s&gt; is not defined' expandMacrosWith: cl );							raiseRequest].			(class inheritsFrom: Collection) 				ifFalse: [WrongObjectType new							messageText: (#WrongObjectTypeForCollection &lt;&lt; #webservices &gt;&gt; 'Wrong type for collection: &lt;1s&gt;.' expandMacrosWith: class name );							raiseRequest].			self collectionClass: class ].</body></methods><methods><class-id>WebServices.ManyRelation</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">collectNodesFrom: marshalingContext do: aBlock	| myNodes |	myNodes := OrderedCollection new.	[ marshalingContext node notNil and: [aBlock value: marshalingContext node ] ]		whileTrue: [ myNodes add: marshalingContext node.					marshalingContext nodes removeFirst. ].	^myNodes</body><body package="XMLObjectMarshalers">createInstance	^collectionClass new</body><body package="XMLObjectMarshalers">createInstanceFor: marshalingContext" Answer properly sized collection. If a collection is a sequenceable collection and element order is important, it has to be initialized with withSize: so it has all element slots and can be populated with at:put:. The reasoning is that elements of the collection may not be readily resolvable, so in callback we should have all the information about the collection and particular slot in the collection " 	^[collectionClass withSize: marshalingContext nodes size]		on: Error		do: [ :ex | ex return: (collectionClass new: marshalingContext nodes size)]</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext relationMarshaler: aMarshaler do: aBlock	marshalingContext value:  (self createInstanceFor: marshalingContext).	aMarshaler 		unmarshalCollectionFrom: marshalingContext 		do: aBlock.</body></methods><methods><class-id>WebServices.ManyRelation</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">handleNilValueFor: marshalingContext nillable: isNillable	isNillable		ifFalse: [ MissingValueSignal new					errorString: ((#ThereIsNilValueInCollection &lt;&lt; #webservices &gt;&gt; 'There is nil value in the collection at: &lt;1s&gt;. The item is described as nillable=false') expandMacrosWith: self name asSymbol printString); 					parameter: marshalingContext parent value;					raiseSignal]</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext do: aBlock	| coll |	(coll := marshalingContext value) ifNil: 		[ ^MissingValueSignal new			errorString: ((#ExpectedInstanceOf1sReceivedNil &lt;&lt; #webservices &gt;&gt; 'Expected instance of: &lt;1s&gt;  at: &lt;2s&gt;. Received nil.') expandMacrosWith: collectionClass name asString with: self setSelector); 			parameter: marshalingContext parent value;			raiseSignal.].	((self class useExactCollectionType and: [coll class ~= collectionClass])		or: [(coll isKindOf: Collection) not])		ifTrue: [self wrongObjectExc: coll].	(coll isEmpty and: [self isMandatory])		ifTrue: [^MissingValueNotification new			errorString: ((#ExpectedNotEmptyCollectionAt1s &lt;&lt; #webservices &gt;&gt; 'Expected not empty collection at: &lt;1s&gt;') expandMacrosWith: self setSelector); 			parameter: self getSelector asSymbol;			raiseSignal.].	coll do: [ :val | aBlock value: val ]</body><body package="XMLObjectMarshalers">wrongObjectExc: coll	WrongObjectType new				messageText: (#WrongObjectTypeForAspect &lt;&lt; #webservices &gt;&gt; 'Wrong type for aspect: &lt;1s&gt;. Expected: &lt;2s&gt;. Received: &lt;3s&gt;' expandMacrosWith: self name with: collectionClass name with: coll class name );				parameter: coll;				raiseRequest</body></methods><methods><class-id>WebServices.ManyRelation</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	stream nextPutAll: collectionClass name asString,  ' with: '</body></methods><methods><class-id>WebServices.ManyRelation class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">from: anotherRelation	| inst |	inst := super from: anotherRelation.	inst maxOccurs &lt;= 1 ifTrue: [inst unbounded].	^inst</body><body package="XMLObjectMarshalers">maxOccursFromAttributes: attributesx from: marshaler	| v |	^(v := marshaler findValue: 'maxOccurs' in: attributesx) ~~ nil		ifTrue: 			[( v = '*' or: [ v = 'unbounded'])				ifTrue: [ -1 ]				ifFalse: [ v asNumber ]]		ifFalse: [-1].</body><body package="XMLObjectMarshalers">new	^super new initialize</body></methods><methods><class-id>WebServices.ManyRelation class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">useExactCollectionType	^useExactCollectionType ifNil: [ useExactCollectionType := self useExactCollectionTypeValue ].</body><body package="XMLObjectMarshalers">useExactCollectionType: aBoolean	useExactCollectionType := aBoolean</body><body package="XMLObjectMarshalers">useExactCollectionTypeValue	^true</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	stream nextPutAll: 'union of types: '.	self marshalers do: [ :marshaler |		stream				nextPut: $" ;			nextPutAll: marshaler smalltalkClassName; 			nextPut: $"]		separatedBy: [ stream nextPutAll: ' / '].</body><body package="XMLObjectMarshalers">printOn: aStream	aStream nextPutAll: 'Union of: '.	marshalers do: [ :each | each printOn: aStream. aStream nextPutAll: ' / '].</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">marshalers	^marshalers</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	marshalers := OrderedCollection new.</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isResolved	^(marshalers detect: [ :each | each isResolved not] ifNone: [nil])  isNil</body><body package="XMLObjectMarshalers">isUnionType	^true</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	super postCopy.	marshalers := OrderedCollection new</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext	| val |	marshalers do: [ :marshaler |		[	marshaler validateValue: marshalingContext value.			val := ( marshaler serializationBlock value: marshalingContext value: marshaler smalltalkClass).			marshalingContext source isElement ifTrue: [ 				marshaler setInlineTypeFor: marshalingContext source marshalingContext: marshalingContext].			^marshalingContext value:  val 		] on: Error do: [ :ex | ex return: nil ]].	self error: (#CannotFindMarshalerForUnionType &lt;&lt; #webservices &gt;&gt; 'Can not find marshaler for union type' ).</body><body package="XMLObjectMarshalers">setInlineTypeFor: anElement marshalingContext: aMarshalingContext</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">add: marshaler	marshalers add: marshaler</body><body package="XMLObjectMarshalers">finish	memberTypeMarshalers ifNotNil: [marshalers addAllFirst: memberTypeMarshalers].	marshalers do: [ :each | each resolveFromBaseType].	marshalers do: [ :each | each finish ].</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder" Set any attributes we are interested in "	super setLocalAttributesFrom: attributesx in: builder.	(self findDomainValue: 'memberTypes' in: attributesx) 		ifNotNil: [ :memberTypes | 			memberTypeMarshalers :=  memberTypes tokensBasedOn: Character space.			memberTypeMarshalers	keysAndValuesDo: [ :ind :qname | 					builder 				 		resolveType: qname 						do: 	[ :resolved | memberTypeMarshalers at: ind put: resolved  ]]]</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oContents	^'union'</body><body package="XMLObjectMarshalers">xmlContents	^'union'</body><body package="XMLObjectMarshalers">xmlMemberTypes	memberTypeMarshalers ifNil: [^nil].	^memberTypeMarshalers collect: [ :each | each tag ]</body><body package="XMLObjectMarshalers">xmlSimpleMarshalers	marshalers isEmpty ifTrue: [^nil ].	^memberTypeMarshalers		ifNil: [ marshalers ]		ifNotNil: [ marshalers reject: [:each | memberTypeMarshalers  includes: each]].</body><body package="XMLObjectMarshalers">xmlUnion	| typeMarshalers struct |	typeMarshalers := self xmlSimpleMarshalers ifNil: [^nil].	struct := Struct new.	typeMarshalers notEmpty ifTrue: [ struct at: #simpleTypes put: typeMarshalers ].	memberTypeMarshalers ifNotNil: [ struct at: #memberTypes put: self xmlMemberTypes ].	^struct</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>tool</category><body package="XMLObjectMarshalers">selectorType	| stream |	stream := String new writeStream.	stream  nextPut: $a.	marshalers 		do: [ :each | stream nextPutAll: (each smalltalkClassName tokensBasedOn: $.) last ]		separatedBy: [ stream nextPutAll: 'Or'].	^stream contents</body></methods><methods><class-id>WebServices.UnionMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">unmarshal: aNodeTag from: marshalingContext do: aBlock	| val marshaler | 	marshaler :=  marshalers 		detect: [ :each | each tag = aNodeTag ] 		ifNone: [self error: ((#ThereIsNoMarshalerForInlineType1s &lt;&lt; #webservices &gt;&gt; 'There is no marshaler defined for inline type: &lt;1s&gt; ') expandMacrosWith: aNodeTag printString)].	val := marshaler deserializationBlock value: marshalingContext  value: marshalingContext node characterData  value: marshaler smalltalkClass.	marshaler validateValue: val.	marshalingContext value:  val.	aBlock value: marshalingContext</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	| val node  |	(node := marshalingContext node) ifNil: [node := MissingValueNotification raiseWith: self tag type printString]. 	" find xsi:type if any, use it first  "	(marshalingContext manager elementTypeFrom: node attributeKey: 'type' ns: XMLObjectBinding defaultUriSchemaInstance)		ifNotNil: [ :aNodeTag | ^self unmarshal: aNodeTag from: marshalingContext do: aBlock].	marshalers do: [ :each |		[val := ( each deserializationBlock value: marshalingContext  value: node characterData  value: each smalltalkClass).			[each validateValue: val.			marshalingContext value:  val.			^aBlock value: marshalingContext.			] on: ValidationNotification do: [ :ex | ex return: nil ].		] on: Error do: [ :ex | ex return: nil ] ].	self error: ((#CannotUnmarshalUnionType &lt;&lt; #webservices &gt;&gt; 'Can not unmarshal union type &lt;1s&gt;' ) expandMacrosWith: node printString ).</body></methods><methods><class-id>WebServices.TaggedObject</class-id> <category>testing</category><body package="XMLObjectMarshalers">isTaggedObject	^true</body><body package="XMLObjectMarshalers">isXMLElement	^(value isKindOf: Element)</body></methods><methods><class-id>WebServices.TaggedObject</class-id> <category>accessing</category><body package="XMLObjectMarshalers">namespace	^namespace</body><body package="XMLObjectMarshalers">nodeTag	^type 		ifNotNil: [ NodeTag qualifier: '' ns: namespace type: type]		ifNil: [ self isXMLElement ifTrue: [value tag] ifFalse: [nil]]</body><body package="XMLObjectMarshalers">type	^type</body><body package="XMLObjectMarshalers">value	^value</body></methods><methods><class-id>WebServices.TaggedObject</class-id> <category>initialize-release</category><body package="XMLObjectMarshalers">element: xmlElement		value := xmlElement</body><body package="XMLObjectMarshalers">ns: namespaceString type: aString value: anObject		namespace := namespaceString.	type := aString.	value := anObject</body></methods><methods><class-id>WebServices.TaggedObject</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream		aStream nextPutAll: 'TaggedObject on: '.	value ifNotNil: [ value printOn: aStream ]</body></methods><methods><class-id>WebServices.TaggedObject class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">element: xmlElement	^self new		element: xmlElement;		yourself</body><body package="XMLObjectMarshalers">ns: namespaceString type: aString value: anObject	^self new		ns: namespaceString type: aString value: anObject;		yourself</body><body package="XMLObjectMarshalers">type: aString value: anObject	^self new		ns: '' type: aString value: anObject;		yourself</body></methods><methods><class-id>WebServices.TextMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isText	^true</body></methods><methods><class-id>WebServices.TextMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">acceptNodesAndUnmarshal: marshalingContext do: aBlock	self decodeAndUnmarshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">decodeAndUnmarshalFrom: marshalingContext do: aBlock"Use xpath to select Text nodes from marshaling context source "	| child |	(child := marshalingContext newChildFor: self)		aspect: marshalingContext aspect;		nodeContext: (self getSourceFrom: marshalingContext).	child  nodeContext isEmpty		ifTrue: [^MissingValueNotification raiseWith: self tag type printString]. 	marshaler unmarshalFrom: child do: aBlock</body></methods><methods><class-id>WebServices.TextMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	xpath xpathSuffix: 'child::text()'.</body></methods><methods><class-id>WebServices.TextMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlMaxOccurs	^nil</body><body package="XMLObjectMarshalers">xmlMinOccurs	^nil</body></methods><methods><class-id>WebServices.TextMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">simpleContentBaseType	^marshaler simpleContentBaseType</body></methods><methods><class-id>WebServices.OneRelation</class-id> <category>testing</category><body package="XMLObjectMarshalers">isOneRelation	^true</body></methods><methods><class-id>WebServices.OneRelation</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">collectNodesFrom: marshalingContext do: acceptBlock	| myNodes |	myNodes := OrderedCollection new.	(marshalingContext node notNil and: [acceptBlock value: marshalingContext node ])		ifTrue: [ myNodes add: marshalingContext node.					marshalingContext nodes removeFirst. ].	^myNodes</body><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext relationMarshaler: aMarshaler do: aBlock	aMarshaler unmarshalObjectFrom: marshalingContext  do: aBlock</body></methods><methods><class-id>WebServices.OneRelation</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">handleNilValueFor: marshalingContext nillable: isNillable	isNillable ifFalse: [ MissingValueNotification raiseWith: self  getSelector printString ]</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext do: aBlock	(marshalingContext value isNil and: [self isMandatory not]) 		ifTrue: [^MissingValueNotification raiseWith: self getSelector printString].	aBlock value: marshalingContext value</body></methods><methods><class-id>WebServices.AnyCollectionMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">setRelationFrom: attributesx in: builder	relation := ManyRelation fromAttributes:  attributesx from: self.</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>initialization</category><body package="XMLObjectMarshalers">reset	xpathPrefix := nil.	xpathSuffix := nil.	xpathNode := nil.	xpathExpression := nil.</body><body package="XMLObjectMarshalers">xpathExpression: aValue	xpathExpression := aValue</body><body package="XMLObjectMarshalers">xpathNode: aValue	xpathNode := aValue</body><body package="XMLObjectMarshalers">xpathPrefix: aValue	xpathPrefix := aValue</body><body package="XMLObjectMarshalers">xpathSuffix: aValue	xpathSuffix := aValue</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>accessing</category><body package="XMLObjectMarshalers">namespaceFilter	^namespaceFilter</body><body package="XMLObjectMarshalers">parent	^parent</body><body package="XMLObjectMarshalers">requiredAttributes	requiredAttributes isNil		ifTrue: [ requiredAttributes := Dictionary new: 5].	^requiredAttributes</body><body package="XMLObjectMarshalers">xpathPrefix	^xpathPrefix</body><body package="XMLObjectMarshalers">xpathSuffix	^xpathSuffix</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>private</category><body package="XMLObjectMarshalers">xpathExpression	^xpathExpression</body><body package="XMLObjectMarshalers">xpathNode	^xpathNode</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream	xpathNode notNil		ifTrue: 			[aStream space.			xpathNode printOn: aStream]		ifFalse:			[xpathExpression  notNil				ifTrue: 					[aStream 						nextPutAll: ' xpath=';						nextPutAll: xpathExpression]].</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">buildFrom: aNodeTag for: aMarshaler	parent := aMarshaler.	allNamespaces := namespaces := 					(Dictionary new: 10) 						at: aNodeTag qualifier put: aNodeTag namespace;						yourself.	xpathExpression := 'child::', aNodeTag name.	self setXPathNode.</body><body package="XMLObjectMarshalers">buildFrom: aNodeTag xpath: anXPathString for: aMarshaler	parent := aMarshaler.	allNamespaces := namespaces := 					(Dictionary new: 10) 						at: aNodeTag qualifier put: aNodeTag namespace;						yourself.	xpathExpression := anXPathString.	self setXPathNode.</body><body package="XMLObjectMarshalers">finish</body><body package="XMLObjectMarshalers">registerWith: xmlObjectBinding</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder for: aMarshaler	parent := aMarshaler. 	namespaces := builder namespaceMap.	allNamespaces := builder allNamespaces.	(aMarshaler findValue: 'namespace' in: attributesx) ifNotNil: [ :filter | namespaceFilter := filter asSymbol].	(aMarshaler findValue:  'xpathPrefix'  in: attributesx) ifNotNil: [ :val | xpathPrefix := val ].	(aMarshaler findValue: 'xpathSuffix'  in: attributesx) ifNotNil: [ :val | xpathSuffix := val ].	xpathSuffix ~= 'child::text()'		ifTrue: [(aMarshaler findValue: 'xpath'  in: attributesx) 				ifNotNil: [ :val | xpathExpression := val ]				ifNil: [aMarshaler tag ifNotNil: [xpathExpression := aMarshaler tag asString ]]].	self 		setXPathNode;		setQualifier</body><body package="XMLObjectMarshalers">setQualifier	(self parent tag isNil or: [ self parent tag qualifier isEmpty]) ifTrue: [^nil].	(self parent qualified and: [xpathNode notNil])		ifTrue: [xpathNode resetQualifier: self parent tag qualifier].</body><body package="XMLObjectMarshalers">setXPathNode	| expr nodeTag ns |	(expr := xpathExpression) ifNil: [ expr := ''].	xpathPrefix ifNotNil: [expr := xpathPrefix, expr].	xpathSuffix ifNotNil: [expr := expr, xpathSuffix].	expr = '' ifTrue: [expr := '*'].	ns := (parent isKindOf: AnyRelationMarshaler) 		ifTrue: [Dictionary new: 5]		ifFalse: [allNamespaces].	XML.Document new addNode: (nodeTag := Element tag: parent tag).	nodeTag namespaces: ns.	xpathNode := XPathParser new 		xmlNode: nodeTag;		parse: expr as: #locationPath.</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock	aBlock value: self</body><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	(anIdentitySet includes: self) ifTrue: [^self].	anIdentitySet add: self.	aBlock value: self</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshalFrom: marshalingContext do: aBlock" If there is any data that should be used by XPath, it is set as value of marshaling context. XPath can use parent information to properly link node to its parent. At the end of the operation, nodeContext contains a collection of nodes and source contains a single node that would produce nodes as a result of XPath expresssion"	^xpathNode marshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">setNodeAndMarshalFrom: marshalingContext do: aBlock" If there is any data that should be used by XPath, it is set as value of marshaling context. XPath can use parent information to properly link node to its parent. At the end of the operation, nodeContext contains a collection of nodes and source contains a single node that would produce nodes as a result of XPath expression"	marshalingContext tag ifNil: [marshalingContext tag: parent tag]. 	^xpathNode setNodeAndMarshalFrom: marshalingContext do: aBlock</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">getSourceFrom: marshalingContext	^xpathNode 		wsSelect: (xpathNode xpathValueFor: marshalingContext source variables: nil) sortedNodes 		for: namespaceFilter</body></methods><methods><class-id>WebServices.XMLMarshalerProxy</class-id> <category>testing</category><body package="XMLObjectMarshalers">isAttribute	^self xpathNode isAttribute</body><body package="XMLObjectMarshalers">isElement	^self isAttribute not</body><body package="XMLObjectMarshalers">isText" text()" 	^self xpathNode baseTest isTextType</body></methods><methods><class-id>WebServices.XMLMarshalerProxy class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">marshaler: anXMLTypeMarshaler	^self new		marshaler: anXMLTypeMarshaler;		yourself</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">newProxyFor: aString		self restrictionType: aString</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">enumerationRestrictions	self isEnumeration ifFalse: [ ^OrderedCollection new ].	^value collect: [ :val |		RestrictionMarshaler new 			parent: self parent;			restrictionType: self restrictionType;			value: val;			yourself].</body><body package="XMLObjectMarshalers">fixed	^fixed</body><body package="XMLObjectMarshalers">fixed: aString	^fixed := aString</body><body package="XMLObjectMarshalers">id	^id</body><body package="XMLObjectMarshalers">id: aString	id := aString</body><body package="XMLObjectMarshalers">parent	^parent</body><body package="XMLObjectMarshalers">parent: aSimpleObjectMarshaler	parent := aSimpleObjectMarshaler</body><body package="XMLObjectMarshalers">restrictionType	^restrictionType</body><body package="XMLObjectMarshalers">restrictionType: aString	restrictionType := aString</body><body package="XMLObjectMarshalers">value	^value</body><body package="XMLObjectMarshalers">value: anObject	value := anObject</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addEnumValue: aValue	value detect: [ :v | v = aValue ] ifNone: [value add: aValue]</body><body package="XMLObjectMarshalers">finish	(self params at: 'unresolved' ifAbsent: [nil]) ifNotNil: [ :val |		value := self resolveValue: val.		self params removeKey: 'unresolved']</body><body package="XMLObjectMarshalers">resolveValue: aNodeTag	| string |	^(parent conversionId = 'ncname' or: [parent conversionId = 'qname'])		ifTrue: [aNodeTag namespace ifNil:				[self error: ((#UnexpectedQualifierInNode &lt;&lt; #webservices &gt;&gt; 'Unexpected qualifier in &lt;1s&gt;') expandMacrosWith: aNodeTag)].				aNodeTag]		ifFalse: [ string := aNodeTag qualifier isEmpty					ifTrue: [ aNodeTag type]					ifFalse: [aNodeTag qualifier, ':', aNodeTag type ].			parent deserializationBlock value: MarshalingContext new  value: string value: parent smalltalkClass ]</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder 	(parent := builder current) ifNil: [ ^nil ].	(self findDomainValue: 'value' in: attributesx) 		ifNotNil: [ :val |  self setValue: val builder:  builder ]		ifNil: [ self error: (#MissedRestrictionValue &lt;&lt; #webservices &gt;&gt; 'Missed restriction value ')].	(self findDomainValue: 'fixed' in: attributesx) ifNotNil: [ :val |  fixed := val ].	(self findDomainValue: 'id' in: attributesx) ifNotNil: [ :val |  id := val ].	parent addRestriction: self.</body><body package="XMLObjectMarshalers">setValue: aString builder: builder		| val |	self isAnyType		ifTrue: [ val := builder tagForName: aString.				parent conversionId 						ifNil: [ self params at: 'unresolved' put: val ]						ifNotNil: [value := self resolveValue: val ].			^value].	self isIntegerType ifTrue: [^value := Number readFrom: aString readStream].	value := aString</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>comparing</category><body package="XMLObjectMarshalers">= aRestrictionMarshaler	^ super = aRestrictionMarshaler		and: [self restrictionType = aRestrictionMarshaler restrictionType		and: [ self value = aRestrictionMarshaler value ]]</body><body package="XMLObjectMarshalers">hash"	If two objects are equal, they have to have same hash.	Since equality includes testing for restrictionType, it must be considered in hash as well."	^(super hash bitXor: self value hash) bitXor: self restrictionType hash</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>validation</category><body package="XMLObjectMarshalers">validateEnumeration: aValue	"Answer whether the given value is equal to one of the enum alternatives defined in this restriction."	^value includes: aValue</body><body package="XMLObjectMarshalers">validateFractionDigits: aNumber	"Answer whether the given value satisfies the fraction digits limit defined in this restriction."	| xmlValue decimalPoint fractionDigits |	xmlValue := self parent serializationBlock				value: (MarshalingContext new value: aNumber)				value: self parent smalltalkClass.	decimalPoint := xmlValue indexOf: $. ifAbsent: [^true].	fractionDigits := xmlValue size - decimalPoint.	^fractionDigits &lt;= value</body><body package="XMLObjectMarshalers">validateLength: aString	"Answer whether the given value has exactly the size defined in this restriction."	^aString size = value</body><body package="XMLObjectMarshalers">validateMaxExclusive: aNumber	"Answer whether the given value is less than defined in this restriction."	^aNumber &lt; value</body><body package="XMLObjectMarshalers">validateMaxInclusive: aNumber	"Answer whether the given value is less or equal to the limit defined in this restriction."	^aNumber &lt;= value</body><body package="XMLObjectMarshalers">validateMaxLength: aString	"Answer whether the given value size is less or equal to the size defined in this restriction."	^aString size &lt;= value</body><body package="XMLObjectMarshalers">validateMinExclusive: aNumber	"Answer whether the given value is greater than defined in this restriction."	^aNumber &gt; value</body><body package="XMLObjectMarshalers">validateMinInclusive: aNumber	"Answer whether the given value is greater or equal to the limit defined in this restriction."	^aNumber &gt;= value</body><body package="XMLObjectMarshalers">validateMinLength: aString	"Answer whether the given value size is greater or equal to the size defined in this restriction."	^aString size &gt;= value</body><body package="XMLObjectMarshalers">validatePattern: aString	"Answer whether the given value satisfies the pattern defined in this restriction."	#{RxParser} isDefined		ifFalse: [^RequiresRegex raiseRequestWith: (#MustLoadRegex &lt;&lt; #webservices &gt;&gt; 'Must load Regex to do pattern verification')].	^aString matchesRegex: value</body><body package="XMLObjectMarshalers">validateTotalDigits: aNumber	"Answer whether the given value satisfies the total digits condition defined in this restriction."	| xmlValue totalDigits |	xmlValue := self parent serializationBlock				value: (MarshalingContext new value: aNumber)				value: self parent smalltalkClass.	totalDigits := xmlValue size.	('+-' includes: xmlValue first) ifTrue: [totalDigits := totalDigits - 1].	(xmlValue includes: $.) ifTrue: [totalDigits := totalDigits - 1].	^totalDigits &lt;= value</body><body package="XMLObjectMarshalers">validateValue: aValue	"Check whether the given value satisfies this restriction. Answer true/false."	| selector |	selector := self class restrictions at: self restrictionType ifAbsent: [^true].	^self perform: selector with: aValue</body><body package="XMLObjectMarshalers">validateWhiteSpace: aString	"Answer whether the given value satisfies the white space constraints defined in this restriction."	| whitespace xmlValue |	value = 'preserve' ifTrue: [^true].	xmlValue := self parent serializationBlock				value: (MarshalingContext new value: aString)				value: self parent smalltalkClass.	" 'replace' and 'collapse' require replacement of tab, lf, cr with space"	whitespace := String with: Character tab with: Character lf with: Character cr.	^(whitespace allSatisfy: [:char | (xmlValue includes: char) not])		and: [value = 'replace'			or: ["no leading, trailing, double spaces"				(xmlValue findString: '  ' startingAt: 1) isZero					and: [xmlValue trimBlanks size = xmlValue size]]]</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isAnyType		^#( #enumeration #maxExclusive #maxInclusive #minExclusive #minInclusive ) includes: self restrictionType asSymbol</body><body package="XMLObjectMarshalers">isEnumeration		^self restrictionType = 'enumeration'</body><body package="XMLObjectMarshalers">isIntegerType		^#(#fractionDigits #length #maxLength #minLength #totalDigits) includes: self restrictionType asSymbol</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: aStream indentation: number	aStream nextPutAll: ' ', self restrictionType, ':'.	self isEnumeration		ifTrue: [ | digest |			digest := value copyFrom: 1 to: ( value size min: 5). 			digest				do: [ :val | val printOn: aStream ]				separatedBy: [ aStream nextPutAll: ' '].			digest size &lt; value size ifTrue: [aStream nextPutAll: '...'] ]		ifFalse: [ value printOn: aStream ]</body><body package="XMLObjectMarshalers">printOn: aStream	aStream nextPutAll: self class name.	restrictionType ifNotNil: [ aStream space; nextPutAll: restrictionType  ].	value ifNotNil: [ 		aStream space. 		value printOn: aStream  ].</body></methods><methods><class-id>WebServices.RestrictionMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlSelector	^( 'xml', restrictionType first asSymbol asUppercase, (restrictionType copyFrom: 2 to: restrictionType size)) asSymbol.</body><body package="XMLObjectMarshalers">xmlValue		self isAnyType		ifTrue: [	^(parent conversionId = 'ncname' or: [ parent conversionId = 'qname'] ) 					ifTrue: [ self value ] 					ifFalse: [parent serializationBlock value: (MarshalingContext new  value: self value; yourself)  value: parent smalltalkClass ]].	self isIntegerType ifTrue: [^self value printString].	^self value</body></methods><methods><class-id>WebServices.RestrictionMarshaler class</class-id> <category>constants</category><body package="XMLObjectMarshalers">initializeRestrictions	"Answer the XML attribute names of allowed simple type restrictions."		Restrictions := Dictionary new.	Restrictions 		at: 'enumeration' put: #validateEnumeration:;		at: 'length' put: #validateLength:;		at: 'minLength' put: #validateMinLength:;		at: 'maxLength' put: #validateMaxLength:;		at: 'pattern' put: #validatePattern:;		at: 'whiteSpace' put: #validateWhiteSpace:;		at: 'minInclusive' put: #validateMinInclusive:;		at: 'minExclusive' put: #validateMinExclusive:;		at: 'maxInclusive' put: #validateMaxInclusive:;		at: 'maxExclusive' put: #validateMaxExclusive:;		at: 'totalDigits' put: #validateTotalDigits:;		at: 'fractionDigits' put: #validateFractionDigits:.	^Restrictions</body><body package="XMLObjectMarshalers">restrictions	"Answer the XML attribute names of allowed simple type restrictions."		^Restrictions ifNil: [ self initializeRestrictions ].</body></methods><methods><class-id>WebServices.BindingImport</class-id> <category>accessing</category><body package="XMLObjectMarshalers">asBindingImport	^self</body><body package="XMLObjectMarshalers">binding	^self namespace ifNotNil: [ WebServices.XMLObjectBinding bindingAtNamespace: self namespace].</body><body package="XMLObjectMarshalers">location	^location</body><body package="XMLObjectMarshalers">location: aValue	location := aValue</body><body package="XMLObjectMarshalers">marshalers	^#()</body><body package="XMLObjectMarshalers">name	^self binding ifNil: [ NodeTag qualifier: '' ns: '' type: '' ] ifNotNil: [ :b | b name]</body><body package="XMLObjectMarshalers">name: aValue	name := aValue</body><body package="XMLObjectMarshalers">namespace	^namespace</body><body package="XMLObjectMarshalers">namespace: aValue	namespace := aValue</body><body package="XMLObjectMarshalers">targetNamespace	^self binding ifNil: [''] ifNotNil: [ :b | b targetNamespace]</body><body package="XMLObjectMarshalers">xmlDocumentation	^nil</body></methods><methods><class-id>WebServices.BindingImport</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream		self binding 		ifNotNil: [ :b | b printOn: aStream]		ifNil: [super printOn: aStream]</body></methods><methods><class-id>WebServices.BindingImport</class-id> <category>error handling</category><body package="XMLObjectMarshalers">doesNotUnderstand: aMessage	self binding ifNil: [^nil].	"Replace all references to me with references to the binding"	self oneWayBecome: self binding.	^self perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>WebServices.BindingImport</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addTo: aParent" Add import binding to my parent.  "	aParent importBinding: self.	aParent imports add: self copy</body><body package="XMLObjectMarshalers">setAttributesFrom: attributesx in: builder	name := self findValue: 'name' in: attributesx.	namespace := self findValue: 'namespace' in: attributesx.	location := self findValue: 'schemaLocation' in: attributesx.	builder register: self</body></methods><methods><class-id>WebServices.UnorderedMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	self marshalers do: [ :relMarshaler | 		marshalingContext newChild			source: marshalingContext source;			marshaler: relMarshaler;			decodeAndUnmarshal: aBlock ].</body></methods><methods><class-id>WebServices.UnorderedMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addElementMarshaler: relationMarshaler	relationMarshaler isRelationMarshaler		ifFalse: [ self error: ( #WrongTypeOfElementMarshaler &lt;&lt; #webservices &gt;&gt; 'Wrong type of the element marshaler: &lt;1s&gt;. Expected RelationMarshaler' expandMacrosWith: relationMarshaler printString )].	super addElementMarshaler: relationMarshaler</body></methods><methods><class-id>WebServices.UnorderedMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">complexTypeContentAspect	^#xmlAll</body><body package="XMLObjectMarshalers">xmlContentAspect	^#xmlAll</body></methods><methods><class-id>WebServices.ImplicitMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">x2oLocalContents	^nil</body><body package="XMLObjectMarshalers">x2oType	^self xmlRef</body><body package="XMLObjectMarshalers">xmlLocalContents	^OrderedCollection new</body><body package="XMLObjectMarshalers">xmlRef	^(self findDomainValue: 'ref' in: attributes ) isNil 		ifTrue: [ nil ]		ifFalse: [ self tag ]</body><body package="XMLObjectMarshalers">xmlType	^nil</body></methods><methods><class-id>WebServices.ImplicitMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">acceptMarshaler: resolvedMarshalers"Support old type mapping: &lt;implicit name='edgemode' ref='xsd:string' /&gt;"	^resolvedMarshalers 		detect: [ :resolved | resolved isElement or: [resolved isType] ] 		ifNone: [ nil ]</body><body package="XMLObjectMarshalers">finish	super finish.	" If 'ref' attribute is not present,we resolved the marshaler by its local type and we need  inherit its path "	(xpath xpathNode isNil and: [ marshaler notNil]) ifTrue: [ xpath := marshaler xpath ]</body><body package="XMLObjectMarshalers">resolveTypeMarshalerFrom: attributesx in: builder" If 'ref' attribute is present,we resolve marshaler by its ref name and copy xpath prefix and suffix from the resolved marshaler. This way we inherit its 'bias', that is, if the resolved marshaler was looking for child nodes, we will inherit that.  The key should #element but for backward compatibility we need to check both #element and #type.&lt;xsd:element ref='Warranty' nillable='true'/&gt;This is not legal. This dynamic morphing capability (i.e., reusing a Warranty element declaration while simultaneously adding nillability) cannot be achieved using elements. The reason for this is that the ref and nillable attributes are mutually exclusive - you can use ref, or you can use nillable, but not both. "	(self findDomainValue: 'ref' in: attributesx) ifNotNil: [ :ref |		builder 			resolve: ref			do: [ :resolved | 				marshaler := self acceptMarshaler: resolved.				marshaler notNil  ifTrue: [				"2.2 If ref is present, then all of &lt;complexType&gt;, &lt;simpleType&gt;, &lt;key&gt;, &lt;keyref&gt;, &lt;unique&gt;, nillable, default, fixed, form, block and type must be absent, i.e. only minOccurs, maxOccurs, id are allowed in addition to ref, along with &lt;annotation&gt;.				Implicit marshaler inherits aspect name and selectors  from the resolved marshaler"					marshaler isElement ifTrue: [						self relation								name: marshaler relation name;							setSelector: marshaler relation setSelector;							getSelector: marshaler relation getSelector.						self 							qualified: marshaler qualified;							isGlobal: marshaler isGlobal.						(marshaler params at: #nillable ifAbsent: [nil])							ifNotNil: [ :val | self params at: #nillable put: val ]].				(self xpathPrefix isNil and: [self xpathSuffix isNil])					ifTrue: [marshaler xpathPrefix ifNotNil: [self xpathPrefix: marshaler xpathPrefix].							marshaler xpathSuffix ifNotNil: [self xpathSuffix: marshaler xpathSuffix]].				self xpathExpression: marshaler xpath xpathNode baseTest type.				self setXPathNode.].				marshaler ]].</body></methods><methods><class-id>WebServices.ImplicitMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isElement	^true</body><body package="XMLObjectMarshalers">isImplicit	^true</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>notification</category><body package="XMLObjectMarshalers">notifyNoMarshalerFor: anObject	^self notifyNoMarshalerFor: anObject text: anObject printString</body><body package="XMLObjectMarshalers">notifyNoMarshalerFor: anObject text: aString	^NoMarshalerSignal new			messageText: ((#NoMarshalerFor &lt;&lt; #webservices &gt;&gt; 'No marshaler for: &lt;1s&gt;')			expandMacrosWith: aString);			parameter: anObject;			raiseRequest</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>copying</category><body package="XMLObjectMarshalers">postCopy	super postCopy.	self initialize</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">_complete" Marshalers invoke this method when object was fully marshaled "	self finish.	self register</body><body package="XMLObjectMarshalers">addElementMarshaler: marshaler	marshalers 		detect: [ :mx | mx path = marshaler path and: [mx symbolSpace = marshaler symbolSpace] ] 			ifNone: [marshalers add: marshaler].</body><body package="XMLObjectMarshalers">addKeyMarshaler: marshaler" Keys are sort of hacked in right now. Keys add themselves via addKeyMarshaler: and for now on we keep both keys and elements in the same list. This should be redone later "	(registeredKeys includesKey: marshaler tag)		ifTrue: 			[self error: ((#DuplicateKey &lt;&lt; #webservices &gt;&gt; 'Duplicate key &lt;1s&gt;')						expandMacrosWith: marshaler tag asString)].	registeredKeys at: marshaler key put: marshaler.	self addElementMarshaler: marshaler</body><body package="XMLObjectMarshalers">finish	classMap := Dictionary new: 30.	self nodesDo: 			[:node |			node finish.			node registerWith: self]		withRegistry: (IdentitySet new: 64)</body><body package="XMLObjectMarshalers">register	| ns |	(name notNil and: [name isString]) ifTrue: [		ns := targetNamespace ifNil: [''] ifNotNil: [targetNamespace].		name := NodeTag qualifier: '' ns: ns type: name ]. 	self class register: self</body><body package="XMLObjectMarshalers">registerClassMarshaler: aComplexTypeMarshaler	self classMap at: aComplexTypeMarshaler smalltalkClass ifAbsentPut: [ aComplexTypeMarshaler ]</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder	| v |	super setLocalAttributesFrom: attributesx in: builder.	name := self findValue: 'name' in: attributesx.	self elementFormDefault: 		((( v :=self findValue: 'elementFormDefault' in: attributesx)  notNil			ifTrue: [ v ]			ifFalse: [#unqualified]) asSymbol).	self attributeFormDefault: (		((v := self findValue: 'attributeFormDefault' in: attributesx) notNil			ifTrue: [ v ]			ifFalse: [#unqualified]) asSymbol).	self defaultQualifier: (self findValue: 'defaultQualifier' in: attributesx).	targetNamespace := self findValue: 'targetNamespace' in: attributesx.	usePrefixedSchemaTags := (self findValue: 'usePrefixedSchemaTags' in: attributesx) ifNotNil: [ :val | Boolean readFrom: val readStream].	(self findValue: 'defaultClassNamespace' in: attributesx) ifNotNil: [ :val |  self defaultClassNamespace: val ].	(self findValue: 'id' in: attributesx) ifNotNil: [ :val |  self id: val ].	(self findValue: 'version' in: attributesx) ifNotNil: [ :val |  self version: val ].	(self findValue: 'lang' in: attributesx) ifNotNil: [ :val | self language: val ].	(self findValue: 'useInlineType' in: attributesx) ifNotNil: 		[ :val  | self useInlineType: (Boolean readFrom: val readStream) ].	(self findValue: 'useReference' in: attributesx) ifNotNil: 		[ :val  | self useReference: (Boolean readFrom: val readStream) ].	(self findValue: 'useTaggedObject' in: attributesx) ifNotNil: 		[ :val  | self useTaggedObject: (Boolean readFrom: val readStream) ].</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>accessing</category><body package="XMLObjectMarshalers">classMap	^classMap</body><body package="XMLObjectMarshalers">importedBindings	^importedBindings</body><body package="XMLObjectMarshalers">imports	^imports</body><body package="XMLObjectMarshalers">imports: anObject	imports := anObject</body><body package="XMLObjectMarshalers">marshalers	^marshalers</body><body package="XMLObjectMarshalers">tag: anObject withType: aString	"Create a TaggedObject that holds a wildcard value and NodeTag to find a value marshaler "	^TaggedObject ns: self targetNamespace type: aString value: anObject</body><body package="XMLObjectMarshalers">targetNamespace	^targetNamespace</body><body package="XMLObjectMarshalers">targetNamespace: aString	targetNamespace := aString</body><body package="XMLObjectMarshalers">usePrefixedSchemaTags	^usePrefixedSchemaTags ifNil: [usePrefixedSchemaTags := self class usePrefixedSchemaTags ]</body><body package="XMLObjectMarshalers">usePrefixedSchemaTags: aBoolean	usePrefixedSchemaTags := aBoolean</body><body package="XMLObjectMarshalers">useTaggedObject	^useTaggedObject ifNil: [useTaggedObject := self class useTaggedObject]</body><body package="XMLObjectMarshalers">useTaggedObject: aBoolean	useTaggedObject := aBoolean</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>api -- translation</category><body package="XMLObjectMarshalers">detect: aKey	^self detect: aKey ifNone: [nil]</body><body package="XMLObjectMarshalers">detect: aKey ifNone: aBlock	|  marshalersx | 	marshalersx  := marshalers select: [ :m | m isLike: aKey ].	^marshalersx isEmpty 		ifTrue: [ aBlock value ]		ifFalse: [ marshalersx ]</body><body package="XMLObjectMarshalers">elementMarshalerForTag: anXmlNodeTag	^self elementMarshalerForTag: anXmlNodeTag ifAbsent: [self noMarshalerError: anXmlNodeTag]</body><body package="XMLObjectMarshalers">elementMarshalerForTag: anXmlNodeTag ifAbsent: aBlock	^(self findMarshalersLike: anXmlNodeTag ifAbsent: [ ^aBlock value ])		detect: [ :mx | mx symbolSpace = #element ] ifNone: aBlock</body><body package="XMLObjectMarshalers">findLocalMarshalersLike: aKey ifAbsent: aBlock	^self 		detect: aKey		ifNone: [ importedBindings do: [ :b | ( b detect: aKey ifNone: [nil]) ifNotNil: [ :mx | ^mx ]].				aBlock value].</body><body package="XMLObjectMarshalers">findMarshalersLike: aKey	^self findMarshalersLike: aKey ifAbsent: [nil]</body><body package="XMLObjectMarshalers">findMarshalersLike: aKey ifAbsent: aBlock	^self 		detect: aKey		ifNone: [ importedBindings do: [ :b | ( b detect: aKey ifNone: [nil]) ifNotNil: [ :mx | ^mx ]].				self class findMarshalersLike: aKey ifAbsent: aBlock ].</body><body package="XMLObjectMarshalers">keyForTag: aNodeTag ifAbsent: aBlock	^registeredKeys 		at: aNodeTag 		ifAbsent: 			[importedBindings do: [ :binding | (binding keyForTag: aNodeTag ifAbsent: [nil]) ifNotNil: [ :marshalerx | ^marshalerx ]].			(self class bindingAtNamespace: aNodeTag value namespace ifAbsent: [nil])				ifNotNil: [ :binding | binding keyForTag: aNodeTag ifAbsent: aBlock]				ifNil: aBlock ].</body><body package="XMLObjectMarshalers">localMarshalerForClass: aClass ifAbsent: aBlock"Finds its own marshaler or imported "	^classMap 		at: aClass 		ifAbsent: 			[importedBindings  do: [ :binding | ( binding localMarshalerForClass: aClass ifAbsent: [nil]) ifNotNil: [ :marshaler | ^marshaler ]].			aBlock value].</body><body package="XMLObjectMarshalers">marshalerForAnyType: aValue ifAbsent: aBlock		^self class		findSimpleMarshaler: aValue 		ifAbsent: [ self marshalerForClass: aValue class ifAbsent: aBlock ].</body><body package="XMLObjectMarshalers">marshalerForClass: aClass ifAbsent: aBlock"Finds any marshaler from the global registry "	^classMap 		at: aClass 		ifAbsent: 			[importedBindings  do: [ :binding | ( binding marshalerForClass: aClass ifAbsent: [nil]) ifNotNil: [ :marshaler | ^marshaler ]].			(self class marshalerForClass: aClass ifAbsent: [nil]) ifNotNil: [ :marshaler | ^marshaler ].			aBlock value].</body><body package="XMLObjectMarshalers">marshalerForObject: anObject ifAbsent: aBlock	^self marshalerForClass: anObject  class ifAbsent: aBlock</body><body package="XMLObjectMarshalers">marshalerForTag: anXmlNodeTag	^self 		marshalerForTag: anXmlNodeTag 		ifAbsent: [self noMarshalerError: anXmlNodeTag]</body><body package="XMLObjectMarshalers">marshalerForTag: anXmlNodeTag ifAbsent: aBlock" Find any marshaler for the node tag (Relation, Object or Simple  type)"	^(self findMarshalersLike: anXmlNodeTag ifAbsent: [^aBlock value]) first</body><body package="XMLObjectMarshalers">marshalerForType: localName ns: ns 	^self marshalerForType: localName ns: ns quailfier: ''</body><body package="XMLObjectMarshalers">marshalerForType: localName ns: ns quailfier: qualifierString	^self typeMarshalerForTag: (NodeTag qualifier: qualifierString ns: ns type: localName)</body><body package="XMLObjectMarshalers">marshalerForType: localName quailfier: qualifierString	^self marshalerForType: localName ns: '' quailfier: qualifierString</body><body package="XMLObjectMarshalers">noMarshalerError: anXmlNodeTag	^NoMarshalerSignal new		messageText: ((#NoMarshalerFor &lt;&lt; #webservices &gt;&gt; 'No marshaler for: &lt;1s&gt;')		expandMacrosWith: anXmlNodeTag printString);		parameter: anXmlNodeTag;		raiseRequest</body><body package="XMLObjectMarshalers">typeMarshalerForTag: anXmlNodeTag	^self 		typeMarshalerForTag: anXmlNodeTag 		ifAbsent: [self noMarshalerError: anXmlNodeTag]</body><body package="XMLObjectMarshalers">typeMarshalerForTag: anXmlNodeTag ifAbsent: aBlock	^(self findMarshalersLike: anXmlNodeTag ifAbsent: [^aBlock value]) 		detect: [ :mx | mx isType ] ifNone: aBlock</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>attribute settings</category><body package="XMLObjectMarshalers">attributeFormDefault	^self defaults at: #attributeFormDefault ifAbsent: [ nil ]</body><body package="XMLObjectMarshalers">attributeFormDefault: aValue	^self defaults at: #attributeFormDefault put: aValue</body><body package="XMLObjectMarshalers">defaultClassNamespace	^self defaults at: #defaultClassNamespace ifAbsent: [nil]</body><body package="XMLObjectMarshalers">defaultClassNamespace: aValue	^self defaults at: #defaultClassNamespace put: aValue</body><body package="XMLObjectMarshalers">defaultQualifier	^self defaults at: #defaultQualifier ifAbsent: [nil]</body><body package="XMLObjectMarshalers">defaultQualifier: aValue	^self defaults at: #defaultQualifier put: aValue</body><body package="XMLObjectMarshalers">defaults	^defaults</body><body package="XMLObjectMarshalers">elementFormDefault	^self defaults at: #elementFormDefault ifAbsent: [nil]</body><body package="XMLObjectMarshalers">elementFormDefault: aValue	^self defaults at: #elementFormDefault put: aValue</body><body package="XMLObjectMarshalers">id	^self defaults at: #id ifAbsent: [nil]</body><body package="XMLObjectMarshalers">id: aValue	^self defaults at: #id put: aValue</body><body package="XMLObjectMarshalers">lang	^self language</body><body package="XMLObjectMarshalers">lang: aValue	^self language: aValue</body><body package="XMLObjectMarshalers">language	^self defaults at: #language ifAbsent: [nil]</body><body package="XMLObjectMarshalers">language: aValue	^self defaults at: #language put: aValue</body><body package="XMLObjectMarshalers">useInlineType	^self defaults at: #useInlineType ifAbsent: [ self class useInlineType ]</body><body package="XMLObjectMarshalers">useInlineType: aBoolean	^self defaults at: #useInlineType put: aBoolean</body><body package="XMLObjectMarshalers">useReference	^self defaults at: #useReference ifAbsent: [ self class useReference ]</body><body package="XMLObjectMarshalers">useReference: aBoolean	^self defaults at: #useReference put: aBoolean</body><body package="XMLObjectMarshalers">useXPath	^self defaults at: #useXPath ifAbsent: [ self class useXPath ]</body><body package="XMLObjectMarshalers">useXPath: aBoolean	^self defaults at: #useXPath put: aBoolean</body><body package="XMLObjectMarshalers">version	^self defaults at: #version ifAbsent: [nil]</body><body package="XMLObjectMarshalers">version: aValue	^self defaults at: #version put: aValue</body><body package="XMLObjectMarshalers">xmlEncoding	^self defaults at: #xmlEncoding ifAbsent: [nil]</body><body package="XMLObjectMarshalers">xmlEncoding: aValue	^self defaults at: #xmlEncoding put: aValue</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">asBindingImport	^BindingImport new 		location: self location; 		namespace: self namespace; 		yourself</body><body package="XMLObjectMarshalers">asSchemaBindingsSpecification	^Element 		tag: (NodeTag qualifier: '' ns: '' type: 'schemaBindings')		elements: (Array with: self asX2OSpecification )</body><body package="XMLObjectMarshalers">asX2OSpecification	| schemaBinding  manager |	[schemaBinding :=  XMLObjectBinding loadFrom: self class x2o_BindingSpecification readStream.	] on: NonDeterministicContentModel do: [ :ex | ex proceed].	manager := XMLObjectMarshalingManager on: schemaBinding.	manager 		recordNamespace: 'urn:visualworks:VWSchemaBinding'  qualifier: '';		recordNamespace: 'http://www.w3.org/2001/XMLSchema'  qualifier: 'xsd'.	self targetNamespace ifNotNil: [ :ns | manager qualifierMap at:  ns put: 'tns'.].	self marshalers do: [ :m | 		(m selectXMLMarshalerFrom: (manager binding marshalers select: [ :each | each smalltalkClass = m class ]))			ifNil: [ self error: ((#ThereIsNoMarshalerFor1s &lt;&lt; #webservices &gt;&gt; 'There is no XML marshaler for: &lt;1s&gt;') expandMacrosWith:   m printString) ]			ifNotNil: [ :xmlMarshaler | manager register: m marshalWith: xmlMarshaler ]].	^manager		marshal: self 		with: (schemaBinding marshalers detect: [ :m | m smalltalkClass = self class ] ifNone: [^nil]).</body><body package="XMLObjectMarshalers">asXMLSchemaSpecification	| schemaBinding  manager |	[schemaBinding := XMLObjectBinding loadFrom: self class xml_SchemaSpecification readStream.	] on: NonDeterministicContentModel do: [ :ex | ex proceed].	manager := XMLObjectMarshalingManager on: schemaBinding.	manager significantNamespaces at: '' put: XMLBuildingPolicy defaultUriXsd.	self targetNamespace ifNotNil: [ :ns | manager qualifierMap at:  ns put: 'tns'.].	self marshalers do: [ :m | 		(m selectXMLMarshalerFrom: (manager binding marshalers select: [ :each | each smalltalkClass = m class ]))			ifNil: [ self error: 'There is no XML marshaler for: ', m printString ]			ifNotNil: [ :xmlMarshaler | manager register: m marshalWith: xmlMarshaler ]].	^manager		marshal: self 		with: (schemaBinding marshalers detect: [ :m | m smalltalkClass = self class ] ifNone: [nil]).</body><body package="XMLObjectMarshalers">location	^nil</body><body package="XMLObjectMarshalers">namespace	^self targetNamespace</body><body package="XMLObjectMarshalers">x2oUseInlineType	^self useInlineType = self class useInlineTypeValue		ifTrue: [ nil]		ifFalse: [self useInlineType]</body><body package="XMLObjectMarshalers">x2oUseReference	^self useReference = self class useReferenceValue		ifTrue: [ nil]		ifFalse: [self useReference]</body><body package="XMLObjectMarshalers">xmlAttributeFormDefault	^self attributeQualified ifTrue: [ 'qualified' ] ifFalse: [ nil ]</body><body package="XMLObjectMarshalers">xmlElementFormDefault	^self elementQualified ifTrue: [ 'qualified'] 	ifFalse: [nil]</body><body package="XMLObjectMarshalers">xmlImports	imports notEmpty ifTrue: [ ^imports collect: [ :x2o | x2o asBindingImport]].	importedBindings notEmpty ifTrue: [^importedBindings collect: [ :x2o | x2o asBindingImport]].	^OrderedCollection new</body><body package="XMLObjectMarshalers">xmlMarshalers	^self marshalers</body><body package="XMLObjectMarshalers">xmlName	self name ifNil: [^nil].	^self name type isEmpty ifTrue: [ nil ] ifFalse: [self name type]</body><body package="XMLObjectMarshalers">xmlTargetNamespace	^self targetNamespace</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">unmarshal: anXmlNode	| marshaler |	marshaler := self 					marshalerForTag: anXmlNode tag 					ifAbsent: [self notifyNoMarshalerFor: anXmlNode text: anXmlNode tag expandedName].	^(XMLObjectMarshalingManager on: self)		 unmarshal: anXmlNode with: marshaler</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>creating specification nodes</category><body package="XMLObjectMarshalers">createSchemaNode	^self asXMLSchemaSpecification</body><body package="XMLObjectMarshalers">createTypesNode	^self createSchemaNode 		ifNotNil: [ :node | Element 					tag: (NodeTag new qualifier: '' ns: '' type: 'type')					elements: (OrderedCollection with: node) ]</body><body package="XMLObjectMarshalers">createXML2SmBindingNode		^self asX2OSpecification</body><body package="XMLObjectMarshalers">createXMLObjectBinding	^self createXML2SmBindingNode 		ifNotNil: [ :node | Element 					tag: (NodeTag new qualifier: '' ns: '' type: 'schemaBindings')					elements: (OrderedCollection with: node) ]</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>printing specification nodes</category><body package="XMLObjectMarshalers">printPrologOn: aStream	| version xmlEncoding |	version := self version ifNil: [ self class xmlVersionValue].	xmlEncoding := self xmlEncoding ifNil: [ self class xmlEncoding ].	aStream nextPutAll: '&lt;?xml version="',  version, '" encoding="', xmlEncoding, '" ?&gt;'; cr.</body><body package="XMLObjectMarshalers">printSmalltalkBindingOn: aStream	self printPrologOn: aStream.	self createXMLObjectBinding		wsPrintOn: aStream depth: 0</body><body package="XMLObjectMarshalers">printXMLSchemaOn: aStream	self printPrologOn: aStream.	self createSchemaNode		wsPrintOn: aStream depth: 0</body><body package="XMLObjectMarshalers">printXMLTypesOn: aStream	self printPrologOn: aStream.	self createTypesNode		wsPrintOn: aStream depth: 0</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">marshal: anObject	| marshaler |	marshaler := self 					marshalerForClass: anObject class 					ifAbsent: [ self error: ((#NoMarshalerFor &lt;&lt; #webservices &gt;&gt; 'No marshaler for: &lt;1s&gt;')								expandMacrosWith: anObject class name asString) ].	^self  marshal: anObject with: marshaler.</body><body package="XMLObjectMarshalers">marshal: anObject with: marshaler	^(XMLObjectMarshalingManager on: self)		marshal: anObject with: marshaler</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>printing</category><body package="XMLObjectMarshalers">printOn: aStream	aStream nextPutAll: self class name.	targetNamespace notNil ifTrue: [aStream nextPutAll: ' targetNamespace="',  targetNamespace, '"' ].	importedBindings notEmpty ifTrue: [		aStream cr; nextPutAll: ' imports: ('.		importedBindings do: [ :each | aStream nextPutAll: each targetNamespace printString, ' ' ].		aStream nextPut: $)]</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>initialization</category><body package="XMLObjectMarshalers">importBinding: aBinding	aBinding notNil 		ifTrue: [( importedBindings detect: [ :import | import targetNamespace = aBinding targetNamespace ] ifNone: [nil])					ifNotNil: [ :import |  importedBindings remove: import].				 importedBindings add: aBinding ]</body><body package="XMLObjectMarshalers">initialize	super initialize.	defaults := Dictionary new: 10.	marshalers := OrderedCollection new: 50.	classMap := Dictionary new: 30.	registeredKeys := Dictionary new: 10.	self elementFormDefault: #unqualified.	self attributeFormDefault: #unqualified.	self defaultQualifier: ''.	self resetImports</body><body package="XMLObjectMarshalers">resetImports	imports := OrderedCollection new: 50.	importedBindings := OrderedCollection new: 50.</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>comparing</category><body package="XMLObjectMarshalers">= anXMLObjectBinding	^self name = anXMLObjectBinding name 		and: [ self targetNamespace = anXMLObjectBinding targetNamespace ]</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>testing</category><body package="XMLObjectMarshalers">attributeQualified	^self attributeFormDefault ifNil: [ false ] ifNotNil: [ :v | v = #qualified]</body><body package="XMLObjectMarshalers">attributeUnqualified	^self attributeFormDefault ifNil: [ true ] ifNotNil: [ :v | v = #unqualified]</body><body package="XMLObjectMarshalers">elementQualified	^self elementFormDefault ifNil: [ false ] ifNotNil: [ :v | v = #qualified]</body><body package="XMLObjectMarshalers">elementUnqualified	^self elementFormDefault ifNil: [ true ] ifNotNil: [ :v | v = #unqualified]</body></methods><methods><class-id>WebServices.XMLObjectBinding</class-id> <category>enumerating</category><body package="XMLObjectMarshalers">nodesDo: aBlock withRegistry: anIdentitySet	marshalers		do: [:each | each ~~ nil ifTrue: [each nodesDo: aBlock withRegistry: anIdentitySet]]</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>accessing</category><body package="XMLObjectMarshalers">bindingAtNamespace: aString	^self bindingAtNamespace: aString ifAbsent: [nil]</body><body package="XMLObjectMarshalers">bindingAtNamespace: aUriOrString ifAbsent: aBlock"asURI"	^self registry at: aUriOrString asString ifAbsent: aBlock</body><body package="XMLObjectMarshalers">bindingNamed: aString"(self bindingNamed: 'VWBinding')"	^self registry values detect: [ :binding | binding name type = aString] ifNone: [ nil ].</body><body package="XMLObjectMarshalers">classForXMLType: aNode ifAbsent: aBlock	| val |	val := self sm2XMLTypeRegistry associations detect: [ :assc | assc value key  = aNode ] ifNone: [nil].	^val ifNotNil: [ val key ] ifNil: [ aBlock  value ]</body><body package="XMLObjectMarshalers">prerequisitesForLoading	^super prerequisitesForLoading		add: BindingBuilder;		yourself</body><body package="XMLObjectMarshalers">register: aBinding	aBinding targetNamespace ifNotNil: [ self registry at: aBinding targetNamespace put: aBinding].</body><body package="XMLObjectMarshalers">registry	^XMLBindingRegistry</body><body package="XMLObjectMarshalers">resolvedXMLTypes	" self resolvedXMLTypes "	^(self bindingAtNamespace: self defaultUriXsd asString) marshalers collect: [ :k | k tag type ]</body><body package="XMLObjectMarshalers">simpleTypes			^self sm2XMLTypeRegistry keys</body><body package="XMLObjectMarshalers">simpleXMLTypeFor: aStringOrClass ifAbsent: aBlock	"(self simpleXMLTypeFor: 'String' ifAbsent: [nil] )"	| aClass |	aClass := aStringOrClass isString ifTrue: [ aStringOrClass asQualifiedReference valueOrDo: [nil]] ifFalse: [ aStringOrClass].	aClass ifNil: [ ^aBlock value].	^self sm2XMLTypeRegistry at: aClass  ifAbsent: aBlock</body><body package="XMLObjectMarshalers">sm2XMLTypeRegistry	Sm2XMLTypeRegistry ifNil: [ self initializeSm2XMLTypeRegistry].	^Sm2XMLTypeRegistry</body><body package="XMLObjectMarshalers">systemTargetNamespaces	^#('http://schemas.xmlsoap.org/soap/envelope/''http://schemas.xmlsoap.org/wsdl/''http://www.w3.org/1999/XMLSchema''http://www.w3.org/2000/10/XMLSchema''http://www.w3.org/2000/XMLSchema''http://www.w3.org/2001/XMLSchema''http://www.w3.org/2003/05/soap-envelope''http://www.w3.org/ns/wsdl''urn:visualworks:VWSchemaBinding''http://www.w3.org/2001/XMLSchema/Mapping''urn:visualworks:VWSchemaBinding/Mapping''urn:visualworks:operationSelectors''urn:visualworks:serviceMap''http://www.w3.org/XML/1998/namespace')</body><body package="XMLObjectMarshalers">xmlTypeForInteger: anInteger	"Find the minimal XML type to represent the given Integer.	This is different dependent on the range."" byte 127 to-128 "	(BindingBuilder isByte: anInteger) ifTrue: [^#byte]."unsignedByte 0 to 255 "	(BindingBuilder isUnsignedByte: anInteger) ifTrue: [^#unsignedByte]."short 32767 to -32768 "	(BindingBuilder isShort: anInteger) ifTrue: [^#short]."unsignedShort 0 to 65535 "	(BindingBuilder isUnsignedShort: anInteger) ifTrue: [^#unsignedShort]."int 2147483647 to -2147483648 "	(BindingBuilder isInt: anInteger) ifTrue: [^#int]."unsignedInt 0 to 4294967295"	(BindingBuilder isUnsignedInt: anInteger) ifTrue: [^#unsignedInt]."long 9223372036854775807 to -9223372036854775808"	(BindingBuilder isLong: anInteger) ifTrue: [^#long]."unsignedLong 0 to 18446744073709551615"	(BindingBuilder isUnsignedLong: anInteger) ifTrue: [^#unsignedLong]."negativeInteger Infinite set {...,-2,-1}"	(BindingBuilder isNegativeInteger: anInteger) ifTrue: [^#negativeInteger]."nonNegativeInteger Infinite set {0, 1, 2, ...}. ""nonPositiveInteger Infinite set {...,-2,-1,0}. ""	anInteger isZero ifTrue: [^#nonNegativeInteger]."" positiveInteger Infinite set {1, 2, ...}. "	^#positiveInteger"integer Integer or whole numbers"</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>class initialization</category><body package="XMLObjectMarshalers">configure" Configure yourself "	" ((self configure)) "	self initializeSm2XMLTypeRegistry.	self 		reset; 		loadVWBinding;		loadXsdBinding.	"The order is important"		#( #{SoapBinding } #{WsdlBinding}  ) 	do: [ :cl |  cl ifDefinedDo: [:cl1 | cl1 configure]].</body><body package="XMLObjectMarshalers">initialize	" self initialize "	self configure.</body><body package="XMLObjectMarshalers">initializeSm2XMLTypeRegistry	"((( self initializeSm2XMLTypeRegistry ))) "	| dom key value q type ns id |	Sm2XMLTypeRegistry := Struct new: 30.	dom := (XMLParser on: self defaultSmalltalk2XMLMap readStream)				validate: false;				scanDocument.		dom root realElements 		do: [ :el |			key := (el valueOfAttribute: 'smalltalkClass' ifAbsent: [nil]) asSymbol asQualifiedReference valueOrDo: [nil].			value := el valueOfAttribute: 'xmlType' ifAbsent: [nil].			id := el valueOfAttribute: 'conversionId' ifAbsent: [nil].			q := value copyFrom: 1 to: (value indexOf: $: ) - 1.			type := value copyFrom: (value indexOf: $: ) + 1 to: value size.			 ns := el  parent namespaceAt: q.			Sm2XMLTypeRegistry at: key  put: (NodeTag qualifier: q ns: ns type: type)-&gt;id ].	^Sm2XMLTypeRegistry</body><body package="XMLObjectMarshalers">reset	"(self reset)"	XMLBindingRegistry := Dictionary new: 50</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>api -- translation</category><body package="XMLObjectMarshalers">elementMarshalerForTag: anXmlNodeTag ifAbsent: aBlock	^(self findMarshalersLike: anXmlNodeTag ifAbsent: [^aBlock value])		detect: [ :mx | mx symbolSpace = #element ] ifNone: aBlock</body><body package="XMLObjectMarshalers">findMarshalersLike: aNodeTag	^self findMarshalersLike: aNodeTag ifAbsent: [nil]</body><body package="XMLObjectMarshalers">findMarshalersLike: aNodeTag ifAbsent: aBlock		^(self bindingAtNamespace: aNodeTag namespace) 		ifNotNil: [ :binding | binding detect: aNodeTag ifNone: aBlock  ]		ifNil: aBlock</body><body package="XMLObjectMarshalers">findSimpleMarshaler: aValue ifAbsent: aBlock	| m assoc  |		^aValue isInteger		ifTrue: [self 				simpleMarshalerType: (self xmlTypeForInteger: aValue) asString				conversionId: nil				ifAbsent: aBlock]		ifFalse: [(assoc := self sm2XMLTypeRegistry at: aValue class  ifAbsent: [nil]) 					ifNotNil: [m := self typeMarshalerForTag: assoc key ifAbsent: aBlock.							assoc value notNil								ifTrue: [m copy setBlocksForId: assoc value ]								ifFalse: [ m ]]					ifNil: aBlock ].</body><body package="XMLObjectMarshalers">marshalerForAnyType: aValue ifAbsent: aBlock		^self 		findSimpleMarshaler: aValue 		ifAbsent: [ self marshalerForClass: aValue class ifAbsent: aBlock ].</body><body package="XMLObjectMarshalers">marshalerForClass: aClass ifAbsent: aBlock	self registry values do: [ :binding | (binding classMap at: aClass ifAbsent: [nil]) ifNotNil: [ :m |  ^m] ].	^aBlock value</body><body package="XMLObjectMarshalers">marshalerForObject: anObject ifAbsent: aBlock	^self marshalerForClass: anObject class ifAbsent: aBlock</body><body package="XMLObjectMarshalers">marshalerForTag: anXmlNodeTag ifAbsent: aBlock	^self typeMarshalerForTag: anXmlNodeTag ifAbsent: aBlock</body><body package="XMLObjectMarshalers">simpleMarshalerType: aStringOrNode	"(self simpleMarshalerType: 'string' )"	^self simpleMarshalerType: aStringOrNode conversionId: nil</body><body package="XMLObjectMarshalers">simpleMarshalerType: aStringOrNode conversionId: idString	^self simpleMarshalerType: aStringOrNode conversionId: idString ifAbsent: [nil]</body><body package="XMLObjectMarshalers">simpleMarshalerType: aStringOrNode conversionId: idString ifAbsent: aBlock	| node  |	node := (aStringOrNode isKindOf: NodeTag)		ifTrue: [aStringOrNode]		ifFalse: 	[NodeTag qualifier: '' 	ns: XMLObjectBinding defaultUriXsd type: aStringOrNode].	^(self typeMarshalerForTag: node ifAbsent: [nil])		ifNotNil: [ :m | (idString notNil and: [ m conversionId ~= idString])							ifTrue: [m copy setBlocksForId: idString ]							ifFalse: [ m ]]		ifNil: aBlock</body><body package="XMLObjectMarshalers">typeMarshalerForTag: anXmlNodeTag ifAbsent: aBlock	^(self findMarshalersLike: anXmlNodeTag ifAbsent: [^aBlock value]) 		detect: [ :mx | mx isType ] ifNone: aBlock</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>accessing bindings</category><body package="XMLObjectMarshalers">vwBinding	^self bindingAtNamespace: self uriVWBinding</body><body package="XMLObjectMarshalers">x2oBinding	^self bindingAtNamespace: 'urn:visualworks:VWSchemaBinding/Mapping'</body><body package="XMLObjectMarshalers">xmlSchemaBinding	^self bindingAtNamespace: 'http://www.w3.org/2001/XMLSchema/Mapping'</body><body package="XMLObjectMarshalers">xsd1999Binding	^self bindingAtNamespace: self uri1999Xsd</body><body package="XMLObjectMarshalers">xsd200010Binding	^self bindingAtNamespace: self uri200010Xsd</body><body package="XMLObjectMarshalers">xsd2000Binding	^self bindingAtNamespace: self uri2000Xsd</body><body package="XMLObjectMarshalers">xsd2001Binding	^self bindingAtNamespace: self uri2001Xsd</body><body package="XMLObjectMarshalers">xsdBinding	^self xsd2001Binding</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>registry removing</category><body package="XMLObjectMarshalers">removeBinding: anXMLObjectBinding	self removeKey: anXMLObjectBinding targetNamespace ifAbsent: [nil]</body><body package="XMLObjectMarshalers">removeKey: aUriOrString ifAbsent: aBlock	self registry removeKey: aUriOrString asString ifAbsent: aBlock</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>specifications</category><body package="XMLObjectMarshalers">defaultSmalltalk2XMLMap	^'&lt;?xml version ="1.0"?&gt;&lt;!--Default binding VW Smalltalk objects to XML datatypes  --&gt;&lt;xmlToSmalltalkBinding name="SmalltalkClassesBinding" 	targetNamespace="http://vwSmalltalkClassesBinding"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns="http://www.w3.org/2001/XMLSchema"&gt;&lt;simple smalltalkClass="String" xmlType="xsd:string"/&gt;&lt;simple smalltalkClass="Integer" xmlType="xsd:int" /&gt;&lt;simple  smalltalkClass="Double" xmlType="xsd:double"/&gt;&lt;simple smalltalkClass="Float" xmlType="xsd:float" /&gt;&lt;simple smalltalkClass="SmallInteger" xmlType="xsd:short"/&gt;&lt;simple smalltalkClass="Boolean" xmlType="xsd:boolean"  /&gt;&lt;simple smalltalkClass="Time" xmlType="xsd:time"/&gt;&lt;simple smalltalkClass="Date" xmlType="xsd:date"/&gt;&lt;simple smalltalkClass="Timestamp" xmlType="xsd:dateTime"/&gt;&lt;simple smalltalkClass="ISO8859L1String" xmlType="xsd:string" conversionId="ISO8859L1String"/&gt;&lt;simple smalltalkClass="MSCP1252String" xmlType="xsd:string"  conversionId="MSCP1252String" /&gt;&lt;simple smalltalkClass="TwoByteString" xmlType="xsd:string"  conversionId="TwoByteString"/&gt;&lt;simple smalltalkClass="FourByteString" xmlType="xsd:string" conversionId="FourByteString"/&gt;&lt;simple smalltalkClass="ByteString" xmlType="xsd:string"/&gt;&lt;simple smalltalkClass="Symbol" xmlType="xsd:string" conversionId="Symbol"/&gt;&lt;simple smalltalkClass="ByteSymbol" xmlType="xsd:string" conversionId="ByteSymbol"/&gt;&lt;simple smalltalkClass="FourByteSymbol" xmlType="xsd:string" conversionId="FourByteSymbol"/&gt;&lt;simple smalltalkClass="TwoByteSymbol" xmlType="xsd:string" conversionId="TwoByteSymbol"/&gt;&lt;simple smalltalkClass="Character" xmlType="xsd:string" conversionId="Character"/&gt;&lt;simple smalltalkClass="FixedPoint" xmlType="xsd:decimal"/&gt;&lt;simple smalltalkClass="LargePositiveInteger" xmlType="xsd:positiveInteger" /&gt;&lt;simple smalltalkClass="LargeNegativeInteger" xmlType="xsd:negativeInteger" /&gt;&lt;simple smalltalkClass="True" xmlType="xsd:boolean"  /&gt;&lt;simple smalltalkClass="False" xmlType="xsd:boolean"  /&gt;&lt;simple smalltalkClass="URI" xmlType="xsd:anyURI"/&gt;&lt;simple smalltalkClass="XML.NodeTag" xmlType="xsd:QName"/&gt;&lt;simple smalltalkClass="ByteArray" xmlType="xsd:base64Binary"/&gt;&lt;simple smalltalkClass="Object" xmlType="xsd:anyType"/&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="XMLObjectMarshalers">defaultVWBindingLocation	^'&lt;?xml version ="1.0"?&gt;&lt;!-- VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="VWBinding" 	targetNamespace="urn:visualworks:VWSchemaBinding"	xmlns="urn:visualworks:VWSchemaBinding"	xmlns:tns="urn:visualworks:VWSchemaBinding"&gt;&lt;simple name="schemaBindings"  id="unmarshalXML" /&gt;&lt;simple name="xmlToSmalltalkBinding" id="unmarshalXML"/&gt;&lt;simple name="nil" id="nil" /&gt;&lt;simple name="tag" id="tag" /&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="XMLObjectMarshalers">defaultXsdBindingLocation	^self uri2001Xsd</body><body package="XMLObjectMarshalers">defaultXsdBindingLocation1999	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="XsdBinding1999" 	targetNamespace="http://www.w3.org/1999/XMLSchema"	xmlns:xsd="http://www.w3.org/1999/XMLSchema"	xmlns="http://www.w3.org/1999/XMLSchema"	xmlns:tns="urn:visualworks:XSchemaBinding"&gt;', self defaultXsdBindingMap</body><body package="XMLObjectMarshalers">defaultXsdBindingLocation2000	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="XsdBinding2000" 	targetNamespace="http://www.w3.org/2000/XMLSchema"	xmlns:xsd="http://www.w3.org/2000/XMLSchema"	xmlns="http://www.w3.org/2000/XMLSchema"	xmlns:tns="urn:visualworks:XSchemaBinding"&gt;', self defaultXsdBindingMap</body><body package="XMLObjectMarshalers">defaultXsdBindingLocation2000_10	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="XsdBinding200010" 	targetNamespace="http://www.w3.org/2000/10/XMLSchema"	xmlns:xsd="http://www.w3.org/2000/10/XMLSchema"	xmlns="http://www.w3.org/2000/10/XMLSchema"	xmlns:tns="urn:visualworks:XSchemaBinding"&gt;', self defaultXsdBindingMap</body><body package="XMLObjectMarshalers">defaultXsdBindingLocation2001	^'&lt;?xml version ="1.0"?&gt;&lt;!-- SOAP to VW Smalltalk binding --&gt;&lt;xmlToSmalltalkBinding name="XsdBinding2001" 	targetNamespace="http://www.w3.org/2001/XMLSchema"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns="http://www.w3.org/2001/XMLSchema"	xmlns:tns="urn:visualworks:XSchemaBinding"&gt;', self defaultXsdBindingMap</body><body package="XMLObjectMarshalers">defaultXsdBindingMap	^'&lt;!--build-in primitive types --&gt;&lt;simple name="string" id="String"/&gt;&lt;simple name="boolean" id="Boolean"/&gt;&lt;simple name="time"  id="Time"/&gt;&lt;simple name="date" id="Date"/&gt;&lt;simple name="dateTime" id="Timestamp"/&gt;&lt;simple name="double" id="Double"/&gt;&lt;simple name="float" id="Float"/&gt;&lt;simple name="decimal" id="Decimal" smalltalkClass="FixedPoint"/&gt;&lt;!--build-in decimal-derived types --&gt;&lt;simple name="integer" id="Integer" smalltalkClass="Integer"/&gt;&lt;!--build-in integer-derived types --&gt;&lt;simple name="nonPositiveInteger" id="NonPositiveInteger"  smalltalkClass="Integer"/&gt;&lt;simple name="nonNegativeInteger" id="NonNegativeInteger"  smalltalkClass="Integer"/&gt;&lt;simple name="long" id="Long"  smalltalkClass="LargeInteger"/&gt;&lt;!--build-in long-derived types --&gt;&lt;simple name="int" id="Int"  smalltalkClass="Integer"/&gt;&lt;simple name="short" id="Short"  smalltalkClass="SmallInteger"/&gt;&lt;simple name="byte"  id="Byte"  smalltalkClass="SmallInteger"/&gt;&lt;!--build-in nonPositiveInteger-derived types --&gt;&lt;simple name="negativeInteger" id="NegativeInteger"  smalltalkClass="Integer"/&gt;&lt;!--build-in nonNegativeInteger-derived types --&gt;&lt;simple name="positiveInteger" id="PositiveInteger"  smalltalkClass="Integer"/&gt;&lt;simple name="unsignedLong" id="UnsignedLong" smalltalkClass="LargeInteger"/&gt; &lt;!--build-in unsignedLong-derived types --&gt;&lt;simple name="unsignedInt" id="UnsignedInt" smalltalkClass="Integer"/&gt;&lt;simple name="unsignedShort" id="UnsignedShort"  smalltalkClass="SmallInteger"/&gt;&lt;simple name="unsignedByte" id="UnsignedByte"  smalltalkClass="SmallInteger"/&gt;&lt;!--build-in string-derived types --&gt;&lt;simple name="normalizedString" id="NormalizedString" smalltalkClass="String"/&gt;&lt;simple name="token" id="Token" smalltalkClass="String"/&gt;&lt;!--build-in token-derived types --&gt;&lt;simple name="language" id="Token" smalltalkClass="String"/&gt;&lt;simple name="Name" id="Token" smalltalkClass="String"/&gt;&lt;simple name="NMTOKEN" id="Token" smalltalkClass="String"/&gt;&lt;!--build-in Name-derived types --&gt;&lt;simple name="NCName" id="ncname" smalltalkClass="String" /&gt;&lt;simple name="ID"  id="id" smalltalkClass="String" /&gt;&lt;simple name="IDREF"  id="id" smalltalkClass="String"/&gt;&lt;simple name="IDREFS"  id="idrefs" smalltalkClass="String"/&gt;&lt;simple name="ENTITY" id="Token" smalltalkClass="String"/&gt;&lt;simple name="ENTITIES" id="NMTOKENS" smalltalkClass="OrderedCollection"/&gt;&lt;!--build-in NMTOKEN-derived types --&gt;&lt;simple name="NMTOKENS" id="NMTOKENS" smalltalkClass="OrderedCollection"/&gt;&lt;!--the rest of build-in primitive types --&gt;&lt;simple name="base64Binary" id="base64" smalltalkClass="String"/&gt;&lt;simple name="hexBinary" id="hexBinary" smalltalkClass="ByteArray"/&gt;&lt;simple name="anyType"  id="anyType"/&gt;&lt;simple name="anySimpleType"  id="anySimpleType"/&gt;&lt;simple name="QName" id="qname" smalltalkClass="String"/&gt;&lt;simple name="anyURI" id="URI" smalltalkClass="OS.URI"/&gt;&lt;simple name="duration"  id="String"/&gt;&lt;simple name="NOTATION" id="String"/&gt;&lt;simple name="gDay" id="String"/&gt;&lt;simple name="gMonth" id="String"/&gt;&lt;simple name="gYear"  id="String"/&gt;&lt;simple name="gYearMonth"  id="String"/&gt;&lt;simple name="gMonthDay"  id="String"/&gt;&lt;!--not from XML Datatypes spec --&gt;&lt;element name="schema"&gt;	&lt;simple name="schema_type" id="Schema"/&gt;&lt;/element&gt;&lt;simple name="XMLNode" id="XMLNode" /&gt;&lt;simple name="uriReference" id="URI" smalltalkClass="OS.URI"/&gt;&lt;simple name="uri-reference" id="URI" smalltalkClass="OS.URI"/&gt;&lt;simple name="base64" id="base64"/&gt;&lt;simple name="QNames" id="qnames" smalltalkClass="String" /&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="XMLObjectMarshalers">diffgramBinding"XMLObjectBinding loadFrom: XMLObjectBinding diffgramBinding readStream."	^'&lt;?xml version ="1.0"?&gt;&lt;!--http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondiffgrams.asp  --&gt;&lt;xmlToSmalltalkBinding name="DiffGramBinding" 	targetNamespace="urn:schemas-microsoft-com:xml-diffgram-v1"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:msdata="urn:schemas-microsoft-com:xml-msdata"	xmlns:tns="urn:schemas-microsoft-com:xml-diffgram-v1"&gt;&lt;struct name="diffgramType" &gt;	&lt;any aspect="DataSet"/&gt;&lt;/struct&gt;&lt;element name="diffgram" ref="tns:diffgramType"/&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="XMLObjectMarshalers">x2o_BindingSpecification"The mapping creates marshalers to build &lt;xmlToSmalltalkBinding&gt; nodes from XMLObjectBinding object  "	^'&lt;?xml version ="1.0"?&gt;&lt;!-- XML Schema binding --&gt;&lt;xmlToSmalltalkBinding name="X2OBinding" 	defaultClassNamespace="WebServices"	targetNamespace="urn:visualworks:VWSchemaBinding/Mapping"	useInlineType="false"	useReference="false"	useTaggedObject="false"	usePrefixedSchemaTags="false"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:vw="urn:visualworks:VWSchemaBinding"	xmlns="urn:visualworks:VWSchemaBinding"&gt;&lt;object  name="vw:xmlToSmalltalkBinding" smalltalkClass="XMLObjectBinding"&gt;	&lt;attribute name="targetNamespace" aspect="xmlTargetNamespace" ref="xsd:string"   minOccurs="0"  /&gt;	&lt;attribute name="name" aspect="xmlName" minOccurs="0"  ref="xsd:string"/&gt;	&lt;attribute name="elementFormDefault" aspect="xmlElementFormDefault"  ref="xsd:string"/&gt;	&lt;attribute name="attributeFormDefault" aspect="xmlAttributeFormDefault"  ref="xsd:string"/&gt;	&lt;attribute name="useInlineType"  aspect="x2oUseInlineType" ref="xsd:boolean"/&gt;	&lt;attribute name="useReference" aspect="x2oUseReference" ref="xsd:boolean"/&gt;	&lt;attribute name="defaultClassNamespace" ref="xsd:string"/&gt;	&lt;implicitAttribute ref="xml:lang"/&gt;	&lt;attribute name="id" ref="xsd:ID"/&gt;	&lt;attribute name="version" aspect="version"  ref="xsd:string"/&gt;	&lt;element name="vw:bindingImport" minOccurs="0" maxOccurs="*" aspect="xmlImports"  ref="vw:importType"/&gt;	&lt;any aspect="xmlMarshalers" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;&lt;/object&gt;&lt;object  name="vw:importType" smalltalkClass="BindingImport"&gt;	&lt;attribute name="namespace" ref="xsd:string"/&gt;	&lt;attribute name="schemaLocation" aspect="location" ref="xsd:string"/&gt;&lt;/object&gt;&lt;object name="vw:relation"  smalltalkClass="RelationMarshaler"&gt;	&lt;attribute name="name"  aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="aspect"  aspect="xmlAspect"   minOccurs="0"  ref="xsd:string"/&gt;	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;attribute name="default"  aspect="xmlDefaultValue" ref="xsd:string"/&gt;	&lt;attribute name="nillable" aspect="xmlNillable" ref="xsd:string"/&gt;	&lt;attribute name="ref"  aspect="x2oType" ref="xsd:QName"/&gt; 	&lt;attribute name="conversionId"  aspect="x2oConversionId" ref="xsd:string"/&gt; 	&lt;sequence&gt;		&lt;choice  name="x2oLocalContents"  minOccurs="0" &gt;			&lt;element name="vw:simple"  minOccurs="0" aspect="simple"  ref="vw:simple"/&gt;			&lt;element name="vw:object"  minOccurs="0" aspect="object"  ref="vw:object"/&gt;			&lt;element name="vw:struct"  minOccurs="0" aspect="struct"  ref="vw:struct"/&gt;			&lt;element name="vw:union"  minOccurs="0" aspect="union"  ref="vw:union"/&gt;			&lt;element name="vw:list"  minOccurs="0" aspect="list"  ref="vw:list"/&gt;			&lt;element name="vw:sequence_of"  minOccurs="0" aspect="sequence_of"  ref="vw:sequence_of"/&gt;		&lt;/choice&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="vw:element" smalltalkClass="ElementMarshaler" constraint="extension" baseType="vw:relation"/&gt;&lt;object name="vw:text" smalltalkClass="TextMarshaler" constraint="extension" baseType="vw:relation"/&gt;&lt;object name="vw:implicit" smalltalkClass="ImplicitMarshaler" &gt;	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;attribute name="nillable" aspect="xmlNillable" ref="xsd:string"/&gt;	&lt;attribute name="ref"  aspect="x2oType" ref="xsd:QName"/&gt; &lt;/object&gt;&lt;object name="vw:simple"  smalltalkClass="SimpleObjectMarshaler" &gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="baseType" aspect="xmlBaseType" ref="xsd:QName"/&gt; 	&lt;all&gt;		&lt;element name="totalDigits" aspect="xmlTotalDigits" minOccurs="0" ref="vw:restriction"/&gt;		&lt;element name="fractionDigits" aspect="xmlFractionDigits" minOccurs="0" ref="vw:restriction"/&gt;		&lt;element name="length" aspect="xmlLength" minOccurs="0" ref="vw:restriction"/&gt; 		&lt;element name="minLength" aspect="xmlMinLength" minOccurs="0" ref="vw:restriction"/&gt;		&lt;element name="maxLength" aspect="xmlMaxLength" minOccurs="0" ref="vw:restriction"/&gt; 		&lt;element name="minExclusive" aspect="xmlMinExclusive" minOccurs="0" ref="vw:restriction"/&gt;		&lt;element name="maxExclusive" aspect="xmlMaxExclusive" minOccurs="0" ref="vw:restriction"/&gt; 		&lt;element name="minInclusive" aspect="xmlMinInclusive" minOccurs="0" ref="vw:restriction"/&gt;		&lt;element name="maxInclusive" aspect="xmlMaxInclusive" minOccurs="0" ref="vw:restriction"/&gt; 		&lt;element name="pattern" aspect="xmlPattern" minOccurs="0" ref="vw:restriction"/&gt;		&lt;element name="whiteSpace" aspect="xmlWhiteSpace" minOccurs="0" ref="vw:restriction"/&gt;		&lt;element name="enumeration" aspect="xmlEnumeration" minOccurs="0" maxOccurs="*" ref="vw:restriction"/&gt;		&lt;element name="vw:union" minOccurs="0" aspect="xmlUnion" ref="vw:union"/&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="vw:restriction" smalltalkClass="RestrictionMarshaler" &gt;	&lt;attribute name="vw:value" aspect="xmlValue" minOccurs="0"&gt; 		&lt;union&gt;			&lt;simple baseType="xsd:string"/&gt;			&lt;simple baseType="xsd:QName"/&gt;		&lt;/union&gt;	&lt;/attribute&gt;	&lt;attribute name="vw:id" minOccurs="0"  ref="xsd:string"/&gt; 	&lt;attribute name="vw:fixed" minOccurs="0"  ref="xsd:string"/&gt; &lt;/object&gt;&lt;object name="vw:union" smalltalkClass="UnionMarshaler" &gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="vw:memberTypes" aspect="xmlMemberTypes" ref="xsd:QNames"/&gt;	&lt;any namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded" name="xmlSimpleMarshalers"/&gt;&lt;/object&gt;&lt;object name="vw:list" smalltalkClass="ListMarshaler" &gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="vw:itemType" aspect="xmlItemType" ref="xsd:QName" minOccurs="0"/&gt;	&lt;element  name="vw:simple"  aspect="xmlSimpleType"  ref="vw:simple" minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="vw:attribute" smalltalkClass="AttributeMarshaler"&gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="aspect"  aspect="xmlAspect"   minOccurs="0"  ref="xsd:string"/&gt;	&lt;attribute name="default"  aspect="xmlDefaultValue" ref="xsd:string"/&gt;	&lt;attribute name="ref"  aspect="x2oType" ref="xsd:QName"/&gt; 	&lt;attribute name="use"  aspect="xmlUse" ref="xsd:string"/&gt; 	&lt;sequence&gt;		&lt;choice minOccurs="0" aspect="x2oSimpleContent"&gt;			&lt;element name="vw:simple"  minOccurs="0" aspect="simple"  ref="vw:simple"/&gt;			&lt;element name="vw:union"  minOccurs="0" aspect="union"  ref="vw:union"/&gt;			&lt;element name="vw:list"  minOccurs="0" aspect="list"  ref="vw:list"/&gt;		&lt;/choice&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="vw:implicitAttribute" smalltalkClass="ImplicitAttributeMarshaler" baseType="vw:attribute" constraint="extension"/&gt;&lt;object name="vw:object"  smalltalkClass="ComplexObjectMarshaler" &gt;	&lt;attribute name="name" aspect="x2oName" ref="xsd:string"/&gt;	&lt;attribute name="abstract"  minOccurs="0" aspect="xmlAbstract" ref="xsd:boolean"/&gt;	&lt;attribute name="smalltalkClass"  minOccurs="0" aspect="x2oSmalltalkClass" ref="xsd:string"/&gt;	&lt;attribute name="baseType" aspect="x2oBaseType" ref="xsd:QName"/&gt; 	&lt;attribute name="constraint" minOccurs="0"  aspect="extensionType" ref="xsd:string"/&gt; 	&lt;sequence&gt;		&lt;choice  name="x2oComplexTypeContentChoice"  minOccurs="0" &gt;			&lt;element name="vw:sequence" minOccurs="0"  aspect="xmlSequence" ref="vw:compositorType"/&gt;			&lt;element name="vw:choice" minOccurs="0"  aspect="xmlChoice" ref="vw:choice"/&gt;			&lt;element name="vw:group" minOccurs="0"  aspect="xmlGroup" ref="vw:group"/&gt;			&lt;element name ="vw:all"  minOccurs="0"  aspect="xmlAll" ref="vw:compositorType"/&gt;		&lt;/choice&gt;		&lt;element name="vw:attributeGroup" minOccurs="0" maxOccurs="*" aspect="x2oAttributeGroup" ref="vw:attributeGroup"/&gt;		&lt;any aspect="x2oAttributes" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;		&lt;element name="vw:text" minOccurs="0" aspect="xmlText" ref="vw:text"/&gt; 	&lt;/sequence&gt;&lt;/object&gt; &lt;object name="vw:struct"  smalltalkClass="StructMarshaler" constraint="extension" baseType="vw:object"/&gt;&lt;struct name="vw:compositorType"&gt;	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs" aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;any name="marshalers" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;&lt;/struct&gt;&lt;object name="vw:all"  smalltalkClass="UnorderedMarshaler"&gt;	&lt;any  aspect="marshalers" namespace="##targetNamespace"  minOccurs="0" maxOccurs="*" /&gt;&lt;/object&gt;&lt;object name="vw:sequence"  smalltalkClass="SequentialMarshaler"&gt;	&lt;attribute name="maxOccurs"  aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;attribute name="aspect"  aspect="x2oName" ref="xsd:string"/&gt;	&lt;any aspect="marshalers" namespace="##targetNamespace" maxOccurs="unbounded"/&gt;&lt;/object&gt;&lt;object name="vw:choice"  smalltalkClass="ChoiceMarshaler"  constraint="extension" baseType="vw:sequence"/&gt;&lt;object name="vw:choiceRelation" smalltalkClass="ChoiceRelation" constraint="extension" baseType="vw:choice"/&gt;&lt;object name="vw:sequence_of" smalltalkClass="CollectionObjectMarshaler" &gt;	&lt;attribute name="name" aspect="x2oName" ref="xsd:string"/&gt;		&lt;attribute name="smalltalkClass"  minOccurs="0" aspect="x2oSmalltalkClass" ref="xsd:string"/&gt;	&lt;any namespace="##targetNamespace"  aspect="elementMarshaler"/&gt;&lt;/object&gt;&lt;object name="vw:modelGroup"  smalltalkClass="ModelGroupMarshaler"&gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;sequence&gt;		&lt;any aspect="x2oRelations" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="vw:modelAttributeGroup" smalltalkClass="ModelAttributeGroupMarshaler" constraint="extension" baseType="vw:modelGroup"/&gt;&lt;object name="vw:group" smalltalkClass="GroupMarshaler"&gt;	&lt;attribute name="ref"  aspect="xmlRef" ref="xsd:QName"/&gt; 	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;&lt;/object&gt;&lt;object name="vw:attributeGroup" smalltalkClass="AttributeGroupMarshaler"&gt;	&lt;attribute name="ref"  aspect="xmlRef" ref="xsd:QName"/&gt; &lt;/object&gt;&lt;object name="vw:any" smalltalkClass="AnyRelationMarshaler"&gt;	&lt;attribute name="namespace"  aspect="xmlNamespaceFilter" ref="xsd:string"/&gt;	&lt;attribute name="aspect"  aspect="xmlAspect" ref="xsd:string"/&gt;	&lt;attribute name="maxOccurs"  aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;attribute name="processContents"  aspect="xmlProcessContents" ref="xsd:string"  minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="vw:anyAttribute" smalltalkClass="AnyAttributeMarshaler" constraint="extension" baseType="vw:any"/&gt;&lt;object name="vw:soapArray" smalltalkClass="SoapArrayMarshaler"&gt;	&lt;attribute name="name"  aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="dimension"  aspect="x2oDimension" ref="xsd:string"/&gt;	&lt;attribute name="ref"  aspect="x2oRef" ref="xsd:QName"/&gt; &lt;/object&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="XMLObjectMarshalers">xmlBinding1998Namespace"http://www.w3.org/XML/1998/namespaceThe namespace whose name is http://www.w3.org/XML/1998/namespace is bound by definition to the prefix xml: according to Namespaces in XML (and by Namespaces in XML 1.1).Note that unlike all other XML namespaces, both the name and the prefix are specified; i.e., if you want XML 1.0 processors to recognize this namespace, you must use the reserved prefix xml:."	^'&lt;xmlToSmalltalkBinding targetNamespace="http://www.w3.org/XML/1998/namespace" defaultQualifier="xml"xmlns:xml="http://www.w3.org/XML/1998/namespace"xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;	&lt;attribute name="base" ref="xsd:anyURI"/&gt;	&lt;attribute name="id" ref="xsd:ID"/&gt;	&lt;attribute name="lang"&gt;		&lt;union memberTypes="xsd:language"&gt;			&lt;simple baseType="xsd:string" length="0"/&gt;		&lt;/union&gt;	&lt;/attribute&gt;	&lt;attribute name="space" ref="xsd:string"/&gt;	&lt;modelAttributeGroup name="specialAttrs"&gt;		&lt;implicitAttribute ref="xml:base"/&gt;		&lt;implicitAttribute ref="xml:id"/&gt;		&lt;implicitAttribute ref="xml:lang"/&gt;		&lt;implicitAttribute ref="xml:space" /&gt;	&lt;/modelAttributeGroup&gt;&lt;/xmlToSmalltalkBinding&gt;'</body><body package="XMLObjectMarshalers">xml_SchemaSpecification"The mapping creates marshalers to build &lt;xsd:schema&gt; nodes from XMLObjectBinding object  "	^'&lt;?xml version ="1.0"?&gt;&lt;!-- XML Schema binding --&gt;&lt;xmlToSmalltalkBinding name="XMLSchema" 	defaultClassNamespace="WebServices"	targetNamespace="http://www.w3.org/2001/XMLSchema/Mapping"	useInlineType="false"	useReference="false"	useTaggedObject="false"	elementFormDefault="qualified"	usePrefixedSchemaTags="false"	xmlns:xsd="http://www.w3.org/2001/XMLSchema"	xmlns:tns="http://www.w3.org/2001/XMLSchema/Mapping"&gt;&lt;importBinding namespace="http://www.w3.org/XML/1998/namespace" /&gt;&lt;object  name="xsd:schema" smalltalkClass="XMLObjectBinding"&gt;	&lt;attribute name="targetNamespace" aspect="xmlTargetNamespace"  ref="xsd:string"   minOccurs="0"  /&gt;	&lt;attribute name="name" aspect="xmlName" minOccurs="0"  ref="xsd:string"/&gt;	&lt;attribute name="elementFormDefault" aspect="xmlElementFormDefault"  ref="xsd:string"/&gt;	&lt;attribute name="attributeFormDefault" aspect="xmlAttributeFormDefault"  ref="xsd:string"/&gt;	&lt;attribute name="version" aspect="version"  ref="xsd:string"/&gt;	&lt;implicitAttribute ref="xml:lang"/&gt;	&lt;attribute name="id" ref="xsd:ID"/&gt;	&lt;sequence&gt;		&lt;element name="xsd:import"  minOccurs="0" maxOccurs="*" aspect="xmlImports"  ref="tns:importType"/&gt;		&lt;any aspect="xmlMarshalers" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object  name="importType" smalltalkClass="BindingImport"&gt;	&lt;attribute name="namespace" ref="xsd:string" minOccurs="0"/&gt;	&lt;attribute name="schemaLocation" aspect="location" ref="xsd:string" minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="relation"  smalltalkClass="RelationMarshaler"&gt;	&lt;attribute name="name"  aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;attribute name="nillable" aspect="xmlNillable" ref="xsd:string"/&gt;	&lt;attribute name="default"  aspect="xmlDefaultValue" ref="xsd:string"/&gt;	&lt;attribute name="type"  aspect="xmlType" ref="xsd:QName"/&gt; 	&lt;attribute name="ref"  aspect="xmlRef" ref="xsd:QName"/&gt; 	&lt;sequence&gt;		&lt;any aspect="xmlLocalContents" namespace="##targetNamespace" minOccurs="0" maxOccurs="unbounded"/&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="xsd:element" smalltalkClass="ElementMarshaler" baseType="tns:relation"  constraint="extension" /&gt;&lt;object name="implicit" tag="xsd:element" smalltalkClass="ImplicitMarshaler"  baseType="tns:relation"  constraint="extension" /&gt;&lt;object name="implicitAttribute" tag="xsd:attribute" smalltalkClass="ImplicitAttributeMarshaler"  baseType="xsd:attribute"  constraint="extension" /&gt;&lt;object name="xsd:simpleType"  smalltalkClass="SimpleObjectMarshaler" &gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;all&gt;		&lt;element name="xsd:restriction" minOccurs="0"  aspect="xmlRestriction" ref="tns:restrictionType"/&gt;		&lt;element name="xsd:union" minOccurs="0"  aspect="xmlUnion" ref="tns:unionType"/&gt;		&lt;element name="xsd:list" minOccurs="0"  aspect="xmlList" ref="tns:listType"/&gt;	&lt;/all&gt;&lt;/object&gt;&lt;struct name="restrictionType"&gt;	&lt;attribute name="xsd:base" aspect="xmlBaseType" ref="xsd:QName"/&gt; 	&lt;all&gt;		&lt;element name="totalDigits"  minOccurs="0" ref="tns:restriction"/&gt;		&lt;element name="fractionDigits"  minOccurs="0" ref="tns:restriction"/&gt;		&lt;element name="length" minOccurs="0" ref="tns:restriction"/&gt; 		&lt;element name="minLength"  minOccurs="0" ref="tns:restriction"/&gt;		&lt;element name="maxLength"  minOccurs="0" ref="tns:restriction"/&gt; 		&lt;element name="minExclusive"  minOccurs="0" ref="tns:restriction"/&gt;		&lt;element name="maxExclusive"  minOccurs="0" ref="tns:restriction"/&gt;		&lt;element name="minInclusive"  minOccurs="0" ref="tns:restriction"/&gt; 		&lt;element name="maxInclusive"  minOccurs="0" ref="tns:restriction"/&gt; 		&lt;element name="pattern"  minOccurs="0" ref="tns:restriction"/&gt;		&lt;element name="whiteSpace"  minOccurs="0" ref="tns:restriction"/&gt;		&lt;element name="enumeration" minOccurs="0" maxOccurs="*" ref="tns:restriction"/&gt;	&lt;/all&gt;&lt;/struct&gt;&lt;object name="restriction" smalltalkClass="RestrictionMarshaler" &gt;	&lt;attribute name="value" aspect="xmlValue" minOccurs="0"&gt; 		&lt;union&gt;			&lt;simple baseType="xsd:string"/&gt;			&lt;simple baseType="xsd:QName"/&gt;		&lt;/union&gt;	&lt;/attribute&gt;	&lt;attribute name="id" minOccurs="0"  ref="xsd:string"/&gt; 	&lt;attribute name="fixed" minOccurs="0"  ref="xsd:string"/&gt; &lt;/object&gt;&lt;object name="union" tag="xsd:simpleType"  smalltalkClass="UnionMarshaler" &gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;element name="xsd:union" aspect="xmlUnion" minOccurs="0" ref="tns:unionType"/&gt; &lt;/object&gt;&lt;struct name="unionType"&gt;	&lt;attribute name="xsd:memberTypes" aspect="memberTypes" ref="xsd:QNames"/&gt;	&lt;any aspect="simpleTypes" namespace="##targetNamespace" minOccurs="0" maxOccurs="unbounded"/&gt;&lt;/struct&gt;&lt;object name="list" tag="xsd:simpleType"  smalltalkClass="ListMarshaler"&gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;element name="xsd:list" aspect="xmlList" minOccurs="0" ref="tns:listType"/&gt; &lt;/object&gt;&lt;struct name="listType"&gt;	&lt;attribute name="xsd:itemType" aspect="itemType" ref="xsd:QName" minOccurs="0" /&gt;	&lt;element name="xsd:simpleType" aspect="simpleType" ref="xsd:simpleType"  minOccurs="0"/&gt;&lt;/struct&gt;&lt;object name="xsd:attribute" smalltalkClass="AttributeMarshaler"&gt;	&lt;attribute name="type"  aspect="xmlType" ref="xsd:QName"/&gt; 	&lt;attribute name="ref"  aspect="xmlRef" ref="xsd:QName"/&gt; 	&lt;attribute name="use"  aspect="xmlUse" ref="xsd:string"/&gt; 	&lt;attribute name="default"  aspect="xmlDefaultValue" ref="xsd:string"/&gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string" required="true"/&gt;	&lt;sequence&gt;		&lt;any name="xmlSimpleContent" namespace="##targetNamespace" minOccurs="0"/&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="xsd:complexType"  smalltalkClass="ComplexObjectMarshaler" &gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;attribute name="abstract" aspect="xmlAbstract" ref="xsd:boolean"/&gt;	&lt;sequence&gt;		&lt;choice  name="xmlComplexTypeContentChoice"  minOccurs="0" &gt;			&lt;element name="xsd:sequence" minOccurs="0"  aspect="xmlSequence" ref="tns:compositorType"/&gt;			&lt;element name="xsd:all" minOccurs="0"  aspect="xmlAll" ref="tns:compositorType"/&gt;			&lt;element name="xsd:choice" minOccurs="0"  aspect="xmlChoice" ref="xsd:choice"/&gt;			&lt;element name="xsd:group" minOccurs="0"  aspect="xmlGroup" ref="xsd:group"/&gt;			&lt;element name ="xsd:complexContent"  minOccurs="0"  aspect="xmlComplexContent" ref="tns:complexContentType"/&gt;			&lt;element name ="xsd:simpleContent"  minOccurs="0"  aspect="xmlSimpleContent" ref="tns:complexContentType"/&gt;		&lt;/choice&gt;		&lt;element name="xsd:attributeGroup" minOccurs="0" maxOccurs="*" aspect="xmlAttributeGroup" ref="xsd:attributeGroup"/&gt;		&lt;any aspect="xmlAttributes" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;	&lt;/sequence&gt;&lt;/object&gt; &lt;object name ="struct" tag="xsd:complexType" smalltalkClass="StructMarshaler" constraint="extension" baseType="xsd:complexType"/&gt;&lt;struct name="compositorType"&gt;	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs" aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;any name="marshalers" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;&lt;/struct&gt;&lt;object name="xsd:sequence"  smalltalkClass="SequentialMarshaler"&gt;	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs" aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;any name="marshalers" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;&lt;/object&gt;&lt;object name="xsd:all"  smalltalkClass="UnorderedMarshaler"&gt;	&lt;any name="marshalers" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;&lt;/object&gt;&lt;struct name="complexContentType"&gt;	&lt;sequence&gt;		&lt;choice  name="xmlChoiceValue"  minOccurs="0" &gt;			&lt;element  name="xsd:extension" aspect="extension" ref="tns:extensionType"/&gt;			&lt;element  name="xsd:restriction" aspect="restriction" ref="tns:extensionType"/&gt;		&lt;/choice&gt;	&lt;/sequence&gt;&lt;/struct&gt;&lt;struct name="extensionType"&gt;	&lt;attribute name="xsd:base" ref="xsd:QName"/&gt; 	&lt;all&gt;		&lt;any minOccurs="0" maxOccurs="*" aspect="attributes"/&gt;		&lt;element name="xsd:attributeGroup" minOccurs="0" maxOccurs="*" aspect="attributeGroup" ref="xsd:attributeGroup"/&gt;		&lt;element name="xsd:sequence" aspect="xmlSequence" minOccurs="0"   ref="tns:compositorType"/&gt;		&lt;element name="xsd:all" minOccurs="0"  aspect="xmlAll" ref="tns:compositorType"/&gt;		&lt;element name="xsd:choice" minOccurs="0"  aspect="xmlChoice" ref="xsd:choice"/&gt;	&lt;/all&gt;&lt;/struct&gt;&lt;object name="xsd:choice"  smalltalkClass="ChoiceMarshaler"&gt;	&lt;attribute name="maxOccurs"  aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;	&lt;sequence&gt;		&lt;any name="marshalers" namespace="##targetNamespace" minOccurs="0"  maxOccurs="unbounded"/&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="xsd:choiceRelation"  tag="xsd:choice" smalltalkClass="ChoiceRelation" baseType="xsd:choice" constraint="extension"/&gt;&lt;object name="sequence" tag="xsd:complexType"  smalltalkClass="CollectionObjectMarshaler" constraint="extension" baseType="xsd:complexType"/&gt;&lt;object name="modelGroup" tag="xsd:group"  smalltalkClass="ModelGroupMarshaler"&gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;sequence&gt;		&lt;choice  name="xmlComplexTypeContentChoice"  minOccurs="0" &gt;			&lt;element name="xsd:sequence" minOccurs="0"  aspect="xmlSequence" ref="tns:compositorType"/&gt;			&lt;element name="xsd:choice" minOccurs="0"  aspect="xmlChoice" ref="xsd:choice"/&gt;		&lt;/choice&gt;	&lt;/sequence&gt;&lt;/object&gt;&lt;object name="xsd:group" smalltalkClass="GroupMarshaler"&gt;	&lt;attribute name="ref"  aspect="xmlRef" ref="xsd:QName"/&gt; 	&lt;attribute name="maxOccurs" aspect="xmlMaxOccurs" ref="xsd:string"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"/&gt;&lt;/object&gt;&lt;object name="modelAttributeGroup" tag="xsd:attributeGroup"  smalltalkClass="ModelAttributeGroupMarshaler" &gt;	&lt;attribute name="name" aspect="xmlName" ref="xsd:string"/&gt;	&lt;all&gt;		&lt;any minOccurs="0" maxOccurs="*" aspect="xmlAttributes"/&gt;		&lt;element name="xsd:attributeGroup" minOccurs="0" maxOccurs="*" aspect="xmlAttributeGroup" ref="xsd:attributeGroup"/&gt;	&lt;/all&gt;&lt;/object&gt;&lt;object name="xsd:attributeGroup" smalltalkClass="AttributeGroupMarshaler"&gt;	&lt;attribute name="ref"  aspect="xmlRef" ref="xsd:QName"/&gt; &lt;/object&gt;&lt;object name="xsd:any" smalltalkClass="AnyRelationMarshaler"&gt;	&lt;attribute name="namespace"  aspect="xmlNamespaceFilter" ref="xsd:string"  minOccurs="0"/&gt;	&lt;attribute name="maxOccurs"  aspect="xmlMaxOccurs" ref="xsd:string"  minOccurs="0"/&gt;	&lt;attribute name="minOccurs"  aspect="xmlMinOccurs" ref="xsd:string"  minOccurs="0"/&gt;	&lt;attribute name="processContents"  aspect="xmlProcessContents" ref="xsd:string"  minOccurs="0"/&gt;&lt;/object&gt;&lt;object name="xsd:anyAttribute" tag="xsd:anyAttribute"  smalltalkClass="AnyAttributeMarshaler" constraint="extension" baseType="xsd:any"/&gt;&lt;object name="soapArray" tag="xsd:complexType" smalltalkClass="SoapArrayMarshaler" constraint="extension" baseType="xsd:complexType"/&gt;&lt;/xmlToSmalltalkBinding&gt;'</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>specification - uri</category><body package="XMLObjectMarshalers">defaultUriSchemaInstance" Answer URI of XMLSchema-instance namespace "	^'http://www.w3.org/2001/XMLSchema-instance'</body><body package="XMLObjectMarshalers">defaultUriXsd" Answer URI of XSchema namespace "	^XMLBuildingPolicy defaultUriXsd</body><body package="XMLObjectMarshalers">uri1999Xsd" Answer URI of XSchema namespace "	^'http://www.w3.org/1999/XMLSchema'</body><body package="XMLObjectMarshalers">uri200010Xsd" Answer URI of XSchema namespace "	^'http://www.w3.org/2000/10/XMLSchema'</body><body package="XMLObjectMarshalers">uri2000Xsd" Answer URI of XSchema namespace "	^'http://www.w3.org/2000/XMLSchema'</body><body package="XMLObjectMarshalers">uri2001Xsd" Answer URI of XSchema namespace "	^'http://www.w3.org/2001/XMLSchema'</body><body package="XMLObjectMarshalers">uriVWBinding" Answer namespace of VisualWorks schema binding "	^XMLBuildingPolicy uriVWBinding</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>specification - load</category><body package="XMLObjectMarshalers">loadVWBinding	" self loadVWBinding "	XMLObjectBinding loadFrom: self defaultVWBindingLocation readStream.	XMLObjectBinding vwBinding isNil 		ifTrue: 			[^self error: ((#VWBindingBindingIsNotFound &lt;&lt; #webservices &gt;&gt; 'VWBinding binding is not found at &lt;1s&gt;')							expandMacrosWith: self defaultVWBindingLocation asString)].</body><body package="XMLObjectMarshalers">loadXsdBinding	" self loadXsdBinding "	XMLObjectBinding loadFrom: self defaultXsdBindingLocation1999 readStream.	XMLObjectBinding loadFrom: self defaultXsdBindingLocation2000 readStream.	XMLObjectBinding loadFrom: self defaultXsdBindingLocation2000_10 readStream.	XMLObjectBinding loadFrom: self defaultXsdBindingLocation2001 readStream.	XMLObjectBinding xsdBinding isNil 		ifTrue: 			[^self error: ((#XsdBindingBindingIsNotFound &lt;&lt; #webservices &gt;&gt; 'XsdBinding binding is not found at &lt;1s&gt;')							expandMacrosWith: self defaultXsdBindingLocation asString)].	XMLObjectBinding loadFrom: self xmlBinding1998Namespace readStream.</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>default values</category><body package="XMLObjectMarshalers">defaultTargetNamespaceValue	^'urn:vwservices'</body><body package="XMLObjectMarshalers">nilNodeTag	^nilNodeTag		ifNil: [nilNodeTag := NodeTag qualifier: '' ns: self defaultUriSchemaInstance type: 'nil']		ifNotNil: [nilNodeTag]</body><body package="XMLObjectMarshalers">useInlineTypeValue	^false</body><body package="XMLObjectMarshalers">usePrefixedSchemaTagsValue	^true</body><body package="XMLObjectMarshalers">useReferenceValue	^false</body><body package="XMLObjectMarshalers">useTaggedObjectValue	^true</body><body package="XMLObjectMarshalers">useXPathValue	^false</body><body package="XMLObjectMarshalers">xmlEncodingValue	^#'utf-8'</body><body package="XMLObjectMarshalers">xmlVersionValue	^#'1.0'</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">defaultTargetNamespace	defaultTargetNamespace ifNil: [ defaultTargetNamespace := self defaultTargetNamespaceValue].	^defaultTargetNamespace</body><body package="XMLObjectMarshalers">defaultTargetNamespace: aString	defaultTargetNamespace := aString</body><body package="XMLObjectMarshalers">prolog	^ '&lt;?xml version="',  self xmlVersionValue, '" encoding="', self xmlEncoding, '" ?&gt;'</body><body package="XMLObjectMarshalers">useInlineType	^useInlineType ifNil: [  self useInlineTypeValue ]</body><body package="XMLObjectMarshalers">useInlineType: aBoolean	useInlineType := aBoolean</body><body package="XMLObjectMarshalers">usePrefixedSchemaTags	^usePrefixedSchemaTags ifNil: [ self usePrefixedSchemaTagsValue]</body><body package="XMLObjectMarshalers">usePrefixedSchemaTags: aBoolean	usePrefixedSchemaTags := aBoolean</body><body package="XMLObjectMarshalers">useReference	^useReference ifNil: [  self useReferenceValue]</body><body package="XMLObjectMarshalers">useReference: aBoolean	useReference := aBoolean</body><body package="XMLObjectMarshalers">useTaggedObject	^useTaggedObject ifNil: [useTaggedObject := self useTaggedObjectValue ]</body><body package="XMLObjectMarshalers">useTaggedObject: aBoolean	useTaggedObject := aBoolean</body><body package="XMLObjectMarshalers">xmlEncoding	xmlEncoding ifNil: [ xmlEncoding := self xmlEncodingValue].	^xmlEncoding</body><body package="XMLObjectMarshalers">xmlEncoding: aString		xmlEncoding := aString</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>loading</category><body package="XMLObjectMarshalers">buildBindings: aCollectionOfXMLElements"This method allows to load a few xmlToSmalltalk bindings. The expected collection includes xml like this:#(&lt;xmlToSmalltalkBinding ...  &lt;/xmlToSmalltalkBinding&gt;, ..&lt;xmlToSmalltalkBinding ..  &lt;/xmlToSmalltalkBinding&gt;)Returns: Collection of XMLToObjectBindings"	^XMLObjectDriver buildBindingFromElements: aCollectionOfXMLElements</body><body package="XMLObjectMarshalers">load: aFilenameString" Load binding from specified file "	^XMLObjectDriver load: aFilenameString</body><body package="XMLObjectMarshalers">loadBindings: aStream"This method allows to load a few xmlToSmalltalk bindings. The expected stream includes xml like this:&lt;schemaBindings&gt;	&lt;xmlToSmalltalkBinding ...  &lt;/xmlToSmalltalkBinding&gt;	&lt;xmlToSmalltalkBinding ..  &lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;Returns: Collection of XMLToObjectBindings"	| dom |	dom := WSSAXDriver on: aStream.	^self buildBindings: dom root realElements.</body><body package="XMLObjectMarshalers">loadFrom: aStream" Load binding from specified stream ""The expected stream includes xml like this:	&lt;xmlToSmalltalkBinding ...  &lt;/xmlToSmalltalkBinding&gt;"	^XMLObjectDriver loadFrom: aStream</body></methods><methods><class-id>WebServices.XMLObjectBinding class</class-id> <category>utilities</category><body package="XMLObjectMarshalers">marshal: anObject atNamespace: aString	|  binding |	binding := self			bindingAtNamespace: aString			ifAbsent: [self error: ((#NoBindingForNS &lt;&lt; #webservices &gt;&gt; 'No binding defined for namespace: &lt;1s&gt;')									expandMacrosWith: aString) ].	^binding  marshal: anObject</body><body package="XMLObjectMarshalers">unmarshal: aStream atNamespace: aString	|  binding |	binding := self			bindingAtNamespace: aString			ifAbsent: [self error: ((#NoBindingForNS &lt;&lt; #webservices &gt;&gt; 'No binding defined for namespace: &lt;1s&gt;')									expandMacrosWith: aString) ].	^binding unmarshal: ((XMLParser on: aStream)						validate: false;						scanDocument)						root.</body></methods><methods><class-id>WebServices.AnyAttributeMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isAnyAttributeMarshaler	^true</body><body package="XMLObjectMarshalers">isAnyRelationMarshaler	^false</body><body package="XMLObjectMarshalers">isAttribute	^true</body><body package="XMLObjectMarshalers">useTaggedObject: marshalingContext	^true</body></methods><methods><class-id>WebServices.AnyAttributeMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">setRelationFrom: attributesx in: builder	relation := ManyRelation fromAttributes:  attributesx from: self.	relation minOccurs: 0.</body></methods><methods><class-id>WebServices.AnyAttributeMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">missingValueNotification</body><body package="XMLObjectMarshalers">unmarshalCollectionFrom: marshalingContext do: aBlock	| coll |	coll := OrderedCollection new.	marshalingContext nodes do: [ :attr | 		self  			unmarshalObjectFrom: marshalingContext  			do: [ :mc | coll add: mc value ]].	marshalingContext 		aspect: self relation;		value: coll.	aBlock value: marshalingContext</body></methods><methods><class-id>WebServices.AnyAttributeMarshaler</class-id> <category>private</category><body package="XMLObjectMarshalers">canAcceptMarshaler: aTypeMarshaler	^aTypeMarshaler isAttribute or: [aTypeMarshaler isAttributeGroup ]</body></methods><methods><class-id>WebServices.AnyAttributeMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">addNamespaceToSource: marshalingContext</body><body package="XMLObjectMarshalers">valueFrom: anObject marshalingContext: marshalingContext	(anObject value isKindOf: Attribute)		ifTrue: [^(processContents = #lax or: [processContents = #skip])					ifTrue: [	marshalingContext setQualifierForAttributeNode: anObject value tag.							marshalingContext parent addAttributeNode: anObject value. nil]					ifFalse: [self error: (#AnXMLAttributeShouldNotBeValueForStrict &lt;&lt;#webservices &gt;&gt; 'An XML Attribute should not be provided as a value for #strict processContents ')]].	processContents = #skip ifTrue: [^nil].	^anObject value</body></methods><methods><class-id>WebServices.AnyAttributeMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlMaxOccurs	^nil</body><body package="XMLObjectMarshalers">xmlMinOccurs	^nil</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	registeredObjects  := IdentityDictionary new: 50.	keyToObjectTable := OrderedCollection new: 50.	needToResolveList := OrderedCollection new: 50.	significantNamespaces := Dictionary new: 5.	qualifierMap := Dictionary new: 5.	qualifierMap at: XMLBuildingPolicy defaultUriXsd  put: 'xsd'.	suffixMap := Dictionary new: 5.	self resetMaps.	currentId := 0.	wildcardScope := OrderedCollection new.</body><body package="XMLObjectMarshalers">initializeIdRefNodes	idTag := self class idTagDefault.	refTag  := self class refTagDefault.</body><body package="XMLObjectMarshalers">resetMaps	idMap := Dictionary new: 50.	idMapReverse := IdentityDictionary new: 50.</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager</class-id> <category>accessing</category><body package="XMLObjectMarshalers">addBinding: aBinding	binding == nil		ifTrue: [binding := aBinding]		ifFalse: [binding importBinding: aBinding]</body><body package="XMLObjectMarshalers">addToWildcardScope: nsStringOrBinding	| xmlBinding |	xmlBinding := nsStringOrBinding isString		ifTrue: [ XMLObjectBinding bindingAtNamespace: nsStringOrBinding ifAbsent: [self error: ((#ThereIsNoSuchBinding &lt;&lt; #webservices &gt;&gt;'There is bo registered XMLObjectBinding at: &lt;1s&gt; ') expandMacrosWith: nsStringOrBinding )]]		ifFalse: [ nsStringOrBinding  ].	wildcardScope add: xmlBinding</body><body package="XMLObjectMarshalers">atID: aString put: aHrefMarshaler	"StB redundant Dictionary added for performance"		self idMapReverse at: aHrefMarshaler value put: aHrefMarshaler.	^self idMap at: aString put: aHrefMarshaler</body><body package="XMLObjectMarshalers">binding	^binding</body><body package="XMLObjectMarshalers">binding: aBinding	binding := aBinding</body><body package="XMLObjectMarshalers">deregister: anObject 	^registeredObjects removeKey: anObject</body><body package="XMLObjectMarshalers">hrefMarshalers	^self idMap values</body><body package="XMLObjectMarshalers">idMap	^idMap</body><body package="XMLObjectMarshalers">idMap: aDictionary	idMap := aDictionary</body><body package="XMLObjectMarshalers">idMapReverse	^idMapReverse</body><body package="XMLObjectMarshalers">idTag	idTag ifNil: [self initializeIdRefNodes].	^idTag</body><body package="XMLObjectMarshalers">idTag: aNodeTag	idTag := aNodeTag</body><body package="XMLObjectMarshalers">nextID	| stream |	currentId := currentId + 1.	stream := (String new: 10) writeStream.	stream nextPutAll: 'id'.	currentId printOn: stream.	^stream contents</body><body package="XMLObjectMarshalers">qualifierMap	^qualifierMap</body><body package="XMLObjectMarshalers">refTag	refTag ifNil: [self initializeIdRefNodes].	^refTag</body><body package="XMLObjectMarshalers">refTag: aNodeTag	refTag := aNodeTag</body><body package="XMLObjectMarshalers">register: anObject asXmlTag: anXmlNodeTag	| marshaler |	marshaler := self 					marshalerForTag: anXmlNodeTag					ifAbsent: [self notifyNoMarshalerFor: anObject ].	^self register: anObject marshalWith: marshaler.</body><body package="XMLObjectMarshalers">register: anObject marshalWith: marshaler	^registeredObjects at: anObject put: marshaler</body><body package="XMLObjectMarshalers">registeredObjects	^registeredObjects</body><body package="XMLObjectMarshalers">significantNamespaces	^significantNamespaces</body><body package="XMLObjectMarshalers">suffixMap	^suffixMap</body><body package="XMLObjectMarshalers">unresolvedReferences	^needToResolveList collect: [ :each | each key ].</body><body package="XMLObjectMarshalers">wildcardScope	^wildcardScope</body><body package="XMLObjectMarshalers">wildcardScope: xmlObjectBindings	wildcardScope := xmlObjectBindings</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager</class-id> <category>namespaces</category><body package="XMLObjectMarshalers">getExistingQualifierFor: aNamespace	"Answer any existing qualifier to the given namespace."	^(self qualifierMap at: aNamespace ifAbsent: [nil ])		ifNotNil: [ :q | self 						significantNamespaces at: q						ifAbsent: [self significantNamespaces at: q put: aNamespace.] .				q ]</body><body package="XMLObjectMarshalers">includesNamespaceQualifier: aString	"Answer any existing qualifier to the given namespace."	^self significantNamespaces includesKey: aString</body><body package="XMLObjectMarshalers">nextSuffixFor: aQualifier"The receiver is searching for an available suffix to create a name space qualifier for an object.  Look up the qualifier in the suffix map to find the last value assigned for it.  Increment the count and save and return the new value."	| count |	count := self suffixMap at: aQualifier ifAbsent: [-1].	^self suffixMap at: aQualifier put: count + 1</body><body package="XMLObjectMarshalers">qualifierFor: aProposedQualifier namespace: aString default: defaultQualifier" Obtain qualifier for given namespace. Answer qualifier of this namespace if it can be found in namespace map. Otherwise manufacture a new qualifier in such a way that it does not match any of qualifiers in eiher namespaces or in namespace map "	| prefix candidate |	prefix := aProposedQualifier notEmpty 		ifTrue: [aProposedQualifier]		ifFalse: 			[(defaultQualifier isNil or: [defaultQualifier isEmpty])				ifTrue: ['ns' ]				ifFalse: [ defaultQualifier ]].	candidate := prefix.	[self  includesNamespaceQualifier: candidate]		whileTrue:			[candidate := prefix, ((self  nextSuffixFor: prefix) printStringRadix: 16)].	^candidate.</body><body package="XMLObjectMarshalers">recordNamespace: aNamespace qualifier: aQualifier	"Answer any existing qualifier to the given namespace."	aQualifier = 'xml' ifTrue: [^nil].	self significantNamespaces at: aQualifier put: aNamespace.	^self qualifierMap at: aNamespace ifAbsentPut: [aQualifier]</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">encodeHrefAttributeFor: aString"A multi-reference simple or compound value is encoded as an independent element containing a local, unqualified attribute named 'id' and of type 'ID' per the XML Specification [7]. Each accessor to this value is an empty element having a local, unqualified attribute named 'href' and of type 'uri-reference' per the XML Schema Specification [11], with a 'href' attribute value of a URI fragment identifier referencing the corresponding independent element."		^Attribute name: (self idRefAttributeName: self refTag) value:  '#', aString</body><body package="XMLObjectMarshalers">encodeIdAttributeFor: aString	^Attribute name: (self idRefAttributeName: self idTag) value: aString</body><body package="XMLObjectMarshalers">idRefAttributeName: aNode	| qualifier |	(aNode namespace isNotEmpty and: [aNode qualifier isEmpty])		ifTrue: [( qualifier := self getExistingQualifierFor: aNode namespace) 				ifNil: [qualifier := self qualifierFor: 'enc' namespace: aNode namespace default: nil.					self recordNamespace: aNode namespace qualifier: qualifier].				aNode resetQualifierTo: qualifier ].	^aNode</body><body package="XMLObjectMarshalers">marshal: anObject	| marshaler |	marshaler := self 					marshalerForObject: anObject 					ifAbsent: [self notifyNoMarshalerFor: anObject].	^self marshal: anObject with: marshaler.</body><body package="XMLObjectMarshalers">marshal: anObject atNamespace: aString	| marshaler |	binding := self  bindingAtNamespace: aString.	marshaler := binding 					marshalerForClass: anObject class 					ifAbsent: [ self error: ((#NoMarshalerFor &lt;&lt; #webservices &gt;&gt; 'No marshaler for: &lt;1s&gt;')								expandMacrosWith: anObject class name asString) ].	^self marshal: anObject with: marshaler.</body><body package="XMLObjectMarshalers">marshal: anObject with: marshaler	| source mc q |  	self resetMaps. 	(mc := MarshalingContext marshaler: marshaler)		manager: self;		value: anObject.	marshaler setNodeAndMarshalFrom: mc. 	source := mc source. 	((source tag qualifier isEmpty) and: [(self significantNamespaces at: '' ifAbsent: [nil ]) isNil ])		ifTrue: [ (self getExistingQualifierFor: source tag namespace)				ifNotNil: [ :qx | q := qx ]				ifNil: [source tag namespace notEmpty ifTrue: [						 q := self qualifierFor: '' namespace: source tag namespace default: ''.						self recordNamespace: source tag namespace qualifier: q ]].				q ifNotNil: [source tag resetQualifierTo: q ]].	self significantNamespaces keysAndValuesDo: [ :key :value | source namespaceAt: key put: value ]. 	^source</body><body package="XMLObjectMarshalers">setHRefNode: anXmlElement for: aMarshalingContext	| hrefMarshaler idref |	(hrefMarshaler := self idMapReverse  at: aMarshalingContext value ifAbsent: [nil]) isNil		ifTrue: 			[idref := self nextID. 			hrefMarshaler := HrefMarshaler 								id: idref								value: aMarshalingContext value 								source: anXmlElement.			self  atID: idref  put: hrefMarshaler]		ifFalse: 				[anXmlElement ~= hrefMarshaler source				ifTrue: [ hrefMarshaler setReferenceFor: anXmlElement manager: self.						aMarshalingContext  beReference ]].	^anXmlElement</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager</class-id> <category>api -- resolving</category><body package="XMLObjectMarshalers">addKey: keyAssoc value: target	| resolved assoc |	assoc := Association key: keyAssoc value: target.	(keyToObjectTable includes: assoc ) 	ifFalse: [ keyToObjectTable add: assoc ].	resolved := needToResolveList select: 					[ :keyRefAssoc | 					(keyRefAssoc key key == keyAssoc key and:					[keyRefAssoc key value = keyAssoc value])						ifTrue: [keyRefAssoc value value: target. true]						ifFalse: [false]].	needToResolveList removeAll: resolved.</body><body package="XMLObjectMarshalers">defaultMarshalerForElement:  anElement	|  m  node |	node := anElement tag. 	anElement realElements size = 0		ifTrue: 			[ m := BindingBuilder newResolverAt: 'simple'.			m deserializationBlock: [ :mv :string :class | string ]]		ifFalse:			[(m := StructMarshaler new)  buildFromTag: node.			m smalltalkClass: WebServices.Struct].	^m</body><body package="XMLObjectMarshalers">defaultTargetFrom: marshalingContext" Resolve object for specified marshaler, evaluate the block with object as argument "	^marshalingContext marshaler newInstanceFor: marshalingContext.</body><body package="XMLObjectMarshalers">elementTypeFrom: anElement  attributeKey: aString ns: nsString	| v type q ns |	anElement isAttribute ifTrue: [^nil].	v := anElement valueOfAttribute: (NodeTag qualifier: '' ns: nsString type: aString ) ifAbsent: [^nil]. 	type := (( v indexOf: $: ) = 0		ifTrue: [q := ''. ns := anElement namespaceAtQualifier: q.  v]		ifFalse: 	[q := v copyUpTo: $: .				ns := anElement namespaceAtQualifier: q. 				v copyFrom: (q size + 2) to: v size]).	type := type copyUpTo: $[.						^NodeTag qualifier: q ns: ns type: type</body><body package="XMLObjectMarshalers">findKeyRefValueFor: anObject ifNone: aBlock	^(keyToObjectTable		detect: [ :assoc |  assoc value == anObject ]		ifNone: [^aBlock value]) key value</body><body package="XMLObjectMarshalers">findMarshalerForAnyType:  anElement"Resolving xsd:anyType "	^(self binding marshalerForTag: anElement tag ifAbsent: [nil])		ifNotNil: [ :m | m ]		ifNil: [ | m  |			"Check if there is xsi:type  attribute "			m := (self 					elementTypeFrom: anElement  					attributeKey: 'type' 					ns: XMLObjectBinding defaultUriSchemaInstance) 			ifNotNil: [:node | self binding typeMarshalerForTag: node ].			m ifNotNil: [ :mx | mx ] ifNil: [self defaultMarshalerForElement:  anElement ]].</body><body package="XMLObjectMarshalers">findTargetFrom: marshalingContext ifAbsent: aBlock	| ref assocx |	(ref := marshalingContext keyRef) ifNil: [ ^aBlock value].	assocx := (keyToObjectTable 			detect: [ :assoc |  					assoc key key == ref  key 						and: [[assoc key value = ref value] 						on: Error 						do: [ :ex | ex return: false]]]			ifNone: [^aBlock value]).	marshalingContext beReference.	^assocx value</body><body package="XMLObjectMarshalers">idAttributeFrom: anXMLElement	^anXMLElement valueOfAttribute: self idTag ifAbsent: [nil]</body><body package="XMLObjectMarshalers">refAttributeFrom: anXMLElement"A multi-reference simple or compound value is encoded as an independent element containing a local, unqualified attribute named 'id' and of type 'ID' per the XML Specification [7]. Each accessor to this value is an empty element having a local, unqualified attribute named 'href' and of type 'uri-reference' per the XML Schema Specification [11], with a 'href' attribute value of a URI fragment identifier referencing the corresponding independent element."	| refValue |	refValue := anXMLElement valueOfAttribute: self refTag ifAbsent: [^nil].	^refValue copyFrom: 2 to: refValue size</body><body package="XMLObjectMarshalers">register: marshalingContext do: aBlock	needToResolveList add: marshalingContext keyRef-&gt;aBlock</body><body package="XMLObjectMarshalers">registerKeysFrom: marshalingContext	" Process object's keys if any "	marshalingContext keys notNil		ifTrue: [marshalingContext keys 					do: [ :key | self addKey: key value: marshalingContext value]].	marshalingContext resetKeys.</body><body package="XMLObjectMarshalers">resolveFrom: marshalingContext do: aBlock" Resolve object for specified marshaled value, evaluate the block with object as argument when resolved. Note it may not be possible to resolve the target object at this time, which is the whole reason for having a callback block. If target can't be resolved, (keyRef, aBlock) is added to needToResolList. Every time a new key is registered, this list is rescanned trying to resolve existing entries with this key. When the target is finally resolved (immediately or in delayed fashion, aBlock is evaluated. The argument is the target object. Therefore, the calling code should be structured in such a manner that all computations that depend on the target object should be done inside aBlock "	| target |		" Resolve object using keys or a default mechanism "	target := (marshalingContext marshaler unmarshalHRefFrom:  marshalingContext)		ifTrue: [ marshalingContext value]		ifFalse: 			[self 				findTargetFrom: marshalingContext				ifAbsent: 					[marshalingContext keyRef ~~ nil						ifTrue: " If keyRef is resolved,  it is a forward ref; register key and callback until we can resolve it "							[self register: marshalingContext do: aBlock.							^self]						ifFalse: 	[self defaultTargetFrom: marshalingContext]]].	" If resolved, evaluated callback block, otherwise register key and callback until can resolve it "	aBlock value: target</body><body package="XMLObjectMarshalers">resolveHReference: aMarshalingContext fromElement: anXMLElement	(self binding useReference and: [anXMLElement notNil and: [anXMLElement isElement ]]) ifFalse: [ ^false].	(self idAttributeFrom: anXMLElement) 		ifNotNil: [ :id | | hrefMarshaler |				 hrefMarshaler := self idMap at: id ifAbsentPut: [HrefMarshaler source: anXMLElement].				(hrefMarshaler setReferencedValueFor: aMarshalingContext)					ifTrue: [^true ]					ifFalse: [hrefMarshaler value: aMarshalingContext]].	(self refAttributeFrom: anXMLElement) 		ifNotNil:	[ :refValue |			(self resolveID: refValue for: anXMLElement) 				ifNotNil: [ :hrefMarshaler | 						hrefMarshaler decodeAndUnmarshalFrom: aMarshalingContext.						^true ]].	^false</body><body package="XMLObjectMarshalers">resolveID: hrefId for: anXmlNode 	^self idMap at: hrefId		ifAbsent: 			["Get all ids from anywhere in document"			self setIdMapFrom: anXmlNode.			"Try again"			self idMap at: hrefId ifAbsent: [nil]]</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager</class-id> <category>api -- translate</category><body package="XMLObjectMarshalers">bindingAtNamespace: aString	^self class bindingAtNamespace: aString</body><body package="XMLObjectMarshalers">marshalerForObject: anObject	^self marshalerForObject: anObject ifAbsent: [nil]</body><body package="XMLObjectMarshalers">marshalerForObject: anObject ifAbsent: aBlock	^registeredObjects 		at: anObject 		ifAbsent: 			[(anObject isKindOf: Struct) 				ifTrue: [ binding marshalers detect: [ :mx | mx tag type = anObject name ] ifNone: [nil] ]				ifFalse: 	[binding marshalerForObject: anObject ifAbsent: aBlock]]</body><body package="XMLObjectMarshalers">marshalerForTag: anXmlNodeTag	^self binding marshalerForTag: anXmlNodeTag</body><body package="XMLObjectMarshalers">marshalerForTag: anXmlNodeTag ifAbsent: aBlock" Find any marshaler "	^binding marshalerForTag: anXmlNodeTag ifAbsent: aBlock.</body><body package="XMLObjectMarshalers">notifyNoMarshalerFor: anObject	^self binding notifyNoMarshalerFor: anObject</body><body package="XMLObjectMarshalers">notifyNoMarshalerFor: anObject text: aString	^self binding notifyNoMarshalerFor: anObject text: aString</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">setIdMapFrom: anXmlNode	| xp |	xp := XPathParser new parse: ('descendant-or-self::*/@', self idTag type) as: #locationPath.	(xp xpathValueFor: anXmlNode variables: nil) sortedNodes do:  [ :attr |		attr tag namespace = self idTag namespace			ifTrue: [ self idMap  at: attr value ifAbsentPut: [HrefMarshaler source: attr parent]]].</body><body package="XMLObjectMarshalers">unmarshal: anXmlNode	| marshaler |  	marshaler := self 					marshalerForTag: anXmlNode tag 					ifAbsent: [self notifyNoMarshalerFor: anXmlNode text: anXmlNode tag expandedName].	^self unmarshal: anXmlNode with: marshaler</body><body package="XMLObjectMarshalers">unmarshal: aStream atNamespace: aString	binding := self bindingAtNamespace: aString.	^self unmarshal: ((XMLParser on: aStream)						validate: false;						scanDocument)						root.</body><body package="XMLObjectMarshalers">unmarshal: anXmlNode with: aTypeMarshaler	| mv |	self resetMaps.	anXmlNode parent ifNil: [XML.Document new addNode: anXmlNode].	self setIdMapFrom: anXmlNode.	(mv := MarshalingContext marshaler: aTypeMarshaler)		manager: self;		source: anXmlNode;		nodeContext: (OrderedCollection with: anXmlNode);		unmarshalDo: [ :mc |  ^mc value ].	ObjectNotResolvedSignal raiseRequestWith: mv.</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">new	^super new initialize</body><body package="XMLObjectMarshalers">on: binding	^self new  		addBinding: binding;		yourself</body><body package="XMLObjectMarshalers">onBindingAtNamespace: aString	^self on: (self bindingAtNamespace: aString)</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager class</class-id> <category>utilities</category><body package="XMLObjectMarshalers">marshal: anObject atNamespace: aString	^self 		new		marshal: anObject atNamespace: aString</body><body package="XMLObjectMarshalers">printContentsFrom:  anXMLElement" The method creates the a XML message stream from the XML element. The stream can used in a HttpEntity body source"	| stream |  	stream := (EncodedStream 						on: (ReadWriteStream on: (ByteArray new: 1024))						encodedBy: (StreamEncoder new: self encoding) initializeForMemory)						lineEndLF.	stream 		nextPutAll: '&lt;?xml version="';		nextPutAll:  self xmlVersion;		nextPutAll: '" encoding="';		nextPutAll: self encoding asString asUppercase;		nextPutAll: '"?&gt;'; 		cr.	anXMLElement printCanonicalOn: stream. 	^stream reset</body><body package="XMLObjectMarshalers">readDocumentFrom: httpEntity"The method reads a decompressed and decoded HttpEntity body contents, parses it and returns XMLElement"	^([(XMLParser on: httpEntity contents readStream) validate: false; scanDocument]			on: SAXParseException do: [ :ex | ex parameter: httpEntity. ex pass])</body><body package="XMLObjectMarshalers">unmarshal: aStream atNamespace: aString	^self 		new		unmarshal: aStream atNamespace: aString</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager class</class-id> <category>defaults</category><body package="XMLObjectMarshalers">encoding	^#'UTF-8'</body><body package="XMLObjectMarshalers">xmlVersion	^'1.0'</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager class</class-id> <category>default values</category><body package="XMLObjectMarshalers">idNodeDefaultValue	^NodeTag new qualifier: '' ns: '' type: 'id'; yourself</body><body package="XMLObjectMarshalers">refNodeDefaultValue	^NodeTag new qualifier: '' ns: '' type: 'href'; yourself</body></methods><methods><class-id>WebServices.XMLObjectMarshalingManager class</class-id> <category>accessing</category><body package="XMLObjectMarshalers">bindingAtNamespace: aString	^XMLObjectBinding 			bindingAtNamespace: aString			ifAbsent: [self error: ((#NoBindingForNS &lt;&lt; #webservices &gt;&gt; 'No binding defined for namespace: &lt;1s&gt;')									expandMacrosWith: aString) ].</body><body package="XMLObjectMarshalers">idTagDefault	^idTagDefault ifNil: [ idTagDefault :=  self idNodeDefaultValue]</body><body package="XMLObjectMarshalers">idTagDefault: aNodeTag	idTagDefault := aNodeTag</body><body package="XMLObjectMarshalers">refTagDefault	^refTagDefault ifNil: [ refTagDefault :=  self refNodeDefaultValue]</body><body package="XMLObjectMarshalers">refTagDefault: aNodeTag	refTagDefault := aNodeTag</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>accessing</category><body package="XMLObjectMarshalers">aspectRelations	^#()</body><body package="XMLObjectMarshalers">conversionId	^conversionId</body><body package="XMLObjectMarshalers">deserializationBlock	^deserializationBlock</body><body package="XMLObjectMarshalers">deserializationBlock: aBlock	deserializationBlock := aBlock</body><body package="XMLObjectMarshalers">enumerationRestrictions	| enumRestrictions |	enumRestrictions := ( self restrictions 							detect: [ :restriction | restriction isEnumeration] 							ifNone: [^OrderedCollection new]) enumerationRestrictions.	baseType ifNotNil: [		baseType enumerationRestrictions do: [ :baseRestriction |			(enumRestrictions detect: [ :myRest | myRest value = baseRestriction value ] ifNone: [nil])				ifNotNil: [ :baseRest | enumRestrictions remove: baseRest ]		]	].	^enumRestrictions</body><body package="XMLObjectMarshalers">fractionDigits	^self restrictions detect: [ :restr | restr restrictionType = 'fractionDigits' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">inlineTypeNode	^self tag</body><body package="XMLObjectMarshalers">length	^self restrictions detect: [ :restr | restr restrictionType = 'length' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">maxExclusive	^self restrictions detect: [ :restr | restr restrictionType = 'maxExclusive' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">maxInclusive	^self restrictions detect: [ :restr | restr restrictionType = 'maxInclusive' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">maxLength	^self restrictions detect: [ :restr | restr restrictionType = 'maxLength' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">minExclusive	^self restrictions detect: [ :restr | restr restrictionType = 'minExclusive' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">minInclusive	^self restrictions detect: [ :restr | restr restrictionType = 'minInclusive' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">minLength	^self restrictions detect: [ :restr | restr restrictionType = 'minLength' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">pattern	^self restrictions detect: [ :restr | restr restrictionType = 'pattern' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">restrictions	^restrictions</body><body package="XMLObjectMarshalers">serializationBlock	^serializationBlock</body><body package="XMLObjectMarshalers">serializationBlock: anObject	serializationBlock := anObject</body><body package="XMLObjectMarshalers">smalltalkClass	^smalltalkClass</body><body package="XMLObjectMarshalers">smalltalkClass: aClass	smalltalkClass := aClass</body><body package="XMLObjectMarshalers">smalltalkClassName	^(self smalltalkClass notNil		ifTrue: [self smalltalkClass ]		ifFalse: 	[XMLObjectBinding classForXMLType: self tag  ifAbsent: [Object]]) name asString</body><body package="XMLObjectMarshalers">totalDigits	^self restrictions detect: [ :restr | restr restrictionType = 'totalDigits' ] ifNone: [nil]</body><body package="XMLObjectMarshalers">validate	^validate ifNil: [self class validate]</body><body package="XMLObjectMarshalers">validate: aBoolean	validate := aBoolean</body><body package="XMLObjectMarshalers">whiteSpace	^self restrictions detect: [ :restr | restr restrictionType = 'whiteSpace' ] ifNone: [nil]</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>testing</category><body package="XMLObjectMarshalers">isResolved 	^deserializationBlock ~~ nil and: [ serializationBlock ~~ nil ]</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>printing</category><body package="XMLObjectMarshalers">printArgsOn: stream indentation: number	self tag type = 'anyType' ifTrue: [^stream nextPutAll: '"any type"'].	self smalltalkClass ifNotNil: [ self printClassName: self smalltalkClass on: stream ].	self restrictions 		do: [ :restriction | restriction printArgsOn: stream indentation: number]		separatedBy: [ stream nextPut: $,]</body><body package="XMLObjectMarshalers">printOn: aStream	super printOn: aStream.	conversionId notNil 		ifTrue: [aStream space; nextPutAll: conversionId]</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>api -- unmarshal</category><body package="XMLObjectMarshalers">unmarshalFrom: marshalingContext do: aBlock	| val node |	(node := marshalingContext node) == nil		ifTrue: [node := MissingValueNotification raiseWith: self tag type printString]. 	(self unmarshalHRefFrom: marshalingContext )		ifFalse: 			[val := self validateValue: (deserializationBlock value: marshalingContext value: node characterData value: smalltalkClass).			marshalingContext value: val].	aBlock value: marshalingContext</body><body package="XMLObjectMarshalers">unmarshalHRefFrom: aMarshalingContext	^self conversionId = 'String'		ifTrue: 			[aMarshalingContext manager 					resolveHReference: aMarshalingContext 					fromElement: aMarshalingContext node]		ifFalse: [ false ]</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>api -- marshal</category><body package="XMLObjectMarshalers">getRealMarshalerMarshal: aMarshalingContext" Answer self. ComplexObjectMarshaler can return a marshaler for derived types "	(aMarshalingContext useInlineType and: [ self path type ~= 'anyType'])		ifTrue: [self setInlineTypeFor: aMarshalingContext source marshalingContext: aMarshalingContext ].	^self</body><body package="XMLObjectMarshalers">privateMarshalFrom: marshalingContext	self validateValue: marshalingContext value.	marshalingContext value: ( serializationBlock value: marshalingContext value: smalltalkClass)</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>api -- builder</category><body package="XMLObjectMarshalers">addBaseRestrictions		baseType restrictions do: [ :baseRestriction |		restrictions			detect: [ :childRestriction | childRestriction restrictionType = baseRestriction restrictionType ]			ifNone: [				baseRestriction isEnumeration					ifTrue: [baseRestriction enumerationRestrictions do: [ :r | self addRestriction: r] ]					ifFalse: [ self addRestriction: baseRestriction ]]].</body><body package="XMLObjectMarshalers">addEnumValues: collectionOfValue	collectionOfValue do: [:aValue | 		self addRestriction: 'enumeration' value: aValue]</body><body package="XMLObjectMarshalers">addRestriction: aRestrictionMarshaler		self restrictions add: aRestrictionMarshaler.</body><body package="XMLObjectMarshalers">addRestriction: restrictionType value: aValue	"&lt;restrictionType&gt; is one of the possible XML restriction types.	Add a new restriction of the given kind and value. Intercept duplicate restrictions."	| newRestriction |	baseType isNil ifTrue: [^self error: 'No restrictions on base types allowed'].	RestrictionMarshaler restrictions 		at: restrictionType 		ifAbsent: [^self error: (#NotSupportedRestriction  &lt;&lt; #webservices &gt;&gt; 'Not supported restriction')].	(self restrictions anySatisfy: [:each | each restrictionType = restrictionType &amp; (each value = aValue)])		ifTrue: [^self].	(newRestriction := RestrictionMarshaler newProxyFor: restrictionType)		value: aValue;		parent: self.	self addRestriction: newRestriction.</body><body package="XMLObjectMarshalers">finish"The method sets serialization blocks from the base type.Uses the blocks to resolve restriction values.Adds restrictions from a base type.Collects all enumeration restrictions in to a one restriction marshaler. "	| enums enumRestriction |	baseType ifNil: [^nil].	self resolveFromBaseType.	self addBaseRestrictions.	"Check if we have enumeration restrictions "	enums := self restrictions select: [ :restr | restr isEnumeration].	(enums isEmpty		or: [ enums size = 1 			and: [enums first value isKindOf: OrderedCollection ]]) ifTrue: [^nil].	"Collect all enumeration restriction marshalers in one restriction marshaler "	enumRestriction := RestrictionMarshaler new							parent: self;							restrictionType: 'enumeration';							value: OrderedCollection new;							yourself.	enums do: [ :each | 			enumRestriction addEnumValue:  each value.			self restrictions remove: each ].	self addRestriction: enumRestriction.</body><body package="XMLObjectMarshalers">resolveFromBaseType		(self isResolved or: [ baseType isNil ]) ifTrue: [ ^nil].	baseType isResolved ifFalse: [ baseType finish].	baseType isSimpleType 	ifFalse: [ baseType := baseType simpleContentBaseType ].	tag ifNil: [ "anonymous(local) type " tag := baseType tag. xpath := baseType xpath ].	smalltalkClass ifNil: [smalltalkClass := baseType smalltalkClass].	conversionId ifNil: [ conversionId := baseType conversionId].	serializationBlock ifNil: [serializationBlock := baseType serializationBlock].	deserializationBlock ifNil: [deserializationBlock := baseType deserializationBlock].	self restrictions do: [ :each | each finish].</body><body package="XMLObjectMarshalers">setBlocksForId: idString" set serializationBlock/deserializationBlock  for the specified id"	conversionId := idString.	( conversionId asQualifiedReference valueOrDo: [nil]) ifNotNil: 		[ :value | smalltalkClass := value ].	serializationBlock := BindingBuilder serializationBlockFor: conversionId.	deserializationBlock := BindingBuilder deserializationBlockFor: conversionId.</body><body package="XMLObjectMarshalers">setLocalAttributesFrom: attributesx in: builder" Set any attributes we are interested in "	super setLocalAttributesFrom: attributesx in: builder.	smalltalkClass := (self findValue: 'smalltalkClass' in: attributes)		ifNotNil: [ :cl | smalltalkClass := cl asQualifiedReference valueOrDo: [nil] ].	(self findDomainValue: 'baseType' in: attributesx) 		ifNil: [self setBlocksForId: (self findValue: 'id' in: attributes). ]		ifNotNil: [ :base |  builder  resolveType: base do: 	[ :resolved | baseType := resolved.]]</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>xml schema support</category><body package="XMLObjectMarshalers">xmlBaseType	^baseType ifNotNil: [ baseType tag ]</body><body package="XMLObjectMarshalers">xmlEnumeration	^self enumerationRestrictions</body><body package="XMLObjectMarshalers">xmlFractionDigits	| fractionDigits |	(baseType isNil or: [ (fractionDigits := self fractionDigits) isNil]) ifTrue: [^nil].	^baseType fractionDigits value = fractionDigits value		ifTrue: [ nil]		ifFalse: [ fractionDigits ]</body><body package="XMLObjectMarshalers">xmlLength	| length |	(baseType isNil or: [ ( length := self length ) isNil]) ifTrue: [^nil].	^baseType length value = length value		ifTrue: [ nil]		ifFalse: [ length ]</body><body package="XMLObjectMarshalers">xmlMaxExclusive	| maxExclusive |	(baseType isNil or: [ ( maxExclusive := self maxExclusive ) isNil]) ifTrue: [^nil].	^baseType maxExclusive value = maxExclusive value		ifTrue: [ nil]		ifFalse: [ maxExclusive ]</body><body package="XMLObjectMarshalers">xmlMaxInclusive	| maxInclusive |	(baseType isNil or: [ (maxInclusive := self maxInclusive) isNil]) ifTrue: [^nil].	^baseType maxInclusive value = maxInclusive value		ifTrue: [ nil]		ifFalse: [ maxInclusive ]</body><body package="XMLObjectMarshalers">xmlMaxLength		| maxLength |	(baseType isNil or: [ ( maxLength := self maxLength ) isNil]) ifTrue: [^nil].	^baseType maxLength value = maxLength value		ifTrue: [ nil]		ifFalse: [ maxLength ]</body><body package="XMLObjectMarshalers">xmlMinExclusive	| minExclusive |	(baseType isNil or: [ ( minExclusive := self minExclusive ) isNil]) ifTrue: [^nil].	^baseType minExclusive value = minExclusive value		ifTrue: [ nil]		ifFalse: [ minExclusive ]</body><body package="XMLObjectMarshalers">xmlMinInclusive	| minInclusive |	(baseType isNil or: [ (minInclusive := self minInclusive) isNil]) ifTrue: [^nil].	^baseType minInclusive value = minInclusive value		ifTrue: [ nil]		ifFalse: [ minInclusive ]</body><body package="XMLObjectMarshalers">xmlMinLength	| minLength |	(baseType isNil or: [ ( minLength := self minLength ) isNil]) ifTrue: [^nil].	^baseType minLength value = minLength value		ifTrue: [ nil]		ifFalse: [ minLength ]</body><body package="XMLObjectMarshalers">xmlPattern	| pattern |	(baseType isNil or: [ (pattern := self pattern ) isNil]) ifTrue: [^nil].	^baseType pattern value = pattern value		ifTrue: [ nil]		ifFalse: [ pattern ]</body><body package="XMLObjectMarshalers">xmlRestriction		| struct |	struct := Struct new.	baseType ifNotNil: [ struct at: #xmlBaseType put: self xmlBaseType ].	self restrictions do: [ :each | 		each isEnumeration 			ifTrue: [  struct at: each restrictionType asSymbol put: self enumerationRestrictions ]			ifFalse: [(self perform: each xmlSelector) ifNotNil: [ :val |  struct at: each restrictionType asSymbol put: val ]]].	^struct</body><body package="XMLObjectMarshalers">xmlTotalDigits	| totalDigits |	(baseType isNil or: [ ( totalDigits := self totalDigits) isNil]) ifTrue: [^nil].	^baseType totalDigits value = totalDigits value		ifTrue: [ nil]		ifFalse: [ totalDigits ]</body><body package="XMLObjectMarshalers">xmlWhiteSpace	| whiteSpace |	(baseType isNil or: [ (whiteSpace := self whiteSpace) isNil]) ifTrue: [^nil].	^baseType whiteSpace value = whiteSpace value		ifTrue: [ nil]		ifFalse: [ whiteSpace ]</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>copying</category><body package="XMLObjectMarshalers">copyFrom: anotherMarshaler	smalltalkClass := anotherMarshaler smalltalkClass.	conversionId := anotherMarshaler conversionId.	serializationBlock := anotherMarshaler serializationBlock.	deserializationBlock := anotherMarshaler deserializationBlock.	restrictions :=  anotherMarshaler restrictions.</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	super initialize.	xpath xpathPrefix: 'self::'.	restrictions := OrderedCollection new.</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler</class-id> <category>validation</category><body package="XMLObjectMarshalers">validateValue: aValue	self validate ifFalse: [^aValue].	self restrictions do: 			[:each |			([each validateValue: aValue] on: Error do: [ :ex | ex return: false])				ifFalse: 					[(ValidationNotification new)						messageText: (#XMLRestrictionViolation &lt;&lt; #webservices									&gt;&gt; 'Value &lt;1p&gt; violates &lt;2s&gt; restriction' expandMacrosWith: aValue										with: each restrictionType) asString;						parameter: (Array with: each value);						raiseRequest]].	^aValue</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">newSerializationBlock: aSerializationBlock deserializationBlock: aDeserializationBlock	^self new 		serializationBlock: aSerializationBlock;		deserializationBlock: aDeserializationBlock;		yourself</body></methods><methods><class-id>WebServices.SimpleObjectMarshaler class</class-id> <category>accessing</category><body package="XMLObjectMarshalers">defaultValidateValue	^true</body><body package="XMLObjectMarshalers">validate	^validate ifNil: [validate := self defaultValidateValue]</body><body package="XMLObjectMarshalers">validate: aBoolean	validate := aBoolean</body></methods><methods><class-id>WebServices.UnresolvedReferenceSignal</class-id> <category>accessing</category><body package="XMLObjectMarshalers">messageText	| stream |	stream := String new writeStream.			self parameter unresolvedMessages 				do: [ :mess | stream nextPutAll: mess ]				separatedBy: [stream cr ].	^stream contents.</body></methods><methods><class-id>WebServices.XMLObjectDriver</class-id> <category>accessing</category><body package="XMLObjectMarshalers">binding	^self builder binding</body><body package="XMLObjectMarshalers">builder	^builder</body><body package="XMLObjectMarshalers">builder: aBindingBuilder		builder := aBindingBuilder</body><body package="XMLObjectMarshalers">document	^self builder binding</body><body package="XMLObjectMarshalers">targetNamespace	^self builder targetNamespace</body><body package="XMLObjectMarshalers">unresolvedMessages	^self builder unresolvedMessages</body></methods><methods><class-id>WebServices.XMLObjectDriver</class-id> <category>content handler</category><body package="XMLObjectMarshalers">endDocument	"Indicates that the parser has finished the document"	self builder finish</body><body package="XMLObjectMarshalers">endElement: namespaceURI localName: localName qName: name	"indicates the end of an element. See startElement"	self builder endObjectBinding:  localName</body><body package="XMLObjectMarshalers">startDocument	"Indicates the start of a document"	self builder start</body><body package="XMLObjectMarshalers">startElement: namespaceURI localName: localName qName: name attributes: attributes	self builder defaultNamespace: namespaceURI.	self builder startObjectBinding: localName attributes: attributes</body><body package="XMLObjectMarshalers">startPrefixMapping: qualifier uri: uri	self builder namespaceMap at: qualifier put: uri.</body></methods><methods><class-id>WebServices.XMLObjectDriver</class-id> <category>initialization</category><body package="XMLObjectMarshalers">initialize	builder := BindingBuilder new.</body></methods><methods><class-id>WebServices.XMLObjectDriver class</class-id> <category>instance creation</category><body package="XMLObjectMarshalers">buildBindingFromElements: anXMLElements	| unresolved value coll |	unresolved := OrderedCollection new: 10.	coll := OrderedCollection new.	anXMLElements 		do: [ :el | 			[value := self loadFrom: el canonicalPrintString readStream]				on: UnresolvedReferenceSignal				do: [ :ex |  unresolved add: ex parameter. ex proceed ].			XMLObjectBinding register: value.			coll add: value ].	unresolved do: [ :b | 	b _complete ].	^coll</body><body package="XMLObjectMarshalers">load: filenameString	| stream |	stream := filenameString asFilename readStream.	^[self loadFrom: stream]		ensure: [ stream close ]</body><body package="XMLObjectMarshalers">loadFrom: aStream	| oldBinding driver |	driver := self new.	^[(XMLParser on: aStream)		validate: false;		saxDriver: driver;		scanDocument 	] ifCurtailed: 		[ (oldBinding := driver builder oldBinding) ifNotNil:[XMLObjectBinding register: oldBinding]]</body><body package="XMLObjectMarshalers">new	^super new initialize</body></methods><methods><class-id>Core.Integer</class-id> <category>xml schema print</category><body package="XMLObjectMarshalers">printDecimalUsing: aBindingBuilder	^aBindingBuilder encodeInteger: self class: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="XMLObjectMarshalers">isTaggedObject	^false</body><body package="XMLObjectMarshalers">isTypeMarshaler			^false</body></methods><methods><class-id>XML.XPathStep</class-id> <category>XML-object</category><body package="XMLObjectMarshalers">isAttribute	^false</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext do: aBlock	aBlock value.	marshalingContext source == nil		ifTrue:  [self error: (#ExpectXMLNode &lt;&lt; #webservices &gt;&gt; 'Expect XML node')].	marshalingContext shouldEncodeValue ifTrue: [self setValueFrom: marshalingContext]</body><body package="XMLObjectMarshalers">myTag	| q ns |	(q := baseTest qualifier) == nil ifTrue: [q := ''].	(ns := baseTest namespace) == nil ifTrue: [ns := ''].	^NodeTag 			qualifier: q 			ns: ns 			type: baseTest type.</body><body package="XMLObjectMarshalers">resetQualifier: aString</body><body package="XMLObjectMarshalers">setElementNodeFrom: marshalingContext	marshalingContext tag == nil ifTrue: [marshalingContext tag: self myTag].	^baseTest setNodeFrom: marshalingContext</body><body package="XMLObjectMarshalers">setNodeAndMarshalFrom: aMarshalingContext do: aBlock	self setNodeFrom: aMarshalingContext.	(baseTest isTextType 		or: [aMarshalingContext isReference]) ifTrue: [^nil].	aMarshalingContext setSourceAttributes.	self marshalFrom: aMarshalingContext do: aBlock.</body><body package="XMLObjectMarshalers">setNodeFrom: marshalingContext" By default build element with specified tag. This can be overridden (i.e. for attribute nodes) "	| node |	^baseTest isTextType		ifTrue: 			[node := self setValueFrom: marshalingContext.			marshalingContext parent ~~ nil				ifTrue: [marshalingContext parent addNode: node]]		ifFalse: [self setElementNodeFrom: marshalingContext]</body><body package="XMLObjectMarshalers">setValueFrom: marshalingContext" Delegate to the base test. Set value will build text node if my base test is typed node test 'text'. Otherwise it does nothing "	^baseTest setValueFrom: marshalingContext</body><body package="XMLObjectMarshalers">wsSelect: nodes for: namespaceFilter	^baseTest 		ifNil: [ nodes ]		ifNotNil: [ baseTest wsSelect: nodes for: namespaceFilter ]</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>xml schema print</category><body package="XMLObjectMarshalers">printDecimalUsing: aBindingBuilder	^aBindingBuilder printDecimal: self</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>xml schema print</category><body package="XMLObjectMarshalers">printDecimalUsing: aBindingBuilder	^aBindingBuilder encodeShort: self class: self class</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>xml schema print</category><body package="XMLObjectMarshalers">printDecimalUsing: aBindingBuilder	^aBindingBuilder printAsDecimal:  self</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>xml schema print</category><body package="XMLObjectMarshalers">printDecimalUsing: aBindingBuilder	^aBindingBuilder encodeLong: self class: self</body></methods><methods><class-id>Core.Number</class-id> <category>xml schema print</category><body package="XMLObjectMarshalers">printDecimalUsing: aBindingBuilder	^self error: (#CanNotEncodeNumber &lt;&lt; #webservices &gt;&gt; 'Can not encode the number as XML decimal' )</body></methods><methods><class-id>XML.XPathTypedNodeTest</class-id> <category>XML-object</category><body package="XMLObjectMarshalers">isTextType	^typeName = 'text'</body><body package="XMLObjectMarshalers">setValueFrom: marshalingContext	self isTextType	ifTrue: [marshalingContext addTextValue].	^marshalingContext source</body><body package="XMLObjectMarshalers">wsSelect: nodes for: namespaceFilter	^nodes</body></methods><methods><class-id>XML.XPathAttributeNode</class-id> <category>XML-object</category><body package="XMLObjectMarshalers">isAttribute	^true</body><body package="XMLObjectMarshalers">marshalFrom: marshalingContext do: aBlock	marshalingContext source == nil		ifTrue:  [self error: (#ExpectAttributeNode &lt;&lt; #webservices &gt;&gt; 'Expect attribute node')].	super marshalFrom: marshalingContext do: aBlock</body><body package="XMLObjectMarshalers">resetQualifier: aString	baseTest resetQualifier: aString</body><body package="XMLObjectMarshalers">setNodeAndMarshalFrom: aMarshalingContext do: aBlock	aMarshalingContext value ifNotNil: [ super setNodeAndMarshalFrom: aMarshalingContext do: aBlock ]</body><body package="XMLObjectMarshalers">setNodeFrom: marshalingContext" Create attribute node and link to my parent. Set value to empty initially. The actual value will be set later after the contents have been marshaled.Preserve qualifier for attributes like: xml:lang "	| node attrName |	attrName := baseTest asNodeTag.	node := Attribute name: attrName  value: ''.	marshalingContext source: node.	marshalingContext parent ~~ nil		ifTrue: [marshalingContext parent addAttributeNode: node].	marshalingContext setQualifierForAttributeNode: node tag.</body><body package="XMLObjectMarshalers">setValueFrom: marshalingContext	marshalingContext source value: marshalingContext value</body><body package="XMLObjectMarshalers">wsSelect: attributes for: namespaceFilter 	| filter |	filter := baseTest namespace ifNil: [''] ifNotNil: [baseTest namespace].	^attributes select: [ :attribute | attribute key namespace = filter].</body></methods><methods><class-id>XML.XPathTaggedNodeTest</class-id> <category>XML-object</category><body package="XMLObjectMarshalers">asNodeTag	^NodeTag 		qualifier: ( self qualifier == nil ifTrue: [''] ifFalse: [ self qualifier ])		ns: ( self namespace == nil ifTrue: [''] ifFalse: [ self namespace ])		type: self type</body></methods><methods><class-id>XML.XPathTaggedNodeTest</class-id> <category>accessing</category><body package="XMLObjectMarshalers">qualifier	^qualifier</body></methods><methods><class-id>XML.XPathTaggedNodeTest</class-id> <category>XML-object</category><body package="XMLObjectMarshalers">resetQualifier: aString	qualifier := aString</body><body package="XMLObjectMarshalers">setNodeFrom: marshalingContext	| node |	node := Element tag: marshalingContext tag copy.	marshalingContext setNode: node.	^node</body><body package="XMLObjectMarshalers">setValueFrom: marshalingContext	(marshalingContext value isString and: [marshalingContext source isElement])		ifTrue: 			[marshalingContext source addNode: (Text text: marshalingContext value).			marshalingContext value: nil]</body><body package="XMLObjectMarshalers">wsMatch: element to: namespaceFilter	namespaceFilter == #'' ifTrue: [^true].	namespaceFilter == #'##other' ifTrue: [^element namespace ~= element parent namespace].	^element namespace asSymbol = namespaceFilter</body><body package="XMLObjectMarshalers">wsSelect: nodes for: namespaceFilter	^namespaceFilter 		ifNil: [ nodes ]		ifNotNil: [nodes select: [ :element | self wsMatch: element to: namespaceFilter]]</body></methods><methods><class-id>XML.XPathNodeTest</class-id> <category>XML-object</category><body package="XMLObjectMarshalers">isTextType	^false</body><body package="XMLObjectMarshalers">setNodeFrom: marshalingContext	" Do nothing by default "</body><body package="XMLObjectMarshalers">setValueFrom: marshalingContext	" Do nothing by default "</body></methods><methods><class-id>Core.Fraction</class-id> <category>xml schema print</category><body package="XMLObjectMarshalers">printDecimalUsing: aBindingBuilder	^aBindingBuilder printAsDecimal:  self</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="XMLObjectMarshalers">webServicesXMLBuilderPage	&lt;settingsPage: #(webservices xmlSchemaBuilder)&gt;	^ModularSettingsPage new		label: #WebServicesXMLSchemaBuilder &lt;&lt; #webservices &gt;&gt; 'XML Schema Builder';		icon: (ListIconLibrary visualFor: #web);		useRadioButtonsForEnumerations;		addSetting:			(self settingWithId: #(webservices xmlSchemaBuilder addSuperClassType ));		yourself</body><body package="XMLObjectMarshalers">webServicesXMLObjectMarshalingPage	&lt;settingsPage: #(webservices xmlObjectMarshaling)&gt;	^ModularSettingsPage new		label: #XMLObjectMarshaling &lt;&lt; #webservices &gt;&gt; 'XMLObject Marshaling';		icon: (ListIconLibrary visualFor: #web);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(webservices xmlObjectMarshaling))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws marshaling</category><body package="XMLObjectMarshalers">ws1UseInlineType	&lt;setting: #(webservices xmlObjectMarshaling useInlineType)&gt;	^(BooleanSetting on: WebServices.XMLObjectBinding aspect: #useInlineType)		default: WebServices.XMLObjectBinding useInlineTypeValue;		label: #UseInlineType &lt;&lt; #webservices &gt;&gt; 'Encode nodes with inline type';		helpText: #UseInlineTypeHelpText &lt;&lt; #webservices &gt;&gt; 'This option chooses whether or not to add the inline type to a node when a message is marshaled. For example: node with inline type &lt;cost xsi:type="xsd:float"&gt;29.95&lt;/cost&gt; '</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws xmlbuilder</category><body package="XMLObjectMarshalers">ws1UseSuperClassType	&lt;setting: #(webservices xmlSchemaBuilder addSuperClassType)&gt;	^((EnumerationSetting 		choices: #(#false #true)		labels: (				Array 					with: (#AddSuperclassTypesWithTypes &lt;&lt; #webservices &gt;&gt; 'Add the super class type only if it has type description')					with: (#AlwaysUseSuperclassType &lt;&lt; #webservices &gt;&gt; 'Always add the super class type'))) 	on: WebServices.BindingBuilder aspect: #setAddSuperClassType)		label: #WhileGeneratingXMLSchemaTypes &lt;&lt; #webservices &gt;&gt; 'While generating the XML schema types:';		default: WebServices.BindingBuilder useAddSuperClassTypeValue;		helpText: #WhileGeneratingXMLSchemaTypesHelpText &lt;&lt; #dialogs &gt;&gt; 'Depending on this setting, the tool does the following:- If "Add the super class type only if it has type description" is selected, then the XML schema types will be generated from the specified classes and their super classes will be added only if superclass instance variables have pragma description. This is the default option.- If "Always add the super class type" is selected, the XML schema types will be generated from the classes and their superclasses will be always added.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws marshaling</category><body package="XMLObjectMarshalers">ws2UseReference	&lt;setting: #(webservices xmlObjectMarshaling useReference)&gt;	^(BooleanSetting on: WebServices.XMLObjectBinding aspect: #useReference)		default: WebServices.XMLObjectBinding useReferenceValue;		label: #UseReference &lt;&lt; #webservices &gt;&gt; 'Use multi-reference encoding for identical objects';		helpText: #UseReferenceHelpText &lt;&lt; #webservices &gt;&gt; 'This option chooses whether or not to use multi-reference encoding for identical objects (id/href attributes) which means that the only object will be encoded with some id attribute. The rest of the identical objects will be encoded as a reference (href) to this id. Choosing this option preserves object identity.For example, with the option on two accessors to the same string will appear, as follows:&lt;greeting id="String-0"&gt;Hello&lt;/greeting&gt;&lt;salutation href="#String-0"/&gt;However, if the option is turned off, they will be encoded as two single-reference values as follows:&lt;greeting&gt;Hello&lt;/greeting&gt;&lt;salutation&gt;Hello&lt;/salutation&gt;'</body><body package="XMLObjectMarshalers">ws4NillableDefault	&lt;setting: #(webservices xmlObjectMarshaling nillableDefault)&gt;	^(BooleanSetting on: WebServices.RPCEncRelationMarshaler aspect: #nillableDefault)		default: WebServices.RPCEncRelationMarshaler nillableDefaultValue;		label: #NillableDefault &lt;&lt; #webservices &gt;&gt; 'Use true as nillable default for Soap Array';		helpText: #nillableDefaultHelpText &lt;&lt; #webservices &gt;&gt; 'This option allows to set nillable default for Soap Array items. By default a Soap Array item is described with the nillable="false" attribute.'</body><body package="XMLObjectMarshalers">ws5CreateBindingForSchema	&lt;setting: #(webservices xmlObjectMarshaling createBindingForSchema)&gt;	^(BooleanSetting on: WebServices.BindingBuilder aspect: #createBindingForSchema)		default: WebServices.BindingBuilder createBindingForSchemaValue;		label: #CreateBindingForSchema &lt;&lt; #webservices &gt;&gt; 'Create XML to object binding for schema data type';		helpText: #createBindingForSchemaHelpText &lt;&lt; #webservices &gt;&gt; 'This option defines whether or not to create XML to object binding for schema data types. If this option is on the schema serializer will create, load and add the binding to a marshaling manager. By default the BindingBuilder class&gt;&gt;schemaParser creates default (to a dictionary) binding for XML complex types. The BindingBuilder class&gt;&gt;schemaParser can be set to create XML to object binding. This option can help to unmarshal DiffGram format (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondiffgrams.asp)'</body><body package="XMLObjectMarshalers">ws6RaiseMissingValueException	&lt;setting: #(webservices xmlObjectMarshaling raiseMissingValueException)&gt;	^(BooleanSetting on: WebServices.ObjectMarshaler aspect: #raiseMissingValueException)		default: WebServices.ObjectMarshaler raiseMissingValueExceptionValue;		label: #RaiseMissingValueException &lt;&lt; #webservices &gt;&gt; 'Always raise missing value exception';		helpText: #RaiseMissingValueExceptionHelpText &lt;&lt; #webservices &gt;&gt; 'Setting this option to true will allow raising MissingValueSignal while marshaling the nil value even if the value is defined as optional (minOccurs=0). The default is false and the exception will be raised only for mandatory values (minOccurs=1)'</body><body package="XMLObjectMarshalers">ws6ValidateSimpleTypes	&lt;setting: #(webservices xmlObjectMarshaling validateSimpleTypes)&gt;	^(BooleanSetting on: WebServices.SimpleObjectMarshaler aspect: #validate)		default: WebServices.SimpleObjectMarshaler defaultValidateValue;		label: #ValidateSimpleTypes &lt;&lt; #webservices &gt;&gt; 'Validate simple types restrictions';		helpText: #ValidateSimpleTypesHelpText &lt;&lt; #webservices &gt;&gt; 'Setting this option to true will allow validate simple types restrictions'</body><body package="XMLObjectMarshalers">ws8UseStructAsChoiceValue	&lt;setting: #(webservices xmlObjectMarshaling useStructAsChoiceValue)&gt;	^(BooleanSetting on: WebServices.ChoiceMarshaler aspect: #useStructAsChoiceValue)		default: WebServices.ChoiceMarshaler useStructAsChoiceValueValue;		label: #UseStructAsChoiceValueValue &lt;&lt; #webservices &gt;&gt; 'Use Struct as Choice value';		helpText: #UseStructAsChoiceValueHelpText &lt;&lt; #webservices &gt;&gt; 'Turning on this option will unmarshal choice elements as Structs. The default setting is false. By default the choice elements will be unmarshaled as Association where the key is the choice sub-element name and the value is the unmarshaled choice object.An example:&lt;struct name="MyStruct"&gt;&lt;choice name="choiceValue"&gt;&lt;element name="a" ref="string"/&gt;&lt;element name="b" ref="string"/&gt;&lt;/choice&gt;&lt;/struct&gt;When the option is off the input parameter ismyStruct := Struct new		at: #choiceValue put: (''a''-&gt; ''aa'');		yourself.Unmarshaling XML document with the option off will return an association at #choiceValue.When the option is on the input parameter ismyStruct := Struct new		at: #choiceValue put: (Struct new at: #a put: ''aa''; yourself );		yourself.Unmarshaling XML document with the option off will return a Struct at #choiceValue.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ws xmlbuilder</category><body package="XMLObjectMarshalers">x2oExcludedSupers	&lt;settingsPage: #(webservices xmlSchemaBuilder excludedSupers)&gt;	^(SequenceSettingPage new)		label: #x2oNotIncludeSupersClasses &lt;&lt; #labels &gt;&gt; 'Do not included in XML schema superclasses:';		icon: (ListIconLibrary visualFor: #net);		listHolder:  WebServices.BindingBuilder excludedSupersHolder displayBlock: [ :value | value  ]  acceptBlock: [ :value |  value ];		helpText: #x2oNotIncludeSupersClassesText &lt;&lt; #net &gt;&gt; 'Specifies the list of classes  that won''t be included in XML schema when the option: "Always add the super class type" is selected';		yourself</body></methods><initialize><class-id>WebServices.MarshalingContext</class-id></initialize><initialize><class-id>WebServices.AspectImplementation</class-id></initialize><initialize><class-id>WebServices.BindingBuilder</class-id></initialize><initialize><class-id>WebServices.XMLObjectBinding</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>XMLObjectBindingSignal</name><environment>WebServices</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-XML-To-Object</category><attributes><package>XMLObjectSupport</package></attributes></class><class><name>XPathStep</name><environment>XML</environment><super>XML.XPathExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>axisName baseTest namespace type parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>XPathAttributeNode</name><environment>XML</environment><super>XML.XPathStep</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class><class><name>XPathNodeTest</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class><class><name>SAXDriver</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><class><name>XPathTaggedNodeTest</name><environment>XML</environment><super>XML.XPathNodeTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace qualifier type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>XPathTypedNodeTest</name><environment>XML</environment><super>XML.XPathNodeTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class></st-source>