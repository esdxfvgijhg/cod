<?xml version="1.0"?><st-source><!-- Name: SOAP-ServerNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: The SOAP-Server package includes classes that can be used to create SOAP server classes for customer applications.OverviewPlease refer to the Web Services Developer's Guides before using this package (discussions of the XMLObjectMarshalers, SOAP and WSDL packages are recommended).The Web services framework allows various approaches to application design. The simplest and fastest way is to use the Web Services Wizard or the WebServices.WsdlClassBuilder class. To open the Wizard, load the WSDLWizard package and select "Web Services Wizard" from the Launcher "Tools" menu. For details on use of the Wizard, refer to the Web Services Guide.UsageLet's build a simple time service as an example. It will support a single operation 'TimeNow' that will return a current timestamp. For the service implementation we will simply use the Timestamp class, and the operation 'Now' will invoke the #now method on it. The corresponding WSDL binding definition could look as follows:	schema := '<definitions		xmlns="http://schemas.xmlsoap.org/wsdl/" 	 	xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 			xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" 			xmlns:xsd="http://www.w3.org/2000/10/XMLSchema"		targetNamespace="urn:time-server">	<message name="timeNow">        </message>        <message name="timeNowResult">                <part name="time" type="xsd:dateTime" />        </message>        <portType name="TimeServerPortType">                <operation name="TimeNow">                        <input message="timeNow" />                        <output message="timeNowResult" />                </operation>        </portType>        <binding name="TimeServerSoapBinding" type="TimeServerPortType">                <soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http" />                <operation name="TimeNow">                        <soap:operation soapAction="http://localhost/TimeServer.TimeNow" />                        <input>                                <soap:body use="encoded"					encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" />                        </input>                        <output>                                <soap:body use="encoded"					encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" />                        </output>                </operation>        </binding>	</definitions>'.The binding instance can be built from the schema as follows:	binding := (WsdlBinding loadWsdlBindingFrom: schema readStream) bindings asArray first.Mapping SOAP operations to Smalltalk messagesWe need to link the operations defined in the WSDL binding to Smalltalk messages. Our example binding defines an operation named TimeNow. By default, the binding will link it to a Smalltalk message #timeNow, simply tweaking the operation name to look more like a Smalltalk selector (note that parameters have to be reflected in the selector as well). To see the selectors that the binding expects to link to its operations you can inspect the following:	map := binding getServiceMapSelector maps are persisted in the form of an XML document. Send #printMap to the map to obtain this document.	map printMap.To change the selector mapped to an operation, simply update the selector map document and load it into the binding. In our example we want to change the selector for the TimeNow operation from #timeNow to #now.	selectors :='<ns:serviceMap xmlns:ns0="urn:vwservices/timeNowService" xmlns:ns="urn:visualworks:serviceMap">	<ns:serviceClass>WSDefault.TimeNowService</ns:serviceClass>	<ns:interface>ns0:TimeNowService</ns:interface>	<ns:operation name="TimeNow" selector="timeNow"/></ns:serviceMap>'.	binding loadServiceMapFrom: selectors readStream.Add SOAP responder to a server and create a new server:	soapResponder := SOAPResponder fromBinding: binding.	soapResponder addToServer.Execute a request:Using WsdlClient:	client := WebServices.WsdlClient readFrom: schema  readStream.	result := client executeSelector: #timeNow args: #().Using SoapRequest:	result := WebServices.SoapRequest new		binding: binding;		accessPoint: binding portAddress;		smalltalkEntity: (Message 							selector: #timeNow							arguments: #());		value.	soapResponder release.DbIdentifier: bear73DbTrace: 496095DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'WSDL' '') #(#any 'SiouX-Server' '') #(#any 'SiouX-Net-Http' ''))PackageName: SOAP-ServerParcel: #('SOAP-Server')PrerequisiteDescriptions: #(#(#name 'WSDL') #(#name 'SiouX-Server' #componentType #bundle) #(#name 'SiouX-Net-Http' #componentType #package))PrerequisiteParcels: #(#('WSDL' '') #('SiouX-Server' '') #('SiouX-Net-Http' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:31:39 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:39 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SOAPInterceptorDispatcher</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerEntries requestHeader policy interceptors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SOAP-Server</package></attributes></class><comment><class-id>WebServices.SOAPInterceptorDispatcher</class-id><body>The class maintains a sequence of interceptors that are invoked for each SOAP header block. Instance Variables	headerEntries	&lt;Collection of: SoapHeaderEntry&gt; unmarshaled request header entries	requestHeader	&lt;Collection of: XML.Element&gt; caches the request header on the client side and the header elements on the server side	interceptors &lt;Collection of: SOAPMessageInterceptor&gt;	policy &lt;SOAPPolicy&gt;Class Instance Variables</body></comment><class><name>SOAPResponder</name><environment>WebServices</environment><super>SiouX.NetHttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processingPolicy environmentWithHeaders binding service </inst-vars><class-inst-vars>defaultProcessingPolicyClass defaultEnvironmentWithHeaders responders </class-inst-vars><imports>			private Net.*			private SiouX.*			</imports><category></category><attributes><package>SOAP-Server</package></attributes></class><comment><class-id>WebServices.SOAPResponder</class-id><body>The class is supeclass for responders with a specific WSDL schema.Instance Variables	binding &lt;WSDLBinding&gt;	service &lt;Object&gt; a service class that provides web services	processingPolicy &lt;SOAPProcessingPolicy&gt; defines processing policy. Mostly used to set additional callbacks for SOAP header marshaling.	environmentWithHeaders &lt;Boolean&gt; should the SOAP header be stored in the process environment before executing a SOAP operationClass Instance Variables	defaultEnvironmentWithHeaders &lt;Boolean&gt; default value is false	defaultProcessingPolicyClass &lt;SOAPProcessingPolicy&gt;	responders &lt;Set&gt; cashed instances of the responder created from WSDL. ImplementationThe class parses WSDL, creates and registers WsdlBinding and X2O binding. For each WSDL schema &lt;&lt;soap:address location=...&gt; element creates an instance of SOAPResponder. Responder instances are cached in class variable #responders. The SOAPResponder instance knows its WSDL binding, service class, processing policy and url path. Since the responder instances are cached, changes in WSDL will require flushing the #responders collection. SOAPResponder class&gt;flushResponders method will remove the responders from servers and set the responder collection to nil. Using SOAPResponder class&gt;&gt;responders method will reinitialize the collection.Subclasses must implement following class methods:#wsdlSchema - The WSDL schema can be returned as a string or URL. If the WSDL schema includes &lt;import&gt; statements #wsdlSchema should return URI that will be used as a base URI to resolve import locations. #x2oBinding - XML Object Binding specification. The WS tools will generate this method from WSDL &lt;schema&gt; elements.#serviceMap - The WS tools generate this method from &lt;portType&gt; elements in WSDL. The service map provides information about a services class and selectors and corresponding Web services interfaces and operations.#interceptors - The WS tools generate this method and interceptor classes when WSDL schema has SOAP headers.See HTimeServer class from TimeDemo:HTimeServer class&gt;&gt;interceptors	OrderedCollection with: HPasswordServerInterceptorThe interceptors provide additional interception points between SOAP header and SOAP body marshaling and unmarshaling.#wsdlQueryFor - the method sets WSDL schema that will be returned in response to a ?WSDL queryUsageLet's look at SecureResponder from WSSecurityDemo. The responder implements methods: #wsdlSchema, #x2oBinding, #serviceMap and #interceptors.The WSDL schema defines an http address as follows:		&lt;port binding="tns:TimeServicesBinding" name="TimeServices"&gt;			&lt;soap:address location="http://localhost:4444/TestTimeServices"&gt;&lt;/soap:address&gt;		&lt;/port&gt;To activate the responder it has to be added to an existing server serving the specified address (localhost:4444) or a new server has to be created. 	SecureResponder addToServer.If the #addToServer method is called for the first time, the WSDL schema is parsed and an instance of the SecureResponder is created and cached. The method will also create and start a new server if a suitable server (serving the specified address) doesn't exist yet.Now you can use a client to send a request to the server:	(SecureClient new timeNow) inspect.To deactivate a responder send message #release to it. You can also remove the responder from the server and flush the class side responder cache as follows:	SecureResponder flushResponders.Note that releasing the responder leaves the server that was hosting it alone. If the server should be destroyed as well, that has to be done explicitly.</body></comment><class><name>ServiceRequestHandler</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>soapRequest soapResponse interceptorDispatcher requestContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SOAP-Server</package></attributes></class><comment><class-id>WebServices.ServiceRequestHandler</class-id><body>ServiceRequestHandler handles web services request. The class unmarshals the Http requests contents, sends messages to a web service class and marshals replies in to Http responses.Instance Variables	soapRequest	&lt;SoapRequest&gt;	 SOAP request	soapResponse	&lt;SoapResponse&gt;	SOAP response	requestContext	&lt;RequestContext&gt; 	interceptorDispatcher &lt;SOAPInterceptorDispatcher&gt; </body></comment><class><name>SOAPProcessingPolicy</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcherClass interceptorClasses processOptionalHeaders </inst-vars><class-inst-vars>defaultDispatcherClass defaultInterceptorClasses defaultProcessOptionalHeaders </class-inst-vars><imports></imports><category></category><attributes><package>SOAP-Server</package></attributes></class><comment><class-id>WebServices.SOAPProcessingPolicy</class-id><body>SOAPProcessingPolicy extends message processing for SOAP messages.  The only supported role for the Soap server is ultimate receiver.Instance Variables	processOptionalHeaders	&lt;Boolean&gt; should we unmarshal optional headers that came with the attribute "mustUnderstand="false" ?	interceptorClasses  &lt;OrderedCollection of  (SOAPMessageInterceptor) &gt;	dispatcherClass &lt;SOAPInterceptorDispatcher&gt;Class Instance Variables	defaultProcessOptionalHeaders	&lt;Boolean&gt; should we unmarshal optional headers ?	defaultDispatcherClass &lt;SOAPInterceptorDispatcher&gt;	defaultInterceptorClasses &lt;OrderedCollection of  (SOAPMessageInterceptor) &gt;</body></comment><class><name>SOAPMessageInterceptor</name><environment>WebServices</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SOAP-Server</package></attributes></class><comment><class-id>WebServices.SOAPMessageInterceptor</class-id><body>SOAP has additional interception points between SOAP header and SOAP body marshaling and unmarshaling. This class adds the callbacks for those.Instance Variables:		dispatcher &lt;SOAPInterceptorDispatcher&gt;</body></comment><methods><class-id>WebServices.SOAPInterceptorDispatcher</class-id> <category>processing callbacks</category><body package="SOAP-Server">receivingReply: aReply in: aTransport	self interceptors do: [ :each | each receivingReply: aReply in: aTransport ]</body><body package="SOAP-Server">receivingReplyEnvelope: aReply in: aConnection	self interceptors do: [ :each | each receivingReplyEnvelope: aReply in: aConnection ]</body><body package="SOAP-Server">receivingRequest: aRequest in: aTransport	self interceptors do: [ :each | each receivingRequest: aRequest in: aTransport ]</body><body package="SOAP-Server">receivingRequestDOM: aDOM	self interceptors do: [ :each | each receivingRequestDOM: aDOM ]</body><body package="SOAP-Server">receivingRequestEnvelope: aRequest in: aConnection	aRequest handler operation inputHeaderBindings ifNotNil: [ self unmarshalHeaderFrom: aRequest.].	self interceptors do: [ :each | each receivingRequestEnvelope: aRequest in: aConnection ]</body><body package="SOAP-Server">sendingReply: aReply in: aTransport	self interceptors do: [ :each | each sendingReply: aReply in: aTransport ]</body><body package="SOAP-Server">sendingReplyEnvelope: aReply in: aConnection	self interceptors do: [ :each | each sendingReplyEnvelope: aReply in: aConnection ]</body><body package="SOAP-Server">sendingRequest: aRequest in: aTransport	self interceptors do: [ :each | each sendingRequest: aRequest in: aTransport ]</body><body package="SOAP-Server">sendingRequestDOM: aDOM	self interceptors do: [ :each | each sendingRequestDOM: aDOM ]</body><body package="SOAP-Server">sendingRequestEnvelope: aRequest in: aConnection	self interceptors do: [ :each | each sendingRequestEnvelope: aRequest in: aConnection ].	" The header struct can be changed after the interceptors processing"	requestHeader := aRequest header.</body><body package="SOAP-Server">sendingResponseDOM: aDOM	self interceptors do: [ :each | each sendingResponseDOM: aDOM ]</body></methods><methods><class-id>WebServices.SOAPInterceptorDispatcher</class-id> <category>interceptor</category><body package="SOAP-Server">addInterceptor: anInterceptor	interceptors add: anInterceptor.	anInterceptor dispatcher: self.</body><body package="SOAP-Server">interceptors	interceptors ifNil: [ interceptors := OrderedCollection new ].	^interceptors</body><body package="SOAP-Server">setInterceptors: aSequenceOfInterceptors	interceptors := aSequenceOfInterceptors.	aSequenceOfInterceptors do: [ :each | each dispatcher: self ]</body></methods><methods><class-id>WebServices.SOAPInterceptorDispatcher</class-id> <category>accessing</category><body package="SOAP-Server">headerEntries	^headerEntries</body><body package="SOAP-Server">headerEntries: aDictionary	headerEntries := aDictionary</body><body package="SOAP-Server">policy	^policy</body><body package="SOAP-Server">policy: aProcessingPolicy	policy := aProcessingPolicy</body><body package="SOAP-Server">requestHeader	^requestHeader</body><body package="SOAP-Server">requestHeader: aStruct	requestHeader := aStruct</body></methods><methods><class-id>WebServices.SOAPInterceptorDispatcher</class-id> <category>unmarshaling</category><body package="SOAP-Server">selectElementsToProcess: xmlElements headerMarshalers: aSOAPRequest " Processing SOAP MessagesThis section sets out the rules by which SOAP messages are processed. Nothing in this specification prevents the use of optimistic concurrency, roll back, or other techniques that might provide increased flexibility in processing order. Unless otherwise stated, processing of all generated SOAP messages, SOAP faults and application-level side effects MUST be semantically equivalent to performing the following steps separately, and in the order given.   1. Determine the set of roles in which the node is to act. The contents of the SOAP envelope, including any SOAP header blocks and the SOAP body, MAY be inspected in making such determination.   2.Identify all header blocks targeted at the node that are mandatory.   3. If one or more of the SOAP header blocks identified in the preceding step are not understood by the node then generate a single SOAP fault with the Value of Code set to env:MustUnderstand . If such a fault is generated, any further processing MUST NOT be done. Faults relating to the contents of the SOAP body MUST NOT be generated in this step.  4. Process all mandatory SOAP header blocks targeted at the node and, in the case of an ultimate SOAP receiver, the SOAP body. A SOAP node MAY also choose to process non-mandatory SOAP header blocks targeted at it.   5.n the case of a SOAP intermediary, and where the SOAP message exchange pattern and results of processing (e.g., no fault generated) require that the SOAP message be sent further along the SOAP message path, relay the message as described in section 2.7 Relaying SOAP Messages."	| binding headerElements |	binding := aSOAPRequest handler binding.	headerElements := Core.OrderedCollection new.	xmlElements		do: [ :elx |  (self policy processOptionalHeaders or: [binding muValueOfAttribute: elx]) ifTrue: [ headerElements add: elx ]].	^headerElements</body><body package="SOAP-Server">unmarshalHeaderFrom: aSOAPRequest 	| headerElements soapHeader |	requestHeader := aSOAPRequest handler operation transport headerNodeFromXML: aSOAPRequest handler dom.	requestHeader isEmpty ifTrue: [ ^aSOAPRequest handler operation verifyRequestHeaderFrom: #() ].	headerElements :=  self  selectElementsToProcess: requestHeader first realElements headerMarshalers: aSOAPRequest.	aSOAPRequest handler operation verifyRequestHeaderFrom: headerElements.	headerElements isEmpty ifTrue: [ ^nil ].  	soapHeader := aSOAPRequest unmarshalHeaderEntriesFromXML: headerElements .	aSOAPRequest handler header: soapHeader.	headerEntries := soapHeader headerEntries.	^aSOAPRequest header</body></methods><methods><class-id>WebServices.SOAPInterceptorDispatcher</class-id> <category>initialize-release</category><body package="SOAP-Server">initialize	super initialize.	headerEntries := Core.OrderedCollection new.</body></methods><methods><class-id>WebServices.SOAPResponder</class-id> <category>accessing</category><body package="SOAP-Server">address	^binding port address</body><body package="SOAP-Server">binding	^binding</body><body package="SOAP-Server">binding: anObject	binding := anObject</body><body package="SOAP-Server">connectionClass	self address protocol = 'http' ifTrue: [^SiouX.HttpConnection ].	self address protocol = 'https' 		ifTrue: [ #{SiouX.HttpsConnection}					ifDefinedDo: [ :value | ^value ]					elseDo: [^self error: (#LoadSiouXServerSecure &lt;&lt; #webservices &gt;&gt; 'To create a listener with secure connection load SiouX-Server-Secure parcel') ]].		^self error: (#SOAPAddressHasUnknownProtocol &lt;&lt; #webservices &gt;&gt; 'SOAP Address has unknown protocol. Supported protocols http and https')</body><body package="SOAP-Server">environmentWithHeaders	^environmentWithHeaders ifNil: [ environmentWithHeaders := self class defaultEnvironmentWithHeaders ]</body><body package="SOAP-Server">environmentWithHeaders: aBoolean	environmentWithHeaders := aBoolean</body><body package="SOAP-Server">ipAddress	^(self address host = 'localhost'		ifTrue: [ IPSocketAddress thisHostAnyPort ]		ifFalse: [ IPSocketAddress hostName: self address host ])  port: self address port</body><body package="SOAP-Server">processingPolicy	^processingPolicy ifNil: [ processingPolicy := self class processingPolicy ]</body><body package="SOAP-Server">processingPolicy: aSOAPProcessingPolicy	processingPolicy := aSOAPProcessingPolicy</body><body package="SOAP-Server">service	^service</body><body package="SOAP-Server">service: anObject	service := anObject</body></methods><methods><class-id>WebServices.SOAPResponder</class-id> <category>tools</category><body package="SOAP-Server">asXmlNode	| root |	root := XML.Element 		tag: 'responder' 		elements: nil.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName ).	^root</body><body package="SOAP-Server">description	^'SOAP Service: ', self service class name asString</body></methods><methods><class-id>WebServices.SOAPResponder</class-id> <category>initialize-release</category><body package="SOAP-Server">addToServer"A server with matching address is found or a new one is created.If a new server is created it will also be started automatically. "	| ipAddress connectionClass |	server ifNotNil: [ ^self ].	ipAddress := self ipAddress.	connectionClass := self connectionClass.	(Server registry values detect: [ :srv | 	(srv findListenerOn: ipAddress for:  connectionClass) notNil ] ifNone: [ nil])		ifNotNil: [ :srv | server :=  srv ]		ifNil: [ server := Server id: nil.			server listenOn: ipAddress for:  connectionClass.			server start.].	server addResponder: self</body><body package="SOAP-Server">fromBinding: aWsdlBinding	aWsdlBinding port ifNil: [		aWsdlBinding setPortIfAbsentDo: [self error: (#BindingHasNoEndpoint &lt;&lt; #webservices &gt;&gt; 'The binding has no endpoint address')]].	binding := aWsdlBinding.	service := binding serviceClass new.	path := self address pathString.	url := self address asPartial.</body></methods><methods><class-id>WebServices.SOAPResponder</class-id> <category>printing</category><body package="SOAP-Server">printOn: aStream	aStream nextPutAll: 'SOAP '.	binding ifNotNil: [ aStream nextPutAll: self address pathString].	service ifNotNil: [ aStream nextPutAll: ' Service class: ', service class name ]</body></methods><methods><class-id>WebServices.SOAPResponder</class-id> <category>services</category><body package="SOAP-Server">acceptRequest: aRequestLine"Find WsdlBinding for HttpRequest url. The GET method can have different url tail when the location attribute is specified in operation binding description. For example: whttp:location='convertValueInput{fromValue} . For GET compare the url beginning only."		(('get' match: aRequestLine method)		or: ['post' match: aRequestLine method])			ifFalse: [^false].	aRequestLine decodedPath = self decodedPath ifTrue: [		(('get' match: aRequestLine method)			or: ['post' match: aRequestLine method])				ifFalse: ["501 Not Implemented  The server does not support the requested feature."						^self  newResponse  							statusCode:  '501';									contents: 'The server doesn''t support ', aRequestLine method ].		^true ].	^(('get' match: aRequestLine method) and: [aRequestLine decodedPath beginsWith: self decodedPath ]) 		or: [('post' match: aRequestLine method) and: [ aRequestLine decodedPath = self decodedPath ]]</body><body package="SOAP-Server">executeRequestFor: aRequestContext"Check if the responder has registered service for the request url. If the service is found the responder processes the web service request and returns HttpResponse. If there is no service found the responder returns nil "	| query |	((query := aRequestContext request url query) notNil		and: ['wsdl' match: query])			ifTrue: ["WSDL schema request" 					^self class wsdlQuery 						ifNil: [ NoWsdlSchemaError raise ]						ifNotNil: [ :string | aRequestContext response contents:  string ].].	(ServiceRequestHandler from: aRequestContext)		executeRequest.</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>defaults</category><body package="SOAP-Server">defaultEnvironmentWithHeaders	^defaultEnvironmentWithHeaders ifNil: [ self defaultEnvironmentWithHeadersValue ]</body><body package="SOAP-Server">defaultEnvironmentWithHeaders: aBoolean	defaultEnvironmentWithHeaders := aBoolean</body><body package="SOAP-Server">defaultEnvironmentWithHeadersValue	^false</body><body package="SOAP-Server">defaultProcessingPolicyClass	^defaultProcessingPolicyClass ifNil: [defaultProcessingPolicyClass := self defaultProcessingPolicyClassValue]</body><body package="SOAP-Server">defaultProcessingPolicyClass: aProcessingPolicyClass	defaultProcessingPolicyClass := aProcessingPolicyClass</body><body package="SOAP-Server">defaultProcessingPolicyClassValue	^SOAPProcessingPolicy</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>accessing</category><body package="SOAP-Server">interceptors"Subclasses should implement this method if a responder wants to add interceptors. See HTimeServer class from TimeDemo:	^OrderedCollection with: HPasswordServerInterceptorThe interceptors provide additional interception points between SOAP header and SOAP body marshaling and unmarshaling."	^OrderedCollection new</body><body package="SOAP-Server">processingPolicy"Subclasses should implement this method if a responder wants to add interceptors. See HTimeServer class from TimeDemo:	^SOAPProcessingPolicy new		interceptorClasses: (OrderedCollection with: HPasswordServerInterceptor);		yourselfThe interceptors provide additional interception points between SOAP header and SOAP body marshaling and unmarshaling."	^self  defaultProcessingPolicyClass new		interceptorClasses: self interceptors;		yourself</body><body package="SOAP-Server">responders " (self responders) ""Returns already initialized responders. If there are no responders initialize them from WSDL.If WSDL has been changed use #flushResponders to reset responders"	^responders ifNil: [ self initializeResponders ]</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>instance creation</category><body package="SOAP-Server">addToServer"Creates responder instances from WSDL binding.Finds or creates SiouX.Server for the each SOAP address &lt;soap:address location'http://localhost:4950/TimeNowService'/&gt;If a server was created starts the server.Adds responders to servers"	self responders do: [ :responder | responder addToServer ].</body><body package="SOAP-Server">flushResponders"Remove each cashed responder from the server and reset the responder collection "	responders ifNil: [ ^nil].	responders do: [ :responder | responder  release ].	responders := nil</body><body package="SOAP-Server">fromBinding: aWsdlBinding	^(super new)		initialize;		fromBinding: aWsdlBinding;		yourself</body><body package="SOAP-Server">initializeResponders"Initialize responders from WSDL. Assign a processing policy."	|  config  processingPolicy |	self wsdlSchema ifNil: [^Set new].	responders ifNotNil: [ self flushResponders ].	responders := Set new.	config := WsdlBinding initializeRegistriesFor: self.	processingPolicy := self processingPolicy.	config services do: [ :service | 		service ports do: [ :port |			(responders add: ( self fromBinding: port binding)) processingPolicy: processingPolicy.]].	^responders</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>wsdl schema</category><body package="SOAP-Server">serviceMap	^nil</body><body package="SOAP-Server">wsdlSchema	^nil</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>creation</category><body package="SOAP-Server">new	self error: 'Use #responders method to get the responder instance'</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>pivate - configuration</category><body package="SOAP-Server">respondersFor: aServer	^self responders select: [ :responder |		(aServer findListenerOn: responder ipAddress for: responder  connectionClass) notNil 			and: [(aServer responders anySatisfy: [ :resp | resp isSameAs: responder]) not ]]</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>private</category><body package="SOAP-Server">canBeCreatedFreely"This method is used by SiouX Tools (#Create button). Since SOAPResponder knows its host, port and connection type (from WSDL soap-address)  it can be added only to a server that runs a listener with  these host and port."	^false</body><body package="SOAP-Server">initializeBindingServiceMap: aConfiguration x2oImports: xmlObjectBindings"Finish WsdlBinding initialization. Set binding service map and XMLObject bindings.The responder has to have service maps for interfaces and service class in method: #serviceMapAn example:&lt;ns:serviceMap xmlns:ns='urn:visualworks:serviceMap' xmlns:ns0='urn:vwservices/timeNowServiceRPC'&gt;	&lt;ns:serviceClass&gt;WebServices.TimeNowService&lt;/ns:serviceClass&gt;	&lt;ns:interface&gt;ns0:TimeNowService&lt;/ns:interface&gt;	&lt;ns:operation name='TimeNow' selector='timeNow'&gt;&lt;/ns:operation&gt;	&lt;ns:operation name='AsTimestamp' selector='asTimestamp:'&gt;&lt;/ns:operation&gt;&lt;/ns:serviceMap&gt;  "	| maps |	maps := self serviceMap 		ifNotNil: [ :map | ServiceMap loadFrom: map readStream ]		ifNil: [self error: #ServiceMapMethosNotImplemented &lt;&lt; #webservices &gt;&gt; '#serviceMap method is not implemented'].	maps ifNotNil: [ 	aConfiguration interfaces do: [ :interface |					(maps detect: [ :m | m interface = interface name] ifNone: [nil ])						ifNotNil: [ :m | interface serviceMap: m]]].	 xmlObjectBindings ifNotNil: [ aConfiguration descriptor schemaBindings addAll: xmlObjectBindings].	aConfiguration bindings do: [ :binding | xmlObjectBindings ifNotNil: [xmlObjectBindings do: [ :x2o |  binding importBinding: x2o]]]</body><body package="SOAP-Server">wsdlQuery"This WSDL schema will be returned by a server in ?WSDL query response "	^self wsdlSchema 		ifNotNil: [ :wsdl |			([ wsdl asURI resource ] on: Error do: [ :ex | ex return: nil])				ifNotNil: [ :resource | | stream contents |					stream := resource stream.					[ contents := stream contents ] ensure: [ stream close ].					contents ]				ifNil: [ wsdl asString]]</body></methods><methods><class-id>WebServices.SOAPResponder class</class-id> <category>configuration</category><body package="SOAP-Server">createResponderFrom: pragma	self error: ( #DoNotDeclareSOAPResponderPragma &lt;&lt; #webservices &gt;&gt; 'Do not declare SOAP responders with pragmas (configuration is driven by WSDL)' )</body></methods><methods><class-id>WebServices.ServiceRequestHandler</class-id> <category>accessing</category><body package="SOAP-Server">binding	^self responder binding</body><body package="SOAP-Server">connection	^requestContext connection</body><body package="SOAP-Server">interceptorDispatcher	^interceptorDispatcher</body><body package="SOAP-Server">interceptorDispatcher: aSOAPInterceptorDispatcher	interceptorDispatcher := aSOAPInterceptorDispatcher</body><body package="SOAP-Server">processingPolicy	^self responder processingPolicy</body><body package="SOAP-Server">receiverFault	^self binding transport receiverFault</body><body package="SOAP-Server">request	^requestContext request</body><body package="SOAP-Server">requestSmalltalkEntity	^self soapRequest smalltalkEntity</body><body package="SOAP-Server">responder	^requestContext responder</body><body package="SOAP-Server">response	^requestContext response</body><body package="SOAP-Server">senderFault	^self binding transport senderFault</body><body package="SOAP-Server">soapRequest	^soapRequest</body><body package="SOAP-Server">soapResponse	^soapResponse</body></methods><methods><class-id>WebServices.ServiceRequestHandler</class-id> <category>private</category><body package="SOAP-Server">ensureRequestOperationSet	self soapRequest operation ifNil: [		"Most likely the Soap action is missing and the operation was not set. Last attempt to find the operation from the SOAP body child element "		self soapRequest operation: 			((self binding transport findOperationForRequest: self soapRequest dom )				ifNil: [ self error: (#UnknownOperationForPOSTRequest &lt;&lt; #webservices &gt;&gt; 'Unknown operation for POST request. Provide SOAP action header for the operation') asString ]				ifNotNil: [ :op | 					self soapResponse operation: op.					op ])].</body><body package="SOAP-Server">processRequestHeaders	["Process request headers before the body gets unmarshaled"		self interceptorDispatcher receivingRequestEnvelope: self soapRequest in: self connection 	] 		on: Error 		do: [ :ex | ex isSoapFault 					ifTrue: [ex pass]					ifFalse: [self soapRequest operation raiseAsUserHeaderError: ex]].</body><body package="SOAP-Server">soapReceiverFault: anException	^anException isSoapFault			ifTrue: [ anException ]			ifFalse: [(self receiverFault faultString: anException description)						detailContents: anException;						yourself ]</body><body package="SOAP-Server">soapSenderFault: anException	^anException isSoapFault			ifTrue: [ anException ]			ifFalse: [(self senderFault faultString: anException description)						detailContents: anException;						yourself ]</body></methods><methods><class-id>WebServices.ServiceRequestHandler</class-id> <category>marshaling</category><body package="SOAP-Server">marshalResponse	["Send the response to interceptors before it gets marshaled "	self interceptorDispatcher sendingReply: self soapResponse in: self connection.	"Marshal Smalltalk entity in to XML DOM"	self soapResponse marshalDom  ifNotNil: [ self interceptorDispatcher sendingResponseDOM: self soapResponse dom].	"Write DOM in to Http response "	self soapResponse setTransportEntityBody. 	"Send Soap response to interceptors. The Http response is ready to be sent "	self interceptorDispatcher sendingReplyEnvelope: self soapResponse in: self connection.	]		on: Error		do: [ :exc | 				self response statusLine code: '500'.			self soapResponse smalltalkEntity:  (self soapReceiverFault: exc).			self soapResponse 				marshalDom;				setTransportEntityBody ].</body><body package="SOAP-Server">unmarshalGET	| arguments |	self soapRequest operation ifNil: [self error: (#UnknownOperationForGetProvideAction &lt;&lt; #webservices &gt;&gt; 'Unknown operation for GET request. Provide SOAP action header for the operation') asString ].	"Deserialize GET url and set the request Smalltalk entity"	arguments := self soapRequest operation deserialize: self request.	self soapRequest smalltalkEntity: (Message 										selector: self soapRequest findSelectorForOperation 										arguments: arguments asArray).	"Send the unmarshaled request  to interceptors"	self interceptorDispatcher receivingRequest: self soapRequest in: self connection.</body><body package="SOAP-Server">unmarshalPOST	self soapRequest readDocumentFrom: self request. 	"Send SOAP envelope DOM to interceptors"	self interceptorDispatcher receivingRequestDOM: self soapRequest dom.	(SoapBinding supportedSoapVersions includes: self soapRequest dom tag namespace) ifFalse: [VersionMismatchFault raise] .	self ensureRequestOperationSet.	self processRequestHeaders.	self responder environmentWithHeaders ifTrue: [		"Set SOAP header entries in ProcessEnvironment "		ProcessEnvironment current at: #SoapHeader put: self soapRequest header ].	"Unmarshal the SOAP body as a message (selector&amp;agruments) "	self soapRequest smalltalkEntity: (self soapRequest operation unmarshalAsMessage:  self soapRequest dom).	"Send unmarshaled request to interceptors"	self interceptorDispatcher receivingRequest: self soapRequest in: self connection.</body><body package="SOAP-Server">unmarshalRequestOnErrorDo: aBlock	[('get' match: self request method)		ifTrue: [self unmarshalGET ]		ifFalse: [ self unmarshalPOST].	]		on: Error 		do: [ :exc |				"We may need to marshal Soap header errors" 			self response statusLine code: '500'.			self soapResponse smalltalkEntity:  (self soapSenderFault: exc).			self soapResponse shouldReturnOneWayContents ifFalse: [self marshalResponse].			aBlock value ].</body></methods><methods><class-id>WebServices.ServiceRequestHandler</class-id> <category>services</category><body package="SOAP-Server">executeRequest	self initializeSoapMessages.	"Unmarshal the request, execute the web service and marshal the reply in to Http response "	self unmarshalRequestOnErrorDo: [ ^self response ].	"Ask SOAP responder to provide an instance of service class and execute the web service. Set the reply in to Soap response smalltalk entity. "	self soapResponse setSmalltalkEntity: ( self executeService: self responder service ).	self soapResponse shouldReturnOneWayContents ifTrue: [^self response ].	"Marshal smalltalk entity in to Http response "	^self marshalResponse.</body><body package="SOAP-Server">executeService: aService"Send the message to a service object. Return an object or Soap Fault "	^[(aService respondsTo: self requestSmalltalkEntity selector)		ifTrue: [aService				perform: self requestSmalltalkEntity selector				withArguments: self requestSmalltalkEntity arguments ]		ifFalse: [ (aService respondsTo: #soapPerform:)				ifTrue: [ aService soapPerform: self ]				ifFalse: [ self senderFault 							faultString: (#request1sNotImplemented &lt;&lt; #webservices &gt;&gt; 'Request &lt;1s&gt; is not implemented'									expandMacrosWith: self requestSmalltalkEntity selector)]]	] 	on: Error		do: [ :exc | 			self connection server 				responderError: exc				from: self request: self  request 				connection: self connection.			self response statusLine code: '500'.			self soapSenderFault: exc ]</body><body package="SOAP-Server">initializeSoapMessages"Set Soap request and response. Find operation based on Soap action HTTP header field  "	| operation |	operation := self binding transport operationFromHttpHeader: self request.	interceptorDispatcher := self processingPolicy provideInterceptorDispatcher.	soapRequest := SoapRequest new				transportEntity: self request;				interceptorDispatcher: self interceptorDispatcher;				binding: self binding;				operation: operation;				yourself.	soapResponse := SoapResponse new				transportEntity: self response;				binding: self binding;				operation: operation;				interceptorDispatcher: self interceptorDispatcher;				request: soapRequest;				yourself.</body></methods><methods><class-id>WebServices.ServiceRequestHandler</class-id> <category>initialize-release</category><body package="SOAP-Server">from: aRequestContext	requestContext := aRequestContext</body></methods><methods><class-id>WebServices.ServiceRequestHandler class</class-id> <category>instance creation</category><body package="SOAP-Server">from: aRequestContext	^self new		from: aRequestContext;		yourself</body></methods><methods><class-id>WebServices.SOAPProcessingPolicy</class-id> <category>printing</category><body package="SOAP-Server">printOn: aStream	aStream nextPutAll: '(', self class name,  ' new '.	interceptorClasses ifNotNil: [ 		aStream nextPutAll: 'interceptorClasses: ( OrderedCollection '.		interceptorClasses do: [ :each | aStream nextPutAll: ' with: '. each printOn: aStream ].		aStream nextPutAll: '); yourself );' ]</body></methods><methods><class-id>WebServices.SOAPProcessingPolicy</class-id> <category>accessing</category><body package="SOAP-Server">dispatcherClass	dispatcherClass ifNil: [ dispatcherClass := self class defaultDispatcherClass].	^dispatcherClass</body><body package="SOAP-Server">dispatcherClass: aClass	dispatcherClass := aClass</body><body package="SOAP-Server">interceptorClasses	^interceptorClasses ifNil: [ interceptorClasses := self class defaultInterceptorClasses ]</body><body package="SOAP-Server">interceptorClasses: aCollectionOfMessageInterceptor	interceptorClasses := aCollectionOfMessageInterceptor</body><body package="SOAP-Server">processOptionalHeaders	^processOptionalHeaders ifNil: [ self class defaultProcessOptionalHeaders ]</body><body package="SOAP-Server">processOptionalHeaders: aBoolean"	aBoolean &lt;Boolean&gt; should we unmarshal and process headers that are not marked 'MustUnderstand=true' ?"	processOptionalHeaders := aBoolean</body><body package="SOAP-Server">provideInterceptorDispatcher	^self dispatcherClass new		setInterceptors: ( self interceptorClasses collect: [ :each | each new] );		policy: self;		yourself</body></methods><methods><class-id>WebServices.SOAPProcessingPolicy class</class-id> <category>defaults</category><body package="SOAP-Server">defaultDispatcherClass	^defaultDispatcherClass ifNil: [defaultDispatcherClass := self defaultDispatcherClassValue ]</body><body package="SOAP-Server">defaultDispatcherClass: aClass	defaultDispatcherClass := aClass</body><body package="SOAP-Server">defaultInterceptorClasses	^defaultInterceptorClasses ifNil: [ self defaultInterceptorClassesValue ]</body><body package="SOAP-Server">defaultInterceptorClasses: aClassOrCollection	defaultInterceptorClasses := (aClassOrCollection isSequenceable 		or: [aClassOrCollection isNil ])		ifTrue: [ 	aClassOrCollection ]		ifFalse: 	[ OrderedCollection with: aClassOrCollection ]</body><body package="SOAP-Server">defaultProcessOptionalHeaders	^defaultProcessOptionalHeaders ifNil: [ defaultProcessOptionalHeaders := self defaultProcessOptionalHeadersValue ]</body><body package="SOAP-Server">defaultProcessOptionalHeaders: aBoolean	defaultProcessOptionalHeaders := aBoolean</body></methods><methods><class-id>WebServices.SOAPProcessingPolicy class</class-id> <category>default values</category><body package="SOAP-Server">defaultDispatcherClassValue	^SOAPInterceptorDispatcher</body><body package="SOAP-Server">defaultInterceptorClassesValue 	^OrderedCollection new</body><body package="SOAP-Server">defaultProcessOptionalHeadersValue	^false</body></methods><methods><class-id>WebServices.SOAPMessageInterceptor</class-id> <category>processing callbacks</category><body package="SOAP-Server">receivingReply: aReply in: aTransport</body><body package="SOAP-Server">receivingReplyEnvelope: aReply in: aTransport</body><body package="SOAP-Server">receivingRequest: aRequest in: aTransport</body><body package="SOAP-Server">receivingRequestDOM: aDOM</body><body package="SOAP-Server">receivingRequestEnvelope: aSOAPRequest in: aTransport</body><body package="SOAP-Server">sendingReply: aReply in: aTransport</body><body package="SOAP-Server">sendingReplyEnvelope: aReply in: aTransport</body><body package="SOAP-Server">sendingRequest: aRequest in: aTransport</body><body package="SOAP-Server">sendingRequestDOM: aDOM</body><body package="SOAP-Server">sendingRequestEnvelope: aRequest in: aTransport</body><body package="SOAP-Server">sendingResponseDOM: aDOM</body></methods><methods><class-id>WebServices.SOAPMessageInterceptor</class-id> <category>accessing</category><body package="SOAP-Server">dispatcher	^dispatcher</body><body package="SOAP-Server">dispatcher: anInterceptorDispatcher	dispatcher := anInterceptorDispatcher</body><body package="SOAP-Server">policy	^self dispatcher policy</body></methods><methods><class-id>WebServices.SOAPMessageInterceptor</class-id> <category>printing</category><body package="SOAP-Server">printOn: aStream		aStream nextPutAll: self class name</body></methods><methods><class-id>WebServices.SOAPMessageInterceptor class</class-id> <category>accessing</category><body package="SOAP-Server">detectInterceptorNamed: aSymbol in: aNamespace	^SOAPMessageInterceptor subclasses detect: 			[:cl |			(cl headerNames includes: aSymbol) and: [cl environment name = aNamespace]]		ifNone: [nil]</body><body package="SOAP-Server">headerNames	^#()</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetHttpResponder</name><environment>SiouX</environment><super>SiouX.Responder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingOptions writingOptions </inst-vars><class-inst-vars>defaultReadingOptions defaultWritingOptions </class-inst-vars><imports>			private OS.IOConstants.*			private Net.*			</imports><category></category><attributes><package>SiouX-Net-Http</package></attributes></class></st-source>