<?xml version="1.0"?><st-source><!-- Name: JapaneseLocaleNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This parcel supports the localization of VisualWorks for Japanese.Note: because Roman characters in some of the Japanese fonts used on Windows have a larger point size, loading the Japanese Locale will adjust the default font size for all tools in the VisualWorks IDE. When loading this locale on a machine that has a U.S. version of Windows, the default fonts may appear too small on your machine. To restore the default size, you can perform the following steps:1. Using the System Browser, restore these two overridden methods:	WinXPLookPolicy class >> defaultSystemFontDescription	WinXPLookPolicy class >> defaultSystemFontScale2. Evaluate: "WinXPLookPolicy class".DbIdentifier: bear73DbTrace: 445131DbUsername: lkooymanDbVersion: 8.0 - 1DevelopmentPrerequisites: #(#(#any 'JaTools-Settings' '') #(#any 'JaTools-Settings-VW' '') #(#any 'DLLCC' '') #(#any 'JapaneseEncodings' ''))DisregardedPrerequisites: #(#(#name 'JaTools-Parcel Manager'))HideSource: falsePackageName: JapaneseLocaleParcel: #('JapaneseLocale')ParcelName: JapaneseLocalePrerequisiteParcels: #(#('JaTools-Settings' '') #('JaTools-Settings-VW' '') #('JapaneseEncodings' ''))PrintStringCache: (8.0 - 1,lkooyman)SaveSource: trueVersion: 8.0 - 1Post-Load Block: 	[ :pkg |  Locale postLoadJA: pkg.StandardSystemController flushMenus.]Pre-Unload Block: 	[ :pkg |  Locale preUnloadJA]Post-Unload Block: 	[InputManager platformHookup.InputManager default setLocale: ''.TextAttributes initialize.VariableSizeTextAttributes initialize.TextAttributes setDefaultTo: #default.WinXPLookPolicy initialize.Win98LookPolicy initialize.Win95LookPolicy initialize.UISettings uiOptionsReset.UISettings initialize.StandardSystemController flushMenus]Date: 9:49:47 AM August 15, 2014 --><time-stamp>From VisualWorks®, Pre-Release 8.0 (aug14.3) of August 15, 2014 on August 15, 2014 at 9:49:47 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.NumberPrintPolicy</class-id> <category>initialize-release</category><body package="JapaneseLocale">japan	"Initialize for Japan."	thousandsSeparator := $,.	decimalPoint := $..	groupingSize := 3.</body><body package="JapaneseLocale">japanCurrency	"Initialize for Japan."	self japan.	policy := self class formatTokensFor: '¥#,###;-¥#,###'</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>private</category><body package="JapaneseLocale">replaceSelectionWith: aText saveSelectionForUndo: aBoolean	| start extent |	view repairDamage.	aBoolean ifTrue: [self undoSelection: self selection].	start := self selectionStartIndex.	extent := self paragraph extent.	self		replaceFrom: start		to: self selectionStopIndex - 1		with: aText.	extent = self paragraph extent		ifFalse:	[view changedPreferredBounds: (0@0 corner: extent)].	self selectionStartIndex: start stopIndex: start + aText size</body></methods><methods><class-id>Core.CompoundTextStreamEncoder class</class-id> <category>class initialization</category><body package="JapaneseLocale">installJapan	"Initialize class variables and register variety of supported and unsupported encodings to them.	 See class comment about each definition of encoding."	| jisEncoder |	jisEncoder := CharacterEncoder encoderNamed: #'jisx0208.1983-0'.	self		addEncoding: #jisKanji1		sequence: #[27 36 41 66]		encoder: [ :c | | x | x := jisEncoder encode: c.				(x &lt; 16r2121) | (16r7E7E &lt; x) ifFalse: [x bitOr: 16r8080]]		decoder: [ :x | | c | c := jisEncoder decode: (x bitAnd: 16r7F7F).				(x &lt; 16rA1A1) | (16rFEFE &lt; x) | (c = Character illegalCode asCharacter) ifFalse: [c]];		addEncoding: #jisKanji0		sequence: #[27 36 40 66]		encoder: [ :c | | x | x := jisEncoder encode: c.				(x &lt; 16r2121) | (16r7E7E &lt; x) ifFalse: [x]]		decoder: [ :x | | c | c := jisEncoder decode: x.				(x &lt; 16r2121) | (16r7E7E &lt; x) | (c = Character illegalCode asCharacter) ifFalse: [c]];		addEncoding: #jisRoman		sequence: #[27 40 74]		encoder: [ :c | (16r21 &lt;= c) &amp; (c &lt;= 16r7E) ifTrue: [c]]		decoder: [ :x | x ];		addEncoding: #jisKatakana		sequence: #[27 41 73]		encoder: [ :c | (16rFF61 &lt;= c) &amp; (c &lt;= 16rFF9F) ifTrue: [c - 16rFEC0]]		decoder: [ :x | (16rA1 &lt;= x) &amp; (x &lt;= 16rDF) ifTrue: [x + 16rFEC0]].</body><body package="JapaneseLocale">unInstallJapan	"CompoundTextStreamEncoder unInstallJapan"	StateTable := nil.	self initialize</body></methods><methods><class-id>Core.Locale class</class-id> <category>installation</category><body package="JapaneseLocale">installJapan	"Locale installJapan"	"This will now only run if Legacy Locales is installed."	self instVarNames isEmpty		ifFalse:			[self installJapaneseX11.			self installJapaneseMSWindows]</body><body package="JapaneseLocale">installJapaneseMSWindows	| locale |	locale := self new.	locale		name: #'ja_JP.CP932';		collationPolicy: (StringCollationPolicy newFor: #japaneseCollate:to:);		compoundTextEncodeOrder: #(#ascii #jisKanji1 #jisKanji0 #jisRoman #jisKatakana #iso1);		currencyPolicy: (NumberPrintPolicy newCurrencyFor: #japan);		numberPolicy: (NumberPrintPolicy newFor: #japan);		timePolicy: (TimestampPrintPolicy newFor: #japan);		cutPasteEncoding: #MS_CP_932;		defaultPaperSize: 8.2677 @ 11.6929; "A4 paper size in inch"		ignoreSerifEncodings: #('kanji');		needsInputMethod: true;		defaultStreamEncoder: MSCP932StreamEncoder;		preferredEncodings: #('kanji' 'ansi');		preferredFontFamily: #();		preferredPixelSize: 16.	self addLocale: locale platform: #win32.	LocaleMap		at: #('win32 *' #JPN) put: #'ja_JP.CP932';		at: #('win32 *' #jpn) put: #'ja_JP.CP932'</body><body package="JapaneseLocale">installJapaneseX11	| locale copy |	locale := self new.	locale		collationPolicy: (StringCollationPolicy newFor: #japaneseCollate:to:);		compoundTextEncodeOrder: #(#ascii #jisKanji1 #jisKanji0 #jisRoman #jisKatakana #iso1);		currencyPolicy: (NumberPrintPolicy newCurrencyFor: #japan);		numberPolicy: (NumberPrintPolicy newFor: #japan);		timePolicy: (TimestampPrintPolicy newFor: #japan);		cutPasteEncoding: #CompoundText;		defaultPaperSize: 8.2677 @ 11.6929; "A4 paper size in inch"		needsInputMethod: true;		preferredFontFamily: #('*gothic*' '*mincho*');		preferredPixelSize: 12.	copy := locale copy.	copy		name: #'ja_JP.eucJPs';		defaultStreamEncoder: JapaneseEUCStreamEncoder;		ignoreSerifEncodings: #('jisx0208.1983-0' 'jisx0201.1976-0');		preferredEncodings: #('iso8859-1' 'jisx0208.1983-0' 'jisx0201.1976-0').	self addLocale: copy platform: #unix.	copy := locale copy.	copy		name: #'ja_JP.eucJP';		defaultStreamEncoder: JapaneseEUCStreamEncoder;		ignoreSerifEncodings: #('jisx0208.1983-0' 'jisx0212.1990-0' 'jisx0201.1976-0');		preferredEncodings: #('iso8859-1' 'jisx0208.1983-0' 'jisx0212.1990-0' 'jisx0201.1976-0').	self addLocale: copy platform: #unix.	copy := locale copy.	copy		name: #'ja_JP.HP15_JP';		defaultStreamEncoder: HP15StreamEncoder;		ignoreSerifEncodings: #('jisx0208.1983-0' 'jisx0201.1976-0');		preferredEncodings: #('iso8859-1' 'jisx0208.1983-0' 'jisx0201.1976-0').	self addLocale: copy platform: #unix.	copy := locale copy.	copy		name: #'ja_JP.SJIS';		defaultStreamEncoder: ShiftJISStreamEncoder;		ignoreSerifEncodings: #('jisx0208.1983-0' 'jisx0201.1976-0');		preferredEncodings: #('iso8859-1' 'jisx0208.1983-0' 'jisx0201.1976-0').	self addLocale: copy platform: #unix.	copy := locale copy.	copy		name: #'ja_JP.utf8';		defaultStreamEncoder: UTF8StreamEncoder;		ignoreSerifEncodings: #('jisx0208.1983-0' 'jisx0201.1976-0');		preferredEncodings: #('iso8859-1' 'jisx0208.1983-0' 'jisx0201.1976-0').	self addLocale: copy platform: #unix.	LocaleMap		at: #('* sun *' #japanese) put: #'ja_JP.eucJPs';		at: #('* sun *' #ja) put: #'ja_JP.eucJPs';		at: #('* hp *' #'japanese.euc') put: #'ja_JP.eucJP';		at: #('* hp *' #japanese) put: #'ja_JP.HP15_JP';		at: #('* hp *' #'ja_JP.SJIS') put: #'ja_JP.HP15_JP';		at: #('*linux*' #'ja_JP.eucJP') put: #'ja_JP.eucJPs';		at: #('*linux*' #'ja_JP.eucjp') put: #'ja_JP.eucJPs';		at: #('*linux*' #'ja_JP.UTF-8') put: #'ja_JP.utf8';		at: #('*linux*' #ja) put: #'ja_JP.eucJPs'</body></methods><methods><class-id>Core.Locale class</class-id> <category>parcel load/unload/save</category><body package="JapaneseLocale">postLoadJA: packageOrParcel	packageOrParcel isUpdating		ifFalse: 			[(packageOrParcel propertyAt: #postscriptFonts)				ifNotNil: 					[:list |					#{PostScriptFontBody.PostScriptFonts} value addAll: list.					PostScriptPrinter initialize]].	CharacterEncoder installJapan.	ShiftJISCharacterEncoder initialize.	JapaneseEUCStreamEncoder initialize.	JISStreamEncoder initialize.	CompoundTextStreamEncoder installJapan.	ScreenFont installJapan.	"MSWindowsFont installJapan."	Locale installJapan.	Win98LookPolicy initialize.	WinXPLookPolicy initialize.	Win95LookPolicy initialize.	FileDialog returnFromSnapshot.	StreamEncoder flushEncoderDirectory.	FontPolicy initialize.	TextAttributes initialize.	VariableSizeTextAttributes initialize.	packageOrParcel isParcel		ifTrue: [			"The following code is doing something which interacts badly with Store's loader,			in ways we don't yet understand. So we have arranged for this to only run when			loading from a parcel and not when loading from Store. For this reason, if loaded			from Store, you may not get a fully functional Japanese locale until you save the			image and restart.""			(UISettings preferenceModelFor: #textSize) value: #small.			UISettings textSizeReset.			TextAttributes setDefaultTo: #small."			InputManager platformHookup.			InputManager default setLocale: ''.			Locale setDefault.			Filename defaultClass install."			Screen default receiveAndProcessAllEvents.			Locale setJapaneseTimezone"			].</body><body package="JapaneseLocale">preUnloadJA	FileDialog imageReturnFromSnapshot.	CharacterEncoder unInstallJapan.	CompoundTextStreamEncoder unInstallJapan.	StreamEncoder flushEncoderDirectory.	ScreenFont unInstallJapan.	MSWindowsFont initialize.	FontPolicy initialize.	Locale unInstallJapan.	Locale setDefault.	Filename defaultClass install.	Screen default receiveAndProcessAllEvents</body><body package="JapaneseLocale">setJapaneseTimezone	"Japan"	TimeZone setDefaultTimeZone:		(TimeZone timeDifference: 9			DST: 0 at: 0			from: 0			to: 0			startDay: #Sunday).</body></methods><methods><class-id>Core.Locale class</class-id> <category>initialization</category><body package="JapaneseLocale">unInstallJapan	"Locale unInstallJapan."	LocaleMap := nil.	LocaleDictionary := nil.      self initialize.</body></methods><methods><class-id>Core.Locale class</class-id> <category>parcel load/unload/save</category><body package="JapaneseLocale">writeSuggestionsXMLForParcelTool	| file |	file := LogicalFilename fromComponents: #('$(VISUALWORKS)' 'parcels' 'suggestions-ja.xml').	file exists 		ifFalse: 			[Tools.ParcelFavoritesTool 				saveDefaultSuggestionsAs: (file withEncoding: #UTF8)]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="JapaneseLocale">asLargeArray	"Answer a new instance of LargeArray whose elements are the elements of	the receiver, in the same order."	| newArray |	newArray := LargeArray new: self size.	1 to: self size do: [:index | newArray at: index put: (self at: index)].	^newArray</body></methods><methods><class-id>Core.StringCollationPolicy</class-id> <category>private</category><body package="JapaneseLocale">japaneseCollate: s1 to: s2 	"Case insensitive(ASCII) Japanese JIS order collation method.	 Answer		-1 when s1 &lt; s2		  0 when s1 = s2		+1 when s1 &gt; s2"	| len1 len2 encoder encoder1 encoder2 encoder3 firstNonMatch |	encoder1 := CharacterEncoder encoderNamed: #'jisx0208.1983-0'.	encoder2 := CharacterEncoder encoderNamed: #'jisx0201.1976-0'.	encoder3 := CharacterEncoder encoderNamed: #'jisx0212.1990-0'.	encoder := [:c | | code |		code := encoder1 encode: c.		code == 65535			ifTrue: [code := encoder2 encode: c].		code == 65535 			ifTrue: ["Add in 16r8000 to differentiate from JISX0208. Use #bitOr: so that if the encoded character is 65535, we don't change it."				code := (encoder3 encode: c) bitOr: 16r8000].		code].	len1 := s1 size.	len2 := s2 size.	firstNonMatch := 0.	1 to: (len1 min: len2) do: [:i | 		| c1 c2 v1 v2 |		c1 := s1 at: i.		c2 := s2 at: i.		c1 = c2 ifFalse: [			v1 := c1 asUppercase.			v2 := c2 asUppercase.			v1 = v2 ifFalse: [				| u1 u2 |				u1 := encoder value: v1.				u2 := encoder value: v2.				(u1 == 65535 or: [u2 == 65535]) ifTrue: ["can not decode to JIS"					u1 := v1 asInteger.					u2 := v2 asInteger].				^u1 &lt; u2					ifTrue: [-1]					ifFalse: [1]				].			firstNonMatch == 0 ifTrue: [				firstNonMatch := c1 &lt; c2					ifTrue: [-1] ifFalse: [1]				].			].		].	len1 &lt; len2 ifTrue: [^-1].	len1 &gt; len2 ifTrue: [^1].	^firstNonMatch</body></methods><methods><class-id>Core.NumberReader</class-id> <category>initialize</category><body package="JapaneseLocale">japan	readSelector := #readLatinNumberFrom:type:.</body></methods><methods><class-id>Kernel.CodeReaderStream</class-id> <category>storage</category><body package="JapaneseLocale">readByteString	| ba |	format = 5 ifTrue: [^self readStringV5].	format &gt;= 8 ifTrue: [^self readGenericString].	ba := self readByteArray.	ByteString adoptInstance: ba.	^ba</body><body package="JapaneseLocale">readStringV5	| len ba type |	len := self readLength.	type := self readByte.	ba := ByteArray new: len.	readLimit - position &gt; len		ifTrue: [ba 				replaceElementsFrom: 1				to: len				withByteArray: collection 				startingAt: position + 1.				position := position + len]		ifFalse: [ self next: len into: ba startingAt: 1].	type = 1		ifTrue: [ba changeClassToThatOf: ' ']		ifFalse: [type = 2			ifTrue:				[ba changeClassToThatOf: TwoByteString new.				swap ifTrue: [ba reverseByteOrder]]			ifFalse: [self error: 'The unitSize for a String was ', type printString, '. Only 1 and 2 are permitted.']].	^ba</body><body package="JapaneseLocale">readTwoByteString	| ba |	format = 5 ifTrue: [^self readStringV5].	format &gt;= 8 ifTrue: [^self readGenericString].	ba := self readByteArray.	TwoByteString adoptInstance: ba.	swap ifTrue: [ba reverseByteOrder].	^ba</body></methods><methods><class-id>Graphics.PostScriptFontBody class</class-id> <category>parsing</category><body package="JapaneseLocale">parseAFMentry: string stack: subsectionStack modify: fontBody	| s t |	(self parseGenericEntry: string stack: subsectionStack modify: fontBody)		ifTrue: [^self].	s := string readStream.	t := self token: s.	t = 'CharWidth'		ifTrue:			[fontBody setDefaultWidth: (self decimalToken: s).			self decimalToken: s.			^self].	t = 'FontName'		ifTrue:			[fontBody fullName: s upToEnd.			^self].	t = 'FamilyName'		ifTrue:			[| family |			family := s upToEnd.			family := family copyReplaceAll: 'ITC ' with: ''.			fontBody family: family.			^self].	t = 'FullName'		ifTrue:			[fontBody extractWidthFrom: s upToEnd.			^self].	t = 'Weight'		ifTrue:			[| boldness |			boldness := s upToEnd.			boldness := self mapBoldnessName: boldness.			fontBody boldness: boldness.			^self].	t = 'ItalicAngle'		ifTrue:			[| italic |			italic := Number readFrom: s.			italic := italic ~= 0.			fontBody italic: italic.			^self].	t = 'IsFixedPitch'		ifTrue:			[| fixed |			fixed := s upToEnd.			fixed := fixed = 'true'.			fontBody fixedWidth: fixed.			^self].	t = 'Ascender'		ifTrue:			[| n |			n := Number readFrom: s.			fontBody ascent: n / 1000.0.			^self].	t = 'Descender'		ifTrue:			[| n |			n := Number readFrom: s.			fontBody descent: n / -1000.0.			^self].	t = 'UnderlinePosition'		ifTrue:			[| n |			n := Number readFrom: s.			fontBody underlinePosition: n / 1000.0.			^self].	t = 'UnderlineThickness'		ifTrue:			[| n |			n := Number readFrom: s.			fontBody underlineThickness: n / 1000.0.			^self].	t = 'FontBBox'		ifTrue:			[| n |			n := Number readFrom: s.			n := Number readFrom: s.			fontBody descent == nil				ifTrue: [fontBody descent: n / -1000.0].			n := Number readFrom: s.			n := Number readFrom: s.			fontBody ascent == nil				ifTrue: [fontBody ascent: n / 1000.0].			^self].	t = 'EncodingScheme'		ifTrue:			[t := s upToEnd.			t = 'AdobeStandardEncoding'				ifTrue: [fontBody encoder name: #AdobeStandardEncoding].			t = 'HRomanEncoding'				ifTrue: [fontBody encoder name: #psJisRoman].			t = 'FontSpecific'				ifTrue:					[(fontBody name findString: 'Symbol' startingAt: 1) &gt; 0						ifTrue: [fontBody encoder name: #'symbol'].					(fontBody name findString: 'ZapfDingbats' startingAt: 1) &gt; 0						ifTrue: [fontBody encoder name: #'zapf dingbats'].					(fontBody name findString: '-RKSJ-' startingAt: 1) &gt; 0						ifTrue:							[| sj |							sj := #{ShiftJISCharacterEncoder} value new.							sj name: #ShiftJIS.							sj mapUnprintableCharacters: false.							fontBody setEncoder: sj]].			('*JIS12*-88-CFEncoding' match: t)				ifTrue: [fontBody setEncoder:						(CharacterEncoder encoderNamed: #'jisx0208.1983-0')]].</body><body package="JapaneseLocale">parseCharMetric: string stack: subsectionStack modify: fontBody	| s t code width cName |	(self parseGenericEntry: string stack: subsectionStack modify: fontBody)		ifTrue: [^self].	s := string readStream.	self skipSeparators: s.	s atEnd ifTrue: [^self].	[s atEnd] whileFalse:		[t := self token: s.		t = 'C' ifTrue:				[code := self decimalToken: s.] ifFalse: [			t = 'CH' ifTrue:				[code := self hexToken: s.] ifFalse: [			(t = 'WX' or: [t = 'W0X']) ifTrue:				[width := self decimalToken: s.] ifFalse: [			t = 'N' ifTrue:				[cName := (self nameToken: s) asSymbol.] ifFalse: [			t = 'V' ifTrue:				[2 timesRepeat: [self decimalToken: s]] ifFalse: [			t = 'B' ifTrue:				[4 timesRepeat: [self decimalToken: s]] ifFalse: [			t = 'L' ifTrue:				[2 timesRepeat: [self nameToken: s]] ifFalse: [			self error: ((#errBadAFMProperty &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; not recognized') expandMacrosWith: t)]]]]]]].		(t := self token: s) = ';'			ifFalse: [self error: (#errExpectedSemiColon &lt;&lt; #dialogs &gt;&gt; 'Expected a ;')]].	width == nil ifTrue: [width := fontBody defaultWidth].	cName == nil		ifFalse:			[fontBody widths at: cName put: width.			fontBody encode: cName as: code]		ifTrue:			[code = -1 ifTrue: [self error: (#errCharacterNameAndCode &lt;&lt; #dialogs &gt;&gt; 'Character with no name and no code?')].			fontBody setTableSizeToAtLeast: code.			fontBody simpleWidths				at: code+1				put: width].</body></methods><methods><class-id>Graphics.PostScriptFontBody</class-id> <category>accessing</category><body package="JapaneseLocale">simpleWidths	simpleWidths == nil		ifTrue: [simpleWidths := LargeWordArray new: 256 withAll: 1000].	^simpleWidths</body><body package="JapaneseLocale">simpleWidthsScaledBy: aSize	"Answer an array that maps byte values to widths that are scaled by aSize."	^self simpleWidths asLargeArray collect: [:w | (w asFloat / 1000.0) * aSize]</body></methods><methods><class-id>Graphics.MSWindowsFont class</class-id> <category>utilities</category><body package="JapaneseLocale">defaultFontDescriptionIn: fontPolicy 	"Find the default font for the font policy.  This is run only once	per policy, when the policy is initialized."	^(fontPolicy graphicsDevice isKindOf: Screen) 		ifTrue: 			["Guess what font size the system			is using, or if we can't, choose a default."			| fd |			fd := fontPolicy availableFonts first.			(FontDescription new)				family: #('ms ui gothic' 'tahoma' 'ms sans serif' 'arial' 'helv*' '*');				pixelSize: (fd pixelSize = 0 ifTrue: [16] ifFalse: [fd pixelSize]);				boldness: 0.5;				italic: false]		ifFalse: 			["Printing."			(FontDescription new)				family: #('courier*' '*');				pixelSize: 12;				boldness: 0.5;				italic: false;				fixedWidth: true]</body></methods><methods><class-id>Graphics.MSWindowsFont class</class-id> <category>class initialization</category><body package="JapaneseLocale">installJapan	"MSWindowsFont installJapan"	KnownFixedWidthFamilies		add: 'ｍｓ ゴシック';		add: 'ｍｓ 明朝'</body></methods><methods><class-id>Graphics.VariableSizeTextAttributes class</class-id> <category>class initialization</category><body package="JapaneseLocale">initializeDefault	| style cStyle |	cStyle := VariableCharacterAttributes newWithDefaultAttributes.	cStyle setDefaultQuery: (FontDescription new			family: #( 'ＭＳ Ｐゴシック'  'helv' 'helvetica' 'arial' '*');			manufacturer: #('adobe' '*');			fixedWidth: false;			serif: false;			italic: false;			boldness: 0.5;			pixelSize: 12 "The actual value will be set later").	style := self new.	style setCharacterAttributes: cStyle.	style scalingFactor: 1.0.	style install.	self styleNamed: #systemDefault put: style.	self styleNamed: #default put: style</body><body package="JapaneseLocale">initializeLarge	| style cStyle |	cStyle := VariableCharacterAttributes newWithDefaultAttributes.	cStyle setDefaultQuery: (FontDescription new			family: #('ＭＳ Ｐゴシック' 'helv' 'helvetica' 'arial' '*');			manufacturer: #('adobe' '*');			fixedWidth: false;			serif: false;			italic: false;			boldness: 0.5;			pixelSize: 12 "The actual value will be set later").	style := self new.	style setCharacterAttributes: cStyle.	style scalingFactor: 1.2.	style install.	self styleNamed: #large put: style</body><body package="JapaneseLocale">initializeSmall	| style cStyle |	cStyle := VariableCharacterAttributes newWithDefaultAttributes.	cStyle setDefaultQuery: (FontDescription new			family: #('ＭＳ Ｐゴシック' 'helv' 'helvetica' 'arial' '*');			manufacturer: #('adobe' '*');			fixedWidth: false;			serif: false;			italic: false;			boldness: 0.5;			pixelSize: 12 "The actual value will be set later").	style := self new.	style setCharacterAttributes: cStyle.	style scalingFactor: 0.85.	style install.	self styleNamed: #small put: style</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>formats</category><body package="JapaneseLocale">defaultTimeFormats	| list |	list := List new.	list add: 'h:mm A/P'.	list add: 'h:mm:ss A/P'.	list add: 'h時mm分'.	list add: 'h時mm分ss秒'.	list add: 'AM/PMh時mm分'.	list add: 'AM/PMh時mm分ss秒'.	list add: 'h:mm'.	list add: 'h:mm:ss'.	^list</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>class initialization</category><body package="JapaneseLocale">initializeDefault	| style cStyle |		"We use VariableCharacterAttributes to get locale-sensitive		encodings and family names. We send the message #noScaling		because this class does not support fonts that change size		dramatically based on locale or screen resolution. If you		do not want locale sensitivity, use CharacterAttributes		instead."	cStyle := VariableCharacterAttributes newWithDefaultAttributes.	cStyle setDefaultQuery: (FontDescription new			family: #('ＭＳ Ｐゴシック' 'helv' 'helvetica' 'arial' '*');			manufacturer: #('adobe' '*');			fixedWidth: false;			serif: false;			italic: false;			boldness: 0.5;			pixelSize: 12).	cStyle noScaling.	style := self new.	style setCharacterAttributes: cStyle.	self styleNamed: #pixelDefault put: style</body><body package="JapaneseLocale">initializeLarge	| style cStyle |		"We use VariableCharacterAttributes to get locale-sensitive		encodings and family names. We send the message #noScaling		because this class does not support fonts that change size		dramatically based on locale or screen resolution. If you		do not want locale sensitivity, use CharacterAttributes		instead."	cStyle := VariableCharacterAttributes newWithDefaultAttributes.	cStyle setDefaultQuery: (FontDescription new			family: #('ＭＳ Ｐゴシック' 'helv' 'helvetica' 'arial' '*');			manufacturer: #('adobe' '*');			fixedWidth: false;			serif: false;			italic: false;			boldness: 0.5;			pixelSize: 14).	cStyle noScaling.	style := self new.	style setCharacterAttributes: cStyle.	style lineGrid: 20; baseline: 15.	self styleNamed: #pixelLarge put: style</body><body package="JapaneseLocale">initializeSmall	| style cStyle |		"We use VariableCharacterAttributes to get locale-sensitive		encodings and family names. We send the message #noScaling		because this class does not support fonts that change size		dramatically based on locale or screen resolution. If you		do not want locale sensitivity, use CharacterAttributes		instead."	cStyle := VariableCharacterAttributes newWithDefaultAttributes.	cStyle setDefaultQuery: (FontDescription new			family: #('ＭＳ Ｐゴシック' 'helv' 'helvetica' 'arial' '*');			manufacturer: #('adobe' '*');			fixedWidth: false;			serif: false;			italic: false;			boldness: 0.5;			pixelSize: 10).	cStyle noScaling.	style := self new.	style setCharacterAttributes: cStyle.	style lineGrid: 14; baseline: 10.	self styleNamed: #pixelSmall put: style</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>converting</category><body package="JapaneseLocale">asLargeArray	"Answer a new instance of LargeArray whose elements are the elements of	the receiver, in the same order."	| newArray |	newArray := LargeArray new: self size.	1 to: self size do: [:index | newArray at: index put: (self at: index)].	compressed ifTrue: [newArray compress].	^newArray</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>enumerating</category><body package="JapaneseLocale">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection that is like 	the receiver.  Answer the new collection."	| newCollection |	newCollection := self emptyCopyWithSize: self size.	1 to: self size do: [:index |		newCollection at: index put: (aBlock value: (self at: index))].	compressed ifTrue: [newCollection compress].	^newCollection</body></methods><methods><class-id>Core.SegmentedCollection</class-id> <category>private</category><body package="JapaneseLocale">emptyCopyWithSize: aSize	"This protocol allows the copy to have similar	state to that of the receiver, if a subclass adds	state that should be transmitted, such as a per	instance page size.	The contents of the copy are not those of the	receiver, but are uninitialized."	^self class new: aSize</body></methods><methods><class-id>Graphics.ScreenFont class</class-id> <category>class initialization</category><body package="JapaneseLocale">installJapan	"ScreenFont installJapan."	| sjisEncoder mscp932Encoder |	sjisEncoder := ShiftJISCharacterEncoder new.	sjisEncoder name: #ShiftJIS.	sjisEncoder mapUnprintableCharacters: false.	mscp932Encoder := self mscp932Encoder.	(FontEncodings at: 'X11') at: 'jisx0201.1976-0' put: self jis0201Encoder.	(FontEncodings at: 'X11') at: 'jisx0208.1983-0' put: self jis0208Encoder.	(FontEncodings at: 'X11') at: 'jisx0212.1990-0' put: self jis0212Encoder.	(FontEncodings at: 'MacOSX') at: 'macJapanese' put: sjisEncoder.	(FontEncodings at: 'MS-Windows') at: 'kanji' put: mscp932Encoder.	(FontEncodings at: 'MS-Windows') at: 'ms_cp_932' put: mscp932Encoder.</body><body package="JapaneseLocale">jis0201Encoder	| map badChar |	map := CharacterEncoder createJIS0201.	badChar := Character illegalCode asCharacter.	0 to: 31 do:		[:i | map encode: badChar as: i].	map encode: badChar as: 16r7F.	map name: #'jisx0201.1976-0'.	^map</body><body package="JapaneseLocale">jis0208Encoder	^CharacterEncoder encoderNamed: #'jisx0208.1983-0'</body><body package="JapaneseLocale">jis0212Encoder	^CharacterEncoder encoderNamed: #'jisx0212.1990-0'</body><body package="JapaneseLocale">mscp932Encoder	| map badChar |	map := CharacterEncoder createMSCP932.	badChar := Character illegalCode asCharacter.	0 to: 31 do:		[:i | map encode: badChar as: i].	map encode: badChar as: 16r7F.	map name: #'ms_cp_932'.	^map</body><body package="JapaneseLocale">unInstallJapan	"ScreenFont unInstallJapan"	FontEncodings := nil.	self initializeEncodings</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>reading Japanese</category><body package="JapaneseLocale">checkForJapaneseAMPM: aStream	| p ampm |	p := aStream position.	ampm := printPolicy interpretAmPm: (aStream nextAvailable: 2) asLowercase.	ampm == nil ifTrue: [aStream position: p].	^ampm</body><body package="JapaneseLocale">checkJapaneseSeparator: expectedChar in: aStream mode: mode	| nextChar found |	mode value == nil		ifTrue:			[nextChar := aStream peek.			nextChar = printPolicy timeSeparator				ifTrue:					[mode value: #latin.					aStream next.					^true].			nextChar = expectedChar				ifTrue:					[mode value: #japanese.					aStream next.					^true].			^false].	mode value == #latin		ifTrue: [^aStream peekFor: printPolicy timeSeparator].	mode value == #japanese		ifTrue:			[found := aStream peekFor: expectedChar.			found ifFalse: [self error: ('Expected to find &lt;1p&gt;'								expandMacrosWith: expectedChar)].			^found]</body><body package="JapaneseLocale">getJapaneseDateToken: aStream mode: mode	| ch n errorBlock |	errorBlock :=		[self error: 'End of data encountered without finding an expected part of the date'].	mode value == nil		ifTrue:			[[ch := aStream peek.			ch == nil or: [ch isLetter or: [ch isDigit]]]				whileFalse: [aStream next].			ch == nil ifTrue: [^errorBlock value].			ch isDigit ifFalse: [^errorBlock value].			n := Integer readFrom: aStream.			ch := aStream peek.			('年月日' includes: ch)				ifTrue:					[aStream next.					mode value: #japanese.					^n-&gt;ch]				ifFalse:					[mode value: #latin.					^n]].	mode value == #latin		ifTrue:			[[ch := aStream peek.			ch == nil or: [ch isLetter or: [ch isDigit]]]				whileFalse: [aStream next].			ch == nil ifTrue: [^errorBlock value].			ch isDigit ifFalse: [^errorBlock value].			^Integer readFrom: aStream].	mode value == #japanese		ifTrue:			[ch := aStream peek.			ch == nil ifTrue: [^errorBlock value].			ch isDigit ifFalse: [^errorBlock value].			n := Integer readFrom: aStream.			ch := aStream next.			('年月日' includes: ch)				ifTrue:					[^n-&gt;ch]				ifFalse:					[errorBlock value]].</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>initialize</category><body package="JapaneseLocale">japan	timeSelector := #readJapaneseTimeFrom:.	dateSelector := #readJapaneseDateFrom:.	timestampSelector := #readJapaneseTimestampFrom:.</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>reading Japanese</category><body package="JapaneseLocale">readJapaneseDateFrom: aStream	"Answer a Date read from the argument aStream in any of	 the forms:		&lt;year&gt;	&lt;monthNumber&gt; &lt;day&gt; (1982年4月5日, 1982/4/5/, 1982-4-5)"	"(Locale named: #'ja_JP.JEUC') readDateFrom: '1982年4月5日' readStream"	| day month token1 token2 token3 year tokens mode |	mode := nil asValue.	token1 := self getJapaneseDateToken: aStream mode: mode.	token2 := self getJapaneseDateToken: aStream mode: mode.	token3 := self getJapaneseDateToken: aStream mode: mode.	mode value == #japanese		ifTrue:			[tokens := Dictionary new					at: token1 value put: token1 key;					at: token2 value put: token2 key;					at: token3 value put: token3 key;					yourself.			'年月日' do: [:c |				(tokens includesKey: c)					ifFalse: [self error: ('The date string did not contain "&lt;1s&gt;"'										expandMacrosWith: (String with: c))]].			year := tokens at: $年.			month := tokens at: $月.			day := tokens at: $日.]		ifFalse:			[tokens := Array with: token1 with: token2 with: token3.			day := tokens at: (printPolicy dateMiniFormat indexOf: $d).			month := tokens at: (printPolicy dateMiniFormat indexOf: $m).			year := tokens at: (printPolicy dateMiniFormat indexOf: $y)].	^Date newDay: day monthNumber: month year: year</body><body package="JapaneseLocale">readJapaneseTimeFrom: aStream	"Answer a Time as read from the argument aStream	that is in the form:		&lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; &lt;am/pm&gt; 	&lt;minute&gt;, &lt;second&gt; or &lt;am/pm&gt; may be omitted. 	such as,			午後1時59分30秒			1:59:30 pm			8AM			15:30	"	"Locale current readTimeFrom: '午後1時59分30秒' readStream"	| hour minute second ampm mode |	ampm := self checkForJapaneseAMPM: aStream.	hour := Integer readFrom: aStream.	second := 0.	mode := nil asValue.	(self checkJapaneseSeparator: $時 in: aStream mode: mode)		ifFalse: [minute := 0]		ifTrue:			[minute := Integer readFrom: aStream.			(self checkJapaneseSeparator: $分 in: aStream mode: mode)				ifTrue:					[second := Integer readFrom: aStream.					mode value == #japanese						ifTrue: [(aStream peekFor: $秒)							ifFalse: [self error: ('Expected to find &lt;1p&gt;'									expandMacrosWith: $秒)]]]].	aStream skipSeparators.	ampm == nil		ifTrue: [ampm := self checkForJapaneseAMPM: aStream].	ampm == nil		ifFalse:			[hour = 12				ifTrue: [ampm == #am ifTrue: [hour := 0]]				ifFalse: [ampm == #pm ifTrue: [hour := hour + 12]]].	(hour &gt;= 0 and: [hour &lt;= 23])		ifFalse: [self error: ('&lt;1p&gt; is not a valid hour' expandMacrosWith: hour)].	(minute &gt;= 0 and: [minute &lt;= 59])		ifFalse: [self error: ('&lt;1p&gt; is not a valid minute' expandMacrosWith: minute)].	(second &gt;= 0 and: [second &lt;= 59])		ifFalse: [self error: ('&lt;1p&gt; is not a valid second' expandMacrosWith: second)].	^Time fromSeconds: 60*(60*hour+minute)+second</body><body package="JapaneseLocale">readJapaneseTimestampFrom: stream	"Answer a Timestamp read from stream, which we expect to contain a Date,	an optional Time.  The Time may be followed by a decimal point and a Number,	which we interpret as milliseconds."	"NOTE: There is currently no difference between this and the Latin method,	but it has been copied as a hedge against more sophisticated, non-portable	support of either Latin or Japanese Timestamps in the future."	| date time milliseconds timestamp |	stream atEnd ifTrue: [ ^nil ].	date := self readDateFrom: stream.	date isNil ifTrue: [ ^nil ].	stream skipSeparators.	milliseconds := 0.	stream atEnd		ifTrue: [time := Time fromSeconds: 0]		ifFalse:			[time := self readTimeFrom: stream.			(stream peekFor: $.)				ifTrue:					[| count fraction |					count := 0.					fraction := 1.					[stream atEnd not and: [stream peek isDigit]] whileTrue:						[count := count * 10 + stream next digitValue.						fraction := fraction*10].					milliseconds := (count * 1000 / fraction) truncated]].	timestamp := Timestamp new fromDate: date andTime: time.	timestamp millisecond: milliseconds.	^timestamp</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private reading</category><body package="JapaneseLocale">readHeader	| storedEndianness platIsEndianness headerSize bytecodeVersion specialSelectorsVersion comment |	storedEndianness := self readByte.	platIsEndianness := UninterpretedBytes isBigEndian ifTrue: [1] ifFalse: [0].	storedEndianness = platIsEndianness		ifFalse: [stream swap: true].	format := self readLong.	self checkFormat.	stream format: format.	"Version 5 starts the use of an explicit header size."	headerSize := format &lt;= 5 ifTrue: [512] ifFalse: [self readLong].	comment := self readByteString.	CodeWriter fileComment = comment ifFalse:		[CodeReader fileFormatSignal raise].	format &gt;= 7 ifTrue:		[parcelName := self readByteString.		versionString := self readByteString].	dateString := self readByteString.	timeString := self readByteString.	objectSpaceSize := self readLong.	mclassNum := self readLong.	mclassclassNum := self readLong.	refNamObjNum := format &gt;= 11 ifTrue: [self readLong] ifFalse: [0].	numNamedObjects := format &gt;= 11 ifTrue: [self readLong] ifFalse: [0].	numClasses := self readLong.	numExtensionMethods := self readLong.	scopeZonesNum := self readLong.	symbolNum := self readLong.	twoByteSymbolNum := self readLong.	stringNum := self readLong.	twoByteStringNum := self readLong.	byteArrayNum := self readLong.	floatNum := self readLong.	doubleNum := self readLong.	largePositiveNum := self readLong.	largeNegativeNum := self readLong.	fixedNum := defObjOrganizerNum := 0.	format &gt;= 14		ifTrue: [defObjOrganizerNum := self readLong]		ifFalse: [fixedNum := self readLong].	classOrganizerNum := self readLong.	arbClassNum := self readLong.	arbObjectNum := self readLong.	userStringsNum := self readLong.	"Version two starts the support for NamedObjects"	format &gt; 1		ifTrue: [namedObjectsNum := self readLong]		ifFalse: [namedObjectsNum := 0].	"Version 5 starts the support of Parcel sources"	format &gt; 5 ifTrue:		[sourceFile := self readByteString.		sourceFile isEmpty ifTrue: [sourceFile := nil].		hideSource := self readByte ~= 0].	"Version 12 starts the support of bytecode version info"	format &gt;=12		ifTrue:			[bytecodeVersion := self readByte.			specialSelectorsVersion := self readByte]		ifFalse:			[bytecodeVersion := 25. "ObjectWorks 2.5 introduced the HPS instruction set"			specialSelectorsVersion := 30 "Standard specialSelectors as of VisualWorks 3.0"].	mustRecompile := bytecodeVersion ~= DefineOpcodePool bytecodeVersion						or: [specialSelectorsVersion ~= DefineOpcodePool specialSelectorsVersion].	stream position: headerSize</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>api</category><body package="JapaneseLocale">readInfoFromFileNamed: aFilename	"Answer aDictionary of useful information from the Parcel named aFilename."	| info timestamp |	info := Dictionary new.	self createStreamFromFileNamed: aFilename.	[self readHeader.	 format &gt;= 7 ifTrue:		[info at: #prerequisiteParcels put: OrderedCollection new.		self readActionsAndPrerequisitesInto:				[:actions :prerequisites|				 prerequisites do:					[:tuple|					(tuple at: 1) = 'parcel'						ifTrue:							[(info at: #prerequisiteParcels)								add: (tuple copyFrom: 2 to: 3)]						ifFalse:							[info at: tuple first asSymbol								put: (tuple copyFrom: 2 to: tuple size - 1)]]]]]		ensure: [stream close].	parcelName size &gt; 0 ifTrue: [info at: #parcel put: parcelName].	versionString size &gt; 0 ifTrue: [info at: #version put: versionString].	info at: #format put: format.	timestamp := format = 5		ifTrue: [Locale current readTimestampFrom: (dateString, ' ', timeString) readStream]		ifFalse: [Timestamp readFromDateAndTime: (dateString, ' ', timeString) readStream].	timestamp notNil ifTrue:		[info at: #timestamp put: timestamp].	^info</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private reading</category><body package="JapaneseLocale">readProperties	"Version two starts the support for the postLoadMethod, which is replaced by a block in Version 15."	"Version 4 starts use of the general heap to store userStrings/properties.	 Version 5 stores properties as a Dictionary."	| timestamp postLoadMethod "&lt;Array of: Symbol&gt;  Class name and selector; the message to send after loading" |	(format between: 2 and: 15) ifTrue: [postLoadMethod := self readObject].	format &gt;= 4 ifTrue:		[((properties := self readObject) isKindOf: Dictionary) ifFalse:			[| userStrings |			userStrings := properties.			properties := Dictionary new.			1 to: userStrings size by: 2 do:				[:i| properties at: (userStrings at: i) asSymbol put: (userStrings at: i + 1)]]].	timestamp := format = 5		ifTrue: [Locale current readTimestampFrom: (dateString, ' ', timeString) readStream]		ifFalse: [Timestamp readFromDateAndTime: (dateString, ' ', timeString) readStream].	timestamp notNil ifTrue:		[properties at: #timestamp put: timestamp].	mustRecompile		ifTrue: [properties at: #recompile put: true]		ifFalse: [properties removeKey: #recompile ifAbsent: nil].	"Action methods have been replaced by action blocks.	 Convert any old method actions to equivalent block actions."	format &lt;= 15 ifTrue:		[postLoadMethod notNil ifTrue:			[properties at: #postLoadMethod put: postLoadMethod].		self convertOldActions]</body></methods><methods><class-id>Core.TimestampPrintPolicy</class-id> <category>initialize-release</category><body package="JapaneseLocale">japan	"Initialize for Japan."	self shortPolicyString: 'yyyy/mm/dd h:mm:ss.fff;yy/mm/dd;h:mm:ss A/P;'.	self longPolicyString: 'yyyy年m月d日 h:mm:ss.fff;yyyy年m月d日;am/pmh時m分s秒;'.	self policyNamed: #editing putString: 'yyyy/mm/dd h:mm:ss.fff;yyyy/mm/dd;h:mm:ss A/P;'.	self	policyNamed: #timeEditing putString: 'h:mm:ss.fff;;h:mm:ss;'.	dateMiniFormat := #ymd.	timeSeparator := $:.	shortWeekdays := #('月' '火' '水' '木' '金' '土' '日').	longWeekdays := #('月曜日' '火曜日' '水曜日' '木曜日' '金曜日' '土曜日' '日曜日').	shortMonths := #('1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12').	longMonths := #('01' '02' '03' '04' '05' '06' '07' '08' '09' '10' '11' '12').	shortAmPm := #('am' 'pm').	longAmPm := #('午前' '午後')</body></methods><methods><class-id>Graphics.FontPolicy class</class-id> <category>class initialization</category><body package="JapaneseLocale">initializeEncodingCrossReference	self link: 'ascii'		toAll: #('iso8859-1' 'mac' 'ibm850' 'AdobeStandardEncoding' 'ansi' 'ms_cp_1252')		penalty: 0.0		table: EncodingTable.	self link: 'ascii'		toAll: #('hp-roman8' 'psJisRoman')		penalty: 0.01		table: EncodingTable.	self link: 'ascii'		toAll: #('jisx0201.1976-0')		penalty: 0.3		table: EncodingTable.	self crossLinkAll: #('iso8859-1' 'hp-roman8' 'mac' 'ibm850' 'AdobeStandardEncoding' 'ansi' 'ms_cp_1252' 'psJisRoman')		penalty: 0.1		table: EncodingTable.	self crossLinkAll: #('ShiftJIS' 'kanji' 'ms_cp_932' 'macJapanese')		penalty: 0.1		table: EncodingTable.	self crossLinkAll: #('jisx0201.1976-0' 'psJisRoman')		penalty: 0.01		table: EncodingTable.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>PostScriptFontBody</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName family boldness italic serif fixedWidth setWidth widths simpleWidths defaultWidth encoder ascent descent underlinePosition underlineThickness fontSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Printing-PostScript</category><attributes><package>Graphics-Printing-PostScript</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SegmentedCollection</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>compressed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ParagraphEditor</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>NumberPrintPolicy</name><environment>Core</environment><super>Core.PrintPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policy thousandsSeparator decimalPoint groupingSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>StringCollationPolicy</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Collections-Collation</package></attributes></class><class><name>TimestampPrintPolicy</name><environment>Core</environment><super>Core.PrintPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policies dateMiniFormat timeSeparator shortWeekdays longWeekdays narrowWeekdays shortMonths longMonths narrowMonths shortAmPm longAmPm tokenProcessingDispatchTable tokenInterpretationDispatchTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>TimestampReader</name><environment>Core</environment><super>Core.LocaleSensitiveDataReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeSelector dateSelector timestampSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>CodeReaderStream</name><environment>Kernel</environment><super>OS.ExternalReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>swap isBigEndianPlatform scratchBuffer format </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>NumberReader</name><environment>Core</environment><super>Core.LocaleSensitiveDataReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>CodeReader</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream pointer format parcelName versionString dateString timeString numNamedObjects numClasses numExtensionMethods definedObjects definedBindings definedExternals classes classSelectors categories packageEnvironment packageUndeclared extensionMethods objectSpaceSize objectSpace symbolNum twoByteSymbolNum stringNum twoByteStringNum byteArrayNum floatNum doubleNum fixedNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbClassNum arbObjectNum messageSendIndices properties userStringsNum namedObjects namedObjectsNum postLoadObjects streamDir sourceFile hideSource importMaps overriddenExtensions versionSelectionBlock warningSuppressionBlock preReadBlock currentSuperclass mustRecompile lateOperations updates tempSourceFile compilationManager </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class></st-source>