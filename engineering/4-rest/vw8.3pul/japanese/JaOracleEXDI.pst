<?xml version="1.0"?><st-source><!-- Name: JaOracleEXDINotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: This parcel supports the localization of the OracleEXDI for Japanese.DbIdentifier: bear73DbTrace: 400890DbUsername: nrossDbVersion: 7.4.1 1.3DevelopmentPrerequisites: #(#(#parcel 'OracleEXDI' '') #(#parcel 'JapaneseLocale' ''))HideSource: falsePackageName: JaOracleEXDIParcel: #('JaOracleEXDI')ParcelName: JaOracleEXDIPrerequisiteParcels: #(#('OracleEXDI' '') #('JapaneseLocale' ''))PrintStringCache: (7.4.1 1.3,nross)SaveSource: trueVersion: 7.4.1 1.3Date: 7:26:58 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 7:26:58 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Database.OracleNTInterface</class-id> <category>parameter</category><body package="JaOracleEXDI">getOracleParameterString: parameterName	"Answer the value of the named Oracle7 parameter, which must be a string.	If not present, answer the empty string.	If the corresponding registry entry is typed as a string(REG_SZ or REG_EXPAND_SZ),	use it as given.  If it is instead typed as a free-form binary value (REG_BINARY), then	the contents are assumed to describe a string in the default platform encoding."	| storedKey initialKey key buffer bufferSize count type errorCode parameterString environmentVariable |   	environmentVariable := super getOracleParameterString: parameterName.   	(environmentVariable isNil or: [environmentVariable isEmpty]) ifFalse: [^environmentVariable asSymbol].	bufferSize := 256.	parameterString := ''.	[buffer := CIntegerType char malloc: bufferSize.	count := CIntegerType long malloc.	type := CIntegerType unsignedLong "dword" malloc.	storedKey := CVoidType void pointerType malloc.	initialKey := CVoidType void pointerType malloc.	initialKey contents: (CVoidType void pointerType cast: self HKEY_LOCAL_MACHINE).	key := initialKey.	#('SOFTWARE' 'ORACLE') do:			[:subKey |			errorCode := self regOpenKey: key contents subKey: subKey result: storedKey.			errorCode = self ERROR_SUCCESS ifFalse: [^''].			key := storedKey].	count contents: bufferSize.	errorCode := self regQueryValueEx: key contents					name: parameterName					reserved: nil					type: type					data: buffer					size: count.	errorCode = self ERROR_SUCCESS ifFalse: [^''].	(type contents = self REG_EXPAND_SZ or: [type contents = self REG_SZ])		ifTrue: [parameterString := buffer copyCStringFromHeap]	ifFalse:[type contents = self REG_BINARY		ifTrue: [| bytes |			bytes := ByteArray new: count contents.			buffer copyAt: 0 to: bytes size: count contents startingAt: 1.					parameterString := IOAccessor convertSimpleStringFromPlatform: bytes]	ifFalse: [^'']]]			valueNowOrOnUnwindDo:				[initialKey notNil ifTrue: [initialKey freePointer].				storedKey notNil ifTrue: [storedKey freePointer].				buffer notNil ifTrue: [buffer freePointer].				type notNil ifTrue: [type freePointer].				count notNil ifTrue: [count freePointer]].	^parameterString</body></methods><methods><class-id>Database.OracleNTInterface</class-id> <category>constants</category><body package="JaOracleEXDI">REG_BINARY	^3</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>class initialization</category><body package="JaOracleEXDI">initializeEncoderMap	"OracleConnection initializeSignalMap"	EncoderMap := Dictionary new.	EncoderMap		at: 'US7ASCII'			put: #ASCII;		at: 'JA16EUC'			put: #JapaneseEUC;		at: 'JA16SJIS'			put: #MS_CP_932;		at: 'WE8ISO8859P1'		put: #ISO8859_1;		at: 'EE8ISO8859P2'		put: #ISO8859_2;		at: 'SE8ISO8859P3'		put: #ISO8859_3;		at: 'NEE8ISO8859P4'	put: #ISO8859_4;		at: 'CL8ISO8859P5'		put: #ISO8859_5;		at: 'AR8ISO8859P6'		put: #ISO8859_6;		at: 'EL8ISO8859P7'		put: #ISO8859_7;		at: 'IW8ISO8859P8'		put: #ISO8859_8;		at: 'WE8ISO8859P9'		put: #ISO8859_9;		at: 'NE8ISO8859P10'	put: #ISO8859_10;		at: 'WE8ISO8859P15'	put: #ISO8859_15;		at: 'WE8ROMAN8'		put: #hp_roman8;		at: 'US8PC437'			put: #ibm437;		at: 'EL8PC737'			put: #ibm737;		at: 'BLT8PC775'			put: #ibm775;		at: 'WE8PC850'			put: #ibm850;		at: 'EE8PC852'			put: #ibm852;		at: 'RU8PC855'			put: #ibm855;		at: 'TR8PC857'			put: #ibm857;		at: 'WE8PC860'			put: #ibm860;		at: 'IS8PC861'			put: #ibm861;		at: 'IW8PC1507'			put: #ibm862;		at: 'CDN8PC863'		put: #ibm863;		at: 'N8PC865'			put: #ibm865;		at: 'RU8PC866'			put: #ibm866;		at: 'EL8PC869'			put: #ibm869;		at: 'AR8ARABICMAC'	put: #macarabic;		at: 'EE8MACCE'			put: #maccenteuro;		at: 'EE8MACCROATIAN'	put: #maccroatian;		at: 'WE8MACROMAN8'	put: #macroman;		at: 'EL8MACGREEK'	put: #macgreek;		at: 'IS8MACICELANDIC'	put: #maciceland;		at: 'CL8MACCYRILLIC'	put: #maccyrillic;		at: 'IW8MACHEBREW'	put: #machebrew;		at: 'TR8MACTURKISH'	put: #macturkish;		at: 'EE8MSWIN1250'	put: #'windows-1250';		at: 'CL8MSWIN1251'		put: #'windows-1251';		at: 'WE8MSWIN1252'	put: #'windows-1252';		at: 'EL8MSWIN1253'		put: #'windows-1253';		at: 'TR8MSWIN1254'	 	put: #'windows-1254';		at: 'IW8MSWIN1255'		put: #'windows-1255';		at: 'AR8MSWIN1256'	put: #'windows-1256';		at: 'BLT8MSWIN1257'	put: #'windows-1257';		at: 'VN8MSWIN1258'	put: #'windows-1258';		at: 'UTF8'				put: #utf_8;		at: 'AL24UTFFSS'		put: #utf_8.</body></methods><methods><class-id>Database.OracleBuffer</class-id> <category>initialize-release</category><body package="JaOracleEXDI">for: value conv: convSymbol count: allocCount size: size	| elemSize externalType nextSize |	nullsPossible := true.	(convSymbol == #Array) ifTrue: [ | type |		type := self session findRightBindingType: value.		^self for: value conv: type count: allocCount size: size].	convSymbol isNil ifTrue:		[ externalType := 1. "VARCHAR2"		elemSize := 256 ].	(convSymbol == #String or: [convSymbol == #ByteArray]) ifTrue:		[ "Infer elemSize if size isn't given"		(elemSize := size) isNil			ifTrue:				[ "If it's an array, we want to take the longest one so that the buffer will fit them all."				(allocCount &gt; 1 or: [value isKindOf: Array])					ifTrue:						[ elemSize := value inject: 0 into:							[ :currentMax :nextValue |							nextSize := ((nextValue isKindOf: Text) or: [(nextValue isKindOf:String) or: [nextValue isKindOf: ByteArray]] )								ifTrue: [									(nextValue isKindOf: ByteArray) ifTrue:[ 										nextValue size									] ifFalse: [ 										(ByteArray fromString: nextValue encoding: self encoding) size ].								] ifFalse: [nextValue].							nextValue == nil								ifTrue: [ currentMax ]								ifFalse: [ nextSize &gt; currentMax ifTrue: [ nextSize ] ifFalse: [ currentMax ] ] ] ]					ifFalse:						[ elemSize := ((value isKindOf: ByteArray) ifTrue: [							value] ifFalse: [(ByteArray fromString: value encoding: self encoding)]) size].				convSymbol == #String 					ifTrue: 					["In Asian stream encodings (like EUC), each character can			  		take up to four bytes.  Adjust the buffer size accordingly."					elemSize := elemSize * 2]].		convSymbol == #String ifTrue:			[ externalType := 1. "VARCHAR2"			elemSize &gt; 4000 ifTrue:				[ externalType := 94. "LONG VARCHAR"				elemSize := 4 + ((elemSize + 3) // 4 * 4) ] ].		convSymbol == #ByteArray ifTrue:			[ externalType := 23. "RAW"			elemSize &gt; 2000 ifTrue:				[ externalType := 95. "LONG VARRAW"				elemSize := 4 + ((elemSize + 3) // 4 * 4) ] ] ].	convSymbol == #Char ifTrue:		[ externalType := 96. "CHAR"		size isNil			ifTrue: [ elemSize := value size ]			ifFalse: [ elemSize := size ] ].	convSymbol == #Timestamp ifTrue:		[ externalType := 12. "DATE"		elemSize := 7.		tempArray := ByteArray new: 7 ].	convSymbol == #Float ifTrue:		[ externalType := 4. "FLOAT"		elemSize := 4 ].	convSymbol == #Double ifTrue:		[ externalType := 4. "FLOAT"		elemSize := 8 ].	convSymbol == #Integer32 ifTrue:		[ externalType := 3. "32-bit signed integer"		elemSize := 4 ].	(convSymbol == #Integer or: [convSymbol == #FixedPoint]) ifTrue:		[ externalType := 6. "VARNUM"		elemSize := 22.		tempArray := ByteArray new: 22 ].	convSymbol == #MLSLABEL ifTrue:		[ externalType := 106. "MLSLABEL"		elemSize := 255 ].	self elementSize: elemSize count: allocCount databaseType: externalType.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>OracleBuffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indicatorsPointer lengthsPointer rcodesPointer cursizPointer getSelector setSelector nullsPossible tempArray session isUnicodeColumn position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><class><name>OracleNTInterface</name><environment>Database</environment><super>Database.OracleInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleNTInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>oci.dll</item> <item>advapi32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class></st-source>