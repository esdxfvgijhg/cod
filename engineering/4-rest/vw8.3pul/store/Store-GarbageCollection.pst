<?xml version="1.0"?><st-source><!-- Name: Store-Garbage CollectionNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: This package contains the Store Garbage Collector and all of the Store.Glorp objects it uses. It is a stand-alone mechanism and package/parcel.  Components ca be marked for deletion using the StoreBase UI, but this must be loaded for them actually to be removed from the database.DbIdentifier: bear73DbTrace: 495138DbUsername: trobinsonDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'StoreBase' ''))PackageName: Store-Garbage CollectionParcel: #('Store-Garbage Collection')ParcelName: Store-Garbage CollectionPrerequisiteDescriptions: #(#(#name 'StoreBase'))PrerequisiteParcels: #(#('StoreBase' ''))PrintStringCache: (8.3 - 1,trobinson)Version: 8.3 - 1Date: 12:56:39 PM October 14, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (oct16.1) of October 7, 2016 on October 14, 2016 at 12:56:39 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StorePackageRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Garbage Collection</package></attributes></class><comment><class-id>Store.Glorp.StorePackageRelationship</class-id><body>StorePackageRelationship is an abstract superclass for all X-to-package relationship classes, which on one side point to a package and on the other, either a Class, NameSpace, SharedVariable, Method or Property.  It and its subclasses differ from StoreObjectInPackage and its subclasses by holding only the primaryKeys of its package and its object, not the whole package or object.  This avoids reading the whole object to assess relationships and determine deletion, so may speed the Garbage Collector.Instance Variables	packageRef	&lt;Integer&gt;	The primarykey of the related package</body></comment><class><name>StoreNameSpaceToPackageRelationship</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePackageRelationship</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaceRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Garbage Collection</package></attributes></class><comment><class-id>Store.Glorp.StoreNameSpaceToPackageRelationship</class-id><body>StoreNameSpaceToPackageRelationship defines the TW_PkgNamespaces relationship table as an Object.Instance Variables	namespaceRef	&lt;Integer&gt;	primary key for the related Namepspace table object</body></comment><class><name>StoreDescriptorForDelete</name><environment>Store.Glorp</environment><super>Store.Glorp.Store73DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Garbage Collection</package></attributes></class><comment><class-id>Store.Glorp.StoreDescriptorForDelete</class-id><body>StoreDescriptorForDelete is a special descriptor used only when Garbage Collecting (deleting) Store objects from a repository.  It omits #versionless mappings, models package-to-object relationships as primaryKey pairs, not object pairs, and makes ParcelRecord-to-blob relationships exclusive to force deletion of those blobs.</body></comment><class><name>StoreMethodToPackageRelationship</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePackageRelationship</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Garbage Collection</package></attributes></class><comment><class-id>Store.Glorp.StoreMethodToPackageRelationship</class-id><body>StoreMethodToPackageRelationship defines the TW_Methods relationship table as an ObjectInstance Variables	methodRef	&lt;Integer&gt;	The primary key of the related method definition</body></comment><class><name>GarbageCollector</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session packageKeys classKeys methodKeys namespaceKeys sharedKeys packageParentKeys parcelKeys packagePropertyKeys packageBlessingKeys blobKeys methodPairs classPairs namespacePairs sharedVariablePairs packageReparentKeys methodReparentKeys sharedReparentKeys classReparentKeys namespaceReparentKeys binaryBlobKeys bundleKeys bundleParentKeys bundlePropertyKeys bundleFileKeys bundleBlessingKeys bundleReparentKeys inClauseLimit allPackageKeys allBundleKeys totalsDictionary startTime endTime </inst-vars><class-inst-vars>defaultINClauseLimit pundleLoopSize </class-inst-vars><imports>			private Store.Glorp.*			private Glorp.*			</imports><category>Store-Database</category><attributes><package>Store-Garbage Collection</package></attributes></class><comment><class-id>Store.GarbageCollector</class-id><body>Removes packages from the database and collects the "garbage." It first analyzes and buids up the lists of things no longer referenced, then removes them.packageKeys and parentKeys are specifically a 1 : 1 collection, and the order of them is package timestamp descending (newest first). This gives us a way to walk the pairs in a way that allows us to hookup packages which have parents which are being removed, all the way up till a non removed parent is seen, or 0 (meaning all parents are gone).Instance Variables</body></comment><class><name>StoreSharedToPackageRelationship</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePackageRelationship</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedVariableRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Garbage Collection</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedToPackageRelationship</class-id><body>StoreSharedToPackageRelationship defines the TW_Data (SharedVariable) relationship table as an ObjectInstance Variables	sharedVariableRef	&lt;Integer&gt;	The primary key of the related Shared Variable definition</body></comment><class><name>StoreClassToPackageRelationship</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePackageRelationship</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Garbage Collection</package></attributes></class><comment><class-id>Store.Glorp.StoreClassToPackageRelationship</class-id><body>StoreClassToPackageRelationship defines the TW_PkgClasses relationship table as an ObjectInstance Variables	classRef	&lt;Integer&gt;	The primary key of the related class (or metaclass) definition</body></comment><methods><class-id>Store.Glorp.StorePackageRelationship</class-id> <category>accessing</category><body package="Store-Garbage Collection">packageRef	^packageRef</body><body package="Store-Garbage Collection">packageRef: anObject	packageRef := anObject</body></methods><methods><class-id>Store.Glorp.StoreNameSpaceToPackageRelationship</class-id> <category>accessing</category><body package="Store-Garbage Collection">namespaceRef	^namespaceRef</body><body package="Store-Garbage Collection">namespaceRef: anInteger	namespaceRef := anInteger</body></methods><methods><class-id>Store.Glorp.StoreDescriptorForDelete</class-id> <category>descriptors</category><body package="Store-Garbage Collection">descriptorForDefinitionToPackageRelationship: aDescriptor	(aDescriptor newMapping: DirectMapping) 		from: #packageRef		to: (aDescriptor table fieldNamed: 'packageRef').</body><body package="Store-Garbage Collection">descriptorForStoreClassToPackageRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_PkgClasses'.	aDescriptor table: table.	self descriptorForDefinitionToPackageRelationship: aDescriptor.	(aDescriptor newMapping: DirectMapping) 		from: #classRef		to: (table fieldNamed: 'classRef').</body><body package="Store-Garbage Collection">descriptorForStoreFileToBundleRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Files'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #bundleeRef		to: (aDescriptor table fieldNamed: 'bundleRef').	(aDescriptor newMapping: DirectMapping) from: #fileRef		to: (table fieldNamed: 'fileRef')</body><body package="Store-Garbage Collection">descriptorForStoreMethodToPackageRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Methods'.	aDescriptor table: table.	self descriptorForDefinitionToPackageRelationship: aDescriptor.	(aDescriptor newMapping: DirectMapping) 		from: #methodRef		to: (table fieldNamed: 'methodRef').</body><body package="Store-Garbage Collection">descriptorForStoreNameSpaceToPackageRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_PkgNameSpaces'.	aDescriptor table: table.	self descriptorForDefinitionToPackageRelationship: aDescriptor.	(aDescriptor newMapping: DirectMapping) 		from: #namespaceRef		to: (table fieldNamed: 'namespaceRef').</body><body package="Store-Garbage Collection">descriptorForStorePackage: aDescriptor	"This deletion descriptor system omits nameSpaceMapping, classDefinitionsMapping. sharedVariableMapping and methodMapping.  The idea - see AR 62517 - is to avoid taking time forcing delete of namespaces, classes, shareds and methods, leaving unlinked ones for later deletion.  It also avoids the risk of loading the whole related object when only the primaryKey is needed."	super descriptorForStorePackage: aDescriptor.	aDescriptor removeMapping: (aDescriptor mappingForAttributeNamed: #nameSpaces).	aDescriptor removeMapping: (aDescriptor mappingForAttributeNamed: #classDefinitions).	aDescriptor removeMapping: (aDescriptor mappingForAttributeNamed: #sharedVariables).	aDescriptor removeMapping: (aDescriptor mappingForAttributeNamed: #methods).</body><body package="Store-Garbage Collection">descriptorForStoreParcelRecord: aDescriptor	"Identical to super except that mappings blob and source are sent #beExclusive."	super descriptorForStoreParcelRecord: aDescriptor.	(aDescriptor mappingForAttributeNamed: #blob) beExclusive.	(aDescriptor mappingForAttributeNamed: #source) beExclusive.</body><body package="Store-Garbage Collection">descriptorForStorePundle: aDescriptor class: aClass inTable: table	"My super adds the #versionless mapping, which this avoids.  Otherwise it is identical to me."	super descriptorForStorePundle: aDescriptor class: aClass inTable: table.	aDescriptor removeMapping: (aDescriptor mappingForAttributeNamed: #versionless).</body><body package="Store-Garbage Collection">descriptorForStoreSharedToPackageRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Data'.	aDescriptor table: table.	self descriptorForDefinitionToPackageRelationship: aDescriptor.	(aDescriptor newMapping: DirectMapping) 		from: #sharedVariableRef		to: (table fieldNamed: 'dataRef').</body></methods><methods><class-id>Store.Glorp.StoreDescriptorForDelete</class-id> <category>classes</category><body package="Store-Garbage Collection">classModelForStoreBundle: aClassModel	"This is identical to what it would inherit from its superclasses except that it omits the #versionless attribute.  Continue this until the reason (or lack thereof) for that omission can be tested."	super classModelForStoreBundle: aClassModel.	aClassModel attributes remove:		(aClassModel attributeNamed: #versionless type: StoreVersionlessBundle).</body><body package="Store-Garbage Collection">classModelForStorePackage: aClassModel	"This is identical to what it would inherit from its superclasses except that it omits the #versionless attribute.  Continue this until the reason (or lack thereof) for that omission can be tested."	super classModelForStorePackage: aClassModel.	aClassModel attributes remove:		(aClassModel attributeNamed: #versionless type: StoreVersionlessPackage).</body></methods><methods><class-id>Store.Glorp.StoreDescriptorForDelete</class-id> <category>initialize-release</category><body package="Store-Garbage Collection">constructAllClasses	"Untilunless the call of 'super constructAllClasses' no longer goes all the way to DescriptorSystem, which computes them from the methods, local bypassing would be essential to exclude any classes of any inherited descriptorFor&lt;Class&gt;: methods.  Even if it were possible to exclude any, it will be necessary to include them because the removed mappings use them for initialization in super calls before being removed in this class' calls.  In any case, barring the most trifling speed effect (which at the moment we do not get anyway), including these classes does not harm.  For information, I list the classes this diescriptor system does not use at the end of the method."	^super constructAllClasses		add: StoreClassToPackageRelationship;		"StoreClassDefinitionInPackage with just the primary keys"		add: StoreMethodToPackageRelationship;		"StoreMethodInPackage with just the primary keys"		add: StoreNameSpaceToPackageRelationship;	"StoreNamespaceInPackage with just the primary keys"		add: StoreSharedToPackageRelationship;		"StoreSharedVariableInPackage with just the primary keys"		yourself"The following inherited classes are not used in deletion (as of VW8.3) but there seems no point bothering to remove them		remove: StoreVersionlessBundle;		remove: StoreVersionlessPackage;		remove: StoreClassExtension;		remove: StoreClassDefinitionInPackage;		remove: StoreMethodInPackage;		remove: StoreNamespaceInPackage;		remove: StoreSharedVariableInPackage;		remove: StoreUserGroup;		remove: StoreAccessPrivilege;		remove: StoreBundleInBundle;		remove: StorePackageInBundle;		yourself"</body></methods><methods><class-id>Store.Glorp.StoreMethodToPackageRelationship</class-id> <category>accessing</category><body package="Store-Garbage Collection">methodRef	^methodRef</body><body package="Store-Garbage Collection">methodRef: anInteger	methodRef := anInteger</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>key collection</category><body package="Store-Garbage Collection">collectAllBundleKeys	| query |	query := Query read: StoreBundle where: [:each | each currentBlessingLevel = -54].	query retrieve: #primaryKey.	query orderBy: [:each | each timestamp descending].	allBundleKeys := (session execute: query) copy.</body><body package="Store-Garbage Collection">collectAllPackageKeys	| query |	query := Query read: StorePackage where: [:each | each currentBlessingLevel = -54].	query retrieve: #primaryKey.	query orderBy: [:each | each timestamp descending].	allPackageKeys := (session execute: query) copy.</body><body package="Store-Garbage Collection">collectBundleBlessings	| query results |	query := Query 		read: StoreBlessing 		where: 			[:each | 			(each pundleID in: bundleKeys) AND: [each recordType = 'B']].	query retrieve: #primaryKey.	query retrieve: #commentID.	results := session execute: query.	bundleBlessingKeys := results collect: #first.	blobKeys addAll: (results collect: #last).</body><body package="Store-Garbage Collection">collectBundleCommentKeys	| query |	query := Query 		read: StoreBundle		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StorePackage 				where:					[:eachSubItem | 					eachSubItem commentID = each commentID AND: [eachSubItem primaryKey notIn: bundleKeys]].			subQuery retrieve: [:x | 'x'].			(each primaryKey in: bundleKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each commentID distinct].	blobKeys addAll: (session execute: query).</body><body package="Store-Garbage Collection">collectBundleFileKeys	| query bundleFileStream workingKeys |	query := Query 		read: StoreBundleFileRelationship		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StoreBundleFileRelationship 				where:					[:eachSubItem | 					eachSubItem fileID = each fileID AND: [eachSubItem bundleID notIn: bundleKeys]].			subQuery retrieve: [:x | 'x'].			(each bundleID in: bundleKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each fileID distinct].	bundleFileKeys := (session execute: query) copy.	bundleFileKeys isEmpty ifTrue: [^self].	bundleFileStream := bundleFileKeys readStream.	[workingKeys := bundleFileStream nextAvailable: self inClauseLimit.	workingKeys isEmpty] whileFalse:		[query := Query			read: StoreFile			where: [:each | each primaryKey in: workingKeys].		query retrieve: [:each | each fileID].		binaryBlobKeys addAll: (session execute: query)].</body><body package="Store-Garbage Collection">collectBundleKeys	| query |	query := Query read: StoreBundle where: [:each | each primaryKey in: bundleKeys].	query retrieve: #traceID.	query orderBy: [:each | each timestamp descending].	bundleParentKeys := (session execute: query) copy</body><body package="Store-Garbage Collection">collectBundlePropertyKeys	| query pundleType |	pundleType := StoreBundle propertyTypeCode.	query := Query 		read: StorePundlePropertyRelationship 		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StorePundlePropertyRelationship 				where:					[:eachSubItem | 					eachSubItem recordType = pundleType AND:						[eachSubItem propertyID = each propertyID AND: [eachSubItem pundleID notIn: bundleKeys]]].			subQuery retrieve: [:x | 'x'].			((each pundleID in: bundleKeys) AND: [each recordType = pundleType]) AND: [each notExists: subQuery]].	query retrieve: [:each | each propertyID distinct].	bundlePropertyKeys := (session execute: query) copy.	bundlePropertyKeys isEmpty ifTrue: [^self].	query := Query		read: StoreProperty		where: [:each | each primaryKey in: bundlePropertyKeys].	query retrieve: [:each | each definition primaryKey distinct].	blobKeys addAll: (session execute: query).</body><body package="Store-Garbage Collection">collectBundleReparentKeys	| query |	query := Query		read: StoreBundle		where: [:each | (each traceID in: bundleKeys) AND: [each primaryKey notIn: bundleKeys]].	query retrieve: #primaryKey.	query retrieve: #traceID.	bundleReparentKeys := (session execute: query) copy.</body><body package="Store-Garbage Collection">collectChainedBlobValues	self collectChainedBlobsForClass: StoreBlob from: blobKeys.	self collectChainedBlobsForClass: StoreBinaryBlob from: binaryBlobKeys</body><body package="Store-Garbage Collection">collectChainedBlobsForClass: aBlobClass from: aCollectionOfExistingKeys	| query chainedBlobs keyStream workingKeys |	aCollectionOfExistingKeys isEmpty ifTrue: [^self].	keyStream := aCollectionOfExistingKeys asOrderedCollection readStream.	[workingKeys := keyStream nextAvailable: self inClauseLimit.	workingKeys isEmpty] whileFalse:		[query := Query 			read: aBlobClass 			where: 				[:each | 				(each primaryKey in: workingKeys) AND: [each blobTypeOrNextKey &lt; 0]].		query retrieve: #blobTypeOrNextKey.		chainedBlobs := (session execute: query) copy.		[chainedBlobs isEmpty] whileFalse:			[ | newBlobs |			aCollectionOfExistingKeys addAll: (newBlobs := chainedBlobs collect: #abs).			query := Query 				read: aBlobClass 				where: 					[:each | 					(each primaryKey in: newBlobs) AND: [each blobTypeOrNextKey &lt; 0]].			query retrieve: #blobTypeOrNextKey.			chainedBlobs := (session execute: query) copy]]</body><body package="Store-Garbage Collection">collectClassDefinitionKeys	| query result |	query := Query 		read: StoreClassDefinitionInPackage		where: 			[:each |			| subQuery |			subQuery := Query 				read: StoreClassDefinitionInPackage				where: 					[:eachSubItem |					eachSubItem classRef = each classRef AND: [eachSubItem packageRef notIn: packageKeys]].			subQuery retrieve: [:x | 'x'].			(each packageRef in: packageKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each classRef distinct].	query retrieve: [:each | each definition definitionID].	query retrieve: [:each | each package timestamp].	query retrieve: [:each | each definition commentID].	query orderBy: [:each | each package timestamp].	result := session execute: query.	result do: 		[:each |		blobKeys add: (each at: 2).		blobKeys add: each last].	^result collect: #first</body><body package="Store-Garbage Collection">collectClassKeys	"At most the size of the result will be twice as big as just the Class definition size.	It could be less if there are some metaclasses that are shared outside of the target packages"	| result |	result := self collectClassDefinitionKeys.	classKeys := OrderedCollection new: result size * 2.	classKeys addAll: result.	classKeys addAll: self collectMetaclassDefinitionKeys.	totalsDictionary at: #classes put: (totalsDictionary at: #classes) + classKeys size</body><body package="Store-Garbage Collection">collectClassParentPairs	| query |	query := Query		read: StoreClassDefinition		where: [:each | each primaryKey in: classKeys].	query retrieve: #primaryKey.	query retrieve: #traceID.	classPairs := (session execute: query) copy</body><body package="Store-Garbage Collection">collectClassReparentKeys	| query |	query := Query		read: StoreClassDefinition		where: [:each | (each traceID in: classKeys) AND: [each primaryKey notIn: classKeys]].	query retrieve: #primaryKey.	query retrieve: #traceID.	classReparentKeys := (session execute: query) copy.</body><body package="Store-Garbage Collection">collectDefinitionParentPairs	self collectMethodParentPairs.	self collectClassParentPairs.	self collectSharedParentPairs.	self collectNamespaceParentPairs</body><body package="Store-Garbage Collection">collectMetaclassDefinitionKeys	| query  result |	query := Query 		read: StoreClassDefinitionInPackage		where: 			[:each |			| subQuery |			subQuery := Query 				read: StoreClassDefinitionInPackage				where: 					[:eachSubItem |					eachSubItem metaclassRef = each metaclassRef AND: [eachSubItem packageRef notIn: packageKeys]].			subQuery retrieve: [:x | 'x'].			(each packageRef in: packageKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each metaclassRef distinct].	query retrieve: [:each | each metaclass definitionID].	query retrieve: [:each | each package timestamp].	query retrieve: [:each | each metaclass commentID].	query orderBy: [:each | each package timestamp].	result := session execute: query.	result do: 		[:each |		blobKeys add: (each at: 2).		blobKeys add: each last].	^result collect: #first</body><body package="Store-Garbage Collection">collectMethodKeys	| query result |	query := Query 		read: StoreMethodInPackage 		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StoreMethodInPackage 				where:					[:eachSubItem | 					eachSubItem methodRef = each methodRef AND: [eachSubItem packageRef notIn: packageKeys]].			subQuery retrieve: [:x | 'x'].			(each packageRef in: packageKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each methodRef distinct].	query retrieve: [:each | each definition definitionID].	result := session execute: query.	methodKeys := result collect: #first.	blobKeys addAll: (result collect: #last).	totalsDictionary at: #methods put: (totalsDictionary at: #methods) + methodKeys size</body><body package="Store-Garbage Collection">collectMethodParentPairs	| keyStream workingKeys query resultKeys |	keyStream := methodKeys asOrderedCollection readStream.	resultKeys := OrderedCollection new.	[workingKeys := keyStream nextAvailable: self inClauseLimit.	workingKeys isEmpty] whileFalse: [		query := Query			read: StoreMethod			where: [:each | each primaryKey in: workingKeys].		query retrieve: #primaryKey.		query retrieve: #traceID.		resultKeys addAll: (session execute: query) copy].	methodPairs := resultKeys</body><body package="Store-Garbage Collection">collectMethodReparentKeys	| keyStream workingKeys query resultKeys methodKeySet |	keyStream := methodKeys asOrderedCollection readStream.	resultKeys := OrderedCollection new.	[workingKeys := keyStream nextAvailable: self inClauseLimit.	Transcript show: 'r'.	workingKeys isEmpty] whileFalse: [		query := Query			read: StoreMethod			where: [:each | (each traceID in: workingKeys) AND: [each primaryKey notIn: workingKeys]].		query retrieve: #primaryKey.		query retrieve: #traceID.		resultKeys addAll: (session execute: query) copy].	"We may have incorrectly included records where the primaryKey is marked for deletion, but wasn't in the same set of working keys	as it's child. Find those and remove them."	methodKeySet := methodKeys asSet.	methodReparentKeys := resultKeys reject: [:ea| methodKeySet includes: ea first].</body><body package="Store-Garbage Collection">collectNamespaceKeys	| query result |	query := Query 		read: StoreNamespaceInPackage 		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StoreNamespaceInPackage 				where:					[:eachSubItem | 					eachSubItem namespaceRef = each namespaceRef AND: [eachSubItem packageRef notIn: packageKeys]].			subQuery retrieve: [:x | 'x'].			(each packageRef in: packageKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each namespaceRef distinct].	query retrieve: [:each | each definition definitionID].	query retrieve: [:each | each definition commentID].	result := session execute: query.	result do: 		[:each |		blobKeys add: (each at: 2).		blobKeys add: each last].	namespaceKeys := (result collect: #first).	totalsDictionary at: #namespaces put: (totalsDictionary at: #namespaces) + namespaceKeys size</body><body package="Store-Garbage Collection">collectNamespaceParentPairs	| query |	query := Query		read: StoreNameSpace		where: [:each | each primaryKey in: namespaceKeys].	query retrieve: #primaryKey.	query retrieve: #traceID.	namespacePairs := (session execute: query) copy</body><body package="Store-Garbage Collection">collectNamespaceReparentKeys	| query |	query := Query		read: StoreNameSpace		where: [:each | (each traceID in: namespaceKeys) AND: [each primaryKey notIn: namespaceKeys]].	query retrieve: #primaryKey.	query retrieve: #traceID.	namespaceReparentKeys := (session execute: query) copy.</body><body package="Store-Garbage Collection">collectPackageAndDefinitionReparentKeys	self collectPackageReparentKeys.	self collectMethodReparentKeys.	self collectClassReparentKeys.	self collectSharedReparentKeys.	self collectNamespaceReparentKeys.</body><body package="Store-Garbage Collection">collectPackageBlessings	| query results |	query := Query 		read: StoreBlessing 		where: 			[:each | 			(each pundleID in: packageKeys) AND: [each recordType = 'P']].	query retrieve: #primaryKey.	query retrieve: #commentID.	results := session execute: query.	packageBlessingKeys := results collect: #first.	blobKeys addAll: (results collect: #last).</body><body package="Store-Garbage Collection">collectPackageCommentKeys	| query |	query := Query 		read: StorePackage		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StorePackage 				where:					[:eachSubItem | 					eachSubItem commentID = each commentID AND: [eachSubItem primaryKey notIn: packageKeys]].			subQuery retrieve: [:x | 'x'].			(each primaryKey in: packageKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each commentID distinct].	blobKeys addAll: (session execute: query).</body><body package="Store-Garbage Collection">collectPackageKeys	| query |	query := Query read: StorePackage where: [:each | each primaryKey in: packageKeys].	query retrieve: #traceID.	query retrieve: #parcelID.	query orderBy: [:each | each timestamp descending].	(session execute: query) do:		[:eachArray |		packageParentKeys add: eachArray first.		eachArray last ifNotNil: [:value | parcelKeys add: value]].	parcelKeys isEmpty ifTrue: [^self].	query := Query read: StoreParcelRecord where: [:each | each primaryKey in: parcelKeys].	query retrieve: #blobID.	query retrieve: #sourceID.	(session execute: query) do:		[:eachArray |		eachArray first ifNotNil: [:value | binaryBlobKeys add: value].		eachArray last ifNotNil: [:value | binaryBlobKeys add: value]]</body><body package="Store-Garbage Collection">collectPackagePropertyBlobKeys	| query |	query := Query 		read: StorePackage		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StorePackage 				where:					[:eachSubItem | 					eachSubItem propertiesBlobID = each propertiesBlobID AND: [eachSubItem primaryKey notIn: packageKeys]].			subQuery retrieve: [:x | 'x'].			(each primaryKey in: packageKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each propertiesBlobID distinct].	blobKeys addAll: (session execute: query).</body><body package="Store-Garbage Collection">collectPackagePropertyKeys	| query pundleType |	pundleType := StorePackage propertyTypeCode.	query := Query 		read: StorePundlePropertyRelationship 		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StorePundlePropertyRelationship 				where:					[:eachSubItem | 					eachSubItem recordType = pundleType AND:						[eachSubItem propertyID = each propertyID AND: [eachSubItem pundleID notIn: packageKeys]]].			subQuery retrieve: [:x | 'x'].			((each pundleID in: packageKeys) AND: [each recordType = pundleType]) AND: [each notExists: subQuery]].	query retrieve: [:each | each propertyID].	packagePropertyKeys := (session execute: query) copy.	packagePropertyKeys isEmpty ifTrue: [^self].	query := Query		read: StoreProperty		where: [:each | each primaryKey in: packagePropertyKeys].	query retrieve: [:each | each definition primaryKey distinct].	blobKeys addAll: (session execute: query).</body><body package="Store-Garbage Collection">collectPackageReparentKeys	| query |	query := Query		read: StorePackage		where: [:each | (each traceID in: packageKeys) AND: [each primaryKey notIn: packageKeys]].	query retrieve: #primaryKey.	query retrieve: #traceID.	packageReparentKeys := (session execute: query) copy.</body><body package="Store-Garbage Collection">collectPrimaryKeysForDeletion	packageKeys notEmpty ifTrue:		[Transcript show: '.'.		self collectPackageKeys.		self collectClassKeys.		self collectMethodKeys.		self collectNamespaceKeys.		self collectSharedKeys.		self collectPackagePropertyKeys.		self collectPackageCommentKeys.		self collectPackagePropertyBlobKeys.		self collectPackageBlessings.		self collectDefinitionParentPairs.		self collectPackageAndDefinitionReparentKeys].	bundleKeys notEmpty ifTrue:		[Transcript show: '.'.		self collectBundleKeys.		self collectBundlePropertyKeys.		self collectBundleCommentKeys.		self collectBundleReparentKeys.		self collectBundleFileKeys.		self collectBundleBlessings].	self collectChainedBlobValues</body><body package="Store-Garbage Collection">collectSharedKeys	| query result |	query := Query 		read: StoreSharedVariableInPackage 		where: 			[:each |			| subQuery |			subQuery :=	Query 				read: StoreSharedVariableInPackage 				where:					[:eachSubItem | 					eachSubItem dataRef = each dataRef AND: [eachSubItem packageRef notIn: packageKeys]].			subQuery retrieve: [:x | 'x'].			(each packageRef in: packageKeys) AND: [each notExists: subQuery]].	query retrieve: [:each | each dataRef distinct].	query retrieve: [:each | each definition definitionID].	query retrieve: [:each | each definition commentID].	result := session execute: query.	result do: 		[:each |		blobKeys add: (each at: 2).		blobKeys add: each last].	sharedKeys := (result collect: #first).	totalsDictionary at: #shareds put: (totalsDictionary at: #shareds) + sharedKeys size</body><body package="Store-Garbage Collection">collectSharedParentPairs	| query |	query := Query		read: StoreSharedVariable		where: [:each | each primaryKey in: sharedKeys].	query retrieve: #primaryKey.	query retrieve: #traceID.	sharedVariablePairs := (session execute: query) copy</body><body package="Store-Garbage Collection">collectSharedReparentKeys	| query |	query := Query		read: StoreSharedVariable		where: [:each | (each traceID in: sharedKeys) AND: [each primaryKey notIn: sharedKeys]].	query retrieve: #primaryKey.	query retrieve: #traceID.	sharedReparentKeys := (session execute: query) copy.</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>deletion</category><body package="Store-Garbage Collection">deleteBinaryBlobs	binaryBlobKeys remove: 0 ifAbsent: [nil].	binaryBlobKeys isEmpty ifTrue: [^self].	session inUnitOfWorkDo: 		[ | keyStream workingKeys |		keyStream := binaryBlobKeys asOrderedCollection readStream.		[workingKeys := keyStream nextAvailable: self inClauseLimit.		Transcript show: '*'.		workingKeys isEmpty] whileFalse: 			[session delete: StoreBinaryBlob where: [:each | each primaryKey in: workingKeys]]]</body><body package="Store-Garbage Collection">deleteBlobs	blobKeys remove: 0 ifAbsent: [nil].	session inUnitOfWorkDo: 		[ | keyStream workingKeys |		keyStream := blobKeys asOrderedCollection readStream.		[workingKeys := keyStream nextAvailable: self inClauseLimit.		Transcript show: 'b'.		workingKeys isEmpty] whileFalse: 			[session delete: StoreBlob where: [:each | each primaryKey in: workingKeys]]]</body><body package="Store-Garbage Collection">deleteBundleBlessings	session inUnitOfWorkDo:		[session delete: StoreBlessing where: [:each | (each pundleID in: bundleKeys) AND: [each recordType = 'B']]]</body><body package="Store-Garbage Collection">deleteBundlePackageRelationships	session inUnitOfWorkDo:		[session delete: StoreBundlePackageRelationship where: [:each | each packageID in: packageKeys]]</body><body package="Store-Garbage Collection">deleteBundleProperties	| pundleType |	bundlePropertyKeys := bundlePropertyKeys copyWithout: 0.	pundleType := StoreBundle propertyTypeCode.	session inUnitOfWorkDo: 		[session 			delete: StorePundlePropertyRelationship 			where: [:each | (each pundleID in: bundleKeys) AND: (each recordType = pundleType)].		bundlePropertyKeys isEmpty ifFalse: [session delete: StoreProperty where: [:each | each primaryKey in: bundlePropertyKeys]]]</body><body package="Store-Garbage Collection">deleteBundles	bundleKeys isEmpty ifTrue: [^self].	session inUnitOfWorkDo:		[session 			delete: StoreBundleSubBundleRelationship 			where: [:each | (each bundleID in: bundleKeys) OR: [each subbundleID in: bundleKeys]].		session delete: StoreBundle where: [:each | each primaryKey in: bundleKeys]]</body><body package="Store-Garbage Collection">deleteClasses	classKeys := classKeys copyWithout: 0.		session inUnitOfWorkDo:		[ | keyStream workingKeys |			session delete: StoreClassToPackageRelationship where: [:each | each packageRef in: packageKeys].			keyStream := classKeys asOrderedCollection readStream.			[workingKeys := keyStream nextAvailable: self inClauseLimit.			Transcript show: 'c'.			workingKeys isEmpty] whileFalse:				[session delete: StoreClassDefinition where: [:each | each primaryKey in: workingKeys]]]</body><body package="Store-Garbage Collection">deleteFiles	bundleFileKeys := bundleFileKeys copyWithout: 0.	session inUnitOfWorkDo: 		[session delete: StoreBundleFileRelationship where: [:each | each bundleID in: bundleKeys].		bundleFileKeys isEmpty ifFalse: [session delete: StoreFile where: [:each | each primaryKey in: bundleFileKeys]]]</body><body package="Store-Garbage Collection">deleteMethods	methodKeys := methodKeys copyWithout: 0.	session inUnitOfWorkDo:		[ | keyStream workingKeys |			session delete: StoreMethodToPackageRelationship where: [:each | each packageRef in: packageKeys].			keyStream := methodKeys asOrderedCollection readStream.			[workingKeys := keyStream nextAvailable: self inClauseLimit.			Transcript show: 'm'.			workingKeys isEmpty] whileFalse:				[session delete: StoreMethod where: [:each | each primaryKey in: workingKeys]]]</body><body package="Store-Garbage Collection">deleteNameSpaces	namespaceKeys := namespaceKeys copyWithout: 0.	session inUnitOfWorkDo: 		[session delete: StoreNameSpaceToPackageRelationship where: [:each | each packageRef in: packageKeys].		namespaceKeys isEmpty ifFalse: [session delete: StoreNameSpace where: [:each | each primaryKey in: namespaceKeys]]]</body><body package="Store-Garbage Collection">deleteObjects	"We have to remove the Packages before the ParcelRecords."	session accessor permitEverythingDuring: [session transact:		[packageKeys isEmpty ifFalse:			[Transcript show: '.'.			self deleteClasses.			self deleteMethods.			self deleteSharedVariables.			self deleteNameSpaces.			self deletePackageProperties.			self deleteBundlePackageRelationships.			self deletePackageBlessings.			self deletePackages.			self deleteParcelRecords].		bundleKeys isEmpty ifFalse:			[Transcript show: '.'.			self deleteBundleProperties.			self deletePackageBundleRelationships.			self deleteFiles.			self deleteBundleBlessings.			self deleteBundles].		Transcript show: '.'.		self deleteBlobs.		self deleteBinaryBlobs]].</body><body package="Store-Garbage Collection">deletePackageBlessings	session inUnitOfWorkDo:		[session delete: StoreBlessing where: [:each | (each pundleID in: packageKeys) AND: [each recordType = 'P']]]</body><body package="Store-Garbage Collection">deletePackageBundleRelationships	session inUnitOfWorkDo:		[session delete: StoreBundlePackageRelationship where: [:each | each bundleID in: bundleKeys]]</body><body package="Store-Garbage Collection">deletePackageProperties	| pundleType |	packagePropertyKeys := packagePropertyKeys copyWithout: 0.	pundleType := StorePackage propertyTypeCode.	session inUnitOfWorkDo: 		[session 			delete: StorePundlePropertyRelationship 			where: [:each | (each pundleID in: packageKeys) AND: (each recordType = pundleType)].		packagePropertyKeys isEmpty ifFalse: 			[session delete: StoreProperty where: [:each | each primaryKey in: packagePropertyKeys]]]</body><body package="Store-Garbage Collection">deletePackages	packageKeys isEmpty ifTrue: [^self].	session inUnitOfWorkDo:		[session delete: StorePackage where: [:each | each primaryKey in: packageKeys]]</body><body package="Store-Garbage Collection">deleteParcelRecords	parcelKeys := parcelKeys copyWithout: 0.	parcelKeys isEmpty ifTrue: [^self].	session inUnitOfWorkDo: 		[session delete: StoreParcelRecord where: [:each | each primaryKey in: parcelKeys]]</body><body package="Store-Garbage Collection">deleteSharedVariables	sharedKeys := sharedKeys copyWithout: 0.	session inUnitOfWorkDo: 		[session delete: StoreSharedToPackageRelationship where: [:each | each packageRef in: packageKeys].		sharedKeys isEmpty ifFalse: [session delete: StoreSharedVariable where: [:each | each primaryKey in: sharedKeys]]]</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>reparent</category><body package="Store-Garbage Collection">reparentBundles		bundleReparentKeys isEmpty ifTrue: [^self].	bundleReparentKeys do:		[:eachPair |		eachPair at: 2 put: (self newParentFor: eachPair last parents: bundleKeys children: bundleParentKeys)].	self reparentAllFor: StoreBundle usingReparentKeys: bundleReparentKeys</body><body package="Store-Garbage Collection">reparentClasses		| workingParentKeys workingMainKeys |	classReparentKeys isEmpty ifTrue: [^self].	workingMainKeys := classPairs collect: #first.	workingParentKeys := classPairs collect: #last.	classReparentKeys do:		[:eachPair |		eachPair at: 2 put: (self newParentFor: eachPair last parents: workingMainKeys children: workingParentKeys)].	self reparentAllFor: StoreClassDefinition usingReparentKeys: classReparentKeys</body><body package="Store-Garbage Collection">reparentMethods		| workingParentKeys workingMainKeys |	methodReparentKeys isEmpty ifTrue: [^self].	workingMainKeys := methodPairs collect: #first.	workingParentKeys := methodPairs collect: #last.	methodReparentKeys do:		[:eachPair |		eachPair at: 2 put: (self newParentFor: eachPair last parents: workingMainKeys children: workingParentKeys)].	self reparentAllFor: StoreMethod usingReparentKeys: methodReparentKeys</body><body package="Store-Garbage Collection">reparentNamespaces		| workingParentKeys workingMainKeys |	namespaceReparentKeys isEmpty ifTrue: [^self].	workingMainKeys := namespacePairs collect: #first.	workingParentKeys := namespacePairs collect: #last.	namespaceReparentKeys do:		[:eachPair |		eachPair at: 2 put: (self newParentFor: eachPair last parents: workingMainKeys children: workingParentKeys)].	self reparentAllFor: StoreNameSpace usingReparentKeys: namespaceReparentKeys</body><body package="Store-Garbage Collection">reparentOrphans	session accessor permitEverythingDuring: [session transact:		[bundleKeys notEmpty ifTrue: 			[Transcript show: '.'.			self reparentBundles].		packageKeys notEmpty ifTrue: 			[Transcript show: '.'.			self reparentPackages.			self reparentMethods.			self reparentNamespaces.			self reparentClasses.			self reparentShareds]]].</body><body package="Store-Garbage Collection">reparentPackages		packageReparentKeys isEmpty ifTrue: [^self].	packageReparentKeys do:		[:eachPair |		eachPair at: 2 put: (self newParentFor: eachPair last parents: packageKeys children: packageParentKeys)].	self reparentAllFor: StorePackage usingReparentKeys: packageReparentKeys</body><body package="Store-Garbage Collection">reparentShareds		| workingParentKeys workingMainKeys |	sharedReparentKeys isEmpty ifTrue: [^self].	workingMainKeys := sharedVariablePairs collect: #first.	workingParentKeys := sharedVariablePairs collect: #last.	sharedReparentKeys do:		[:eachPair |		eachPair at: 2 put: (self newParentFor: eachPair last parents: workingMainKeys children: workingParentKeys)].	self reparentAllFor: StoreSharedVariable usingReparentKeys: sharedReparentKeys</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>initialize-release</category><body package="Store-Garbage Collection">bundlesToRemove: aCollectionOfBundles	| storeBundles |	storeBundles := aCollectionOfBundles collect: 		[:each |		each isGlorpObject ifTrue: [each] ifFalse: [each asStorePundleIn: session]].	storeBundles := storeBundles asOrderedCollection sort:		[:a :b |		a timestamp &gt; b timestamp or:			[a timestamp = b timestamp and: [a primaryKey &gt; b primaryKey]]].	session accessor permitEverythingDuring: [		session inTransactionDo: [			storeBundles do: [:eachBundle |				eachBundle currentBlessingLevel = -54 ifFalse: [self setBlessingForRemoval: eachBundle]]]].	allBundleKeys addAll: (storeBundles collect: [:each | each primaryKey]).</body><body package="Store-Garbage Collection">collectGarbageInSession: aSession	self session: aSession.	self collectGarbage</body><body package="Store-Garbage Collection">initialize	session := StoreLoginFactory currentStoreSession.	packageKeys := OrderedCollection new.	bundleKeys := OrderedCollection new.	packageParentKeys := OrderedCollection new.	bundleParentKeys := OrderedCollection new.	parcelKeys := OrderedCollection new.	binaryBlobKeys := Set new.	blobKeys := Set new.	totalsDictionary := Dictionary new.	totalsDictionary at: #classes put: 0.	totalsDictionary at: #methods put: 0.	totalsDictionary at: #shareds put: 0.	totalsDictionary at: #namespaces put: 0.	allPackageKeys := OrderedCollection new.	allBundleKeys := OrderedCollection new.</body><body package="Store-Garbage Collection">packagesToRemove: aCollectionOfPackages	| storePackages |	storePackages := aCollectionOfPackages collect: 		[:each |		each isGlorpObject ifTrue: [each] ifFalse: [each asStorePundleIn: session]].	storePackages := storePackages asOrderedCollection sort:		[:a :b | a timestamp &gt; b timestamp or:			[a timestamp = b timestamp and: [a primaryKey &gt; b primaryKey]]].	session accessor permitEverythingDuring: [		session inTransactionDo: [			storePackages do: [:eachPackage |				eachPackage currentBlessingLevel = -54 ifFalse: [self setBlessingForRemoval: eachPackage]]]].	allPackageKeys addAll: (storePackages collect: [:each | each primaryKey]).</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>accessing</category><body package="Store-Garbage Collection">inClauseLimit	^inClauseLimit ifNil: [inClauseLimit := self class inClauseLimitForPlatform: session platform].</body><body package="Store-Garbage Collection">pundleLoopSize	^self class pundleLoopSize</body><body package="Store-Garbage Collection">session: aGlorpSessionOrNil	aGlorpSessionOrNil ifNotNil: [session := aGlorpSessionOrNil]</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>private</category><body package="Store-Garbage Collection">executeWithDeleteDescriptor: aBlock	| originalSession |	originalSession := session.	[session := session copy.	session system: (StoreDescriptorForDelete forPlatform: originalSession accessor platform).	session accessor reset.	aBlock value] ensure:		[session := originalSession.		session accessor reset].</body><body package="Store-Garbage Collection">newParentFor: currentTrace parents: itemsToBeDeleted children: itemsCurrentTraces	| workingTrace |	workingTrace := currentTrace.	[itemsToBeDeleted includes: workingTrace] whileTrue:		[workingTrace := itemsCurrentTraces at: (itemsToBeDeleted indexOf: workingTrace)].	^workingTrace</body><body package="Store-Garbage Collection">reparentAllFor: aStoreClass usingReparentKeys: reparentKeys	session inUnitOfWorkDo: 			[reparentKeys				do: [:eachPair | self reparentOrphanOfClass: aStoreClass usingKeyPair: eachPair]]</body><body package="Store-Garbage Collection">reparentOrphanOfClass: aStoreClass usingKeyPair: eachPair	| results newTrace source |	results := session read: aStoreClass				where: [:each | each primaryKey in: eachPair].	results size = 1		ifTrue: [source := results first. newTrace := nil]		ifFalse: [			results first primaryKey = eachPair first				ifTrue: [source := results first.					newTrace := results last]				ifFalse: [source := results last.					newTrace := results first]].	session register: source.	^newTrace isNil		"the new 0-trace object will require isMetaclass set, and possibly other values as well, to avoid walkbacks"		ifTrue: [source trace: (source class new privateSetPrimaryKey: 0)]		ifFalse: [source trace: newTrace]</body><body package="Store-Garbage Collection">setBlessingForRemoval: aStorePundle	| specification |	specification := PublishSpecification dbPundle: aStorePundle.	specification publish: true.	specification blessing: -54.	specification publishBlessing.	aStorePundle currentBlessingLevel: -54.</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>reporting</category><body package="Store-Garbage Collection">writeBeginningTranscriptStatus	| packageCount bundleCount stream |	stream := (String new: 150) writeStream.	packageCount := allPackageKeys size.	bundleCount := allBundleKeys size.	stream nextPutAll: ((#NGarbageCollectionStarted1pN &lt;&lt; #store &gt;&gt; '&lt;n&gt;Garbage collection started @ &lt;1p&gt;&lt;n&gt;') 		expandMacrosWith: startTime).	stream nextPutAll: (#TDeletingSpace &lt;&lt; #store &gt;&gt; '&lt;t&gt;Deleting ') expandMacros.	bundleCount &gt; 0 ifTrue:		[stream nextPutAll: ((#_1pBundle2Q &lt;&lt; #store &gt;&gt; '&lt;1p&gt; Bundle&lt;2?:s&gt;')			expandMacrosWith: bundleCount			with: bundleCount = 1)].	(bundleCount &gt; 0 and: [packageCount &gt; 0]) ifTrue:		[stream nextPutAll: (#And &lt;&lt; #store &gt;&gt; ' and ') asString].	packageCount &gt; 0 ifTrue:		[stream nextPutAll: ((#_1pPackage2Q &lt;&lt; #store &gt;&gt; '&lt;1p&gt; Package&lt;2?:s&gt;')			expandMacrosWith: packageCount			with: packageCount = 1)].	Transcript show: stream contents; cr</body><body package="Store-Garbage Collection">writeEndingTranscriptStatus 	| stream |	stream := (String new: 150) writeStream.	stream nextPutAll: (#NGarbageCollectionEnded1pN &lt;&lt; #store &gt;&gt; '&lt;n&gt;Garbage collection ended @ &lt;1p&gt;&lt;n&gt;'		expandMacrosWith: endTime).	stream nextPutAll: (#NGarbageCollectionElapsed1pN &lt;&lt; #store &gt;&gt; 'Elapsed collection time was: &lt;1p&gt;&lt;n&gt;'		expandMacrosWith: (endTime - startTime)).	(allBundleKeys size = 0 and: [allPackageKeys size = 0])		ifTrue: 			[stream nextPutAll: 				(#TNoBundlesOrPackagesMarkedN &lt;&lt; #store &gt;&gt; '&lt;t&gt;No Bundles or Packages were marked for deletion&lt;n&gt;') 				expandMacros]		ifFalse: [stream nextPutAll: (#RemovedSpace &lt;&lt; #store &gt;&gt; 'Removed ') expandMacros].	allBundleKeys size &gt; 0 ifTrue: 		[stream nextPutAll: ((#_1pBundle2Q &lt;&lt; #store &gt;&gt; '&lt;1p&gt; Bundle&lt;2?:s&gt;') 			expandMacrosWith: allBundleKeys size			with: allBundleKeys size = 1)].	(allBundleKeys size &gt; 0 and: [allPackageKeys size &gt; 0]) ifTrue: [stream nextPutAll: (#And &lt;&lt; #store &gt;&gt; ' and ') asString].	allPackageKeys size &gt; 0 ifTrue:		[stream nextPutAll: ((#_1pPackage2Q &lt;&lt; #store &gt;&gt; '&lt;1p&gt; Package&lt;2?:s&gt;') 			expandMacrosWith: allPackageKeys size			with: allPackageKeys size = 1).		stream nextPutAll: (#NContainingSpace &lt;&lt; #store &gt;&gt; '&lt;n&gt;Containing ') expandMacros.		stream nextPutAll: (#_1pNamespacesQ &lt;&lt; #store &gt;&gt; '&lt;1p&gt; NameSpace&lt;2?:s&gt;, '  			expandMacrosWith: (totalsDictionary at: #namespaces)			with: (totalsDictionary at: #namespaces) = 1).		stream nextPutAll: (#_1pClassesQ &lt;&lt; #store &gt;&gt; '&lt;1p&gt; Class&lt;2?:es&gt;, '  			expandMacrosWith: (totalsDictionary at: #classes)			with: (totalsDictionary at: #classes) = 1).		stream nextPutAll: (#_1pMethodsQ &lt;&lt; #store &gt;&gt; '&lt;1p&gt; Method&lt;2?:s&gt;, ' 			expandMacrosWith: (totalsDictionary at: #methods)			with: (totalsDictionary at: #methods) = 1).		stream nextPutAll: (#_1pSharedVariablesQN &lt;&lt; #store &gt;&gt; '&lt;1p&gt; Shared Variable&lt;2?:s&gt;&lt;n&gt;' 			expandMacrosWith: (totalsDictionary at: #shareds)			with: (totalsDictionary at: #shareds) = 1)].	Transcript show: stream contents</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>API</category><body package="Store-Garbage Collection">collectGarbage	"We initialize the session, making sure the caches are cleared before we do any work" 	| packageKeyStream bundleKeyStream |	session initialize.	startTime := Timestamp now.	(allPackageKeys isEmpty and: [allBundleKeys isEmpty])		ifTrue: [				self collectAllPackageKeys.			self collectAllBundleKeys].		self writeBeginningTranscriptStatus.	packageKeyStream := allPackageKeys readStream.	bundleKeyStream := allBundleKeys readStream.	[packageKeys := packageKeyStream nextAvailable: self pundleLoopSize.	bundleKeys := bundleKeyStream nextAvailable: self pundleLoopSize.		packageKeys notEmpty or: [bundleKeys notEmpty]] whileTrue:		[self collectPrimaryKeysForDeletion.		self reparentOrphans.		self executeWithDeleteDescriptor: [self deleteObjects]].	endTime := Timestamp now.	self writeEndingTranscriptStatus.</body></methods><methods><class-id>Store.GarbageCollector class</class-id> <category>instance creation</category><body package="Store-Garbage Collection">collectGarbage	| instance |	instance := self new.	instance collectGarbage.</body><body package="Store-Garbage Collection">collectGarbageInSession: aSession	| instance |	instance := self new.	instance collectGarbageInSession: aSession</body><body package="Store-Garbage Collection">new	^super new initialize</body><body package="Store-Garbage Collection">removeBundles: aCollection	"Remove the bundles and packages from the physical store."		self new		bundlesToRemove: aCollection;		collectGarbage.</body><body package="Store-Garbage Collection">removeBundles: aCollection inSession: aSession	"Remove the bundles and packages from the physical store."		self new		session: aSession;		bundlesToRemove: aCollection;		collectGarbage.</body><body package="Store-Garbage Collection">removeBundles: aCollectionOfBundles packages: aCollectionOfPackages	"Remove the bundles and packages from the physical store."		self new		bundlesToRemove: aCollectionOfBundles;		packagesToRemove: aCollectionOfPackages;		collectGarbage.</body><body package="Store-Garbage Collection">removeBundles: aCollectionOfBundles packages: aCollectionOfPackages inSession: aSession	"Remove the bundles and packages from the physical store."		self new		session: aSession;		bundlesToRemove: aCollectionOfBundles;		packagesToRemove: aCollectionOfPackages;		collectGarbage.</body><body package="Store-Garbage Collection">removePackages: aCollection	"Remove the bundles and packages from the physical store."		self new		packagesToRemove: aCollection;		collectGarbage.</body><body package="Store-Garbage Collection">removePackages: aCollection inSession: aSession	"Remove the bundles and packages from the physical store."		self new		session: aSession;		packagesToRemove: aCollection;		collectGarbage.</body></methods><methods><class-id>Store.GarbageCollector class</class-id> <category>accessing</category><body package="Store-Garbage Collection">defaultINClauseLimit	^defaultINClauseLimit</body><body package="Store-Garbage Collection">defaultINClauseLimit: anIntegerOrNil	defaultINClauseLimit := anIntegerOrNil</body><body package="Store-Garbage Collection">inClauseLimitForPlatform: aDatabasePlatform	^defaultINClauseLimit ifNil: [aDatabasePlatform defaultOptimalINClauseLimit]</body><body package="Store-Garbage Collection">pundleLoopSize	^pundleLoopSize ifNil: [25]</body><body package="Store-Garbage Collection">pundleLoopSize: anIntegerOrNil	pundleLoopSize := anIntegerOrNil</body></methods><methods><class-id>Store.GarbageCollector class</class-id> <category>documentation</category><body package="Store-Garbage Collection">DOCUMENTATION	"There is some real important behavior going on here.	One main thing is how to find out, of all package versions we want to delete	which definition objects (method/class/namespace/shared) are ONLY used in the target versions	and nowhere else in the system.	To do this with regular SQL looks like this (using pseudo code):select distinct a.objectRef	from tw_objectToPackageTable A	where not exists		(select 'X'			from tw_objectToPackageTable B			where 				B.packageref not in aCollectionOfPackagePrimaryKeysWeWantToDelete				and A.objectRef = B.objectRef)	and A.packageRef in aCollectionOfPackagePrimaryKeysWeWantToDelete;	In Glorpized code, this looks like this (again, using pseudo code):query := Query 	read: StoreObjectInPackage 	where: 		[:each |		| subQuery |		subQuery :=	Query 			read: StoreObjectInPackage 			where:				[:eachSubItem | 				eachSubItem objectRef = each objectRef AND: [eachSubItem packageRef notIn: targetPackageKeys]].		subQuery retrieve: [:x | 'x'].		(each packageRef in: targetPackageKeys) AND: [each notExists: subQuery]].query retrieve: [:each | each objectRef distinct].result := session execute: query.	This code is executed once each for Properties, Methods, Classes, NameSpaces and SharedVariables, 	no matter how many packages we are trying to delete.	Our only limitation is that an in/not in clause is usually limited by each database, but overridable by setting the inClaseLimit[:]"</body></methods><methods><class-id>Store.Glorp.StoreClassToPackageRelationship</class-id> <category>accessing</category><body package="Store-Garbage Collection">classRef	^classRef</body><body package="Store-Garbage Collection">classRef: anObject	classRef := anObject</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Store73DescriptorSystem</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class></st-source>