<?xml version="1.0"?><st-source><!-- Name: StoreForSqlServerNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: Store adds team development and version control tools and facilities to the VisualWorks development environment.Load this parcel to use Store with a SQL Server repository -  all other Store parcels will be loaded automatically.Further information on Store can be found in the "Source Code Management Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 482320DbUsername: nrossDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'ODBCEXDI' '') #(#any 'StoreBase' ''))PackageName: StoreForSqlServerParcel: #('StoreForSqlServer')ParcelName: StoreForSqlServerPrerequisiteDescriptions: #(#(#name 'ODBCEXDI') #(#name 'StoreBase'))PrerequisiteParcels: #(#('ODBCEXDI' '') #('StoreBase' ''))PrintStringCache: (8.2 - 1,nross)Version: 8.2 - 1Date: 12:48:05 PM January 8, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jan16.1) of January 8, 2016 on January 8, 2016 at 12:48:05 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MS_SQLServerConnection</name><environment>Database</environment><super>Database.ODBCConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreSqlServer</category><attributes><package>StoreForSqlServer</package></attributes></class><comment><class-id>Database.MS_SQLServerConnection</class-id><body>MS_SQLServerConnection is a specialized class that allows one to connect to MS SQL Server using Store.</body></comment><class><name>NTAuthenticatedConnection</name><environment>Smalltalk</environment><super>Database.MS_SQLServerConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NT_Authenticate</category><attributes><package>StoreForSqlServer</package></attributes></class><comment><class-id>NTAuthenticatedConnection</class-id><body>NTAuthenticatedConnection is a specialized class that allows one to connect to MS SQL Server with Store, but using NT Authentication to validate the user. This feature must be enabled at the server.</body></comment><methods><class-id>Database.MS_SQLServerConnection class</class-id> <category>accessing</category><body package="StoreForSqlServer">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'MS_SQL Server'</body></methods><methods><class-id>Database.MS_SQLServerConnection class</class-id> <category>glorp</category><body package="StoreForSqlServer">glorpStoreDatabasePlatformClass	^Glorp.SQLServerPlatform</body></methods><methods><class-id>NTAuthenticatedConnection</class-id> <category>private-execution</category><body package="StoreForSqlServer">acquireExternal: aPassword 	"Assume that the current user is recognized by	the server using NT authorization.Verify that stated	user name is correct, and replace the username	and password logon strings with blanks so that	NT authorization can take place."	| xif rc name pw env  szDSN szUID szAuthStr env1 nm1 pw1 |	xif := self class xif.	self username = self authenticatedUserName		ifFalse: [self class authenticationFailureSignal raise].	name := ''.	[ name isString ] whileFalse:		[ name := self class requiredUsernameSignal raiseRequest ].	pw := ''. "aPassword."	[ pw isString ] whileFalse:		[ pw := self class requiredPasswordSignal raiseRequest  ].	(env := self environment) isNil ifTrue:		[ env := self class defaultEnvironment ].	[ env isString ] whileFalse:		[ env := self class requiredEnvironmentSignal raiseRequest  ].	env := self class mapLogical: env.	"Get required handles."	HenvLock critical: [ self unprotectedAllocConnect ].	[ "Begin unwind protection (level 1) -- ensure release of connection handle on failure."	[ "Begin unwind protection (level 2) -- ensure release of pointers on success or failure."	szDSN := (env1 := env asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	szUID := (nm1 := name asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	szAuthStr := (pw1 := pw asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	rc := xif SQLConnect: self hdbc			with: szDSN			with: env1 size			with: szUID			with: nm1 size			with: szAuthStr			with: pw1 size.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rc; 			nextPutAll: ' = SQLConnect( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix:16);			nextPutAll: ', szDSN = '; nextPutAll: env; 			nextPutAll: ', szUID = '; nextPutAll: name; 			nextPutAll: ', szAuthStr = ******* )'.		self class trace: self emitTrace].	"End unwind protection (level 2)" ]		valueNowOrOnUnwindDo: 			[ szAuthStr notNil ifTrue: [ szAuthStr freePointer ].			szUID notNil ifTrue: [ szUID freePointer ]. 			szDSN notNil ifTrue: [ szDSN freePointer ] ].	(rc == xif SQL_SUCCESS 	or: [rc == xif  SQL_SUCCESS_WITH_INFO]) ifFalse:		[| errs |		errs := self getConnectionErrors.		^self class unableToConnectToSQLserverSignal raiseWith: errs].	"End unwind protection (level 1)" ]		valueOnUnwindDo:			[ "Some failure is causing unwind, don't keep the handles."			HenvLock critical: [ self unprotectedFreeConnect ] ].	"Enter autocommit mode on the transaction."	self singleStatementTransactions.	"Set the correct isolation level for this connect"	"self setIsolationLevel: (SupportedIsolationLevels at: isolationLevel)."</body></methods><methods><class-id>NTAuthenticatedConnection</class-id> <category>private-authentication</category><body package="StoreForSqlServer">authenticatedUserName	^OSSystemSupport new getVariable: 'USERNAME'</body></methods><methods><class-id>NTAuthenticatedConnection class</class-id> <category>accessing</category><body package="StoreForSqlServer">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'MS_SQL_NT Authenticated'</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="StoreForSqlServer">postLoginInitializeStoreFromAccessor: anAccessor	"We set ourself to UTF16, which works for reading and writing single byte, but if the strings are double byte, will NOT prevent it if the table spaces are double byte."	anAccessor encoding: #UTF16.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>ODBCConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hdbcHolder supportedFunctions generalInformationCache unicodeEncoding sqlConnectionOptionCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class></st-source>