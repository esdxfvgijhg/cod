<?xml version="1.0"?><st-source><!-- Name: StoreForPostgreSQLNotice: Copyright 2014-2016 Cincom Systems, Inc.  All rights reserved.Comment: This loads the prereqs required for creating and using a Store database in VisualWorks 8.0 and after when connecting to a Postgres database.  It maps the protocol 3.0 EXDI connection classes (PostgresSocketConnection and PostgresLibpqConnection) to their Glorp DatabasePlatform subclasses.It does not load the parcel (PostgreSQLEXDI) that contains the protocol 2.0 driver, but if that parcel is loaded, then it also maps the protocol 2.0 EXDI connection class to its Glorp DatabasePlatform subclass.Store adds team development and version control tools and facilities to the VisualWorks development environment. Further information can be found in the "Source Code Management Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 482321DbUsername: nrossDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'StoreBase' '') #(#any 'PostgreSQL3EXDI' '') #(#any 'PostgreSQLEXDI' ''))Namespace: GlorpPackageName: StoreForPostgreSQLParcel: #('StoreForPostgreSQL')ParcelName: StoreForPostgreSQLPrerequisiteDescriptions: #(#(#name 'StoreBase') #(#name 'PostgreSQL3EXDI') #(#name 'PostgreSQLEXDI' #applicability #store))PrerequisiteParcels: #(#('StoreBase' '') #('PostgreSQL3EXDI' ''))PrintStringCache: (8.2 - 1,nross)Version: 8.2 - 1Date: 12:48:39 PM January 8, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jan16.1) of January 8, 2016 on January 8, 2016 at 12:48:39 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>database-specific</category><body package="StoreForPostgreSQL">postLoginInitializeStoreFromAccessor: anAccessor	"This is only used by the 2.0 driver.  We're going to force the encoding, but if it can't tell us which encoding it's using, then this is so old that it won't let us set the encoding, and we really can't do much about it;  just hope that the encodings match well enough for the characters in use."	| encoding |	encoding := anAccessor executeSQLString: 'SHOW CLIENT_ENCODING'.	encoding isEmpty		ifTrue: [anAccessor encoding: #'iso-8859-1']		ifFalse:			[anAccessor encoding: #'utf8'.			anAccessor executeSQLString: 'SET CLIENT_ENCODING TO ''UNICODE''']</body><body package="StoreForPostgreSQL">preLoginInitializeStoreFromAccessor: anAccessor	"Suppress super 3.0 encoding behaviour as this may be used with a 2.0 driver."</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>database-specific</category><body package="StoreForPostgreSQL">preLoginInitializeStoreFromAccessor: anAccessor	"PostgresSocket and PostgresLibpq both set the encoding as part of the login process if a non-nil encoding is set on the connection before login.  In the case of PostgresSocket, but not PostgresLibpq, this setting is part of the login round trip and so has zero overhead.  Thus we can continue to force #utf8 on login at zero (PostgresSocket) or little (PostgresLibpq) cost if Store still so desires ..."	anAccessor encoding: #utf8."... However the default behaviour of both PostgresSocket and PostgresLibpq is to get the encoding and check whether it is known to the image (see #knownClientEncoding);  if not, they both force the postgres client encoding to be #utf8.  So I suggest the option of doing nothing here about the character encoding.  (There will remain the task of configuring the blob/byteArray encoding, once initial review of the revamped Store hooks is done.)If the server can't tell us which encoding it's using, it's too old to use the 3.0 driver, so we ignore that case."</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>glorp</category><body package="StoreForPostgreSQL">glorpStoreDatabasePlatformClass	^PostgreSQLPlatform</body></methods><methods><class-id>Database.PostgresLibpqConnection class</class-id> <category>glorp</category><body package="StoreForPostgreSQL">glorpStoreDatabasePlatformClass	^PostgresLibpqPlatform</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>glorp</category><body package="StoreForPostgreSQL">glorpStoreDatabasePlatformClass	^PostgresSocketPlatform</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>PostgresPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charactersThatNeedEscaping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>PostgreSQLPlatform</name><environment>Glorp</environment><super>Glorp.PostgresPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class></st-source>