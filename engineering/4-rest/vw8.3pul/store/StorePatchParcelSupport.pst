<?xml version="1.0"?><st-source><!-- Name: StorePatchParcelSupportNotice: Copyright 2011-2013 Cincom Systems, Inc.  All rights reserved.Comment: This package has behaviors to Gather changes into a package, and Distribute a package into its owning packagesDbIdentifier: bear73DbTrace: 400118DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'StoreBase' ''))PackageName: StorePatchParcelSupportParcel: #('StorePatchParcelSupport')PrerequisiteDescriptions: #(#(#name 'StoreBase' #componentType #bundle))PrerequisiteParcels: #(#('StoreBase' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 5:37:09 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.4) of March 22, 2013 on April 3, 2013 at 5:37:09 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DistributedDefinitionCollectionHolder</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children itemString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.DistributedDefinitionCollectionHolder</class-id><body>DistributedDefinitionCollectionHolder has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables	children	&lt;Collection&gt;	description of children	itemString	&lt;UserMessage | Text | String&gt;	description of itemString</body></comment><class><name>DistributedDefinitionRootHolder</name><environment>Store</environment><super>Store.DistributedDefinitionCollectionHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePackage targetedDefinitions untargetedDefinitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.DistributedDefinitionRootHolder</class-id><body>DistributedDefinitionRootHolder has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables	targetedDefinitions	&lt;DistributedDefinitionTargetHolder&gt;	For instances of me, I hold the Targeted definitions	untargetdDefinitions	&lt;DistributedDefinitionTargetHolder&gt;	For instances of me, I hold the UnTargeted definitions</body></comment><class><name>SelectTargetPackage</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StorePatchParcelSupport</category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.SelectTargetPackage</class-id><body>SelectTargetPackage is a UI based exception which opens a PackageSelector UI. If you raise this with a parameter, the parameter is expected to be a PackageModel, and that package model is excluded from the list of proposed packages.The default is to answer nil</body></comment><class><name>DistributedDefinitionTargetHolder</name><environment>Store</environment><super>Store.DistributedDefinitionCollectionHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaceDefinitions classDefinitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.DistributedDefinitionTargetHolder</class-id><body>DistributedDefinitionTargetHolder has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.In my instance variables which I inherit, I have	namespaceDefinitions	&lt;DistributedDefinitionOwnerrHolder&gt;	For instances of me, I hold Namespace definitions	classDefinitions	&lt;DistributedDefinitionOwnerHolder&gt;	For instances of me, I hold Class definitions</body></comment><class><name>StoreDistributeDefinitionsDialog</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetPackageString definitions askForUnknownTargets package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.StoreDistributeDefinitionsDialog</class-id><body>StoreDistributeDefinitionsDialog is used to distribute definitions from a package into their owning package, either overriding or replacing definitionsInstance Variables	package	&lt;PackageModel&gt;	Source package	askForUnknownTargets	&lt;ValueHolder on: Boolean&gt;	description of askForUnknownTargets	definitions	&lt;SelectionInList&gt;	description of definitions	targetPackageString	&lt;ValueHolder&gt;	description of targetPackage</body></comment><class><name>DistributedDefinition</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition targetPackage extension children distribute </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.DistributedDefinition</class-id><body>DistributedDefinition has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables	children	&lt;OrderedCollection&gt;	description of children	definition	&lt;Store.PseudoRecord&gt;	description of definition	extension	&lt;Boolean&gt;	description of extension	targetPackage	&lt;PackageModel | nil&gt;	description of targetPackage.</body></comment><class><name>DistributedDefinitionOwnerHolder</name><environment>Store</environment><super>Store.DistributedDefinitionCollectionHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.DistributedDefinitionOwnerHolder</class-id><body>DistributedDefinitionOwnerHolder instances have either Namespaces or Classes as immediate children</body></comment><class><name>AssignAllChildrenSamePackage</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StorePatchParcelSupport</category><attributes><package>StorePatchParcelSupport</package></attributes></class><comment><class-id>Store.AssignAllChildrenSamePackage</class-id><body>AssignAllChildrenSamePackage is called from #distributeAndAskForUntargeted via #assignTargetToAllChildren, the default open a Yes/No dialog, and if yes, then open another dialog to open the PackageChooser and select a package</body></comment><methods><class-id>Store.DistributedDefinitionCollectionHolder</class-id> <category>enumerating</category><body package="StorePatchParcelSupport">excludeFromDistribution	self children do: #excludeFromDistribution</body><body package="StorePatchParcelSupport">includeInDistribution	self children do: #includeInDistribution</body><body package="StorePatchParcelSupport">setTargetPackageTo: aPackageModel	self children do: [:each | each setTargetPackageTo: aPackageModel].</body></methods><methods><class-id>Store.DistributedDefinitionCollectionHolder</class-id> <category>testing</category><body package="StorePatchParcelSupport">allExcluded	^self children allSatisfy: #allExcluded</body><body package="StorePatchParcelSupport">canExcludeFromDistribution	^self children anySatisfy: #canExcludeFromDistribution</body><body package="StorePatchParcelSupport">canIncludeInDistribution	^self children anySatisfy: #canIncludeInDistribution</body></methods><methods><class-id>Store.DistributedDefinitionCollectionHolder</class-id> <category>accessing</category><body package="StorePatchParcelSupport">children	^children</body><body package="StorePatchParcelSupport">children: aCollection	children := aCollection</body><body package="StorePatchParcelSupport">currentTargetPackage	^''</body><body package="StorePatchParcelSupport">icon	^nil</body><body package="StorePatchParcelSupport">itemString	^children isEmpty		ifTrue: [itemString]		ifFalse: 			[self allExcluded 				ifTrue: [itemString asText emphasizeAllWith: (#color -&gt; ColorValue gray)] 				ifFalse: [itemString asText allBold]]</body><body package="StorePatchParcelSupport">itemString: aStringTextOrUserMessage	itemString := aStringTextOrUserMessage</body></methods><methods><class-id>Store.DistributedDefinitionCollectionHolder</class-id> <category>initialize-release</category><body package="StorePatchParcelSupport">initialize	children := OrderedCollection new.</body></methods><methods><class-id>Store.DistributedDefinitionCollectionHolder class</class-id> <category>instance creation</category><body package="StorePatchParcelSupport">new	^super new initialize</body></methods><methods><class-id>Store.DistributedDefinitionRootHolder</class-id> <category>distrubuting</category><body package="StorePatchParcelSupport">askForUntargetedTargetsAndDistribute	untargetedDefinitions children isEmpty ifFalse:		[self shouldAssignSameTargetToAllChildren 			ifTrue: [self assignUntargeted]			ifFalse: [untargetedDefinitions askForTargets].		self moveUntargetedThatAreNowTargeted.		self distributeTargeted]</body><body package="StorePatchParcelSupport">assignUntargeted	| targetPackage |	(targetPackage := SelectTargetPackage raiseWith: sourcePackage) ifNil: [^self].	untargetedDefinitions setTargetPackageTo: targetPackage.</body><body package="StorePatchParcelSupport">distributeTargeted	targetedDefinitions distributeTargeted</body></methods><methods><class-id>Store.DistributedDefinitionRootHolder</class-id> <category>enumerating</category><body package="StorePatchParcelSupport">moveUntargetedThatAreNowTargeted	"My job is to take any untargeted objects in the root, and move them into the targeted branch"	| itemsToMove |	itemsToMove := untargetedDefinitions targetedDefinitions.	targetedDefinitions addTargets: itemsToMove.	untargetedDefinitions removeTargets: itemsToMove</body></methods><methods><class-id>Store.DistributedDefinitionRootHolder</class-id> <category>accessing</category><body package="StorePatchParcelSupport">targetedDefinitions	^targetedDefinitions</body><body package="StorePatchParcelSupport">targetedDefinitions: aDistributedDefinitionTargetHolder	targetedDefinitions := aDistributedDefinitionTargetHolder</body><body package="StorePatchParcelSupport">untargetedDefinitions	^untargetedDefinitions</body><body package="StorePatchParcelSupport">untargetedDefinitions: aDistributedDefinitionTargetHolder	untargetedDefinitions := aDistributedDefinitionTargetHolder</body></methods><methods><class-id>Store.DistributedDefinitionRootHolder</class-id> <category>filling</category><body package="StorePatchParcelSupport">fromPackage: aPackageModel	sourcePackage := aPackageModel.	targetedDefinitions := DistributedDefinitionTargetHolder new.	targetedDefinitions itemString: #Targeted &lt;&lt; #store &gt;&gt; 'Targeted'.	targetedDefinitions targetedFrom: aPackageModel.	untargetedDefinitions := DistributedDefinitionTargetHolder new.	untargetedDefinitions itemString: #UnTargeted &lt;&lt; #store &gt;&gt; 'UnTargeted'.	untargetedDefinitions untargetedFrom: aPackageModel.	children add: targetedDefinitions.	children add: untargetedDefinitions</body></methods><methods><class-id>Store.DistributedDefinitionRootHolder</class-id> <category>user interface</category><body package="StorePatchParcelSupport">shouldAssignSameTargetToAllChildren	"This is UI, but we do it via an Exception so you can drive this without a UI"	^AssignAllChildrenSamePackage raiseRequestErrorString: #UntargetedDefinitions &lt;&lt; #store &gt;&gt; 'Untargeted Definitions'</body></methods><methods><class-id>Store.DistributedDefinitionRootHolder class</class-id> <category>instance creation</category><body package="StorePatchParcelSupport">fromPackage: aPackageModel	| instance |	instance := self new.	instance fromPackage: aPackageModel.	^instance</body></methods><methods><class-id>Store.SelectTargetPackage</class-id> <category>constants</category><body package="StorePatchParcelSupport">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="StorePatchParcelSupport">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.SelectTargetPackage</class-id> <category>private - actions</category><body package="StorePatchParcelSupport">defaultAction	| packages targetPackage |	packages := Store.Registry allPackages.	packages := packages asSortedCollection: [:each :other | each name &lt; other name].	packages add: Store.Registry nullPackage.	parameter ifNotNil: [packages remove: parameter ifAbsent: [nil]].	targetPackage := (IncrementalSearchDialog		forSelectionFrom: packages		filterBlock: [:entry :pack | entry , '*' match: pack name])		windowLabel: (messageText ifNil: [#ChoosePackage &lt;&lt; #browser &gt;&gt; 'Choose Package']);		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #PackageToDistributeInto &lt;&lt; #store &gt;&gt; 'Package to Distribute into:';		objectToStringBlock: [:pack | pack name asString];		displayStringSelector: #toolListText;		iconBlock: #toolListIcon;		select.	^targetPackage</body></methods><methods><class-id>Store.SelectTargetPackage class</class-id> <category>testing</category><body package="StorePatchParcelSupport">mayResume	^true</body></methods><methods><class-id>Store.DistributedDefinitionTargetHolder</class-id> <category>enumerating</category><body package="StorePatchParcelSupport">addTargets: aCollectionOfDistributedDefinitions	| newTargets |	newTargets := (aCollectionOfDistributedDefinitions select: #isForNameSpace).	newTargets notEmpty ifTrue: [self currentNamespaceDefinitions addTargets: newTargets].	newTargets := (aCollectionOfDistributedDefinitions reject: #isForNameSpace).	newTargets notEmpty ifTrue: [self currentClassDefinitions addTargets: newTargets].</body><body package="StorePatchParcelSupport">removeTargets: aCollectionOfDistributedDefinitions	| newTargets |	newTargets := (aCollectionOfDistributedDefinitions select: #isForNameSpace).	newTargets notEmpty ifTrue: [namespaceDefinitions removeTargets: newTargets].	newTargets := (aCollectionOfDistributedDefinitions reject: #isForNameSpace).	newTargets notEmpty ifTrue: [classDefinitions removeTargets: newTargets].	(classDefinitions notNil and: [classDefinitions children isEmpty]) ifTrue: 		[children remove: classDefinitions.		classDefinitions := nil].	(namespaceDefinitions notNil and: [namespaceDefinitions children isEmpty]) ifTrue: 		[children remove: namespaceDefinitions.		namespaceDefinitions := nil].</body><body package="StorePatchParcelSupport">targetedDefinitions	| targeted |	targeted := OrderedCollection new.	namespaceDefinitions ifNotNil: [targeted addAll: namespaceDefinitions targetedDefinitions].	classDefinitions ifNotNil: [targeted addAll: classDefinitions targetedDefinitions].	^targeted</body></methods><methods><class-id>Store.DistributedDefinitionTargetHolder</class-id> <category>accessing</category><body package="StorePatchParcelSupport">currentClassDefinitions	^classDefinitions ifNil: 		[classDefinitions := DistributedDefinitionOwnerHolder new itemString: #Classes &lt;&lt; #store &gt;&gt; 'Classes'.		children add: classDefinitions]</body><body package="StorePatchParcelSupport">currentNamespaceDefinitions	^namespaceDefinitions ifNil: 		[namespaceDefinitions := DistributedDefinitionOwnerHolder new itemString: #NameSpaces &lt;&lt; #store &gt;&gt; 'NameSpaces'.		children add: namespaceDefinitions]</body></methods><methods><class-id>Store.DistributedDefinitionTargetHolder</class-id> <category>distribution</category><body package="StorePatchParcelSupport">askForTargets	namespaceDefinitions ifNotNil: 		[self shouldAssignSameTargetToAllNamespaces			ifTrue: [self assignTargetTo: namespaceDefinitions]			ifFalse: [namespaceDefinitions askForTargets]].	classDefinitions ifNotNil: 		[self shouldAssignSameTargetToAllClasses			ifTrue: [self assignTargetTo: classDefinitions]			ifFalse: [classDefinitions askForTargets]]</body><body package="StorePatchParcelSupport">assignTargetTo: aDistributedDefinitionOwnerHolder	| targetPackage |	(targetPackage := SelectTargetPackage raise) ifNil: [^self].	aDistributedDefinitionOwnerHolder setTargetPackageTo: targetPackage.</body><body package="StorePatchParcelSupport">distributeTargeted	namespaceDefinitions ifNotNil: [namespaceDefinitions distributeTargeted].	classDefinitions ifNotNil: [classDefinitions distributeTargeted]</body></methods><methods><class-id>Store.DistributedDefinitionTargetHolder</class-id> <category>filling</category><body package="StorePatchParcelSupport">collectionBlockFor: nameSpaces and: classes	^[:each |	each isForNameSpace ifTrue: 		[(nameSpaces at: each ifAbsentPut: [OrderedCollection new])				addAll: each datumDescriptors].	each isForClass ifTrue: 		[(classes at: each actualClass ifAbsentPut: [OrderedCollection new])			addAll: each methods;			addAll: each datumDescriptors]]</body><body package="StorePatchParcelSupport">targetedFrom: aStorePackage	| nameSpaces classes collectionBlock |	nameSpaces := Dictionary new.	classes := Dictionary new.	collectionBlock := self collectionBlockFor: nameSpaces and: classes.	aStorePackage extendedModels do: collectionBlock.	nameSpaces isEmpty		ifFalse: 			[namespaceDefinitions := self currentNamespaceDefinitions.			namespaceDefinitions extensionNamespacesFrom: nameSpaces].	classes isEmpty		ifFalse: 			[classDefinitions := self currentClassDefinitions.			classDefinitions extensionClassesFrom: classes].	nameSpaces := Dictionary new.	classes := Dictionary new.	collectionBlock := self collectionBlockFor: nameSpaces and: classes.	aStorePackage definedModels do: 			[:each |			each asDescription existingOverrides notEmpty				ifTrue: [collectionBlock value: each]].	nameSpaces isEmpty		ifFalse: 			[namespaceDefinitions := self currentNamespaceDefinitions.			namespaceDefinitions namespacesFrom: nameSpaces addTarget: true].	classes isEmpty		ifFalse: 			[classDefinitions := self currentClassDefinitions.			classDefinitions classesFrom: classes addTarget: true].</body><body package="StorePatchParcelSupport">untargetedFrom: aStorePackage	| nameSpaces classes collectionBlock |	nameSpaces := Dictionary new.	classes := Dictionary new.	collectionBlock := self collectionBlockFor: nameSpaces and: classes.	aStorePackage definedModels do: 			[:each |			each asDescription existingOverrides isEmpty				ifTrue: [collectionBlock value: each]].	nameSpaces isEmpty		ifFalse: 			[namespaceDefinitions := self currentNamespaceDefinitions.			namespaceDefinitions namespacesFrom: nameSpaces addTarget: false].	classes isEmpty		ifFalse: 			[classDefinitions := self currentClassDefinitions.			classDefinitions classesFrom: classes addTarget: false].</body></methods><methods><class-id>Store.DistributedDefinitionTargetHolder</class-id> <category>user interface</category><body package="StorePatchParcelSupport">shouldAssignSameTargetToAllClasses	"This is UI, but we do it via an Exception so you can drive this without a UI"	^AssignAllChildrenSamePackage raiseRequestErrorString: #UntargetedClasses &lt;&lt; #store &gt;&gt; 'Untargeted Classes'</body><body package="StorePatchParcelSupport">shouldAssignSameTargetToAllNamespaces	"This is UI, but we do it via an Exception so you can drive this without a UI"	^AssignAllChildrenSamePackage raiseRequestErrorString: #UntargetedNameSpaces &lt;&lt; #store &gt;&gt; 'Untargeted NameSpaces'</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog</class-id> <category>actions</category><body package="StorePatchParcelSupport">cancel	self closeAndUnschedule</body><body package="StorePatchParcelSupport">distribute	| root |	(root := self definitions list root) distributeTargeted.	self askForUnknownTargets value		ifTrue: [root askForUntargetedTargetsAndDistribute].	self refreshRBIfNeeded.	self fillDefinitionsTree.	(self definitions list root children allSatisfy: [:each | each children isEmpty])		ifTrue: [self closeAndUnschedule]</body><body package="StorePatchParcelSupport">excludeFromDistribution	self definitions selections do: #excludeFromDistribution.	(self widgetAt: #DefinitionsTree) invalidate</body><body package="StorePatchParcelSupport">fillDefinitionsTree	self definitions list: (TreeModel 		on: (DistributedDefinitionRootHolder fromPackage: package)		displayRoot: false		childrenWith: [:item | item children]).	self definitions list expandToLevel: 2</body><body package="StorePatchParcelSupport">includeInDistribution	self definitions selections do: #includeInDistribution.	(self widgetAt: #DefinitionsTree) invalidate</body><body package="StorePatchParcelSupport">setTargetPackage	| targetPackage |	(targetPackage := self selectTargetPackageExcluding: package) ifNil: [^self].	self definitions selections do: [:each | each setTargetPackageTo: targetPackage].	self moveUntargetedThatAreNowTargeted.	self updateTargetPackage</body><body package="StorePatchParcelSupport">updateTargetPackage	| selection |	self targetPackageString value: ((selection := self definitions selection) isNil		ifTrue: ['']		ifFalse: [selection currentTargetPackage]).</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog</class-id> <category>private</category><body package="StorePatchParcelSupport">moveUntargetedThatAreNowTargeted	"My job is to update the display after the model has taken any untargeted objects in the root, 	and moved them into the targeted branch"	| list selections root |	selections := self definitions selections.	(root := self definitions list root) moveUntargetedThatAreNowTargeted.	self definitions list root: root displayIt: false.	(list := self definitions list) expandToLevel: 2.	selections do: [:each | list expandFound: each].	self definitions selections: selections.	(self widgetAt: #DefinitionsTree) invalidate</body><body package="StorePatchParcelSupport">refreshRBIfNeeded	Refactory.Browser.HierarchyPundleNavigatorPart		allGeneralInstancesDo: [:each | each changeSetUpdate: #loadPundle: with: nil]</body><body package="StorePatchParcelSupport">selectTargetPackageExcluding: aPackage	^SelectTargetPackage raiseWith: aPackage</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog</class-id> <category>aspects</category><body package="StorePatchParcelSupport">askForUnknownTargets	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^askForUnknownTargets isNil		ifTrue:			[askForUnknownTargets := true asValue]		ifFalse:			[askForUnknownTargets]</body><body package="StorePatchParcelSupport">definitions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^definitions isNil		ifTrue:			[definitions := MultiSelectionInTree new]		ifFalse:			[definitions]</body><body package="StorePatchParcelSupport">targetPackageString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetPackageString isNil		ifTrue:			[targetPackageString := String new asValue]		ifFalse:			[targetPackageString]</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog</class-id> <category>menu</category><body package="StorePatchParcelSupport">canExcludeFromDistribution	^self definitions selections anySatisfy: #canIncludeInDistribution</body><body package="StorePatchParcelSupport">canIncludeInDistribution	^self definitions selections anySatisfy: #canExcludeFromDistribution</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog</class-id> <category>interface opening</category><body package="StorePatchParcelSupport">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self fillDefinitionsTree.	self definitions selectionIndexHolder onChangeSend: #updateTargetPackage to: self.</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog</class-id> <category>accessing</category><body package="StorePatchParcelSupport">package: aPackageModel	package := aPackageModel</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog class</class-id> <category>interface opening</category><body package="StorePatchParcelSupport">openOn: aPackageModel	| instance |	instance := self new.	instance package: aPackageModel.	instance open</body></methods><methods><class-id>Store.DistributedDefinition</class-id> <category>testing</category><body package="StorePatchParcelSupport">allExcluded	^distribute not and: [self children allSatisfy: #allExcluded]</body><body package="StorePatchParcelSupport">canExcludeFromDistribution	^distribute not or: [self children anySatisfy: #canExcludeFromDistribution]</body><body package="StorePatchParcelSupport">canIncludeInDistribution	^distribute or: [self children anySatisfy: #canIncludeInDistribution]</body><body package="StorePatchParcelSupport">hasTargetPackage	^targetPackage notNil</body><body package="StorePatchParcelSupport">isForNameSpace	^definition isForNameSpace</body></methods><methods><class-id>Store.DistributedDefinition</class-id> <category>accessing</category><body package="StorePatchParcelSupport">children	^children</body><body package="StorePatchParcelSupport">children: aCollection	children := aCollection</body><body package="StorePatchParcelSupport">currentTargetPackage	| unknown |	unknown := (#BracketUnknownBracket &lt;&lt; #store &gt;&gt; '[Unknown]') asText emphasizeAllWith: #color -&gt; ColorValue gray.	targetPackage ifNil: [^extension ifTrue: [''] ifFalse: [unknown]].	^targetPackage name</body><body package="StorePatchParcelSupport">definition	^definition</body><body package="StorePatchParcelSupport">definition: anObject	definition := anObject</body><body package="StorePatchParcelSupport">distribute	^distribute</body><body package="StorePatchParcelSupport">distribute: aBoolean	distribute := aBoolean</body><body package="StorePatchParcelSupport">extension	^extension</body><body package="StorePatchParcelSupport">extension: aBoolean	extension := aBoolean</body><body package="StorePatchParcelSupport">icon	^(definition isForMethod 		ifTrue: [CompiledMethod] 		ifFalse: [definition isForData			ifTrue: [Store.Glorp.StoreSharedVariableInPackage]			ifFalse: [definition actual]]) toolListIcon</body><body package="StorePatchParcelSupport">targetPackage	^targetPackage</body><body package="StorePatchParcelSupport">targetPackage: anObject	targetPackage := anObject</body></methods><methods><class-id>Store.DistributedDefinition</class-id> <category>enumerating</category><body package="StorePatchParcelSupport">excludeFromDistribution	distribute := false.	self children do: #excludeFromDistribution</body><body package="StorePatchParcelSupport">includeInDistribution	distribute := true.	self children do: #includeInDistribution</body><body package="StorePatchParcelSupport">removeChildrenMatching: aCollection	aCollection do:		[:each |		| target |		target := children detect: [:eachDefinition | eachDefinition itemString string = each itemString string] ifNone: [nil].		target ifNotNil: [children remove: target]]</body><body package="StorePatchParcelSupport">setTargetPackageTo: aPackageModel	distribute ifFalse: [^self].	(children isEmpty or: [extension not]) ifTrue: [targetPackage := aPackageModel].	self children do: [:each | each setTargetPackageTo: aPackageModel].</body></methods><methods><class-id>Store.DistributedDefinition</class-id> <category>distribution</category><body package="StorePatchParcelSupport">askForTargets	self shouldAssignSameTargetToMeAndMyChildren		ifTrue: [self assignTargetToAll]		ifFalse: 			[self assignTargetToMe.			self children do: #assignTargetToMe]</body><body package="StorePatchParcelSupport">assignTargetToAll	| package |	(package := SelectTargetPackage raise) ifNil: [^self].	self setTargetPackageTo: package.</body><body package="StorePatchParcelSupport">assignTargetToMe	| package |	(package := SelectTargetPackage raiseErrorString: (#TargetFor1s &lt;&lt; #store &gt;&gt; 'Target for: &lt;1s&gt;' expandMacrosWith: self typeAndSimpleName)) ifNil: [^self].	self setTargetPackageTo: package.</body><body package="StorePatchParcelSupport">distributeTargeted	(extension not or: [children isEmpty]) ifTrue: 		[distribute ifTrue: [definition distributeTargetedTo: targetPackage]].	self children do: #distributeTargeted</body><body package="StorePatchParcelSupport">shouldAssignSameTargetToMeAndMyChildren	^AssignAllChildrenSamePackage raiseRequestErrorString: (#DefinitionsOf1s &lt;&lt; #store &gt;&gt; 'definitions of &lt;1s&gt;' expandMacrosWith: self typeAndSimpleName)</body></methods><methods><class-id>Store.DistributedDefinition</class-id> <category>printing</category><body package="StorePatchParcelSupport">itemString	| string |	definition isForClass ifTrue: [string := definition actual longNameFromSmalltalk].	definition isForMethod ifTrue: [string := definition shortMethodString].	definition isForNameSpace ifTrue: [string := definition actual longNameFromSmalltalk].	string ifNil: [string := definition name].	((definition isForClass or: [definition isForNameSpace]) and: [extension])		ifTrue: [string := string asText emphasizeAllWith: #italic].	^distribute		ifTrue: [string]		ifFalse: 			[string asText				addEmphasis: (Array with: #color -&gt; ColorValue gray)				removeEmphasis: #()				allowDuplicates: true]</body><body package="StorePatchParcelSupport">simpleName	| string |	definition isForClass ifTrue: [string := definition actual name].	definition isForMethod ifTrue: [string := definition shortMethodString].	definition isForNameSpace ifTrue: [string := definition actual name].	string ifNil: [string := definition name].	^string</body><body package="StorePatchParcelSupport">typeAndSimpleName	| string |	definition isForClass ifTrue: [string := #Class &lt;&lt; #labels &gt;&gt; 'Class'].	definition isForMethod ifTrue: [string := #Method &lt;&lt; #browser &gt;&gt; 'Method'].	definition isForNameSpace ifTrue: [string := #NameSpace &lt;&lt; #labels &gt;&gt; 'NameSpace'].	string ifNil: [string := #SharedVariable &lt;&lt; #store &gt;&gt; 'Shared Variable'].	string := string asString , ' ', self simpleName.	^string</body></methods><methods><class-id>Store.DistributedDefinition</class-id> <category>initialize-release</category><body package="StorePatchParcelSupport">initialize	extension := false.	children := OrderedCollection new.	distribute := true</body></methods><methods><class-id>Store.DistributedDefinition class</class-id> <category>instance creation</category><body package="StorePatchParcelSupport">extendedDefinitionFrom: aDistributedDefinition	| instance descriptor owner |	descriptor := (owner := aDistributedDefinition definition owner) isForNameSpace		ifTrue: [NameSpaceDescriptor fromModel: owner]		ifFalse: [ClassDescriptor fromModel: owner].	instance := self extensionOn: descriptor.	instance children add: aDistributedDefinition.	^instance</body><body package="StorePatchParcelSupport">extensionOn: aDefinitionObject	| instance |	instance := self on: aDefinitionObject.	instance extension: true.	^instance</body><body package="StorePatchParcelSupport">extensionOn: aDefinitionObject target: aPackageModel	| instance |	instance := self on: aDefinitionObject  target: aPackageModel.	instance extension: true.	^instance</body><body package="StorePatchParcelSupport">new	^super new initialize</body><body package="StorePatchParcelSupport">on: aDefinitionObject	| instance |	instance := self new.	instance definition: aDefinitionObject.	^instance</body><body package="StorePatchParcelSupport">on: aDefinitionObject target: aPackageModel	| instance |	instance := self on: aDefinitionObject.	instance targetPackage: aPackageModel.	^instance</body></methods><methods><class-id>Store.DistributedDefinitionOwnerHolder</class-id> <category>distribution</category><body package="StorePatchParcelSupport">askForTargets	self children do: #askForTargets</body><body package="StorePatchParcelSupport">distributeTargeted	self children do: #distributeTargeted</body></methods><methods><class-id>Store.DistributedDefinitionOwnerHolder</class-id> <category>filling</category><body package="StorePatchParcelSupport">classesFrom: aDictionary addTarget: aBoolean	| class |	aDictionary keys do:		[:eachClass |		| definitions descriptor overrides targetPackage |		definitions := aDictionary at: eachClass.		descriptor := ClassDescriptor fromModel: eachClass.		aBoolean ifTrue: [targetPackage := (overrides := descriptor existingOverrides) isEmpty 			ifTrue: [Registry packageForClass: eachClass]			ifFalse: [overrides last sources detect: #isPackage]].		children add: (class := DistributedDefinition on: descriptor target: targetPackage).		class children addAll: (definitions collect: 			[:each | 			| owner |			owner := each isForMethod 				ifTrue: [each owner instanceBehavior] 				ifFalse: [each owner].			aBoolean ifTrue: [targetPackage := (overrides := each existingOverrides) isEmpty 				ifTrue: [Registry packageForClass: owner]				ifFalse: [overrides last sources detect: #isPackage]].			DistributedDefinition on: each target: targetPackage])]</body><body package="StorePatchParcelSupport">extensionClassesFrom: aDictionary	| class |	aDictionary keys do:		[:eachClass |		| definitions |		definitions := aDictionary at: eachClass.		children add: (class := DistributedDefinition extensionOn: (ClassDescriptor fromModel: eachClass)).		class children addAll: (definitions collect: 			[:each | 			| owner targetPackage overrides |			owner := each isForMethod 				ifTrue: [each owner instanceBehavior] 				ifFalse: [each owner].			targetPackage := (overrides := each existingOverrides) isEmpty 				ifTrue: [Registry packageForClass: owner]				ifFalse: [overrides last sources detect: #isPackage].			DistributedDefinition extensionOn: each target: targetPackage])]</body><body package="StorePatchParcelSupport">extensionNamespacesFrom: aDictionary	| class |	aDictionary keys do:		[:eachNamespace |		| definitions |		definitions := aDictionary at: eachNamespace.		children add: (class := DistributedDefinition extensionOn: (NameSpaceDescriptor fromModel: eachNamespace)).		class children addAll: (definitions collect: 			[:each | 			| owner targetPackage overrides |			owner := each owner.			targetPackage := (overrides := each existingOverrides) isEmpty 				ifTrue: [Registry packageForClass: owner]				ifFalse: [overrides last sources detect: #isPackage].			DistributedDefinition extensionOn: each target: targetPackage])]</body><body package="StorePatchParcelSupport">namespacesFrom: aDictionary addTarget: aBoolean	| definition |	aDictionary keys do: 		[:eachNamespace |		| definitions descriptor overrides targetPackage |		definitions := aDictionary at: eachNamespace.		descriptor := NameSpaceDescriptor fromModel: eachNamespace.		aBoolean ifTrue: [targetPackage := (overrides := descriptor existingOverrides) isEmpty			ifTrue: [Registry packageForClass: eachNamespace owner]			ifFalse: [overrides last sources detect: #isPackage]].		children add: (definition := DistributedDefinition on: descriptor target: targetPackage).		definition children addAll: (definitions collect: 			[:each |			| owner |			owner := each owner.			aBoolean ifTrue: [targetPackage := (overrides := each existingOverrides) isEmpty				ifTrue: [Registry packageForClass: owner]				ifFalse: [overrides last sources detect: #isPackage]].			DistributedDefinition on: each target: targetPackage])]</body></methods><methods><class-id>Store.DistributedDefinitionOwnerHolder</class-id> <category>enumerating</category><body package="StorePatchParcelSupport">addTargets: aCollectionOfDistributedDefinitions	aCollectionOfDistributedDefinitions do:		[:each |		| target |		target := children detect: [:eachDefinition | eachDefinition itemString string = each itemString string] ifNone: [nil].		target isNil			ifTrue: [children add: each]			ifFalse: 				[(target extension and: [each extension not]) ifTrue: 					[target targetPackage: each targetPackage.					target extension: false].								target children addAll: each children]]</body><body package="StorePatchParcelSupport">removeTargets: aCollectionOfDistributedDefinitions	aCollectionOfDistributedDefinitions do:		[:each |		| target |		target := children detect: [:eachDefinition | eachDefinition itemString string = each itemString string] ifNone: [nil].		each extension			ifTrue: [target removeChildrenMatching: each children]			ifFalse: [children remove: target]]</body><body package="StorePatchParcelSupport">targetedDefinitions	| topLevelTargets individualItems |	topLevelTargets := children select: #hasTargetPackage.	individualItems := OrderedCollection new.	(children reject: #hasTargetPackage) do:		[:each | individualItems addAll: (each children select: #hasTargetPackage)].	^topLevelTargets, (individualItems collect: [:each | DistributedDefinition extendedDefinitionFrom: each])</body></methods><methods><class-id>Store.DistributedDefinitionOwnerHolder</class-id> <category>initialize-release</category><body package="StorePatchParcelSupport">initialize	super initialize.	children := SortedCollection sortBlock: [:each :other | each simpleName &lt; other simpleName].</body></methods><methods><class-id>Store.AssignAllChildrenSamePackage</class-id> <category>private - actions</category><body package="StorePatchParcelSupport">defaultAction		^Dialog		confirm:			(#AssignAll1sChildren &lt;&lt; #store &gt;&gt; 'Assign all &lt;1s&gt; to the same target package?' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.AssignAllChildrenSamePackage</class-id> <category>constants</category><body package="StorePatchParcelSupport">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="StorePatchParcelSupport">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.AssignAllChildrenSamePackage class</class-id> <category>testing</category><body package="StorePatchParcelSupport">mayResume	^true</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>utils</category><body package="StorePatchParcelSupport">distributeTargetedTo: aPackageModel	super distributeTargetedTo: aPackageModel.	XChangeSet current		moveNameSpaceDefinition: self nameSpace		toPackage: aPackageModel</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>accessing</category><body package="StorePatchParcelSupport">existingOverrides	^(Override overridesForClassOrNameSpace: self actual) ifNil: [#()]</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>utils</category><body package="StorePatchParcelSupport">distributeTargetedTo: aPackageModel	super distributeTargetedTo: aPackageModel.	XChangeSet current		moveDataKey: self dataKey 		owner: self owner 		toPackage: aPackageModel</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="StorePatchParcelSupport">existingOverrides	^(Override overridesForDataKey: dataKey in: self owner) ifNil: [#()]</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>gathering</category><body package="StorePatchParcelSupport">gather: anOrderedCollection into: aStorePackageModel	Store.Policies packagePolicy 		forcePackage: aStorePackageModel		while:			[(anOrderedCollection reject: #isOverride) do: 				[:each | 				[each loadSourceDirect]					on: RedefinitionNotification					do:						[:notification | 						notification currentPackage = aStorePackageModel ifFalse:							[notification override install.							notification override 								notifyChangeSet: Store.XChangeSet current								ofMoveTo: aStorePackageModel].						notification resume]]]</body><body package="StorePatchParcelSupport">gatherChangesInto: aPackage	self gather: otherPackageNamespaces into: aPackage.	self gather: otherPackageClasses into: aPackage.	self gather: otherPackageShareds into: aPackage.	self gather: otherPackageMethods into: aPackage.</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>menu</category><body package="StorePatchParcelSupport">gatherAllPackageDifferencesInto: aPackage	| comparitor mySide otherSide |	(self leftComponents includes: menuTarget)		ifTrue: 			[mySide := self leftComponents select: #isPackage.			otherSide := self rightComponents select: #isPackage]		ifFalse: 			[mySide := self rightComponents select: #isPackage.			otherSide := self leftComponents select: #isPackage].	mySide with: otherSide do:		[:each :other |		comparitor := Store.PackageComparitor			differencesWithPropertiesBetween: other			and: each.		comparitor gatherChangesInto: aPackage].</body><body package="StorePatchParcelSupport">gatherMenuTargetDifferencesInto: aPackage	| comparitor |	comparitor := Store.PackageComparitor		differencesWithPropertiesBetween: self menuTargetCompliment		and: menuTarget.	comparitor gatherChangesInto: aPackage.</body><body package="StorePatchParcelSupport">gatherPackageDifferences: aBoolean	| packages targetPackage |	packages := Store.Registry allPackages.	packages := packages asSortedCollection: [:a :b | a name &lt; b name].	targetPackage := (IncrementalSearchDialog		forSelectionFrom: packages		filterBlock: [:entry :package | entry , '*' match: package name])		windowLabel: #ChoosePackage &lt;&lt; #browser &gt;&gt; 'Choose Package';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #PackageToGatherInto &lt;&lt; #store &gt;&gt; 'Package to Gather into:';		objectToStringBlock: [:package | package name asString];		displayStringSelector: #toolListText;		iconBlock: #toolListIcon;		select.	targetPackage ifNil: [^self].	[(Store.Gathering for: menuTarget) started.	aBoolean 		ifTrue: [self gatherAllPackageDifferencesInto: targetPackage]		ifFalse: [self gatherMenuTargetDifferencesInto: targetPackage].	(Store.Gathering for: menuTarget) finished]			withStoreFeedbackOn: self topComponent</body><body package="StorePatchParcelSupport">onePackagesDoesntExistOrIsntInImage	| leftPackages rightPackages |	rightPackages := self rightComponents select: #isPackage.	leftPackages := self leftComponents select: #isPackage.	rightPackages size = leftPackages size ifFalse: [^true].	rightPackages size &gt; 1 ifFalse: [^true].	(leftPackages allSatisfy: [:eachLeft | rightPackages contains: [:eachRight | eachRight name = eachLeft name]]) ifFalse: [^true].	(rightPackages allSatisfy: [:eachRight | leftPackages contains: [:eachLeft | eachRight name = eachLeft name]]) ifFalse: [^true].	^((rightPackages allSatisfy: #isSameAsImage) or: [leftPackages allSatisfy: #isSameAsImage]) not</body><body package="StorePatchParcelSupport">oneSidesDoesntExistOrIsntInImage	| otherTarget |	menuTarget isPackage ifFalse: [^true].	^(otherTarget := self menuTargetCompliment) isNil or: [(menuTarget isSameAsImage or: [otherTarget isSameAsImage]) not]</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>utils</category><body package="StorePatchParcelSupport">distributeTargetedTo: aPackageModel	| overrides |	(overrides := self existingOverrides) isEmpty ifFalse:		[overrides do: 			[:each | 			(each sources detect: #isPackage) = aPackageModel ifTrue: [Override removeOverride: each]]].</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>accessing</category><body package="StorePatchParcelSupport">existingOverrides	self subclassResponsibility</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>utils</category><body package="StorePatchParcelSupport">distributeTargetedTo: aPackageModel	super distributeTargetedTo: aPackageModel.	XChangeSet current		moveClassDefinition: self actual		toPackage: aPackageModel</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="StorePatchParcelSupport">existingOverrides	^(Override overridesForClassOrNameSpace: self actual) ifNil: [#()]</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>utils</category><body package="StorePatchParcelSupport">distributeTargetedTo: aPackageModel	super distributeTargetedTo: aPackageModel.	XChangeSet current		moveSelector: selector		class: self myClass		toPackage: aPackageModel</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing</category><body package="StorePatchParcelSupport">existingOverrides	^(Override overridesForSelector: selector class: self owner) ifNil: [#()]</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>printing</category><body package="StorePatchParcelSupport">shortMethodString	| string |	string := '#' , self itemString.	self isMeta ifTrue: [string := string , ' (class)'].	^string</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog class</class-id> <category>resources</category><body package="StorePatchParcelSupport">definitionsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #definitionsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SetTargetPackage 					#defaultString: 'Set Target Package' 					#catalogID: #store ) 				#value: #setTargetPackage) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ExcludeFromDistribution 					#defaultString: 'Exclude From Distribution' 					#catalogID: #store ) 				#value: #excludeFromDistribution 				#enablementSelector: #canExcludeFromDistribution ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #IncludeInDistribution 					#defaultString: 'Include In Distribution' 					#catalogID: #store ) 				#value: #includeInDistribution 				#enablementSelector: #canIncludeInDistribution ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="StorePatchParcelSupport">targetPackageMenu	"Tools.MenuEditor new openOnClass: self andSelector: #targetPackageMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SetTargetPackage 					#defaultString: 'Set Target Package' 					#catalogID: #store ) 				#value: #setTargetPackage) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="StorePatchParcelSupport">unknownTargetsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #unknownTargetsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AskForUnknownTargets 					#defaultString: 'Ask For Unknown Targets' 					#catalogID: #store ) 				#value: true ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SkipUnknownTargets 					#defaultString: 'Skip Unknown Targets' 					#catalogID: #store ) 				#value: false ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.StoreDistributeDefinitionsDialog class</class-id> <category>interface specs</category><body package="StorePatchParcelSupport">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #DistributeToPackages 				#defaultString: 'Distribute To Package(s)' 				#catalogID: #store ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 500 300 1000 600 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 30 0 -5 1 0 0.666 ) 					#name: #DefinitionsTree 					#model: #definitions 					#menu: #definitionsMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight 					#displayStringSelector: #itemString 					#useIcons: #other 					#iconSelectors: #(#icon ) 					#rootExpander: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 25 0.666 -5 1 55 0.666 ) 					#name: #TargetPackageText 					#isOpaque: true 					#model: #targetPackageString 					#tabable: false 					#menu: #targetPackageMenu 					#alignment: #center 					#style: #default 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 5 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Definitions 						#defaultString: 'Definitions' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0.666 0.5 0 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #TargetPackageColon 						#defaultString: 'Target Package:' 						#catalogID: #store ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -165 1 -28 1 -85 1 -5 1 ) 					#name: #ActionButton2 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 -28 1 -5 1 -5 1 ) 					#name: #ActionButton1 					#model: #distribute 					#label: 					#(#{Kernel.UserMessage} 						#key: #Distribute 						#defaultString: 'Distribute' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -28 1 0 0.45 -5 1 ) 					#name: #MenuButton1 					#model: #askForUnknownTargets 					#menu: #unknownTargetsMenu ) ) ) )</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>menu</category><body package="StorePatchParcelSupport">gatherAllDifferences	&lt;itemInMenu: #(#menu) position: 40.2&gt;	^(MenuItem		labeled: ((#GatherAll1qReposImageDifferences &lt;&lt; #IDE				&gt;&gt; 'Gather All &lt;1?Repository:Image&gt; Differences') expandMacrosWith: menuTarget isImageModel))		hidden: [self onePackagesDoesntExistOrIsntInImage];		value: [self gatherPackageDifferences: true];		yourself</body><body package="StorePatchParcelSupport">gatherDifferencesFrom	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^(MenuItem		labeled: (#GatherCodeDifferenceFrom1s &lt;&lt; #IDE				&gt;&gt; 'Gather Code Differences from &lt;1s&gt;'					expandMacrosWith: self menuTargetCompliment version))		hidden: [self oneSidesDoesntExistOrIsntInImage];		value: [self gatherPackageDifferences: false];		yourself</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="StorePatchParcelSupport">distributePackage	"Compare this version to the version in the database that we think represents the root of the branch it's on. Done via naming convention."	&lt;itemInMenu: #(#pundleMenu ) position: 20.899&gt;	^(MenuItem labeled: #DistributeToPackages &gt;&gt; 'Distribute To Package(s)' &lt;&lt; #store)		enablement: [self isPackageSelected];		value: [Store.StoreDistributeDefinitionsDialog openOn: self pundle]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PseudoRecord</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-ImageModel</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpaceDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>MethodDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol fullClassName meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>PackageComparisonHeaderView</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expandedFraction filteredComponents menuTarget comparison </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><class><name>StoreError</name><environment>Store</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ClassDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullClassName meta cachedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>PackageComparitor</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainPackage otherPackage mainPackageMethods otherPackageMethods mainPackageShareds otherPackageShareds mainPackageNamespaces otherPackageNamespaces mainPackageClasses otherPackageClasses mainPackageProperties otherPackageProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><class><name>DatumDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey nameSpaceName className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class></st-source>