<?xml version="1.0"?><st-source><!-- Name: StoreBaseNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.BundleName: StoreBaseBundleStructure: a Store.BundleForParcelComment: Store adds team development and version control tools and facilities to the VisualWorks development environment. To load this parcel, you should instead load one (or several) of the following parcels:	StoreForOracle8, StoreForSQLServer, StoreForPostgreSQLwhich will then load this parcel as a prerequisite.Further information on Store can be found in the "Source Code Management Guide" (located in the /doc subdirectory of the VisualWorks installation).DevelopmentPrerequisites: #(#(#any 'BOSS' '') #(#any 'LDM-Framework' '') #(#any 'LoggingTool' '') #(#any 'Database' '') #(#any 'Glorp' '') #(#any 'GlorpVWPort' ''))IsLoadOrderWarningSuppressed: trueParcel: nilParcelName: StoreBasePrerequisiteDescriptions: #(#(#name 'BOSS') #(#name 'LDM-Framework') #(#name 'LoggingTool') #(#name 'Database') #(#name 'Glorp' #componentType #bundle) #(#name 'GlorpVWPort' #componentType #package))PrerequisiteParcels: #(#('BOSS' '') #('LDM-Framework' '') #('LoggingTool' '') #('Database' '') #('Glorp' '') #('GlorpVWPort' ''))Version: 8.3 - 45Pre-Load Block: 	[ :pkg |  ]Post-Load Block: 	[ :pkg |  Store.PundleAccess postLoadActionFor: pkg.]Pre-Unload Block: 	[ :pkg |  Store.PundleAccess preUnloadActionFor: pkg.]Post-Unload Block: 	[]Date: 11:42:39 AM July 7, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on July 7, 2017 at 11:42:39 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Glorp</name><environment>Store</environment><private>false</private><imports>			private Glorp.*			private Smalltalk.*			</imports><category></category><attributes><package>Store-Base</package></attributes></name-space><comment><name-space-id>Store.Glorp</name-space-id><body>Store.Glorp namespace for all Store Database classes. </body></comment><name-space><name>UI</name><environment>Glorp</environment><private>false</private><imports>			private Glorp.*			private Store.*			private Smalltalk.*			</imports><category>StoreForGlorpVWUI</category><attributes><package>StoreForGlorpBrowserUI</package></attributes></name-space><comment><name-space-id>Glorp.UI</name-space-id><body>This is a namespace for Glorp tools and UI work.</body></comment><class><name>RedefinitionOfClass</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Compiling and Loading</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.RedefinitionOfClass</class-id><body>RedefinitionOfClass is raised when a class redefinition is raised, and the class is already in the shadow environment and in the standard environment.</body></comment><class><name>PundleInstall</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle pundleModel installed needsEarlyInstall hasRunPreload hasRunPostload completedAnalysis parentInstallObject hasRunPrerequisites </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.PundleInstall</class-id><body>PundleInstall is the abstract object for BundleInstall and PackageInstall.I am the object that represents and analyzes Pundles for the Quark installer.Subclasses must implement the following messages:	analysis		analyzeUsing:Instance Variables	completedAnalysis	&lt;Boolean&gt;	Set to true once all definitions have been analyzied and had ShadowedObjects created.	hasRunPreload	&lt;Boolean&gt;	Set to true once the preLoad has been executed for this pundle	hasRunPostload	&lt;Boolean&gt;	Set to true once the postLoad has been executed for this pundle	hasRunPrerequisites	&lt;Boolean&gt;	Set to true once all prerequisites have been run for this pundle	installed	&lt;Boolean&gt;	Set to true once this pundle has been installed.	needsEarlyInstall	&lt;Boolean&gt;	Set to true if this pundle requires early installation	parentInstallObject	&lt;BundleInstall | nil&gt;	Points to the owning BundleInstall object if I am a PackageInstall	pundle	&lt;StorePackage | StoreBundle&gt;	The actual StorePundle that I represent	pundleModel	&lt;Object | ProtoObject&gt;	description of pundleModel</body></comment><class><name>BundleInstall</name><environment>Store</environment><super>Store.PundleInstall</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.BundleInstall</class-id><body>BundleInstall is a container object for BundleInstall and PackageInstall objects that represent the first level contents of the underlying StoreBundleInstance Variables	contents	&lt;(Collection of: (BundleInstall | PackageInstall))&gt;	The immediate contents of myself as Install objects</body></comment><class><name>StorePublishDialog</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars>developmentTabLabels runtimeTabLabels tabSpecsAndHelpSelectors </class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StorePublishDialog</class-id><body>StorePublishDialog is an abstract class that provides for tabbed selection and acceptance of user modifiable setting or property pages. Subclasses must implement the following messages:	class protocol:		constants			windowLabelInstance Variables	disturbed	&lt;ValueModel on: Boolean&gt;	True on page entry change.	list	&lt;SelectionInList&gt;	Selection model.	subBuilder	&lt;UIBuilder&gt;	Page subcanvas builder.Class Instance Variables	developmentTabLabels	&lt;OrderedCollection of: String&gt;  Labels of the dialog tabs shown at development time.  	runtimeTabLabels	&lt;OrderedCollection of: String&gt; Labels of the dialog tabs shown at runtime. 	tabSpecsAndHelpSelectors	&lt;OrderedCollection of: Array&gt; A collection of the same size as developmentTabLabels, with two-element arrays as entries. The first element is the spec to use for the tab, the second is the selector to send to the application to get help text for the tab.   </body></comment><class><name>PublishPundleDialog</name><environment>Store</environment><super>Store.StorePublishDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items blessingLevel blessingComment publish versionString binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelSaveSource parcelHideSource parcelPadded parcelRepublish parcelBackup parcelOverwrite parcelWarningMessage labelDict offsets callBackBlock retry files publishFile parcelVersionString pundleModel session </inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			private Store.Glorp.*			</imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishPundleDialog</class-id><body>Tabbed dialog for all publishing options.Instance Variables	items	&lt;SelectionInList&gt; a collection of user data for each pundle		blessingLevel	&lt;ValueHolder&gt;	current item's blessing level	blessingComment	&lt;ValueHolder &lt;String&gt;	current item's comment	publish	&lt;ValueHolder &lt;Boolean&gt;&gt;	indicates if current selection is to be published	versionString	&lt;ValueHolder &lt;String&gt;&gt;	current item's version string.	binarySave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish binary	parcelSave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish as a parcel	bundleStructure	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save bundle structure in parcel.	databaseLinks	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save links to current db in parcel.	parcelDirectory	&lt;ValueHolder &lt;Filename&gt;&gt;	directory for parcel	parcelSaveSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels.	parcelHideSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelPadded	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelRepublish	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelBackup	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelOverwrite	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelWarningMessage	&lt;ValueHolder &lt;String&gt;&gt;	message that explains why a parcel cannot be published.	parcelVersionString	&lt;ValueHolder &lt;String&gt;&gt; If there is a parcel to publish, this is the version string for the Parcel (which can be different than the package/bundle)	labelDict &lt;Dictionary&gt; Cache of item labels.	offsets	&lt;Array&gt;	 Cache of label offsets	callBackBlock &lt;OneArgumentBlock&gt; Block for post-processing after publish.	retry &lt;Boolean&gt; Flag that indicates wheter to close the dialog, or retry if publish was canceled</body></comment><class><name>PublishPackageDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			private Store.Glorp.*			</imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishPackageDialog</class-id><body>PublishPackageDialog is used when publishing a single package (not a bundle)Instance Variables	package		&lt;PackageModel&gt;	The target package being published</body></comment><class><name>StoreForGlorpBrowserEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractBrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id><body>I represent the classes/methods in the Store Browser.Instance Variables	pundles	&lt;(SequenceableCollection of: StoreBundle)&gt;	cached collection of all packages and bundles in the browser environment</body></comment><class><name>BasicPublishPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allowBinaryLoading allowOverridesWithinBundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicPublishPolicy</class-id><body> When Store is publishing or loading pundles from the database it consults the instance of this maintained in the global Policies, which is a singleton of instance of Access.When publishing a pundle, this class will defer to the current BlessingPolicy to determine if the blessing level being published is appropriate.Despite the name of this class, this class allows some customization of how published pundles are loaded from a database.  When Store is loading pundles from the database it consults the instance of this maintained in the global Policies, which is a singleton of instance of Access.When a package has been published, one can optionally choose to published it as binary.  If a package is published as binary, then in addition to storing the sources for the package, a parcel file is serialized into the database.  This is useful for future loading of those packages that might be difficult to load, such as packages that contain hand crafted parsers.  Also, in the past, clients used binary publishing to help speed up loading from Store (this is no longer necessary, source loading can be in most cases faster than binary loading).  When loading packages from the database, it sometimes is useful to suppress the ability to load these packages as binary and instead simply use the source.  An example of when this might be useful is when bytecode sets have change and the source must be reompiled.  The allowsBinaryLoading instance variable toggles whether loading binary is allowed when loading from a database.If a bundle has overrides within itself and is being published the client is warned about these overrides.  However, a client can choose to ignore this warning and still publish the bundle.  When loading this bundle, two things can happen.  One, these overrides are treated as simple movement across packages within the bundle.  Or, these overrrides can be treated as overrides within the bundle being loaded.The allowsOverridesWithinBundles instance variable controls which behavior is seen.Instance Variables:	allowBinaryLoading	&lt;Boolean&gt; Boolean flag to determine if packages should load their pcl file if published binary.	allowOverridesWithinBundles	&lt;Boolean&gt;	When loading bundles, respect overrides or treat them as definition movements between packages.</body></comment><class><name>AbstractPundleDisplayRow</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.AbstractPundleDisplayRow</class-id><body>AbstractPundleDisplayRow is the abstract superclass for a family of display wrappers for pundles inside the PundleVersionPane of a PublishedPundlesVersionTool. It exists to allow different permutations of pundles needing different display formats and attributes to be shown in the same multiselection list view.Subclasses must implement the following messages:	accessing		pundleInstance Variables:	parentModel	&lt;PSFPundleVersionPane or subclass instance&gt;	This is the parent model, which provides additional information like the pundle version loaded into the image or the textStyle to use to render text.</body></comment><class><name>StorePublishAnnouncement</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StorePublishAnnouncement</class-id><body>StorePublishAnnouncement is the abstract superclass of all Publish Dialog announcementsInstance Variables	subject	&lt;StorePublishDialog&gt;	One of the subclasses of StorePublishDialog</body></comment><class><name>StorePostPublish</name><environment>Store</environment><super>Store.StorePublishAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specifications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StorePostPublish</class-id><body>StorePostPublish is announced after a publish occurs its parameters is the dialog doing the publish and the specifications being publishedInstance Variables	specifications	&lt;PublishSpecifcationList&gt;	description of specifications</body></comment><class><name>PseudoDifference</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainPackage otherPackage mainObject otherObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoDifference</class-id><body>PseudoDifference is the abstract class for all Pseudo Difference objects. It holds the "main" (from if you will) Package, which will be an PackageModel or StorePackage, and the "other" (to of you will) Package, which will always be a StorePackge.The objects they hold (mainObject otherObject) depends on what kind of difference they are. Classes, Namespaces, Comment, Shareds, Properties and Methods may be in each, depending on the subclass type.Instance Variables	mainObject	&lt;Object&gt;	description of mainObject	mainPackage	&lt;PackageModel | StorePackage&gt;	description of mainPackage	otherObject	&lt;Object&gt;	description of otherObject	otherPackage	&lt;StorePackage&gt;	description of otherPackage</body></comment><class><name>PseudoNamespaceDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedDifferences mainComment mainDefinition otherComment otherDefinition </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceDifference</class-id><body>PseudoNamespaceDifference holds on to a Namespace difference, along with any shared differences that the namespace my have.Instance Variables	sharedDifferences	&lt;Object | ProtoObject&gt;	description of sharedDifferences</body></comment><class><name>PseudoNamespaceExtensionDifference</name><environment>Store</environment><super>Store.PseudoNamespaceDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceExtensionDifference</class-id><body>PseudoNamespaceExtensionDifference is used when a Namespace is extended with Shareds in a Package</body></comment><class><name>BundleStructureMergeChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleName structure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Refactory.Browser.BundleStructureMergeChange</class-id><body>BundleStructureMergeChange is used only in the Merge Tool to change and undo a Bundle Structure.Unlike other Change refactorings, I can not cleanly reset the state of the bundle to not being changed even though I can undo.This is because of the underlying way a structure change works which deeply modifies the database informations in the BundleModelInstance Variables	bundleName	&lt;String&gt;			This is the name of the bundle being changed	structure	&lt;Array of Array&gt;	This is the array for the structure</body></comment><class><name>AbstractTool</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.AbstractTool</class-id><body>This was once the superclass of all Store browsers. Slowly, but surely, this guy is going obsolete.Subclasses must implement the following messages:	selection		pundles		pundleVersionsClass Variables:	DbBundleImage	&lt;CachedImage&gt;  comment	DbNonCodePackageImage	&lt;CachedImage&gt;  comment	DbPackageImage	&lt;CachedImage&gt;  comment	IsMonocrome	&lt;Boolean&gt;  comment	ModifiedBundleImage	&lt;OpaqueImage&gt;  comment	ModifiedNonCodePackageImage	&lt;OpaqueImage&gt;  comment	ModifiedPackageImage	&lt;OpaqueImage&gt;  comment	UnmodifiedBundleImage	&lt;CachedImage&gt;  comment	UnmodifiedNonCodePackageImage	&lt;CachedImage&gt;  comment	UnmodifiedPackageImage	&lt;CachedImage&gt;  comment</body></comment><class><name>TextDifferenceBrowser</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text2 text1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI-Definition Comparison</package></attributes></class><comment><class-id>Store.TextDifferenceBrowser</class-id><body>TextDifferenceBrowser is a simple view of two texts (passed in as strings) with their differences highlightedInstance Variables	text1	&lt;ValueModel&gt;	One string as text	text2	&lt;ValueModel&gt;	Another string as text</body></comment><class><name>DefinitionsForListPane</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itemsInList tool title </inst-vars><class-inst-vars></class-inst-vars><imports>			Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.DefinitionsForListPane</class-id><body>DefinitionsForListPane is an abstract pane for use as the top subcanvas in a DefiintionsForListTool.This pane always has a MultiSelection list.Subclasses must implement the following messages:	accessing		fillInFor:		listTitle	aspects		itemsInListInstance Variables	itemsInList	&lt;MultiSelectionInList&gt;	This is the list that the pane manages	tool	&lt;DefinitionForListTool&gt;	This is the host DefiintionsForListTool instance that uses me</body></comment><class><name>BundleTreePane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.BundleTreePane</class-id><body>BundleTreetPane is used to show the tree view of a Bundle</body></comment><class><name>StoreWorkActivity</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject isFinished </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StoreWorkActivity</class-id><body>Abstract activity announcement.UsageActivity announcements are announced at strategic edge points in Store code, allowing tools to be aware of activity. Using announcements allows the architecture to be one that carries rich state, and can have zero, one, or many interested tools paying attention.Tools become aware of their occurrence by subscribing (see Object 'announcements-configuring' method category) to the StoreLoadActivity notifications. Care should be token to unsubscribe tools when they are no longer active.StoreLoadActivity announcements come (usually) in pairs. A 'started' instance, and a 'finished' instance. They usually have a 'subject' that they represent activity for. The usual pattern is to have a sequence that looks like:(Loading for: aCodeComponent) started....work code...(Loading for: aCodeComponent) finished.Instances of me can be asked if they are the compliment of another, useful for finding the paired value in a transaction.Instance Variables	subject	&lt;Object&gt; subject is the object we're doing the work for. It's type and interpretation is defined by subclases. For many, it is a CodeComponent, so we provide an implementation of #componentName that assume it is that. If it is not a CodeComponent, said methods should be adjusted appropriately	isFinished &lt;Boolean&gt;</body></comment><class><name>LoadingParcel</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.LoadingParcel</class-id><body>My subject is a String indicating the name of the parcel</body></comment><class><name>AbstractResolutions</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolutions name </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.AbstractResolutions</class-id><body>AbstractResolutions is the abstract class for the non leaf items in the tree of a Merge.Subclasses must implement the following messages:	displaying		browseVersionsInstance Variables:	name	&lt;String&gt;	This is the name of the thing, such as the Package name, the Class name, Namespace name or '[Properties]'	resolutions	&lt;Dictionary&gt;	 Where each key the value to display in the tree, and the value is a Resolutions or a Resolver</body></comment><class><name>PundleResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PundleResolutions</class-id><body>PackageResolutions is another aggregator object which holds: PropertyResolutions, NamespaceResoltuions, ClassResolutions and PropertyResolutions</body></comment><class><name>Reconciling</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.Reconciling</class-id><body>This is announced when Reconciling packages and bundles</body></comment><class><name>PundleChanges</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle1 pundle2 changeSet1 changeSet2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PundleChanges</class-id><body>A PundleChanges is the abstract class that converts and holds the changes between two database package/bundle versions. Instance Variables	pundle1	&lt;Pundle&gt;	First pundle	pundle2	&lt;Pundle&gt;	Second pundle.	changeSet1	&lt;XChangeSet&gt;	ChangeSet for converting pundle2 into pundle1	changeSet2	&lt;XChangeSet&gt;	ChangeSet for converting pundle1 into pundle2</body></comment><class><name>PackageChanges</name><environment>Store</environment><super>Store.PundleChanges</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PackageChanges</class-id><body>A PackageChanges computes the changes between two packages where one may be an image version..</body></comment><class><name>ChangeResolver</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applied original proposed base alternatives applyable ownerName refactoring undo </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ChangeResolver</class-id><body>ChangeResolver holds a collection of alternatives for a definition. One of those definitions, &lt;original&gt;, reflects the state of the system at the time the ChangeResolver was created. A boolean indicates whether the proposed resolution has been applied to the image, that is, it has become the current definition of the class definition, comment, method definition, shared definition, namespace definition or property in a specific package..Instance Variables	alternatives	&lt;OrderedSet of GeneralResolution&gt;	A collection of definitions which includes, the one in the image, the one in the base, and all others in other merge packages	applied		&lt;Boolean&gt;							Boolean if the "proposed" is applied to the image	applyable	&lt;Boolean&gt;							True if this resover can be applied, false if this is just a notice object	original		&lt;GeneralResolution | nil&gt;				The definition that was in the image when we started 	proposed	&lt;GeneralResolution | nil&gt;				The definition from alternatives which is on deck or applied to the image	base		&lt;GeneralResolution | nil&gt;				The "base" is the common ancestor of all merged versions.	ownerName	&lt;String&gt;								The name of the owning object being definedSubclasses must implement the following messages:	displaying		browseVersions	private		validateParse:	resolving		apply		applyAsRemove</body></comment><class><name>MethodChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>movePair </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.MethodChangeResolver</class-id><body>MethodChangeResolver is a resolver that represents changes available for a Method</body></comment><class><name>BasicBlessingPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessings defaultBlessing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicBlessingPolicy</class-id><body>Defines the available blessing levels and the default blessing level. Provides a menu of blessings ease of use in dialogs.Instance Variables:	blessings	&lt;IdentityDictionary&gt;	maps symbol to BlessingLevel	defaultBlessing	&lt;BlessingLevel&gt; the default blessing for dialogs</body></comment><class><name>StoreObject</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreObject</class-id><body>This is an abstract superclass for Store domain objects. These serve several possible purposes. First, they provide a set of domain objects represent the data in the store database, which can be examined and manipulated more easily than tables. Second, they can be used to stand in for the corresponding image objects (for those that have corresponding image objects). So we can take a StorePackage and give it to the browser, which might think it is browsing a PackageModel with references to actual classes and methods, but will actually be browsing the database. Third, they can be used to stand in for Store database objects. So we can have Store believe it is manipulating a Package object with a collection of records, but actually have it be manipulating our domain objects. This lets us take advantage of some more efficient querying and other mechanisms without needing to rewrite all of the Store infrastructure.Instance Variables:	primaryKey	&lt;Integer&gt;	The primary key of the corresponding row in the database.</body></comment><class><name>StoreSourceObject</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trace username timestamp name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSourceObject</class-id><body>This is an abstract superclass for for most of the Store entities, representing the common structure among them. Most of these (but not all) are the entities that would exist in Smalltalk source code.Instance Variables:	name	&lt;String&gt;	The name of the entity.	timestamp	&lt;Timestamp&gt;	The timestamp of when it was published.	trace	&lt;self class&gt;	The previous version of ourselves.	username	&lt;String&gt;	The name of the user who published this.</body></comment><class><name>StoreParcelRecord</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blob source filename version </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreParcelRecord</class-id><body>StoreParcelRecord represents a parcel record in the database, part of a binary publish. It just holds onto blobs for the source and the binary representation.Instance Variables:	blob	&lt;StoreBlob&gt;	The parcel bits.	filename	&lt;String&gt;	The parcel file name.	source	&lt;StoreBlob&gt;	The source code for the parcel.</body></comment><class><name>PseudoNamespaceForSharedDifference</name><environment>Store</environment><super>Store.PseudoNamespaceDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceForSharedDifference</class-id><body>PseudoNamespaceForSharedDifference  is used only in merging to create a Difference object that holds a SharedVariable for a NameSpace that by itself does not have any other changes, and thus wouldn't show up in the tree</body></comment><class><name>StoreBlob</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type data result next </inst-vars><class-inst-vars>maximumDataSize </class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBlob</class-id><body>This holds the text, or bytes, for the various large strings (where large means &gt; 255 characters) associated with Store entities. Method definitions, class definitions, comments, properties, and so on, are all stored in StoreBlob entities. The really clean way to represent this would just be to have it as a string or array of bytes/words, but the database representation is complicated enough to make that difficult. So instead they are represented asStoreBlob objects, which can answer their #source or #object. #object means that we expect the blob to contain an array of bytes which is BOSS data. There is also a blob chaining scheme in the database, to accomodate blobs larger than the biggest size we can handle in the database (which varies by database). N.B. creating an instance using #new alone does not create a valid object. An instance must have non-nil type and data.  Use one of the #forXXX: instance creation methods to create a properly formed instance.Instance Variables:	data		&lt;ByteArray | nil&gt;	our raw binary data	next		&lt;StoreBlob&gt;		If we have are part of a chain of blobs, this points to the next entry. Otherwise it is nil.	result	&lt;String | Object&gt;	Our contents. This is cached, so that if we access it repeatedly we don't have to recompute it. If we are a string type, this will be a string. If we are BOSS data, it will be an arbitrary object. Trying to mix and match is not a good idea.	type	&lt;Magnitude | nil&gt;	If we are part of a chain, this is nil. If we are not, then it will be          1 for an Object (i.e. a bytearray of BOSS data).         2 for a String         3 for a double byte string         4 for a byte array, not interpreted</body></comment><class><name>StoreBinaryBlob</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreBlob</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBinaryBlob</class-id><body>This is exactly the same as a blob. I guess on some databases the blobData field may need to be of a different type in order to accomodate binary data.</body></comment><class><name>AbstractComparisonRollupView</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expandedFraction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.AbstractComparisonRollupView</class-id><body>All of the views in the comparison tools that have a triangular disclosure button to expand or collapse, are a subclass of this abstract class.UsageI implement a number of the basic behaviors of the expandable/collapsable rows used in the comparison tools. All of the actual expansion/collapsing is handled by me. Subc;lasses may use the #expansionChangeBeginning and #expansionChangeFinished methods as hooks to react changes in expansion.Nominally, I break myself down into two parts. The "header" refers to the main row that is always visible, whether expanded or not. The part that shows more when expanded is called the detailsPanel. Most of this is constructed by myself in the view construction method category.The header is populated with the disclosure triangle by me, subclasses override the method #populateHeader (with a call to the super version) to further populate the header. Some subclasses like to place an '...' graphic at the end of the header to show further details via a popup. This can be accessed be sending #moreIntoTooltipHandle. Subclasses return lines to go in the tooltip by answering an array of methods to send with #tooltipTextChunks method. The header may have a pop up menu. The menu is generated from methods tagged with the &lt;menu: aNumber&gt; tag. A subclass that potentiall has a menu should respond true to the message #hasMenu. Some common menu action methods shared amongst some subclasses exist in the menu-methods category.The detailsPanel is populated lazily, the first time it is opened. Subclasses return an array of rows to go in the details section by adding a subclass implementation of #computeDetailRows. Usually, the rows that are returned, are further created by sending #newRow to self, and then add:'ing the desired parts to it.I also support a mechanism for providing some memory for me and my children that were expanded. This is used when throwing a whole tree of these, and creating a new tree, but wanting similiar views to have the same expanded state. The methods that support this are found in the 'private-expansion memory' method category.Instance Variables	expandedFraction	&lt;Number&gt;	at rest, a value of 0 (collapsed) or 1 (expanded), is values in between to animate the "rollup/rolldown" of the view</body></comment><class><name>BindingBlueprintComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightBlueprint leftBlueprint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.BindingBlueprintComparisonView</class-id><body>I am the abstract class for comparison of any of the system structuring "objects", namely classes, shared variables, and namespaces.Usage	Aspects that are common between the comparison rollups for classes, shares, and namespaces are found in me. I further specialize my parent in the following ways:	1) I always have a left and right blueprint, but one may be nil, indicating that the particular object being shown is either either added (if left is nil) or removed (if right is nil). I add + or x overlays to various icons when it is a removal or addition.	2) I will populate the header with the name of the object, and an icon, either pulled from the live system associated object, or with the result of #defaultIcon method, which subclasses must provide.	3) When collapsed and not a remove or add (indicating a change), I show a set of icons (with counts if approprirate) after the object name in parentheses. Subclasses return these by returning the appropriate icons for the rows that will be shown when expanded; they do so by overriding the #detailHintGraphics method.	4) Which changes are shown is worked out by the #bindingDetailSelectors and the #enumerateBindingDetailChanges: methods. Subclasses are responsible to return rows in either singular mode (when this object is added or removed) or comparison mode (when this object is changed), for these specific details. I provide methods for the two details that are common to all subclass types: package information, and isPrivate information.	5) To locate the image counterpart or a blueprint (if there is one), subclasses must implement the #bindingTest method which is a test method that can be sent against the binding referennce of the object (e.g. #isForGeneral, #isForClass, #isForNamespace), this aids in interpreting the the binding refence of the blueprints.	6) There are no setters for leftBlueprint or rightBlueprint, instead subclasses provide specifically named setters for these (e.g. leftNamespace:, etc).Instance Variables	leftBlueprint	&lt;BindingBlueprint&gt;	the original class, shared, or namespace blueprint	rightBlueprint	&lt;BindingBluprint&gt;	the changed or evolved class, shared, or namespace blueprintSubclass Responsibility	private		bindingTest	utility-menu		versionListPaneClass	view construction		defaultIcon</body></comment><class><name>NamespaceBlueprintComparisonView</name><environment>Tools</environment><super>Tools.BindingBlueprintComparisonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.NamespaceBlueprintComparisonView</class-id><body>Namespace specific variant for showing namespace changes.ImplementationMost of my behavior is derived from my super class, I just provide the required queries: bindingTest, defaultIcon, and detail rows for comments and import strings. My leftBlueprint and rightBlueprint objects should be nil or NamespaceBlueprints.</body></comment><class><name>ClassBlueprintComparisonView</name><environment>Tools</environment><super>Tools.NamespaceBlueprintComparisonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightMethods leftMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.ClassBlueprintComparisonView</class-id><body>Class specific variant for showing class changes.ImplementationI am a significant specialization of the super abstract behaviors. I'm a subclass of the Namespace variant, because I can pick up comment and imports details rows from their. I provide a number of other detail rows for classes. In addition to class detail rows, I also add detail rows for all of the methods I know about.Unlike the super classes, I can actually have both leftBlueprint and rightBlueprint be nil. This is because in addition to the class blueprints, I also hold lists of methods associated with both sides. When one or the other is nil, it will then infer the class information from any of the methods classReference.Instance Variables	leftMethods	&lt;(Array of: (MethodBlueprint))&gt;	description of leftMethods	rightMethods	&lt;(Array of: (MethodBlueprint))&gt;	description of rightMethods</body></comment><class><name>Publishing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Publishing Support</package></attributes></class><comment><class-id>Store.Publishing</class-id><body>My subject is a PublishSpecification (not a CodeComponent)</body></comment><class><name>StoreObjectInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreObjectInPackage</class-id><body>This represents an object in the context of a particular package version. This corresponds most closely to the way we'd talk about the object in regular Smalltalk. So, for example, a StoreMethodInPackage is like a Smalltalk method. One thing it can do is answer the question "what package am I in? A StoreMethod can't do that because it represents a method version which can be part of many different package versions.Instance Variables:	package	&lt;StorePackage&gt;	The containing package.	definition	&lt;StoreObject&gt;	The full definition of the thing we represent.</body></comment><class><name>StoreNamespaceInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreNamespaceInPackage</class-id><body>This represents a namespace definition in a particular package. Like the other inPackage entities, it corresponds more to what we'd think of as a method in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.</body></comment><class><name>LoadOrSaveActionError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveActionError</class-id><body>LoadOrSaveActionError is an abstract error for several load/save action problems</body></comment><class><name>StoreBundleFileRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleID sequence expressionID fileID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundleFileRelationship</class-id><body>StoreBundleFileRelationship simply defines the relationship between a Bundle and its files at the lower table level.Instance Variables	bundleID		&lt;Integer&gt;	The primary key of the related StoreBundle	expressionID	&lt;Integer&gt;	Unused	sequence		&lt;Integer&gt;	The order of the related file in the list of files for the related bundle	fileID			&lt;Integer&gt;	The primary key of the related StoreFile object</body></comment><class><name>AbstractPundleLoader</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AbstractPundleLoader</class-id><body>AbstractPundleLoader is the abstract superclass for the Atomic and AtomicAnalysisLoaders.  It holds the LoadFailed shared variable which determines the action to be performed when load errors occur.</body></comment><class><name>AtomicLoader</name><environment>Store</environment><super>Store.AbstractPundleLoader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageModel classesToInitialize bindingsToInitialize classesToNotify overrides workingResult doNotMarkClean overriddenClassesInPackage </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AtomicLoader</class-id><body>Once all of the definitions have been compiled into a shadow namespace (shadowed objects), they need to then be installed into the system proper.  AtomicCompilationResult use this class to to install those definitions.  Ultimately installation starts with the instance side method #installCompilationResult:, and the argument is the compliation result.This class requires that the shadowed objects are arranged in the proper order for installation.  Each shadowed object definition is sent redirectTo: with the instance of this class as the argument.  This way each definition in the system (Class, Method, Namespace, Shareds) calls back to the shadow installer with either #installClass:, #installMethod:, #installNameSpace: or #installSharedBinding:.   See those four methods for how the definitions are installed in the system.When installing a class, or a method, this class keeps track of whether it needs to send #initialize of #postLoad: once the installation is complete.   The same is done for BindingReferences (Shared Variables).Instance Variables	packageModel	&lt;PackageModel&gt; - the package into which the objects are being installed.	classesToInitialize	&lt;OrderedCollection of: Class&gt; The classes that need to be sent #postLoad: once the installation is complete.	bindingsToInitialize	&lt;OrderedCollection of: BindingReference&gt; The bindingreferences for shared variables that need to be told to initialize once the installation is complete.	classesToNotify	&lt;IdentitySet of: Class&gt; The classes that need to be sent #instanceMethodsChange once the installation is complete and after classes have been sent #postLoad:	overrides	&lt;OrderedCollection of: override definitions&gt;	workingResult &lt;AtomicCompilationResult&gt;	The result object I am current installing from.	doNotMarkClean &lt;Boolean&gt; if an initializer fails, we flag this to true, allowing a later republish</body></comment><class><name>GraphTool</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.GraphTool</class-id><body>GraphTool is the abstract superclass of the VersionGraph tool, used to graph versions of objects in storeInstance Variables	graphView	&lt;LensGraphView&gt;	description of graphView</body></comment><class><name>BlessingDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dialog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.BlessingDialog</class-id><body>BlessingDialog is used by other Store tools to reset the blessing level for a package or a bundle.    The class side method protocol, #'interface opening' contains the protocol to invoke the dialog.    If the blessing is to be reset on a package, then BlessingDialog will instead open up a CommentPrompt dialog (see the class side method #setBlessingForPackage:).    If the blessing is to be reset on a bundle, then BlessingDialog is opened up as a SimpleDialog.Instance Variables:	dialog	&lt;SimpleDialog&gt;	The instance that provides the dialog behavior</body></comment><class><name>StoreLogin</name><environment>Store.Glorp</environment><super>Glorp.Login</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driverClassName </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreLogin</class-id><body>StoreLogin specializes the standard Glorp.Login object, by containing the driverClassName when converted from a store connection profile. This way, a StoreLogin can get the exact driver class associated with the converted connection and not try to guess. This can be a problem for Thapi based connections, where Glorp guesses at the connection, but StoreLogin can knowInstance Variables	driverClassName	&lt;String&gt;	description of driverClassName</body></comment><class><name>AbstractPublishSpecification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publish modified comment level version parentVersion description blessing object pundleModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-Publishing Support</package></attributes></class><comment><class-id>Store.AbstractPublishSpecification</class-id><body>AbstractPublishSpecificationAbstract is generic publishing information. Specifications allow you to set up instructions for publishing to the Bundle/Package.Instance Variables	blessing	&lt;Integer&gt;	 The blessing level 	comment	&lt;String&gt;	The blessing comment 	description	&lt;String&gt;	A dexcription of the pundle for display	level	&lt;SmallInteger&gt;  indent level		modified	&lt;Boolean&gt;	indicates wheter a component was modified	object	&lt;PundleModel&gt;	the pundle being published (This object changes to a StorePundle during publish)	parentVersion	&lt;String&gt; a version string for the published parent version	publish	&lt;Boolean&gt;	true if this component to be published	version	&lt;String&gt;	The version string to use use when publishing	pundleModel	&lt;PundleModel&gt; The image object being published</body></comment><class><name>PublishSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeData binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelRepublish parcelBackup parcelOverwrite parcelSaveSource parcelHideSource parcelPadded publisher parcelVersionString </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>StoreTags</category><attributes><package>Store-Publishing Support</package></attributes></class><comment><class-id>Store.PublishSpecification</class-id><body>PublishSpecification contains all the options used when publishing. #parcelX options are only used when a parcel is also being produced.Instance Variables	binarySave	&lt;Boolean&gt;	Indicates whether to publish the pundle as binary	bundleStructure	&lt;Boolean&gt;	Indicates if bundle structure should be stored when producing a parcel. 	databaseLinks	&lt;Boolean&gt;	Indicates if trace links to the current database should be stored in the parcel. 	mergeData	&lt;MergeData&gt;	Information collected in the MergeTool	parcelBackup	&lt;Boolean&gt;	Indicates if the parcel (it it exists and we are overwriting it) should be backed up.	parcelDirectory	&lt;String&gt;	The directory to store the parcel in. 	parcelHideSource &lt;Boolean&gt; Indicates if the parcel should have its source hidden. 	parcelOverwrite	&lt;Boolean&gt;	Indicates if the parcel (if it already exists) should be overwritten. 	parcelPadded	&lt;Boolean&gt;	Indicates if the parcel's source file should be padded.  See the class comment for SourceFileManager for futher information on padding source files.	parcelRepublish	&lt;Boolean&gt;	Indicates if the parcel should be republished.  	parcelSave	&lt;Boolean&gt;	Indicates if a parcel should also be created when publishing	parcelSaveSource &lt;Boolean&gt; Indicates if the parcel should have its source file saved	parcelVersionString	&lt;String&gt;	If parcelSave is true, then this is the version string to use in the parcel, which can be differnt than the package/bundle	publisher &lt;StorePundleWriter&gt; holds the pundle writer  </body></comment><class><name>GeneralResolution</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.GeneralResolution</class-id><body>GeneralResolution is the abstract resolution for all resolutionsInstance Variables	package	&lt;PundleModel | StorePundle&gt;		This is the pundle object where this user input resolution was cloned from.</body></comment><class><name>PackageDifferences</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes1 classes2 meta1 meta2 nameSpaces1 nameSpaces2 methods1 methods2 data1 data2 pkg1 pkg2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PackageDifferences</class-id><body>This hold the set of differences between two packages.  It holds definitions of methods and classes that are different from package to package. Instances of this class are used by a difference browser.Instance Variables:	classes1	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #1 	but not in the package #2	classes2	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #2 	but not in the package #1	data1	&lt;(SequenceableCollection of: DataElement)&gt; 	definitions that are in the package #1 	but not in the package #2	data2	&lt;(SequenceableCollection of: DataElement)&gt; 	definitions that are in the package #2 	but not in the package #1	meta1	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #1 	but not in the package #2	meta2	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #2 	but not in the package #1	method1	&lt;(SequenceableCollection of: Method)&gt; 	definitions that are in the package #1 	but not in the package #2	method2	&lt;(SequenceableCollection of: Method)&gt; 	definitions that are in the package #2 	but not in the package #1	data1	&lt;(SequenceableCollection of: NameSpaceRecord)&gt; 	definitions that are in the package #1 	but not in the package #2	data2	&lt;(SequenceableCollection of: NameSpaceRecord)&gt; 	definitions that are in the package #2 	but not in the package #1	pkg1	&lt;Package&gt;		package #1	pkg2	&lt;Package&gt;		package #2</body></comment><class><name>UserManagementPoliciesNotInstalledNotice</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UserManagementPoliciesNotInstalledNotice</class-id><body>UserManagementPoliciesNotInstalledNotice is raised to notify the user that the user management policies have not been installed.Default value is nil</body></comment><class><name>StoreDefinitionObject</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment definition environmentName longName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDefinitionObject</class-id><body>This is an abstract superclass for entities representing definitions in the database. Except for methods, whose structure is different enough to put them on their own.Instance Variables	comment	&lt;StoreBlob&gt;	The comment for the entity	definition	&lt;StoreBlob&gt;	The definition (i.e. source code) string for the entity.	environmentName	&lt;String&gt;	The long name of the namespace in which the object is defined. e.g. Root.Smalltalk.Core.	longName	&lt;String&gt; This is the long name of the whole object.</body></comment><class><name>StoreProperty</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreProperty</class-id><body>This represents the definition of an individual property of a package or bundle. Instance Variables:	searchString	&lt;String&gt;	The actual property values are BOSSed into the definition string, and thus are opaque to database queries. But many of the properties are simple values, or even strings. So we store up to 255 characters worth of the printable representation of the property here, so it can be queried against.</body></comment><class><name>CleanUp</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.CleanUp</class-id><body>CleanUp is signaled at the end of loading when cleanup is being done</body></comment><class><name>StorePundlePropertyRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleID propertyID recordType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePundlePropertyRelationship</class-id><body>StorePundlePropertyRelationship represents the "TW_Properties" table and is used by the Garbage CollectorInstance Variables	propertyID	&lt;Integer&gt;	This is the propertyRef column value	pundleID	&lt;Integer&gt;	This is the pundleRef column value	recordType	&lt;Integer&gt;	This is the recType column value</body></comment><class><name>DBAccess</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentString connection sequenceConnection connectedProfileHolder recentProfile tablePrefix debug log logFile databaseIdentifier installScript debugger cachedNames highestPrimaryKeyChecked subscriptionRegistry currentDatabaseAccessor storeDescriptorSystems </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Repository Access</category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.DBAccess</class-id><body>DBAccess has a singleton instance (Store.DbRegistry) that provides an access point for Store queries and some basic database utilities.self someInstanceInstance Variables	connectedProfileHolder	&lt;ValueModel&gt;	contains a ConnectionProfile of the current login.	connection	&lt;ExternalDatabaseConnection&gt;	current database connection	currentDatabaseAccessor	&lt;DatabaseAccessor&gt; the Glorp DatabaseAccessor associated with the current connection/connectionProfile	databaseIdentifier	&lt;Symbol&gt;	identifies the current database	debug	&lt;Boolean&gt;	if true, logs sql statements.	debugger	&lt;LogEnvironment&gt;	where sql statements are logged if debug is true	environmentString	&lt;unknown&gt;	unused	installScript	&lt;Boolean&gt;	if true, will create an install script instead of actually installing the tables	isOnline	&lt;Boolean&gt;	true if we believe we have a valid connection to a db	log	&lt;Boolean&gt;	if true keep log	logFile	&lt;Stream&gt;	description of logFile	recentProfile	&lt;ConnectionProfile&gt;	last succesful login profile	sequenceConnection	&lt;unknown&gt;	unused	storeDescriptorSystems &lt;Dictionary of: (aString -&gt; StoreDescriptorSystem)&gt; A simple way of not having to look up in the database what tables exist for what connection every time I get a new connection (aString is the connectionString of the login).	storeBroker	&lt;SQLBroker&gt;	an instance of a sqlbroker for the current database.	tablePrefix	&lt;String&gt;	used in creating the database tables. the default is BERN.	cachedNames &lt;IdentityDictionary of: Record-&gt;String&gt; A cache of database record classes and their names, cleared when the session is reset.  For example, after sending #allNames to Package, one would find an entry in cachedNames where the key is Package and the value is an Array of all the known names in the database.	highestPrimaryKeyChecked &lt;IdentityDictionary of: Record-&gt;Number&gt; A cache of database record classes to the highest known primary key for that class in the database.  Used to speed-up searches for database records.	subscriptionRegistry	&lt;SubscriptionRegistry&gt; Registry of panes that listen to my announcement (StoreConnect and StoreDisconnect)</body></comment><class><name>BasicMergePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>integratedBlessingChangePolicy mergeToolMinInitialTreeSize includeBranchBlessingCommentHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicMergePolicy</class-id><body>This class provides a basic merging policy.   When merging two (or more) pundles together, the default instance of this class (found in the Policies global) is consulted to decide:	1) What blessing level to set branches when merged together	2) Whether to include the entire merging blessing comment history in the blessing comment of the merged pundle	3) What is the minimum initial size of the viewable merge tree in the Merge Tool.This class will also help Store decide which pundles might be read for merging by the answer it gives to #versionsReadyForIntegration:Instance Variables:	includeBranchBlessingCommentHistory	&lt;nil|Boolean&gt;	A boolean indiciating whether to include the entire blessing comment history of the merged branches in the merged blessing comment.	integratedBlessingChangePolicy	&lt;nil|Symbol&gt;	#change or #dontChange, or if nil, then the answer to defaultIntegratedBlessingChangePolicy	mergeToolMinInitialTreeSize	&lt;nil|Number&gt;	A number that limits the size of the expanded tree view in the MergeTool.  If nil, then the answer to #defaultMergeToolMaxInitialTreeSize</body></comment><class><name>BasicOwnershipPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.BasicOwnershipPolicy</class-id><body>BasicOwnershipPolicy is a blessing policy which allows full access to the system (in effect, a "no ownership" policy)</body></comment><class><name>BasicVersionPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicVersionPolicy</class-id><body>This is the most basic versioning policy. It simply takes the current version string, looks to see if the last character is a digit, and if so, tries to increment that value.</body></comment><class><name>BranchingVersionPolicy</name><environment>Store</environment><super>Store.BasicVersionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BranchingVersionPolicy</class-id><body>BranchingVersionPolicy is a version policy that knows how to create branched version numbers :If there is a 1.0 and a 1.1 and a person attempts to publish a version based on 1.0, that version will be given the value 1.0.1</body></comment><class><name>BasicFilePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>downloadPreference downloadDirectory useDownloadDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicFilePolicy</class-id><body>When loading a bundle from the database that has files, this class provides a policy for how these files are to be downloaded.  The possible choices for a user for this policy object are 		Download Preference		#never 	Never download files for bundles, this also implies that the user is shown the dialog		#prompt 	Prompt the user with a dialog asking which files to download, if any		#always 	Always download the files	Download Directory		The directory (LogicalFileName) to store the downloaded files.   If the files being download use a SystemVariable, the download directory takes precedence.  The same holds true for absolute filenamesInstance Variables	downloadPreference	 &lt;Symbol&gt;	See above	downloadDirectory  &lt;Symbol&gt;  See above	useDownloadDirectory &lt;Boolean&gt;  See above</body></comment><class><name>StoreSettings</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StoreSettings</class-id><body>This class holds the Store specific settings</body></comment><class><name>DownloadingFiles</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.DownloadingFiles</class-id><body>This announcement is broadcast during loading when files are downloaded as part of a Bundle load</body></comment><class><name>RequestNilSuperClassNotification</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Tests</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.RequestNilSuperClassNotification</class-id><body>RequestNilSuperClassNotification is triggered when a class has a nil superclass so that the ShadowedCompiler has the opportunity to provide an alternative to Class.</body></comment><class><name>ResolutionsPane</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeTool nameStyle list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionsPane</class-id><body>ResolutionsPane is an abstract class. Its subclasses are used to display the modifications in either a list or a tree.Subclasses must implement the following messages:	aspects		list	name style		setShowLongNames		setShowShortNames	updating		updateResolutionsInstance Variables	list	&lt;SelectionInList&gt;	List of Resolutions	mergeTool	&lt;MergeTool&gt;	MergeTool	nameStyle	&lt;ByteSymbol&gt;	The style used to display the namespace names.</body></comment><class><name>GlorpWorkbook</name><environment>Glorp.UI</environment><super>Tools.Workbook</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpVWUI</category><attributes><package>StoreForGlorpVWUI</package></attributes></class><comment><class-id>Glorp.UI.GlorpWorkbook</class-id><body>Glorp.UI.StoreWorkbook openInstance Variables:	session	&lt;GlorpSession&gt; StoreForGlorp session</body></comment><class><name>UninstallingDatabaseTables</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UninstallingDatabaseTables</class-id><body>UninstallingDatabaseTables is announced when uninstalling database tables</body></comment><class><name>StoreDescriptorSystem</name><environment>Store.Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbIdentifier commonMaximumBlobRows </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDescriptorSystem</class-id><body>This is a descriptor system for a set of domain objects representing Store database entities. It also has subclasses representing the different evolutionary stages of the schema.</body></comment><class><name>Store73DescriptorSystem</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.Store73DescriptorSystem</class-id><body>This is a subclass which includes the changes made for version 7.3. This specifically means - adding a commentId field to Method - add PropertiesRecord and the Properties link table - add FileRecord and the Files link table</body></comment><class><name>AbstractTag</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol isMeta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.AbstractTag</class-id><body>This abstract class provides the information needed to reference code objects (that are class based) apart from any version information.  A (tag,package/version) pair should reference any code object.  These objects are used in Change lists and sets when dealing with Store object chanesThis class is intended to provide a uniform way of referencing class names.Subclasses must implement the following messages:	accessing		containingPackage		description		sourceTextForImage	actions		compileText:from:		moveToPackage:ifNotLoaded:	change list support		browseSystemVersion		fileOutOn:		fileOutOn:from:		fileOutRemovalOn:	converting		recordForPackage:	private-loading		applyDefinitionFrom:		removeFromSystemTolerant:fromPackage:	testing		existsInImageInstance Variables	classSym	&lt;Symbol&gt;	The name of the class or the name of the sole instance if a meta class.	isMeta		&lt;Boolean&gt;	Is this a meta class.</body></comment><class><name>DataTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey forClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.DataTag</class-id><body>DataTag manages changes to SharedVariables (Data being a very old/original name for SharedVariable)Instance Variables	dataKey	&lt;Symbol&gt;	the name of the SharedVariable	forClass	&lt;Boolean&gt;	if true, then this is a Class owned SharedVariable, if false, it is a NameSpace owned SharedVariable</body></comment><class><name>MergeException</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.MergeException</class-id><body>MergeException the parent to a collection of exceptions and errors that can be raised during a merge</body></comment><class><name>MergingMayCausePublish</name><environment>Store</environment><super>Store.MergeException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.MergingMayCausePublish</class-id><body>MergingMayCausePublish is raised if a package or bundle being merged has no image version, but all changes will cause a new package to be created and possibly later published.This situation when it arrises does not cancel a merge, and this exception is resumable</body></comment><class><name>BundleStructureComparisonView</name><environment>Store.Glorp</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isPressed targetView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.BundleStructureComparisonView</class-id><body>Provides a side by side hierarchy view of bundle structures, showing differences between the two.ImplementationI build my tree of elements as a series of annotated Panels (annotated using properties). The method for populating them is basically a recursive traversal, starting with a root left and right bundle.I place the following properties on my sub panels:	#codeComponent - The Bundle/Package (in image or not) that I'm browsing for	#codeComponentPeer - the Bundle/Package (in image or not) that is the counterpart of my codeComponent. If the bundle structure has been reordered, thse won't necessarily be on the same row	#row - index of the row it's one, used by the layout algorithm	#indent - the indent level, used by the layout algorithm	#column - 1 or 2 (left or right), used by the layout algorithmSee the menu category for examples of adding menu items.Instance Variables	isPressed	&lt;Boolean&gt;	is button2 down?	targetView	&lt;nil | Panel&gt;	 target the mouse is over</body></comment><class><name>ShadowNameSpaceBuilder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowNameSpaceBuilder</class-id><body>An instance of ShadowNameSpaceBuilder will create a new namespace tree that will have the same structure existing system namespaces.  This new namespace tree, which we call a shadow namespace, cannot be reached from the current root in the system.  To create the shadow namespace, ShadowNameSpaceBuilder first creates the Root and Smalltalk namespace.  This is because Root and Smalltalk have a special self-referential relationship - Root contains Smalltalk and Root, and Smalltalk contains Root and Smalltalk.  The builder then enumerates the namespaces in Smalltalk.  For each namespace it encounters, the builder creates a VariableBnding with its reserved flag set and whose value is a new NameSpace that has the same name and same import definitions.  This variable binding is added to the shadow namespace system.Users of ShadowNameSpaceBuilder would create a new instance, send #createShadowRoot to this instance and capture the return value.  The return error from #createShadowRoot will be the root NameSpace for the shadowed namespace.  Each time the receiver is sent createShadowRoot a new shadow namespace is created so the onus is on clients of ShadowNameSpaceBuilder to hold onto their shadowed NameSpace.When is trying to resolve a binding reference, whose home is a shadow namespace, ShadowNameSpaceHandler should be used to ensure the binding properly resolves if the binding does exist in the shadow namespace.Instance Variables	root	&lt;NameSpace&gt;	The root of the NameSpace that was created</body></comment><class><name>SQLBroker</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-Broker-Obsolete</package></attributes></class><comment><class-id>Store.SQLBroker</class-id><body>Abstract superclass responsible for processing database queries and error handling. The subclasses interface to a specific backend.Subclasses must implement the following messages:	Class protocol:		drop objects			dropDatabaseFor:			dropIndexForClass:			dropIndexForClass:index:			dropSequenceForClass:			dropTableForClass:			dropUser:			dropViewForClass:		grant statements			grant:on:columnList:to:			processGrantStatement:		private-accessing			dismissSession:		connection class			connectionClass		error handling			alreadyExistErrors			cannotCloseCursorErrorCode			doesNotExistErrors			invalidObjectErrorNumber			objectAlreadyExistisErrorNumber			objectAlreadyGoneErrorNumber			serverDiedErrorCodes		accessing			fullTableName:			getBlobData:			indexNameFor:			needsSequenceFor:		private			typeToStringMap		sql processing			safelyExecuteBlock:		create objects			allocateSpaceForObjectsIn:			createDatabaseSequence:			createDatabaseTable:			createPhysicalSpaces			createTablePrimaryKeySectionFor:keys:			createViewForClass:		queries			newSQLFor:			nextIDQuery:			sqlAssistClass</body></comment><class><name>StoreSharedVariable</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol isClassVariable </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariable</class-id><body>This represents the definition of a shared variable in either a class or a namespace.Instance Variables:	isClassVariable	&lt;Boolean&gt;	Is this a class variable, or does it stand alone in a namespace.	protocol	&lt;String&gt;	Shared variables, like methods, are grouped into protocols. This holds the name of the protocol containing this variable.</body></comment><class><name>SQLAssist</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName tableClass sqlStream alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-Broker-Obsolete</package></attributes></class><comment><class-id>Store.SQLAssist</class-id><body>Abstract superclass for sql statment generators. Subclasses support specfic backends.Instance Variables:	tableName	&lt;String&gt;  name of table being queried.	sqlStream	&lt;ReadWriteStream&gt;  used to build the query.	tableClass &lt;Class&gt; the class that represents the table being queried	alias &lt;String&gt; optional alias used for doing joins. Allows subclasses to optimize for specific backends.</body></comment><class><name>StoreSelectorProtocolNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SelectorProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id><body>StoreSelectorProtocolNavigatorPart is used when browsing Glorp/Store Database objects</body></comment><class><name>UnloadableDefinition</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loaded storeObject userDefinition problem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI-Unloadables Support</package></attributes></class><comment><class-id>Store.UnloadableDefinition</class-id><body>UnloadableDefinition is a wrapper for StoreObjectsInPackage that were not able to be loaded during a Store loadInstance Variables	loaded	&lt;Boolean&gt;	When the definition has been loaded successfully, this answers true, otherwise false.	problem	&lt;UnloadableDefinitionError&gt; the reason for being unloadable	storeObject	&lt;StoreObjectInPackage&gt;	This is the store object that was not able to be loaded	userDefinition	&lt;String | nil&gt;	If the user changes the source and executes Apply and Load, then this is the code that they changed</body></comment><class><name>AbstractPropertyComparisonRollupView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.AbstractPropertyComparisonRollupView</class-id><body>I am a common superclass for rollup views that display properties. I provide pluggable services for how to print particular properties.ImplementationBy default subclasses will send printString to the value of a property to render it in the compare tool. Some properties lend themselves to a higher level of structuring or formatting in their text representation. To accomodate this, one adds a single arugment method with &lt;printProperty:&gt; tag. The argument should the key of the property. See existing methods in the 'printing properties' method category.Subclasses must implement the following messages:	private		propertyKey</body></comment><class><name>StoreMethod</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version source className isMetaclass protocol comment selector longName </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreMethod</class-id><body>This represents the definition of a method. Note that this can be shared between many package versions. See also StoreMethodInPackage.Instance Variables	className	&lt;String&gt;	description of className	isMetaclass	&lt;Boolean&gt;	If true, then this is a class method. Otherwise it's an instance method.	protocol	&lt;String&gt;	The protocol/method category in which this method exists.	source	&lt;StoreBlob&gt;	The blob that holds our source code.	comment	&lt;Unused | StoreBinaryBlob&gt;	Not at this point used. In place for SmalltalkDoc to be able to store non-inline method comments.	version	&lt;Unused&gt;	Presumably this is there for symmetry with the other tables, but individual methods are not given version names.	longName &lt;String | nil&gt;	This is the name without the word 'class' at the end if it is a meta class, otherwise, nil</body></comment><class><name>ChangeSetInspector</name><environment>Store</environment><super>Tools.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.ChangeSetInspector</class-id><body>A ChangeSetInspector provides a menu of operations suitable for an inspector on a set of changes.Instance Variables:	windowLabel	&lt;String&gt;	The label to use for the inspector's window</body></comment><class><name>PundleChangeList</name><environment>Store</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>pundle conflictPundle dbIdentifier conflictCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PundleChangeList</class-id><body>Each BundleModel or PackageModel that has been published to a database is aware of its modifications with respect to its parent in that database.  One way to obtain these modifications is to send #modifications or #modificationsFor: to an instance of one of these models.  PundleChangeList displays these changes in the conventional ChangeList format that one might see when opening up a ChangeList on a file.  To help cache database queries, the conflictCache instance variable is used to provide a map between these modification instances and their respective record in the database.  Instance Variables:	conflictCache	&lt;IdentityDictionary&gt;	Described above	conflictPundle	&lt;Package | Bundle&gt;	The parent record for pundle	dbIdentifier	&lt;Symbol&gt;	The unique database ID that identifies which database the modifications are recorded against	pundle	&lt;PackageModel | BundleModel &gt; The pundle that is in the image</body></comment><class><name>ResolutionsListPane</name><environment>Store</environment><super>Store.ResolutionsPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionsListPane</class-id><body>ResolutionsListPane is used to display the the merge tool modification sets in a selection list.</body></comment><class><name>FileoutDifferencesDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>from to </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.FileoutDifferencesDialog</class-id><body>FileoutDifferencesDialog displays a dialog allwowing the user to choose the from/to object when filing out differences between two packages or bundlesInstance Variables	from	&lt;StorePackage | StoreBundle&gt;	The current selected difference from object	to	&lt;StorePackage | StoreBundle&gt;	The current selected difference to object</body></comment><class><name>StoreClassNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreClassNavigatorPart</class-id><body>StoreClassNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>OwnerBlessingPolicy</name><environment>Store</environment><super>Store.BasicBlessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.OwnerBlessingPolicy</class-id><body>A policy for blessings that has a concept of package/bundle ownership.</body></comment><class><name>StoreUserGroup</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>groupName userName type session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreUserGroup</class-id><body>StoreUserGroup represents a user (if type = 'U') or group (if type = 'G') in the minimal privileges system, where a user/group may be limited to publishing various pundles by their entries in the TW_DBPundlePriviliges table (StoreAccessPrivileges)Instance Variables	groupName	&lt;String&gt;	The name of a Group that is associated with bundle/package privileges	session		&lt;GlorpSession&gt;	type	&lt;String&gt;		'U' = User, 'G' = Group	userName	&lt;String&gt;	The name of a User that is associated with bundle/package privileges</body></comment><class><name>BasicPrerequisitePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchOrder versionSelection blessingLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicPrerequisitePolicy</class-id><body>The policies for resolving which development prerequisite to load.Instance Variables:	searchOrder			&lt;Symbol&gt; #parcelsFirst or #pundlesFirst.  Flag to determine whether to first meet the							development prerequisite with a parcel or a bundle, when the prerequisite type is #any.	versionSelection		&lt;Symbol&gt;	#ask or #latest.  Flag to determine whether to ask the user, or use the latest							version with at least a blessing level of blessingLevel.	blessingLevel		&lt;Integer&gt;	The blessing level used if #latest is the versionSelection criteria</body></comment><class><name>StoreCodeComponentTabNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentTabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentTabNavigatorPart</class-id><body>StoreCodeComponentTabNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>PackageObjectsToInitialize</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package classes sharedVariables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><class><name>MethodListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.MethodListPane</class-id><body>MethodListPane is used to list versions of a StoreMethodInPackage in a DefinitionsForListTool</body></comment><class><name>MethodVersionsListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.MethodListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.MethodVersionsListPane</class-id><body>MethodVersionsListPane displays versions of a single method in a class</body></comment><class><name>ShadowNameSpaceHandler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shadowRoot </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>System-Name Spaces</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Kernel.ShadowNameSpaceHandler</class-id><body>ShadowNameSpaceHandler is used by the ShadowCompiler to control how bindings are resolved.  When executing compiled definitions (for example a class definition, or namespace definition) in a shadow namespace, we want to lookup any binding first in the shadow namespace to resolve the binding, and if it is not found then look in system namespace.  This class, when used with Process&gt;&gt;#scopeEnviornmentWith:, controls the lookup.   Instance Variables	shadowRoot	&lt;NameSpace&gt;	The shadow namespace to use for resolving bindings</body></comment><class><name>RequestImageAdministatorName</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.RequestImageAdministatorName</class-id><body>RequestImageAdministatorName requests the name of a user to administrate the image.If dealt with in a resume, it will answer the userNameIf dealt with in a resume: aString it will answer aString</body></comment><class><name>LoadingError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.LoadingError</class-id><body>Generic superclass for Errors raised during loading.Instance Variables	package	&lt;PundleModel or Pundle&gt;	Package being loaded when the error occured.</body></comment><class><name>LoadingActionError</name><environment>Store</environment><super>Store.LoadingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.LoadingActionError</class-id><body>Triggered when an error occurs evaluating a components action blocks during loading.Instance Variables:	action	&lt;Symbol&gt;	indicates what failed: #preLoad #postLoad or #preRead</body></comment><class><name>StoreBrowserCommentTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserCommentTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserCommentTool</class-id><body>StoreBrowserCommentTool is used when browsing Store/Glorp database objects</body></comment><class><name>IgnorePossibleOverrideNotice</name><environment>Store</environment><super>Store.MergeException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.IgnorePossibleOverrideNotice</class-id><body>IgnorePossibleOverrideNotice is raised whenever a dialoge for override notice is about to be opened.If there are multiple applies going on, the system will resume with trueIf there is only one apply going on, the system will default to false, and the dialog will open</body></comment><class><name>EnvyStyleBlessingPolicy</name><environment>Store</environment><super>Store.OwnerBlessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.EnvyStyleBlessingPolicy</class-id><body>EnvyStyleBlessingPolicy is a simplified EnvyStyleBlessingPolicy</body></comment><class><name>StoreNameSpaceItemTabNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.NameSpaceItemTabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart</class-id><body>StoreNameSpaceItemTabNavigatorPart is used when browsing Glorp/Store objects from a Database</body></comment><class><name>StoreSharedVariableNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SharedVariableNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableNavigatorPart</class-id><body>StoreSharedVariableNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>Compiling</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Compiling</class-id><body>This is announced when Compiling during a Load</body></comment><class><name>LoadOrSaveCompilationError</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveCompilationError</class-id><body>LoadOrSaveCompilationError is raised if the action can not be compiled</body></comment><class><name>PackageComparisonHeaderView</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expandedFraction filteredComponents menuTarget comparison </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.PackageComparisonHeaderView</class-id><body>I show the list of packages/bundles that make up the contents of CodeComponentComparison, and support the ability to enable/disable some of them for a sibling ScrolledComparisonShell.ImplementationI show dual column rows for all of the matching component names found in my comparison. When one is found on only one side, I leave the other empty. Each sub view that shows a component, is tagged with a #codeComponent property, which allows that to be later queried from a given view.I support menu actions for components. When the mouse goes down a menuTarget is set by querying the #codeComponent property of the view under the mouse.I have four distinct children: summaryPanel, detailsPanel,swapButton, and disclosureButton. They always exist for all modes, but through the layout algorithm, we control which shows up where and when.I have two view modes that I manage. One is details mode. In this mode, we show all of the rows. The rows are actually buried in a BorderDecorator with a scrollbar, but we take care with the layout algorithm, to only show the scrollbar when we need to, otherwise we shove it past the right edge of me. The user can do menu actions and interact with the enable/disable button in that case.Summary mode hides all the rows (see the layout algorithm) and instead shows a single child which shows a synopsis label of the view.When there is exactly one package to show on both sides of the same name, I am said to be in "simple mode." In this case I start out in details mode, and I remove the expansion/collapse indicator at the bottom.When changes take place in the filteredComponents set, I synthesize a new comparsion object from mine via the #withoutComponents: API it provides, and pass that to my sibling ScrolledComparisonShell.When the swap button is pressed, I do that and rebuild myself.Instance Variables	comparison	&lt;CodeComponentComparison&gt;	The original whole comparison	expandedFraction	&lt;Number&gt;	value between 0 and 1, 0 is collapsed and puts me in "summary mode", 1 is expanded and puts me in details mode	filteredComponents	&lt;Set of: (CodeComponent | StorePundle)&gt;	components in the comparison which are to be currently filtered out using the withoutComponents: API	menuTarget	&lt;nil | StorePundle | CodeComponent&gt;	nil when idle, but set to the component under the mouse (if there is one), when the mouse button goes down</body></comment><class><name>ElementProxy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element related cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.ElementProxy</class-id><body>Wraps an an item in a graph. For the LDM graphing tools.Instance Variables:	element	&lt;Object&gt;  an element in a graph.	related	&lt;IdentityDictionary&gt; saves key-&gt;relationships.	cache	&lt;Dictionary&gt;  passed in by the client.Used to cache all the items in the graph for sharing.</body></comment><class><name>GroupElement</name><environment>Store</environment><super>Store.ElementProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.GroupElement</class-id><body>GroupElement is used in graphing group/users/privileges</body></comment><class><name>StoreBundleInBundle</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>containingBundle expression sequence subbundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundleInBundle</class-id><body>This describes the relationship between a Bundle and any bundles it containsInstance Variables	containingBundle	&lt;StoreBundle&gt;	The bundle containing this relationship	expression			&lt;String&gt;			Unused	sequence			&lt;Integer&gt;		Within the bundle, the sequence of this item in the load order	subbundle			&lt;StoreBundle&gt;	The bundle within the containing bundle.</body></comment><class><name>StoreLogEnvironment</name><environment>Store</environment><super>Tools.LogEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StoreLogEnvironment</class-id><body>Store extensions to LogEnvironment used to record sql statements as executed. For debugging and building installtation script.</body></comment><class><name>PundleFilter</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showPackages showBundles olderThanDate newerThanDate lessThanBlessing greaterThanBlessing </inst-vars><class-inst-vars>lastAppliedFilter </class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.PundleFilter</class-id><body>PundleFilter defines a filter that can be used for applying to a list of pundles or pundle versions.Instance Variables	greaterThanBlessing	&lt;Integer | nil&gt;	description of greaterThanBlessing	lessThanBlessing	&lt;Integer | nil&gt;	description of lessThanBlessing	newerThanDate	&lt;Date | nil&gt;	description of newerThanDate	olderThanDate	&lt;Date | nil&gt;	description of olderThanDate	showBundles	&lt;Boolean&gt;	description of showBundles	showPackages	&lt;Boolean&gt;	description of showPackages</body></comment><class><name>StorePundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment properties propertiesBlob propertiesRecordDictionary version blessings currentBlessingLevel storeModel session versionless fullClasses </inst-vars><class-inst-vars>cache </class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePundle</class-id><body>This is an abstract superclass for Store packages and bundles. Each instance represents a particular version of a particular package or bundle.Subclasses must implement the following messages:	accessing		namespaces		nameSpaces	constants		componentType		defaultCompileManager	enumerating		allComponentsDo:	full classes		fullClasses	store faking		asStoreRecord		descriptionClassInstance Variables	blessings	&lt;(Collection of: StoreBlessing)&gt;	The blessings this version has	comment	&lt;StoreBlob&gt;	Our comment.	currentBlessingLevel	&lt;Integer&gt;	The current blessing level of this pundle. Should correspond to the level of the most recent blessing.	fullClasses 	&lt;OrderedCollection of: StoreClassExtension&gt;	The full classes, that is, class entities that have their own methods, definitions, and shared variables, rather than a separate collection of the different pieces. Note that this isn't read directly from the database, but is assembled out of the pieces as required. It's possible to map it directly to the database, but prohbitively slow with the current schema.	properties	&lt;Dictionary from: Symbol to: Object&gt;	Our properties, in the Smalltalk domain form, as a dictionary of symbol keys and object values. This will be created from either the propertiesBlob or propertiesRecordDictionary representation, automatically.	propertiesBlob	&lt;StoreBlob&gt;	The pre-7.3 representation of properties, with the entire dictionary in a single blob.	propertiesRecordDictionary	&lt;Dictionary from: String to: StoreBlob&gt;	The 7.3 or after representation of properties, as individual records, containing each property as a BOSSed out object.	session	&lt;GlorpSession&gt;	The session in which we were constructed. We hold on to this because it is often useful to know.	storeModel	&lt;PundleModel | nil&gt;	The corresponding Store BundleModel or PackageModel. This may be nil if there isn't one. This is computed lazily if required.	version	&lt;String&gt;	Our version name	versionless	&lt;StoreVersionlessPundle&gt;	A link to our corresponding versionless pundle. That is, if we're version 2.4.3 of package Foo, then the corresponding versionless thing is just Foo.</body></comment><class><name>PackageInstall</name><environment>Store</environment><super>Store.PundleInstall</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shadowOrganizer hasInstalledEarly packageComparitor needsPackageRecompile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.PackageInstall</class-id><body>PackageInstall is where all the hard work is really done. The real analysis and gathering of ShadowedObjects is done here.I hold my own local ShadowOrganizer, which I send off to the AtomicAnalysisLoader only after all of my definitions have been gathered and analyzed. Instance Variables	hasInstalledEarly	&lt;Boolean&gt;	Set to true if I have been installed early	packageComparitor	&lt;PackageComparitor&gt;	If this package is a delta vs new load, then this is the comparitor used to do the delta comparison	needsPackageRecompile	&lt;Boolean&gt;	Default: false. This is set to true if the package has a Scanner or Parser subclass, and thus all classes in the package need a recompile	shadowOrganizer	&lt;ShadowOrganizer&gt;	Holds the ShadowedObjects to be installed.</body></comment><class><name>LostConnectionError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LostConnectionError</class-id><body>LostConnectionError is signalled when we unexpectedly have no database connection.</body></comment><class><name>InvalidStorePundleError</name><environment>Store.Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.InvalidStorePundleError</class-id><body>We raise this exception when we are attempting to write out a pundle, either directly or by replication, and detect an error in its structure (e.g. duplicate methods). Instance Variables:	pundle	&lt;StorePundle&gt;	The pundle we had a problem with.</body></comment><class><name>RemovalResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.RemovalResolution</class-id><body>RemovalResolution is a special kind of resolver which when applied removes the defined item from the imageInstance Variables:	base	&lt;Association&gt;	This is the Resolver's alternative which represents the object to be removed	package	&lt;StorePundle | PundleModel&gt;	description of package</body></comment><class><name>StoreProgressOverlay</name><environment>Store</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalDisplayPolicy background dropdownGradient </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StoreProgressOverlay</class-id><body>This is used to 'subsume' a Window with a topmost view which shows StoreWorkActivity feedback, and locks out any other user interaction.ImplementationThis view grabs the current component of the Window it is about to subsume, and then places itself in between the original top view and the Window. It then adds a StoreProgressView to show an StoreWorkActivity during its life cycle.On restoration, it removes itself form the view tree, and reattaches the 'regularView' as the window's top component.Note:While we are in a transition state between old UILayout and new Constraints layout, we need to save the original view's constraints when inserting it into the StoreProgressOverlay panel so they can be restored when the overlay activity is complete.  The constraints are active in the toolbar and statusbar widgets, but they are destroyed by Panel&gt;&gt;updateChildFrames:, and those widgets can no longer respond to bounds changes appropriately after the view is restored to its view tree.  This is a temporary measure until we can get Panel upgraded to work in Constraints mode.To keep things looking smooth, during it's life cycle, it installs a DoubleBufferingDisplayPolicy on the Window, but remembers the original so that it can restore that during restoration.Instance Variables	background	&lt;Image&gt;	A canned picture of the 'regularView', which is then "grayed" out to make the window contents look disabled. It is lazily managed.	originalDisplayPolicy	&lt;WindowDisplayPolicy&gt;	the damageRepairPolicy noticed at subsumption time and restored at restoreOriginal time</body></comment><class><name>PseudoClassDefinitionDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoClassDefinitionDifference</class-id><body>PseudoClassDefinitionDifference is used in the ComparePackages UI to show any definition difference between two classes</body></comment><class><name>MergeInformation</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingComment blessingLevel integratedVersions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.MergeInformation</class-id><body>MergeInformation contains information that is updated when a merge is executed that contains the details for a later publish's blessing level and blessing comment.Instance Variables	blessingComment	&lt;String&gt;		description of blessingComment	blessingLevel		&lt;Integer&gt;	description of blessingLevel	integratedVersions	&lt;OrderedCollection&gt;	description of integratedVersions</body></comment><class><name>StoreAbstractClassExtension</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreAbstractClassExtension</class-id><body>This represents a class in the more normal Smalltalk sense, something with both variables and methods. It's called a class extension to distinguish that it may be a partial class. That is, this is the definition and/or instance methods and/or class methods associated with a particular package. Any of those pieces may be missing.Subclasses must implement the following messages:	accessing		classDefinition		instanceMethods		longName		timestampInstance Variables	organization	&lt;ClassOrganizer&gt;	The Class Organizer for this object</body></comment><class><name>StoreMetaclassExtension</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreAbstractClassExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainClass classNameWithMeta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreMetaclassExtension</class-id><body>This is a fake metaclass, used for browsing.Instance Variables	mainClass	&lt;StoreClass&gt;	The actual class this is extending	classNameWithMeta	&lt;String&gt;	The class name with the string ' class' appended, which we cache to keep from making strings all the time</body></comment><class><name>ResolutionPackageItem</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package base image proposed applied alternative </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionPackageItem</class-id><body>ResolutionPackageItem is used to display Packages in the upper right hand pane of the Merge toolInstance Variables	applied	&lt;Boolean&gt;	true if this resolution has been applied	base	&lt;Boolean&gt;	true if this resolution represents the package that is the 'base'	image	&lt;Boolean&gt;	true if this resolution represents the package that is the image	package	&lt;PundleModel  | StorePundle&gt;	The PundleModel or StorePundle where the resolution is to be applied	proposed	&lt;Boolean&gt;	true if the item is the proposed item	alternative &lt;anAssociation | RemovalResolution | UserInputResolution | NoOpResolution&gt; The current resolution that this item is representing</body></comment><class><name>EarlyInstallNotice</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Compiling and Loading</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.EarlyInstallNotice</class-id><body>EarlyInstallNotice is raised during analysis when a StoreBundle or StorePackage is determined to need early install</body></comment><class><name>SingleMethodView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method isAddition parseTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.SingleMethodView</class-id><body>I show a single method view, either removed or added (but not changed).ImplementationOne additional feature I add, is keeping track of a parse tree. This is used by ClassBlueprintComparisonView to detect potential method renames. When it can find an add and remove view, for which the selectors have the same argument count and the parseTree's match, then it can annotate those two methods as a potential rename.Instance Variables	isAddition	&lt;Boolean&gt;	used to determine my header icon	method	&lt;MethodBlueprint&gt;	the method i show	parseTree	&lt;RBProgramNode&gt;	parse tree of the method source</body></comment><class><name>CreateParcelDirectoryConfirmation</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.CreateParcelDirectoryConfirmation</class-id><body>CreateParcelDirectoryConfirmation is raised when attempting to save a Package as a Parcel and the target directory does not exist, and the system wants to know if you wish to create that directory</body></comment><class><name>StoreMethodInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreMethodInPackage</class-id><body>This represents a method defined in a particular package. Like the other inPackage entities, it corresponds more to what we'd think of as a method in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.</body></comment><class><name>AtomicAnalysisLoader</name><environment>Store</environment><super>Store.AbstractPundleLoader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>installObjects pundles shadowOrganizer dllccLoaded earlyInstallClassNames compilationManager fullLoadClasses sortedFullClasses unloadableDefinitions pundlesNeedPostInstallReconcile objectsToInitialize classesToInitialize overrides overriddenClasses bindingsToInitialize classesToNotify lastPundleWorkedOn ignoreUnloadables </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AtomicAnalysisLoader</class-id><body>AtomicAnalysisLoader is the managing engine for the Quark analysis loader. When the Quark feature is turned on, then this class, instead of the AtomicCompilationManager is the driving engine for compiling and loadingInstance Variables	bindingsToInitialize	&lt;OrderedCollection of: BindingReference&gt; The bindingreferences for shared variables that need to be told to initialize once the installation is complete.	classesToInitialize	&lt;OrderedCollection of: Class&gt; The classes that need to be sent #postLoad: once the installation is complete.	classesToNotify	&lt;Collecton of: Class&gt; The classes that need to be sent #instanceMethodsChange once the installation is complete and after classes have been sent #postLoad:	compilationManager	&lt;AtomicCompilationManager&gt;	The CompilationManager used when compiling	dllccLoaded	&lt;Boolean&gt;	True if (or when) the DLLCC package/parcel is loaded.	earlyInstallClassNames	&lt;Collection of: String&gt;	A collection of names of class names that are subclasses of Scanner and SmalltalkCompiler that are in the system. This is recalculated every time there is an early install.	fullLoadClasses	&lt;SequenceableCollection&gt;	A collection of all locally defined classes during the whole compilation. Used for method ordering.	ignoreUnlodables &lt;Boolean&gt; Default : false. If ever set to true, don't bother with checking about unloadables for the rest of the load	installObjects	&lt;(Collection of: (BundleInstall | PackageInstall))&gt;	A collection of Install objects that I am analyzing compiling and installing.	lastPundleWorkedOn	&lt;StorePundle&gt;	Private: Used internally to keep track of what we are working on.	methodsMovedFromOriginalBinding &lt;Boolean&gt;	If a definition was on a Class but that class is now a Shared that points to a different class, we set this to true	overriddenClasses	&lt;Collection&gt;	The subset of Overrides that are classes which need to be recompiled	overrides	&lt;Collection&gt;	 Collection of Override objects we need to install	pundles	&lt;(Collection of: StorePundle)&gt;	This is the collection of root pundles that I am installing	shadowOrganizer	&lt;ShadowOrganizer&gt; This is the global store of ShadowedObjects that I am installing.	sortedFullClasses	&lt;Collection&gt;	Private: Used internally for detecting redefined and special early install situations	unloadableDefinitions	&lt;Collection&gt;	This is a collection of any things I can't compile</body></comment><class><name>DefinitionForListTool</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition listPart statusBar status </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.DefinitionForListTool</class-id><body>DefinitionForListTool is a generic tool for listing a bunch of homogenous objects in a list in its top pane, and a text pane below that shows information about the selected object(s).Instance Variables	definition	&lt;ValueModel&gt;	This is the text holder for showing what if anything is selected.	listPart	&lt;DefinitionsForListPane&gt;	This is the list pane that is specific to the current need.</body></comment><class><name>LoadAnalyzer</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes nameSpaces methodDict dataDict toPackage classesAreAlien wholePackage classesWithoutSuper classesWithNoEnvironment nameSpacesWithNoEnvironment withinBundle leafItems overrides </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database</category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.LoadAnalyzer</class-id><body>LoadAnalyzer does a pre-load analysis for obvious failure conditions such as methods in classes that aren't in the image or in the current load. It displays the errors and offers the user the choice to abort or to attempt the load.Instance Variables:	classes	&lt;Collection of: ClassRecord&gt;	Classes being loaded	classesWithNoEnvironment	&lt;Collection of: ClassRecord&gt; - Classes whose environment isn't in the image or the load	classesWithoutSuper	&lt;Collection of: ClassRecord&gt; - Classes whose superclass isn't in the image or the load	dataDict	&lt;Dictionary&gt; - Class to DataKey dictionary for verifying shared enviornments	leafItems	&lt;Collection&gt; - collection of the package names being loaded	methodDict	&lt;IdentityDictionary&gt;	Class to selector dictionary for verify the existance of classes for methods	nameSpaces &lt;Collection of: NameSpaceRecord&gt;	 NameSpaces being loaded	nameSpacesWithNoEnvironment	&lt;Collection of: NameSpaceRecord&gt; - NameSpaces whose environment isn't in the image or the load	overrides	&lt;OrderedCollection of Overrides&gt; - Overrides that this load would contain	toPackage	&lt;PackageModel&gt; - the Package we ware loading into	wholePackage	&lt;Boolean&gt;	whether we are loading the entire package or individual definitions. Defaults to true.	withinBundle &lt;Bundle &gt;	the bundle being loaded, nil if loading a package</body></comment><class><name>PublishSpecificationList</name><environment>Store</environment><super>Core.List</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>publisher notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>Store-IMG-Configurations</category><attributes><package>Store-Publishing Support</package></attributes></class><comment><class-id>Store.PublishSpecificationList</class-id><body>A List of PublishSpecifications. These are for the master bundle/package and all sub-components</body></comment><class><name>StoreVersionlessPundle</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name versions comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreVersionlessPundle</class-id><body>This is an abstract superclass for versionless pundles. That is, a StorePackage or StoreBundle represents one particular version of a thing. This represents the abstract thing by itself, and has a collection of its versions. We also define a precedence which is used when we sort these to put bundles before packages.Subclasses must implement the following messages:	comparing		precedenceInstance Variables:	comment	&lt;SequenceableCollection&gt;	The comment for this pundle. Since this can change by version, we get the comment for the most recent version (but note that we get it directly from the database via the mapping for this variable).	name	&lt;String&gt;	The name of the pundle	versions	&lt;SequenceableCollection of: StorePundle)&gt;	The versions of this pundle.</body></comment><class><name>StoreVersionlessPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreVersionlessPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreVersionlessPackage</class-id><body>This represents a particular versionless package.</body></comment><class><name>PrivilegeGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userGroupList packageList privilegeText </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.PrivilegeGraph</class-id><body>PrivilegeGraph is used to assiging privileges of users/groups to packagesInstance Variables:	packageList	&lt;MultiSelectionInList&gt;	The list of Packages available to assign to.	privilegeText	&lt;ValueModel&gt;	This holds the current privileges for the current user	userGroupList	&lt;SelectionInList&gt;	The list of known users and groups in the current database</body></comment><class><name>StorePundleNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.PundleNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StorePundleNavigatorPart</class-id><body>StorePundleNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>ShadowedObject</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package storeObject shadowCompiledDefinition override </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedObject</class-id><body>ShadowedObjects are used with the Quark analysis installer to gather up objects from packages which will be queried for if they need early install, and later sorted and installed.Instance Variables	package	&lt;StorePackage&gt;	The containing package for the defintion	shadowCompiledDefinition	&lt;Object&gt;	This is the object compiled into the shadow environment	storeObject	&lt;StoreObjectInPackage&gt;	The actual definition in package object</body></comment><class><name>PrerequisiteUnableToLoadConfirmation</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.PrerequisiteUnableToLoadConfirmation</class-id><body>PrerequisiteUnableToLoadConfirmation is raised when a prerequisite is unable to be satisfied.</body></comment><class><name>ShadowPundleCompileManager</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle compilationManager notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><class><name>ShadowPackageCompileManager</name><environment>Smalltalk</environment><super>ShadowPundleCompileManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shadowObjects unloadableDefinitions packageComparitor isAtomicallyLoadable overrides externalClassesNeedingRecompile methodsMovedFromOriginalBinding needsEarlyInstall </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowPackageCompileManager</class-id><body>ShadowPackageCompileManager compiles and then loads a StorePackage. When done, it answers an AtomicLoadResultInstance Variables	shadowCompiler	&lt;ShadowCompiler&gt;	This is the object that actually executes any compilation, which we collect	packageDifferences	&lt;PackageDifferences&gt;	When loading an update, this contains the difference between what is in the image and the StorePackage	isAtomicallyLoadable	&lt;Boolean&gt;	Figures out if after we are compiled, we are loadable	overrides	&lt;Collection&gt;	 Collection of Override objects we need to install	package	&lt;StorePackage&gt;	This is the StorePackage we are compiling and loading	root	&lt;Namespace&gt;	The shadow copy of the root namespace we are doing our compiling in	shadowObjects	&lt;(OrderedCollection of: (CompiledMethod))&gt;	Once an object is compiled in the shadow namespace, these are the objects that have successfully been created, ready to be atomically loaded	unloadableDefinitions	&lt;Collection&gt;	This is a collection of any things I can't compile	compilerManager	&lt;AtomicCompilationManager&gt; The manager that manages the world	externalClassesNeedingRecompile	&lt;Collection of: ExternalInterface&gt;	These are classes that need to be recompiled after installing	methodsMovedFromOriginalBinding &lt;Collection of: CompiledMethod&gt;	If a definition was on a Class but that class is now a Shared that points to a different class, we collect up those methods here	needsEarlyInstall	&lt;Boolean&gt; False (default) if an early install condition is not seen</body></comment><class><name>ConnectionDialog</name><environment>Store</environment><super>Database.ConnectionDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableOwnerHolder tableOwnerListHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.ConnectionDialog</class-id><body>Store extension to the Database.ConnectionDialog.  Adds support for owner names.Instance Variables:	tableOwnerHolder	  &lt;ValueHolder&gt;	 Holds the current owner string.	tableOwnerListHolder &lt;ValueHolder&gt;	 Holds the list of existing owners.</body></comment><class><name>StoreSelectorNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SelectorNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSelectorNavigatorPart</class-id><body>StoreSelectorNavigatorPart is used when browsing Glorp/Store objects from a Database</body></comment><class><name>FileModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dbtrace bundle portableFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-Publishing Support</package></attributes></class><comment><class-id>Store.FileModel</class-id><body>A FileModel is the in image model that represents a file that which is associated with a bundle.  A FileModel is stored in the database a portable filename.Instance Variables:	name		&lt;Object&gt; undocumented	dbtrace	&lt;Object&gt; undocumented	bundle		&lt;BundleModel&gt; The bundle that is associated with this model	portableFilename    &lt;PortableFilename&gt;  The portable filename</body></comment><class><name>NamespaceCommentChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id><body>NamespaceCommentChangeResolver is a resolver that represents a NameSpace Comment</body></comment><class><name>Gathering</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.Gathering</class-id><body>Gathering is a generic I'm Doing Something announcement</body></comment><class><name>Relinking</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Relinking</class-id><body>This is announced when Relinking is done during loading</body></comment><class><name>MismatchedDatabaseError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.MismatchedDatabaseError</class-id><body>MismatchedDatabaseError is signalled when on operation is attempted cross databases or the package isn't present on the current database when it's expected to be.</body></comment><class><name>ImagePundleDisplayRow</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractPundleDisplayRow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.ImagePundleDisplayRow</class-id><body>ImagePundleDisplayRow is a display wrapper for a pundle model loaded in the image. It is used to show the loaded version in the list in of pundles in a PundleVersionPane or subclass.Instance Variables:	pundleModel	&lt;PundleModel&gt;	This is the PundleModel currently in the image to be displayed differently from the rest of the StorePundleVersions in a PundleVersionPane or subclass.</body></comment><class><name>PseudoClassDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodDifferenceDictionary sharedDifferences </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoClassDifference</class-id><body>PseudoClassDifference holds on to a Class difference, along with any method differences that class my have.Instance Variables	methodDifferences	&lt;(Collection of: PseudoMethodDifference)&gt;	description of methodDifferences	sharedDifferences	&lt;Collection of: PseudoMethodDifferences)&gt;	</body></comment><class><name>StoreBlessing</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp username comment blessingLevel trace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBlessing</class-id><body>This represents a blessing attached to a package or bundle version. Each can have multiple blessings, and blessings can be added after the bundle/package has been published. At any given point one blessing will be considered current, and its blessing level will also be stored in the package/bundle record.Instance Variables:	blessingLevel	&lt;Integer&gt;	The blessing level. The correspondence between the integers and descriptions is in Store.Policies blessingPolicy.	comment	&lt;String&gt;	The comment describing this blessing. This is essentially the version comment - the comment associated with the blessing the pundle was given when published.	timestamp	&lt;Timestamp&gt;	The time this blessing was published.	trace	&lt;nothing&gt;	This would hold the parent blessing, but it's only here because all the Store tables have these fields. Blessing trace/previous are not used.	username	&lt;String&gt;	The name of the user who published this blessing.</body></comment><class><name>NameSpaceTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.NameSpaceTag</class-id><body>NameSpaceTag manages changes to NameSpace definitions</body></comment><class><name>NameSpaceCommentTag</name><environment>Store</environment><super>Store.NameSpaceTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.NameSpaceCommentTag</class-id><body>NameSpaceCommentTag manages changes to NameSpace comments</body></comment><class><name>SpinnerIcons</name><environment>Store</environment><super>AlphaBlendedIcons</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.SpinnerIcons</class-id><body>This class defines the spinner icons used in the StoreProgressView</body></comment><class><name>StoreProtocolEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.ProtocolEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreProtocolEnvironment</class-id><body>StoreProtocolEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>RepositoryPropertiesDialog</name><environment>Store</environment><super>Tools.DBProfilePropertiesDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableOwnerHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepositoryPropertiesDialog</class-id><body>RepositoryPropertiesDialog is used by RepositoryManager and MiniRepositoryManager to edit properties of individual Store connections.Most of the instance variables hold aspects of the dialog's widgets. The aspects are buffered value holders on aspect adaptors on the contents of 'profileHolder' variable.Instance Variables:	acceptTrigger	&lt;ValueHolder with: Boolean&gt;	Trigger channel of the buffered value	databaseHolder	&lt;BufferedValueHolder&gt;	databaseListHolder	&lt;List&gt;	environmentHolder	&lt;BufferedValueHolder&gt;	nameHolder	&lt;BufferedValueHolder&gt;	passwordHolder	&lt;BufferedValueHolder&gt;	profileHolder	&lt;ValueHolder&gt; Holds the profile whose properties are being edited.	tableOwnerHolder	&lt;BufferedValueHolder&gt;	userNameHolder	&lt;BufferedValueHolder&gt;</body></comment><class><name>ConnectionProfile</name><environment>Store</environment><super>Database.ConnectionProfile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableOwner </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.Element			private XML.Attribute			</imports><category>Store-DB-BaseObjects</category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.ConnectionProfile</class-id><body>Extends the base ConnectionProfile to include the Store database owner.Instance Variables:	tableOwner	&lt;String&gt;	the Store installation db owner name.</body></comment><class><name>StoreRepositoryListPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setting repositoryListHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.RepositoryPropertiesDialog			private Store.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Tools.StoreRepositoryListPage</class-id><body>StoreRepositoryListPage is a page that displays (and allows for the creation of) Store.ConnectionProfiles to control which repositories the image can connect to.  The list of repositories is obtained from an instance of StoreRepositoryListSetting.self someInstanceInstance Variables:	repositoryListHolder	&lt;SelectionInListSortAware on: List of: Store.ConnectionProfile&gt;	The list of repositories	setting	&lt;StoreRepositoryListSetting&gt;	The setting used for obtaining (and modifying) the list of repositories</body></comment><class><name>Comparing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.Comparing</class-id><body>Comparing is signaled when comparing packages</body></comment><class><name>StoreSelectorEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSelectorEnvironment</class-id><body>StoreSelectorEnvironment is used when browsing Glorp/Store objects from a Database</body></comment><class><name>ObsoleteBrowserContent</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session wasUsed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.ObsoleteBrowserContent</class-id><body>Stateless announcement triggered when an unhandled GlorpError is raised.</body></comment><class><name>StoreNameSpace</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreNameSpace</class-id><body>This represents the definition of a namespace.</body></comment><class><name>PundleLoadedChange</name><environment>Store</environment><super>Kernel.ComponentLoadedChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseId primaryKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PundleLoadedChange</class-id><body>Represents a package or bundle loaded event. Instance Variables:	databaseId  &lt;String&gt; - The database from which the pundle was loaded	primaryKey &lt;Integer&gt; - The primary key in the database that identifies the exact version.</body></comment><class><name>ShadowBundleCompileManager</name><environment>Smalltalk</environment><super>ShadowPundleCompileManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results parentManager </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowBundleCompileManager</class-id><body>ShadowBundleCompiler compiles a Bundle into a ShadowSpace based on a shadowed root.Instance Variables	bundle	&lt;Bundle&gt;	The Bundle being compiled	results	&lt;ShadowedBundleCompilationResult&gt; Maintains the shadowed objects and the unloadable definitions	root	&lt;Object&gt; The Shadowed Root.	notificationQueue &lt;SharedQueue&gt; the current notificationQueue	compilerManager &lt;AtomicCompilationManager&gt; The overlord of compilation</body></comment><class><name>StoreAccessPrivilege</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleName pundleType userName userType privilege session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreAccessPrivilege</class-id><body>StoreAccessPrivilege represents the relationship between a user/group (where userType 'G' = group, and userType 'U' = user) in the minimal privileges system, where a user/group may be limited to publishing various pundles by their entries in this tableInstance Variables	privilege	&lt;String&gt;	description of privilege	pundleName	&lt;String&gt;	description of pundleName	pundleType	&lt;String&gt;	description of pundleType	session		&lt;GlorpSession&gt;	userName	&lt;String&gt;	description of userName	userType	&lt;String&gt;	description of userType</body></comment><class><name>MethodTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.MethodTag</class-id><body>MethodTag manages changes for a MethodInstance Variables	protocol	&lt;Symbol&gt;	The protocol for the method	selector	&lt;Symbol&gt;	The selector for the method</body></comment><class><name>BundleChanges</name><environment>Store</environment><super>Store.PundleChanges</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.BundleChanges</class-id><body>BundleChanges computes the changes between two bundles where one may be an image version..Instance Variables	componentChanges	&lt;(Collection of: (BundleChanges | PackageChanges))&gt;	These are the first level sub components (bundle or package) for this bundle</body></comment><class><name>PublishMergeDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishMergeDialog</class-id><body>PublishMergeDialog is used when publishing a Merge or any generic group of publish specifications</body></comment><class><name>AbstractComponentTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.AbstractComponentTag</class-id><body>AbstractComponentTag is the abstract superclass of Component structure and property change tag objectsSubclasses must implement the following messages:	accessing		textInstance Variables	package	&lt;BundleModel | StoreBundle&gt;	 the image object related to this object</body></comment><class><name>StoreClassExtension</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreAbstractClassExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDefinition classMethods name longName package instanceMethods metaclass sharedVariables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreClassExtension</class-id><body>This represents a class, or a piece of a class. In the Store schema there really isn't such an entity. We just have the class definition, method definitions, but nothing that ties them together but a name. This is a thing that holds them all together. It will have to be assembled out of those pieces, either in-memory or via some sophisticated (i.e. slow) queries. This doesn't have to have any of the pieces. If we have only methods, but not the definition, then this is more like an ENVY class extension - hence the name. But it can also represent something that has the definition and may or may not have methods as well.Instance Variables:	classDefinition	&lt;StoreClassDefinitionInPackage&gt;	The definition of this class. This doesn't have to be present.	classMethods	&lt;Collection of: StoreMethodDefinitionInPackage&gt;	Our class methods.	instanceMethods	&lt;Collection of: StoreMethodDefinitionInPackage&gt;	Our instance methods.	longName	&lt;String&gt;	The long name of the class. That is Root.Smalltalk.Whatever.Whatever	metaclass	&lt;StoreMetaclassExtension&gt;	A representation of our metaclass. This doesn't have a lot of useful data, since we have our class methods here, but one of the purposes of this is to be able to use these as proxies for real classes when browsing, so the browser can be made to browse the database without really knowing it. In that usage it's likely to to want an equivalent of a metaclass for us.	name	&lt;String&gt;	Our short name.	package	&lt;StorePackage&gt;	The package that contains us.	sharedVariables	&lt;Collection of: StoreSharedVariableInPackage&gt;	Our shared variable definitions.</body></comment><class><name>PackageConflicts</name><environment>Store</environment><super>Store.PackageDifferences</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PackageConflicts</class-id><body>This class differs from the superclass by holding only the set of conflicting definitions between two packages.  </body></comment><class><name>UnloadableDefinitionNotification</name><environment>Store</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UnloadableDefinitionNotification</class-id><body>UnloadableDefinitionNotification is a notification to be sent when a Store loading operation fails. As opposed to UnloadableDefinitionError, this is just a notification which can be caught by interested use cases, but does not lead to unhandled exception handling.</body></comment><class><name>FilingOut</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.FilingOut</class-id><body>FilingOut is an annoucer used when filing out Store/Glorp objects</body></comment><class><name>StoreMethodDefinitionEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.MethodDefinitionEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id><body>StoreMethodDefinitionEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>StoreCodeComponentPropertyInspector</name><environment>Store.Glorp</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertyParts </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Trippy.*			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id><body>I provide an inspector like experience for editing the properties of a code component. I was really just designed to be used in an "embedded" mode and should always be pointed at a StorePundle.I collaborate with a special Part subclass: CodeComponentProperty.From an interaction point-of-view, I'm modeled somewhat after a DictionaryInspector.</body></comment><class><name>AtomicLoadingError</name><environment>Store</environment><super>Store.LoadingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AtomicLoadingError</class-id><body>AtomicLoadingError is thown if a stand alone package is not able to be loaded atomically. In interactive mode, the user is notified that a problem occurred.If because of missing subclasses, shared or namespaces, the Atomic Loader determines a Package can not be loaded atomically, this error is thrown, and a dialog will open reading:	&lt;somepackage&gt; is unable to be atomically loaded.If you are using hand code to load stuff and you don't want to have a dialog pop up, you can wrap your code in an	on: AtomicLoadingError	do: []There are two helper methods you can use in your do:, you can :	[:exception | exception abortLoad]Which will simply abort the load cleanly.</body></comment><class><name>StoreSharedVariableInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id><body>This represents a shared variable definition in a particular package. Like the other inPackage entities, it corresponds more to what we'd think of as a method in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.</body></comment><class><name>MergeToolHelp</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>helpTextHolder helpIconList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MergeToolMods</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.MergeToolHelp</class-id><body>MergeToolHelp is the application responsible for displaying the help windows for the Merge Tool.Instance Variables:	helpIconList	&lt;SelectionInList on: (List of: LabelAndIcon)&gt;	The list of icons and their descriptions.	helpTextHolder	&lt;ValueHolder on: Text&gt;	The help text.</body></comment><class><name>MethodDifferenceBrowser</name><environment>Store</environment><super>Store.TextDifferenceBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol1 protocol2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI-Definition Comparison</package></attributes></class><comment><class-id>Store.MethodDifferenceBrowser</class-id><body>MethodDifferenceBrowser is used to display the differences between two methods showing their protcol.Instance Variables	protocol1	&lt;ValueHolder&gt;	the text of the left hand side protocol	protocol2	&lt;ValueHolder&gt;	the text of the right hand side protocol</body></comment><class><name>RepositoryManager</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repositoryListHolder connectedIcon </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.XMLParser			private XML.SAXWriter			private XML.Document			private XML.Element			</imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepositoryManager</class-id><body>RepositoryManager is the standalone application for managing Store connections. It uses a dataset to list the known connections and allows one to manage connections, including saving to and loading from files.Instance Variables:	connectedIcon	&lt;Image&gt;	The image used by the dataset to mark the currenly connected repository, if any.	repositoryListHolder	&lt;SelectionInList&gt;	The model of the repository list.</body></comment><class><name>StoreRepositoryListSetting</name><environment>Tools</environment><super>Tools.GenericSettingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.RepositoryManager			private Store.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Tools.StoreRepositoryListSetting</class-id><body>StoreRepositoryListSetting is the setting used by the StoreRepositoryListPage.  It is a list of Store.ConnectionProfile instances that are used for connecting to store repositories.  This list of repositories is found at:	RepositoryManager repositoriesThis does not modifiy the original list returned by #repositories, but instead operates on a copy of it.This list (profiles) is populated by the #initialize method (and #resetProfiles which can be sent by the StoreRepositoryListSettingPage).   If a new profile is created in the settings tool, then it will be installed in #installProfiles.  Instance Variables:	profiles	&lt;List of: Store.ConnectionProfile&gt;	The store connection profiles</body></comment><class><name>PseudoClassCommentDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoClassCommentDifference</class-id><body>PseudoClassCommentDifference is used in the ComparePackages UI to show any comment difference between two classes</body></comment><class><name>StoreClassAndMethodTabNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassAndMethodTabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart</class-id><body>StoreClassAndMethodTabNavigatorPart is used when browsing Glorp/Store objects from a Database</body></comment><class><name>MarkPundlesForDeletionTool</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleTabs targetedPundles bundleVersions bundles packages packageVersions session previouslyMarkedPundles filter cachedNames oldFilter </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.MarkPundlesForDeletionTool</class-id><body>MarkPundlesForDeletionTool is the UI front end to the GarbageCollector. It allows the user to mark for deletion, both StorePackages and StoreBundles visually.Instance Variables	bundles	&lt;SelectionInList&gt;	The collection of filtered bundle names that can be chosen from	bundleVersions	&lt;MultiSelectionInList&gt;	When a bundle is chosen, the versions of that bundle available to be removed	cachedNames	&lt;Dictionary&gt;		At startup, this caches the list of unfiltered bundle and package names	filter	&lt;DeletionToolFilter&gt;	This is the filter used to filter the list of packages/bundles and versions	oldFilter	&lt;nil | DeletetionToolFilter&gt;	When you clear the filter, we stash the existing one here, to be reused when the filter tool is reopened	packages	&lt;SelectionInList&gt;		The collection of filtered package names that can be chosen from	packageVersions	&lt;MultiSelectionInList&gt;	When a package is chosen, the versions of that package available to be removed	previouslyMarkedPundles	&lt;(Collection of: (StorePundle))&gt;	On startup, this is the collection of pundles that are already marked for deleteion.	pundleTabs	&lt;SelectionInList&gt;		This is the Tab widget used in the UI	session	&lt;GlorpSession&gt;	The GlorpSession used throughout this tool for accessing the database.	targetedPundles	&lt;MultiSelectionInList&gt;	This is the list of marked for deletion, and proposed marked for deletion pundles</body></comment><class><name>SharedChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>movePair </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.SharedChangeResolver</class-id><body>SharedChangeResolver represents changes to a Shared in either a Class or Namespace</body></comment><class><name>AbstractModification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.AbstractModification</class-id><body>AbstractModification is the superclass for Modification and TextModificationSubclasses must implement the following messages:	accessing		description		existsInPackage		source		timeStampString	actions		apply	change list support		sameAsSystem	comparing		=	testing		notOriginallyInImageInstance Variables:	package	&lt;PundleModel&gt;	The current package or bundle being modified	tag	&lt;MethodTag&gt;	The method</body></comment><class><name>CodeComponentPropertiesComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightProperties leftProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.CodeComponentPropertiesComparisonView</class-id><body>I am similiar in behavior to a ClassBlueprintComparisonView, but instead of methods, my detail rows are for changed/added/removed package properties.Instance Variables	leftProperties	&lt;Array of: CodeComponentPropertyBlueprint&gt;	properties of the original package	rightProperties	&lt;Array of: CodeComponentPropertyBlueprint&gt;	evolved properties of the new package</body></comment><class><name>ClassCommentChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ClassCommentChangeResolver</class-id><body>ClassCommentChangeResolver is a ChangeResolver for Class Comments</body></comment><class><name>AlreadyConnected</name><environment>Store</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.AlreadyConnected</class-id><body>AlreadyConnected is raised in the scope of connecting to a named profile</body></comment><class><name>CommentPrompt</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text blessingLevel userName pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.CommentPrompt</class-id><body>CommentPrompt is used to ask the user for the blessing level and  comment when changing a blessing for a package or bundleInstance Variables	blessingLevel	&lt;ValueHolder&gt;	The current blessing level selected	pundle	&lt;StorePundle&gt;	The StorePundle being mnodified	text	&lt;ValueModel&gt;	The comment the user may make	userName	&lt;LensAbsentee | Object&gt;	description of userName</body></comment><class><name>InstallUserManagementPolicies</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.InstallUserManagementPolicies</class-id><body>InstallUserManagementPolicies asks the user if they want to install user management policies.default value is true</body></comment><class><name>RepositoryFilterDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleFilter showBundles showPackages useGreaterThanBlessing useLessThanBlessing useNewerThanDate useOlderThanDate newerThanDate olderThanDate lessThanBlessing greaterThanBlessing </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepositoryFilterDialog</class-id><body>RepositoryFilterDialog is a dialog associated with the PublishedPundleVersionsTool, which sets up filters for use in the various published viewsInstance Variables	greaterThanBlessing	&lt;ValueModel on: (Integer | nil)&gt;	description of greaterThanBlessing	lessThanBlessing	&lt;ValueModel on: (Integer | nil)&gt;	description of lessThanBlessing	newerThanDate	&lt;ValueModel on: Date&gt;	description of newerThanDate	olderThanDate	&lt;ValueModel on: Date&gt;	description of olderThanDate	showBundles	&lt;ValueModel on: Boolean&gt;	description of showBundles	showPackages	&lt;ValueModel on: Boolean&gt;	description of showPackages	useGreaterThanBlessing	&lt;ValueModel on: Boolean&gt;	description of useGreaterThanBlessing	useLessThanBlessing	&lt;ValueModel on: Boolean&gt;	description of useLessThanBlessing	useNewerThanDate	&lt;ValueModel on: Boolean&gt;	description of useNewerThanDate	useOlderThanDate	&lt;ValueModel on: Boolean&gt;	description of useOlderThanDate</body></comment><class><name>StoreWorkbook</name><environment>Glorp.UI</environment><super>Glorp.UI.GlorpWorkbook</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpVWUI</category><attributes><package>StoreForGlorpVWUI</package></attributes></class><comment><class-id>Glorp.UI.StoreWorkbook</class-id><body>StoreWorkbook is the notebook UI that opens on a Glorp connection which shows examples of how to interact with Store.Glorp database objects</body></comment><class><name>PublishPundlesDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			private Store.Glorp.*			</imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishPundlesDialog</class-id><body>PublishPundlesDialog is used to publish a collection of packages and/or bundles. By default, only modified packages and/or bundles will be publishedInstance Variables	pundles	&lt;&gt;	description of pundles	session &lt;GlorpSession&gt; one session to rule them all</body></comment><class><name>VersionGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.VersionGraph</class-id><body>VersionGraph is the tool that displays the graphed version of store objectsInstance Variables	pundle	&lt;CodeComponent | FileModel | PseudoPackage | Pundle | StorePundle&gt;	description of pundle</body></comment><class><name>ShadowCompiler</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shadowRoot </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowCompiler</class-id><body>ShadowCompilationManager is used to compile and evaluate definition messages in the context of a shadowed namespace.Instance Variables	shadowRoot	&lt;NameSpace&gt;	The root of the shadowed namespace.</body></comment><class><name>StorePublishDialogInitializing</name><environment>Store</environment><super>Store.StorePublishAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StorePublishDialogInitializing</class-id><body>StorePublishDialogInitializing is announced when the StorePublishDialog subclass instance is initialized</body></comment><class><name>PundleVersionSelector</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleVersions mergeList pundleList mergeTool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MergeToolMods</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PundleVersionSelector</class-id><body>PundleVersionSelector is used by the merge tool to display and select the various pundles to merge.Instance Variables	mergeList	&lt;MultiSelectionInList&gt;	Selected pundles to merge.	mergeTool	&lt;MergeTool&gt;	The merge tool.	pundleList	&lt;SelectionInList&gt;	List of pundles to choose from.	pundleVersions	&lt;MultiSelectionInList&gt;	List of versions of the selected pundle.</body></comment><class><name>ClassCommentTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.ClassCommentTag</class-id><body>ClassCommentTag manages changes to class comment changes </body></comment><class><name>StoreDatabaseTable</name><environment>Store.Glorp</environment><super>Glorp.DatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDatabaseTable</class-id><body>StoreDatabaseTable is used exclusively by Store in order to "store" properties needed by Store, but which are not used by all database engines we support.Instance Variables	properties	&lt;Dictionary&gt;	A properties dictionary</body></comment><class><name>StoreLoggingTool</name><environment>Store</environment><super>Tools.LoggingTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StoreLoggingTool</class-id><body>Store extensions to LoggingTool used to view sql statements that would have been executed. For debugging and building installtation script.</body></comment><class><name>UnloadableDefinitionError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package originalError </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UnloadableDefinitionError</class-id><body>Raised when a db definition cannot be loaded into the image. Common problems covered here are methods and shared extensions with no class; class and namepsace defs with no enfivornment.Instance Variables:	package	&lt;PackageModel&gt;	The package this definition should load into.	originalError	&lt;Error | nil&gt;	The error that caused this to happen</body></comment><class><name>StoreBrowserCodeTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserCodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserCodeTool</class-id><body>StoreBrowserCodeTool is used when browsing Store/Glorp database objects</body></comment><class><name>MiniRepositoryManager</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>intrinsicWidthConstraint intrinsicHeightConstraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.MiniRepositoryManager</class-id><body>MiniRepositoryManager is the application model of the tiny one-line application intended for the launcher's status bar. It displays information about the current Store connection, allows to connect and disconnect, and do basic connection information management.Instance Variables:	intrinsicWidthConstraint	&lt;Constraint&gt;	The intrinsicWidth of the parts in this application	intrinsicHeightConstraint	&lt;Constraint&gt;	The intrinsicHeight of the parts in this application</body></comment><class><name>StoreCodeModel</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractCodeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeModel</class-id><body>I manage the tabbed collection of CodeTools and the status bar for the Store Browser.</body></comment><class><name>SharedVariableListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.SharedVariableListPane</class-id><body>SharedVariableListPane is used to list versions of a StoreSharedVariableInPackage in a DefinitionsForListTool</body></comment><class><name>SharedVariableBlueprintComparisonView</name><environment>Tools</environment><super>Tools.BindingBlueprintComparisonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.SharedVariableBlueprintComparisonView</class-id><body>SharedVariable specific variant for showing shared variable changes.ImplementationMost of my behavior is derived from my super class, I just provide the required queries: bindingTest, defaultIcon, and detail rows for initializer, isConstant, and category. My leftBlueprint and rightBlueprint objects should be nil or SharedVariableBlueprints.One specialization I do, is rather than just show the name of the share in the header, I show the Namspace.ShareName.</body></comment><class><name>StoreBundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundles packages files </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundle</class-id><body>This represents a version of a particular Store Bundle.Instance Variables:	bundles	&lt;Dictionary from: Integer to: StoreBundle&gt;	The sub-bundles we contain, keyed by their position in the ordering of sub-components. That is, if we contain sub-bundle A, sub-package B, and sub-bundle C, then we will hold 1-&gt;A, 3-&gt;C.	files	&lt;(OrderedCollection of: StoreFile)&gt;	The external files associated with this bundle.	packages	&lt;Dictionary from: Integer to: StorePackage&gt;	The sub-bundles we contain, keyed by their position in the ordering of sub-components. In the example above, we would hold 2-&gt;B.</body></comment><class><name>PseudoPackage</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Pundles</category><attributes><package>Store-Component Support</package></attributes></class><comment><class-id>Store.PseudoPackage</class-id><body>PseudoPackage is used in comparing bundlesInstance Variables:	realPackage	&lt;BundleModel | PackageModel | PseudoPackage | Pundle&gt;	the real package being compared</body></comment><class><name>ClassVersionsNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpBrowserUI</category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.ClassVersionsNavigatorPart</class-id><body>This really just distinguishes a type of navigation, in which have a list of class versions of the same class, rather than a bunch of different classes, visible in the browser.</body></comment><class><name>FileOutClassDoesntExistError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.FileOutClassDoesntExistError</class-id><body>FileOutClassDoesntExist is raised when filing out a Class from an XChangeShet and it no longer exists in the image</body></comment><class><name>AtomicCompilationManager</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results root pundle shadowCompiler failedInitializations installedEarly </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AtomicCompilationManager</class-id><body>AtomicCompilationManager is the master manager for all compilation and loading. It calls other managers (or code reader for Parcel) as needed for loading and compiling packages and bundles.Instance Variables	pundle	&lt;Pundle | StorePundle&gt;	The current Pundle that is being loaded	results	&lt;(Collection of: (CodeReader | AtomicCompilationResult | BundleCompilationResult | PackageCompilationResult))&gt;		root	&lt;NameSpace&gt;	The root shadow namespace.	failedInitializations &lt;(Collection of: (Class initializations or something)&gt;	installedEarly	&lt;Boolean&gt; True if because of compiler/scanner reasons, we installed early. False if a fully atomic load is possible</body></comment><class><name>CodeComponentComparison</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftCodeComponents rightCodeComponents removedSharedVariables addedSharedVariables removedNamespaces addedNamespaces removedClasses addedClasses removedMethods addedMethods removedPackageProperties addedPackageProperties addedBundleProperties removedBundleProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.CodeComponentComparison</class-id><body>I exist to compute the changed blueprints evolving from a set of packages (and bundles) inputs to another set.UsageA comparison is created by sending the #leftCodeComponents:rightCodeComponents: method to a newly created instance. The arguments represent only the initial inputs. They may evolve as the computation proceeds.The message #compute is used to actually do the computation between the two sides (see Implementation notes below).After it has been computed, the various added and removed blueprint types can be queried by dictionary keys (see Instance Variables section below).Reduced set versions can be quickly created using the #withoutComponents: conversion message.ImplementationThe basic compare algorithm makes heavy use of the Meyer's Difference algorithm (#differences: method) and the fact that Blueprint objects can be deterministically sorted and compared. The steps of comparison (found mostly, but not entirely in the #compute method) go as follows:	1) Expand all input packages/bundles to include them as well as their sub bundles and sub packages.	2) Sort them deterministically	3) Throw out any exact matches between the two.	4) Sweep all of the packages/bundles on the left side, and fetch their various types of blueprints, sorted deterministically.	5) Same for the right side	6) For each type of blueprint, compute the #differences. Deleted elements are cataloged as "removed" things, and Inserted elements are cataloged as "added" things. The method of category is some kind of Dictionary key to objects, it varies for the different types.	7) Throw out any packages for which no blueprints were logged in either the added or removed set.Instance Variables	addedBundleProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by bundle name	addedClasses			&lt;Dictionary of: ClassBlueprint&gt; keyed by binding reference	addedMethods			&lt;Dictionary of: (Array of: MethodBlueprint)&gt;	keyed by class binding reference	addedNamespaces		&lt;Dictionary of: NamespaceBlueprint&gt;	keyed by binding reference	addedPackageProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by package name	addedSharedVariables	&lt;Dictionary of: SharedVariableBlueprint&gt;	keyed by binding reference	leftCodeComponents		&lt;Array of: (CodeComponent | StorePundle)&gt;	the left side code components, or the "from" source	removedBundleProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by bundle name	removedClasses			&lt;Dictionary of: ClassBlueprint&gt; keyed by binding reference	removedMethods			&lt;Dictionary of: (Array of: MethodBlueprint)&gt;	keyed by class binding reference	removedNamespaces	&lt;Dictionary of: NamespaceBlueprint&gt;	keyed by binding reference	removedPackageProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by package name	removedSharedVariables	&lt;Dictionary of: SharedVariableBlueprint&gt;	keyed by binding reference	rightCodeComponents	&lt;Array of: (CodeComponent | StorePundle)&gt;	the right side code components, or the "to" target</body></comment><class><name>StoreDatabaseIdentifier</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDatabaseIdentifier</class-id><body>This is a very very simple object that holds onto the unique name of the store database. There's only ever one of these, but it's still useful to have it mapped, if only so the object gets cached.Instance Variables:	name	&lt;String&gt;	The identifier name.</body></comment><class><name>PropertyTag</name><environment>Store</environment><super>Store.AbstractComponentTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PropertyTag</class-id><body>PropertyTag is used when managing changes for pundle propertiesInstance Variables	property	&lt;Symbol&gt;	the key for the property being managed by this Tag</body></comment><class><name>ClassSelectorKeyDictionary</name><environment>Store.Glorp</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database Model</package></attributes></class><class><name>PseudoMethodDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoMethodDifference</class-id><body>PseudoMethodDifference is used by the ComparePackages UI to show method object differences</body></comment><class><name>StoreRBInitializerDefinition</name><environment>Store.Glorp</environment><super>Refactory.Browser.RBInitializerDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreRBInitializerDefinition</class-id><body>StoreRBInitializerDefinition is used when browsing Store/Glorp database objects</body></comment><class><name>StoreConnect</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.StoreConnect</class-id><body>StoreConnect is announced when the global Store connection connects to a Repository</body></comment><class><name>SharedNeedsShadowRoot</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Compiling and Loading</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.SharedNeedsShadowRoot</class-id><body>When defining a shared for a class that may have its namespace already in sunshine, we need some way of getting the shadow environment over to the definition mechanism. This is the way</body></comment><class><name>PseudoBundle</name><environment>Store</environment><super>Store.PseudoPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Component Support</package></attributes></class><comment><class-id>Store.PseudoBundle</class-id><body>PseudoBundle is used when comparing bundles</body></comment><class><name>StoreDisconnect</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.StoreDisconnect</class-id><body>StoreDisconnect is announced when the global Store connection disconnects from a Repository</body></comment><class><name>StoreSignatureObject</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signatureObject </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSignatureObject</class-id><body>This class wraps implementors of equalsSignatureIn: so a set can be used for duplicate detection.Instance Variables	signatureObject	&lt;implementor of equalsSignatureIn:&gt;</body></comment><class><name>PublishedPundleVersionsTool</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionForListTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listBlock searchModule cachedPundles titleBlock pundleFilter </inst-vars><class-inst-vars>listPartClass </class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id><body>PublishedPundleVersionsTool is used to display a list of pundles that are published in the database.  When one of these pundles is selected (multi-selection is allowed), the versionClientApp (an instance of VersionBrowser) will display the list of versions for those selected pundles. Instance Variables	listBlock		&lt;BlockContext&gt;	This block will answer the items in the left selection pane.	searchModule	&lt;IncrementalSearchModule&gt;	This is the left pane, which searches and displays the pundle name list	cachedPundles	&lt;(Collection of: (StoreBundle | StorePackage)&gt; This is the current result of sending value to the listBlock.	titleBlock		&lt;BlockContext&gt; This block answers the title for the open window.	pundleFilter	&lt;PundleFilter&gt; This is the filter the current instance is working with.Class Instance Variables	listPartClass	&lt;PundleVersionPane class or a subclass&gt; This determines the type for the right pane</body></comment><class><name>Reading</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Store.Reading</class-id><body>Announced when reading packages from a database.</body></comment><class><name>TextModification</name><environment>Store</environment><super>Store.AbstractModification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.TextModification</class-id><body>TextModification is a kind of modification that is in the image but not anywhere in the database.Instance Variables:	text	&lt;String&gt;	The source code describing the modification</body></comment><class><name>Store74DescriptorSystem</name><environment>Store.Glorp</environment><super>Store.Glorp.Store73DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.Store74DescriptorSystem</class-id><body>This is a system for 7.4-upgraded Store databases, which will include the methodDocs table, although it's not really used yet.</body></comment><class><name>ReplaceModifiedPackageNotice</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.ReplaceModifiedPackageNotice</class-id><body>ReplaceModifiedPackageNotice is raised if a version of a package is being loaded over a version that is modified in the image</body></comment><class><name>StoreCodeComponentInspectPropertiesTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentInspectPropertiesTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentInspectPropertiesTool</class-id><body>StoreCodeComponentInspectPropertiesTool is used when browsing Store/Glorp database objects</body></comment><class><name>RequestUniqueDatabaseIdentifierString</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.RequestUniqueDatabaseIdentifierString</class-id><body>RequestUniqueDatabaseIdentifierString requests a unique name for the databaseIf dealt with in a resume, it will answer 'store_database'If dealt with in a resume: aString it will answer aString</body></comment><class><name>StandardResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.StandardResolution</class-id><body>StandardResolution is the most common kind of resolution holder. This is for standard add or modify resolutions, but not for removal, no-op or user input resolutionsInstance Variables	resolver	&lt;Object&gt;	A definition string or Store object or other object representing a resolution</body></comment><class><name>StoreNewVersionWarning</name><environment>Store</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Component Support</package></attributes></class><comment><class-id>Store.StoreNewVersionWarning</class-id><body>StoreNewVersionWarning is raised if there is a new version of a package already published</body></comment><class><name>AbsentResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applied </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.AbsentResolution</class-id><body>AbsentResolution is used when there is no image or base version of a change, and thus is "absent from the image"Instance Variables	applied	&lt;Boolean&gt;	True when applied</body></comment><class><name>UserInputResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.UserInputResolution</class-id><body>UserInputResolution is a special kind of resolution that represents a user input definition which is based on a known merge resolverInstance Variables	package	&lt;PundleModel | StorePundle&gt;		This is the pundle object where this user input resolution was cloned from.	protocol	&lt;Symbol | nil&gt;	When the user input represents a Method, this is the protocol for the method.	text	&lt;Text | String&gt;	This is the string that represents the user input definition</body></comment><class><name>RequestInstallDatabaseTables</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.RequestInstallDatabaseTables</class-id><body>RequestInstallDatabaseTables is raised if when connecting the database tables don't seem to be installed.It opens a dialog to choose to create or cancelDefault resume/return value is true.</body></comment><class><name>MethodComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftMethod rightMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.MethodComparisonView</class-id><body>I'm a side by side comparison view for two methods.ImplementationThe majority of my display work is done by my SideBySideTextComparisonView. I do set up the header, and provide menu options for the method.Instance Variables	leftMethod	&lt;MethodBlueprint&gt;	method to show on the left side	rightMethod	&lt;MethodBlueprint&gt;	method to show on the right side</body></comment><class><name>StorePublishingError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StorePublishingError</class-id><body>StorePublishingError is raised when a GlorpDatabaseWriteError occurs, and provides a dialog that notifies the user of the problem</body></comment><class><name>Loading</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Loading</class-id><body>This is the outermost announcement during a Load</body></comment><class><name>ClassChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>movePair </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ClassChangeResolver</class-id><body>ClassChangeResolver is a ChangeResolver for Class DefinitionsInstance Variables	movePair	&lt;ClassChangeResovler | nil&gt;	If not nil, this change (an add or remove) has a paired remove or add</body></comment><class><name>SkipPrerequisite</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.SkipPrerequisite</class-id><body>SkipPrerequisite is raised when a prerequisite is skipped</body></comment><class><name>BlessingLevel</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name level type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BlessingLevel</class-id><body>BlessingLevel are the various blessing names and values for blessingsInstance Variables	level	&lt;Integer&gt;	The level number for the blessing	name	&lt;String&gt;		Name of the blessing	type	&lt;ByteSymbol | nil&gt;	The type as used by the ownershop system (#qa, #owner, #admin)</body></comment><class><name>BundlePrivilegeGraph</name><environment>Store</environment><super>Store.PrivilegeGraph</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.BundlePrivilegeGraph</class-id><body>BundlePrivilegeGraph allows the image administrator to grant or revoke ownership to Bundles.</body></comment><class><name>StoreFile</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents filename fileSize decodedFilename </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreFile</class-id><body>Store bundles can be associated with arbitrary external files. This represents the definition of such a file.Instance Variables	contents	&lt;StoreBinaryBlob&gt;	The contents of the file	filename	&lt;ByteArray&gt;	The BOSS Encoding of the filename object representing the path of this object.	fileSize	&lt;Integer&gt;	The size of the file.	decodedFilename &lt;Filename&gt; The unencoded Filename object gotten the first time someone sends #filename</body></comment><class><name>ElementView</name><environment>Store</environment><super>Lens.LDMElementView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.ElementView</class-id><body>ElementView is a specialization for the Store graphs</body></comment><class><name>LoadOrSaveEvaluationError</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveEvaluationError</class-id><body>LoadOrSaveEvaluationError is raised if the action can not be evaluated</body></comment><class><name>StoreLoginFactory</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpVWUI</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreLoginFactory</class-id><body>This is a convenience object for creating Glorp logins for Store databases out of Store's named databae identifiers. It has logic to convert the data into our login, and also knows about Store-specific things that ought to be done for specific databases, either because of the way Store uses schemas there, for performance, or whatever other reasons.</body></comment><class><name>Merging</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Merging</class-id><body>Merging is a generic I'm Doing Something announcement that happens during a merge</body></comment><class><name>ComparePackages</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comparedDifferences comparedPackages rawDifferences classesAndProperties methodsOrProperties selectionType fromProtocol toDefinition fromDefinition toProtocol definitionMenu storeSession </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			private Refactory.Browser.*			private Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.ComparePackages</class-id><body>ComparePackages is a new UI to compare multiple Packages against other versions of each packageInstance Variables	comparedDifferences	&lt;Collection&gt;	description of comparedDifferences	comparedPackages	&lt;SelectionInList&gt;	description of comparedPackages	rawDifferences	&lt;Object | ProtoObject&gt;	description of rawDifferences	classesAndProperties	&lt;SelectionInList&gt;	description of classesAndProperties	methodsOrProperties	&lt;SelectionInList&gt;	description of methodsOrProperties	selectionType	&lt;ValueModel&gt;	description of selectionType</body></comment><class><name>PundleVersionAlreadyExistsError</name><environment>Store</environment><super>Store.StorePublishingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.PundleVersionAlreadyExistsError</class-id><body>PundleVersionAlreadyExistsError is raised if the user attempts to publish a pundle with version string that is the same as one already in the database.</body></comment><class><name>UnloadableDefinitionsViewer</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>viewerListHolder text selectionModule </inst-vars><class-inst-vars>specPreference </class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Unloadables Support</package></attributes></class><comment><class-id>Store.UnloadableDefinitionsViewer</class-id><body>Sometimes when loading a package from the database certain definitions may not be loadable.  This could occur because there might be a missing superclass, or missing namespace or missing class for an extension method or extension shared variable.  This viewer is used to present the list of unloadable definitions.  A user can then file-out the definitions, load the definitions (assuming the user has full-filled those artifacts that are needed to load the definition) or remove the definitions from the package.When creating an instance of this viewer, it is important to use the #definitions:package: method in the initialize-release protocol.  This is because in order to remove or load any of the unloadable definitions the desired instance of PackageModel must be known.  Note, that because of this initialization requirement this viewer can only cope with unloadable definitions that are associated with the same package.Instance Variables	selectionModule	&lt;ListSelectionModule&gt;	A module that holds the list definitions that would not load	text		&lt;ValueHolder on: String|Text&gt;	The definition string for the currently selected definition	viewerListHolder	&lt;SelectionInList on: UnloadableDefinitionsViewer|RecordVersionsViewer&gt;	The two viewers used for the tab controlClass Instance Variables	specPreference &lt;Symbol&gt; The desired window specification to use for viewing.  Currently, there are two choices, which control whether the sequence view is displayed above (#horizontalWindowSpec) or to the left (#verticalWindowSpec) of the text view.  Note, that it is assumed that this class understands the message represented by this variable.	</body></comment><class><name>StoreForGlorpNavigatorState</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractNavigatorState</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id><body>I hold state for the Store Browser.Instance Variables	environment	&lt;StoreForGlorpBrowserEnvironment&gt;	the browser's environment</body></comment><class><name>Renaming</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.Renaming</class-id><body>Renaming is announced when a Package or Bundle is being renamed in a repository</body></comment><class><name>StorePackageInBundle</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>containingBundle expression sequence package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePackageInBundle</class-id><body>StorePackageInBundle describes the relationship between a bundle an any of the packages it containsInstance Variables	containingBundle	&lt;StoreBundle&gt;	The bundle this relationship is pointing to	expression	&lt;String&gt;					Unused	package	&lt;StorePackage&gt;			The package this relationship is pointing to	sequence	&lt;Integer&gt;				Within the bundle, the sequence of this item in the load order</body></comment><class><name>UserCancelledPublish</name><environment>Store</environment><super>Store.StorePublishingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UserCancelledPublish</class-id><body>UserCancelledPublish is raised if the user cancels publishing when asked to enter a new version</body></comment><class><name>ClassSelectorLookupKey</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classKey selectorKey hash </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database Model</package></attributes></class><class><name>StoreBrowserDefinitionTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserDefinitionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id><body>StoreBrowserDefinitionTool is used when browsing Store/Glorp database objects</body></comment><class><name>GroupGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userList groupList </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.GroupGraph</class-id><body>GroupGraph is the UI used to manage User / GroupsInstance Variables	groupList	&lt;SelectionInList&gt;	list of groups	userList	&lt;SelectionInList&gt;	list of users</body></comment><class><name>BindingTextualDetailComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftText rightText name icon </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.BindingTextualDetailComparisonView</class-id><body>I'm a parameterizable side by side comparison view for two text attributes of a BindingBlueprint.ImplementationThe majority of my display work is done by my SideBySideTextComparisonView. I just wrap it with the disclosure button and the header.Instance Variables	icon	&lt;VisualComponent&gt;	the icon to place in the header (meant to correlate with the detailHintGraphics)	leftText	&lt;CharacterArray&gt;	text to show on the left side	name	&lt;CharacterArray&gt;	string label that shows up in the header	reference &lt;BindingReference&gt; identifies the object that the detail belongs to	rightText	&lt;CharacterArray&gt;	text to show on the left side</body></comment><class><name>LoadAnalysisError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadAnalysisError</class-id><body>LoadAnalysisError is raised the LoadAnalyzer determines that a load of a definition can not proceed</body></comment><class><name>PackageListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.PackageListPane</class-id><body>PackageListPane is used to list versions of a StorePackage in a DefinitionsForListTool</body></comment><class><name>NotifyNoMergeChanges</name><environment>Store</environment><super>Store.MergeException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.NotifyNoMergeChanges</class-id><body>NotifyNoMergeChanges is raised during a merge if there are no merge items to be merged</body></comment><class><name>NullPackageCanNotBeSavedError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.NullPackageCanNotBeSavedError</class-id><body>NullPackageCanNotBeSavedError is riased when attempting to save the Null package</body></comment><class><name>ReconcilingComparitor</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleModel storePundle workingChangeSet notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.ReconcilingComparitor</class-id><body>ReconcilingComparitor is used when reconciling a packageModel or bundleModel against a StorePackage or StoreBundle from the a database.It does not produce anything per se, but along the way, it sets the pundleModel objects' change set to reflect the difference between the pundleModel and the StorePundle objects.	Instance Variables	pundleModel		&lt;PundleModel&gt;		Image model that will receive an updated change set	storePundle			&lt;StorePundle&gt;		Database model that is compared to the image	workingChangeSet 	&lt;XChangeSet&gt;		The accumulated changes between the image and database model	notificationQueue	&lt;SharedQueue&gt;		User feedback notifications</body></comment><class><name>StoreSharedVariableProtocolNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SharedVariableProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableProtocolNavigatorPart</class-id><body>StoreSharedVariableProtocolNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>PropertyResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PropertyResolutions</class-id><body>PropertyResolutions holds a collection of PropertyChangeResolvers for a Package or Bundle</body></comment><class><name>RecordVersionsViewer</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionModule text </inst-vars><class-inst-vars>specPreference </class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>Store-UI-Unloadables Support</package></attributes></class><comment><class-id>Store.RecordVersionsViewer</class-id><body>This viewer displays a list of versions for concrete subclasses of DefinedRecord.  When a version is selected, the viewer will display the definition for that record.   A utility method on the class side will open (#openOnVersionsOf:) can be used to open up the viewer when a client has a specific concrete subclass instance of a DefinedRecord that they want to display.  For example:	|record |	record := (ClassRecord allVersionsNamed: 'Root.Core.Object') first.	self openOnVersionsOf: record.Otherwise, the instance side method, #versions:, is used to set the list of versions to display for a DefinedRecord.   For example:	|record viewer |	record := (ClassRecord allVersionsNamed: 'Root.Core.Object') first.	viewer := self new.	viewer open.	viewer versions: record versionsInstance Variables:	selectionModule	&lt;ListSelectionModule&gt;	A module that holds the list of version records	text		&lt;ValueHolder on: String|Text&gt;	The definition string for the currently selected definitionClass Instance Variables:	specPreference &lt;Symbol&gt; The desired window specification to use for viewing.  Currently, there are two choices, which control whether the sequence view is displayed above (#horizontalWindowSpec) or to the left (#verticalWindowSpec) of the text view.  Note, that it is assumed that this class understands the message represented by this variable.	</body></comment><class><name>StoreCodeComponentPropertiesTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentPropertiesTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentPropertiesTool</class-id><body>StoreCodeComponentPropertiesTool is used when browsing Store/Glorp database objects</body></comment><class><name>OwnerOwnershipPolicy</name><environment>Store</environment><super>Store.BasicOwnershipPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.OwnerOwnershipPolicy</class-id><body>OwnerOwnershipPolicy is a basic ownership policy which confirms publish, owner and read rights to packages and bundles for users and groups</body></comment><class><name>ProcessHealthView</name><environment>Store</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>observedProcess lastContext progressIndex isActive timer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.ProcessHealthView</class-id><body>A simple widget which observes a process and gives feedback that the process is proceeding (rather than stuck waiting) as long as the process makes progress.Instance Variables:	isActive	&lt;BlockClosure&gt;	any valuable which is used to query whether we should be currently updating	lastContext	&lt;MethodContext&gt;	on each checkHealth call, we remember the context of the observedProcess, which we can then compare against in the next checkHealth call to make sure the process is not stuck	observedProcess	&lt;Process&gt;	the process we are watching	progressIndex	&lt;Integer&gt;	value between 0 and 23, advanced at each checkHealth point, provided the lastContext is found to have changed	timer	&lt;Timer&gt;	used to generate the periodic ticks where we checkHealth at each point</body></comment><class><name>ReconcileWarning</name><environment>Core</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpVWUI</package></attributes></class><comment><class-id>Core.ReconcileWarning</class-id><body>ReconcileWarning is raised when one is loading a package from a database which had not previously been reconciled to.This is a resumable exception:	["code that loads packages or bundles"]		on: ReconcileWarning		do: [:exception | exception resume: true] "or false"</body></comment><class><name>PseudoClassForSharedDifference</name><environment>Store</environment><super>Store.PseudoClassDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.PseudoClassForSharedDifference</class-id><body>PseudoClassForSharedDifference is used only in merging to create a Difference object that holds a SharedVariable for a Class that by itself does not have any other changes, and thus wouldn't show up in the tree</body></comment><class><name>StoreClassDefinition</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassName </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreClassDefinition</class-id><body>This represents a class definition - that is to say the name, superclass, instance variables, and so forth.Instance Variables:	superclassName	&lt;String&gt;	The long name of the superclass. e.g. Root.Smalltalk.Core.Object.</body></comment><class><name>PseudoNamespaceCommentDifference</name><environment>Store</environment><super>Store.PseudoClassCommentDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceCommentDifference</class-id><body>PseudoNamespaceCommentDifference is used in the ComparePackages UI to show any comment difference between two NameSpaces</body></comment><class><name>NamespaceResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NamespaceResolutions</class-id><body>NamespaceResolutions is a Resolutions that holds changes for namespaces: (NamespaceChangeResolver, NamespaceCommentChangeResolver SharedChangeResolver)</body></comment><class><name>StorePublishDialogOpening</name><environment>Store</environment><super>Store.StorePublishAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StorePublishDialogOpening</class-id><body>StorePublishDialogOpening is announced as part of the postOpenWith:, right after the StorePublishDialog subclass is published</body></comment><class><name>StoreNotConnectedError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StoreNotConnectedError</class-id><body>StoreNotConnectedError is unused. LostConnectionNotification is used instead.</body></comment><class><name>StoreClassDefinitionInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metaclass </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id><body>This is a class definition in a package. Like the other inPackage entities, it corresponds more closely to what we'd call a class definition in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.Instance Variables:	metaclass	&lt;StoreClassDefinition&gt;	The metaclass for our definition.</body></comment><class><name>BundleCompilationResult</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundle results notificationQueue hasRunPostLoad installed </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>BundleCompilationResult</class-id><body>Maintains the results of the bundle components compilations. The component results are kept in the order they are passed in, which should be by their successful compilation order, not the component declared load order. Instance Variables	bundle	&lt;Pundle&gt;	The Bundle being loaded.	results	&lt;(OrderedCollection of: (ShadowedBundleCompilationResult | ShadowedCompilationResult))&gt;			the list of sub-compilation results. 	notificationQueue &lt;SharedQueue&gt;	Used to update any controlling UI	hasRunPostLoad &lt;Booelan&gt; Has this bundle been sent postLoad yet?	installed &lt;Boolean&gt; Has this bundle been installed yet</body></comment><class><name>StorePrePublish</name><environment>Store</environment><super>Store.StorePublishAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specifications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StorePrePublish</class-id><body>StorePrePublish is announced just before a publish occurs its parameters is the dialog doing the publish and the specifications being publishedInstance Variables	specifications	&lt;Object | ProtoObject&gt;	description of specifications</body></comment><class><name>StoreRefactoringBrowser</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractRefactoringBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreRefactoringBrowser</class-id><body>I am a special browser that manages browsing Store/Glorp objects.To isolate the Store Browser from potential RefactoringBrowser extensions, all toolbar and menu items are explicitly implemented in this class, and any menu augmentation will also terminate with this class.</body></comment><class><name>Preloading</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.Preloading</class-id><body>Preloading is called during prerequisite and preload of a pundle</body></comment><class><name>ClassResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classInImage </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ClassResolutions</class-id><body>ClassResolutions holds resolutions for Class objects (MethodChangeResolvers, ClassChangeResolvers, ClassCommentChangeResolvers, SharedChangeResolvers)</body></comment><class><name>PundleSavedChange</name><environment>Store</environment><super>Store.PundleLoadedChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PundleSavedChange</class-id><body>Represents a package or bundle saved event. </body></comment><class><name>BundleStructureTag</name><environment>Store</environment><super>Store.AbstractComponentTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.BundleStructureTag</class-id><body>BundleStructureTag is used by change management for dealing with changes to BundleStructure</body></comment><class><name>StoreBundleSubBundleRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleID subbundleID expressionID sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundleSubBundleRelationship</class-id><body>StoreBundleSubBundleRelationship represents the "TW_Bundles" table and is used by the Garbage CollectorInstance Variables	bundleID		&lt;Integer&gt;	This is the bundleRef column value	expressionID	&lt;Integer&gt;	This is the expressionID column value	sequence		&lt;Integer&gt;	This is the seqNumber column value	subbundleID	&lt;Integer&gt;	This is the subbundleRef column value</body></comment><class><name>NamespaceChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>movePair </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NamespaceChangeResolver</class-id><body>NamespaceChangeResolver is a resolver that represents a NameSpace DefinitionInstance Variables	movePair	&lt;NamespaceChangeResovler | nil&gt;	If not nil, this change (an add or remove) has a paired remove or add</body></comment><class><name>PseudoPropertiesDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoPropertiesDifference</class-id><body>PseudoPropertyDifference  is used by the ComparePackages UI to show package property differences</body></comment><class><name>BundleHasUnpublisedChangesConfirmation</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.BundleHasUnpublisedChangesConfirmation</class-id><body>BundleHasUnpublisedChangesConfirmation is raised when a bundle has unpublished modifications and the system wants to know if it is ok to proceed to publish without database links</body></comment><class><name>BindingTextualDetailSingularView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text icon name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.BindingTextualDetailSingularView</class-id><body>I'm a parameterizable view for a BindingBlueprint detail, for when the attribute is either added or removed (thus singular in display) rather than changed.Instance Variables	icon	&lt;VisualComponent&gt;	the icon to place in the header (meant to correlate with the detailHintGraphics)	text	&lt;CharacterArray&gt;	text that further describes the item (e.g. souce code of a share initializer, or text of a class comment)	name	&lt;CharacterArray&gt;	string label that shows up in the header	reference &lt;BindingReference&gt; identifies the object that the detail belongs to	</body></comment><class><name>VersionNode</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent package children level </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>Store-Merge Mangement</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.VersionNode</class-id><body>VersionNode is used by the ResolutionManager to hold information about the tree for a package versionInstance Variables	children		&lt;(Collection of: VersionNode)&gt;	My Children (if any)	level		&lt;Integer&gt;						My level in the tree	package	&lt;StorePundle | PundleModel&gt;		The package I'm holding	parent		&lt;VersionNode&gt;					My parent (or nil if none)</body></comment><class><name>MergeTool</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolutionManager packageList bundles displayText conflictText textMode show selectedResolution conflictType nameStyle resolutionListTabs currentResolutionsPane autoSelectResolution toolbarMenuHolder compareWithHolder differencesType databaseSession conflictProtocol selectionProtocol stringsNotForCompare </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.MergeTool</class-id><body>MergeTool is the UserInterface that is used in performing mergesInstance Variables	autoSelectResolution	&lt;Boolean&gt;	If true (default) then a resolution is selected for you if the tool can (which you can change)	bundles	&lt;(Collection of: (Bundle))&gt;	Bundles we are working with	compareWithHolder	&lt;ValueModel&gt;	The current selection of the compare with menu	compareWithMenuHolder	&lt;ValueHolder&gt;	The menu of options for the compare with menu	conflictText	&lt;ValueModel&gt;	The text shown in the conflict pane	conflictType	&lt;ByteSymbol&gt;	#conflictsWithBase, #conflictsWithImage, #conflictsWithResolution or #none (Default is #conflictsWithBase)	differencesType	&lt;ByteSymbol&gt;	 #showCodeDifferences or #showSourceDifferences (Default is #showSourceDifferences)	displayText	&lt;ValueModel&gt;	The change	resolutionManager	&lt;ResolutionManager&gt;	An object that holds all the merge data that can be published	selectedResolution	&lt;AbstractResolutions | ChangeResolver&gt;	An object that holds all possible resolutions for the current selected modification	resolutionsPane	&lt;ResolutionsTreePane | ResolutionsListPane&gt;	The embedded UserInterface that displays the tree or list of modifications based on which tab is visible	resolutionListTabs	&lt;SelectionInList&gt;	The selection representing which ResolutionsPane is being displayed	nameStyle	&lt;ByteSymbol&gt;	#showLongNames or  #showShortNames (Default is #showShortNames)	packageList	&lt;MultiSelectionInList&gt;	The current selection of of packages in the current ResolutionsPane	show	&lt;ByteSymbol&gt;	#unresolved, #conflicts or #all (Default is #all)	textMode	&lt;ByteSymbol&gt;	#external or #internal	toolbarMenuHolder	&lt;ValueModel&gt;	The toolbar menu</body></comment><class><name>ShadowOrganizer</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadingDictionary namespaces sharedVariables classes cTypeMethods externalMethods cOtherMethods extensionMethods definedClassMethods classLookupDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><class><name>NoOpResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applied </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NoOpResolution</class-id><body>NoOpResolution is a special resolution choice that represents a "Don't Apply This Resolver" resolutionInstance Variables	applied	&lt;Boolean&gt;	when true, this resolution has been applied (in fact, these kind of resolutions don't do any work)</body></comment><class><name>ReInitializeSharedVariableNotification</name><environment>Store</environment><super>Store.MergeException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ReInitializeSharedVariableNotification</class-id><body>ReInitializeSharedVariableNotification is raised during Merge (and the old compare tool) when a Shared is being changed and the initializer may change.</body></comment><class><name>NoCorrespondingImageItemError</name><environment>Store</environment><super>Store.MergeException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.NoCorrespondingImageItemError</class-id><body>NoCorrespondingImageItemError is raised during the setup phase of the ResolutionManager if it finds that a package or bundle has no corresponding image version.A Merge cannot proceed if this situation is detected</body></comment><class><name>StoreForGlorpNavigator</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreForGlorpNavigator</class-id><body>I manage the classes and methods for the Store Browser.</body></comment><class><name>PublishFileSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Configurations</category><attributes><package>Store-Publishing Support</package></attributes></class><comment><class-id>Store.PublishFileSpecification</class-id><body>PublishFileSpecification is used to create a file to be published with a Bundle as follows:The BundleModel object can simply have a collection of FileModel objects in it's fileDescriptions accessor	| publishFileSpecifications |	publishFileSpecifications := aBundle fileDescriptions collect:		[:fileModel | 		(Store.PublishFileSpecification new)			file: fileModel;			publish: true;			yourself].	bundle fileDescriptions: (publishFileSpecifications collect: [:each | each file]) asList.</body></comment><class><name>StorePundleDisplayRow</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractPundleDisplayRow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.StorePundleDisplayRow</class-id><body>StorePundleDisplayRow is a display wrapper for a StorePundle version loaded. It is used to show the pundle version in the list of pundles in a PundleVersionPane or subclass.Instance Variables:	pundle	&lt;StorePundle&gt;	This is a StorePundle that exists in the database. I display it's version, blessing, source format and publish date in the list of a PundleVersionPane. Under some circumstances, I also display the pundle name. </body></comment><class><name>PackageOwnerElement</name><environment>Store</environment><super>Store.ElementProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.PackageOwnerElement</class-id><body>PackageOwnerElement is used for showing package ownership graphs</body></comment><class><name>StoreVersionlessBundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreVersionlessPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreVersionlessBundle</class-id><body>This represents a particular versionless bundle.</body></comment><class><name>PackageComparisonTool</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.PackageComparisonTool</class-id><body>I am a high level view for creating a package comparison tool, which has a headerBand (PackageComparisonHeaderView), a mainArea (ScrolledComparisonShell) and a button for opening help.I also have services for opening up a window around me, and showing feedback while computing the actual CodeComponentComparison.</body></comment><class><name>StoreLoadRecord</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username pundleName type version timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreLoadRecord</class-id><body>This mirrors the LoadRecord class in Store for 7.5. It is not usedInstance Variables	pundleName	&lt;Object | ProtoObject&gt;		timestamp	&lt;Object | ProtoObject&gt;		type	&lt;Object | ProtoObject&gt;		username	&lt;Object | ProtoObject&gt;		version	&lt;Object | ProtoObject&gt;	</body></comment><class><name>Modification</name><environment>Store</environment><super>Store.AbstractModification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>record originallyInImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MergeToolMods</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.Modification</class-id><body>A record plus a flag for whether it started out in the image or not.Instance Variables:	originallyInImage	&lt;Boolean&gt;	flag of originallyInImage	record	&lt;Method&gt;	description of record</body></comment><class><name>ClassListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.ClassListPane</class-id><body>ClassListPane is used to list versions of a StoreClass in a DefinitionsForListTool</body></comment><class><name>LoadCanceled</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.LoadCanceled</class-id><body>LoadCanceled is raised if a load is canceled. This is possibly raised if a prereq selection is asked of the user and the user says to cancel load.Instance Variables	package	&lt;PundleModel or Pundle&gt;	Package being loaded when the error occured.</body></comment><class><name>PrerequisiteSelector</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PrerequisiteSelector</class-id><body>PrerequisiteSelector this provides a list of packages to satisfy a prerequisiteInstance Variables	selections	&lt;SelectionInList&gt;	Package versions to choose from</body></comment><class><name>ComparisonUsersManual</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.ComparisonUsersManual</class-id><body>I am a view that self populates with information describing how to use the CodeComparisonTool.ImplementationI populate myself by aggregating a series of arbitrary height "row" sub views. Methods that return said sub components have a &lt;paragraph&gt; method tag. They are sorted (and executed) in alphabetical order, thus the leading _#### pattern on most of the methods.I also have methods to open a window around myself.</body></comment><class><name>NoCommonAncestor</name><environment>Store</environment><super>Store.MergeException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.NoCommonAncestor</class-id><body>I am raised when no common ancestor can be computed between a set of pundles to compute merge changes from.</body></comment><class><name>BundleStructureResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.BundleStructureResolver</class-id><body>BundleStructureResolver  is a ChangeResolver for Bundle Structure differences</body></comment><class><name>StoreProgressView</name><environment>Store</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activityStack notifications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StoreProgressView</class-id><body>A simple widget which shows the most current  StoreWorkActivity.ImplementationI am a 3 part widget. One for a 'health' view (a spinner). And two labels, one to show the component being worked on, and the other to show the kind of work. As new notifications are received, they are updated (or rolled back to previous states when finished notifications are received).Instance Variables:	activityStack	&lt;SequenceableCollection of: StoreWorkActivity&gt;	 as started variants of announcements are received, they are added to this stack. When a finished one is received, the stack is cut back to the started compliment of the finished. The 'current' activity being shown is the top of the stack.	notifications	&lt;Announcer&gt;	this is by default set to the StoreWorkActivity notifications, which is the "global" announcer for instances of StoreWorkActivity</body></comment><class><name>ResolutionManager</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trees resolutions versionsToMerge bundles canMerge successfullyCompared currentUndos </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			private Store.*			</imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ResolutionManager</class-id><body>ResolutionManager is the holder of all merge objects for a merge.Instance Variables	versionsToMerge		&lt;Dictionary of (keys = pundleClass-pundleName, values = OrderedCollection of pundleVersions&gt;	resolutions			&lt;Dictionary of (keys = packageNames values = PackageResolutions)&gt; 	trees				&lt;(OrderedCollection of: &lt;Array of: VersionNode&gt; )&gt; Each array contains two elements, the root node and the package node. The version node represents a compressed tree, meaning that versions in a single line between the root and package are eliminated.	bundles				&lt;(OrderedCollection of: StoreBundle)&gt; The merged bundles found during setup, if any[-] SomePackage (1-n) (aPackageResoltuions)	- AClass (0-n) (ClassResolutions)		ADef - comment (0-1)		ADef - class def (0-1)		ADef - method (class or not) (0-n)		ADef - Shared (0-n)	- ANameSpace (0-n) (NamespaceResoltions)		ADef - defintion (0-1)		ADef - Shared (0-n)	- AProperty (0-n) (PropertyResolutions)ClassResolutions	resolutions - ((0-1) ClassChangeResolver, (0-1) ClassCommentChangeResolver, (0-n) SharedChangeResolver, (0-n) MethodChangeResolver).NamespaceResolutions	resolutions ((0-1) NamespaceChangeResolver, (0-n) SharedChangeResolver, (0-n) NamespaceCommentChangeResolver)PropertyResolutions	resolutions ((1-n) PropertyChangeResolver)</body></comment><class><name>NoTrunkToMergeError</name><environment>Store</environment><super>Store.MergeException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.NoTrunkToMergeError</class-id><body>NoTrunkToMergeError is raised during merge if the trunk version is nil</body></comment><class><name>PseudoPropertyDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoPropertyDifference</class-id><body>PseudoPropertyDifference is used by the ComparePackages UI to show a single property difference</body></comment><class><name>StorePundleWriter</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle newPundle previousVersionInTargetDatabase targetSession preWriteAction splitPundles notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePundleWriter</class-id><body>This writes an individual bundle or package version.Instance Variables	pundle							&lt;StorePundle&gt;	The thing we're writing.	newPundle						&lt;StorePundle&gt;	The new pundle we've created, ready to be written to the database.	previousVersionInTargetDatabase	&lt;StorePundle&gt;	The previous version, if there is one.	targetSession 					&lt;GlorpSession&gt;	The target database.	notificationQueue				&lt;SharedQueue | nil&gt;	The shared queue for progress indications	preWriteAction					&lt;Block | nil&gt; An assignable one parameter block that will be executed before the write takes place.	splitPundles						&lt;Boolean&gt;	True if sub-bundles should be written in separate sub-publishes	targetDatabaseIdentifier			&lt;Symbol&gt;	The id of the target database	targetSession					&lt;GlorpSession&gt;	The glorp session which does the transaction writing</body></comment><class><name>InstallingDatabaseTables</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.InstallingDatabaseTables</class-id><body>InstallingDatabaseTables is announced when installing database tables</body></comment><class><name>PropertyChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertyKey </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Refactory.Browser.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PropertyChangeResolver</class-id><body>PropertyChangeResolver is a resolution for Package/Bundle propertiesInstance Variables:	propertyKey	&lt;Symbol&gt;	this is the "AT" part when doing the at put for a property</body></comment><class><name>ContainsUndeclaredError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.ContainsUndeclaredError</class-id><body>ContainsUndeclaredError is raised whe trying to publish a Package which has undeclared items</body></comment><class><name>AtomicCompilationResult</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package shadowedObjects unloadableDefinitions packageDifferences isAtomicallyLoadable overrides notificationQueue overridden installed externalClassesNeedingRecompile methodsMovedFromOriginalBinding needsEarlyInstall </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>AtomicCompilationResult</class-id><body>AtomicCompilationResult tracks a unit of objects (ie. package) that have or have not been successfully compiled into shadowland. Order is maintained so that installation from shadow into the standard enviornment will follow actual load dependancies.Instance Variables	package	&lt;StorePackage&gt;	The store package to which these defintions belong.	shadowedObjects	&lt;OrderedCollection&gt;	successfully compiled objects in shadow	unloadableDefinitions	&lt;OrderedCollection&gt;  definitions which failed compilation	packageDifferences 	&lt;PackageDifferences|nil&gt;  If not nil (not loading a new package), the PackageDifferences instance to consult for loading	isAtomicallyLoadable		&lt;Boolean&gt; False if the compiliation failed atomic compiling	overrides	&lt;OrderedCollection&gt; Overrides that were accumulated during compiling	overridden	&lt;Collection&gt; Overrides that others created	installed &lt;Booelan&gt; Is this result installed	externalClassesNeedingRecompile	&lt;Collection of: ExternalInterface&gt;	These are classes that need to be recompiled after installing	needsEarlyInstall	&lt;Boolean&gt; False (default) if an early install condition is not seen</body></comment><class><name>StoreSharedVariableCodeTool</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreBrowserDefinitionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableCodeTool</class-id><body>StoreSharedVariableCodeTool is used when browsing Store/Glorp database objects</body></comment><class><name>ViewUnloadableDefinitionsNotification</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unloadableDefinitionErrors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.ViewUnloadableDefinitionsNotification</class-id><body>ViewUnloadableDefinitionsNotification is raised when after a load, an unloadable definition error viewer is asked to be opened. If this is not handled, that viewer is opened, otherwise, this object is raisedInstance Variables	unloadableDefinitionErrors	&lt;Collection of: UnloadableDefinitionError&gt;	a collection of UnloadableDefinitionErrors that were raised during the load of a package/bundle</body></comment><class><name>StoreDevelopmentSystem</name><environment>Store</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-Repository Access</package></attributes></class><comment><class-id>Store.StoreDevelopmentSystem</class-id><body>This sets up Store to be able to run in development mode. At the moment, all it does is bring up the reconnect dialog if the image was connected to a Store database when saved.</body></comment><class><name>Analyzing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Analyzing</class-id><body>Analyzing is annouced during analysis phase of the Quark analysis loader</body></comment><class><name>ShadowedNamespaceObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longName ownerName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedNamespaceObject</class-id><body>ShadowedNamespaceObject is a specialization of ShadowedObject for NamesSpacesInstance Variables	longName	&lt;String&gt;	The long name (from Root) of this Namespace	ownerName	&lt;String&gt;	The long name (from Root) of the owning environment</body></comment><class><name>WasConvertedFromParcelWithUndeclaredError</name><environment>Store</environment><super>Store.ContainsUndeclaredError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.WasConvertedFromParcelWithUndeclaredError</class-id><body>WasConvertedFromParcelWithUndeclaredError is raised if an attempt to publish a Package that was converted from a Parcel which has undeclared objects in it</body></comment><class><name>StoreBrowserOverviewTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserOverviewTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserOverviewTool</class-id><body>I show a terse "Overview of the Browser" style message when nothing is selected in the Store Browser.</body></comment><class><name>IndentedListBuilder</name><environment>Store</environment><super>Lens.LDMIndentedListBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.IndentedListBuilder</class-id><body>IndentedListBuilder is used for graphing versions or user/privileges</body></comment><class><name>LoadOrSaveInvalidArgumentsError</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveInvalidArgumentsError</class-id><body>LoadOrSaveInvalidArgumentsError if the action has the wrong number of arguments</body></comment><class><name>StoreMethodDefinition</name><environment>Store.Glorp</environment><super>Tools.MethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreMethodDefinition</class-id><body>StoreMethodDefinition is used when browsing Store/Glorp objects</body></comment><class><name>NameSpaceListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.NameSpaceListPane</class-id><body>NameSpaceListPane is used to list versions of a StoreNameSpace in a DefinitionsForListTool</body></comment><class><name>SinglePropertyView</name><environment>Tools</environment><super>Tools.AbstractPropertyComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property isAddition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.SinglePropertyView</class-id><body>I show a single package property, either removed or added (but not changed).Instance Variables	isAddition	&lt;Boolean&gt;	used to determine the header icon	property	&lt;CodeComponentPropertyBlueprint&gt;	property we're displaying</body></comment><class><name>DeletionToolFilter</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleName versionLike beforeDate afterDate blessingGreater blessingLess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.DeletionToolFilter</class-id><body>DeletionToolFilter is used by the DeletionToolFilterTool to edit a filter for use in the MarkPundlesForDeletionToolInstance Variables	afterDate		&lt;Date | nil&gt;		filter the versions to only items after this date	beforeDate		&lt;Date | nil&gt;		filter the versions to only items before this date	blessingGreater	&lt;Integer | nil&gt;	filter the versions to only items with blessing level greater than this	blessingLess	&lt;Integer | nil&gt;	filter the versions to only items with blessing level less than this	pundleName		&lt;String | nil&gt;		filter the package and names to only names matching this	versionLike		&lt;String | nil&gt;		filter the versions to only items with version names like this</body></comment><class><name>ShadowedSharedVariableObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longName ownerName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedSharedVariableObject</class-id><body>ShadowedSharedVariableObject is a specialization of ShadowedObject for SharedVariablesInstance Variables	longName	&lt;String&gt;	The long name (from Root) of this SharedVariable	ownerName	&lt;String&gt;	The long name (from Root) of the owning Namespace or Class</body></comment><class><name>PackageComparitor</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainPackage otherPackage mainPackageMethods otherPackageMethods mainPackageShareds otherPackageShareds mainPackageNamespaces otherPackageNamespaces mainPackageClasses otherPackageClasses mainPackageProperties otherPackageProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PackageComparitor</class-id><body>PackageComparitor is used by the loading mechanism to compare a loaded version of a pundle against an about to load version, to determine which definition objects (methods, classes, shareds, namespaces) to add, remove or change during the requested load.  It is also used to compare two unloaded versions.Instance Variables	mainPackage	&lt;PackageModel | PseudoPackage | StorePackage&gt;	description of mainPackage	mainPackageClasses	&lt;(Collection of: (StoreClass | StoreClassInPackage))&gt;	description of mainPackageClasses	mainPackageMethods	&lt;(Collection of: (StoreMethod | StoreMethodInPackage))&gt;	description of mainPackageMethods	mainPackageNamespaces	&lt;(Collection of: (StoreNamespace | StorNamespaceInPackage&gt;	description of mainPackageNamespaces	mainPackageShareds	&lt;(Collection of: (StoreShared | StoreSharedInPackage))&gt;	description of mainPackageShareds	mainPackageProperties	&lt;(Collection of: Association)&gt;	otherPackage	&lt;PackageModel | PseudoPackage | StorePackage&gt;	description of otherPackage	otherPackageClasses	&lt;(Collection of: (StoreClass | StoreClassInPackage))&gt;	description of otherPackageClasses	otherPackageMethods	&lt;((Collection of: (StoreMethod | StoreMethodInPackage))) | ExpressionGroup | MappingExpression | ReadStream&gt;	description of otherPackageMethods	otherPackageNamespaces	&lt;(Collection of: (StoreNamespace | StorNamespaceInPackage))&gt;	description of otherPackageNamespaces	otherPackageShareds	&lt;(Collection of: (StoreShared | StoreSharedInPackage))&gt;	description of otherPackageShareds	otherPackageProperties	&lt;(Collection of: Association)&gt;</body></comment><class><name>StorePundleEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.PundleEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StorePundleEnvironment</class-id><body>StorePundleEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>Installing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Installing</class-id><body>This is announced when Installing during a Load</body></comment><class><name>PundleVersionTooltipAssistant</name><environment>Store.Glorp</environment><super>UI.SequenceHoverAssistant</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.PundleVersionTooltipAssistant</class-id><body>PundleVersionTooltipAssistant extends SequenceHoverAssistant to use the list item origin as opposed to the current mouse point to anchor the hover text display for its list items, which are NOT Label or LabelAndIcon objects.</body></comment><class><name>PreReadActionConfirmation</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.PreReadActionConfirmation</class-id><body>PreReadActionConfirmation is raised if the pre read action can not be executed</body></comment><class><name>StoreClassEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreClassEnvironment</class-id><body>StoreClassEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>DeletionToolFilterTool</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingGreaterThanCheck afterDateCheck pundleName afterDate beforeDate blessingLessThan versionLikeCheck blessingLessThanCheck nameLikeCheck blessingGreaterThan beforeDateCheck versionLike filter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.DeletionToolFilterTool</class-id><body>DeletionToolFilterTool is a tool which creates a DeletionToolFilter object that is usable by the MarkPundlesForDeletionToolInstance Variables:	afterDate	&lt;ValueModel on Date&gt;	aDate entered for filtering the pundle version list(s)	afterDateCheck	&lt;ValueModel on Boolean&gt;	if true, then the afterDate value will be enabled and applied	beforeDate	&lt;ValueModel on Date&gt;	aDate entered for filtering the pundle version list(s)	beforeDateCheck	&lt;ValueModel on Boolean&gt;	if true the beforeData value will be enabled and applied	blessingGreaterThan	&lt;ValueModel on Integer&gt;	a blessing level for being equal or greater than to filter the pundle version list(s)	blessingGreaterThanCheck	&lt;ValueModel on Boolean&gt;	if true the blessing greater than level is enabled and applied	blessingLessThan	&lt;ValueModel on Integer&gt;	a blessing level for being equal or less than to filter the pundle version list(s)	blessingLessThanCheck	&lt;ValueModel on Boolean&gt;	if true the blessing less than level is enabled and applied	filter	&lt;DeletionToolFilter&gt;	The current DeletionToolFilter object being edited	nameLikeCheck	&lt;ValueModel on Boolean&gt;	if true the pundle name string is enabled and applied	pundleName	&lt;ValueModel on String&gt;	the pundle name match string to filter the pundle name list(s)	versionLike	&lt;ValueModel on String&gt;	the verion name match string to filter the pundle version list(s)	versionLikeCheck	&lt;ValueModel on Boolean&gt;	if true the version name match string is enabled and applied</body></comment><class><name>ClassTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.ClassTag</class-id><body>ClassTag manages changes to class definitions</body></comment><class><name>ResolutionsTreePane</name><environment>Store</environment><super>Store.ResolutionsPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root oldTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionsTreePane</class-id><body>ResolutionsTreePane is used to display the the merge tool modification sets in a tree.Instance Variables:	oldTree	&lt;Object&gt;	When switching trees, this is used to hold the old tree for a moment.	root	&lt;ResolutionManager&gt;	This is the base resolution manager</body></comment><class><name>ShadowedClassObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longName superclassName isExternalInterface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedClassObject</class-id><body>ShadowedClassObject is a specialization of ShadowedObject for ClasssesInstance Variables	longName	&lt;String&gt;	The long name (from Root) of the class	superclassName	&lt;String&gt;	The name of the superclass for this class	isExternalInterface &lt;Boolean|nil&gt;	Indicates whether this instance represents a subclass of ExternalInterface</body></comment><class><name>StoreBundlePackageRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleID packageID expressionID sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundlePackageRelationship</class-id><body>StoreBundlePackageRelationship represents the "TW_Packages" table and is used by the Garbage CollectorInstance Variables	bundleID	&lt;Integer&gt;	This is the bundleRef column value	expressionID	&lt;Integer&gt;	This is the expressionID column value	packageID	&lt;Integer&gt;	This is the packageRef column value	sequence	&lt;Integer&gt;	This is the seqNumber column value</body></comment><class><name>PseudoSharedDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoSharedDifference</class-id><body>PseudoSharedDifference is used by the ComparePackages UI to show shared variable object differences</body></comment><class><name>StorePackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods classDefinitions nameSpaces sharedVariables parcel binFile </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePackage</class-id><body>This represents a Store package, with its associated components.Instance Variables	binFile	&lt;String&gt;	As far as I can tell, an empty string if this is published binary, and otherwise null	classDefinitions	&lt;(OrderedCollection of: StoreClassDefinition)&gt; The basic class definitions	methods	&lt;(Collection of: (StoreMethod))&gt; All the methods associated with this package.	nameSpaces	&lt;(Collection of: (StoreNameSpace))&gt;	The namespace definitions.	parcel	&lt;StoreBlob&gt;	The parcel, if any	sharedVariables	&lt;(Collection of: (StoreSharedVariable))&gt;	The shared variable definitions</body></comment><class><name>PundleVersionPane</name><environment>Store.Glorp</environment><super>Store.Glorp.PackageListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listFilterBlock imageVersions publishedFormatDescriptions versionSearchList currentList </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.PundleVersionPane</class-id><body>PundleVersionPane is used for the new PublishedPundleVersionsTool.It is in effect the right hand panes in that toolInstance Variables	listFilterBlock	&lt;One Argument Block|nil&gt;	This block, if set, will filter the list in the top right pane. The block is used in a select: statement, 									and each item is a StorePundle.	imageVersions	&lt;Dictionary of pundleName-&gt;PundleModel&gt;  Represents the versions of selected pundles loaded in the image. Newer versions 												than the ones in this Dictionary are displayed in the list in bold.	versionSearchList &lt;IncrementalSearchModule&gt; This is the model for my text field above the results list.	</body></comment><class><name>ScrolledComparisonShell</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comparisonSource expansionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.ScrolledComparisonShell</class-id><body>I am the top level view for managing a set of "Rollup" comparison views.ImplementationI use my comparisonSource (currently a CodeComponentComparison) to build a set of views for the various class, namespace, sharedvariable, and component property differences. See the 'view construction' and 'initialize' category for this.I also make sure that mouse wheel events are not handled by sub editors, but instead cause me to scroll.Perhaps the most involved thing I do, is to remember the various expansion states of my children and their children. When the comparisonSource it is necessary to throw out all the children and rebuild. But if the comparison is like the previous one (possibly a subset of it), then we want the expansions to be similiar. So I build up a dictionary indicating indirectly which children are expanded, with nested dictionaries for their children. AbstractComparisonRollupView provides the service of filling in, or restoring from these dictionaries.Instance Variables	comparisonSource	&lt;CodeComponentComparison&gt;	description of comparisonSource	expansionMemory	&lt;Dictionary&gt;	description of expansionMemory</body></comment><class><name>MergeIcons</name><environment>Store</environment><super>AlphaBlendedIcons</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.MergeIcons</class-id><body>This is a collection of icons used by the merge tool</body></comment><class><name>InitializerFailedError</name><environment>Store</environment><super>Store.LoadingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.InitializerFailedError</class-id><body>InitializerFailedError is used when an initializer fails, to tell the package to not mark itself clean at the end of loading</body></comment><class><name>PropertyComparisonView</name><environment>Tools</environment><super>Tools.AbstractPropertyComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftProperty rightProperty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.PropertyComparisonView</class-id><body>I show a side by side comparison of two package properties.ImplementationThe majority of my display work is done by my SideBySideTextComparisonView. I just wrap it with the disclosure button and the header.Instance Variables	leftProperty	&lt;CodeComponentPropertyBlueprint&gt;	property to show on the left side	rightProperty	&lt;CodeComponentPropertyBlueprint&gt;	property to show on the right side</body></comment><class><name>ShadowedMethodObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className extension ctype selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedMethodObject</class-id><body>ShadowedMethodObject is a specialization of ShadowedObject for MethodsInstance Variables	className	&lt;String&gt;	The long name for the class owning this method	ctype	&lt;Boolean&gt;	True if the object is a CTYPE method	extension	&lt;Boolean&gt;	True if the object is an extension in the owning package	selector	&lt;Symbol&gt;	The, well, selector, ok?</body></comment><class><name>StoreCodeComponentInspectorField</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentInspectorField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentInspectorField</class-id><body>StoreCodeComponentInspectorField is used when browsing Store/Glorp database objects</body></comment><class><name>PseudoNamespaceDefinitionDifference</name><environment>Store</environment><super>Store.PseudoClassDefinitionDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceDefinitionDifference</class-id><body>PseudoNamespaceDefinitionDifference is used in the ComparePackages UI to show any definition difference between two NameSpaces</body></comment><shared-variable><name>DebugStoreII</name><environment>Store.Glorp.StoreObject</environment><private>false</private><constant>false</constant><category>settings-store</category><initializer>false</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>WarnIfNewerVersionPublished</name><environment>Store.Glorp.StoreObject</environment><private>false</private><constant>false</constant><category>settings-store</category><initializer>false</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>PrerequisiteRecursion</name><environment>Store.Glorp.StorePundle</environment><private>false</private><constant>false</constant><category>prerequisites</category><initializer>nil</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>ComponentNotFoundSignal</name><environment>Store.Glorp.StorePundle</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>Announcements</name><environment>Store.StorePublishDialog</environment><private>false</private><constant>false</constant><category>announcements</category><initializer>Announcer new</initializer><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>EmptyInArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>FullOutArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>EmptyOutArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>FullInArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>LoadingFromStore</name><environment>Store.DBAccess</environment><private>false</private><constant>false</constant><category>system</category><initializer>false</initializer><attributes><package>Store-Repository Access</package></attributes></shared-variable><shared-variable><name>ShouldWriteLoadRecords</name><environment>Store.DBAccess</environment><private>false</private><constant>false</constant><category>system</category><initializer>false</initializer><attributes><package>Store-Repository Access</package></attributes></shared-variable><shared-variable><name>UseAtomicLoader</name><environment>Store.DBAccess</environment><private>false</private><constant>false</constant><category>system</category><initializer>true</initializer><attributes><package>Store-Repository Access</package></attributes></shared-variable><shared-variable><name>UseAnalysisLoader</name><environment>Store.DBAccess</environment><private>false</private><constant>false</constant><category>system</category><initializer>true</initializer><attributes><package>Store-Repository Access</package></attributes></shared-variable><shared-variable><name>UseChangeSetsForCompare</name><environment>Store.PundleModel</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>true</initializer><attributes><package>Store-Component Support</package></attributes></shared-variable><shared-variable><name>UseNewCompareTool</name><environment>Store.ComparePackages</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>true</initializer><attributes><package>Store-Difference Management</package></attributes></shared-variable><shared-variable><name>DbRegistry</name><environment>Store</environment><private>false</private><constant>false</constant><category>Store-Base</category><attributes><package>Store-Base</package></attributes></shared-variable><shared-variable><name>ReconnectAction</name><environment>Store.StoreDevelopmentSystem</environment><private>false</private><constant>false</constant><category>control</category><initializer>#prompt</initializer><attributes><package>Store-Repository Access</package></attributes></shared-variable><shared-variable><name>MoveOutIcon</name><environment>Store.Glorp.ChangeResolver</environment><private>false</private><constant>false</constant><category>MoveOutIcon</category><initializer>MergeIcons move copy image: (MergeIcons move image copy reflectedInX)</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>LoadFailedOption</name><environment>Store.AbstractPundleLoader</environment><private>false</private><constant>false</constant><category>Load Fail</category><initializer>UI.ValueHolder with: #loadButNotify</initializer><attributes><package>Atomic Compiling and Loading</package></attributes></shared-variable><shared-variable><name>Announcements</name><environment>Glorp.GlorpError</environment><private>false</private><constant>false</constant><category>announcements</category><initializer>Announcer new</initializer><attributes><package>Store-Base</package></attributes></shared-variable><shared-variable><name>CannotUnloadComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-Component Support</package></attributes></shared-variable><shared-variable><name>CannotStoreComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-Component Support</package></attributes></shared-variable><shared-variable><name>CannotLoadComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-Component Support</package></attributes></shared-variable><shared-variable><name>Repositories</name><environment>Store.RepositoryManager</environment><private>false</private><constant>false</constant><category>repository profiles</category><initializer>List new</initializer><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>AlwaysOpenMergeTool</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>false</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>ShowToolbar</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>true</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>NameStyle</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>#showShortNames</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>DowngradeBlessingOnMerge</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>false</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>InformativeBlessingsOnly</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>false</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>AutoSelectResolution</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>true</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>ConflictsReference</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>#conflictsWithImage</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>WarnBeforeAbandoningUnpublished</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>true</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>DifferencesType</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>#showCodeDifferences</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>NewRepositoryDescriptorSystemClass</name><environment>Store.Glorp.StoreDescriptorSystem</environment><private>false</private><constant>false</constant><category>configuring</category><initializer>nil</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>UseRecursionIfSupported</name><environment>Store.Glorp.StoreDescriptorSystem</environment><private>false</private><constant>false</constant><category>configuring</category><initializer>true</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>UserPreferences</name><environment>Store.StoreSettings</environment><private>false</private><constant>false</constant><category>Settings</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>IsMonocrome</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ModifiedPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ModifiedNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ModifiedBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DefaultNotifications</name><environment>Store.StoreWorkActivity</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Store-Base</package></attributes></shared-variable><methods><class-id>Store.PundleInstall</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">cleanUpOverrides	pundleModel ifNotNil: [pundleModel cleanUpOverrides]</body><body package="Atomic Compiling and Loading">completedAnalysis	^completedAnalysis</body><body package="Atomic Compiling and Loading">hasRunPrerequisites	^hasRunPrerequisites</body><body package="Atomic Compiling and Loading">hasRunPrerequisites: aBoolean		hasRunPrerequisites := aBoolean</body><body package="Atomic Compiling and Loading">installed	^installed</body><body package="Atomic Compiling and Loading">installed: aBoolean	installed := aBoolean</body><body package="Atomic Compiling and Loading">owningComponent	^parentInstallObject ifNotNil: [:value | value pundle]</body><body package="Atomic Compiling and Loading">parentInstallObject	^parentInstallObject</body><body package="Atomic Compiling and Loading">parentInstallObject: aPundleInstall		parentInstallObject := aPundleInstall</body><body package="Atomic Compiling and Loading">pundle	^pundle</body><body package="Atomic Compiling and Loading">pundle: aStoreBundleOrPackage	pundle := aStoreBundleOrPackage</body><body package="Atomic Compiling and Loading">pundleModel	^pundleModel</body><body package="Atomic Compiling and Loading">pundleModel: aPundleModel	pundleModel := aPundleModel</body><body package="Atomic Compiling and Loading">smartMarkInstalled		completedAnalysis ifTrue: [self installed: true]</body><body package="Atomic Compiling and Loading">topComponent	parentInstallObject ifNil: [^self].	^parentInstallObject topComponent</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>installation</category><body package="Atomic Compiling and Loading">runPostLoadUsing: anAtomicAnalysisLoader	self subclassResponsibility</body><body package="Atomic Compiling and Loading">runPreLoad	self subclassResponsibility</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isBundle	^false</body><body package="Atomic Compiling and Loading">isPackage	^false</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize	super initialize.	installed := false.	hasRunPostload := hasRunPrerequisites := completedAnalysis := hasRunPreload := false</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	super printOn: aStream.	aStream nextPut: ${.	aStream nextPutAll: pundle name.	aStream nextPutAll: '} '</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>analysis</category><body package="Atomic Compiling and Loading">analyzeUsing: anAtomicAnalysisLoader	self subclassResponsibility</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>private</category><body package="Atomic Compiling and Loading">visit: aBlock	aBlock value: self</body></methods><methods><class-id>Store.PundleInstall class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new	^super new initialize</body><body package="Atomic Compiling and Loading">pundle: aStoreBundleOrPackage	| instance |	instance := self new.	instance pundle: aStoreBundleOrPackage.	^instance</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>installation</category><body package="Atomic Compiling and Loading">gatherDefinitionsToRemoveInto: aDictionary	contents do: [:each | each gatherDefinitionsToRemoveInto: aDictionary].</body><body package="Atomic Compiling and Loading">installPackageNamespaces	contents do: #installPackageNamespaces</body><body package="Atomic Compiling and Loading">runPostLoadUsing: anAtomicAnalysisLoader	contents do: [:each | each runPostLoadUsing: anAtomicAnalysisLoader].	(installed not and: [hasRunPostload not and: [contents allSatisfy: #completedAnalysis]]) ifTrue: 		[pundleModel ifNil: [pundleModel := pundle createImagePundle].		pundle postLoad: pundleModel.		anAtomicAnalysisLoader hasUnloadableDefinitions			ifFalse: [pundleModel markNotModified].		hasRunPostload := true].</body><body package="Atomic Compiling and Loading">runPreLoad	hasRunPreload ifFalse: 		[(contents anySatisfy: #hasSomethingAnalyzed) ifTrue:			[pundle runPreLoad.			pundleModel := [pundle createImagePundle]				on: MessageNotUnderstood				do: [:exception | exception return: pundle storeModel].			hasRunPreload := true]].	contents do: [:each | each runPreLoad ifFalse: [^false]].	^true</body><body package="Atomic Compiling and Loading">updateForPackageRecompile	contents do: [:each | each updateForPackageRecompile].</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">pundle: aStoreBundle	super pundle: aStoreBundle.	aStoreBundle componentsInOrderDo: 		[:each |		| installObject |		each runPreRead ifTrue:			[installObject := contents add: each asAtomicInstallObject.			installObject parentInstallObject: self]]</body><body package="Atomic Compiling and Loading">smartMarkInstalled		completedAnalysis ifTrue: [self installed: true].	contents do: [:each | each installed not ifTrue: [each smartMarkInstalled]]</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>private</category><body package="Atomic Compiling and Loading">visit: aBlock	super visit: aBlock.	contents do: [:each | each visit: aBlock]</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize	super initialize.	contents := OrderedCollection new</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>testing</category><body package="Atomic Compiling and Loading">hasSomethingAnalyzed	^contents anySatisfy: #hasSomethingAnalyzed</body><body package="Atomic Compiling and Loading">isBundle	^true</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>analysis</category><body package="Atomic Compiling and Loading">analyzeUsing: anAtomicAnalysisLoader	(Analyzing for: pundle) started.	anAtomicAnalysisLoader lastPundleWorkedOn: pundle.	contents do: [:each | each analyzeUsing: anAtomicAnalysisLoader].	completedAnalysis := true.	(Analyzing for: pundle) finished.	(pundle propertyAt: #installBeforeContinuing ifAbsent: [self]) == self ifFalse: 		[EarlyInstallNotice raiseSignal].</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>interface opening</category><body package="Store-UI">postOpenWith: aBuilder 	| canvas |	canvas := builder componentAt: #notebook.	canvas isNil ifTrue: [^self].	canvas widget		client: self		spec: #activeAreaSpec		builder: builder.	builder window keyboardProcessor keyboardHook: [:ev :ctrlr | self disturb. ev].	self updatePreferences.</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>private</category><body package="Store-UI">disturb	disturbed value: true.	^true</body><body package="Store-UI">enableButtons	| button |	(button := subBuilder namedComponents at: #resetButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]].	(button := subBuilder namedComponents at: #acceptButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]]</body><body package="Store-UI">helpAction	| sh |	sh := SimpleHelp helpString: self helpString.	sh class  openOn: sh</body><body package="Store-UI">helpString	^self perform: (self class tabSpecsAndHelpSelectors at: list selectionIndex) last.</body><body package="Store-UI">masterList	^self class masterList.</body><body package="Store-UI">rebuild	| canvas next |	canvas := builder componentAt: #activeComponents.	next := (self class tabSpecsAndHelpSelectors at: list selectionIndex) first.	canvas widget		client: self		spec: next		builder: (subBuilder := self builder newSubBuilder)</body><body package="Store-UI">requestSliceChange	| win |	builder notNil ifTrue: [win := builder window].	self disturbed		ifTrue:			[(Dialog					confirm: (#alteredNotAccepted &lt;&lt; #dialogs &gt;&gt; 'Settings have been altered but not accepted.Do you wish to discard the changes?')					for: win)				ifTrue: [self resetForSlice. ^true]				ifFalse: [^false]]		ifFalse: [^true]</body><body package="Store-UI">resetForSlice	(subBuilder componentAt: #resetButton) widget model value: true.	self undisturb</body><body package="Store-UI">setFocus	"Set the keyboard input focus to be the first text input widget on the focus chain."	builder keyboardProcessor keyboardConsumers do: 			[:aWidget |			(aWidget isKindOf: ComposedTextView)				ifTrue: 					[builder keyboardProcessor focusedView: aWidget.					(aWidget isKindOf: TextEditorView)						ifTrue: [aWidget controller selectEntireText].					^aWidget invalidate]]</body><body package="Store-UI">undisturb	disturbed value: false</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>top level</category><body package="Store-UI">preferenceMasterList	^list</body><body package="Store-UI">updatePreferences	"Update the subcanvas for the currently selected preference item. Answer the receiver."	self rebuild.	self setFocus</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>events</category><body package="Store-UI">requestForWindowClose	^self requestSliceChange</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>accessing</category><body package="Store-UI">disturbed	^disturbed value</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	Announcements announce: (StorePublishDialogInitializing for: self).	list := SelectionInList new.	list list: self masterList.	list selectionIndexHolder value: 1.	list selectionIndexHolder onChangeSend: #updatePreferences to: self.	(disturbed := false asValue) onChangeSend: #enableButtons to: self</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>constants</category><body package="Store-UI">windowLabel	"Answer a string for the window label."	self subclassResponsibility</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	^self windowNotebookSpec</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>accessing</category><body package="Store-UI">developmentTabLabels	^developmentTabLabels</body><body package="Store-UI">masterList	^DeploymentOptionsSystem isDevelopment 		ifTrue: [self developmentTabLabels]		ifFalse: [self runtimeTabLabels]</body><body package="Store-UI">runtimeTabLabels	^runtimeTabLabels</body><body package="Store-UI">tabSpecsAndHelpSelectors	^tabSpecsAndHelpSelectors</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>class initialization</category><body package="Store-UI">initialize	Announcements ifNil: [#{Store.StorePublishDialog.Announcements} initialize]</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private-visual blocks</category><body package="Store-UI">computeLabelsForView: aView	"Compute all the labels right away so that we know 	what offsets to use. Store the labels so that extra 	database accesses are not needed to recompute them."	| max1 max2 max3 |	max1 := max2 := max3 := 0.	labelDict := Dictionary new: self currentItems list size.	self currentItems list do: 			[:anItem |			| publishFlag pndl label1 label2 label3 label4 level levelOffset |			publishFlag := anItem publish.			label1 := LabelAndIcon with: ''.			publishFlag ifTrue: [label1 beCheckMark].			levelOffset := 10.			level := levelOffset * anItem level.			pndl := anItem pundle.			label2 := pndl elementLabel: #().			label2 text: pndl name asText.			label2 attributes: aView textStyle.			label3 := Label						with: (publishFlag ifTrue: [anItem version] ifFalse: [anItem parentVersion]).			label3				attributes: aView textStyle;				alignVerticalCenter.			label4 := Label with: (publishFlag								ifTrue: [Policies blessingPolicy blessingName: anItem blessing]								ifFalse: ['']).			label4				attributes: aView textStyle;				alignVerticalCenter.			labelDict at: anItem				put: (Array						with: label1						with: (Array with: label2 with: level)						with: label3						with: label4).			max1 := label1 width max: max1.			max2 := label2 width + level max: max2.			max3 := label3 width max: max3].	offsets := Array				with: 6				with: max1 + 16				with: max2 + max1 + 26				with: max3 + max2 + max1 + 56</body><body package="Store-UI">labelForItem: anItem view: aView	| cp labels |	cp := CompositePart new.	(labelDict == nil or: [(labelDict at: anItem ifAbsent: nil) == nil])		ifTrue: [self computeLabelsForView: aView].	labels := labelDict at: anItem.	cp		add: (labels at: 1)		at: (offsets at: 1) @ 0.	cp		add: (labels at: 2) first		at: ((offsets at: 2) + (labels at: 2) last) @ 0.	cp		add: (labels at: 3)		at: (offsets at: 3) @ 0.	^cp</body><body package="Store-UI">listVisualBlock	""	^	[:view :index | 	| arr label | 	arr := view sequence at: index.	label := self labelForItem: arr view: view.	BoundedWrapper on: label]</body><body package="Store-UI">selectedListVisualBlock	""	^	[:view :index | 	| arr label rw|	arr := view sequence at: index.	label := self labelForItem: arr view: view.	rw := ReversingWrapper on: label.	rw reverse setValue: true.	BoundedWrapper on: rw]</body><body package="Store-UI">setVisualBlocks	| itemList |	(itemList := self subComponentAt: #itemsList)		ifNotNil: 			[itemList widget visualBlock: self listVisualBlock.			itemList widget tooltip: nil.			itemList widget selectedVisualBlock: self selectedListVisualBlock].	(itemList := self subComponentAt: #fileList)		ifNotNil: 			[itemList widget visualBlock: self listVisualBlock.			itemList widget tooltip: nil.			itemList widget selectedVisualBlock: self selectedListVisualBlock]</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>actions</category><body package="Store-UI">accept	"Publish a pundle.  	It's possible there have been changes to the bundle since we opened the dialog, 	so tell the user to retry and close the UI without publishing, because otherwise the 	pundles will/can get nil blessing levels and versions."	self validateParcelOptions ifFalse: [^self].	self validateFileOptions ifFalse: [^self].	self validatePublishStateIsConsistent ifFalse: [^self].	(self specList		allSatisfy: [:each | each publish not or: [self canPublish: each]])			ifFalse: [^self].	self newGlobalState.	self fillEmptyComments.	self updateFiles.	Announcements announce: (StorePrePublish for: self specifications: self specList).	StoreProgressOverlay subsume: builder window		while: 			[self specList publishPundle.			callBackBlock ifNotNil: [callBackBlock value: items list]].	Announcements announce: (StorePostPublish for: self specifications: self specList).	self updatePackageListsAndClose</body><body package="Store-UI">addFile	| dialog result fileSpec |	dialog := OpenFileDialog new.	dialog 		windowTitle: 'Select File Attachment For Bundle';		acceptButtonLabel: 'Add File';		addFilterForAllFiles;		fileCondition: #any.	result := dialog open		ifTrue: [dialog selection]		ifFalse: [nil].	result ifNil: [^nil].	fileSpec := (Store.PublishFileSpecification new)			file: (FileModel from: result);			publish: true;			yourself.	self fileList add: fileSpec</body><body package="Store-UI">allBlessings	"Use current blessinglevel/comment for all items."		self forAllItemsDo:		[:each | 		each blessing: self blessingLevel value.		each comment: self blessingComment value].	labelDict := nil.	self newSelection</body><body package="Store-UI">allVersions	"Mark all items for publishing."	self versionString value isEmpty		ifFalse: [ self setAllVersionsTo: versionString value ].	self newSelection</body><body package="Store-UI">canPublish: aPublishSpecification	| objectionString |	objectionString := Policies publishPolicy objectionsToPublishing: aPublishSpecification.	^objectionString isNil or:		[Dialog warn: objectionString.		false]</body><body package="Store-UI">cancel	"Disconnect us from the database, so if our background operations are still in progress they will error out."	self closeAndUnschedule</body><body package="Store-UI">copyFromPackage	self parcelVersionString value: (self versionString value).	(subBuilder componentAt: #VersionString) ifNotNil: [:value | value widget controller accept]</body><body package="Store-UI">publishAllNo	self forAllItemsDo: 		[ :ar | ar publish: ar modified  ].	labelDict := nil.	self newSelection</body><body package="Store-UI">publishAllYes	self forAllItemsDo: 		[ :ar | 		( ar modified )			ifFalse: [ ar publish: true ]		].	labelDict := nil.	self newSelection</body><body package="Store-UI">removeFile	| selectedFile |	selectedFile := self files selection.	self files list remove: selectedFile ifAbsent: [self halt]</body><body package="Store-UI">updateFiles	| targetPundleModel fileDescriptions |	targetPundleModel := self specList first dbPundle.	fileDescriptions := targetPundleModel fileDescriptions.	self fileList do:		[:each |		each publish ifTrue:			[(fileDescriptions contains: [:eachFile | eachFile portableFilename asString = each name])				ifTrue:					[targetPundleModel removeFile: each name.					targetPundleModel addFile: each name]				ifFalse: [targetPundleModel addFile: each name]]].	fileDescriptions := targetPundleModel fileDescriptions copy.	fileDescriptions do:		[:each |		(self fileList anySatisfy: [:eachFile | eachFile name = each portableFilename asString]) ifFalse:			[targetPundleModel removeFile: each portableFilename asString]]</body><body package="Store-UI">updatePackageListsAndClose	#{Refactory.Browser.BrowserNavigator}		ifDefinedDo: [:navigatorClass | navigatorClass updatePackageListsInOpenWindows].	self closeAndUnschedule</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>aspects</category><body package="Store-UI">binarySave		binarySave ifNil: 		[binarySave := false asValue.		binarySave onChangeSend: #binarySaveChanged to: self].	^binarySave</body><body package="Store-UI">binarySaveChanged	"If the globalOptions (the bundle) is the selection item, then all items get the same value.	However, if the current item is NOT the global (bundle) AND the global (bundle) says no to binary, then this one can be either or"	self items selection = self globalOptions		ifFalse: 			[self globalOptions binarySave value ifFalse: 				[self items selection binarySave: binarySave value]]		ifTrue: [self items list do: [:each | each binarySave: self binarySave value]].</body><body package="Store-UI">blessingComment	blessingComment == nil		ifTrue: [ blessingComment := String new asValue ].	^blessingComment</body><body package="Store-UI">blessingLevel	blessingLevel == nil		ifTrue:			[blessingLevel := self initialBlessingLevel asValue.			blessingLevel onChangeSend: #blessingLevelChanged to: self].	^blessingLevel</body><body package="Store-UI">bundleStructure	bundleStructure ifNil: [bundleStructure := true asValue].	^bundleStructure</body><body package="Store-UI">bundleStructureChanged	"Enable the database links depending on whether the structure will be saved."	self enableComponentAt: #databaseLinks enable: self parcelSave value.	self databaseLinks value: (self databaseLinks value).</body><body package="Store-UI">databaseLinks	databaseLinks == nil		ifTrue: [ databaseLinks := false asValue ].	^databaseLinks</body><body package="Store-UI">files	files == nil		ifTrue: [ files := SelectionInList new list: PublishSpecificationList new ].	^files</body><body package="Store-UI">globalOptions	^self items list first.</body><body package="Store-UI">items	^items ifNil: [items := SelectionInList new].</body><body package="Store-UI">parcelBackup	parcelBackup == nil		ifTrue: [ parcelBackup := false asValue ].	^parcelBackup</body><body package="Store-UI">parcelDetails	^#( parcelDirectory 		parcelOverwrite 		parcelRepublish		parcelSaveSource 		parcelBackup		VersionString		CopyFromPackage		), self parcelSaveSourceDetails</body><body package="Store-UI">parcelDirectory		parcelDirectory ifNil: 		[parcelDirectory := (self pundle storeModel ifNotNil: [:value | value parcelDirectory]) isNil			ifTrue: [(PundleAccess parcelDirectory asFilename construct: self pundle parcelName) asString asValue]			ifFalse: [self pundle storeModel parcelDirectory asString asValue]].	^parcelDirectory</body><body package="Store-UI">parcelHideSource	parcelHideSource == nil		ifTrue: [ parcelHideSource := false asValue ].	^parcelHideSource</body><body package="Store-UI">parcelOverwrite	parcelOverwrite == nil		ifTrue: [ parcelOverwrite := false asValue ].	^parcelOverwrite</body><body package="Store-UI">parcelPadded	parcelPadded == nil		ifTrue: [ parcelPadded := false asValue ].	^parcelPadded</body><body package="Store-UI">parcelRepublish	parcelRepublish == nil		ifTrue: [ parcelRepublish := false asValue ].	^parcelRepublish</body><body package="Store-UI">parcelSave	parcelSave == nil		ifTrue: [ parcelSave := false asValue ].	^parcelSave</body><body package="Store-UI">parcelSaveChanged	"Enable the parcel directory depending on whether parcel will be published."	| shouldSave |	shouldSave := self parcelSave value.	self parcelDetails do: [:each | self enableComponentAt: each enable: shouldSave].	self bundleStructureChanged.	self parcelSaveSourceChanged</body><body package="Store-UI">parcelSaveSource	parcelSaveSource == nil		ifTrue: [ parcelSaveSource := true asValue ].	^parcelSaveSource</body><body package="Store-UI">parcelSaveSourceChanged	"Enable/disable the subcheck boxes depending on sources."	| save |	save := self parcelSaveSource value &amp;  ( self parcelSave value ).	self parcelSaveSourceDetails do:		[ :sym | self enableComponentAt: sym enable: save ].	self parcelRepublish value: ( self parcelRepublish value &amp; save ).	self enableComponentAt: #parcelRepublish enable: save.</body><body package="Store-UI">parcelSaveSourceDetails	^#( parcelHideSource 		parcelPadded 		)</body><body package="Store-UI">parcelVersionString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelVersionString isNil		ifTrue:			[parcelVersionString := String new asValue]		ifFalse:			[parcelVersionString]</body><body package="Store-UI">parcelWarningMessage	parcelWarningMessage == nil		ifTrue: [ parcelWarningMessage := self validateParcelSaveString ].	^parcelWarningMessage</body><body package="Store-UI">publish	publish == nil		ifTrue: 			[ 			publish := false asValue.			self disableDetails.			].	^publish</body><body package="Store-UI">publishFile	publishFile == nil		ifTrue: [ publishFile := false asValue ].	^publishFile</body><body package="Store-UI">versionString	versionString == nil		ifTrue: [ versionString := String new asValue ].	^versionString</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private</category><body package="Store-UI">blessingLevelChanged	self specList do: [:each | each blessing: self blessingLevel value]</body><body package="Store-UI">connectionLabel		^self class connectionLabel</body><body package="Store-UI">detailHolders	^OrderedCollection		with: self publish		with: self blessingComment		with: self versionString</body><body package="Store-UI">details	"Answer a list of ids for individual pundle settings."	^#( blessingLevelButton blessingComment vStringLabel 		bCommentLabel versionStringBox )</body><body package="Store-UI">disableDetails	| comp |	self details do: 		[ :sym | 		( comp := self subComponentAt: sym ) == nil 			ifFalse: [ comp disable ]		]</body><body package="Store-UI">disablePublishBox	self enableComponentAt: #publishSelectedCheck enable: false.</body><body package="Store-UI">enableDetails	self currentItems selection notNil		ifTrue: 			[ ( self currentItems selection modified )				ifTrue: [ self disablePublishBox ]				ifFalse: [ self enablePublishBox ].			self publish value 				ifTrue: 					[ self details do: 						[:sym | self enableComponentAt: sym enable: true ] 					]			]</body><body package="Store-UI">enablePublishBox	self enableComponentAt: #publishSelectedCheck enable: true.</body><body package="Store-UI">forAllItemsDo: aBlock	| alist |	alist := self currentItems list.	1 to: alist size do: 		[ :i | | ar |		ar := alist at: i.		aBlock value: ar.		alist at: i put: ar		]</body><body package="Store-UI">glorpSession	session ifNil: [session := StoreLoginFactory currentStoreSession].	^session</body><body package="Store-UI">glorpSession: aSession	session := aSession</body><body package="Store-UI">newDetailState	| sel duplicates |	sel := self currentItems selection.	duplicates := self currentItems list		select: [:each | each pundle == sel pundle].	duplicates		do:			[:each | 			| index sub |			each publish: self publish value.			each comment: self blessingComment value.			each version: self versionString value.			index := self currentItems list indexOf: each.			(sub := self subComponentAt: #itemsList) == nil				ifFalse: [sub widget updateAt: index].			(sub := self subComponentAt: #fileList) == nil				ifFalse: [sub widget updateAt: index]].	labelDict := nil</body><body package="Store-UI">newGlobalState	"Update the global (belonging to the outer bundle) state.	Note: We don't update binarySave since that is now package by package"	^self globalOptions		parcelSave: self parcelSave value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelPadded: self parcelPadded value;		parcelVersionString: self parcelVersionString value;		yourself.</body><body package="Store-UI">newItemSelection	self newSelection.	self items selection ifNil: [^self].	self binarySave setValue: (self items list at: self items selectionIndex) binarySave.	self builder window component invalidate</body><body package="Store-UI">newPublishState	"Publish selected. If an pundle is marked for publish, mark containing bundles as well."	self publish value		ifFalse: [ ^self ].	self publishState: self currentItems selection pundle.</body><body package="Store-UI">newSelection		self currentItems selection isNil		ifFalse:			[self setDetailState.			self enableDetails]		ifTrue:			[self disableDetails.			self disablePublishBox]</body><body package="Store-UI">publishState: aPundle	"aPundle has been marked for publication. Mark all bundles containing it as well, except those in the DB (not in image)"	self forAllItemsDo: 		[:each |		| pundle |		pundle := each pundle.		(pundle isLoaded and: [pundle isImageObject]) ifFalse: [^self].			((pundle := each pundle) isBundle and: [pundle containsItem: aPundle])			ifTrue: 				[each publish: self publish value.				self publishState: pundle]]</body><body package="Store-UI">retractDetailInterest	self publish retractInterestsFor: self.	self detailHolders do: 		[ :dh | dh retractInterestsFor: self ].</body><body package="Store-UI">setAllVersionsTo: aString	self forAllItemsDo: [ :ar | ar version: aString ].	labelDict := nil.</body><body package="Store-UI">setDetailInterest	self publish onChangeSend: #newPublishState to: self.	self detailHolders do: [:dh| dh onChangeSend: #newDetailState to: self].</body><body package="Store-UI">setDetailState	| sel |	sel := self currentItems selection.	self retractDetailInterest.	self publish value: sel publish.	self blessingComment value: sel comment.	self versionString value: sel version.	self setDetailInterest</body><body package="Store-UI">setDetailState: selection	self retractDetailInterest.	self publish value: selection publish.	self blessingComment value: selection comment.	self versionString value: selection version.	self setDetailInterest</body><body package="Store-UI">specificationClass	^self class specificationClass</body><body package="Store-UI">trapForEsc: anEvent	"If the event is an escape then 'press' the cancel button"		^anEvent keyValue = Character esc		ifTrue:			[(self widgetAt: #cancelButton) model value: true.			nil]		ifFalse: [anEvent]</body><body package="Store-UI">updateFilePreferences	| indx |	indx := self files selectionIndex.	( self subComponentAt: #filesList ) widget updateAt: indx</body><body package="Store-UI">updateItemList	( self subComponentAt: #itemsList ) widget updateModel.	labelDict := nil.</body><body package="Store-UI">updateSelectedItem	| indx |	indx := self currentItems selectionIndex.	( self subComponentAt: #itemsList ) widget updateAt: indx</body><body package="Store-UI">userNameLabel		^self class userNameLabel</body><body package="Store-UI">validateFileOptions	| msg1 msg2 |	msg1 := #File1sDoesNotExist &lt;&lt; #store &gt;&gt; 'File: &lt;1s&gt; does not exist.'.	msg2 :=  #File1snDoesNotExistInDB &lt;&lt; #store &gt;&gt; 'File: &lt;1s&gt;&lt;n&gt; does not exist in the database and is not being published.'.	self fileList do:		[ :fspec | 		fspec publish 			ifTrue: 				[ ( fspec file portableFilename exists )					ifFalse: 						[ Dialog warn: ( msg1 expandMacrosWith: fspec file name ).					^false 					]				] 			ifFalse: 				[ ( fspec file dbTrace isNil )					ifTrue: 						[ Dialog warn:  ( msg2  expandMacrosWith: fspec file name ).						^false						]				].		].	^true</body><body package="Store-UI">validateParcelOptions		| filename |	self parcelSave value ifFalse: [^true].	((filename := self basePath , Parcel fileExtension) asFilename exists and: [self parcelOverwrite value not])		ifTrue:			[(Dialog confirm: (#_n1sExistsnnOverwriteFiles &lt;&lt; #store &gt;&gt; '&lt;n&gt;&lt;1s&gt; exists: &lt;n&gt;&lt;n&gt;Overwrite files?&lt;n&gt;' expandMacrosWith: filename))				ifTrue: [self parcelOverwrite value: true]				ifFalse: [^false]].	self pundle parcelDirectory: filename.	^true</body><body package="Store-UI">validatePublishStateIsConsistent	"We look at all the specs and validate that ALL pass #isConsistentForPublishing	The result is to make sure that no package has been changed behind the back of this dialog.	If it has, we disable the 'Publish' button as a way of saying 'You Can Go No Further!'"	(self items list isConsistentForPublishing)		ifTrue: [^true].	Dialog warn: (#AtLeastOneBuckageHasBeenModifiednRetry &lt;&lt; #store &gt;&gt; 'At least one Package or Bundle has been modified since the Publish Dialog was opened.&lt;n&gt;Please cancel this publish, and retry') expandMacros.	(self builder componentAt: #publishButton) isEnabled: false.	^false</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>interface opening</category><body package="Store-UI">buildInSubCanvas: spec withBuilder: aBuilder 	"Reimplement to ensure that visualBlocks are set up on the subcanvas if was installed."	super buildInSubCanvas: spec withBuilder: aBuilder.	"subBuilder will not be nil if we are building a page on the notebook."	subBuilder isNil ifFalse: 		[self setVisualBlocks].	^aBuilder</body><body package="Store-UI">localPostOpenWith: aBuilder	[(Gathering for: (pundleModel ifNil: [self pundle])) started.	self mainWindow label: ''.	(pundleModel notNil and: [pundleModel isBundle]) ifTrue: 		[self items list: (self class publishSpecsFrom: pundleModel in: self glorpSession).		self files list: (self class publishFileSpecsFrom: pundleModel)].	(pundleModel notNil and: [pundleModel isPackage]) ifTrue:		[pundleModel mergeInformation ifNotNil: 			[:value |			self blessingLevel value: value blessingLevel.			self blessingComment value: value blessingComment]].	self mainWindow label: self windowLabel.	self items selectionIndexHolder onChangeSend: #newItemSelection to: self.	self files selectionIndexHolder onChangeSend: #newSelection to: self.	Announcements announce: (StorePublishDialogOpening for: self).	self setVisualBlocks.	self items selectionIndex: 1.	self copyFromPackage.	self parcelSaveChanged.	self setGlobalEnablement.	(Gathering for: (pundleModel ifNil: [self pundle])) finished] withStoreFeedbackOn: self mainWindow</body><body package="Store-UI">localRebuild		self setVisualBlocks.	self setGlobalEnablement.	self parcelSaveChanged.	self newSelection</body><body package="Store-UI">openOnPundleModel: aPundleModel	pundleModel := aPundleModel.	labelDict := nil.	self open</body><body package="Store-UI">openWith: userData	self items list: userData.	labelDict := nil.	self open</body><body package="Store-UI">openWith: userData ifSuccessfulDo: aOneArgumentBlock	callBackBlock := aOneArgumentBlock.	self openWith: userData.</body><body package="Store-UI">openWith: userData with: fileData	( ( fileData notEmpty ) &amp; ( DbRegistry isDb73Enabled not ) )		ifTrue: [ Dialog warn: 'Your database does not support external files.&lt;n&gt;Publishing will cause your image to forget attatched external files.' expandMacros ].	self items list: userData.	self files list: fileData.	labelDict := nil.	self open</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	aBuilder keyboardProcessor keyboardHook: [:event :controller | self trapForEsc: event]</body><body package="Store-UI">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	super postOpenWith: aBuilder.	self localPostOpenWith: aBuilder.</body><body package="Store-UI">preBuildWith: aBuilder 	"This message is sent by the builder prior to beginning construction 	of either a SubCanvas or a complete window."	aBuilder 		aspectAt: #blessingLevelMenu 		put: Policies blessingPolicy blessingLevelsMenu.</body><body package="Store-UI">rebuild		super rebuild.	self localRebuild.</body><body package="Store-UI">requestSliceChange	^true</body><body package="Store-UI">resetForSlice</body><body package="Store-UI">setGlobalEnablement	self enableComponentAt: #parcelSave enable: true.	self enableComponentAt: #binarySave enable: true.</body><body package="Store-UI">windowLabel		^#PublishingPackageOrBundleC2S &lt;&lt; #labels &gt;&gt; 'Publishing &lt;1?Package:Bundle&gt; &lt;2s&gt; on: &lt;3s&gt; for: &lt;4s&gt;'		expandMacrosWith: self pundle isPackage		with: self pundle name		with: self connectionLabel		with: self userNameLabel</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>subcomponents</category><body package="Store-UI">enableComponentAt: aSymbol enable: aBoolean	| comp |	( comp := subBuilder componentAt: aSymbol ) == nil		ifFalse: [ comp isEnabled: aBoolean ]</body><body package="Store-UI">subComponentAt: aSymbol	^subBuilder componentAt: aSymbol</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private-publishing</category><body package="Store-UI">fillEmptyComments	"Look at the spec list and determine any publish spec which have empty comments where there is also a spec for the containing bundle 	that does have comment. When found, copy said bundle comment down."	self specList fillEmptyCommentsFromParent</body><body package="Store-UI">validateParcelSaveString	"This used to check for uninstalled and overridden methods.  Which are now safe to save. We now answer	 no warning string. We leave this here to support some future change where a warning might be needed." 	^String new</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>binding</category><body package="Store-UI">labelFor: aKey 	"Return an instance of a non-abstract subclass of CharacterArray, 	that will be used as a label for a component."	^[ self perform: aKey ] on: MessageNotUnderstood do:		[ : e | e return: aKey ].</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>help</category><body package="Store-UI">fileHelp^#fileHelp &lt;&lt; #store &gt;&gt;'Select Publish All to publish all of the files listed.Select Publish None to reset the default, which does not publish any files.Publish and Do not Publish allow you to change the setting to the currently selected file.'</body><body package="Store-UI">mainHelp^'The Blessing Level and Blessing Comment can be set individually for each component. It will apply to the selected item. Set Current Blessing Level and Comment for All, sets the same level and comment for all published items.Publish Binary - saves the packages in the database in parcel formal. This is good for faster initial loading and for cases where the individual packages may not compile cleanly. If this option is diabled, it means that the parcel is invalid. See the Parcel Options tab for details.'</body><body package="Store-UI">parcelHelp	^self class parcelHelp</body><body package="Store-UI">publishHelp^'All modified components will be published. Select Publish All to publish all unmodified components.Select Publish Only Modified to reset the default, which does not publish any unmodified components.Publish and Do not Publish allow you to change the setting to the currently selected unmodfied component.'</body><body package="Store-UI">versionHelp^'Change the version string for the selected component, or Set the Global Version for all the components.'</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>accessing</category><body package="Store-UI">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: ( self parcelDirectory value ) ) asString</body><body package="Store-UI">callBackBlock: aOneArgumentBlock	"Having an accessor saves us from adding this to every class side open... method.  Normally, this would be called either before the dialog was opened, e.g.	self new callBackBlock: [:publishSpecOrSpecList | ... ]; openWith: userData.or immediately after some open... method, before the quickest-fingered user could hit accept."	callBackBlock := aOneArgumentBlock.</body><body package="Store-UI">currentItems	^self isPaneForFiles		ifTrue: [ self files ]		ifFalse: [ self items ].</body><body package="Store-UI">fileList	^self files list</body><body package="Store-UI">initialBlessingLevel	| candidates |	candidates := ((self specList select: [:each | each modified])		collect: [:each | each blessing]) asSet.	candidates size = 1 ifTrue: [^candidates any].	candidates size &gt; 1 ifTrue: [^nil].	"now try again with all specs, modified or not"	candidates := (self specList collect: [:each | each blessing]) asSet.	candidates size = 1 ifTrue: [^candidates any].	candidates size &gt; 1 ifTrue: [^nil].	^Policies blessingPolicy defaultBlessing</body><body package="Store-UI">pundle	^items list first pundle</body><body package="Store-UI">specList	^items list</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	retry := false.</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>testing</category><body package="Store-UI">fileIsSelected	^files selection notNil</body><body package="Store-UI">isPaneForFiles	^( subBuilder componentAt: #fileList ) ~~ nil</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>private</category><body package="Store-UI">connectionLabel		| connectionName profile |	profile := DbRegistry connectedProfile.	connectionName :=  profile name.	(connectionName notNil and: [connectionName notEmpty]) ifTrue: [^connectionName].	connectionName :=  profile environment.	(connectionName notNil and: [connectionName notEmpty]) ifTrue: [^connectionName].	^(#aRepository &lt;&lt; #labels &gt;&gt; 'a Repository') asString</body><body package="Store-UI">publishFileSpecsFrom: imageOrDatabaseBundle  	^PublishSpecificationList filesFromBundle: imageOrDatabaseBundle</body><body package="Store-UI">publishSpecsFrom: aBundleModel  	"For incredibly bizarre reasons to do with the #component message, 	we need to go through this and make sure the objects are the pundleModels"	| publishSpecs |	publishSpecs := PublishSpecificationList fromBundle: aBundleModel.	publishSpecs do: 		[:each |		(each dbPundle isNil and: [each description notNil]) ifTrue: 			[(Gathering for: each pundle) started.			each pundle: each description component.			(Gathering for: each pundle) finished]].	^publishSpecs.</body><body package="Store-UI">publishSpecsFrom: aBundleModel in: aSession	"For incredibly bizarre reasons to do with the #component message, 	we need to go through this and make sure the objects are the pundleModels"	| publishSpecs |	publishSpecs := PublishSpecificationList fromBundle: aBundleModel in: aSession.	publishSpecs do: 		[:each |		(each dbPundle isNil and: [each description notNil]) ifTrue: 			[(Gathering for: each pundle) started.			each pundle: each description component in: aSession.			(Gathering for: each pundle) finished]].	^publishSpecs.</body><body package="Store-UI">publishSpecsFromPackages: aCollectionOfPundleModel comments: aCollectionOfComments defaultBlessing: anInteger	^PublishSpecificationList fromPundles: aCollectionOfPundleModel comments: aCollectionOfComments defaultBlessing: anInteger</body><body package="Store-UI">specificationClass	^PublishSpecification</body><body package="Store-UI">userData: anUserData forPundle: aPundle 	"Set the common items in the user data."	| mod vString pvString |	 mod := aPundle hasBeenModified or: [ aPundle hasTrace not ].	pvString := aPundle parentVersionString.	vString := pvString isEmpty			ifTrue: [ Policies versionPolicy initialVersionForPundle: aPundle ]			ifFalse: [ Policies versionPolicy nextVersion: pvString forPundle: aPundle ].	anUserData 		at: #publish put: mod;		at: #pundle put: aPundle;		at: #comment put: '';		at: #parentVersion put: pvString;		at: #version put: vString;		at: #level put: 0;		at: #modified put: mod;		at: #description put: nil;		at: #blessing put: Policies blessingPolicy defaultBlessing.</body><body package="Store-UI">userDataFrom: anImageBundle  	| dict coll |	dict := Dictionary new.	self userData: dict forPundle: anImageBundle.	dict 		at: #publish put: true;		at: #modified put: true;		at: #binarySave put: false;		at: #parcelSave put: false;		at: #bundleStructure put: true;		at: #databaseLinks put: false;		at: #parcelDirectory put: '';		at: #parcelRepublish put: false;		at: #parcelBackup put: false;		at: #parcelOverwrite put: false;		at: #parcelSaveSource put: true;		at: #parcelHideSource put: false;		at: #parcelPadded put: true.	coll := List with: dict.	anImageBundle descriptionsAndLevels do: 		[ :pair | 	| pndl descr |		descr := pair at: 1.		pndl := descr component.		dict := Dictionary new.		self userData: dict forPundle: pndl.		dict at: #description put: descr.		dict at: #level put: ( pair at: 2 ).		coll add: dict		].	^coll</body><body package="Store-UI">userNameLabel	^DbRegistry connectedProfile userName</body><body package="Store-UI">validateForPublishing: aCollection 	(self validateSourcesIn: aCollection) ifFalse: [^false].	aCollection do: 		[:each | 		each canBePublishedToCurrentDatabase ifFalse: 			[| message |			message := #x1sIsNotLinkedProceedByReconciling &lt;&lt; #store 						&gt;&gt; '&lt;1s&gt; is not linked to an existing version with the same name in the current database.&lt;n&gt; Proceed by reconciling?' 							expandMacrosWith: each name.			(Dialog confirm: message) 				ifFalse: [^false] 				ifTrue: [each reconcileWithDb ifNil: [^false]]]].	^true</body><body package="Store-UI">validateForPublishing: aCollection in: aSession	(self validateSourcesIn: aCollection) ifFalse: [^false].	aCollection do: 		[:each | 		(each canBePublishedToCurrentDatabaseIn: aSession) ifFalse: 			[| message |			message := #x1sIsNotLinkedProceedByReconciling &lt;&lt; #store 						&gt;&gt; '&lt;1s&gt; is not linked to an existing version with the same name in the current database.&lt;n&gt; Proceed by reconciling?' 							expandMacrosWith: each name.			(Dialog confirm: message) 				ifFalse: [^false] 				ifTrue: [(each reconcileWithDbIn: aSession) ifNil: [^false]]]].	^true</body><body package="Store-UI">validateLoadOrder: imageBundle	| errorString |	(imageBundle propertyAt: #isLoadOrderWarningSuppressed) == true		ifTrue: [^true].	errorString := imageBundle validateLoadOrder.	^errorString isEmpty		ifTrue: [true]		ifFalse: 			[Dialog				choose: (#InvalidBundleLoadOrder &lt;&lt; #store &gt;&gt; 'Bundle load order is invalid.')				labels: (Array with: (#PublishAnyway &lt;&lt; #store &gt;&gt; 'Publish Anyway') with: (#Cancel &lt;&lt; #store &gt;&gt; 'Cancel'))				values: (Array with: true with: false)				default: #false]</body><body package="Store-UI">validateSourcesIn: aCollection	"Validate that we're not publishing decompiled code from the image.  If a pundle is not loaded in the image then decompiled source isn't relevant (we're republishing or doing other in-database operations).  Otherwise, search for invalid source:  if none is found, proceed;  on the first case found, ask the user and abort or proceed as they say (with aborting the default, as usually one does not intend to publish decompiled)."	aCollection do:		[:eachPundle |		eachPundle getImagePundle ~~ eachPundle ifFalse:			[eachPundle anyInvalidModifiedSource ifNotNil:				[:invalidMethod |				^(Dialog confirm:					(#xCode1sIn2sAboutToPublishDecompiled &lt;&lt; #store &gt;&gt;						'Some code, including&lt;nt&gt;&lt;1s&gt;&lt;n&gt;in&lt;nt&gt;&lt;2s&gt;&lt;n&gt;is about to publish as decompiled (missing sources).&lt;n&gt;Abort publish?'						expandMacrosWith: invalidMethod printString with: eachPundle printString)) not]]].	^true</body><body package="Store-UI">windowLabel	^(#PublishingBundleOnly &lt;&lt; #labels &gt;&gt; 'Publish Bundle on: &lt;1s&gt; for: &lt;2s&gt;')		expandMacrosWith: self connectionLabel		with: self userNameLabel</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>class initialization</category><body package="Store-UI">initialize	"self initialize "	| complexList |	complexList := 		OrderedCollection new			add: 'Blessing' -&gt; #(#mainSpec #mainHelp);			add: 'Version Names' -&gt; #(#versionSpec #versionHelp);			add: 'Items to Publish' -&gt; #(#publishSpec #publishHelp);			add: 'Parcel Options' -&gt; #(#parcelSpec #parcelHelp);			add: 'File Options'-&gt;#(#filesSpec #fileHelp);			asArray.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new: 1.</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>interface opening</category><body package="Store-UI">publishBundle: aBundleModel	"Present a dialog and let user set parameters for the new published bundle and its contents.  Return the dialog, or nil if we did not open one.	Just in case some tool hooks into new, we call that here"		| instance session |	session := StoreLoginFactory currentStoreSession.	(self validateForPublishing: aBundleModel withContainedItems in: session) ifFalse: [^nil].	(self validateLoadOrder: aBundleModel) ifFalse: [^nil].	instance := self new.	instance glorpSession: session.	instance openOnPundleModel: aBundleModel.	^instance</body><body package="Store-UI">publishPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: anInteger ifSuccessfulDo: aOneArgumentBlock 	"Open a publish dialog on aCollectionOfPackages. If everything is okay, exececute a block 	with the list of user data for each package. " 	| publishSpecificationList |	publishSpecificationList := self		publishSpecsFromPackages: aCollectionOfPackages		comments: aCollectionOfComments		defaultBlessing: anInteger.	self new openWith: publishSpecificationList ifSuccessfulDo: aOneArgumentBlock.	^publishSpecificationList</body><body package="Store-UI">publishPundle: aPundle	^self publishBundle: aPundle.</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>help</category><body package="Store-UI">parcelHelp	^'The parcel will be saved in the Parcel Path + .pcl, the sources in Parcel Path +.pst.Include Bundle Structure if you would like the bundle to be recreated when loading the parcel into a Store image.  Saving Database Links will hook the components to a particular database. This saves the loader from needing to reconcile source before publishing a new version to the same database.Save source file will create the parcel sources (.pst) file.Hide sources on load will not effect the current image, but will supress sources when it is loaded into a another image. This is for deployment parcels and should not be used during development.Select republish to save with sources to a parcel that is currently loaded to the same file name.  Republishing does not hide sources. Republishing will invalidate other images that point to the original file.'</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>accessing</category><body package="Store-UI">masterList	"For the VisualWorks tools use case we only want to use the development lables.	 In other words, we do not encourage deployment of our tools."	^self developmentTabLabels</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>aspects</category><body package="Store-UI">binarySaveChanged	"No Selections in a package publish"</body><body package="Store-UI">blessingLevel	blessingLevel == nil		ifTrue: [ blessingLevel := Policies blessingPolicy defaultBlessing asValue ].	^blessingLevel</body><body package="Store-UI">versionString		versionString ifNil: 		[versionString := (Policies versionPolicy 			nextVersion: (package traceVersionIn: self glorpSession) 			forPundle: package 			in: self glorpSession) asValue].	^versionString</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>accessing</category><body package="Store-UI">package	^package</body><body package="Store-UI">package: aPackage	package := aPackage.	pundleModel := aPackage.</body><body package="Store-UI">pundle	^package</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>private</category><body package="Store-UI">newGlobalState		"Update the global (belonging to the outer bundle) state."	^self specificationClass new		binarySave: self binarySave value;		parcelSave: self parcelSave value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelPadded: self parcelPadded value;		parcelVersionString: self parcelVersionString value;		yourself.</body><body package="Store-UI">newItemSelection	"No Selections in a package publish"</body><body package="Store-UI">newSelection	"No Selections in a package publish"</body><body package="Store-UI">publishSpecificationFrom: aPackageModel	"Create a PublishSpecifcation from the passed in package model"	| publishSpecification |	publishSpecification := self specificationClass pundle: aPackageModel.	publishSpecification		binarySave: self binarySave value;		parcelSave: self parcelSave value;		comment: self blessingComment value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelVersionString: self parcelVersionString value;		description: aPackageModel comment;		blessing: self blessingLevel value;		version: self versionString value;		publish: true;		parcelPadded: self parcelPadded value.	^publishSpecification</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>actions</category><body package="Store-UI">accept	"It's possible there have been changes to the package since we opened the dialog, so regenerate our model before applying the spec."	| publishSpecification |	self validateParcelOptions ifFalse: [^self].	publishSpecification := self publishSpecificationFrom: package.	(self canPublish: publishSpecification) ifFalse: [^self].	Announcements announce: (StorePrePublish for: self specification: publishSpecification).	StoreProgressOverlay subsume: builder window		while: 			[publishSpecification publishPundle.			callBackBlock				ifNotNil: 					[callBackBlock value: (PublishSpecificationList with: publishSpecification)]].	Announcements announce: (StorePostPublish for: self specification: publishSpecification).	self updatePackageListsAndClose</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>interface opening</category><body package="Store-UI">localPostOpenWith: aBuilder	super localPostOpenWith: aBuilder.	package isPackage ifTrue: 		[self binarySave value: ((package parentRecordIn: self glorpSession)			ifNil: [false]			ifNotNil: [:value | value parcelID notNil])]</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>interface opening</category><body package="Store-UI">publishPackage: aPackage	| session instance |	session := StoreLoginFactory currentStoreSession.	(self validateForPublishing: (PublishSpecificationList with: aPackage) in: session)		ifFalse: [^nil].	instance := self new.	instance glorpSession: session.	instance package: aPackage.	instance open.	^instance</body><body package="Store-UI">validateForPublishing: aList	^super validateForPublishing: (aList collect: [:each | each storeModel]).</body><body package="Store-UI">validateForPublishing: aList in: aSession	^super validateForPublishing: (aList collect: [:each | each storeModel]) in: aSession.</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>class initialization</category><body package="Store-UI">initialize	"self initialize "	| complexList |	complexList := 		OrderedCollection new			add: 'Version Name and Blessing' -&gt; #(#mainSpec #mainHelp);			add: 'Parcel Options' -&gt; #(#parcelSpec #parcelHelp);			asArray.	runtimeTabLabels := Array new: 1.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new: 1.</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">addPundle: aPundle	^pundles add: aPundle</body><body package="StoreForGlorpBrowserUI">allClasses	^((self pundles inject: Set new into:		[:sum :each |		sum addAll: each fullClasses]) asSortedCollection: [:each :other| each name &lt;= other name]) asOrderedCollection</body><body package="StoreForGlorpBrowserUI">allClassesAndExtensionsForName: aString	" Answer all class and extension representations from my pundles whose name is aString. "	| answer |	answer := OrderedCollection new.	self allClassesDo: [:each | each longName = aString ifTrue: [answer add: each]].	^answer sorted: [:a :b | a name &lt; b name]</body><body package="StoreForGlorpBrowserUI">allNameSpaces	^(self pundles inject: Set new into:		[:sum :each |		sum addAll: each nameSpaces]) asSortedCollection asOrderedCollection</body><body package="StoreForGlorpBrowserUI">allPundles	| result |	result := OrderedCollection new.	self bundlesAndPackagesDo: [:each | result add: each].	^result</body><body package="StoreForGlorpBrowserUI">allShared	| answer sharedVariables |	answer := OrderedCollection new.	sharedVariables := self pundles		inject: Set new		into: [:sum :each | sum addAll: each sharedVariables].	sharedVariables do: [:each | answer add: each longNameFromSmalltalk -&gt; each].	^sharedVariables asSortedCollection collect: [:each | each value]</body><body package="StoreForGlorpBrowserUI">bindingReferencesDo: aBlock	| traversed enumerationBlock reference |	traversed := Set new.	enumerationBlock :=			[:each |			reference := each longName.			(traversed includes: reference)				ifFalse: 					[aBlock value: each.					traversed add: reference]].	pundles first nameSpaces do: enumerationBlock.	pundles first allClasses do: enumerationBlock.	pundles first sharedVariables		do: [:each | each isInClass ifFalse: [enumerationBlock value: each]]</body><body package="StoreForGlorpBrowserUI">bundlesAndPackagesDo: aBlock	"This is a read-only environment so use the cached collection."	| visited visitor |	visited := IdentitySet new.	visitor :=			[:each |			(visited includes: each)				ifFalse: 					[visited add: each.					aBlock value: each.					each isBundle ifTrue: [each allItems do: visitor]]].	self pundles do: visitor</body><body package="StoreForGlorpBrowserUI">bundlesDo: aBlock	"This is a read-only environment so use bundles from the cached collection."	| visited visitor |	visited := IdentitySet new.	visitor :=			[:each |			each isBundle				ifTrue: 					[(visited includes: each)						ifFalse: 							[visited add: each.							aBlock value: each.							each allItems do: visitor]]].	self pundles do: visitor</body><body package="StoreForGlorpBrowserUI">categories	^self pundles</body><body package="StoreForGlorpBrowserUI">enclosingBundlesFor: aStorePundle	self pundles do:		[:each |		(each enclosingBundlesFor: aStorePundle) ifNotNil: [:value | ^value]].	^#()</body><body package="StoreForGlorpBrowserUI">methodDefinitions	| methods |	methods := OrderedCollection new.	^pundles inject: methods into: [:sum :each | sum addAll: each methods. sum].</body><body package="StoreForGlorpBrowserUI">methodNamed: aSelector inClass: aClass	^self methodDefinitions 		detect: [:each | each classNameWithMeta = aClass classNameWithMeta and: [each name = aSelector asString]]		ifNone: [nil]</body><body package="StoreForGlorpBrowserUI">navigatorClass		^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI">openEditor	self pundles do: [:each | each resetFullClasses].	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI">packagesContaining: aClassOrNameSpaceOrShared	| found |	^(self pundles inject: OrderedCollection new into:		[:sum :each |		found := each 			componentsDetect: [:eachPundle | eachPundle isPackage and: [eachPundle name = aClassOrNameSpaceOrShared package name]]			ifNone: [nil].		found ifNotNil: [sum add: found].		sum]).</body><body package="StoreForGlorpBrowserUI">packagesDo: aBlock	"This is a read-only environment so use packages from the cached collection."	| visited visitor |	visited := IdentitySet new.	visitor :=			[:each |			(visited includes: each)				ifFalse: 					[visited add: each.					each isPackage ifTrue: [aBlock value: each].					each isBundle ifTrue: [each allItems do: visitor]]].	self pundles do: visitor</body><body package="StoreForGlorpBrowserUI">protocolsFor: aClass 	^aClass protocols.</body><body package="StoreForGlorpBrowserUI">pundleNamed: aString isPackage: aBoolean	| target |	pundles do:		[:each |		target := each withAllItems 			detect:				[:eachPundle |				eachPundle isPackage = aBoolean and: [eachPundle name = aString]]			ifNone: [nil].		target ifNotNil: [^target]].	^nil</body><body package="StoreForGlorpBrowserUI">pundles	^pundles</body><body package="StoreForGlorpBrowserUI">selectorsFor: aProtocol in: aClass	^(aClass instanceMethods select: [:each | each protocol = aProtocol]) collect: [:each | each name]</body><body package="StoreForGlorpBrowserUI">selectorsForClass: aClass do: aBlock 	(aClass instanceMethods collect: [:each | each name])  do: aBlock.</body><body package="StoreForGlorpBrowserUI">setPundles: aCollection	pundles := OrderedCollection new.	pundles addAll: aCollection</body><body package="StoreForGlorpBrowserUI">sharedVariable: aName for: aClassOrNameSpace	^self pundles first sharedVariables 		detect: [:each | each absoluteOwnerName asString = aClassOrNameSpace and: [each name = aName asString]]		ifNone: [nil]</body><body package="StoreForGlorpBrowserUI">sharedVariableProtocolsFor: aClass 	^(self pundles first sharedVariables select: [:each | each absoluteOwnerName asString = aClass longName])		collect: [:each | each protocol].</body><body package="StoreForGlorpBrowserUI">sharedVariablesFor: aProtocol in: aClassOrNameSpace	^(self pundles first sharedVariables		select: [:each | each absoluteOwnerName asString = aClassOrNameSpace longName and: [each protocol = aProtocol]])			collect: [:each | each dataKey]</body><body package="StoreForGlorpBrowserUI">sharedVariablesForClass: aClass	^self pundles first sharedVariables		select: [:each | each absoluteOwnerName asString = aClass longName]</body><body package="StoreForGlorpBrowserUI">whichProtocolIncludes: aSelector in: aClass	^(aClass compiledMethodAt: aSelector) ifNotNil: #protocol</body><body package="StoreForGlorpBrowserUI">whichProtocolIncludesVariable: aSymbol in: aClass	| result |	result := self pundles first sharedVariables 		detect: [:each | each absoluteOwnerName asString = aClass longName and: [each name = aSymbol]]		ifNone: [^nil].	^result protocol</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">includesClass: aClass	^self pundles anySatisfy: [:each |		each fullClasses includes: aClass mainClass].</body><body package="StoreForGlorpBrowserUI">includesSelector: aSelector in: aClass		^self pundles anySatisfy:		[:each | 		each methods anySatisfy: [:eachMethod | eachMethod classNameWithMeta = aClass classNameWithMeta and: [eachMethod selector = aSelector asSymbol]]]</body><body package="StoreForGlorpBrowserUI">isEmpty	^pundles isEmpty.</body><body package="StoreForGlorpBrowserUI">isPundleEnvironemt	^true</body><body package="StoreForGlorpBrowserUI">isSystem	^false.</body><body package="StoreForGlorpBrowserUI">useSystemNavigator	"Override so we use the system browser spec, even though this is not the system browser."	^true</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>initialize-release</category><body package="StoreForGlorpBrowserUI">initialize	pundles := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI">allClassesDo: aBlock 	self packagesDo: [:each | each fullClasses do: [:eachClass | aBlock value: eachClass]].</body><body package="StoreForGlorpBrowserUI">allMetaClassesDo: aBlock 	self packagesDo: [:each | each fullClasses do: [:eachClass | aBlock value: eachClass storeMetaClass]].</body><body package="StoreForGlorpBrowserUI">at: className ifAbsent: aBlock	^self classForName: className asString ifAbsent: aBlock.</body><body package="StoreForGlorpBrowserUI">classForName: aString	^self classForName: aString ifAbsent: [nil].</body><body package="StoreForGlorpBrowserUI">classForName: aString ifAbsent: aBlock	"We may sometimes hand out object name wrappers but should always receive full names back from our navigator and state.  (Our code assumes that aBlock will either return or answer something that responds to #objectNamed:)"	self pundles do: [:each | (each objectNamed: aString) ifNotNil: [:theClass | ^theClass]].	^aBlock value</body><body package="StoreForGlorpBrowserUI">nameSpaceForName: aString	^self nameSpaceForName: aString ifAbsent: [nil].</body><body package="StoreForGlorpBrowserUI">nameSpaceForName: aString ifAbsent: aBlock	"aBlock must either return or answer something that responds to #objectNamed:"	| containingPundle theNamespace |	containingPundle := self pundles		detect: [:each | (each nameSpaceNamed: aString ) notNil]		ifNone: aBlock.	containingPundle ifNil: [^aBlock value].	theNamespace := containingPundle nameSpaceNamed: aString.	^theNamespace isNil ifTrue: aBlock ifFalse: [theNamespace]</body><body package="StoreForGlorpBrowserUI">nameSpaceObjectNames	| names |	names := OrderedCollection new.	self nameSpacesDo: [:each | names add: each name].	^names.</body><body package="StoreForGlorpBrowserUI">nameSpacesDo: aBlock 	self packagesDo: [:each | each namespaces do: aBlock].</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>environments</category><body package="StoreForGlorpBrowserUI">protocolEnvironmentClass	^StoreProtocolEnvironment</body><body package="StoreForGlorpBrowserUI">pundleEnvironmentClass	^StorePundleEnvironment</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>printing</category><body package="StoreForGlorpBrowserUI">fullNameFor: aClassOrNamespace	^aClassOrNamespace longName.</body><body package="StoreForGlorpBrowserUI">glorpSession	^pundles first session</body><body package="StoreForGlorpBrowserUI">repositoryName	^pundles first dbIdentifier</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">classEnvironmentClass	^StoreClassEnvironment</body><body package="StoreForGlorpBrowserUI">selectorEnvironmentClass	^StoreSelectorEnvironment</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI">on: aPundle	^self new		addPundle: aPundle;		yourself</body></methods><methods><class-id>Store.BasicPublishPolicy</class-id> <category>publishing</category><body package="Store-User Management">basicCanPublish: aPundle atBlessing: aBlessing	^Policies blessingPolicy basicCanPublish: aPundle atBlessing: aBlessing</body><body package="Store-User Management">objectionsToPublishing: aPublishSpecification	"Replaces #objectionsToPublishingPundle:atBlessingLevel:.  The blessing policy is unchanged - it only cares about the level."	^Policies blessingPolicy		objectionsToPublishingPundle: aPublishSpecification pundleModel		atBlessingLevel: aPublishSpecification blessing</body><body package="Store-User Management">objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may 	not be published.  Return nil if it may."	self deprecated: #(#version '7.9' #sunset '8.0' #use #objectionsToPublishing:).	^Policies blessingPolicy objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel</body><body package="Store-User Management">objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	self deprecated: #(#version '7.9' #sunset '8.0' #use #objectionsToPublishing:).	^Policies blessingPolicy objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel</body><body package="Store-User Management">objectionsToPublishingParcel: aParcel  atBlessingLevel: aLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	self deprecated: #(#version '7.9' #sunset '8.0' #use #objectionsToPublishing:).	^Policies blessingPolicy objectionsToPublishingParcel: aParcel  atBlessingLevel: aLevel</body><body package="Store-User Management">objectionsToPublishingPundle: aPundle atBlessingLevel: aLevel	"WARNING! DEPRECATED! From 7.9, the publish policy looks at the blessing comment as well as the blessing level."	self deprecated: #(#version '7.9' #sunset '8.0' #use #objectionsToPublishing:).	^Policies blessingPolicy objectionsToPublishingPundle: aPundle atBlessingLevel: aLevel</body></methods><methods><class-id>Store.BasicPublishPolicy</class-id> <category>accessing</category><body package="Store-User Management">allowBinaryLoading	allowBinaryLoading == nil		ifTrue: [ allowBinaryLoading := true ].	^allowBinaryLoading</body><body package="Store-User Management">allowBinaryLoading: aBoolean	allowBinaryLoading := aBoolean</body><body package="Store-User Management">allowOverridesWithinBundles	allowOverridesWithinBundles isNil ifTrue: [allowOverridesWithinBundles := true].	^allowOverridesWithinBundles.</body><body package="Store-User Management">allowOverridesWithinBundles: aBoolean	allowOverridesWithinBundles := aBoolean</body></methods><methods><class-id>Store.Glorp.AbstractPundleDisplayRow</class-id> <category>accessing</category><body package="Store-UI">comment	^self pundle comment</body><body package="Store-UI">isImageModel	^self pundle isImageModel</body><body package="Store-UI">name	^self pundle name</body><body package="Store-UI">parentModel	^parentModel</body><body package="Store-UI">parentModel: anObject	parentModel := anObject</body><body package="Store-UI">pundle	^self subclassResponsibility</body><body package="Store-UI">version	^self pundle version</body></methods><methods><class-id>Store.Glorp.AbstractPundleDisplayRow</class-id> <category>labels</category><body package="Store-UI">nameLabelText		^self pundle name trimBlanks asText</body><body package="Store-UI">versionLabelText	^self pundle versionString asText</body></methods><methods><class-id>Store.Glorp.AbstractPundleDisplayRow</class-id> <category>displaying</category><body package="Store-UI">toolTipText	^nil</body></methods><methods><class-id>Store.Glorp.AbstractPundleDisplayRow class</class-id> <category>instance creation</category><body package="Store-UI">newFor: aPundleModel parentModel: aPundleVersionPane	^self subclassResponsibility</body></methods><methods><class-id>Store.StorePublishAnnouncement</class-id> <category>accessing</category><body package="Store-Base">publishDialog	^subject</body><body package="Store-Base">subject	^subject</body><body package="Store-Base">subject: aPublishDialog	subject := aPublishDialog</body></methods><methods><class-id>Store.StorePublishAnnouncement class</class-id> <category>instance creation</category><body package="Store-Base">for: aStorePublishDialog	| instance |	instance := self new.	instance subject: aStorePublishDialog.	^instance</body></methods><methods><class-id>Store.StorePostPublish</class-id> <category>accessing</category><body package="Store-Base">specifications	^specifications</body><body package="Store-Base">specifications: aCollection	specifications := aCollection</body></methods><methods><class-id>Store.StorePostPublish class</class-id> <category>instance creation</category><body package="Store-Base">for: aStorePublishDialog specification: aPublishSpecification	^self for: aStorePublishDialog specifications: (PublishSpecificationList with: aPublishSpecification)</body><body package="Store-Base">for: aStorePublishDialog specifications: aPublishSpecificationList	| instance |	instance := self for: aStorePublishDialog.	instance specifications: aPublishSpecificationList.	^instance</body></methods><methods><class-id>Store.PseudoDifference</class-id> <category>testing</category><body package="Store-Difference Management">hasBothDefinitions	^mainPackage notNil and: [otherPackage notNil]</body><body package="Store-Difference Management">hasMainDifferences	^mainObject notNil</body><body package="Store-Difference Management">hasOnlyMainDefinition	^mainPackage notNil and: [otherPackage isNil]</body><body package="Store-Difference Management">hasOnlyOtherDefinition	^mainPackage isNil and: [otherPackage notNil]</body><body package="Store-Difference Management">hasOtherDifferences	^otherObject notNil</body><body package="Store-Difference Management">isBundleStructureOnly	^false</body><body package="Store-Difference Management">isClass	^false</body><body package="Store-Difference Management">isClassExtension	^false</body><body package="Store-Difference Management">isExtensionInMain	^mainObject isNil</body><body package="Store-Difference Management">isExtensionInOther	^otherObject isNil</body><body package="Store-Difference Management">isForSharedVariable	^false</body><body package="Store-Difference Management">isMeta	^false</body><body package="Store-Difference Management">isNamespace	^false</body><body package="Store-Difference Management">isNamespaceExtension	^false</body><body package="Store-Difference Management">isNotMeta	^self isMeta not</body><body package="Store-Difference Management">isProperty	^false</body><body package="Store-Difference Management">isPropertyDifference	^false</body><body package="Store-Difference Management">isShownInMethodList	^false</body><body package="Store-Difference Management">isStandin	^false</body></methods><methods><class-id>Store.PseudoDifference</class-id> <category>accessing</category><body package="Store-Difference Management">differenceName	^self classListName</body><body package="Store-Difference Management">firstTextFragments	| text |	text := self mainDefinition asText.	^text smalltalkOrWordAndWhitespaceFragments</body><body package="Store-Difference Management">mainObject	^mainObject</body><body package="Store-Difference Management">mainObject: anObject	mainObject := anObject</body><body package="Store-Difference Management">mainPackage	^mainPackage</body><body package="Store-Difference Management">mainPackage: anObject	mainPackage := anObject</body><body package="Store-Difference Management">mainPackage: aPackage object: anObject	mainPackage := aPackage.	mainObject := anObject</body><body package="Store-Difference Management">notDefinedInThisPackage	^Text new</body><body package="Store-Difference Management">otherObject	^otherObject</body><body package="Store-Difference Management">otherObject: anObject	otherObject := anObject</body><body package="Store-Difference Management">otherPackage	^otherPackage</body><body package="Store-Difference Management">otherPackage: anObject	otherPackage := anObject</body><body package="Store-Difference Management">otherPackage: aPackage object: anObject	otherPackage := aPackage.	otherObject := anObject</body><body package="Store-Difference Management">secondTextFragments	| text |	text := self otherDefinition asText.	^text smalltalkOrWordAndWhitespaceFragments</body></methods><methods><class-id>Store.PseudoDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	self subclassResponsibility</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	self subclassResponsibility</body></methods><methods><class-id>Store.PseudoDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage	| instance |	instance := self new.	^instance 		mainPackage: aPackage;		yourself</body><body package="Store-Difference Management">otherPackage: aPackage	| instance |	instance := self new.	^instance 		otherPackage: aPackage;		yourself</body></methods><methods><class-id>Store.PseudoNamespaceDifference</class-id> <category>accessing</category><body package="Store-Difference Management">changedMethodsSharedAndProperties	| namespaceDifferences |		^(namespaceDifferences := self classNamespaceDifferences) notEmpty		ifTrue: [namespaceDifferences , self sortedSharedDifferences]		ifFalse: [self sortedSharedDifferences]</body><body package="Store-Difference Management">classListIcon	^NameSpace toolListIcon</body><body package="Store-Difference Management">classListName	^mainObject notNil 		ifTrue: [mainObject longNameFromSmalltalk]		ifFalse: [			otherObject notNil				ifTrue: [otherObject longNameFromSmalltalk]				ifFalse: [					self sharedDifferences notEmpty						ifTrue: [self sharedDifferences first classListName]						ifFalse: [self error: 'Empty namespace difference']]]</body><body package="Store-Difference Management">classNamespaceDifferences	| diffs pseudoDefinition pseudoComment |	diffs := OrderedCollection new.	pseudoDefinition := PseudoNamespaceDefinitionDifference new.	pseudoDefinition mainPackage: mainPackage definition: self mainDefinition.	pseudoDefinition otherPackage: otherPackage definition: self otherDefinition.	pseudoDefinition isExtensionInMain &amp; pseudoDefinition isExtensionInOther		ifTrue: [^diffs].	pseudoDefinition mainObject = pseudoDefinition otherObject		ifFalse: [diffs add: pseudoDefinition].	pseudoComment := PseudoNamespaceCommentDifference new.	pseudoComment mainPackage: mainPackage comment: mainComment.	pseudoComment otherPackage: otherPackage comment: otherComment.	pseudoComment mainObject = pseudoComment otherObject		ifFalse: [diffs add: pseudoComment].	^diffs</body><body package="Store-Difference Management">mainClass	^self mainNamespace ifNotNil: [:value | self mainPackage objectNamed: value asString]</body><body package="Store-Difference Management">mainClassLongName	self mainNamespace ifNotNil: [:value | ^value absoluteName].	self sharedDifferences notEmpty ifTrue:		[self sharedDifferences first mainObject ifNotNil: [:value | ^value classNameWithoutMeta]].	^''</body><body package="Store-Difference Management">mainClassStoreObject	| targetObject |	mainObject ifNotNil: [^self mainPackage objectNamed: self mainClassLongName].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleMainSharedDifference.		targetObject ifNotNil: [^targetObject mainPackage objectNamed: targetObject mainObject classNameWithoutMeta]].	^nil</body><body package="Store-Difference Management">mainComment	^mainComment ifNil: [^'']</body><body package="Store-Difference Management">mainDefinition	^mainDefinition ifNil: [^'']</body><body package="Store-Difference Management">mainNamespace	^mainObject ifNil:		[(self sharedDifferences 			detect: [:each | each mainObject notNil]			ifNone: [nil]) ifNotNil: [:value | value mainPackage objectNamed: value mainObject environmentName]]</body><body package="Store-Difference Management">mainPackage: aPackage namespace: aNamespace	self mainPackage: aPackage object: aNamespace</body><body package="Store-Difference Management">mainPackage: aPackage namespace: aNamespace comment: aString definition: aDefinitionString	self mainPackage: aPackage object: aNamespace.	mainComment := aString.	mainDefinition := aDefinitionString</body><body package="Store-Difference Management">mainPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference mainPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference mainPackage: aPackage shared: aStoreSharedVariable]</body><body package="Store-Difference Management">methodDifferences	^OrderedCollection new</body><body package="Store-Difference Management">modifiedClassNamespaceDifferences	| pseudoDefinition pseudoComment trueDifferences |	trueDifferences := OrderedCollection new.	self mainDefinition = self otherDefinition ifFalse:		[pseudoDefinition := PseudoNamespaceDefinitionDifference new.		pseudoDefinition mainPackage: mainPackage definition: self mainDefinition.		pseudoDefinition otherPackage: otherPackage definition: self otherDefinition.		trueDifferences add: pseudoDefinition].	self mainComment = self otherComment ifFalse: 		[pseudoComment := PseudoNamespaceCommentDifference new.		pseudoComment mainPackage: mainPackage comment: mainComment.		pseudoComment otherPackage: otherPackage comment: otherComment.		trueDifferences add: pseudoComment].	^trueDifferences</body><body package="Store-Difference Management">modifiedMethodsSharedAndProperties		^self modifiedClassNamespaceDifferences , self sortedSharedDifferences</body><body package="Store-Difference Management">otherClass	^self otherNamespace ifNotNil: [:value | self otherTargetPackage objectNamed: value asString]</body><body package="Store-Difference Management">otherClassLongName	self otherNamespace ifNotNil: [:value | ^value absoluteName].	self sharedDifferences notEmpty ifTrue:		[self sharedDifferences first otherObject ifNotNil: [:value | ^value classNameWithoutMeta]].	^''</body><body package="Store-Difference Management">otherClassStoreObject	| targetObject |	otherObject ifNotNil: [^self otherPackage objectNamed: self otherClassLongName].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleOtherSharedDifference.		targetObject ifNotNil: [^targetObject otherPackage objectNamed: targetObject otherObject classNameWithoutMeta]].	^nil</body><body package="Store-Difference Management">otherComment	^otherComment ifNil: [^'']</body><body package="Store-Difference Management">otherDefinition	^otherDefinition ifNil: [^'']</body><body package="Store-Difference Management">otherNamespace	^otherObject ifNil:		[(self sharedDifferences 			detect: [:each | each otherObject notNil]			ifNone: [nil]) ifNotNil: [:value | value otherPackage objectNamed: value otherObject environmentName]]</body><body package="Store-Difference Management">otherPackage: aPackage justNamespace: aNamespace	self otherPackage: aPackage object: aNamespace fullName asQualifiedReference</body><body package="Store-Difference Management">otherPackage: aPackage namespace: aNamespace	self  otherPackage: aPackage namespace: aNamespace fullName asQualifiedReference comment: aNamespace comment definition: aNamespace definition</body><body package="Store-Difference Management">otherPackage: aPackage namespace: aNamespace comment: aString definition: aDefinitionString	self otherPackage: aPackage object: aNamespace.	otherComment := aString.	otherDefinition := aDefinitionString</body><body package="Store-Difference Management">otherPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference otherPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference otherPackage: aPackage shared: aStoreSharedVariable]</body><body package="Store-Difference Management">otherTargetPackage	^otherPackage ifNil:		[ | target |		target := self sharedDifferences 			detect: [:each | each otherPackage notNil]			ifNone: [nil].		target ifNotNil: [target otherPackage]]</body><body package="Store-Difference Management">referencesHolderClass 	^NamespaceResolutions</body><body package="Store-Difference Management">sampleMainSharedDifference		^self sharedDifferences detect: [:each | each mainObject notNil] ifNone: [nil]</body><body package="Store-Difference Management">sampleOtherSharedDifference		^self sharedDifferences detect: [:each | each otherObject notNil] ifNone: [nil]</body><body package="Store-Difference Management">sharedDifferences	sharedDifferences ifNil: [sharedDifferences := OrderedCollection new].	^sharedDifferences</body></methods><methods><class-id>Store.PseudoNamespaceDifference</class-id> <category>testing</category><body package="Store-Difference Management">hasMainDifferences	self mainNamespace ifNotNil: [^true].	(self sharedDifferences 		detect: [:each | each mainObject notNil]		ifNone: [nil]) ifNotNil: [^true].	^false</body><body package="Store-Difference Management">hasOtherDifferences	self otherNamespace ifNotNil: [^true].	(self sharedDifferences 		detect: [:each | each otherObject notNil]		ifNone: [nil]) ifNotNil: [^true].	^false</body><body package="Store-Difference Management">isMainDefinedInPackage	mainPackage isImageModel ifTrue: 		[ | imageObject |		imageObject := self mainClassStoreObject isImageObject			ifTrue: [self mainClassStoreObject]			ifFalse: [self mainClassStoreObject correspondingImageClass].		imageObject  ifNil: [^false].		^mainPackage definesObject: imageObject].	^mainPackage definesObject: (self mainClassStoreObject ifNil: [^false])</body><body package="Store-Difference Management">isNamespace	^true</body><body package="Store-Difference Management">isOtherDefinedInPackage	^otherPackage definesObject: (self otherClassStoreObject ifNil: [^false])</body></methods><methods><class-id>Store.PseudoNamespaceDifference</class-id> <category>private</category><body package="Store-Difference Management">sortedSharedDifferences		^(self sharedDifferences collect: [:each | each selectorListName -&gt; each])		asSortedCollection collect: [:each | each value]</body></methods><methods><class-id>Store.PseudoNamespaceDifference</class-id> <category>printing</category><body package="Store-Difference Management">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: self classListName;		nextPut: $)</body></methods><methods><class-id>Store.PseudoNamespaceDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference mainPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		mainPackage: aPackage namespace: namespace fullName asQualifiedReference comment: namespace comment definition: namespace definitionString;		yourself</body><body package="Store-Difference Management">mainPackage: aPackage namespace: aNamespace	| instance |	instance := self new.	^instance		mainPackage: aPackage namespace: aNamespace fullName asQualifiedReference comment: aNamespace comment definition: aNamespace definitionString;		yourself</body><body package="Store-Difference Management">otherPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference otherPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		otherPackage: aPackage namespace: namespace fullName asQualifiedReference comment: namespace comment definition: namespace definitionString;		yourself</body><body package="Store-Difference Management">otherPackage: aPackage namespace: aNamespace	| instance |	instance := self new.	^instance		otherPackage: aPackage namespace: aNamespace fullName asQualifiedReference comment: aNamespace comment definition: aNamespace definitionString;		yourself</body></methods><methods><class-id>Store.PseudoNamespaceExtensionDifference</class-id> <category>accessing</category><body package="Store-Difference Management">classListName	"Currently, in an extension, the mainObject and otherObject are strings."	^mainObject notNil 		ifTrue: [mainObject]		ifFalse: [otherObject notNil				ifTrue: [otherObject]				ifFalse: [self sharedDifferences notEmpty						ifTrue: [self sharedDifferences first classListName]						ifFalse: [self error: 'Empty namespace extension difference']]]</body><body package="Store-Difference Management">classNamespaceDifferences	^OrderedCollection new</body><body package="Store-Difference Management">correspondingImageNamespace	| sharedDifference |	(mainPackage notNil and: [mainObject notNil])		ifTrue: [^Dialect smalltalkAt: 'Root.Smalltalk.', mainObject ifAbsent: [nil]].	(otherPackage notNil and: [otherObject notNil])		ifTrue: [^Dialect smalltalkAt: 'Root.Smalltalk.', otherObject ifAbsent: [nil]].	sharedDifference := sharedDifferences first.	^mainObject isNil		ifTrue: [Dialect smalltalkAt: 'Root.Smalltalk.', sharedDifference otherObject environmentNameFromSmalltalk ifAbsent: [nil]]		ifFalse: [Dialect smalltalkAt: 'Root.Smalltalk.', sharedDifference mainObject environmentNameFromSmalltalk ifAbsent: [nil]]</body><body package="Store-Difference Management">mainClassStoreObject	^self</body><body package="Store-Difference Management">modifiedClassNamespaceDifferences	^OrderedCollection new</body><body package="Store-Difference Management">otherClassStoreObject	^self</body></methods><methods><class-id>Store.PseudoNamespaceExtensionDifference</class-id> <category>testing</category><body package="Store-Difference Management">hasMainDifferences	^mainObject notNil</body><body package="Store-Difference Management">hasOtherDifferences	^otherObject notNil</body><body package="Store-Difference Management">isForClassOrExtension	^false</body><body package="Store-Difference Management">isMainDefinedInPackage	^false</body><body package="Store-Difference Management">isNamespaceExtension	^true</body><body package="Store-Difference Management">isOtherDefinedInPackage	^false</body></methods><methods><class-id>Store.PseudoNamespaceExtensionDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage fromShared: aSharedVariable	| instance |	instance := self new.	instance mainObject: aSharedVariable environmentNameFromSmalltalk.	instance mainPackage: aPackage.	^instance</body><body package="Store-Difference Management">otherPackage: aPackage fromShared: aSharedVariable	| instance |	instance := self new.	instance otherObject: aSharedVariable environmentNameFromSmalltalk.	instance otherPackage: aPackage.	^instance</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange</class-id> <category>private</category><body package="Store-Merge Management">executeNotifying: aBlock 	| undo |	undo := self asUndoOperation.	self primitiveExecute.	aBlock value.	^undo</body><body package="Store-Merge Management">primitiveExecute	self bundle structure: structure.</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange</class-id> <category>accessing</category><body package="Store-Merge Management">bundle	^self storeRegistry bundleNamed: bundleName</body><body package="Store-Merge Management">bundleName	^bundleName</body><body package="Store-Merge Management">bundleName: aString	bundleName := aString</body><body package="Store-Merge Management">structure	^structure</body><body package="Store-Merge Management">structure: anArray	structure := anArray</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange</class-id> <category>printing</category><body package="Store-Merge Management">changeString	^((#ChangeStructureFor1s &lt;&lt; #store &gt;&gt; 'Change Structure for &lt;1s&gt;')			expandMacrosWith: bundleName)</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange</class-id> <category>converting</category><body package="Store-Merge Management">asUndoOperation	^(self copy)		structure: self bundle structure;		name: self name</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange</class-id> <category>comparing</category><body package="Store-Merge Management">= anObject	^super = anObject and:		[self bundleName = anObject bundleName and:		[self structure isSameSequenceAs: anObject structure]]</body></methods><methods><class-id>Refactory.Browser.BundleStructureMergeChange class</class-id> <category>instance creation</category><body package="Store-Merge Management">bundle: aBundle structure: anArray	^(self new)		bundleName: aBundle name;		structure: anArray;		yourself</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>menu enabling</category><body package="Store-UI">are2VersionsOfAPundleSelected	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size = 2 ifFalse: [^false].	pundles first isPackage = pundles last isPackage ifFalse: [^false].	pundles first name = pundles last name ifFalse: [^false].	^true</body><body package="Store-UI">areBundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isBundle ifFalse: [^false].			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI">areDBPundlesSelected	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles do: [:pun | pun isLoaded ifTrue: [^false]].	^true</body><body package="Store-UI">areDBPundlesSelectedAndSomeVersionIsLoaded	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isLoaded ifTrue: [^false].			((pun isPackage and: [Registry isPackageLoaded: pun name]) 					or: [pun isBundle and: [Registry isBundleLoaded: pun name]])				ifFalse: [^false]].	^true</body><body package="Store-UI">areLoadedBundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isBundle ifFalse: [^false].			pun isLoaded ifFalse: [^false]].	^true</body><body package="Store-UI">areLoadedPundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isLoaded ifFalse: [^false]].	^true</body><body package="Store-UI">arePackagesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isPackage ifFalse: [^false].			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI">arePundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI">areVersionableObjectsSelected	self isDBConnected ifFalse: [^false].	^self pundles size &gt; 0</body><body package="Store-UI">isDBConnected	^DbRegistry isOnline</body><body package="Store-UI">isImageAdministrator	"Added by Philippe F. Monnet of Andersen Consulting"			^Policies ownershipPolicy isImageAdministrator</body><body package="Store-UI">isLoadedPackageSelected	| pundles pun |	pundles := self pundleVersions.	pundles size = 1 ifFalse: [^false].	pun := pundles first.	pun isPackage ifFalse: [^false].	pun isLoaded ifFalse: [^false].	^true</body><body package="Store-UI">isLoadedPundleSelected	| pundles |	pundles := self pundleVersions.	pundles size = 1 ifFalse: [ ^false ].	^pundles contains: [ :pun | pun isLoaded not ].</body><body package="Store-UI">makePundleMenuDynamic: menu 	"Many of the symbols below (e.g. createAsParcel) are now not in any menu unless OldStoreTools is loaded.	Add dynamic features to the menu. ALPHA ORDER. " 	self makeDynamicItem: #browsePackageVersion selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #browseVersions selectionBlock: [self areVersionableObjectsSelected] inMenu: menu.	self makeDynamicItem: #createAsParcel selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #enclosingBundles selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #deletePundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #diffPundleWithImage selectionBlock: [self areDBPundlesSelectedAndSomeVersionIsLoaded] inMenu: menu.	self makeDynamicItem: #diffPundleWithParent selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #diffTwoPundles selectionBlock: [self are2VersionsOfAPundleSelected] inMenu: menu.	self makeDynamicItem: #editBundleSpecification selectionBlock: [self areLoadedBundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutChanges selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutPundle selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutTwoPundleDiff selectionBlock: [self are2VersionsOfAPundleSelected] inMenu: menu.	self makeDynamicItem: #graphPundleVersions selectionBlock: [self areVersionableObjectsSelected] inMenu: menu.	self makeDynamicItem: #inspectChangesInPundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #listBundleContents selectionBlock: [self areBundlesSelected] inMenu: menu.	self makeDynamicItem: #republish selectionBlock: [self areBundlesSelected &amp; self areLoadedBundlesSelected not ] inMenu: menu.	self makeDynamicItem: #loadPundle selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #makeCurrentPackage selectionBlock: [self isLoadedPackageSelected] inMenu: menu.	self makeDynamicItem: #mergePundleVersion selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #methodsChangesInPundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #reloadVersions selectionBlock: [self isDBConnected] inMenu: menu.	self makeDynamicItem: #renamePundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #setBlessingLevel selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #showBundleStructure selectionBlock: [self areBundlesSelected] inMenu: menu.	self makeDynamicItem: #storePundleInDB selectionBlock: [self areLoadedPundlesSelected and: [self isDBConnected]] inMenu: menu.	self makeDynamicItem: #reconcile selectionBlock: [self isLoadedPundleSelected] inMenu: menu.	^menu</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>pundle actions</category><body package="Store-UI">addBlessingForPundle: aDBPundle 	"Add a new record describing blessing for package."	BlessingDialog setBlessingFor: aDBPundle.</body><body package="Store-UI">browseVersions		| session |	self doIfOnlineImage: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		[self pundles do: 			[:each | 			(Gathering for: each name) started.			Store.Glorp.DefinitionForListTool forPackages: (each allStoreVersionsIn: session).			(Gathering for: each name) finished]] withStoreFeedbackOn: self mainWindow]</body><body package="Store-UI">createAsParcel	self pundles do:		[ :pundle | self createAsParcel: pundle ].</body><body package="Store-UI">createAsParcel: aPundle 	| name |	name := nil.	[name == nil] whileTrue: 		[name := Dialog 					request: #ParcelName &lt;&lt; #store &gt;&gt; 'Parcel name:'					initialAnswer: aPundle name					onCancel: [^self].		name isEmpty ifTrue: [^self].		(Parcel parcelNamed: name) == nil ifFalse: 			[(Dialog confirm: ((#ParcelNamed1sExistsOverwriteIt &lt;&lt; #store &gt;&gt; 'Parcel named "&lt;1s&gt;" exists - overwrite it?') expandMacrosWith: name)) 				ifTrue: [Parcel destroyParcelNamed: name]				ifFalse: [name := nil]]].	aPundle asParcel: name</body><body package="Store-UI">deletePundle	| pundles | 	pundles := self pundles.	(Dialog confirm: 'Unload', (pundles inject: '' into: [:str :pun | str , ' ' , pun name]) , '?')		ifTrue: [pundles do: [:pun | pun unloadLogged: false ]]</body><body package="Store-UI">diffPundleWithImage	self doIfOnlineImage: 		[self packages do: 			[:eachPackage | 			| packageModel |			packageModel := Registry packageNamed: eachPackage name.			packageModel isNil				ifTrue: [Dialog warn:( (#Package1sIsNotCuOadedIntoTheImage &lt;&lt; #store &gt;&gt; 'Package &lt;1s&gt; is not currently loaded into the image.') expandMacrosWith: eachPackage name)]				ifFalse: [self diffPundle: packageModel with: eachPackage]].		self bundles do: 			[:eachBundle | 			| bundleModel |			bundleModel := Registry bundleNamed: eachBundle name.			bundleModel isNil				ifTrue: [Dialog warn: ((#Bundle1sIsNotCurOadedIntoTheImage &lt;&lt; #store &gt;&gt; 'Bundle &lt;1s&gt; is not currently loaded into the image.')expandMacrosWith:eachBundle name)]				ifFalse: [self diffPundle: bundleModel with: eachBundle]]]</body><body package="Store-UI">diffPundleWithParent		self packages , self bundles do:		[:eachStorePundle | 		| tracePackage |		(tracePackage := eachStorePundle tracePackage) isNil ifTrue: 			[tracePackage := eachStorePundle selectStoreVersion].		tracePackage ifNotNil: [self diffPundle: eachStorePundle with: tracePackage]]</body><body package="Store-UI">diffTwoPundles	| selectedPundles |	selectedPundles := self pundles.	selectedPundles size = 2 ifFalse: 		[^Dialog warn: #ChooseExactlyTwoVersionsToCompare &lt;&lt; #store &gt;&gt; 'Choose exactly two versions to compare'].	self doIfOnlineImage: [self diffPundle: selectedPundles first with: selectedPundles last]</body><body package="Store-UI">fileOutChanges		| puns fileName strm |	puns := self pundles.	puns size = 0 ifTrue: [^self].	fileName := puns size = 1		ifTrue:			[| oldSeparator pun |			pun := puns first.			fileName := pun name asString , '.st'.			oldSeparator := (fileName includes: UnixFilename separator)				ifTrue: [UnixFilename separator]				ifFalse:					[(fileName includes: PCFilename separator)						ifTrue: [PCFilename separator]						ifFalse: [nil]].			fileName				replaceAll: oldSeparator				with: Filename separator.			fileName copyWithout: Character space]		ifFalse: ['changes.st'].	fileName := Dialog		requestNewFileName:			#FileOutAsFileNamed &lt;&lt; #store &gt;&gt; 'File out as file named'		default: fileName.	fileName isEmpty ifTrue: [^self].	strm := SourceCodeStream write: fileName.	Cursor write		showWhile:			[[strm timeStamp.			puns do: [:pun | pun fileOutChangesOn: strm]] ensure: [strm close]]</body><body package="Store-UI">fileOutPundle	self pundles do: [:pun | pun fileOut]</body><body package="Store-UI">fileOutTwoPundleDiff	| puns |	puns := self pundles.	puns size = 2 ifFalse: 		[^Dialog warn: #ChooseExactlyTwoVersionsToCompare &lt;&lt; #store &gt;&gt; 'Choose exactly two versions to compare'].	(puns first pundleChangesClass with: puns first with: puns last) 		fileOutChangesFor: 1</body><body package="Store-UI">glorpLoad	| session |	self doIfOnlineImage:		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		StoreProgressOverlay			subsume: builder window			while:				[| myVersions |				myVersions := self pundles collect: [:each | each glorpReconciledVersionIn: session].				myVersions do: [:each | each ifNotNil: [each loadSource]]].		self reloadVersions].</body><body package="Store-UI">graphPundleVersions	self doIfOnlineImage: [		self pundles do: [:pundle |			VersionGraph browseVersionsOfPundle: pundle]]</body><body package="Store-UI">inspectChangesInPundle	self pundles do: [:pun | pun inspectChangeSet]</body><body package="Store-UI">loadPundle	^self glorpLoad</body><body package="Store-UI">mergePundleVersion	| session openMergeTool |	openMergeTool := Store.Glorp.MergeTool alwaysOpenMergeTool.	self doIfOnlineImage: 		[ | targets |		session := Store.Glorp.StoreLoginFactory currentStoreSession.		targets := (self pundles collect: [:each | each asStorePundleIn: session]).		openMergeTool			ifTrue: [Store.Glorp.MergeTool openOnPundles: targets]			ifFalse: [[Store.Glorp.ResolutionManager doMergeOnPundles: targets] withStoreFeedbackOn: self mainWindow]]</body><body package="Store-UI">methodsChangesInPundle	"Spawn method changes list on pundle(s)."		self storeBrowseChanges: self defaultDbId</body><body package="Store-UI">reconcile	| puns dbVersion imgVersion |	puns := self pundles.	puns size == 1 ifFalse: 		[^Dialog warn: #ChooseOneVersionToReconcile &lt;&lt; #store &gt;&gt; 'Choose one version to reconcile.'].	dbVersion := puns first.	(imgVersion := dbVersion getImagePundle) == nil ifTrue: 		[^Dialog warn: #ThereIsNoImageVersionToReconcile &lt;&lt; #store &gt;&gt; 'There is no image version to reconcile.'].	imgVersion reconcileWithDbVersion: dbVersion</body><body package="Store-UI">renamePundle"----  SOON TO BE DEFUNCT ------	self pundles		do: 			[:pundle | 			| pundleName |			pundleName := Dialog						request: 'Rename to what?'						initialAnswer: pundle name						onCancel: [nil].			pundleName size = 0 ifTrue: [^self].			[((self storageForPundle: pundle)				entryNamed: pundleName) notNil]				whileTrue: 					[pundleName := Dialog								request: pundleName , ' is already in use.\Enter another name.' withCRs								initialAnswer: pundleName								onCancel: [nil].					pundleName isEmpty ifTrue: [^self]].			pundle name: pundleName].	self updatePundleVersion-------------------------"</body><body package="Store-UI">setBlessingLevel	"Add blessing level to the selected package."	self			doIfOnlineImage: 				[self pundles do: [:pundle | self addBlessingForPundle: pundle].				self updatePundleVersion]</body><body package="Store-UI">setTrace	self pundles do: 			[:pundle | 			(Dialog confirm: ((#DoYouWantToSetTheTraceTo1s &lt;&lt; #store &gt;&gt; 'Do you want to set the trace to &lt;1s&gt;?') 						expandMacrosWith: pundle itemString)) 				ifTrue: 					[| imPun |					imPun := pundle isPackage 								ifTrue: [Registry packageNamed: pundle name]								ifFalse: [Registry bundleNamed: pundle name].					imPun isNil 						ifTrue: 							[^Dialog warn: ((#NoVersionOf1sIsLoadedInTheImage &lt;&lt; #store &gt;&gt; 'No version of &lt;1s&gt; is loaded in the image.') 										expandMacrosWith: pundle name)].					imPun dbTrace: pundle primaryKey]]</body><body package="Store-UI">storePundleInDB	self doIfOnlineImage: [Cursor wait showWhile: [self pundles do: [:pundle | pundle storeInDB]]]</body><body package="Store-UI">updatePundleVersion	"No-op unless over-ridden"</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>selection</category><body package="Store-UI">bundles	^self pundles select: [:aPundle | aPundle isBundle].</body><body package="Store-UI">packages	^self pundles select: [:aPundle | aPundle isPackage].</body><body package="Store-UI">pundles	self subclassResponsibility</body><body package="Store-UI">pundleVersions	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>bundle actions</category><body package="Store-UI">addBundle	BundleSpecEditor open</body><body package="Store-UI">editBundleSpecification	self bundles do: [:aBundle | BundleSpecEditor openOnBundle: aBundle]</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>menus</category><body package="Store-UI">menuBar	"Add dynamic features to the menu bar."	| menu |	menu := self class menuBarSkeleton.	menu menuItems do: [:item | self makePundleMenuDynamic: item submenu].	menu augmentFrom: self class		to: AbstractTool		menuName: #menuBar		for: self.	^menu</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>private</category><body package="Store-UI">diffPundle: aPundle with: anotherPundle	"Assume they're in left-&gt;right order, then determine if we need to swap them via the timestamps that might or might not be available to us. The asStoreComparisonObjectIn: makes sure we have either StorePundle or PundleModel objects, no old Store objects."	| left right session leftTimestamp rightTimestamp |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	left := aPundle asStoreComparisonObjectIn: session.	right := anotherPundle asStoreComparisonObjectIn: session.	leftTimestamp := (left isKindOf: PundleModel)				ifTrue: [left storeTracePackage ifNotNil: #timestamp]				ifFalse: [left timestamp].	rightTimestamp := (right isKindOf: PundleModel)				ifTrue: [right storeTracePackage ifNotNil: #timestamp]				ifFalse: [right timestamp].	(leftTimestamp isNil		or: [rightTimestamp notNil and: [rightTimestamp &lt; leftTimestamp]])			ifTrue: 				[| swap |				swap := left.				left := right.				right := swap].	ComparePackages compareFrom: left to: right</body><body package="Store-UI">doIfOnlineImage: aBlock 	^DbRegistry doIfOnlineImage: aBlock</body><body package="Store-UI">makeDynamicItem: actionSymbol selectionBlock: aBlock inMenu: aMenu	| mi |	mi := aMenu menuItemWithValue: actionSymbol ifNone: [nil].	mi notNil ifTrue: [mi enabled: aBlock].</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>events</category><body package="Store-UI">noticeOfWindowClose: aWindow	"The containing window is being closed -- release."	self release</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>package actions</category><body package="Store-UI">addPackage		SmalltalkWorkbench requestNewPackageName		ifNotNil: [:name | PackageModel named: name].</body><body package="Store-UI">browsePackageVersion		self pundles do: 		[:each | 		InputState default ctrlDown 			ifTrue: [each inspect] 			ifFalse: 				[each isPackage					ifTrue: [self browseStorePackage: each]					ifFalse: [self browseStoreBundle: each]]]</body><body package="Store-UI">browseStoreBundle: aBundle	| storeBundle |	storeBundle := aBundle asStorePundle.		[(Gathering for: storeBundle) started.	storeBundle prefetchAllFromDatabase.	(Gathering for: storeBundle) finished]			withStoreFeedbackOn: self mainWindow.	(Store.Glorp.StoreForGlorpBrowserEnvironment on: storeBundle) openEditor</body><body package="Store-UI">browseStorePackage: aPackage	| storePackage |	storePackage := aPackage asStorePundle.		[(Gathering for: storePackage) started.	storePackage prefetchAllFromDatabase.	(Gathering for: storePackage) finished]			withStoreFeedbackOn: self mainWindow.	(Store.Glorp.StoreForGlorpBrowserEnvironment on: storePackage) openEditor</body><body package="Store-UI">makeCurrentPackage	self packages size = 1 ifFalse: 		[^Dialog warn: #PleaseSelectExactlyOnePackage &lt;&lt; #store &gt;&gt; 'Please select exactly one package.'].	Registry currentPackage: self packages first</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>actions</category><body package="Store-UI">reloadVersions	self unimplemented</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>text differencing</category><body package="Store-UI">differenceEmphasis		^#bold</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>resources</category><body package="Store-UI">dbNonCodePackageImage	^DbNonCodePackageImage</body><body package="Store-UI">nonCodePackageImageModified	^ModifiedNonCodePackageImage</body><body package="Store-UI">nonCodePackageImageUnmodified	^UnmodifiedNonCodePackageImage</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>utilities</category><body package="Store-UI">addPackageDialog	| pkgName newPkg |	pkgName := (Dialog				request: #EnterANameForThePackage &lt;&lt; #store &gt;&gt; 'Enter a name for the package:' 				initialAnswer: ''				onCancel: [String new]) 					trimBlanks.	pkgName isEmpty ifTrue: [^nil].	[Registry isPackageLoaded: pkgName]		whileTrue: 			[pkgName := Dialog						request:  ( (#_1sIsAlreadyInUseNameForThePackage &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is already in use.&lt;n&gt;Enter another name for the package.') expandMacrosWith: pkgName)						initialAnswer: pkgName						onCancel: [nil].			pkgName isNil ifTrue: [^nil]].	newPkg := PackageModel named: pkgName.	^newPkg</body><body package="Store-UI">compareBundle: aBundle1 with: aBundle2 	"Compare all packages that are in aBundle1 with 	packages that are contained by aBundle2. 	Answer a collection of pairs. First element of each pair 	is one of my packages or nil. Second element of each pair 	is one of packages belonging to aBundle or nil. 	Note that aBundle1 and aBundle2 may have different names"	| result |	(Gathering for: aBundle1) started.	result := self compareHomogeneousItems: aBundle1 leafItems with: aBundle2 leafItems.	(Gathering for: aBundle1) finished.	^result</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>label utilities</category><body package="Store-UI">addCheckMarkToImage: anImage 	| cp |	cp := CompositePart new.	cp add: self checkMark at: 0 @ 0.	cp add: anImage at: self checkMarkWidth @ 0.	^cp</body><body package="Store-UI">iconForPundle: aPundle	^aPundle toolListIcon</body><body package="Store-UI">labelForPundle: aPundle reversed: isReversed inView: aSelectionView 	^self		labelWithString: (aPundle stringKey: #())		icon: (self iconForPundle: aPundle)		disabled: false		reversed: isReversed		checked: false		inView: aSelectionView		offsetForCheckedView: false</body><body package="Store-UI">labelWithString: aString icon: anImage disabled: isDisabled reversed: isReversed checked: isChecked inView: aSelectionView offsetForCheckedView: isOffset 	"If isOffset is true, the returned LabalAndIcon will be offset so that the icon 	will align with the icons of other labels preceeded by check marks."	| label disabledText |	label := LabelAndIcon with: aString attributes: aSelectionView textStyle.	isDisabled		ifTrue: 			[disabledText := aString asText.			disabledText emphasizeAllWith: #color -&gt; aSelectionView inactiveForegroundColor.			label text: disabledText].	label icon: (isChecked ifTrue: [self addCheckMarkToImage: anImage] ifFalse: [anImage]).	isOffset ifTrue: [label offset: self checkMarkWidth @ 0].	isReversed		ifTrue: 			[label := ReversingWrapper on: label.			label reverse setValue: true].	^label</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>private</category><body package="Store-UI">checkMark	^LabelAndIcon checkMark</body><body package="Store-UI">checkMarkGap	^4</body><body package="Store-UI">checkMarkWidth	^self checkMark width + self checkMarkGap</body><body package="Store-UI">compareHomogeneousItems: aCollectionOfPundles with: anotherCollectionOfPundles	"Compare two lists that contain pundles with 	Answer a collection of pairs. First element of each pair 	is one from list1 or nil. Second element of each pair 	is one from list2 or nil."		| gatheredPundles versionMatchedPundles session |	gatheredPundles := Dictionary new.	versionMatchedPundles := OrderedCollection new.	session := Store.Glorp.StoreLoginFactory currentStoreSession.	anotherCollectionOfPundles do: [:each | gatheredPundles at: each name put: (each asStoreComparisonObjectIn: session)].	aCollectionOfPundles do:		[:each | 		| other |		(Gathering for: (each asStoreComparisonObjectIn: session)) started.		other := gatheredPundles			at: each name			ifAbsent:				[versionMatchedPundles add: (Array with: (each asStoreComparisonObjectIn: session) with: nil).				nil].		other notNil ifTrue:			[(other sameVersionAs: (each asStoreComparisonObjectIn: session)) ifFalse: 				[versionMatchedPundles add: (Array 					with: (each asStoreComparisonObjectIn: session) 					with: (other asStoreComparisonObjectIn: session))].			gatheredPundles at: each name put: nil].		(Gathering for: (each asStoreComparisonObjectIn: session)) finished].	gatheredPundles do: [:each | each notNil ifTrue: [versionMatchedPundles add: (Array with: nil with: (each asStoreComparisonObjectIn: session))]].	^versionMatchedPundles</body><body package="Store-UI">install	self updateImages.</body><body package="Store-UI">obsolete	super obsolete.	ObjectMemory removeDependent: self</body><body package="Store-UI">update: anAspect with: arguments from: anObject	"Check for return from snapshot to install."	anAspect == #returnFromSnapshot		ifTrue: [self install]</body><body package="Store-UI">updateImages	| mono |	mono := Screen default colorDepth == 1.	IsMonocrome = mono ifTrue: [^self].	IsMonocrome := mono.	IsMonocrome		ifTrue: 			[ModifiedBundleImage := self bundleImageModifiedBW.			ModifiedPackageImage := self packageImageModifiedBW.			ModifiedNonCodePackageImage := self nonCodePackageImageModifiedBW]		ifFalse: 			[ModifiedBundleImage := OpaqueImage figure: (CachedImage on: self bundleImageModifiedC)						shape: (CachedImage on: self bundleImageModifiedBW).			ModifiedPackageImage := OpaqueImage figure: (CachedImage on: self packageImageModifiedC)						shape: (CachedImage on: self packageImageModifiedBW).			ModifiedNonCodePackageImage := OpaqueImage figure: (CachedImage on: self nonCodePackageImageModifiedC)						shape: (CachedImage on: self nonCodePackageImageModifiedBW)].	DbBundleImage := self dbBundleImageBW.	DbNonCodePackageImage := self dbNonCodePackageImageBW.	DbPackageImage := self dbPackageImageBW.	UnmodifiedBundleImage := self bundleImageUnmodifiedBW.	UnmodifiedPackageImage := self packageImageUnmodifiedBW.	UnmodifiedNonCodePackageImage := self nonCodePackageImageUnmodifiedBW</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>class initialization</category><body package="Store-UI">initialize	"self initialize"	ObjectMemory removeDependent: self.	ObjectMemory addDependent: self.	self updateImages.</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>generated resources</category><body package="Store-UI">bundleImageModified	^ListIconLibrary visualFor: #modifiedBundle</body><body package="Store-UI">bundleImageUnmodified	^ListIconLibrary visualFor: #bundle</body><body package="Store-UI">dbBundleImage	^ListIconLibrary visualFor: #bundle</body><body package="Store-UI">dbPackageImage	^ListIconLibrary visualFor: #package</body><body package="Store-UI">packageImageModified	^ListIconLibrary visualFor: #modifiedPackage</body><body package="Store-UI">packageImageUnmodified	^ListIconLibrary visualFor: #package</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>menu messages</category><body package="Store-UI-Definition Comparison">findDiffs	| main other mainFragments otherFragments |	main := text1 value asText.	other := text2 value asText.	mainFragments := main wordAndWhitespaceFragments.	otherFragments := other wordAndWhitespaceFragments.	(mainFragments differences: otherFragments)		do: #applyAnyDifferenceTextEmphases.	(self builder componentAt: #text1Widget) widget model value: main.	(self builder componentAt: #text2Widget) widget model value: other</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>aspects</category><body package="Store-UI-Definition Comparison">enableTextAccept	^false</body><body package="Store-UI-Definition Comparison">postOpenWith: aBuilder 	(self text1 value isEmpty not and: [self text2 value isEmpty not])		ifTrue: [self findDiffs]</body><body package="Store-UI-Definition Comparison">text1	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^text1 isNil ifTrue: [text1 := String new asValue] ifFalse: [text1]</body><body package="Store-UI-Definition Comparison">text2	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^text2 isNil ifTrue: [text2 := String new asValue] ifFalse: [text2]</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>menus</category><body package="Store-UI-Definition Comparison">customTextMenu	"No accept from this browser."	| mb |	mb := MenuBuilder new.	mb		addFindReplaceUndo;		line;		addCopyCutPaste;		line;		add: (#cancel &lt;&lt; #store &gt;&gt; 'cancel') asString -&gt; #cancel.	^mb menu</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>text differencing</category><body package="Store-UI-Definition Comparison">differenceEmphasis		^Array with: #color -&gt; ColorValue red with: #bold</body></methods><methods><class-id>Store.TextDifferenceBrowser class</class-id> <category>instance creation</category><body package="Store-UI-Definition Comparison">compare: text1 with: text2 		| instance |	instance := self new.	instance text1 value: text1.	instance text2 value: text2.	instance openInterface: #briefSpec</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>accessing</category><body package="Store-UI">fillListWith: aCollection		self itemsInList list: aCollection</body><body package="Store-UI">listMenu	^[| menu |	menu := (self class mainMenu atNameKey: #Action) submenu.	menu augmentFrom: self class		to: DefinitionsForListPane		menuName: #listMenu		for: self.	menu]</body><body package="Store-UI">listOfThings	^self</body><body package="Store-UI">listTitle	self subclassResponsibility</body><body package="Store-UI">reportUnpackagedDefinitionNamed: aString		Transcript		show:				(#AtLeastOneVersionOf1sNoPackage &lt;&lt; #store &gt;&gt; 'At least one version of &lt;1s&gt; has no associated package.&lt;n&gt;It has been excluded from the version list'						expandMacrosWith: aString);		cr</body><body package="Store-UI">selections	^self itemsInList selections</body><body package="Store-UI">title	^title ifNil: ['']</body><body package="Store-UI">title: aString	title := aString</body><body package="Store-UI">tool: aDefinitionForListTool	tool := aDefinitionForListTool</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>actions</category><body package="Store-UI">inspectSelected	self itemsInList selections first inspect</body><body package="Store-UI">selectionsUpdated	self subclassResponsibility</body><body package="Store-UI">updateStatusPaneWith: aStringOrText	tool updateStatusPaneWith: aStringOrText</body><body package="Store-UI">updateStatusUsing: package		| statusText hasDefinition |	hasDefinition := (package isGlorpProxy not or: [package isInstantiated]).	hasDefinition ifFalse: [package getValue].	statusText := TextStream on: String new.	package ifNotNil:		[statusText emphasis: #bold.		statusText nextPutAll: (#PackageOrBundleColon &lt;&lt; #store &gt;&gt; '&lt;1?Package:Bundle&gt;: ' expandMacrosWith: package isPackage).		statusText emphasis: #none.		statusText nextPutAll: package name.		statusText space.		statusText nextPutAll: package versionString].	self updateStatusPaneWith: statusText contents</body><body package="Store-UI">updateTextPaneWith: aStringOrText	tool updateTextPaneWith: aStringOrText</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>aspects</category><body package="Store-UI">itemsInList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^itemsInList isNil		ifTrue:			[itemsInList := MultiSelectionInList new]		ifFalse:			[itemsInList]</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>interface opening</category><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self itemsInList selectionIndexHolder onChangeSend: #selectionsUpdated to: self</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane class</class-id> <category>utility</category><body package="Store-UI">fileOutDifferencesBetweenBundle: aPundle and: anotherPundle into: fileName using: session	"For the bundle and its contents, we compute a sequence of key-value version pairs.	Our task is to file out those things in the 'value' side of the pair that do not match what is in the key side of the pair.	We also delete anything that is solely in the key side.  (As these deletions do not need package locations, 	we supply the package name from the value-side, not the key-side;  set the realPackage of the PsuedoPackage if this 	is ever a problem).	We process all packages in load order followed by all bundles in reverse load order, so structure changes occur after	creation/change of the item being restructured.  It is the 'to' load order that we aim at, so we process in that order 	first and then add any 'from' changes at the end, expecting them to be deletions."		| comparitor fileManager fromPundleItems toPundleItems matchups |	fromPundleItems := aPundle leafItems.	fromPundleItems addAll: (aPundle withAllItems asOrderedCollection removeAll: fromPundleItems; reverse).	toPundleItems := anotherPundle leafItems.	toPundleItems addAll: (anotherPundle withAllItems asOrderedCollection removeAll: toPundleItems; reverse).	matchups := OrderedCollection new.	toPundleItems do:		[:each |		| fromPundle |		fromPundle := fromPundleItems 			detect: [:eachPundle | eachPundle name = each name and: [eachPundle isBundle = each isBundle]]			ifNone: [nil].		fromPundle isNil ifTrue: [matchups add: (fromPundle ifNil: [Store.PseudoPackage new]) -&gt; each]].	fromPundleItems do:		[:each |		| toPundle |		toPundle := toPundleItems 			detect: [:eachPundle | eachPundle name = each name and: [eachPundle isBundle = each isBundle]]			ifNone: [nil].		matchups add: each -&gt; (toPundle ifNil: [Store.PseudoPackage new])].	[fileManager := SourceCodeStream write: fileName encoding: #Source.	fileManager timeStamp.	matchups do:		[:eachPair |		(Store.FilingOut for: eachPair value) started.		comparitor := self packageComparitorClass			differencesWithPropertiesBetween: (eachPair key asStoreComparisonObjectIn: session)			and: (eachPair value asStoreComparisonObjectIn: session).		fileManager sourceFormatter attributeFor: #package compute: [:ignore | eachPair value name].		fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | eachPair value name].		comparitor fileOutMainToOtherDifferencesOn: fileManager.		(Store.FilingOut for: eachPair value) finished]] ensure: [fileManager close]</body><body package="Store-UI">fileOutDifferencesBetweenPackage: aPundle and: anotherPundle into: fileName using: session		| comparitor fileManager |	comparitor := self packageComparitorClass		differencesWithPropertiesBetween: (aPundle asStoreComparisonObjectIn: session)		and: (anotherPundle asStoreComparisonObjectIn: session).	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	fileManager sourceFormatter attributeFor: #package compute: [:ignore | aPundle name].	fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aPundle name].	comparitor fileOutMainToOtherDifferencesOn: fileManager] ensure: [fileManager close]</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane class</class-id> <category>constants</category><body package="Store-UI">packageComparitorClass	^PackageComparitor</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>accessing</category><body package="Store-UI">fillInFor: aStoreBundle	(Gathering for: aStoreBundle) started.	self itemsInList list: (TreeModel 		on: (aStoreBundle)		displayRoot: true		childrenWith: [:each | each containedItems]).	self itemsInList tree expandFully: 1.	(Gathering for: aStoreBundle) finished.</body><body package="Store-UI">listTitle	^self title.</body><body package="Store-UI">onlyOneItemSelected	^self itemsInList selection notNil</body><body package="Store-UI">selections	| selected |	^(selected := self itemsInList selection) isNil		ifTrue: [#()] 		ifFalse: [OrderedCollection with: selected]</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>actions</category><body package="Store-UI">browseSelectedVersion	| package |	package := self itemsInList selection.	(StoreRefactoringBrowser		openOnEnvironment: (Store.Glorp.StoreForGlorpBrowserEnvironment on: package)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-UI">compareSelectionWith	| pundle target |	pundle := self itemsInList selection.	target := pundle class selectStoreVersionOf: pundle name in: pundle session.	target ifNotNil: [ComparePackages compareFrom: pundle to: target]</body><body package="Store-UI">enclosingBundles	| package enclosingBundles |	package := self itemsInList selection.	(enclosingBundles := package enclosingComponents) isEmpty		ifTrue: [^Dialog warn: #NoEnclosingBundles &lt;&lt; #store &gt;&gt; 'No enclosing bundles.'].	DefinitionForListTool forPackages: enclosingBundles</body><body package="Store-UI">fileOutSelectedVersion	| package fileName fileManager |	package := self itemsInList selection.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: package name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			package fileOutOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: package) finished].</body><body package="Store-UI">graphSelectedVersion	| package |	package := self itemsInList selection.	package isImageModel ifFalse: [package := StorePackage cachedItemFor: package].	VersionGraph browseVersionsOfPundle: package.</body><body package="Store-UI">inspectSelected	self itemsInList selection inspect</body><body package="Store-UI">selectionsUpdated	| updateText item |	updateText := TextStream on: String new.	(item := self itemsInList selection) notNil		ifTrue: 			[updateText emphasis: #bold.			updateText nextPutAll: item name.			updateText space.			updateText nextPutAll: item versionString.			updateText space.			updateText space.			updateText nextPutAll: (Policies blessingPolicy blessingName: item currentBlessingLevel).			updateText cr.			updateText cr.			updateText emphasis: #none.			item blessings do:				[:eachBlessing | eachBlessing blessingLevel = -1 ifFalse: [eachBlessing printWideOn: updateText]]	.			updateText cr.			updateText emphasis: (Array with: #color-&gt; ColorValue navy).			updateText nextPutAll: item comment.			updateText cr].		self itemsInList selection			ifNil: [self updateStatusPaneWith: '']			ifNotNil: [:value | self updateStatusUsing: value package].	self updateTextPaneWith: updateText contents</body><body package="Store-UI">setBlessingLevel	| package |	package := self itemsInList selection.	BlessingDialog setBlessingFor: package. 	(self builder componentAt: #SelectionList) widget invalidate.	self selectionsUpdated</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>aspects</category><body package="Store-UI">itemsInList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^itemsInList isNil		ifTrue:			[itemsInList := SelectionInTree new]		ifFalse:			[itemsInList]</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>interface opening</category><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI">setUpListViewWith: aBuilder		| widget |	widget := (aBuilder componentAt: #SelectionList) widget.	widget useImage: #toolListIcon</body></methods><methods><class-id>Store.StoreWorkActivity</class-id> <category>accessing</category><body package="Store-Base">actionText	^self subclassResponsibility</body><body package="Store-Base">announce	"Bullet proof announcing these things. We don't want any misbehaved clients bringing store loads to a halt."	[self class notifications announce: self] on: Error		do: 			[:ex |			Transcript				show: 'StoreWorkActivity error: ' , ex errorString;				cr]</body><body package="Store-Base">codeComponent	^self subject</body><body package="Store-Base">codeComponent: anObject	self subject: anObject</body><body package="Store-Base">componentName	"Assume that subject is a CodeComponent"	^self codeComponent shortItemString</body><body package="Store-Base">finished	self isFinished: true.	self announce</body><body package="Store-Base">isFinished: aBoolean	isFinished := aBoolean</body><body package="Store-Base">started	self isFinished: false.	self announce</body><body package="Store-Base">subject	^subject</body><body package="Store-Base">subject: anObject	subject := anObject</body></methods><methods><class-id>Store.StoreWorkActivity</class-id> <category>testing</category><body package="Store-Base">isComplement: anActivity	^self class = anActivity class and: 			[subject = anActivity codeComponent				and: [self isStarted = anActivity isFinished]]</body><body package="Store-Base">isFinished	^isFinished</body><body package="Store-Base">isStarted	^self isFinished not</body></methods><methods><class-id>Store.StoreWorkActivity</class-id> <category>initialize-release</category><body package="Store-Base">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	subject := nil.	isFinished := false.	^self</body></methods><methods><class-id>Store.StoreWorkActivity class</class-id> <category>instance creation</category><body package="Store-Base">for: aCodeComponent	^self new codeComponent: aCodeComponent</body><body package="Store-Base">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Store.StoreWorkActivity class</class-id> <category>announcements</category><body package="Store-Base">notifications	^DefaultNotifications ifNil: [DefaultNotifications := Announcer new]</body></methods><methods><class-id>Store.LoadingParcel</class-id> <category>accessing</category><body package="Store-UI">actionText	^(#Loading &lt;&lt; #store &gt;&gt; 'Loading') asString</body><body package="Store-UI">componentName	^self parcelName , ' (Parcel)'</body><body package="Store-UI">parcelName	^subject</body></methods><methods><class-id>Store.LoadingParcel class</class-id> <category>instance creation</category><body package="Store-UI">named: aString	^self new codeComponent: aString</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	resolutions := Dictionary new.</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>accessing</category><body package="Store-Merge Management">baseLabel	^''</body><body package="Store-Merge Management">bundleStructureDisplayString	^(#BracketBundleStructureBracket &lt;&lt; #store &gt;&gt; '[Bundle Structure]') asString</body><body package="Store-Merge Management">imageLabel	^''</body><body package="Store-Merge Management">longTreeName	^self shortTreeName</body><body package="Store-Merge Management">mergeDisplayName		^name</body><body package="Store-Merge Management">name		^name</body><body package="Store-Merge Management">named: aString	name := aString</body><body package="Store-Merge Management">rejectBlockFor: aSymbol		^aSymbol = #all 		ifTrue: [[:each | false]] 		ifFalse: 			[aSymbol = #conflicts 				ifTrue: [[:each | each hasNoConflicts]] 				ifFalse: [[:each | each isResolved]]]</body><body package="Store-Merge Management">resolutionForDifference: aPseudoDifference fromVersion: aPackage	| resolver resolution |	aPseudoDifference differenceName = self bundleStructureDisplayString ifTrue: [^self].	resolver := resolutions 		at: aPseudoDifference differenceName 		ifAbsentPut: [aPseudoDifference resolutionClass new].	resolver ownerName: name.	aPseudoDifference mainObject ifNotNil: 		[:value | 		| originalResolver |		aPseudoDifference mainPackage isVersionLoaded ifTrue:			[(resolver original isNil or: [aPseudoDifference mainPackage isImageModel]) ifTrue: 				[(aPseudoDifference otherPackage isNil or: [aPseudoDifference otherPackage pseudoPackage not]) ifTrue:					[resolver original: (originalResolver := StandardResolution 						package: aPseudoDifference mainPackage 						resolver: value)]].			(aPseudoDifference otherPackage notNil and: [aPseudoDifference otherPackage pseudoPackage not and: [aPseudoDifference otherObject isNil]]) ifTrue: 				[resolution := RemovalResolution 					fromBaseResolution: aPseudoDifference otherPackage -&gt; value 					fromPackage: aPackage.				resolver base: resolution.				resolver addAlternative: resolution]].		resolver addAlternative: (originalResolver ifNil: [StandardResolution 			package: aPseudoDifference mainPackage 			resolver: value]).		resolver isPropertyResolver ifTrue: [resolver propertyKey: aPseudoDifference mainObject key]].	aPseudoDifference otherObject ifNotNil: 		[:value | 		| target |		resolver addAlternative: (target := StandardResolution 			package: aPseudoDifference otherPackage 			resolver: value).		resolver base: target.		aPseudoDifference mainObject isNil			ifTrue: 				[resolution := RemovalResolution 					fromBaseResolution: aPackage -&gt; value 					fromPackage: aPackage.				resolver addAlternative: resolution.				resolver original: (aPseudoDifference otherPackage isVersionLoaded 					ifTrue: 						[aPackage isImageObject 							ifTrue: [resolution] 							ifFalse: [target]] 					ifFalse: [(target package isVersionLoaded and: [target sameAsImageUsing: resolver]) ifTrue: [target]])]			ifFalse: 					[aPseudoDifference otherPackage isVersionLoaded					ifTrue: [(resolver original isNil or: [aPseudoDifference otherPackage isImageModel]) ifTrue: [resolver original: target]]					ifFalse: [(resolver original isNil and: [target sameAsImageUsing: resolver]) ifTrue: [resolver original: target]]].		resolver isPropertyResolver ifTrue: [resolver propertyKey: aPseudoDifference otherObject key]].	^resolver</body><body package="Store-Merge Management">resolutionIcon	^self isResolved		ifFalse: [self class unresolvedImage]		ifTrue: 			[self hasBeenApplied				ifTrue: 					[self isApplyable						ifTrue: [self class appliedImage]						ifFalse: [self class unappliedImage]]				ifFalse: 					[self isApplyable 						ifTrue: [self class resolvedImage]						ifFalse: [self class unapplyableImage]]].</body><body package="Store-Merge Management">resolutionLabel	^''</body><body package="Store-Merge Management">resolutions	^resolutions</body><body package="Store-Merge Management">shortTreeName		^self mergeDisplayName , self applyableString</body><body package="Store-Merge Management">sortedListResolutionValues: aSymbol	| result |	result := OrderedCollection new.	resolutions values 		inject: result 		into: 			[:sum :each | 			sum addAll: (each sortedListResolutionValues: aSymbol).			sum].	^result</body><body package="Store-Merge Management">sortedTreeResolutionValues: aSymbol	| rejectBlock |	rejectBlock := self rejectBlockFor: aSymbol.	^resolutions values reject: rejectBlock</body><body package="Store-Merge Management">standardResolutionAlternative		self resolutions do: [:each | each standardResolutionAlternative ifNotNil: [:value | ^value]].	^nil</body><body package="Store-Merge Management">totalResolutionItems	"I add one for me, and add my children"	^resolutions inject: 0 into: [:sum :each | sum + 1 + each totalResolutionItems]</body><body package="Store-Merge Management">typeIcon	^nil</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>testing</category><body package="Store-Merge Management">applyable	^resolutions values allSatisfy: #applyable</body><body package="Store-Merge Management">canBrowseVersions	^true</body><body package="Store-Merge Management">displaysProtocolStatus	^false</body><body package="Store-Merge Management">hasBeenApplied	^resolutions values allSatisfy: #hasBeenApplied</body><body package="Store-Merge Management">hasNoConflicts	resolutions isEmpty ifTrue: [^false].	^resolutions values allSatisfy: #hasNoConflicts</body><body package="Store-Merge Management">isApplyable	^true</body><body package="Store-Merge Management">isBundleStructureResolver	^false</body><body package="Store-Merge Management">isForClass	^false</body><body package="Store-Merge Management">isForNamespace	^false</body><body package="Store-Merge Management">isForProperties	^false</body><body package="Store-Merge Management">isMethodResolver	^false</body><body package="Store-Merge Management">isResolved	resolutions isEmpty ifTrue: [^false].	^resolutions values allSatisfy: #isResolved</body><body package="Store-Merge Management">isResolver	^false</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>visiting</category><body package="Store-Merge Management">collectResolutionsInto: aSet	resolutions do: [:each | each collectResolutionsInto: aSet].</body><body package="Store-Merge Management">resolutionsDo: aBlock	resolutions do: [:ea| ea resolutionsDo: aBlock]</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>resolving</category><body package="Store-Merge Management">doNotResolve	resolutions do: [:each | each doNotResolve]</body><body package="Store-Merge Management">makeResolutionProposals		self resolutions do: [:each | each makeResolutionProposals]</body><body package="Store-Merge Management">proposedResolutions	| proposedResolutions |	proposedResolutions := OrderedCollection new.	self resolutions do: [:each | proposedResolutions addAll: each proposedResolutions].	^proposedResolutions</body><body package="Store-Merge Management">removeEmptyResolvers	| keysToRemove |	keysToRemove := OrderedCollection new.	self resolutions do: [:each | 		each removeEmptyResolvers.		each resolutions isEmpty ifTrue: [keysToRemove add: each name]].	keysToRemove do: [:eaKey|		resolutions removeKey: eaKey ifAbsent: [nil]].	(resolutions size = 1			and: [resolutions values any isBundleStructureResolver			and: [resolutions values any alternatives isEmpty]])		ifTrue: [resolutions := Dictionary new].</body><body package="Store-Merge Management">resolution: aResolutionPackageItem	resolutions do: [:each | each resolution: aResolutionPackageItem].</body><body package="Store-Merge Management">unApply	resolutions do: [:each | each unApply].</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>displaying</category><body package="Store-Merge Management">applyableString	^self isApplyable not		ifTrue: [(#SpaceParenInformationalColonNotResolvableParen &lt;&lt; #store &gt;&gt; ' (Informational: Not Resolvable)') asString]		ifFalse: ['']</body><body package="Store-Merge Management">browseVersions	self subclassResponsibility</body><body package="Store-Merge Management">createModificationDisplayRecords	| list collector |	list := List new.	collector := Set new.	resolutions do: [:each | each collectResolutionsInto: collector].	collector := collector reject: #isAbsentResolution.	collector do:		[:each |		(list contains: [:eachDisplayRecord | eachDisplayRecord package = each package])			ifFalse: [list add: each]].	(list allSatisfy: [:each | each image not]) ifTrue: [list add: ResolutionPackageItem forAbsentImage].	list := (list asSortedCollection: [:each :other | each sortKey &lt; other sortKey]).	^list</body><body package="Store-Merge Management">explanationText	| stream |	stream := WriteStream on: String new.	stream 		nextPut: $[;		nextPutAll: name;		nextPut: $].	self isApplyable		ifTrue: [stream nextPutAll: ((#Does1qHaveQllProposedResolutions &lt;&lt; #store &gt;&gt; ' has &lt;1?:not &gt;been fully resolved.') expandMacrosWith: self isResolved)]		ifFalse: [stream nextPutAll: ((#IsForInformationOnlyAndIsNotResolvable &lt;&lt; #store &gt;&gt; ' is for information purposes only, and is not resolvable.&lt;n&gt;The object this is resolved to was a Class (&lt;1s&gt;) and is now a Shared Variable representing another class (&lt;2s&gt;)&lt;n&gt;To see all modifications, it is important that this package be reconciled with the database.') 			expandMacrosWith: self name			with: self name asQualifiedReference value class instanceBehavior name)].	stream cr.	(self isApplyable and: [self isResolved]) ifTrue:		[stream nextPutAll: ((#ResolutionHas1qBeenApplied &lt;&lt; #store &gt;&gt; 'Resolutions have&lt;1?: not yet&gt; been applied to the image') expandMacrosWith: self hasBeenApplied)].	^stream contents</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>private - accessing</category><body package="Store-Merge Management">sortedResolutionsSelectedBy: aSelectBlock	"Aggressively cache shortTreeName, and sort the results only once"	| selectedResolutions sortKeys sortedKeys answer |	selectedResolutions := OrderedCollection new.	resolutions do: [:each | (aSelectBlock value: each) ifTrue: [selectedResolutions add: each]].	sortKeys := (1 to: selectedResolutions size) collect: [:each | (selectedResolutions at: each) shortTreeName -&gt; each].	sortedKeys := sortKeys asSortedCollection: [:x :y | x key &lt; y key].	answer := Array new: sortedKeys size.	sortedKeys doWithIndex:		[:each :eachWriteIndex |			answer				at: eachWriteIndex				put: (selectedResolutions at: each value)		].	^answer</body></methods><methods><class-id>Store.Glorp.AbstractResolutions class</class-id> <category>instance creation</category><body package="Store-Merge Management">named: aString	| instance |	instance := self new.	instance named: aString.	^instance</body><body package="Store-Merge Management">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.AbstractResolutions class</class-id> <category>resources</category><body package="Store-Merge Management">appliedImage	^MergeIcons applied</body><body package="Store-Merge Management">resolvedImage	^MergeIcons resolved</body><body package="Store-Merge Management">unappliedImage	^MergeIcons unapplied</body><body package="Store-Merge Management">unapplyableImage	^MergeIcons unapplyable</body><body package="Store-Merge Management">unresolvedImage	^MergeIcons unresolved</body></methods><methods><class-id>Store.Glorp.PundleResolutions</class-id> <category>displaying</category><body package="Store-Merge Management">browseVersions	| list session |	(Gathering for: name) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value package session].	list := Store.Glorp.StorePackage allVersionsWithName: name in: session.	(Gathering for: name) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: name)].	Store.Glorp.DefinitionForListTool forPackages: list</body><body package="Store-Merge Management">explanationText	| values |	values := self createModificationDisplayRecords.	^(#X1shas2pversions &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has &lt;2p&gt; versions.')		expandMacrosWith: name		with: values size</body></methods><methods><class-id>Store.Glorp.PundleResolutions</class-id> <category>accessing</category><body package="Store-Merge Management">pundle	^pundle</body><body package="Store-Merge Management">pundle: aStorePundleOrPundleModel	pundle := aStorePundleOrPundleModel</body><body package="Store-Merge Management">resolutionForDifference: aPseudoDifference fromVersion: aPackage	| classifiedResolutions |	aPseudoDifference isBundleStructureOnly ifTrue: [^self].	classifiedResolutions := resolutions at: aPseudoDifference classListName ifAbsentPut: [aPseudoDifference referencesHolderClass named: aPseudoDifference classListName].	aPseudoDifference modifiedMethodsSharedAndProperties do:		[:each |		classifiedResolutions resolutionForDifference: each fromVersion: aPackage].</body><body package="Store-Merge Management">sortedTreeResolutionValues: aSymbol		| values result rejectBlock |	rejectBlock := self rejectBlockFor: aSymbol.	result := OrderedCollection new.	values := self sortedResolutionsSelectedBy: [:each | each isForClass and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | each isForNamespace and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | each isForProperties and: [(rejectBlock value: each) not]].	result addAll: values.	^result</body><body package="Store-Merge Management">structureDifferenceUsing: aPseudoDifference fromVersion: aPackage	| resolver resolution |	(aPseudoDifference hasBothDefinitions and: [aPseudoDifference mainPackage structure isSameSequenceAs: aPseudoDifference otherPackage structure])		ifTrue: [^self].	resolver := resolutions 		at: self bundleStructureDisplayString		ifAbsentPut: [BundleStructureResolver new].	aPseudoDifference mainPackage ifNotNil: 		[:value |		aPseudoDifference mainPackage isVersionLoaded ifTrue:			[(resolver original isNil or: [aPseudoDifference mainPackage isImageModel]) ifTrue: 				[resolver original: (StandardResolution 					package: aPseudoDifference mainPackage 					resolver: value structure)]].		resolver addAlternative: (StandardResolution 			package: aPseudoDifference mainPackage 			resolver: value structure)].	aPseudoDifference otherPackage ifNotNil: 		[:value | 		| target |		aPseudoDifference otherPackage pseudoPackage ifFalse:			[resolver addAlternative: (target := StandardResolution 				package: aPseudoDifference otherPackage 				resolver: value structure).			resolver base: target.			aPseudoDifference mainPackage isNil				ifTrue: 					[resolution := RemovalResolution 						fromBaseResolution: aPackage -&gt; aPackage structure 						fromPackage: aPackage.					resolver addAlternative: resolution.					resolver original: (aPseudoDifference otherPackage isVersionLoaded 						ifTrue: 							[aPackage isImageObject 								ifTrue: [resolution] 								ifFalse: [target]] 						ifFalse: [resolution])]				ifFalse: 						[aPseudoDifference otherPackage isVersionLoaded						ifTrue: [(resolver original isNil or: [aPseudoDifference otherPackage isImageModel]) ifTrue: [resolver original: target]]						ifFalse: [resolver original isNil ifTrue: [resolver original: target]]]]].	resolver ownerName: name.	^resolver</body><body package="Store-Merge Management">typeIcon	^pundle toolListIcon</body></methods><methods><class-id>Store.Glorp.PundleResolutions</class-id> <category>testing</category><body package="Store-Merge Management">isBundle	^pundle isBundle</body><body package="Store-Merge Management">isPackage	^self isBundle not</body></methods><methods><class-id>Store.Glorp.PundleResolutions class</class-id> <category>instance creation</category><body package="Store-Merge Management">fromPundle: aPundle	| instance |	instance := self named: aPundle name.	instance pundle: aPundle.	^instance</body></methods><methods><class-id>Store.Reconciling</class-id> <category>accessing</category><body package="Store-Difference Management">actionText	^(#Reconciling &lt;&lt; #store &gt;&gt; 'Reconciling') asString</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>printing</category><body package="Store-Change Management">printOn: aStream	aStream nextPutAll: 		( (#ChangesFor1s2s3s &lt;&lt; #store &gt;&gt; 'Changes for &lt;1s&gt; (&lt;2s&gt;/&lt;3s&gt;)') expandMacrosWithArguments: 			( Array 				with: pundle1  name				with: pundle1 version				with: pundle2 version			)		)</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>private</category><body package="Store-Change Management">addOtherChanges	"Add other changes to the changesets.	Ensure that we remove any property keys that are volatile or system only.  The list of 	these property keys has changed over time so there is not point tracking them."		| props1 props2 |	props1 := pundle1 propertiesForFileOut.	props2 := pundle2 propertiesForFileOut.	CodeComponent systemOnlyPropertyKeys do:		[:each | 		props1 removeKey: each ifAbsent: [nil].		props2 removeKey: each ifAbsent: [nil]].	props1 associationsDo:		[:each | 		((props2 includesKey: each key) and: [each value = (props2 at: each key)])			ifFalse:				[changeSet1 addPropertyChange: each key.				changeSet2 addPropertyChange: each key]].	props2 keysDo:		[:each | 		(props1 includesKey: each)			ifFalse:				[changeSet1 addPropertyChange: each.				changeSet2 addPropertyChange: each]].	IncrementNotification raiseSignal</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>accessing</category><body package="Store-Change Management">changeSet1	"Answer the change set 'belonging' to  package1. That is, changes that	when applied to package2 will result in package1."	^changeSet1</body><body package="Store-Change Management">changeSet2	"Answer the change set 'belonging' to  package2. That is, changes that	when applied to package1 will result in package2."	^changeSet2</body><body package="Store-Change Management">changeSetFor: anInteger	^anInteger == 1		ifTrue: [ changeSet1 ]		ifFalse: [ changeSet2 ].</body><body package="Store-Change Management">otherPackageFor: anInteger	^anInteger == 1		ifTrue: [ pundle2 ]		ifFalse: [ pundle1 ].</body><body package="Store-Change Management">otherPundleFor: anInteger	^anInteger == 1		ifTrue: [ pundle2 ]		ifFalse: [ pundle1 ].</body><body package="Store-Change Management">pundle1	^pundle1</body><body package="Store-Change Management">pundle2	^pundle2</body><body package="Store-Change Management">pundleFor: anInteger	^anInteger == 1		ifTrue: [ pundle1 ]		ifFalse: [ pundle2 ].</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>initialization</category><body package="Store-Change Management">fromPackageDifferences: pkgDiffs	pundle1 := pkgDiffs pkgSide: 1.	pundle2 := pkgDiffs pkgSide: 2.	changeSet2 := pkgDiffs changeSet.	changeSet1 := changeSet2 reflection.	self addOtherChanges.</body><body package="Store-Change Management">recurseChanges	"Only required for bundles"</body><body package="Store-Change Management">reflectChangesFrom: changeSet	"Answer a changeSet that reflects the changes in changeSet."	^changeSet reflection.</body><body package="Store-Change Management">with: aPackage parent: bPackage	"Initialize the receiver for comparing aPackage with bPackage where it can be assumed	that aPackage's changeset reflects all the changes between them."	pundle1 := aPackage.	pundle2 := bPackage.	changeSet1 := aPackage changeSet.	changeSet2 := self reflectChangesFrom: changeSet1.</body><body package="Store-Change Management">with: aPackage with: bPackage	"Initialize the receiver for comparing aPackage with bPackage."	pundle1 := aPackage.	pundle2 := bPackage.	changeSet1 := XChangeSet new.	changeSet2 := XChangeSet new.	( pundle1 sameVersionAs: pundle2 )		ifFalse:			[ [ self requiresFullCompare				ifTrue:					[ Notice 						showProgress:  ((#ComparingVersionsOfPackage1s &lt;&lt; #store &gt;&gt; 'Comparing versions of package &lt;1s&gt;.')											expandMacrosWith: pundle1 name)						complete: self calcItemCount 						while: [ self calculateChanges ]						title: #Reconciling &lt;&lt; #store &gt;&gt; 'Reconciling'.					]				ifFalse: [ self calculateChanges ].			  ] on: DbRegistry errorSignals do: [ :ex | ex outer ].			]</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>fileout</category><body package="Store-Change Management">changedPropertiesFor: id	| props all |	props := IdentityDictionary new.	all := ( self pundleFor: id ) properties.	( self changeSetFor: id ) properties do:		[ :key | props at: key put: ( all at: key ifAbsent: [ ] ) ].	^props.</body><body package="Store-Change Management">fileOutChangesFor: id	| fileName stream |	fileName := ( self pundleFor: id ) name.	fileName := Dialog			requestNewFileName: #FileOutChangesOn &lt;&lt; #store &gt;&gt; 'File out changes on'			default: (Filename filterFilename: fileName, '-diffs.st'). 	fileName isEmpty ifTrue: [ ^nil ].	stream := SourceCodeStream  write: fileName.	self recurseChanges.		"ensure we get the whole thing."	[ Notice 		showProgress:  ( (#FilingOut1sChanges &lt;&lt; #store &gt;&gt; 'Filing out &lt;1s&gt; changes.')  expandMacrosWith: pundle1 name )		complete: self itemCount 		while:			[ stream timeStamp. 			stream addComment: 				( (#ChangesFrom1sTo2s &lt;&lt; #store &gt;&gt; 'Changes from: &lt;1s&gt;  to: &lt;2s&gt;') 					expandMacrosWith: ( self otherPundleFor: id ) displayString 					with: ( self pundleFor: id ) displayString ).			stream deferInitializations.			self fileOutChangesFor: id on: stream.			stream finishInitializations] 		title: #Store &lt;&lt; #store &gt;&gt; 'Store'	] ensure: [ stream close ].</body><body package="Store-Change Management">fileOutChangesFor: id on: stream	self fileOutChangesFor: id within: nil on: stream</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>testing</category><body package="Store-Change Management">requiresFullCompare	"Answer true if a source code comparison is neccessary, false if a db compare is good enough."		( pundle1 isLoaded and: 			[ pundle1 hasTrace not or: [ pundle1 userWantsFullCompare ] ] 	)		ifTrue: [ ^true ].	( pundle2 isLoaded and:			[ pundle2 hasTrace not or: [ pundle2 userWantsFullCompare ] ]	)		ifTrue: [ ^true ].		^false</body></methods><methods><class-id>Store.PundleChanges class</class-id> <category>instance creation</category><body package="Store-Change Management">fromPackageDifferences: pkgDiffs	^self basicNew fromPackageDifferences: pkgDiffs.</body><body package="Store-Change Management">new	"Use #with:with: "	^self shouldNotImplement</body><body package="Store-Change Management">with: pkg1 parent: pkg2	^self basicNew		with: pkg1 parent: pkg2;		yourself.</body><body package="Store-Change Management">with: pkg1 with: pkg2	^( pkg1 isLoaded and: [ pkg1 dbTrace == pkg2 primaryKey ] )		ifTrue: [ self  with: pkg1 parent: pkg2 ]		ifFalse: [ self basicNew with: pkg1 with: pkg2 ]</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>private</category><body package="Store-Change Management">addDataChanges	"Add data changes to the change sets."			| chg datum2 |	pundle2 isLoaded		ifFalse: [ pundle2 dataWithSource ].	"cache sources"	pundle1 dataWithSource do:		[ :datum | 		chg := Change new dataKey: datum dataKey.		datum isInClass			ifTrue: [ chg classSymbol: datum absoluteOwnerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: datum absoluteOwnerName asSymbol ].		chg dataKey: datum dataKey.		( self pundle2 includesDatum:  datum )			ifTrue:				[ datum2 := self pundle2 datum: datum dataKey forOwnerNamed: datum absoluteOwnerName.				( datum sourceMatches: datum2 )					ifFalse: 						[ changeSet1 doSubdefChange: chg change.						changeSet2 doSubdefChange: chg change.						].				]			ifFalse: 				[ changeSet1 doSubdefChange: chg add.				changeSet2 doSubdefChange: chg remove.				].		IncrementNotification raiseSignal.		].	pundle2 data do:		[ :datum |  | ownerName |		ownerName := datum ownerName.		( pundle1 includesDatum: datum )			ifFalse: 				[ chg := Change new dataKey: datum dataKey.				datum isInClass					ifTrue: [ chg classSymbol: ownerName ]					ifFalse: [ chg nameSpaceSymbol: ownerName ].				changeSet2 doSubdefChange: chg add.				changeSet1 doSubdefChange: chg remove.				].		]</body><body package="Store-Change Management">addDefClassChanges	"Add def class changes to the change sets."	| chg cls2 |	pundle2 isLoaded		ifFalse: [ pundle2 classesWithSource ].		"cache definitions"	pundle1 classesWithSource do:		[ : cls1 |		chg := Change new classSymbol: cls1 absoluteName.		( pundle2 includesClassNamed: cls1 absoluteName )			ifFalse: 				[ changeSet1 doClassChange: chg add.				changeSet2 doClassChange: chg removeDefinition.				]			ifTrue: 				[ cls2 := pundle2 classInPackageNamed: cls1 absoluteName meta: false. 				( cls1 primaryKey = cls2 primaryKey )					ifFalse:						[ cls1 definition =  cls2 definition							ifFalse: 								[ changeSet1 doClassChange: chg change.								changeSet2 doClassChange: chg change.								].						( cls1 comment string equalsAcrossPlatforms:  cls2 comment string )							ifFalse: 								[ changeSet1 doClassChange: chg comment.								changeSet2 doClassChange: chg comment.								].						]				].		IncrementNotification raiseSignal.		].	pundle2 classesDefinedInPackage do:		[ : cls |		( pundle1 includesClassNamed: cls absoluteName )			ifFalse: 				[ chg := Change new classSymbol: cls absoluteName.				changeSet2 doClassChange: chg add.				changeSet1 doClassChange: chg removeDefinition.				].		].</body><body package="Store-Change Management">addDefNameSpaceChanges	"Add def namespace changes to the change sets."	| chg ns2 |	pundle2 isLoaded		ifFalse: [ pundle2 nameSpacesWithSource ].		"cache definitions"	pundle1 nameSpacesWithSource do:		[ : ns1 |		chg := Change new nameSpaceSymbol: ns1 absoluteName.		( ns2 := pundle2 nameSpaceInPackageNamed: ns1 absoluteName ) ~~ nil			ifTrue: 				[ ns1 definition =  ns2 definition					ifFalse: 						[ changeSet1 doNameSpaceChange: chg change.						changeSet2 doNameSpaceChange: chg change.						].				( ns1 comment equalsAcrossPlatforms:  ns2 comment )					ifFalse: 						[ changeSet1 doNameSpaceChange: chg comment.						changeSet2 doNameSpaceChange: chg comment.						].				]			ifFalse: 				[ changeSet1 doNameSpaceChange: chg add.				changeSet2 doNameSpaceChange: chg removeDefinition.				].		IncrementNotification raiseSignal.		].	pundle2 nameSpacesDefinedInPackage do:		[ : cls |		( pundle1 includesNameSpaceNamed: cls absoluteName )			ifFalse: 				[ chg := Change new nameSpaceSymbol: cls absoluteName.				changeSet2 doNameSpaceChange: chg add.				changeSet1 doNameSpaceChange: chg removeDefinition.				].		].</body><body package="Store-Change Management">addMethodChanges	"Add method changes to the change sets."			| chg meth2 |	pundle2 isLoaded		ifFalse: [ pundle2 methodsWithSource ].		"to cache sources"	pundle1 methodsWithSource do:		[ :meth |		chg := Change new classSymbol: meth classNameWithMeta; selector: meth selector.		( pundle2 includesMethod: meth )			ifFalse: 				[ changeSet1 doSubdefChange: chg add.				changeSet2 doSubdefChange: chg remove.				]			ifTrue:				[ meth2 := pundle2 method: meth selector forClassNamed: meth absoluteClassName meta: meth isMeta.				( meth primaryKey = meth2 primaryKey )					ifFalse:						[ ( meth sourceMatches: meth2 )							ifFalse: 								[ changeSet1 doSubdefChange: chg change.								changeSet2 doSubdefChange: chg change.								].						]				].		IncrementNotification raiseSignal.		].	pundle2 methods do:		[ :meth |		( pundle1 includesMethod: meth )			ifFalse: 				[ chg := Change new classSymbol: meth className; selector: meth selector.				changeSet2 doSubdefChange: chg add.				changeSet1 doSubdefChange: chg remove.				].		]</body><body package="Store-Change Management">calculateChanges	 ( pundle1 isLoaded or: [ pundle2 isLoaded ] )		ifTrue: 			[ self addDefClassChanges.			self addDefNameSpaceChanges.			self addMethodChanges.				self  addDataChanges.			self addOtherChanges			] 		ifFalse: [ self fromPackageDifferences: ( PackageDifferences with: pundle1 with: pundle2 ) ]</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>accessing</category><body package="Store-Change Management">calcItemCount	"Answer a count for time to calculate changes."	^pundle1 itemCount.</body><body package="Store-Change Management">itemCount	^changeSet1 itemCount.</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>fileout</category><body package="Store-Change Management">fileOutChangesFor: anInteger within: aBundle on: aStream		| package |	package := self pundleFor: anInteger.	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[(aStream sourceFormatter)			attributeFor: #package compute: [:ignore | package name];			attributeForMethods: #package compute: [:ignore :moreIgnore | package name].		package fileOutProperties: (self changedPropertiesFor: anInteger) on: aStream].	(self changeSetFor: anInteger) fileOutOn: aStream for: package within: aBundle</body></methods><methods><class-id>Store.PackageChanges class</class-id> <category>instance creation</category><body package="Store-Change Management">fromPackageDifferences: pkgDiffs	^self basicNew fromPackageDifferences: pkgDiffs.</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management">addAlternative: aDefinition	alternatives add: aDefinition</body><body package="Store-Merge Management">alternatives	^alternatives</body><body package="Store-Merge Management">applied	^applied</body><body package="Store-Merge Management">applied: aBoolean	(applied and: [aBoolean not]) ifTrue: [self undo].	self basicApplied: aBoolean</body><body package="Store-Merge Management">applyable	^applyable</body><body package="Store-Merge Management">base	^base</body><body package="Store-Merge Management">base: anObject	base := anObject</body><body package="Store-Merge Management">containingPackageModel	| resolution |	resolution := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	^resolution package storeModel</body><body package="Store-Merge Management">original	^original</body><body package="Store-Merge Management">original: anObject	original := anObject</body><body package="Store-Merge Management">ownerName	^ownerName</body><body package="Store-Merge Management">ownerName: aString	ownerName := aString</body><body package="Store-Merge Management">proposed	^proposed</body><body package="Store-Merge Management">proposed: anObject	proposed := anObject</body><body package="Store-Merge Management">proposedResolutions	^Array with: self</body><body package="Store-Merge Management">resolutions	^Array with: self</body><body package="Store-Merge Management">sortedListResolutionValues: aSymbol	(aSymbol = #unresolved and: [self isResolved]) ifTrue: [^#()].	(aSymbol = #conflicts and: [self hasNoConflicts]) ifTrue: [^#()].	^Array with: self</body><body package="Store-Merge Management">sortedTreeResolutionValues: aSymbol	^#()</body><body package="Store-Merge Management">standardResolutionAlternative		^alternatives detect: [:each | each isStandardResolution] ifNone: [nil]</body><body package="Store-Merge Management">totalResolutionItems	^1</body><body package="Store-Merge Management">undoValue	^undo</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^true</body><body package="Store-Merge Management">displaysProtocolStatus	^false</body><body package="Store-Merge Management">hasBeenApplied	^applied</body><body package="Store-Merge Management">hasNoConflicts	^alternatives size &lt; 3</body><body package="Store-Merge Management">hasPotentialOverride		applied ifTrue: [^false].	self existingOverrides notEmpty ifTrue: [^true].	self isMove ifTrue: [^false].	^self existingDefinitionPackage 		ifNil: [false]		ifNotNil:			[:value |			(proposed isNil or: [proposed isDoNothingResolution])				ifTrue: [false]				ifFalse: 					[proposed 						ifNil: [false]						ifNotNil: [value name ~= (proposed package ifNotNil: [:package | package name])]]]</body><body package="Store-Merge Management">isAbsentResolution	^false</body><body package="Store-Merge Management">isApplyable	^applyable</body><body package="Store-Merge Management">isBundleStructureResolver	^false</body><body package="Store-Merge Management">isClassDefinitionResolver	^false</body><body package="Store-Merge Management">isCommentResolver	^false</body><body package="Store-Merge Management">isDefintionResolver	^false</body><body package="Store-Merge Management">isMethodResolver	^false</body><body package="Store-Merge Management">isMove	^false</body><body package="Store-Merge Management">isNameSpaceDefinitionResolver	^false</body><body package="Store-Merge Management">isNoOp	^self isNoResolve or: [self proposed notNil and: [self proposed isNoOpResolution]]</body><body package="Store-Merge Management">isNoResolve	^self proposed notNil and: [self proposed isAbsentResolution]</body><body package="Store-Merge Management">isPotentialMove	^false</body><body package="Store-Merge Management">isPropertyResolver	^false</body><body package="Store-Merge Management">isProposedForRemoval	^proposed isRemovalResolution</body><body package="Store-Merge Management">isResolved	^self proposed notNil</body><body package="Store-Merge Management">isResolver	^true</body><body package="Store-Merge Management">isSharedResolver	^false</body><body package="Store-Merge Management">sameDefinitionAs: anObject	"If we get here, it can not be the same, because the resolver is not comparable to the image"	^false</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">basicApplied: aBoolean	applied := aBoolean</body><body package="Store-Merge Management">className	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^#Unknown &lt;&lt; #store &gt;&gt; 'Unknown'].	^alternative value className</body><body package="Store-Merge Management">createModificationDisplayRecords	| list collector |	list := List new.	collector := Set new.	self collectResolutionsInto: collector.	list addAll: (collector asSortedCollection: [:each :other | each sortKey &lt; other sortKey]).	^list</body><body package="Store-Merge Management">owningEnvironment	"When parsing classes, the owningEnvironment is the nil class"	^nil class</body><body package="Store-Merge Management">parseDefinition: aString in: anEnvironment		^[Compiler new 		parseWithSignalling: aString asString 		in: anEnvironment 		noPattern: self usePatternWhenParsing 		notifying: (SignallingCompilerErrorHandler handler: SilentCompilerErrorHandler new)]			on: CompilerError			do: 				[:exception |				exception return: (self raiseNoticeFor: exception)].</body><body package="Store-Merge Management">parseText: aString		| nodeHolder |	self owningEnvironment ifNil: [^self unavailableOwnerNotice].	nodeHolder := self parseDefinition: aString in: self owningEnvironment.	^(nodeHolder isKindOf: Boolean) 		ifTrue: [nodeHolder]		ifFalse: [self validateParse: nodeHolder].</body><body package="Store-Merge Management">raiseNoticeFor: aCompilerError	aCompilerError type = #syntax ifTrue: 		[Dialog warn: #SyntaxError &lt;&lt; #dialogs &gt;&gt; 'Syntax Error'.		^nil].	^Dialog confirm: (#UnableToValidateChange &lt;&lt; #store &gt;&gt; 'Unable To Validate Change&lt;n&gt;Accept Change?') expandMacros</body><body package="Store-Merge Management">unavailableOwnerNotice	Dialog warn: ((#TheClass1sMustAndApplyResolved &lt;&lt; #store &gt;&gt; 'The class "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept edited code.&lt;n&gt;Resolve conflicts in the class definition, if any,&lt;n&gt;and "Apply Resolved".') expandMacrosWith: self className).	^false</body><body package="Store-Merge Management">usePatternWhenParsing		^true</body><body package="Store-Merge Management">validateParse: aNodeHolder	"Answer false if there is a problem, otherwise, answer true"	self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">absentFromPackageString		^MergeTool absentFromThisPackageString</body><body package="Store-Merge Management">applyableString	^self isApplyable not		ifTrue: [(#SpaceParenInformationalColonNotResolvableParen &lt;&lt; #store &gt;&gt; ' (Informational: Not Resolvable)') asString]		ifFalse: ['']</body><body package="Store-Merge Management">baseDefinitionText	base ifNil: [^nil].	^self definitionTextFor: base</body><body package="Store-Merge Management">baseLabel	^base ifNotNil: [base package displayString]</body><body package="Store-Merge Management">browseVersions	self subclassResponsibility</body><body package="Store-Merge Management">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value definitionString</body><body package="Store-Merge Management">definitionTextFrom: aResolutionPackageItem	(self alternatives 		detect: [:each | each = aResolutionPackageItem alternative]		ifNone: [nil]) ifNotNil: [:value | ^self definitionTextFor: value].	^self absentFromPackageString.</body><body package="Store-Merge Management">explanationText		| stream description |	stream := WriteStream on: String new.	description := self mergeDisplayName.	description first = $[ ifFalse: [stream nextPut: $[].	stream nextPutAll: description.	description first = $[ ifFalse: [stream nextPut: $]].	applyable		ifTrue:			[stream nextPutAll: (#Has1qNotHadAResolutionSelected &lt;&lt; #store &gt;&gt; ' has &lt;1?:not &gt;had a resolution selected.' expandMacrosWith: self isResolved)]		ifFalse: [stream nextPutAll: self unapplyableString].	^stream contents</body><body package="Store-Merge Management">imageLabel	^original ifNotNil: [original package displayString]</body><body package="Store-Merge Management">labelInView: aView nameStyle: aSymbol 	^(LabelAndIcon with: (self perform: aSymbol) attributes: aView textStyle) 		icon: (VisualRow withAll: (Array with: self resolutionIcon with: self typeIcon with: self listIcon))</body><body package="Store-Merge Management">listIcon	^Behavior toolListIcon</body><body package="Store-Merge Management">longListName	| string |	string := self longTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">longOwnerName	"Examples: 		Root.Smalltalk.UI.Blah, 		Smalltalk.UI.Blah, 		UI.Blah, 		Root.Frost.Blah"	| name |	name := self ownerName.	(name includes: $.) ifTrue: 		[^('Root.*' match: name)			ifTrue: [name]			ifFalse: 				[('Smalltalk.*' match: name)					ifTrue: ['Root.' , name]					ifFalse: ['Root.Smalltalk.', name]]].	^'Root.Smalltalk.' , name</body><body package="Store-Merge Management">longTreeName	| string |	string := self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">mergeDisplayName		^self class name</body><body package="Store-Merge Management">moveFromPackage: aString	^(#starsThisDefinitionIsBeingMovedFromPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition is being moved from package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management">moveToPackage: aString	^(#starsThisDefinitionIsBeingMovedToPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition is being moved to package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management">movedFromPackage: aString	^(#starsThisDefinitionIsMovedFromPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition was moved from package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management">movedToPackage: aString	^(#starsThisDefinitionIsWasMovedToPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition was moved to package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management">originalDefinitionText	original ifNil: [^nil].	^self definitionTextFor: original</body><body package="Store-Merge Management">overrideEmpahsis		^Array with: #bold with: #color -&gt; ColorValue orange</body><body package="Store-Merge Management">proposedDefinitionText	proposed ifNil: [^nil].	^self definitionTextFor: proposed</body><body package="Store-Merge Management">removeFromImageString		^MergeTool removeFromImageString</body><body package="Store-Merge Management">resolutionIcon	^self isResolved		ifFalse: [self class unresolvedImage]		ifTrue: 			[self hasBeenApplied				ifTrue: 					[(self isApplyable and: [self isNoOp not])						ifTrue: [self class appliedImage]						ifFalse: [self class unappliedImage]]				ifFalse: 					[self isApplyable 						ifTrue: [self class resolvedImage]						ifFalse: [self class unapplyableImage]]].</body><body package="Store-Merge Management">resolutionLabel	^proposed ifNotNil: [proposed package displayString]</body><body package="Store-Merge Management">shortListName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management">typeIcon	applyable ifFalse: [^GeneralIcons padlock].	(proposed notNil and: [proposed isNoOpResolution]) ifTrue: [^MergeIcons doNotResolve].	(base isNil and: [original isNil and: [proposed notNil and: [proposed isAbsentResolution]]]) ifTrue: [^GeneralIcons warning].	self isMove ifTrue: 		[^self isProposedForRemoval			ifTrue: [self class moveOutImage]			ifFalse: [self class moveImage]].	(base isNil and: [original isNil or: [proposed value = original value]]) ifTrue: [^MergeIcons add].	(proposed notNil and: [proposed isRemovalResolution]) ifTrue: [^MergeIcons remove].	^MergeIcons modify</body><body package="Store-Merge Management">unapplyableString		^(#IsForInformationOnlyGeneral &lt;&lt; #store &gt;&gt; ' is for information purposes only, and is not resolvable.') asString</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	self subclassResponsibility</body><body package="Store-Merge Management">applyAsRemove	self subclassResponsibility</body><body package="Store-Merge Management">doExtraUndoWork	"I do nothing myself, but a subclass may do things"</body><body package="Store-Merge Management">doNotResolve	| possibleNoOp |	self undo.	possibleNoOp := alternatives detect: [:each | each isNoOpResolution] ifNone: [nil].	self proposed: (proposed isNil		ifTrue: [possibleNoOp ifNil: [NoOpResolution new]]		ifFalse: [proposed isNoOpResolution ifTrue: [proposed] ifFalse: [possibleNoOp ifNil: [NoOpResolution new]]]).	alternatives detect: [:each | each isNoOpResolution] ifNone: [self addAlternative: proposed].</body><body package="Store-Merge Management">existingDefinitionPackage	^nil</body><body package="Store-Merge Management">existingOverrides	^#()</body><body package="Store-Merge Management">makeProposalForAbsentInImageAndAllRemovals		| alternativesWithoutBaseOrOriginal |	applied ifTrue: [^self].	alternativesWithoutBaseOrOriginal := alternatives select: [:each | each ~= original and: [each ~= base]].	(applied not and: 		[self original isNil and: 		[alternativesWithoutBaseOrOriginal allSatisfy: [:each | each isRemovalResolution]]])			ifTrue: [self basicApplied: true]</body><body package="Store-Merge Management">makeResolutionProposals	"It is possible to get 0 alternatives, we'll just empty those out later"		| alternativesWithoutBase alternativesWithoutImage alternativeSameAsImage |	proposed ifNotNil: [^self].	alternativesWithoutBase := self alternatives reject: [:each | each = self base].	alternativesWithoutBase size = 1 ifTrue: [self proposed: alternativesWithoutBase any].	proposed ifNotNil: [proposed package isImageObject ifTrue: [original := proposed]].	original notNil ifTrue:		[alternativesWithoutImage := alternativesWithoutBase reject: [:each | each = original].		alternativeSameAsImage := alternativesWithoutImage 			detect: [:each | each package name = original package name and: [(self definitionTextFor: each) = (self definitionTextFor: original) and: [(self protocolStringFor: each) = (self protocolStringFor: original)]]] 			ifNone: [nil].		alternativeSameAsImage notNil ifTrue:			[self proposed: alternativeSameAsImage.			self basicApplied: true]].	(proposed notNil and: 		[original notNil and: 		[proposed isRemovalResolution not and: 		[proposed package = original package]]]) 			ifTrue: [self basicApplied: true].	(proposed notNil and: 		[original isNil and: 		[base notNil and: 		[base isStandardResolution and: 		[proposed isRemovalResolution and: 		[base sameAsImageUsing: self]]]]])		 ifTrue: [original := base].	self makeProposalForAbsentInImageAndAllRemovals</body><body package="Store-Merge Management">markApplied	self basicApplied: true</body><body package="Store-Merge Management">markUnapplied	self basicApplied: false.	undo := nil</body><body package="Store-Merge Management">markUnapplyable	applyable := false.	self proposed: NoOpResolution new.	self basicApplied: false</body><body package="Store-Merge Management">pairedUndo	undo ifNil: [^self].	self privateUndo</body><body package="Store-Merge Management">privateUndo	| changeManager |	changeManager := RefactoryChangeManager instance.	[changeManager performChange: undo] on: Error		do: 			[:exception |			Transcript				show: (#nUndoingFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Undoing Previus Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).			exception return].	self doExtraUndoWork.	undo := refactoring := nil</body><body package="Store-Merge Management">protocolStringFor: aResolution	^nil</body><body package="Store-Merge Management">resolution: aResolutionPackageItemOrNil	self basicApplied: false.	self undo.	aResolutionPackageItemOrNil ifNil: [self proposed: nil. ^self].	(aResolutionPackageItemOrNil isAbsentResolution and: [aResolutionPackageItemOrNil alternative isNil]) ifTrue: 		[^original isNil			ifTrue: 				[self proposed: AbsentResolution new.				aResolutionPackageItemOrNil proposed: true]			ifFalse: 				[self proposed: (alternatives detect: [:each | each isAbsentResolution] ifNone: [nil]).				proposed isNil ifTrue: [^self]]].	self proposed: (aResolutionPackageItemOrNil isForGeneralResolution		ifTrue: [alternatives detect: [:each | each package = aResolutionPackageItemOrNil package] ifNone: [nil]]		ifFalse: [alternatives detect: [:each | each = aResolutionPackageItemOrNil alternative] ifNone: [nil]]).	proposed isNil ifTrue: [^self].	self isMove ifTrue: [self movePair unApply].</body><body package="Store-Merge Management">unApply	self basicApplied: false</body><body package="Store-Merge Management">undo	undo		ifNil: 			["#pairedUndo is called to prevent a recursion"			self isMove ifTrue: [self movePair pairedUndo].			^self].	"override to extract code to privateUndo"	self privateUndo</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	alternatives := OrderedSet new.	self basicApplied: false.	applyable := true</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>visiting</category><body package="Store-Merge Management">collectResolutionsInto: aSet	| item resolution |	(base isNil and: [original isNil])		ifTrue: 			[item := ResolutionPackageItem forAbsentBaseAndImage.			item proposed: (proposed notNil and: [proposed isAbsentResolution]).			"item alternative: proposed."			(item proposed and: [applied]) ifTrue: [item applied: true].			aSet add: item]		ifFalse: 			[(alternatives anySatisfy: #isRemovalResolution) ifFalse: 				[base ifNil: 					[resolution := ResolutionPackageItem forAbsentBase.					(proposed notNil and: [proposed isAbsentResolution or: [proposed isRemovalResolution]]) ifTrue: [resolution proposed: true].					aSet add: resolution].				original ifNil: [aSet add: ResolutionPackageItem forAbsentImage]]].	aSet addAll: (alternatives collect: [:each | ResolutionPackageItem on: each in: self]).	(aSet allSatisfy: [:each | each image not]) ifTrue: 		[(aSet detect: #base ifNone: [nil])			ifNil: [aSet add: ResolutionPackageItem forAbsentImage]			ifNotNil: [:value | value image: true]]</body><body package="Store-Merge Management">resolutionsDo: aBlock	aBlock value: self.</body></methods><methods><class-id>Store.Glorp.ChangeResolver class</class-id> <category>instance creation</category><body package="Store-Merge Management">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.ChangeResolver class</class-id> <category>resources</category><body package="Store-Merge Management">appliedImage	^MergeIcons applied</body><body package="Store-Merge Management">doNotResolveImage	^MergeIcons doNotResolve</body><body package="Store-Merge Management">moveImage	^MergeIcons move</body><body package="Store-Merge Management">moveOutImage	MoveOutIcon ifNil: [#{ChangeResolver.MoveOutIcon} initialize].	^MoveOutIcon</body><body package="Store-Merge Management">resolvedImage	^MergeIcons resolved</body><body package="Store-Merge Management">unappliedImage	^MergeIcons unapplied</body><body package="Store-Merge Management">unapplyableImage	^MergeIcons unapplyable</body><body package="Store-Merge Management">unresolvedImage	^MergeIcons unresolved</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">displaysProtocolStatus	^true</body><body package="Store-Merge Management">isMeta	| storeObject |	storeObject := (base ifNil: [original ifNil: [proposed]]).	(storeObject isNil or: [storeObject isString or: [storeObject isStandardResolution not]]) ifTrue: [storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^false]].	^storeObject value isMeta</body><body package="Store-Merge Management">isMethodResolver	^true</body><body package="Store-Merge Management">isMove	^movePair notNil</body><body package="Store-Merge Management">isPotentialMove	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	| class realSelector |	proposed ifNil: [^true].	proposed isRemovalResolution ifFalse: [^true].	(class := base value correspondingImageClass) ifNil: [^false].	realSelector := self realSelectorToBeRemovedFromClass: class.	(class selectors includes: realSelector) ifFalse: [^false].	^(Registry containingPackageForSelector: realSelector asSymbol class: class)		name = proposed package name		or: 			[Override				isOverriddenSelector: realSelector asSymbol				class: class				in: proposed package storeModel]</body><body package="Store-Merge Management">isProtocolChangeOnly	| currentMethod currentSource |	(currentMethod := proposed value correspondingImageMethod) ifNil: [^false].	currentMethod protocol = proposed value protocol ifTrue: [^false].	(currentSource := currentMethod getSource) ifNil: [^false].	^currentSource string = proposed value getSource string.</body><body package="Store-Merge Management">realSelectorToBeRemovedFromClass: class	| storeMethod realSelector |	proposed isRemovalResolution ifFalse: [self error: 'This method should only be used on removals'].	storeMethod := proposed base value.	realSelector := (class selectors includes: storeMethod selector)				ifTrue: [storeMethod selector]				ifFalse: [Parser new parseSelector: storeMethod source].	^realSelector</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">baseProtocol	base ifNil: [^''].	^base value protocol</body><body package="Store-Merge Management">browseVersions	| alternative list selectorName session |	alternative := self standardResolutionAlternative.	alternative		ifNil: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self mergeDisplayName)].	selectorName := alternative value selector asString.	session := alternative package session.	(Gathering for: self ownerName , '&gt;&gt;' , self shortTreeName) started.	list := self owningEnvironment				ifNil: [StoreMethodInPackage allVersionsWithName: selectorName in: session]				ifNotNil: 					[StoreMethodInPackage						allVersionsWithName: selectorName						inClass: self owningEnvironment absoluteName						in: session].	(Gathering for: self ownerName , '&gt;&gt;' , self shortTreeName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: selectorName)].	DefinitionForListTool forMethods: list</body><body package="Store-Merge Management">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[movePair notNil ifTrue: 			[^applied 				ifTrue: [self movedToPackageString]				ifFalse: [self moveToPackageString]].		^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value ifNotNil: 		[:value | 		value isString			ifTrue: [value]			ifFalse: [	value definitionString]]</body><body package="Store-Merge Management">listIcon	^CompiledMethod toolListIcon</body><body package="Store-Merge Management">longListName	| string |	string := self longTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">longTreeName	| string |	string := self longOwnerName, '&gt;&gt;', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">mergeDisplayName	| storeMethod extension |	storeMethod := alternatives detect: [:each | each isStandardResolution] ifNone: [^'unknonwn'].	extension := storeMethod value isMeta		ifTrue: [' (class method)']		ifFalse: [''].	^'#', storeMethod value name , extension</body><body package="Store-Merge Management">moveFromPackageString	^self moveFromPackage: movePair proposed package name</body><body package="Store-Merge Management">moveToPackageString	^self moveToPackage: movePair proposed package name</body><body package="Store-Merge Management">movedFromPackageString	^self movedFromPackage: movePair proposed package name</body><body package="Store-Merge Management">movedToPackageString	^self movedToPackage: movePair proposed package name</body><body package="Store-Merge Management">originalProtocol	original ifNil: [^''].	original isRemovalResolution ifTrue: [^''].	^original value protocol</body><body package="Store-Merge Management">otherString	^self isApplyable not		ifTrue: [(#MethodSpaceParenInformational1s2s &lt;&lt; #store &gt;&gt; ' (Informational: Not Resolvable)&lt;n&gt;This method was originally on class &lt;1s&gt;&lt;n&gt;That class is now a Shared Variable (&lt;2s&gt;)') expandMacrosWith: ownerName with: (ownerName asQualifiedReference value name)]		ifFalse: ['']</body><body package="Store-Merge Management">proposedProtocol	proposed ifNil: [^''].	^proposed value isString		ifTrue: ['']		ifFalse: 			[proposed isRemovalResolution 				ifTrue: [proposed value value protocol] 				ifFalse: 					[proposed isUserInputResolution						ifTrue: [proposed protocol ifNil: ['']]						ifFalse: [proposed value protocol]]]</body><body package="Store-Merge Management">protocolStringFrom: aResolutionPackageItem	(self alternatives 		detect: [:each | each = aResolutionPackageItem alternative]		ifNone: [nil]) ifNotNil: 			[:value | 			value isRemovalResolution ifTrue: [^nil].			value isDoNothingResolution ifTrue: [^nil].			^value isUserInputResolution				ifTrue: [value protocol asString]				ifFalse: [value value protocol]].	^nil</body><body package="Store-Merge Management">selector	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	^alternative value selector</body><body package="Store-Merge Management">shortListName	| string |	string := self ownerName, '&gt;&gt;', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">shortTreeName	| string |	string := self mergeDisplayName, self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management">unapplyableString	^#MethodSpaceParenInformational1s2s3s &lt;&lt; #store &gt;&gt;			' (Informational: Not Resolvable) is for information purposes only, and is not resolvable.&lt;n&gt;This method was originally on class &lt;1s&gt;&lt;n&gt;That class is now a Shared Variable (&lt;2s&gt;)&lt;n&gt;To see all modifications, it is important that this package (&lt;3s&gt;) be reconciled with the database.'		expandMacrosWith: ownerName		with: ownerName asQualifiedReference value class instanceBehavior name		with: (base ifNil: [original]) package name</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	| existingPackage |	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isNoOpResolution]]]) 			ifTrue: [^true].	self isMove ifTrue: [^self applyMove].	self hasOverrideAndShouldApply ifFalse: [^false].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isUserInputResolution ifTrue: [^self applyUserInput].	self isProtocolChangeOnly ifTrue: [^self applyProtocolChange].	(existingPackage := self existingDefinitionPackage) isNil ifTrue: [^self applyChange].	^existingPackage = proposed package storeModel		ifTrue: [self applyChange]		ifFalse: [self applyOverride].</body><body package="Store-Merge Management">applyAsRemove	"isOverridden		ifTrue: RemoveMethodChange		ifFalse: 			isTheOverridden				ifTrue: RemoveOverrideChange				ifFalse: RestoreOverrideChange"	| realSelector class overrides targetOverride changeManager |	(class := base value correspondingImageClass) ifNil: [^true].	realSelector := self realSelectorToBeRemovedFromClass: class.	(class includesSelector: realSelector) 		ifFalse: [^true].	refactoring := (overrides := self existingOverrides) isEmpty		ifTrue: [RemoveMethodChange remove: realSelector from: class]		ifFalse: [(targetOverride := Override overrideForSelector: realSelector class: class in: proposed package storeModel) notNil			ifTrue: [RemoveOverrideChange for: targetOverride]			ifFalse: [RestoreOverrideChange for: overrides last]].	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do: 			[:exception | 			Transcript show: (#nApplyingRemovalMethodFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Method &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self ownerName, '&gt;&gt;', self shortTreeName).			exception return: false].</body><body package="Store-Merge Management">applyChange	| changeManager |	^[refactoring := AddMethodChange		compile: proposed value definitionString		in: self owningEnvironment		classified: proposed value protocol.	refactoring package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	changeManager performChange: refactoring.	undo := changeManager undoChange.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingMethodChangeFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying Method Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">applyMove	| targetResolver changeManager |	applied ifTrue: [^true].	targetResolver := proposed isRemovalResolution		ifTrue: [movePair proposed]		ifFalse: [proposed].	refactoring := MoveMethodToPackageChange		class: self owningEnvironment		selector: targetResolver value selector		package: targetResolver package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	self markApplied.	movePair markApplied.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingMethodMoveFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying Method Move Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">applyOverride	| changeManager |	refactoring := CompositeRefactoryChange named: 'Merge Override Method'.	refactoring addChange: (MoveMethodToOverrideInPackageChange 		class: self owningEnvironment		selector: proposed value selector		package: proposed package storeModel).	refactoring addChange: (AddOverrideChange for: (Override forSelector: proposed value selector class: self owningEnvironment)).	refactoring addChange: (AddMethodChange		compile: proposed value definitionString		in: self owningEnvironment		classified: proposed value protocol).	refactoring changes last package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do: 			[:exception |			Transcript 				show: (#nApplyingMethodOverrideFailed1s &lt;&lt; #store					&gt;&gt; '&lt;n&gt;Applying Method Override Change Failed &lt;2s&gt; : &lt;1s&gt;'				expandMacrosWith: exception messageText				with: self mergeDisplayName).			exception return: false]</body><body package="Store-Merge Management">applyProtocolChange	| changeManager |	refactoring := (MoveToProtocolChange 		class: proposed value correspondingImageClass		protocol: proposed value protocol		symbol: proposed value selector).	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do: 			[:exception | 			Transcript show: (#nApplyingMethodProtocolFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Change Protocol of Method &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self ownerName, '&gt;&gt;', self shortTreeName).			exception return: false].</body><body package="Store-Merge Management">applyUserInput	| changeManager |	refactoring := (AddMethodChange		compile: proposed text		in: self owningEnvironment		classified: proposed protocolName).	refactoring package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do: 			[:exception | 			Transcript show: (#nApplyingMethodChangeFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Method Change Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self mergeDisplayName).			exception return: false].</body><body package="Store-Merge Management">existingDefinitionPackage		^Registry trueContainingPackageForSelector: self selector class: (self owningEnvironment ifNil: [^nil])</body><body package="Store-Merge Management">existingOverrides	^(Override overridesForSelector: self selector class: self owningEnvironment) ifNil: [#()].</body><body package="Store-Merge Management">hasOverrideAndShouldApply		self existingDefinitionPackage ifNotNil:		[:value | 		value name = proposed package name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed package name) ifFalse: 				[Transcript show: (#nDidNotApplyOverrideOfMethod1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of method &lt;1s&gt; in &lt;2s&gt;' 					expandMacrosWith: self longTreeName					with: proposed package name).				^false]]].	^true</body><body package="Store-Merge Management">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingChangeWillCause1snIn2sAsOverideIn3snnProceed &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;Method "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longTreeName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">owningEnvironment	| resolution imageClass |	ownerName asQualifiedReference bindingOrNil ifNotNil: 		[:value | value value ifNotNil: 			[:class | 				^self isMeta				ifTrue: [class class]				ifFalse: [class]]].	resolution := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	imageClass := resolution value correspondingImageClass.	^self isMeta		ifTrue: [imageClass class]		ifFalse: [imageClass]</body><body package="Store-Merge Management">usePatternWhenParsing		^false</body><body package="Store-Merge Management">validateParse: aNodeHolder	"Answer false if there is a problem, true otherwise"		| mainStatementNode alternative alternativeSelector |	self owningEnvironment ifNil:		[self unavailableOwnerNotice.		^nil].	mainStatementNode := aNodeHolder node.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	alternativeSelector := alternative resolver selector.	alternativeSelector = mainStatementNode selector		ifFalse: [			Dialog warn: #SelectorDefinitionMustNotChange &lt;&lt; #store &gt;&gt; 'Selector definition must not change'.			^false].	^true</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management">movePair	^movePair</body><body package="Store-Merge Management">movePair: aMethodChangeResolver	movePair := aMethodChangeResolver</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>proposal calculation</category><body package="Store-Merge Management">makeProposalForAddedAlreadyInImage		applied ifTrue: [^self].	(original notNil and: [proposed notNil and: [original isStandardResolution and: [proposed isStandardResolution]]])		ifTrue: 			[(proposed resolver = original resolver and: [original package ~= proposed package or: 			[original package = proposed package and: [original package hasBeenModified not]]]) 				ifTrue: [self basicApplied: true]].</body><body package="Store-Merge Management">makeProposalForMatchingMethod	applied ifTrue: [^self].		(original isNil and: [proposed notNil and: [proposed isStandardResolution]]) ifTrue:		[proposed value correspondingImageMethod ifNotNil:			[:value | 			(value getSource notNil and:			[(value getSource asString = proposed value definitionString and:			[value protocol asString = proposed value protocol asString and:			[proposed package name = ((Registry componentDefiningSelector: value selector class: value mclass) ifNotNil: [:component | component name])]])])				ifTrue:					[self basicApplied: true.					original := proposed]]]</body><body package="Store-Merge Management">makeProposalForRemovalsMatchingOrignial		applied ifTrue: [^self].	(proposed notNil and: [original notNil and: [proposed isRemovalResolution and: [original isRemovalResolution]]]) ifTrue: [self basicApplied: true]</body><body package="Store-Merge Management">makeResolutionProposals		applied ifTrue: [^self].	super makeResolutionProposals.	self makeProposalForMatchingMethod.	self removeProposalForMismatchingPackages.	self makeProposalForRemovalsMatchingOrignial.	self makeProposalForAddedAlreadyInImage.</body><body package="Store-Merge Management">protocolStringFor: aResolution	^aResolution isRemovalResolution 		ifTrue: [aResolution value value protocol] 		ifFalse: 			[aResolution isUserInputResolution				ifTrue: [aResolution protocol ifNil: ['']]				ifFalse: [aResolution value protocol]]</body><body package="Store-Merge Management">removeProposalForMismatchingPackages		applied ifFalse: [^self].	(proposed notNil and: [proposed isStandardResolution]) ifTrue:		[proposed value correspondingImageMethod ifNotNil:			[:value | 			(value getSource notNil and:			[(value getSource asString = proposed value definitionString and:			[value protocol asString = proposed value protocol asString and:			[proposed package name = ((Registry componentDefiningSelector: value selector class: value mclass) ifNotNil: [:component | component name])]])])					ifFalse: [self basicApplied: false]]			ifNil: [self basicApplied: false]]</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing numbers</category><body package="Store-User Management">blessingName: aNumber	"Given a number from DB answer the official name of the blessing level."		aNumber = 0 ifTrue: [^(#Unblessed &lt;&lt; #store &gt;&gt; 'Unblessed') asString].	^(self blessings 		detect: [:each | each level == aNumber] 		ifNone: [^(#Unknown &lt;&lt; #store &gt;&gt; 'Unknown') asString]) name</body><body package="Store-User Management">blessingNumber: aName	"Given the name for the blessing level answer a number used in DB."		aName = (#Unblessed &lt;&lt; #store &gt;&gt; 'Unblessed') asString ifTrue: [^0].	^(self blessings detect: [:each | each name = aName] ifNone: [^nil]) level</body><body package="Store-User Management">defaultBlessing		^defaultBlessing</body><body package="Store-User Management">defaultBlessing: aNumber		defaultBlessing := aNumber</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-User Management">initialize	self initializeBlessings.	self defaultBlessing: self developmentBlessing.</body><body package="Store-User Management">initializeBlessings	"Policies blessingPolicy initializeBlessings"	blessings := IdentityDictionary new		at: #MarkedForDeletion put: (BlessingLevel name: 'Marked For Deletion' level: -54);		at: #Obsolete put: (BlessingLevel name: 'Obsolete' level: -10);		at: #ReplicationNotice put: (BlessingLevel name: 'Replication Notice' level: -1);		at: #Broken put: ( BlessingLevel name: 'Broken' level: 10 );		at: #WorkInProgress put: ( BlessingLevel name: 'Work In Progress' level: 15 );	 	at: #Development put: ( BlessingLevel name:  'Development' level: 20 );		at: #ToReview put: (  BlessingLevel name: 'To Review' level: 25 );		at: #Patch put: ( BlessingLevel name:  'Patch' level: 30 );	 	at: #IntegrationReady put: ( BlessingLevel name:  'Integration-Ready' level: 40 );		at: #Integrated put: ( BlessingLevel name:  'Integrated' level: 50 );		at: #ReadyToMerge put: ( BlessingLevel name: 'Ready to Merge' level: 55 );		at: #Merged put: ( BlessingLevel name:  'Merged'  level: 60 );		at: #Tested put: ( BlessingLevel name:  'Tested' level: 70 );		at: #InternalRelease put: ( BlessingLevel name:  'Internal Release' level:  80 );		at: #Release put: ( BlessingLevel name:  'Released' level:  99 );		yourself.</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>display</category><body package="Store-User Management">blessingLevelsNotToBeDisplayed	"Return a list of blessing levels that will not be displayed in a printed blessing history."	^#(-1).</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>relationships</category><body package="Store-User Management">stringKeyFor: aString blessingLevel: blessingLevel	blessingLevel = self developmentBlessing 		ifTrue: [^(aString , ' D') asText emphasizeAllWith: #italic].	blessingLevel = self integrationReadyBlessing 		ifTrue: [^( aString , ' Y' ) asText emphasizeAllWith: #bold ].	^aString , ' ' , ( String with: ( self blessingName: blessingLevel ) first )</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>accessing</category><body package="Store-User Management">blessingAt: aSymbol put: aBlessingLevel	blessings at: aSymbol put: aBlessingLevel.</body><body package="Store-User Management">blessingNumbers	"Answer an array of existing blessing numbers."	^blessings values collect:		[ :bl | bl level ]</body><body package="Store-User Management">blessings	"Answer an array of existing BlessingLevels."	^blessings values</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>publishing</category><body package="Store-User Management">basicCanPublish: aPundle atBlessing: aBlessing	^true</body><body package="Store-User Management">objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body><body package="Store-User Management">objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel 	"Return a string specifying why this package may not be published.  Return nil if it may.	An example policy is shown below:"	^nil"	aPackage changeSet listOfClasses 			detect: [:className | 				(className copyFrom: 1 to: 3) ~= 'TT_']			ifNone: [^nil].	^aLevel = (Policies blessingPolicy blessingNumber: 'Development')		ifTrue: [nil]		ifFalse: ['Changes to external classes may not\be published with this blessing.']"</body><body package="Store-User Management">objectionsToPublishingParcel: aParcel atBlessingLevel: aLevel 	"Return a string specifying why this parcel may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body><body package="Store-User Management">objectionsToPublishingPundle: aPundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing menus</category><body package="Store-User Management">blessingLevelsMenu	"Answer a menu with all existing blessing names and levels."	| menu labels values list |	list := self blessings asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body><body package="Store-User Management">blessingLevelsMenuForPundle: aPundle	^self blessingLevelsMenu</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing names</category><body package="Store-User Management">brokenBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Broken ) level</body><body package="Store-User Management">developmentBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Development ) level.</body><body package="Store-User Management">integratedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Integrated ) level</body><body package="Store-User Management">integrationReadyBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"		^(blessings at: #IntegrationReady) level</body><body package="Store-User Management">internalReleaseBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"		^(blessings at: #InternalRelease) level</body><body package="Store-User Management">mergedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Merged ) level.</body><body package="Store-User Management">patchBlessing 	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Patch ) level</body><body package="Store-User Management">readyToMergeBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #ReadyToMerge ) level</body><body package="Store-User Management">releasedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Release ) level</body><body package="Store-User Management">testedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Tested ) level</body><body package="Store-User Management">toReviewBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #ToReview ) level</body><body package="Store-User Management">workInProgressBlessing 	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #WorkInProgress ) level</body></methods><methods><class-id>Store.BasicBlessingPolicy class</class-id> <category>instance creation</category><body package="Store-User Management">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>copying</category><body package="Store-Database Model">= anObject	^self == anObject yourSelf.</body><body package="Store-Database Model">copy	^self glorpCopyIn: IdentityDictionary new.</body><body package="Store-Database Model">glorpCopyIn: aDictionary	| existing copy |	existing := aDictionary at: self ifAbsent: [nil].	existing isNil ifFalse: [^existing].	copy :=  self shallowCopy.	aDictionary at: self put: copy.	aDictionary at: copy put: copy.	copy postCopyIn: aDictionary.	^copy.</body><body package="Store-Database Model">postCopyIn: aDictionary	primaryKey := nil</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>store faking</category><body package="Store-Database Model">statusLineString	^''</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>testing</category><body package="Store-Database Model">belongsToClass	^false.</body><body package="Store-Database Model">isClass	^false.</body><body package="StoreForGlorpVWUI">isDataModel	"Is this a Bernstein data model?"	^true</body><body package="Store-Database Model">isForClass	^false</body><body package="Store-Database Model">isForClassOrExtension	^false</body><body package="StoreForGlorpVWUI">isForData	^false.</body><body package="StoreForGlorpVWUI">isForMethod	^false.</body><body package="Store-Database Model">isForNameSpace	^false.</body><body package="Store-Database Model">isForSharedVariable	^false</body><body package="Store-Database Model">isGlorpObject	^true</body><body package="Store-Database Model">isImageObject	^false</body><body package="Store-Database Model">isLoaded	^false</body><body package="StoreForGlorpVWUI">isPatched	^false</body><body package="Store-Database Model">isStoreDefinitionInPackage	^false</body><body package="Store-Database Model">needsComment	^false.</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>loading</category><body package="Store-Database Model">defaultUnloadableMessage	"Answer the default message to tell if this object cannot be loaded."	| ident |	ident := self isForMethod ifTrue: [self printString] ifFalse: [self name].	^#DefIsNotLoadable &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is not loadable.'		expandMacrosWith: ident</body><body package="Store-Database Model">evaluateDefinition: aString	"Let the Compiler evaluate the given string. Typical examples are class definitions like		SomeClass defineClass: #MySubclass superclass:...category:...	or namespace or shared variable definitions. The evaluation creates the class/namespace/shared.	Suppress the general warning about variable naming conventions.	Answer the result (new Class, binding for Namespace or Shared)"	^[self class evaluatorClass evaluate: aString]		on: VariableConfirmation		do: [:exception | exception resume: false]</body><body package="Store-Database Model">evaluateDefinition: aString onError: aBlock	"Let the Compiler evaluate the given string. For details see comment in #evaluateDefinition:.	On errors evaluate &lt;aBlock&gt;, typically raising an UnloadableDefinitionError with the underlying exception.	On success answer the result (new Class, binding for Namespace or Shared)"	^[self evaluateDefinition: aString] on: self exceptionDuringEvaluate do: aBlock</body><body package="Store-Database Model">exceptionDuringEvaluate	"Answer the exception(s) handled during Smalltalk code evaluation in the course of loading.	By default we intercept all Error. The previous use of UnhandledException here is possible but no longer tested.	Handling UnhandledException has the effect to propagate the basic exception up the stack	and really handle only in case that no handler was found."	^Error</body><body package="Store-Database Model">loadSourceInto: aPackageModelOrNil	"Answer back nil if I failed"	^self loadSrcInto: aPackageModelOrNil</body><body package="Store-Database Model">loadSrcInto: aPackageModelOrNil	"Answer back nil if I failed"	^aPackageModelOrNil isNil		ifTrue: [self loadSource]		ifFalse: [Store.Policies packagePolicy forcePackage: aPackageModelOrNil while: [self loadSource]]</body><body package="Store-Database Model">loadSrcIntoPackage: aPackage confirm: aBoolean	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource or #loadSrcInto:).	^self loadSrcInto: aPackage</body><body package="Store-Database Model">notifyUnloadableError: exceptionOrString	"Raise a notification about a loading problem, as opposed to the error exception."	| errorMessage |	errorMessage := exceptionOrString isSignalledException ifTrue: [exceptionOrString messageText] ifFalse: [exceptionOrString].	(Store.UnloadableDefinitionNotification new)		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		parameter: self;		raiseSignal: errorMessage.	^nil</body><body package="Store-Database Model">raiseUnloadableError: exceptionOrString inPackage: aStorePackage	"Raise a fully populated UnloadableDefinitionError to signal that this StoreObject could not be loaded."	| unloadableError |	unloadableError := Store.UnloadableDefinitionError				for: self				inPackage: aStorePackage				error: exceptionOrString.	unloadableError raise.	^nil</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">binding	^self</body><body package="StoreForGlorpVWUI">bindingOrNil	^self</body><body package="Store-Database Model">currentUsernameself todo.	^'???'</body><body package="Store-Database Model">debugStoreII	^self class debugStoreII</body><body package="StoreForGlorpVWUI">fullRootName	^self longName</body><body package="Store-Database Model">id	^primaryKey</body><body package="Store-Database Model">notifyOfReversionToStore1Object	self debugStoreII ifTrue: [Dialog warn: 'About To Revert To A Store 1 Object'].</body><body package="Store-Database Model">primaryKey	^primaryKey.</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>converting</category><body package="StoreForGlorpVWUI">timestampOffset	"Duplicate this here because we might not have the session available"	^2922938387</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>private</category><body package="Store-Database Model">convertVariableNodeToXML: aParseNode	| environmentName |	environmentName := (aParseNode respondsTo: #name)		ifTrue: [aParseNode name asString]		ifFalse: 			[aParseNode value == nil				ifTrue: ['nil']				ifFalse: 					[aParseNode value isBindingReference						ifTrue: [aParseNode value asString]						ifFalse: [self error: #ExpectedToFindAGlobalReferenceHere &lt;&lt; #store &gt;&gt; 'Expected to find a global reference here']]].	('Smalltalk.#*' match: environmentName) ifTrue: [environmentName := environmentName copyFrom: 'Smalltalk.*' size to: environmentName size].	^environmentName</body><body package="Store-Database Model">privateSetPrimaryKey: aNumber	primaryKey := aNumber.</body><body package="Store-Database Model">sax: driver tag: tag value: value	driver startElement: tag atts: nil.	driver characters: value.	driver endElement</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>comparing</category><body package="Store-Database Model">sameAs: anObject 	^anObject notNil and: [anObject sameAsDBThing: self]</body><body package="Store-Database Model">sameAsDBThing: anObject	"If primary key is not set then a records have to be indentical."	self primaryKey isNil ifTrue: [^anObject == self].	^anObject primaryKey =  self primaryKey</body><body package="StoreForGlorpVWUI">sameAsImThing: anObject	^self = anObject.</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">fullDisplayString	^self displayString</body><body package="StoreForGlorpVWUI">itemString	^self fullDisplayString</body><body package="StoreForGlorpVWUI">toolListDisplayString	^self displayString.</body><body package="StoreForGlorpVWUI">toolListIcon	^self class toolListIcon.</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>accessing</category><body package="Store-Database Model">currentDescriptorSystem		^self currentStoreSession system</body><body package="Store-Database Model">currentStoreSession		^StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">databaseIdentifier		^self currentStoreSession 		ifNil: [nil]		ifNotNil: [self currentDescriptorSystem databaseIdentifier asString]</body><body package="Store-Database Model">debugStoreII	^DebugStoreII</body><body package="Store-Database Model">warnIfNewerVersionPublished	#{Store.Glorp.StoreObject.WarnIfNewerVersionPublished} value ifNil:		[#{Store.Glorp.StoreObject.WarnIfNewerVersionPublished} binding reinitializeValue].	^WarnIfNewerVersionPublished</body><body package="Store-Database Model">warnIfNewerVersionPublished: aBoolean	WarnIfNewerVersionPublished := aBoolean</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>instance creation</category><body package="Store-Database Model">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>installation</category><body package="Store-Database Model">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy defaultTableSpace</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>database utility</category><body package="Store-Database Model">aRecordWithID: anInteger	"The ID is the primary key, answer nil if there is no match"	^self aRecordWithID: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">aRecordWithID: anInteger in: aSessionOrNil	| session |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	^session readOneOf: self where: [:each | each primaryKey = anInteger]</body><body package="Store-Database Model">getRecordWithID: anInteger	"The ID is the primary key, answer nil if there is no match"	^self aRecordWithID: anInteger</body><body package="Store-Database Model">withPrimaryKey: anInteger	"The ID is the primary key, answer nil if there is no match"	^self aRecordWithID: anInteger</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>accessing</category><body package="Store-Database Model">absoluteName	^self longName.</body><body package="Store-Database Model">asString	^self name</body><body package="Store-Database Model">basicComment	^nil</body><body package="Store-Database Model">childrenIn: aSession	| query session |	session := aSession.	query := Query read: self class where: [:each | each trace primaryKey = self primaryKey].	^session execute: query</body><body package="Store-Database Model">comment	self basicComment yourSelf isNil ifTrue: [^''].	^self basicComment source</body><body package="Store-Database Model">commentOrNil	self basicComment yourSelf isNil ifTrue: [^nil].	^self basicComment source</body><body package="Store-Database Model">localTimestamp	^TimeZone default universalToLocal: timestamp</body><body package="Store-Database Model">localTimestamp: aTimestamp	timestamp := aTimestamp subtractSeconds: (Dialect timeOffsetFromGMT * 60 * 60).</body><body package="Store-Database Model">name	^name</body><body package="Store-Database Model">name: aString	name := aString.</body><body package="Store-Database Model">newVersion	| copy |	copy := self copy.	copy previous: self.	^copy</body><body package="Store-Database Model">package	"I don't have a package, but because of polymorphic reasons, I want to respond to this just like my 'InPackage' cousins"	^nil</body><body package="Store-Database Model">parent	^self previous.</body><body package="Store-Database Model">parent: aStoreSourceObject	self previous: aStoreSourceObject.</body><body package="Store-Database Model">previous	^trace</body><body package="Store-Database Model">previous: aStoreSourceObject 	aStoreSourceObject notNil ifTrue: [aStoreSourceObject yourSelf class = self class ifFalse: [self halt]].	trace := aStoreSourceObject yourSelf.</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	^self definition</body><body package="Store-Database Model">timeStampString	"Use the #medium policy when the current Locale is CLDR, or	use the #editing policy when the current Locale is legacy-based."	^Locale current 		printAsTime: self localTimestamp		policyNamed: (Locale isCLDR ifTrue: [#medium] ifFalse: [#editing])</body><body package="Store-Database Model">timestamp	^timestamp</body><body package="Store-Database Model">timestamp: aTimestamp	timestamp := aTimestamp.</body><body package="Store-Database Model">trace	"A synonym, because this is the name of the database field"	^self previous.</body><body package="Store-Database Model">trace: aStoreSourceObject	"A synonym, because this is the name of the database field"	self previous: aStoreSourceObject.</body><body package="Store-Database Model">userName	^self username.</body><body package="Store-Database Model">username	^username</body><body package="Store-Database Model">username: aBoolean	username := aBoolean.</body><body package="Store-Database Model">version	^''.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>printing</category><body package="Store-Database Model">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self name ifNil: ['']);		nextPut: $,;		nextPutAll: (self version ifNil: ['']);		nextPut: $)</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>comparing</category><body package="Store-Database Model">sourceMatches: aStoreObject	| sourceCode |	sourceCode := aStoreObject isCharacters 		ifTrue: [aStoreObject asString] 		ifFalse: [aStoreObject source].	^self source equalsAcrossPlatforms: sourceCode.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>reconciling</category><body package="Store-Database Model">reconcilesWith: aStoreSourceObject	^self name = aStoreSourceObject name</body><body package="Store-Database Model">unreconcile	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>testing</category><body package="Store-Database Model">isForClass	^false</body><body package="Store-Database Model">isPseudo	^false.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>fileIn/Out</category><body package="Store-Database Model">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self longNameFromSmalltalk		with: self timeStampString		with: self username</body><body package="Store-Database Model">longNameFromSmalltalk	^self class longNameFromSmalltalkUsing: self longName</body><body package="Store-Database Model">longNameWithMetaFromSmalltalk	| lngName |	lngName := self longNameFromSmalltalk.	self isMeta		ifTrue: [lngName := lngName, ' class'].	^lngName</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>compatibility</category><body package="Store-Database Model">timeStampAsTimestampObject	^self timestamp</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>publishing</category><body package="Store-Database Model">updateUserAndTimestampFrom: aPackage	(self username isNil or: [self username = '???'])		ifTrue: [self username: aPackage username].	self timestamp isNil 		ifTrue: [self timestamp: aPackage timestamp]</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>atomic loading</category><body package="Atomic Compiling and Loading">asShadowedObjectIn: aStorePackage	^self shadowedObjectClass newFrom: self in: aStorePackage.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject class</class-id> <category>printing</category><body package="StoreForGlorpVWUI">longNameFromSmalltalkUsing: aString	"For 'Root.Smalltalk.Whatever..' (the typical case), strip off the prefix and return only the 'Whatever...'.  For 'Root.Smalltalk' itself, return 'Smalltalk'.  For anything else not starting 'Root.Smalltalk.', return the whole thing."	(aString beginsWith: 'Root.Smalltalk.') ifTrue: [^aString allButFirst: 15].	aString = 'Root.Smalltalk' ifTrue: [^'Smalltalk'].	^aString</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>accessing</category><body package="Store-Database Model">binaryData	^self blob binaryData.</body><body package="Store-Database Model">blob	^blob.</body><body package="Store-Database Model">defaultParcelName	"This method is used to return a name that can be used in the creation	of a temporary source file (*.pst) when loading a parcel from a Store	database.  Currently only uses [name][primaryKey].pst but will need to	also have some way of identifying the database being accessed since	two different ParcelRecords in two different databases could have the	same name and the same primary key."	self needsMoreWork.	^self name, self primaryKey printString</body><body package="Store-Database Model">privateSetBlob: aStoreBlob	blob := aStoreBlob</body><body package="Store-Database Model">privateSetSource: anObject	source := anObject</body><body package="Store-Database Model">source	^source</body><body package="Store-Database Model">version	^version</body><body package="Store-Database Model">version: anObject	version := anObject</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>comparing</category><body package="Store-Database Model">= aStoreParcelRecord	^self reconcilesWith: aStoreParcelRecord.</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>reconciling</category><body package="Store-Database Model">reconcilesWith: aStoreParcelRecord	"Return true if we appear to be the same entry, but potentially in a different database"	aStoreParcelRecord yourSelf isNil ifTrue: [^false].	self name = aStoreParcelRecord name ifFalse: [^false].	self binaryData = aStoreParcelRecord binaryData ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	blob := blob glorpCopyIn: aDictionary.	source := source glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord class</class-id> <category>instance creation</category><body package="Store-Database Model">from: aPackageModel	| instance |	instance := self new.	instance name: aPackageModel name.	instance timestamp: aPackageModel timestamp.	instance version: (aPackageModel properties at: #version ifAbsent: ['']).	^instance</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord class</class-id> <category>accessing</category><body package="Store-Database Model">parcelDirectory	"self parcelDirectory"		| directory |	directory := PundleAccess parcelDirectory.	DbRegistry isConnected ifFalse: [^directory].	^self databaseIdentifier		ifNil: [directory]		ifNotNil: [:value | directory := directory construct: (Filename canonicalize: value)]</body></methods><methods><class-id>Store.PseudoNamespaceForSharedDifference</class-id> <category>accessing</category><body package="Store-Merge Management">changedMethodsSharedAndProperties		^self sortedSharedDifferences</body></methods><methods><class-id>Store.PseudoNamespaceForSharedDifference class</class-id> <category>instance creation</category><body package="Store-Merge Management">mainPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference mainPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		mainPackage: aPackage namespace: namespace fullName asQualifiedReference;		yourself</body><body package="Store-Merge Management">otherPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference otherPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		otherPackage: aPackage justNamespace: namespace fullName asQualifiedReference;		yourself</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>reconciling</category><body package="Store-Database Model">unreconcile	"Do nothing, we have no direct reference to previous versions"</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>private-two byte strings</category><body package="Store-Database Model">byteOrder	| test null chara |	test := 'abc' asTwoByteString.	null := 0.	chara := $a asInteger.	(((test basicAt: 1) = chara) and: [(test basicAt: 2) = null]) ifTrue: [^#(0 1)].	(((test basicAt: 2) = chara) and: [(test basicAt: 1) = null]) ifTrue: [^#(1 0)].	self error: 'Can not determine byte order for TwoByteString'</body><body package="Store-Database Model">decodeTwoByteDefinitionStream: strm	| string2Byte order inx |	string2Byte := TwoByteString new: strm size.	order := self byteOrder.	inx := 1.	[strm atEnd]		whileFalse: 			[string2Byte basicAt: inx + order first put: (self readDecodedByteFrom: strm).			string2Byte basicAt: inx + order last put: (self readDecodedByteFrom: strm).			inx := inx + 2].	^string2Byte copyFrom: 1 to: ((inx - 1)//2)</body><body package="Store-Database Model">encodeTwoByteDefinition: aString	| strm order |	strm := WriteStream on: (String new: (aString size * 4)).	order := self byteOrder.	1 to: aString basicSize by: 2 do: [:inx|		self writeByte: (aString basicAt: inx + order first) encodedOn: strm.		self writeByte: (aString basicAt: inx + order last) encodedOn: strm].	^strm contents asByteArray</body><body package="Store-Database Model">readDecodedByteFrom: aStream 	| code |	code := aStream next asInteger.	^(code &gt;= 16 and: [code &lt;= 127])		ifTrue: [code]		ifFalse: [code = 1				ifTrue: [0]				ifFalse: [(code &gt;= 2 and: [code &lt;= 5])						ifTrue: [aStream next asInteger - 32 + ((code - 2) * 64)]						ifFalse: 							[self error: 'Invalid encoding of TwoByteString'.							0]]]</body><body package="Store-Database Model">writeByte: aByte encodedOn: aStream 	(aByte &gt;= 16 and: [aByte &lt;= 127])		ifTrue: [aStream nextPut: (Character value: aByte)]		ifFalse: [aByte = 0				ifTrue: [aStream nextPut: (Character value: 1)]				ifFalse: 					[aStream nextPut: (Character value: 2 + (aByte // 64)).					aStream nextPut: (Character value: 32 + (aByte \\ 64))]]</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>accessing</category><body package="Store-Database Model">asText	^self source asText.</body><body package="Store-Database Model">basicType	^type.</body><body package="Store-Database Model">binaryData	| stream |	next isNil ifTrue: [^data].	stream := WriteStream on: (ByteArray new: 64000).	self binaryDataInto: stream.	^stream contents</body><body package="Store-Database Model">binaryData: aByteArray	self binaryData: aByteArray startingAt: 1.</body><body package="Store-Database Model">binaryData: aByteArray startingAt: anOffset	aByteArray size - anOffset + 1 &gt; self maximumDataSize		ifTrue:			[data := aByteArray copyFrom: anOffset to: anOffset - 1 + self maximumDataSize.			next := self class forByteArray: aByteArray startingAt: anOffset + self maximumDataSize.			self lastInChain type: type.			type := nil]		ifFalse: [data := aByteArray copyFrom: anOffset to: aByteArray size].</body><body package="Store-Database Model">binaryDataInto: aStream 	aStream nextPutAll: data.	next notNil ifTrue: [next binaryDataInto: aStream]</body><body package="Store-Database Model">lastInChain	| current |	current := self.	[current next isNil] whileFalse: [current := current next].	^current.</body><body package="Store-Database Model">next	^next</body><body package="Store-Database Model">next: aStoreBlob	"Return the parameter (simplifies chain construction in #inject:into: calls)."	^next := aStoreBlob</body><body package="Store-Database Model">object	| stream boss bossClass |	result notNil ifTrue: [^result].	bossClass := Smalltalk at: #BinaryObjectStorage ifAbsent: [nil].	bossClass isNil 		ifTrue: 			["self error: 'Cannot load properties without BinaryObjectStorage class'" ^Dictionary new].	stream := ReadStream on: self binaryData.	boss := bossClass onOld: stream.	result := [boss next] on: Dialect error do: [:ex | nil].	^result</body><body package="Store-Database Model">source	| myData |	result notNil ifTrue: [^result].	myData := self binaryData.	myData isNil ifTrue: [^''].	"The encoding used here is bizarre. Just reuse"	result := self isTwoByteString		ifTrue: [self decodeTwoByteDefinitionStream: (ReadStream on: myData)]		ifFalse: [myData asString].	Dialect isVisualAge ifTrue: [result := result copyReplaceAll: (String with: Character cr) with: (Dialect smalltalkAt: #CwText) lineDelimiter].	^result</body><body package="Store-Database Model">type	^next isNil ifTrue: [type] ifFalse: [next type]</body><body package="Store-Database Model">type: anInteger	type := anInteger</body><body package="Store-Database Model">unchainedBinaryData	^data.</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>testing</category><body package="Store-Database Model">glorpPostFetch: aSession	primaryKey = 0 ifTrue: [self halt].	type = 0 ifTrue: [self halt].</body><body package="Store-Database Model">glorpPostFetchValidate: aSession	"Note that returning false means that this object will be ignored. Used because on at least one occasion I've seen a Store database with a blob record in it of primary key zero, which just messes things up horribly."	primaryKey = 0 ifTrue: [^false].	type = 0 ifTrue: [^false].</body><body package="Store-Database Model">isTwoByteString	^self type = 3.</body><body package="Store-Database Model">validTypeField	type isNil ifTrue: [^nil].	^type &gt; 0 ifTrue: [type] ifFalse: [nil].</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>constants</category><body package="Store-Database Model">maximumDataSize	^32000</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>initializing</category><body package="Store-Database Model">forByteArray: aCollection	type := 4.	self binaryData: aCollection asByteArray.</body><body package="Store-Database Model">forByteArray: aCollection startingAt: anOffset	type := 4.	self binaryData: aCollection asByteArray startingAt: anOffset.</body><body package="Store-Database Model">forObject: anObject	| bossClass stream boss |	type := 1.	bossClass := Smalltalk at: #BinaryObjectStorage ifAbsent: [nil].	bossClass isNil 		ifTrue: 			[self error: 'Cannot store properties without BinaryObjectStorage class'].	stream := WriteStream on: (ByteArray new: 500).	boss := bossClass onNew: stream.	boss nextPut: anObject.	self binaryData: stream contents.</body><body package="Store-Database Model">forString: aCollection	| newData invalidCharacter |	type := 2.	"This criteria for two-byte strings is kind of fuzzy. We're out of range if the unicode code point is out of single byte range. But without knowing what encoding the database is using, it's hard to know"	invalidCharacter := aCollection detect: [:each | each asInteger &gt; 255] ifNone: [nil].	invalidCharacter isNil ifFalse: [^self forTwoByteString: aCollection].	newData := Dialect isVisualAge		ifTrue:			[aCollection				copyReplaceAll: (Dialect smalltalkAt: #CwText) lineDelimiter				with: (String with: Character cr)]		ifFalse: [aCollection].	self binaryData: newData asByteArray.</body><body package="Store-Database Model">forTwoByteString: aCollection	| newData |	type := 3.	Dialect isVisualAge		ifTrue:			[newData := aCollection				copyReplaceAll: (Dialect smalltalkAt: #CwText) lineDelimiter				with: (String with: Character cr)]		ifFalse: [			Dialect isVisualWorks ifTrue: [newData := aCollection asTwoByteString] ifFalse: [newData := aCollection]].	"The encoding scheme used here is quite weird, and I can't tell if it corresponds to any known encoding. Just reuse"	self binaryData: (self encodeTwoByteDefinition: newData) asByteArray.</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	next := next glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>adding</category><body package="Store-Database Model">nextPseudoBlobRecursively: aStoreBlob	"If I am the parameter, exit:  we've already read this blob.  If my next is neither the parameter nor another blob then (it must be a proxy or nil, and) the parameter is my next (because the chain being recovered in order - this implementation relies on that).  If it is another blob, seek the parameter's predecessor further down the chain.  "	next == aStoreBlob ifTrue: [^aStoreBlob].	^next class == aStoreBlob class		ifFalse: [next := aStoreBlob]		ifTrue: [next nextPseudoBlobRecursively: aStoreBlob]</body></methods><methods><class-id>Store.Glorp.StoreBlob class</class-id> <category>instance creation</category><body package="Store-Database Model">forByteArray: aByteArray	^self new forByteArray: aByteArray</body><body package="Store-Database Model">forObject: anObject	^self new forObject: anObject</body><body package="Store-Database Model">forString: aString	^self new forString: aString</body><body package="Store-Database Model">forTwoByteString: aString	^self new forTwoByteString: aString</body></methods><methods><class-id>Store.Glorp.StoreBlob class</class-id> <category>private</category><body package="Store-Database Model">forByteArray: aByteArray startingAt: anOffset	^self new forByteArray: aByteArray startingAt: anOffset</body></methods><methods><class-id>Store.Glorp.StoreBlob class</class-id> <category>installation</category><body package="Store-Database Model">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy blobTableSpace</body></methods><methods><class-id>Store.Glorp.StoreBlob class</class-id> <category>accessing</category><body package="Store-Database Model">maximumDataSize	"When encoding for PostgreSQL, we use Base64Encoding, and that is typically 3/2 the original size.  Elsewhere, the question is a balance between making big hunks of things and typical size of things.  We used to say 32K (32000 * (3/2) == 48000 final chunk max size) but most files are bigger.  So our choice is about the size of garbage chunks we make. about 100K (2^17) is as good as any with (2 ** 17 * (3/2)  == 196608) being the max chunk size read/write for PostgreSQL."	^maximumDataSize ifNil: [131072] "2 ** 17"</body><body package="Store-Database Model">maximumDataSize: anInteger	maximumDataSize := anInteger.</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>view construction</category><body package="Store-Code Comparison">collapsedIndicator	^self indicatorNormal: ComparisonIcons collapsed		focused: ComparisonIcons focusCollapsed</body><body package="Store-Code Comparison">computeDetailRows	^Array new</body><body package="Store-Code Comparison">detailsPanel	^self children last</body><body package="Store-Code Comparison">disclosureButton	"Manufacture a button to be used to indicate the expanded/collapsed status of the reasons."	| disclosure |	disclosure := Refactory.Browser.ClickableGraphic new.	disclosure idleGraphic: (self isExpanded				ifTrue: [self expandedIndicator]				ifFalse: [self collapsedIndicator]).	disclosure mouseDownGraphic: self transitionIndicator.	disclosure when: Refactory.Browser.Clicked send: #disclosureClicked to: self.	^disclosure</body><body package="Store-Code Comparison">disclosureButtonSpace	^PixelSpace width: 12</body><body package="Store-Code Comparison">expandedIndicator	^self indicatorNormal: ComparisonIcons expanded		focused: ComparisonIcons focusExpanded</body><body package="Store-Code Comparison">header	^self children first</body><body package="Store-Code Comparison">indicatorNormal: aNormalGraphic focused: aFocusedGraphic	^VisualBlock block: 			[:gc :box |			(self hasFocus ifTrue: [aFocusedGraphic] ifFalse: [aNormalGraphic])				displayOn: gc				at: Point zero]		extent: aNormalGraphic image extent</body><body package="Store-Code Comparison">moreInfoTooltipHandle	| tooltipProvider |	tooltipProvider := ClickableGraphic new.	tooltipProvider idleGraphic: ComparisonIcons moreInfoHandle.	tooltipProvider tooltip: [self infoTooltipText].	^tooltipProvider</body><body package="Store-Code Comparison">newRow	^Panel new beRow: 0.5 gap: 4</body><body package="Store-Code Comparison">populate	"This is the primary point of fleshing out the receiver, once its instance variable state has been filled out. Note that we don't bother populating the subrows unless they have set us to be expanded already."	self populateHeader.	self detailsPanel releaseAllComponents.	self isExpanded ifTrue: [self populateDetails]</body><body package="Store-Code Comparison">populateDetails	"Called when we expand for the first time, simply concatonate the sections and throw them in the subrows."	(self detailsPanel)		releaseAllComponents;		addAll: self computeDetailRows</body><body package="Store-Code Comparison">populateDetailsIfNecessary	self detailsPanel children isEmpty ifTrue: [self populateDetails]</body><body package="Store-Code Comparison">populateHeader	self header releaseAllComponents.	self header add: self disclosureButton</body><body package="Store-Code Comparison">transitionIndicator	^self indicatorNormal: ComparisonIcons transition		focused: ComparisonIcons focusTransition</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">beExpanded	self expansionChangeBeginning.	expandedFraction := 1.	self expansionChangeFinished</body><body package="Store-Code Comparison">initDetailsPanel	| details |	details := Panel new.	details beFullColumn.	self add: details</body><body package="Store-Code Comparison">initHeader	"The header row is the first subpart, and is a vertically centererd row with spacing of 2."	| headerRow |	headerRow := self newRow.	self add: headerRow</body><body package="Store-Code Comparison">initialize	super initialize.	expandedFraction := 0.	self initHeader.	self initDetailsPanel</body><body package="Store-Code Comparison">initializeLayoutAlgorithm	self layoutAlgorithm: 			[:rect :children |			| rolledBottom rolledLeft rolledHeight headerBox details |			headerBox := rect origin extent: children first preferredExtent.			details := children last.			rolledHeight := details preferredHeight.			rolledLeft := rect left + self indent.			rolledBottom := headerBox bottom + (expandedFraction * rolledHeight).			Array with: headerBox				with: (Rectangle						left: rolledLeft						right: rect right - 5						top: headerBox bottom						bottom: rolledBottom)]</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>private</category><body package="Store-Code Comparison">anticipateNewDisclosureButtonLabel	| button |	button := self header children first.	button idleGraphic: (self isExpanded				ifTrue: [self collapsedIndicator]				ifFalse: [self expandedIndicator])</body><body package="Store-Code Comparison">collapseDetails	self isExpanded ifTrue: [self toggleExpansion]</body><body package="Store-Code Comparison">cycleThruChanges: anEvent	| target |	target := anEvent hasShift				ifTrue: 					["previous"					self previousSibling ifNil: [self parentRollup]]				ifFalse: 					["next"					self firstExpandedRollupChild						ifNil: [self nextSibling ifNil: [self parentRollup ifNotNil: #nextSibling]]].target ifNil: [^self].	target parentRollup == self ifFalse: [self collapseDetails].	self parentRollup		ifNotNil: [:nextUp | nextUp = target parentRollup ifFalse: [nextUp collapseDetails]].	target expandDetails.	target takeKeyboardFocus</body><body package="Store-Code Comparison">disclosureClicked	| viewsToToggle |	viewsToToggle := InputState default shiftDown				ifTrue: 					[InputState default altDown						ifTrue: [self sameExpansionCousinRollups]						ifFalse: [self sameExpansionSiblingRollups]]				ifFalse: [Array with: self].	self toggleExpansions: viewsToToggle.	self takeKeyboardFocus</body><body package="Store-Code Comparison">expandDetails	self isExpanded ifFalse: [self toggleExpansion]</body><body package="Store-Code Comparison">expandedFraction: aFraction	expandedFraction := aFraction</body><body package="Store-Code Comparison">expansionChangeBeginning	self populateDetailsIfNecessary.	self anticipateNewDisclosureButtonLabel</body><body package="Store-Code Comparison">expansionChangeFinished</body><body package="Store-Code Comparison">firstExpandedRollupChild	self isExpanded ifFalse: [^nil].	self rollupChildrenDo: [:each | ^each].	^nil</body><body package="Store-Code Comparison">focusNext	self firstExpandedRollupChild		ifNotNil: #takeKeyboardFocus		ifNil: 			[self nextSibling				ifNotNil: #takeKeyboardFocus				ifNil: 					[(self parentRollup ifNotNil: #nextSibling) ifNotNil: #takeKeyboardFocus]]</body><body package="Store-Code Comparison">focusPrevious	| neighbor closer |	neighbor := self previousSibling				ifNil: [^self parentRollup ifNotNil: #takeKeyboardFocus].	[(closer := neighbor lastExpandedRollupChild) notNil]		whileTrue: [neighbor := closer].	neighbor takeKeyboardFocus</body><body package="Store-Code Comparison">indent		^Refactory.Browser.PrerequisiteIcons expanded width * 2</body><body package="Store-Code Comparison">lastExpandedRollupChild	| last |	self isExpanded ifFalse: [^nil].	last := nil.	self rollupChildrenDo: [:each | last := each].	^last</body><body package="Store-Code Comparison">makeVisible	| scroller scrollerBox myBox |	scroller := self findParent: [:each | each isKindOf: ScrollWrapper].	scroller ifNil: [^self].	scroller topComponent ifNotNil: #repairDamages.	scrollerBox := scroller bounds.	scrollerBox		moveTo: (scroller parent localPointToGlobal: scrollerBox origin).	"we don't want to be translated to the scroller scrolled out origin, so ask his parent to do the translation"	myBox := self bounds.	myBox moveTo: (self localPointToGlobal: myBox origin).	(myBox top &gt;= scrollerBox top and: [myBox bottom &lt;= scrollerBox bottom])		ifTrue: [^self].	myBox top &lt; scrollerBox top		ifTrue: [^scroller scrollBy: 0 @ (myBox top - scrollerBox top)].	scroller scrollBy: 0				@ (myBox bottom - scrollerBox bottom min: myBox top - scrollerBox top)</body><body package="Store-Code Comparison">nextSibling	| found |	found := false.	self parent childrenDo: 			[:each |			(found and: [each isKindOf: AbstractComparisonRollupView]) ifTrue: [^each].			found := found or: [each == self]].	^nil</body><body package="Store-Code Comparison">parentRollup	^self		findParent: [:candidate | candidate isKindOf: AbstractComparisonRollupView]</body><body package="Store-Code Comparison">previousSibling	| previous |	previous := nil.	self parent childrenDo: 			[:each |			each == self ifTrue: [^previous].			(each isKindOf: AbstractComparisonRollupView) ifTrue: [previous := each]].	^nil</body><body package="Store-Code Comparison">rollupChildrenDo: aBlock	self detailsPanel childrenDo: 			[:candidate |			(candidate isKindOf: AbstractComparisonRollupView)				ifTrue: [aBlock value: candidate]]</body><body package="Store-Code Comparison">sameExpansionCousinRollups	| visibleCousins |	visibleCousins := OrderedCollection new.	self parentRollup ifNil: [^self sameExpansionSiblingRollups].	self parentRollup siblingRollups do: 			[:uncleRollup |			uncleRollup isExpanded				ifTrue: 					[uncleRollup rollupChildrenDo: 							[:each |							each isExpanded = self isExpanded ifTrue: [visibleCousins add: each]]]].	^visibleCousins</body><body package="Store-Code Comparison">sameExpansionSiblingRollups	^self siblingRollups select: [:each | each isExpanded = self isExpanded]</body><body package="Store-Code Comparison">siblingRollups	^self parent children		select: [:each | each isKindOf: AbstractComparisonRollupView]</body><body package="Store-Code Comparison">toggleExpansion	self toggleExpansions: (Array with: self)</body><body package="Store-Code Comparison">toggleExpansions: aSequenceLikeSelf	| newFraction |	newFraction := 1 - expandedFraction.	aSequenceLikeSelf do: [ :view | 		view expansionChangeBeginning.		view expandedFraction: newFraction.		view expansionChangeFinished.		"TODO: ASB - move into #expansionChangeFinished"		view relayout.		view invalidate	].</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>testing</category><body package="Store-Code Comparison">hasFocus	^self topComponent		ifNil: [false]		ifNotNil: 			[:window |			window hasFocus				and: [window keyboardProcessor focusedEventHandler == self]]</body><body package="Store-Code Comparison">hasMenu	^false</body><body package="Store-Code Comparison">isExpanded		^expandedFraction = 1</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>displaying</category><body package="Store-Code Comparison">displayChild: aChild on: aGC	| drawDecoration oldPaint detailGC |	oldPaint := aGC paint.	(aChild == self header and: [self hasFocus])		ifTrue: [self displayHeaderFocusOn: aGC].	drawDecoration := self isExpanded and: [aChild == self detailsPanel].	detailGC := aGC copy.	drawDecoration ifTrue: [self drawDetailsBackroundOn: detailGC].	super displayChild: aChild on: detailGC.	drawDecoration ifTrue: [self drawDetailsBorderOn: detailGC].	aGC paint: oldPaint</body><body package="Store-Code Comparison">displayHeaderFocusOn: aGC	aGC		paint: SymbolicPaint selectionBackground;		displayPolygon: (self roundedRectangle: (self header frame origin							corner: self header frame corner - 1)).	aGC paint: SymbolicPaint selectionForeground</body><body package="Store-Code Comparison">drawDetailsBackroundOn: aGC	| frame poly oldPaint preferences |	oldPaint := aGC paint.	preferences := LookPreferences new.	preferences		setBackgroundColor: (ColorValue red: 0.9 green: 0.9 blue: 0.93).	aGC overridePaintPreferencesWith: preferences for: self.	aGC paint: SymbolicPaint background.	self detailsPanel childrenDo: 			[:row |			frame := row frame.			frame := (frame topLeft rounded corner: frame bottomRight rounded - 1)						translatedBy: self detailsPanel frame origin.			poly := self roundedRectangle: frame.			aGC displayPolygon: poly].	aGC paint: oldPaint</body><body package="Store-Code Comparison">drawDetailsBorderOn: aGC	| frame |	self detailsPanel childrenDo: 			[:row |			frame := row frame translatedBy: self detailsPanel frame origin.			frame := frame topLeft rounded corner: frame bottomRight rounded - 1.			aGC				paint: ColorValue darkGray;				displayPolyline: (self roundedRectangle: frame)]</body><body package="Store-Code Comparison">roundedRectangle: aRectangle	| ws |	ws := Array new writeStream.	ws		nextPut: (aRectangle topLeft downBy: 3);		nextPut: (aRectangle topLeft rightBy: 3);		nextPut: (aRectangle topRight leftBy: 3);		nextPut: (aRectangle topRight downBy: 3);		nextPut: (aRectangle bottomRight upBy: 3);		nextPut: (aRectangle bottomRight leftBy: 3);		nextPut: (aRectangle bottomLeft rightBy: 3);		nextPut: (aRectangle bottomLeft upBy: 3);		nextPut: (aRectangle topLeft downBy: 3).	^ws contents</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>utility</category><body package="Store-Code Comparison">italicizedText: aCharacteryArray	"We add the space, because our current width measuring code computes a width that 'chops' off the top right of the last character"	^aCharacteryArray asText , ' ' emphasizeAllWith: #italic</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>event driven</category><body package="Store-Code Comparison">getEventHandler	^self</body><body package="Store-Code Comparison">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-Code Comparison">handlerForMouseEvent: aMouseEvent	(self containsMouseEvent: aMouseEvent) ifFalse: [^nil].	^(super handlerForMouseEvent: aMouseEvent)		ifNil: 			[(aMouseEvent anyButtonPressed				and: [self header containsMouseEvent: aMouseEvent])					ifTrue: [self]					ifFalse: [nil]]</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>keyboard focus protocol</category><body package="Store-Code Comparison">activate	self invalidate</body><body package="Store-Code Comparison">controller	^self</body><body package="Store-Code Comparison">deactivate	self invalidate</body><body package="Store-Code Comparison">desiresFocus	^true</body><body package="Store-Code Comparison">hasControl	self header invalidate</body><body package="Store-Code Comparison">requestFocusIn	^true</body><body package="Store-Code Comparison">requestFocusOut	^true</body><body package="Store-Code Comparison">takeKeyboardFocus	self keyboardProcessor		ifNotNil: [:keyboardProcessor | keyboardProcessor requestActivationFor: self].	self makeVisible</body><body package="Store-Code Comparison">view	^self</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>menu</category><body package="Store-Code Comparison">menu		| menu |	menu := Menu new.	menu		augmentFrom: self class		to: AbstractComparisonRollupView		menuName: #menu		for: self.	^menu</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>menu-methods</category><body package="Store-Code Comparison">browseImageMethod: aMethodDefinition	(Refactory.Browser.MethodDefinitionEnvironment		onMethods: (Array with: aMethodDefinition)) openEditor</body><body package="Store-Code Comparison">browseStoreMethod: aStoreMethodInPackage	| storeInstanceBehavior storeClass |	storeInstanceBehavior := aStoreMethodInPackage classOrNameSpace.	storeClass := aStoreMethodInPackage definition isMetaclass				ifTrue: [storeInstanceBehavior storeMetaClass]				ifFalse: [storeInstanceBehavior].	((Store.Glorp.StoreMethodDefinitionEnvironment new)		environment: (Store.Glorp.StoreForGlorpBrowserEnvironment					on: aStoreMethodInPackage package);		addClass: storeClass selector: aStoreMethodInPackage selector) openEditor</body><body package="Store-Code Comparison">imageMethodDefinitionFrom: aMethodBlueprint	| classReference binding behavior |	classReference := aMethodBlueprint classReference.	classReference ifNil: [^nil].	binding := classReference bindingOrNil.	binding ifNil: [^nil].	binding isForClass ifFalse: [^nil].	behavior := binding value.	aMethodBlueprint isInstanceBehavior		ifFalse: [behavior := behavior classBehavior].	^(behavior includesSelector: aMethodBlueprint selector)		ifTrue: [MethodDefinition class: behavior selector: aMethodBlueprint selector]		ifFalse: [nil]</body><body package="Store-Code Comparison">loadMethod: aStoreMethodInPackage	aStoreMethodInPackage loadSource</body><body package="Store-Code Comparison">openMethodVersions: aCollectionOfStoreMethod	| tool listPart |	tool := Store.Glorp.DefinitionForListTool new.	listPart := Store.Glorp.MethodVersionsListPane new.	listPart tool: tool.	listPart fillListWith: aCollectionOfStoreMethod any allStoreVersions.	tool listPart: listPart.	tool open.	listPart itemsInList selections: aCollectionOfStoreMethod</body><body package="Store-Code Comparison">storeObjectVersionLabel: aStoreObjectInPackage	| ws |	ws := String new writeStream.	ws policy dateAndTimePolicy		printShort: aStoreObjectInPackage definition localTimestamp		on: ws.	^'(&lt;1s&gt;, &lt;2s&gt;, &lt;3s&gt;)'		expandMacrosWith: aStoreObjectInPackage package version		with: aStoreObjectInPackage definition username		with: ws contents</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison">infoTooltipText	| output notEmptyChunks |	notEmptyChunks := self tooltipTextChunks reject: #isEmpty.	notEmptyChunks isEmpty ifTrue: [^nil].	output := TextStream on: String new.	notEmptyChunks do: [:each | output nextPutAllText: each]		separatedBy: [output cr].	^output contents</body><body package="Store-Code Comparison">tooltipTextChunks	^Array new</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">childrenExpansionMemoryKey: anArray	^(Array with: #chidlrenOf) , anArray</body><body package="Store-Code Comparison">expansionMemoryKey	"Return an indirect object that can be used to remember a view looking at the same sort of thing."	^nil</body><body package="Store-Code Comparison">forgetIfCollapsedIn: aDictionary	| myKey |	myKey := self expansionMemoryKey.	self isExpanded ifFalse: [aDictionary removeKey: myKey ifAbsent: []].	aDictionary at: (self childrenExpansionMemoryKey: myKey)		ifPresent: 			[:subDictionary |			self rollupChildrenDo: [:each | each forgetIfCollapsedIn: subDictionary]]</body><body package="Store-Code Comparison">rememberIfExpandedIn: aDictionary	| myKey subDictionary |	myKey := self expansionMemoryKey.	self isExpanded ifTrue: [aDictionary at: myKey put: 0].	subDictionary := nil.	self rollupChildrenDo: 			[:each |			each rememberIfExpandedIn: (subDictionary						ifNil: [subDictionary := Dictionary new])].	(subDictionary isNil or: [subDictionary isEmpty])		ifFalse: 			[aDictionary at: (self childrenExpansionMemoryKey: myKey) put: subDictionary]</body><body package="Store-Code Comparison">restoreExpandedIn: aDictionary	| myKey |	myKey := self expansionMemoryKey.	(aDictionary includesKey: myKey) ifTrue: [self beExpanded].	aDictionary at: (self childrenExpansionMemoryKey: myKey)		ifPresent: 			[:subDictionary |			self populateDetailsIfNecessary.			self rollupChildrenDo: [:each | each restoreExpandedIn: subDictionary]]</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>bounds accessing</category><body package="Store-Code Comparison">preferredExtent	^super preferredExtent x @ (self header preferredHeight + (self detailsPanel preferredHeight * expandedFraction))</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>displaying</category><body package="Store-Code Comparison">drawDetailsBackroundOn: aGC	"not for me"</body><body package="Store-Code Comparison">drawDetailsBorderOn: aGC	"not for me"</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison">bindingDetailIcon: aSelector	^ComparisonIcons		perform: (#(#modifyClassAttributes #modifyBehaviorType #modifyClassInstanceVariables #modifyComment #modifyImports #modifyInstanceVariables #modifyIsPrivate #movePackage #modifySuperclass #moveCategory #modify #modifyIsConstant)				at: (#(#attributes #behaviorType #classInstanceVariables #comment #importsString #instanceVariables #isPrivate #packageName #superclassReference #category #initializer #isConstant)						indexOf: aSelector))</body><body package="Store-Code Comparison">bindingDetailSelectors	^self singularBlueprint bindingDetailSelectors sort</body><body package="Store-Code Comparison">bindingTest	^self subclassResponsibility</body><body package="Store-Code Comparison">enumerateBindingDetailChanges: aBlock	| selector |	(leftBlueprint isNil or: [rightBlueprint isNil]) ifTrue: [^self].	self bindingDetailSelectors sorted do: 			[:name |			selector := name asSymbol.			(leftBlueprint perform: selector) = (rightBlueprint perform: selector)				ifFalse: [aBlock value: selector]]</body><body package="Store-Code Comparison">expansionChangeFinished	super expansionChangeFinished.	self isExpanded		ifTrue: [self removeHeaderDetailHints]		ifFalse: [self addDetailHints]</body><body package="Store-Code Comparison">imageReferenceFrom: aBindingBlueprint	| bindingReference binding |	bindingReference := aBindingBlueprint ifNotNil: #reference.	bindingReference ifNil: [^nil].	binding := bindingReference bindingOrNil.	binding ifNil: [^nil].	^(binding perform: self bindingTest)		ifTrue: [bindingReference]		ifFalse: [nil]</body><body package="Store-Code Comparison">leftImageReference	^self imageReferenceFrom: leftBlueprint</body><body package="Store-Code Comparison">leftStoreObject	^leftBlueprint ifNotNil: #originalStoreObject</body><body package="Store-Code Comparison">liveObject	^self objectReference		ifNotNil: [:reference | reference bindingOrNil ifNotNil: #value]</body><body package="Store-Code Comparison">objectHeaderName	^self objectReference path last</body><body package="Store-Code Comparison">objectHeaderText	| text |	text := self objectHeaderName asText allBold.	self isAddition		ifTrue: 			[text				addEmphasis: (Array with: #color -&gt; (ColorValue red: 0 green: 0.6 blue: 0))				removeEmphasis: #()				allowDuplicates: false				from: 1				to: text size].	self isRemoval		ifTrue: 			[text				addEmphasis: (Array with: #color -&gt; ColorValue red)				removeEmphasis: #()				allowDuplicates: false				from: 1				to: text size].	^text</body><body package="Store-Code Comparison">rightImageReference	^self imageReferenceFrom: rightBlueprint</body><body package="Store-Code Comparison">rightStoreObject	^rightBlueprint ifNotNil: #originalStoreObject</body><body package="Store-Code Comparison">singularBlueprint	^leftBlueprint ifNil: [rightBlueprint]</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>testing</category><body package="Store-Code Comparison">browseInHierarchy	^false</body><body package="Store-Code Comparison">hasMenu	^true</body><body package="Store-Code Comparison">hasSameImageObject	^self leftImageReference		ifNil: [self rightImageReference notNil]		ifNotNil: 			[:left |			self rightImageReference ifNil: [true] ifNotNil: [:right | left = right]]</body><body package="Store-Code Comparison">isAddition	^leftBlueprint isNil and: [rightBlueprint notNil]</body><body package="Store-Code Comparison">isChange	^(self isAddition or: [self isRemoval]) not</body><body package="Store-Code Comparison">isRemoval	^rightBlueprint isNil and: [leftBlueprint notNil]</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison">addDetailHints	| detailsAtAGlance icons |	icons := self detailHintGraphics.	icons isEmpty ifTrue: [^self].	detailsAtAGlance := Panel new beRow: 0.5.	detailsAtAGlance propertyAt: #id put: #detailHints.	detailsAtAGlance add: '('.	icons do: [:each | detailsAtAGlance add: each]		separatedBy: [detailsAtAGlance add: ','].	detailsAtAGlance add: ')'.	self header updateFramesAfter: 			[self header children add: detailsAtAGlance				before: self header children last]</body><body package="Store-Code Comparison">annotateIconWithDisposition: aBaseGraphic	self isAddition ifTrue: [^VisualStack with: aBaseGraphic with: ComparisonIcons addedBindingOverlay].	self isRemoval ifTrue: [^VisualStack with: aBaseGraphic with: ComparisonIcons removedBindingOverlay].	^aBaseGraphic</body><body package="Store-Code Comparison">changedBindingDetailRows	| rows classDetailRowSelector |	rows := OrderedCollection new.	self enumerateBindingDetailChanges: 			[:selector |			classDetailRowSelector := (selector , 'ComparisonRow') asSymbol.			rows add: (self perform: classDetailRowSelector)].	^rows</body><body package="Store-Code Comparison">computeDetailRows	^self isChange		ifTrue: [self changedBindingDetailRows]		ifFalse: [self uniqueBindingDetailRows]</body><body package="Store-Code Comparison">defaultIcon	^self subclassResponsibility</body><body package="Store-Code Comparison">detailHintGraphics	| icons |	icons := OrderedCollection new.	self		enumerateBindingDetailChanges: [:selector | icons add: (self bindingDetailIcon: selector)].	^icons</body><body package="Store-Code Comparison">populateHeader	| headerRow objectIcon label |	super populateHeader.	self objectReference ifNil: [^self].	headerRow := self header.	objectIcon := self liveObject				ifNotNil: #safeToolListIcon				ifNil: [self defaultIcon].	label := Label with: self objectHeaderText.	headerRow		add: (self annotateIconWithDisposition: objectIcon);		add: label;		add: self moreInfoTooltipHandle.	self isExpanded ifFalse: [self addDetailHints]</body><body package="Store-Code Comparison">removeHeaderDetailHints	self header		removeAll: (self header children select: [:each | (each propertyAt: #id) = #detailHints])</body><body package="Store-Code Comparison">uniqueBindingDetailRows	^(self bindingDetailSelectors		collect: [:each | self perform: (each , 'SingularRow') asSymbol])			reject: #isNil</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison">objectReference	^self singularBlueprint ifNotNil: #reference</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison">isPrivateComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifyIsPrivate;		add: (self italicizedText: 'Private');		add: 'changed from';		add: leftBlueprint isPrivate toolListIcon;		add: 'to';		add: rightBlueprint isPrivate toolListIcon;		yourself</body><body package="Store-Code Comparison">isPrivateSingularRow	^self singularBlueprint isPrivate		ifTrue: 			[(self newRow)				add: self disclosureButtonSpace;				add: (self annotateIconWithDisposition: ComparisonIcons modifyIsPrivate);				add: (self italicizedText: 'Private');				add: self singularBlueprint isPrivate toolListIcon;				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison">packageNameComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons movePackage;		add: (self italicizedText: 'Package');		add: 'changed from';		add: leftBlueprint packageName asText allBold;		add: 'to';		add: rightBlueprint packageName asText allBold;		yourself</body><body package="Store-Code Comparison">packageNameSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons movePackage);		add: (self italicizedText: 'Package');		add: self singularBlueprint packageName asText allBold;		yourself</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison">browseImageObject: aBindingReference	| environment state |	environment := Refactory.Browser.BrowserEnvironment new.	state := Refactory.Browser.RefactoringBrowser navigatorStateClass new.	state objectName: aBindingReference.	Refactory.Browser.RefactoringBrowser		openOnEnvironment: environment		state: state		hierarchy: self browseInHierarchy</body><body package="Store-Code Comparison">browseStoreObject: aStoreObjectInPackage	| environment state |	environment := Store.Glorp.StoreForGlorpBrowserEnvironment				on: aStoreObjectInPackage package.	state := Store.Glorp.StoreRefactoringBrowser navigatorStateClass new.	state environment: environment.	state objectName: aStoreObjectInPackage fullName.	Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: environment		state: state		hierarchy: self browseInHierarchy</body><body package="Store-Code Comparison">loadObject: aStoreClass	aStoreClass loadSource</body><body package="Store-Code Comparison">openObjectVersions	| selections tool listPart |	selections := Set new.	self rightStoreObject		ifNotNil: [:storeObjectInPackage | selections add: storeObjectInPackage definition].	self leftStoreObject		ifNotNil: [:storeObjectInPackage | selections add: storeObjectInPackage definition].	tool := Store.Glorp.DefinitionForListTool new.	listPart := self versionListPaneClass new.	listPart tool: tool.	listPart fillListWith: selections any allStoreVersions.	tool listPart: listPart.	tool open.	listPart itemsInList selections: selections asArray</body><body package="Store-Code Comparison">versionListPaneClass	^self subclassResponsibility</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison">additionalInfoTooltipText	^Text new</body><body package="Store-Code Comparison">definingNamespaceReferences	| references |	references := OrderedCollection new.	leftBlueprint		ifNotNil: [:blueprint | references add: (self referenceNamespace: blueprint reference)].	rightBlueprint		ifNotNil: 			[:blueprint |			| rightReference |			rightReference := self referenceNamespace: blueprint reference.			(references includes: rightReference)				ifFalse: [references add: rightReference]].	^references</body><body package="Store-Code Comparison">definingPackageNames	| packages |	packages := OrderedCollection new.	leftBlueprint ifNotNil: [:blueprint | packages add: blueprint packageName].	rightBlueprint		ifNotNil: 			[:blueprint |			(packages includes: blueprint packageName)				ifFalse: [packages add: blueprint packageName]].	^packages</body><body package="Store-Code Comparison">namespaceInfoTooltipText	| output namespaces |	output := TextStream on: String new.	namespaces := self definingNamespaceReferences.	namespaces size = 1		ifTrue: [output nextPutAll: (#NamespaceC &gt;&gt; 'Namespace:' &lt;&lt; #IDE) asString].	namespaces size = 2		ifTrue: [output nextPutAll: (#NamespacesC &gt;&gt; 'Namespaces:' &lt;&lt; #IDE) asString].	namespaces isEmpty ifFalse: [output space].	namespaces do: 			[:each |			output				emphasis: #bold;				nextPutAll: each asSimplestReference asString;				emphasis: nil]		separatedBy: [output nextPut: $/].	^output contents</body><body package="Store-Code Comparison">packageInfoTooltipText	| output packages |	output := TextStream on: String new.	packages := self definingPackageNames.	packages size = 1		ifTrue: 			[output nextPutAll: (#DefinitionPackageC &gt;&gt; 'Package:' &lt;&lt; #IDE) asString].	packages size = 2		ifTrue: 			[output nextPutAll: (#DefinitionPackagesC &gt;&gt; 'Packages:' &lt;&lt; #IDE) asString].	packages isEmpty ifFalse: [output space].	packages do: 			[:each |			output				emphasis: #bold;				nextPutAll: each;				emphasis: nil]		separatedBy: [output nextPut: $/].	^output contents</body><body package="Store-Code Comparison">referenceNamespace: aBindingReference	^BindingReference path: (aBindingReference path allButLast: 1)</body><body package="Store-Code Comparison">tooltipTextChunks	^Array		with: self namespaceInfoTooltipText		with: self packageInfoTooltipText		with: self additionalInfoTooltipText</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^leftBlueprint		ifNotNil: [Array with: self bindingTest with: leftBlueprint reference]		ifNil: 			[rightBlueprint				ifNotNil: [Array with: self bindingTest with: rightBlueprint reference]]</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison">commentComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyComment		name: 'Comment'		leftText: leftBlueprint comment		rightText: rightBlueprint comment</body><body package="Store-Code Comparison">commentSingularRow	^self singularBlueprint comment size isZero		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self annotateIconWithDisposition: ComparisonIcons modifyComment)				name: 'Comment'				text: self singularBlueprint comment]</body><body package="Store-Code Comparison">importsStringComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyImports		name: 'Imports'		leftText: leftBlueprint importsString		rightText: rightBlueprint importsString</body><body package="Store-Code Comparison">importsStringSingularRow	^self singularBlueprint importsString isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self annotateIconWithDisposition: ComparisonIcons modifyImports)				name: 'Imports'				text: self singularBlueprint importsString]</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison">defaultIcon	^BehaviorIcons Namespace</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">leftNamespace: aNamespaceBlueprint rightNamespace: bNamespaceBlueprint	leftBlueprint := aNamespaceBlueprint.	rightBlueprint := bNamespaceBlueprint.	self populate</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison">bindingTest	^#isForNameSpace</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison">versionListPaneClass	^Store.Glorp.NameSpaceListPane</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison">addedMethodRow: aMethodBlueprint	^(SingleMethodView new)		method: aMethodBlueprint;		isAddition: true;		populate</body><body package="Store-Code Comparison">changedMethodRowFrom: anOriginalMethodBlueprint to: aChangedMethodBlueprint	^MethodComparisonView new leftMethod: anOriginalMethodBlueprint rightMethod: aChangedMethodBlueprint</body><body package="Store-Code Comparison">computeDetailRows	^super computeDetailRows , self methodRows</body><body package="Store-Code Comparison">defaultIcon	^BehaviorIcons Object</body><body package="Store-Code Comparison">detailHintGraphics	| icons addedMethodCount changedMethodCount removedMethodCount changedCategoryCount changedPackageCount |	icons := super detailHintGraphics.	addedMethodCount := changedMethodCount := removedMethodCount := changedCategoryCount := changedPackageCount := 0.	self		enumerateOrderedMethodAdditions: [addedMethodCount := addedMethodCount + 1]		removals: [removedMethodCount := removedMethodCount + 1]		changes: 			[:a :b |			a source = b source				ifFalse: [changedMethodCount := changedMethodCount + 1].			a category = b category				ifFalse: [changedCategoryCount := changedCategoryCount + 1].			a packageName = b packageName				ifFalse: [changedPackageCount := changedPackageCount + 1]].	changedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons modify						with: (Label with: 'Ã' , changedMethodCount printString))].	changedPackageCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons movePackage						with: (Label with: 'Ã' , changedPackageCount printString))].	changedCategoryCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons moveCategory						with: (Label with: 'Ã' , changedCategoryCount printString))].	addedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons add						with: (Label with: 'Ã' , addedMethodCount printString))].	removedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons remove						with: (Label with: 'Ã' , removedMethodCount printString))].	^icons</body><body package="Store-Code Comparison">methodRows	| rows adds removes |	rows := OrderedCollection new.	adds := OrderedCollection new.	removes := OrderedCollection new.	self		enumerateOrderedMethodAdditions: 			[:addedMethod |			rows add: (adds addLast: (self addedMethodRow: addedMethod))]		removals: 			[:removedMethod |			rows add: (removes addLast: (self removedMethodRow: removedMethod))]		changes: 			[:removedMethod :addedMethod |			rows add: (self changedMethodRowFrom: removedMethod to: addedMethod)].	self correlateRenamesFrom: adds to: removes.	^rows</body><body package="Store-Code Comparison">removedMethodRow: aMethodBlueprint	^(SingleMethodView new)		method: aMethodBlueprint;		isAddition: false;		populate</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">initialize	super initialize.	rightMethods := leftMethods := Array new</body><body package="Store-Code Comparison">leftClass: aClassBlueprint leftMethods: aSequenceOfMethodBlueprints rightClass: bClassBlueprint rightMethods: bSequenceOfMethodBlueprints	(aClassBlueprint isNil and: 			[aSequenceOfMethodBlueprints isEmpty				and: [bClassBlueprint isNil and: [bSequenceOfMethodBlueprints isEmpty]]])		ifTrue: [^self halt].	leftBlueprint := aClassBlueprint.	leftMethods := aSequenceOfMethodBlueprints.	rightBlueprint := bClassBlueprint.	rightMethods := bSequenceOfMethodBlueprints.	self populate</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>displaying</category><body package="Store-Code Comparison">drawDetailsBackroundOn: aGC	| box oldPaint oldStrokeWidth hue |	oldPaint := aGC paint.	oldStrokeWidth := aGC lineWidth.	hue := ColorValue orange hue.	aGC lineWidth: 2.	self detailsPanel childrenDo: 			[:row |			(row propertyAt: #linkTo)				ifNotNil: 					[:target |					box := ((Rectangle vertex: row frame topLeft vertex: target frame topLeft)								expandedBy: (self indent - 1) @ 0) translatedBy: 0 @ 8.					aGC paint: (ColorValue hue: hue saturation: 1 brightness: 0.6).					hue := (hue + 0.4) \\ 1.0.					aGC						displayArcBoundedBy: box rounded						startAngle: 90						sweepAngle: 180						at: self detailsPanel frame origin rounded]].	aGC		paint: oldPaint;		lineWidth: oldStrokeWidth</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison">bindingTest	^#isForClass</body><body package="Store-Code Comparison">correlateRenamesFrom: addMethodViews to: removeMethodViews	| matches map |	(addMethodViews isEmpty or: [removeMethodViews isEmpty]) ifTrue: [^self].	map := Dictionary new.	addMethodViews do: 			[:eachAdd |			eachAdd parseTree				ifNotNil: 					[:addTree |					matches := removeMethodViews select: 									[:eachRemove |									eachRemove parseTree										ifNil: [false]										ifNotNil: 											[:removeTree |											"overridden to take both methods' arguments into account"											addTree arguments size = removeTree arguments size 												and:[													addTree body														equalTo: removeTree body														exceptForNewVariables: (addTree arguments collect: #name)														oldVariables: (removeTree arguments collect: #name)]]].					matches size = 1						ifTrue: [(map at: matches any ifAbsentPut: [IdentitySet new]) add: eachAdd]]].	map keysAndValuesDo: 			[:eachRemove :allAdds |			allAdds size = 1 ifTrue: [allAdds any propertyAt: #linkTo put: eachRemove]]</body><body package="Store-Code Comparison">enumerateOrderedMethodAdditions: additionBlock removals: removalBlock changes: changeBlock	| additionStack removalStack |	additionStack := OrderedCollection withAll: rightMethods.	removalStack := OrderedCollection withAll: leftMethods.	[additionStack isEmpty and: [removalStack isEmpty]] whileFalse: 			[additionStack isEmpty				ifTrue: [removalBlock cull: removalStack removeFirst]				ifFalse: 					[removalStack isEmpty						ifTrue: [additionBlock cull: additionStack removeFirst]						ifFalse: 							[(additionStack first isSameSignatureAs: removalStack first)								ifTrue: 									[changeBlock cull: removalStack removeFirst cull: additionStack removeFirst]								ifFalse: 									[(additionStack first isSignatureLess: removalStack first)										ifTrue: [additionBlock cull: additionStack removeFirst]										ifFalse: [removalBlock cull: removalStack removeFirst]]]]]</body><body package="Store-Code Comparison">imageReferenceFrom: aClassBlueprint orMethods: aMethodArray	| classReference binding |	classReference := aClassBlueprint ifNotNil: #reference.	(classReference isNil and: [aMethodArray notEmpty])		ifTrue: [classReference := aMethodArray any classReference].	classReference ifNil: [^nil].	binding := classReference bindingOrNil.	binding ifNil: [^nil].	^binding isForClass ifTrue: [classReference] ifFalse: [nil]</body><body package="Store-Code Comparison">leftImageReference	^self imageReferenceFrom: leftBlueprint orMethods: leftMethods</body><body package="Store-Code Comparison">leftStoreObject	^leftBlueprint		ifNotNil: #originalStoreObject		ifNil: 			[leftMethods do: 					[:blueprint |					blueprint originalStoreObject						ifNotNil: 							[:storeMethodInPackage |							(self storeClassForMethod: storeMethodInPackage)								ifNotNil: [:storeClassInPackage | ^storeClassInPackage]]].			nil]</body><body package="Store-Code Comparison">rightImageReference	^self imageReferenceFrom: rightBlueprint orMethods: rightMethods</body><body package="Store-Code Comparison">rightStoreObject	^rightBlueprint		ifNotNil: #originalStoreObject		ifNil: 			[rightMethods do: 					[:blueprint |					blueprint originalStoreObject						ifNotNil: 							[:storeMethodInPackage |							(self storeClassForMethod: storeMethodInPackage)								ifNotNil: [:storeClassInPackage | ^storeClassInPackage]]].			nil]</body><body package="Store-Code Comparison">storeClassForMethod: aStoreMethodInPackage	^(aStoreMethodInPackage package		objectNamed: aStoreMethodInPackage fullClassName)			ifNotNil: #classDefinition</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison">attributesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyClassAttributes		name: 'Attributes'		leftText: leftBlueprint attributes printString		rightText: rightBlueprint attributes printString</body><body package="Store-Code Comparison">attributesSingularRow	^self singularBlueprint attributes isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyClassAttributes)				name: 'Attributes'				text: self singularBlueprint attributes printString]</body><body package="Store-Code Comparison">behaviorTypeComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifyBehaviorType;		add: (self italicizedText: 'Type');		add: 'changed from';		add: leftBlueprint behaviorType asText allBold;		add: 'to';		add: rightBlueprint behaviorType asText allBold;		yourself</body><body package="Store-Code Comparison">behaviorTypeSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons modifyBehaviorType);		add: (self italicizedText: 'Type');		add: self singularBlueprint behaviorType asText allBold;		yourself</body><body package="Store-Code Comparison">classInstanceVariablesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyClassInstanceVariables		name: 'Class Instance Variables'		leftText: (self				formattedInstanceVariables: leftBlueprint classInstanceVariables)		rightText: (self				formattedInstanceVariables: rightBlueprint classInstanceVariables)</body><body package="Store-Code Comparison">classInstanceVariablesSingularRow	^self singularBlueprint classInstanceVariables isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyClassInstanceVariables)				name: 'Class Instance Variables'				text: (self						formattedInstanceVariables: self singularBlueprint classInstanceVariables)]</body><body package="Store-Code Comparison">formattedInstanceVariables: anInstanceVariableSequence	| ws |	ws := String new writeStream.	anInstanceVariableSequence do: [:each | ws nextPutAll: each]		separatedBy: [ws cr].	^ws contents</body><body package="Store-Code Comparison">instanceVariablesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyInstanceVariables		name: 'Instance Variables'		leftText: (self formattedInstanceVariables: leftBlueprint instanceVariables)		rightText: (self				formattedInstanceVariables: rightBlueprint instanceVariables)</body><body package="Store-Code Comparison">instanceVariablesSingularRow	^self singularBlueprint instanceVariables isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyInstanceVariables)				name: 'Instance Variables'				text: (self						formattedInstanceVariables: self singularBlueprint instanceVariables)]</body><body package="Store-Code Comparison">superclassReferenceComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifySuperclass;		add: (self italicizedText: 'Superclass');		add: 'changed from';		add: (self fullReferenceDisplayName: leftBlueprint superclassReference);		add: 'to';		add: (self fullReferenceDisplayName: rightBlueprint superclassReference);		yourself</body><body package="Store-Code Comparison">superclassReferenceSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons modifySuperclass);		add: (self italicizedText: 'Superclass');		add: (self					fullReferenceDisplayName: self singularBlueprint superclassReference);		yourself</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison">objectReference	^super objectReference		ifNil: 			[leftMethods isEmpty				ifFalse: [leftMethods any classReference]				ifTrue: 					[rightMethods isEmpty						ifTrue: [nil]						ifFalse: [rightMethods any classReference]]]</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>testing</category><body package="Store-Code Comparison">browseInHierarchy	^true</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison">versionListPaneClass	^Store.Glorp.ClassListPane</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison">additionalInfoTooltipText	| output extendingPackages |	extendingPackages := (leftMethods , rightMethods collect: #packageName)				asSet.	self definingPackageNames		do: [:each | extendingPackages remove: each ifAbsent: []].	output := TextStream on: String new.	extendingPackages isEmpty ifTrue: [^output contents].	output		nextPutAll: (#ExtensionPackagesC &gt;&gt; 'Other Packages:' &lt;&lt; #IDE) asText.	output space.	extendingPackages sorted do: 			[:each |			output				emphasis: #bold;				nextPutAll: each;				emphasis: nil]		separatedBy: [output nextPut: $/].	^output contents</body><body package="Store-Code Comparison">definingNamespaceReferences	"When we have no class blueprints (unique to class variant), we probe the first method on each side for the information."	| references |	(leftBlueprint isNil and: [rightBlueprint isNil])		ifFalse: [^super definingNamespaceReferences].	references := OrderedCollection new.	leftMethods isEmpty		ifFalse: 			[references add: (self referenceNamespace: leftMethods any classReference)].	rightMethods isEmpty		ifFalse: 			[| rightReference |			rightReference := self referenceNamespace: rightMethods any classReference.			(references includes: rightReference)				ifFalse: [references add: rightReference]].	^references</body><body package="Store-Code Comparison">definingPackageNames	"When we have no class blueprints (unique to class variant), we use the method packages IF and only IF, they are consistent."	| packages leftPackages rightPackages |	(leftBlueprint isNil and: [rightBlueprint isNil])		ifFalse: [^super definingPackageNames].	packages := OrderedCollection new.	leftPackages := (leftMethods collect: #packageName) asSet.	rightPackages := (rightMethods collect: #packageName) asSet.	leftPackages size = 1 ifTrue: [packages add: leftPackages any].	rightPackages size = 1		ifTrue: 			[(packages includes: rightPackages any)				ifFalse: [packages add: rightPackages any]].	^packages</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^super expansionMemoryKey		ifNil: 			[leftMethods isEmpty				ifTrue: 					[rightMethods isEmpty						ifTrue: [nil]						ifFalse: [Array with: self bindingTest with: rightMethods any classReference]]				ifFalse: [Array with: self bindingTest with: leftMethods any classReference]]</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>utility</category><body package="Store-Code Comparison">fullReferenceDisplayName: aBindingReference	| path output nsPath |	aBindingReference ifNil: [^'nil' asText allBold].	path := aBindingReference path.	output := TextStream on: String new.	output		emphasis: #bold;		nextPutAll: path last;		emphasis: nil;		nextPutAll: ' in {'.	nsPath := path allButLast: 1.	(nsPath size &gt; 2 and: [(nsPath first: 2) = #(#Root #Smalltalk)])		ifTrue: [nsPath := nsPath allButFirst: 2].	nsPath do: [:each | output nextPutAll: each]		separatedBy: [output nextPut: $.].	output nextPut: $}.	^output contents</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView class</class-id> <category>example</category><body package="Store-Code Comparison">compareTwoClasses	"self compareTwoClasses"	| leftClass rightClass leftMethods rightMethods differences view scrolled |	leftClass := (IncrementalSearchDialog selectClass: 'First (left) class?')				ifNil: [^self].	rightClass := (IncrementalSearchDialog				selectClass: 'Second (right) class?') ifNil: [^self].	leftMethods := (leftClass getMethodDictionary values				, leftClass class getMethodDictionary values collect: #definition)				collect: #asBlueprint.	rightMethods := (rightClass getMethodDictionary values				, rightClass class getMethodDictionary values collect: #definition)				collect: #asBlueprint.	differences := (SequenceableCollectionDifferences new)				comparisonFunction: [:a :b | a &gt;=&lt; b];				differencesFrom: leftMethods sort to: rightMethods sort.	leftMethods := (differences select: #isDelete) inject: Array new				into: [:accum :each | accum , each].	rightMethods := (differences select: #isInsert) inject: Array new				into: [:accum :each | accum , each].	view := (ClassBlueprintComparisonView new)				leftClass: leftClass asBlueprint					leftMethods: leftMethods					rightClass: rightClass asBlueprint					rightMethods: rightMethods;				toggleExpansion.	scrolled := (BorderDecorator on: view) useVerticalScrollbar.	scrolled scrollerComponent scrollOffsetHolder grid: 1 @ 20.	(ScheduledWindow new)		component: scrolled;		openWithExtent: 800 @ 800</body></methods><methods><class-id>Store.Publishing</class-id> <category>accessing</category><body package="Store-Publishing Support">actionText	^(#Publishing &lt;&lt; #store &gt;&gt; 'Publishing') asString</body><body package="Store-Publishing Support">componentName	^'&lt;1s&gt;(&lt;2s&gt;)' expandMacrosWith: subject pundle name with: subject version</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>accessing</category><body package="Store-Database Model">absoluteName	^self definition absoluteName</body><body package="Store-Database Model">absoluteSymbol	^self definition absoluteSymbol</body><body package="StoreForGlorpVWUI">actual	^self definition actual.</body><body package="Store-Database Model">application	^self package yourSelf.</body><body package="Store-Database Model">bracketedVersionString	^'(&lt;1s&gt;, &lt;2s&gt;)' expandMacrosWith: self timestamp printString with: self definition userName</body><body package="Store-Database Model">browserIcon	^nil</body><body package="Store-Database Model">definition	^definition</body><body package="Store-Database Model">definition: aStoreObject	definition := aStoreObject</body><body package="StoreForGlorpVWUI">definitionAndComment	^self definition definitionAndComment.</body><body package="Store-Database Model">definitionObject	^definition</body><body package="Store-Database Model">definitionString	^self definition isNil ifTrue: [''] ifFalse: [self definition definitionString].</body><body package="StoreForGlorpVWUI">environmentString	^self definition isNil ifTrue: [''] ifFalse: [self definition environmentString].</body><body package="Store-Database Model">fullName	^self longName.</body><body package="Store-Database Model">longName	^self definition longName.</body><body package="Store-Database Model">name	^self definition name.</body><body package="Store-Database Model">package	^package</body><body package="Store-Database Model">package: aStorePackage	package := aStorePackage</body><body package="Store-Database Model">prerequisitesForAtomicLoading	"If we're trying to sort one of our in-database class definitions, there's not much we can do. Just return an empty list of prerequisites."	"NOTE: No User Subclass Class Should Implement This Method"	^OrderedCollection with: self</body><body package="Store-Database Model">prerequisitesForLoading	"If we're trying to sort one of our in-database class definitions, there's not much we can do. Just return an empty list of prerequisites."	^OrderedCollection new.</body><body package="Store-Database Model">primaryKey	"This is important because we may hand these objects to Store with it thinking they're records for the definitions"	^self definition primaryKey.</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	^self definition source</body><body package="StoreForGlorpVWUI">simpleName	^self name</body><body package="Store-Database Model">timestamp	^self package timestamp.</body><body package="Store-Database Model">value	^definition.</body><body package="Store-Database Model">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printString with: self definition userName)</body><body package="Store-Database Model">versions	self subclassResponsibility</body><body package="Store-Database Model">xmlDefinition	^self definition xmlDefinition</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>comparing</category><body package="Store-Database Model">&lt; aStoreObjectInPackage	^self definitionString &lt; aStoreObjectInPackage definitionString.</body><body package="Store-Database Model">&lt;= aStoreObjectInPackage	^self definition &lt;= aStoreObjectInPackage definition.</body><body package="StoreForGlorpVWUI">comparesTo: anObject	^self class = anObject class and: [(self package comparesTo: anObject package) and: [self definition comparesTo: anObject definition]]</body><body package="Store-Database Model">hash	^self package yourSelf hash bitXor: self definition yourSelf hash.</body><body package="Store-Database Model">sourceMatches: aStoreObject	^self definition sourceMatches: aStoreObject definition.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>reconciling</category><body package="Store-Database Model">unreconcile	self definition unreconcile.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>testing</category><body package="Store-Database Model">belongsToClass	^self definition belongsToClass.</body><body package="Store-Database Model">isExtension	^false</body><body package="StoreForGlorpVWUI">isLoaded	^false.</body><body package="StoreForGlorpVWUI">isPseudo	^false.</body><body package="Store-Database Model">isStoreDefinitionInPackage	^true</body><body package="StoreForGlorpVWUI">matchesWith: aStoreMethodInPackage	^self definition = aStoreMethodInPackage definition</body><body package="Store-Database Model">sameAsDBThing: anObject	^self = anObject.</body><body package="Store-Database Model">sameAsImage	"Answer true if the receiver is the same as the image version."	^self definition sameAsImage.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	package := package glorpCopyIn: aDictionary.	definition := definition glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>printing</category><body package="Store-Database Model">fileOutSourceOn: aSourceFileManager	self subclassResponsibility</body><body package="Store-Database Model">printOn: aStream	aStream nextPut: $(.	self definition printOn: aStream.	aStream nextPutAll: ' in '.	self package printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>private</category><body package="Store-Database Model">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	aStream sourceFormatter attributeFor: #package compute: [:ignored | self package name].	aStream sourceFormatter attributeForMethods: #package compute: [:ignored :more | self package name].	aStream storeObjectDefinition: self.</body><body package="Store-Database Model">fileOutOn: aSourceFileManager		aSourceFileManager addComment: self longName.	self fileOutSourceOn: aSourceFileManager.	aSourceFileManager cr</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>displaying</category><body package="Store-Database Model">fullDisplayString	^'[&lt;3s&gt;] &lt;1s&gt; &lt;2s&gt;' 		expandMacrosWith: self displayString		with: self bracketedVersionString		with: self package name</body><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^self definition longNameFromSmalltalk</body><body package="StoreForGlorpVWUI">longNameWithMetaFromSmalltalk	^self definition longNameWithMetaFromSmalltalk</body><body package="StoreForGlorpVWUI">shortItemString	^self longNameFromSmalltalk</body><body package="StoreForGlorpVWUI">text	^self definitionString</body><body package="StoreForGlorpVWUI">timeStampString	^self definition timeStampString</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>converting</category><body package="Store-Database Model">asStoreObjectInPackage: aPackage	^self</body><body package="Store-Database Model">asText	^self definition asText</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>atomic loading</category><body package="Atomic Compiling and Loading">asShadowedObjectIn: aPackage	^self shadowedObjectClass newFrom: self</body><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	self subclassResponsibility</body><body package="Glorp Atomic Compiling">shadowedObjectClass	self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage class</class-id> <category>database utility</category><body package="Store-Database Model">allPackagesContaining: aStoreDefinitionInPackage	^self allPackagesContaining: aStoreDefinitionInPackage in: aStoreDefinitionInPackage package session</body><body package="Store-Database Model">allPackagesContaining: aStoreDefinitionInPackage in: aSession	| query session objects |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: 			[:eachObject | 			eachObject definition name = aStoreDefinitionInPackage name AND: 				[eachObject definition primaryKey = aStoreDefinitionInPackage definitionObject primaryKey]].	query alsoFetch: #definition.	query alsoFetch: [:eachObject | eachObject package].	query orderBy: [:each | each package timestamp descending].	objects := session execute: query.	^objects collect: [:each | each package]</body><body package="Store-Database Model">allVersionsWithName: aString	^self allVersionsWithName: aString in: nil</body><body package="Store-Database Model">allVersionsWithName: aString in: aSession	| query session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachObject | (eachObject definition name = aString)			AND: [eachObject package timestamp = (				(Query					readOneOf: self					where: [:eachObject2 | eachObject2 definition id = eachObject definition id]					)					retrieve: [:eachObject2 | eachObject2 package timestamp min];					yourself)]].	query alsoFetch: #definition.	query alsoFetch: [:eachObject | eachObject definition definition].	query orderBy: [:eachObject | eachObject definition timestamp descending].	query orderBy: [:eachObject | eachObject package timestamp].	^(session execute: query) asOrderedCollection</body><body package="Store-Database Model">allVersionsWithName: aString inOwner: anOwnerName	^self allVersionsWithName: aString inOwner: anOwnerName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allVersionsWithName: aString inOwner: anOwnerString in: aSessionOrNil	| query session |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachObject | ((eachObject definition name = aString)			AND: [eachObject definition environmentName = anOwnerString])			AND: [eachObject package timestamp = (				(Query					readOneOf: self					where: [:eachObject2 | eachObject2 definition id = eachObject definition id]					)					retrieve: [:eachObject2 | eachObject2 package timestamp min];					yourself)]].	query alsoFetch: #definition.	query alsoFetch: [:eachObject | eachObject definition definition].	query orderBy: [:eachObject | eachObject definition timestamp descending].	query orderBy: [:eachObject | eachObject package timestamp].	^(session execute: query) asOrderedCollection</body><body package="Store-Database Model">removeDuplicatesFrom: objects	| uniqueKeys |	uniqueKeys := Set new.	^objects inject: OrderedCollection new		into: 			[:sum :each |			(uniqueKeys includes: each primaryKey)				ifFalse: 					[uniqueKeys add: each primaryKey.					sum add: each].			sum]</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString	"Produce a dialogue that answers a store class definitin in package object or nil."		^self selectStoreVersionOf: aString in: nil</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString in: aSession	"Produce a dialogue that answers a store class definitin in package object or nil."		^self selectStoreVersionOf: aString in: aSession warnIfNone: true</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString in: aSession warnIfNone: aBoolean	"Produce a dialogue that answers a store class definitin in package object or nil."		| list session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	list := self allVersionsWithName: aString in: session.	list isEmpty ifTrue:		[aBoolean ifTrue: [Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions') asString].		^nil].	list size == 1 ifTrue: [^list first].	^Dialog		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list collect: [:each | each longNameFromSmalltalk, ' ', each definition timeStampString])		values: list		lines: 10		cancel: [^nil]		for: nil</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString warnIfNone: aBoolean	"Produce a dialogue that answers a store class definitin in package object or nil."		^self selectStoreVersionOf: aString in: nil warnIfNone: aBoolean</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>accessing</category><body package="Store-Code Comparison">asBlueprint	| definitionParts myReference blueprint |	blueprint := NamespaceBlueprint of: self.	definitionParts := blueprint parseDefinition: self definition definition.	myReference := self fullName asQualifiedReference.	blueprint reference: myReference.	blueprint isPrivate: (definitionParts at: #private:).	blueprint importsString: (definitionParts at: #imports:).	self comment ifNotNil: [:string | blueprint comment: string].	^blueprint</body><body package="Store-Database Model">asNameSpace	"hack"	^StoreNameSpace new</body><body package="Store-Database Model">comment	^self definition comment</body><body package="Store-Database Model">correspondingImageNamespace	^definition correspondingImageNamespace</body><body package="Store-Database Model">isForClass	^false</body><body package="StoreForGlorpBrowserUI">isForGeneral	^false.</body><body package="Store-Database Model">organization	^self definition organization</body><body package="StoreForGlorpVWUI">removeFromPackage: aPackageModel	"For adding a removal of unloaded defintions from the change sets."	Store.XMainChangeSet current		addRemoveNameSpace: self absoluteName		package: aPackageModel</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := self definition source.	insertPoint := definitionString indexOfSubCollection: 'defineNameSpace:' startingAt: 1.	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Store-Database Model">versions	| session query namespaces uniqueKeys |	session := StoreLoginFactory currentStoreSession.	query := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	query alsoFetch: #definition.	query alsoFetch: [:eachClass | eachClass definition definition].	query orderBy: [:each | each definition timestamp descending].	namespaces := session execute: query.	uniqueKeys := Set new.	^namespaces inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>comparing</category><body package="Store-Database Model">= aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifTrue:		[^self package yourSelf = aStoreObjectInPackage package yourSelf			and: [self definition reconcilesWith: aStoreObjectInPackage definition]].	(aStoreObjectInPackage respondsTo: #asStoreNameSpace) ifFalse: [^false]."Any aStoreObjectInPackage reaching here replies true to isForNameSpace so we need not check it.	self isForNameSpace == aStoreObjectInPackage isForNameSpace and:"	^self definition = aStoreObjectInPackage asStoreNameSpace</body><body package="Store-Database Model">equalsSignatureIn: aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifFalse: [		^self definition equalsSignatureIn: aStoreObjectInPackage asStoreNameSpace].	^self package yourSelf = aStoreObjectInPackage package yourSelf and: [self definition equalsSignatureIn: aStoreObjectInPackage definition].</body><body package="Store-Database Model">signatureHash	^self definition signatureHash</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>printing</category><body package="StoreForGlorpVWUI">asString	^self longName</body><body package="StoreForGlorpVWUI">displayString	^self name</body><body package="Store-Database Model">printOutOn: aStream	"Print me out on a textStream"	| saved |	saved := aStream emphasis.	aStream emphasis: #bold.	aStream nextPutAll: self definitionString.	aStream cr.	aStream emphasis: #italic.	aStream cr.	aStream nextPutAll: self comment.	aStream emphasis: saved.	aStream cr.	aStream cr</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>filing out</category><body package="Store-Database Model">fileOutDifferencesBetween: aNamespaceInPackage on: aSourceCodeStream	self definitionString = aNamespaceInPackage definitionString ifFalse:		[self fileOutSourceOn: aSourceCodeStream]</body><body package="Store-Database Model">fileOutObjectType	^#nameSpace</body><body package="Store-Database Model">fileOutSourceOn: aSourceFileManager	aSourceFileManager storeObjectDefinition: self</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>private</category><body package="Store-Database Model">fileOutOn: aSourceFileManager		super fileOutOn: aSourceFileManager.	self comment notEmpty ifTrue: [aSourceFileManager comment: self value: self comment]</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>testing</category><body package="Store-Database Model">isForNameSpace	^true</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>loading</category><body package="Store-Database Model">loadNewSource: aString	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableNamespaceMsgForUnspecifiedParent inPackage: self package].	Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[| binding |			binding := self evaluateDefinition: aString				onError: [:exception | ^self raiseUnloadableError: exception inPackage: self package].			self comment notEmpty ifTrue: [binding comment: self comment]]</body><body package="Store-Database Model">loadSource	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableNamespaceMsgForUnspecifiedParent inPackage: self package].	Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[| binding cmt |			binding := self evaluateDefinition: self definitionString				onError: [:exception | ^self raiseUnloadableError: exception inPackage: self package].			self halt.			((cmt := self comment) notNil and: [cmt notEmpty]) 				ifTrue: [binding comment: cmt]				ifFalse: [binding comment: nil].			(self package sharedVariablesForClass: self) do: [:each | each loadSource]]</body><body package="Store-Database Model">loadSourceDirect	^self definition loadSourceDirectInPackage: self package</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">toolListIcon		^BehaviorIcons Namespace</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>enumeration</category><body package="StoreForGlorpVWUI">allStoreVersions	^[(Gathering for: self name) started.		self class allVersionsWithName: self name]		ensure: [(Gathering for: self name) finished]</body><body package="StoreForGlorpVWUI">bindingFor: aKey	self package sharedVariableWithLongName: (self longName, '.' , aKey asString)</body><body package="StoreForGlorpVWUI">bindingsDo: ignore	^self</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI">fullyQualifiedReference	^(BindingReference simpleName: self name) home: self</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStoreNameSpace	^self definition</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeNamespace: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedNamespaceObject</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage class</class-id> <category>instance creation</category><body package="Store-Database Model">newFor: aNamespace package: aPackage		| namespaceDefinition |	namespaceDefinition := aNamespace asStoreNameSpace.	namespaceDefinition updateUserAndTimestampFrom: aPackage.	^(self new)		definition: namespaceDefinition;		package: aPackage</body></methods><methods><class-id>Store.LoadOrSaveActionError class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreBundleFileRelationship</class-id> <category>accessing</category><body package="Store-Database Model">bundleID	^bundleID</body><body package="Store-Database Model">bundleID: anInteger	bundleID := anInteger</body><body package="Store-Database Model">expressionID	^expressionID</body><body package="Store-Database Model">expressionID: anInteger	expressionID := anInteger</body><body package="Store-Database Model">fileID	^fileID</body><body package="Store-Database Model">fileID: anInteger	fileID := anInteger</body><body package="Store-Database Model">sequence	^sequence</body><body package="Store-Database Model">sequence: anInteger	sequence := anInteger</body></methods><methods><class-id>Store.AbstractPundleLoader</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">loadFailOption	^self class loadFailOption</body></methods><methods><class-id>Store.AbstractPundleLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading">invokeClassCreationMessage: aMessageSend	"The given MessageSend has been compiled from a class definition.	Evaluate it to finally create (define) the class. Suppress ClassConstructionError warnings.	Answer the new class."	^[self invokeCreationMessage: aMessageSend] on: Kernel.ClassConstructionError do: [:ex | ex resume]</body><body package="Atomic Compiling and Loading">invokeCreationMessage: aMessageSend	"The given MessageSend has been compiled from a namespace/class/shared definition.	Evaluate it to finally create (define) the object. 	Suppress those general warnings about variable naming conventions.	Answer the result."	^[aMessageSend value] on: VariableConfirmation do: [:ex | ex resume: false]</body></methods><methods><class-id>Store.AbstractPundleLoader class</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">loadFailOption	^LoadFailedOption value</body></methods><methods><class-id>Store.AbstractPundleLoader class</class-id> <category>unloadable definition messages</category><body package="Atomic Compiling and Loading">uninstalledCodeMessage	^(#UninstalledCode &lt;&lt; #store &gt;&gt;  'Uninstalled Code')</body><body package="Atomic Compiling and Loading">unloadableClassOrNameSpaceMessageForMissingParent: parentName type: parentType	"Alternative wording in the AtomicLoader was 'Owner &lt;1p&gt; does not exist'. Replacing that one with this one. 	Is there another place where namespace shareds get handled?  Do we have tests?"	^(#UDefClassOrNamespaceDueToMissingParentAndType &lt;&lt; #store &gt;&gt; 'Namespace &lt;1p&gt; for &lt;2s&gt; is not loaded')		expandMacrosWith: parentName with: (parentType asLowercase)</body><body package="Atomic Compiling and Loading">unloadableMethodMessageForUnloadedClass: aClassName	^(#UDefMethodDueToUnloadedClass &lt;&lt; #store &gt;&gt; 'Class &lt;1p&gt; for method is not loaded')		expandMacrosWith: aClassName</body><body package="Atomic Compiling and Loading">unloadableNameSpaceMessageForMissingParent: parentName type: parentType	"Alternative wording in the AtomicLoader was 'Owner &lt;1p&gt; does not exist'. Replacing that one with this one. 	Is there another place where namespace shareds get handled?  Do we have tests?"	^(#UDefNamespaceDueToMissingParentAndType &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2p&gt; for namespace is not loaded')		expandMacrosWith: parentType with: parentName</body><body package="Atomic Compiling and Loading">unloadableNamespaceMsgForUnspecifiedParent	"The pre-UserMessage version of this was 'Home namespace not specified'. Parent seems clearer."	^(#UDefNamespcDueToUnspecifiedParent &lt;&lt; #store &gt;&gt; 'Parent namespace not specified')</body><body package="Atomic Compiling and Loading">unloadableSharedMessageForMissingParent: parentName type: parentType	"Alternative wording in the AtomicLoader was 'Owner &lt;1p&gt; does not exist'. Replacing that one with this one. 	Is there another place where namespace shareds get handled?  Do we have tests?"	^(#UDefSharedDueToMissingParentAndType &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2p&gt; for shared variable is not loaded')		expandMacrosWith: parentType with: parentName</body><body package="Atomic Compiling and Loading">unloadableSharedMessageForPossibleLoadOrder: sharedName	^(#UDefSharedDueToPossLoadOrder &lt;&lt; #store &gt;&gt;  '&lt;n&gt;Shared Variable &lt;1p&gt; is not loadable... Possible load order problem&lt;n&gt;')		expandMacrosWith: sharedName</body><body package="Atomic Compiling and Loading">unloadableSharedMessageForUnspecifiedClass	^(#UDefSharedDueToUnspecifiedClass &lt;&lt; #store &gt;&gt; 'Class for shared variable is not specified')</body></methods><methods><class-id>Store.AtomicLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading">collectShadowedRedefinition: aNotification	"We need to capture the overrides as the system notifies of them.  Unfortunately, the overrides	 are not in a state that is installable.  We will fix that later."	overrides add: aNotification override.	aNotification resume.</body><body package="Atomic Compiling and Loading">installCompilationResult: aResult	"Note that we use an explicit linkSystem rather than a modifySystem: call. 	We are very likely to have invalid bindings in the code we just installed, referring to shadow. 	We need those flushed before we run the initializers."	aResult package isComponentLoaded ifFalse: [aResult pundle runPreRead ifFalse: [^nil]].	aResult package runPreLoad ifFalse: [^nil].	packageModel := aResult package createImagePundle.	self resetInitializerCollections.	aResult packageDifferences ifNotNil: 		[:value |		value hasDifferences ifFalse: 			[aResult package postLoad: packageModel.			aResult markContentsInstalled: doNotMarkClean.			^packageModel]].	(Installing for: aResult package) started.	workingResult := aResult.	self installShadowObjects: aResult shadowedObjects.	aResult packageDifferences ifNotNil: [:value | packageModel removeDeletedDefinitions: value].	self recompileScannerClassesIn: packageModel.	packageModel recompileOverrideAffectedMethods.	Policies packagePolicy 		forcePackage: packageModel		while: 			[self handleExternalInterfacesWith: aResult.			self recompileNewExternalInterfacesFrom: aResult.			self recompileLocalOverriddenClasses.			packageModel recompileExtensionsForSunshine.			self compileBindingInitializersIn: packageModel.			Kernel.SystemUtils linkSystem.			self initializeDefinitionsForPackage: packageModel].	aResult package postLoad: packageModel.	aResult markContentsInstalled: doNotMarkClean.	packageModel cleanse: false.	(doNotMarkClean or: [aResult methodsMovedFromOriginalBinding notNil and: [aResult methodsMovedFromOriginalBinding notEmpty]]) ifTrue: 		[packageModel reconcileWithDbVersion: aResult component].	(Installing for: aResult package) finished.	Kernel.SourceFileManager default endOfChunk.	^packageModel</body><body package="Atomic Compiling and Loading">installShadowObjects: aCollection	"Ignore unpackaged.	If there is a ClassConstructionError, there is a likelyhood that the problem is a push up of an instance variable.	If so, we check if this package's changes has the target class in it, and if so, then we say resume, 'cause that's the problem	If not, we do a pass, because the problem is other than this.	Note, we make sure when detecting that we only test the behavior objects, others will DNU if we send them to #realFromShadow:"		[[[aCollection do: 		[:each | 		each ifNotNil: [each redirectInstallTo: self]]] 			on: UI.RedefinitionNotification			do: 				[:notification |				| package samePackage |				(package := notification currentPackage) ifNil: [notification resume].				((samePackage := packageModel name = package name) and: [notification override isForClass])					ifTrue: [self collectRedefinedClassInPackage: notification override].				(samePackage or: [package name = Registry nullPackageName]) ifFalse: [self fixAndInstallNotification: notification].				notification resume]]					on: Core.VariableConfirmation					do: [:notification | notification resume: false]]						on: Kernel.ClassConstructionError						do: 						[:exception |						| failedClass |						failedClass := exception originator targetClass.						(aCollection contains: [:each | each isBehavior and: [(self realFromShadow: each) = failedClass]])							ifTrue: [exception resume]							ifFalse: [exception pass]].	overrides do: [:each | each cleanUpAfterLoad].</body></methods><methods><class-id>Store.AtomicLoader</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">commentForClassOrNameSpace: aShadowClassOrNameSpace	"Answer a string or nil"	^workingResult commentForClassOrNameSpace: aShadowClassOrNameSpace</body></methods><methods><class-id>Store.AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading">collectRedefinedClassInPackage: aClassOverride	overriddenClassesInPackage add: aClassOverride</body><body package="Atomic Compiling and Loading">compileBindingInitializersIn: aPackageModel		| initialized |	initialized := (bindingsToInitialize collect: [:each | each environment]) asSet.	initialized := initialized copy reject: [:each | each isNameSpace].	initialized do: [:each | aPackageModel recompileSunshineMethodsFor: each].</body><body package="Atomic Compiling and Loading">externalInterfaceClassesFrom: aResult	| externalInterfaceClasses |	externalInterfaceClasses := aResult shadowedObjects select:		[:each |		each isBehavior and: [each inheritsFrom: External.ExternalInterface]].	externalInterfaceClasses := externalInterfaceClasses collect: [:each | self realFromShadow: each].	^externalInterfaceClasses reject: [:each | each isNil].</body><body package="Atomic Compiling and Loading">externalInterfaceCompiledMethodsFrom: aResult		^aResult shadowedObjects select:		[:each | 		each isExternalMethod].</body><body package="Atomic Compiling and Loading">fixMClass: aMethod to: newClass	"Scans blocks to update references to the new (not in shadow) class."	| originalClass |	originalClass := aMethod mclass.	aMethod mclass: newClass.	aMethod withAllBlockMethodsDo:		[:method |		1 to: method basicSize do:			[:i |			originalClass  == (method basicAt: i) ifTrue:				[method basicAt: i put: newClass]]].	^aMethod</body><body package="Atomic Compiling and Loading">handleExternalInterfacesWith: aResult		| externalInterfaceObjects sortedObjects |	externalInterfaceObjects := Core.Set new.	externalInterfaceObjects addAll:		((self externalInterfaceCompiledMethodsFrom: aResult)			collect: [:each | each mclass]).	externalInterfaceObjects addAll: (self externalInterfaceClassesFrom: aResult).	externalInterfaceObjects isEmpty ifTrue: [^self].	sortedObjects := Kernel.SystemUtils sortForLoading: externalInterfaceObjects.	sortedObjects do:		[:each | 		| failed |		failed := Core.OrderedCollection new.		(Core.Array with: each with: each class) do:			[:eachClass |			eachClass selectors do:				[:eachSelector | 				[eachClass recompile: eachSelector]					on: Core.Error, Core.UserNotification					do:						[:error | 						failed add: eachSelector.						error isResumable							ifTrue: [error resume]							ifFalse: [error return]]].			failed do: [:eachFailed | (eachClass selectors includes: eachFailed) ifFalse: [eachClass recompile: eachFailed]]]]</body><body package="Atomic Compiling and Loading">initializeBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| toBeDone success |	bindingsToInitialize isEmpty ifTrue: [^self].	toBeDone := bindingsToInitialize copy.	[toBeDone notEmpty] whileTrue:		[success := false.		toBeDone copy do:			[:each |			[each recompile.			each initialize.			toBeDone remove: each.			success := true]				on: self messageNotUnderstoodSignal				do: [:exception | exception resume]].		success ifFalse: [^self]]</body><body package="Atomic Compiling and Loading">initializeClassesIn: aPackageModel	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"	| toBeDone success |	classesToInitialize isEmpty ifTrue: [^self].	toBeDone := Kernel.SystemUtils sortForLoading: (classesToInitialize collect: [:each | each key]).	success := true.	[toBeDone notEmpty &amp; success] whileTrue:		[success := false.		toBeDone copy do:			[:each | 			[each postLoad: aPackageModel.			toBeDone remove: each.			success := true]				on: InitializerFailedError				do: [:exception | exception return]]].	toBeDone do: 		[:each |		doNotMarkClean := true.		[each postLoad: aPackageModel]			on: InitializerFailedError			do: [:exception | exception resignalAs: Core.MessageNotUnderstood new]]</body><body package="Atomic Compiling and Loading">initializeDefinitionsForPackage: aPackageModel	"Initialize any datum and classes that require initialization.	The collection of bindings will only contain those that need to be initialized."		self initializeBindings.	classesToInitialize do: [:each | each key postCopyFromShadow: each value].	self initializeClassesIn: aPackageModel.	classesToNotify keysAndValuesDo: [:key :value | key extensionMethodsWereAdded: value].</body><body package="Atomic Compiling and Loading">realFromShadow: aShadowedObject		"Looks up aShadowedObject in the real world and answers it, or nil if it doesn't exist. 		Works for NameSpaces and Classes."	| real obj |	obj := aShadowedObject isBehavior 		ifTrue: [ aShadowedObject instanceBehavior ]		ifFalse: [ aShadowedObject ].	real := obj absoluteName asStrictReference 			ifDefinedDo: [ :value |  value ]			elseDo: [ ^nil ].	^( aShadowedObject isBehavior and: [ aShadowedObject isMeta ] )		ifTrue: [ real class ]		ifFalse: [ real ].</body><body package="Atomic Compiling and Loading">recompileLocalOverriddenClasses	| allClassesWithSubclasses classesToRecompile |	allClassesWithSubclasses := Core.Set new.	overriddenClassesInPackage isEmpty ifTrue: [^self].	classesToRecompile := overriddenClassesInPackage collect: [:each | each actual].	classesToRecompile do: [:each | allClassesWithSubclasses addAll: each withAllSubclasses].	(Kernel.SystemUtils sortForAtomicLoading: allClassesWithSubclasses)		do: [:each | packageModel recompileMethodsFor: each].</body></methods><methods><class-id>Store.AtomicLoader</class-id> <category>private-installation</category><body package="Atomic Compiling and Loading">fixAndInstallClassNotification: aRedefinitionNotification		| overridden |	overridden := workingResult overrides 		detect: [:each | each isForClass and: [each fullName = aRedefinitionNotification override absoluteName]]		ifNone: [nil].	overridden isNil		ifTrue: [aRedefinitionNotification override install]		ifFalse: [self fixAndInstallNotification: aRedefinitionNotification using: overridden].	overrides add: aRedefinitionNotification override</body><body package="Atomic Compiling and Loading">fixAndInstallNameSpaceNotification: aRedefinitionNotification		| overridden |	overridden := workingResult overrides 		detect: [:each | each isForNameSpace and:[each fullName = aRedefinitionNotification override absoluteName]]		ifNone: [nil].	overridden isNil		ifTrue: [aRedefinitionNotification override install]		ifFalse: [self fixAndInstallNotification: aRedefinitionNotification using: overridden].	overrides add: aRedefinitionNotification override</body><body package="Atomic Compiling and Loading">fixAndInstallNotification: aRedefinitionNotification		aRedefinitionNotification override isForClass ifTrue: [^self fixAndInstallClassNotification: aRedefinitionNotification].	aRedefinitionNotification override isForNameSpace ifTrue: [^self fixAndInstallNameSpaceNotification: aRedefinitionNotification].	aRedefinitionNotification override install.	overrides add: aRedefinitionNotification override</body><body package="Atomic Compiling and Loading">fixAndInstallNotification: aRedefinitionNotification using: aClassOrNameSpaceOverride		aClassOrNameSpaceOverride definitionMessage receiver: aRedefinitionNotification override definitionMessage receiver.	aRedefinitionNotification override install.</body><body package="Atomic Compiling and Loading">installClass: aShadowedClass	"The KISS approach: 		execute the new class definition to install or replace the existing one."		| realEnvironment realClass messageSend classComment |	realEnvironment := self realFromShadow: aShadowedClass environment.	(messageSend := aShadowedClass definitionMessage) receiver: realEnvironment.	aShadowedClass strictReference ifDefinedDo:		[:value |		(Kernel.Override overridesForClassOrNameSpace: value) ifNotNil:			[:knownOverrides | | target |			target := knownOverrides detect: [:over | over sources includes: packageModel] ifNone: [nil].			target ifNotNil: [^target setOverriddenDefinition: messageSend]]].	Policies packagePolicy		forcePackage: packageModel		while:			[realClass := self invokeClassCreationMessage: messageSend.			(classComment := self commentForClassOrNameSpace: aShadowedClass) notNil				ifTrue: [realClass comment: classComment]				ifFalse: [realClass comment: nil].			realClass addToSuper].	classesToInitialize add: realClass -&gt; aShadowedClass</body><body package="Atomic Compiling and Loading">installMethod: aCompiledMethod	"If the new method is already in the REAL class, then throw a RedefinitionNotification	If this is a new method, just move it directly to the package we want. 	The system will think it's in the package of the class definition, since no other packages have information about it yet.	If the method is NOT new, then this is an override. We need to move it to the package we want in a way that modifies other change sets."	| shadowClass realClass category selector existingMethod knownOverride |	shadowClass := aCompiledMethod mclass.	realClass := self realFromShadow: shadowClass.	selector := aCompiledMethod selector.	category := shadowClass whichCategoryIncludesSelector: selector.	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: 		[ | override methodNodeHolder |		methodNodeHolder := Kernel.Compiler new 			parse: aCompiledMethod getSource			in: realClass			notifying: nil.		methodNodeHolder notNil ifTrue:			[override := workingResult overridden 				detect: [:each | each isForMethod and: [each selector = methodNodeHolder selector and: [each absoluteClassName = realClass absoluteName]]] 				ifNone: [nil].			override ifNotNil: 				[selector := override selector.				category := override protocol]]].	(existingMethod := realClass compiledMethodAt: selector ifAbsent: nil) ifNotNil:		[knownOverride := Kernel.Override 			overrideForSelector: selector 			class: realClass 			in: packageModel.		knownOverride ifNotNil: 			[knownOverride setOverriddenDefinition: (self fixMClass: aCompiledMethod to: realClass).			^knownOverride setOverriddenProtocol: category].		UI.RedefinitionNotification			redefinedSelector: selector			class: realClass			attributes: existingMethod attributes].	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: [^self].	self fixMClass: aCompiledMethod to: realClass.	realClass needsSafeRebinding ifTrue:		[aCompiledMethod literalsDo: [:each | (each isVariableBinding and: [each isDeferred]) ifTrue: [each resolveBinding]]]. 	(realClass		justAddSelectorUnsafe: selector		withMethod: aCompiledMethod		category: category) ifTrue: 			[(classesToNotify at: realClass ifAbsentPut: [OrderedCollection new]) add: selector].	existingMethod ifNotNil:		[self updateSourcePackageFor: aCompiledMethod in: realClass].	packageModel doSubdefChange:		((Change new add)			selector: aCompiledMethod selector;			class: realClass).	(realClass isMeta and: [selector = #initialize and: [(classesToInitialize anySatisfy: [:each | each key = realClass instanceBehavior]) not]])		ifTrue: [classesToInitialize add: realClass instanceBehavior -&gt; shadowClass instanceBehavior].	aCompiledMethod sourcePointer:		(Kernel.SourceFileManager default			storeMethodSource: aCompiledMethod getSource			class: realClass			selector: selector			category: category			safely: false)</body><body package="Atomic Compiling and Loading">installNameSpace: aNameSpace	"The KISS approach: 		execute the new namespace definition to install or replace the existing one."		| realEnvironment messageSend |	realEnvironment := self realFromShadow: aNameSpace environment.	(messageSend := aNameSpace definitionMessage) receiver: realEnvironment.	aNameSpace strictReference ifDefinedDo:		[:value |		(Kernel.Override overridesForClassOrNameSpace: value) ifNotNil:			[:knownOverrides | | target |			target := knownOverrides detect: [:eachOverride | eachOverride sources includes: packageModel] ifNone: [nil].			target ifNotNil: [^target setOverriddenDefinition: messageSend]]].	Policies packagePolicy		forcePackage: packageModel		while:			[| namespace cmt |			namespace := self invokeCreationMessage: messageSend.			(cmt := self commentForClassOrNameSpace: aNameSpace) notNil 				ifTrue: [namespace comment: cmt]				ifFalse: [namespace comment: nil]]</body><body package="Atomic Compiling and Loading">installSharedBinding: aBindingReference	"Install the shared var in its namespace (class pool). If it has an initializer, queue it up for later initialization."		| env owningClassOrNamespace binding messageSend |	env := aBindingReference environment.	owningClassOrNamespace := self realFromShadow: env.	messageSend := env asNameSpace definitionMessageOfStatic: aBindingReference binding.	messageSend receiver: owningClassOrNamespace.	env strictReference ifDefinedDo:		[:value |		(Kernel.Override overridesForStatic: aBindingReference binding in: value) 			ifNotNil: [:knownOverrides| | target | 				target := knownOverrides detect: [:eachOverride | eachOverride sources includes: packageModel] ifNone: [nil].				target ifNotNil: [^target setOverriddenDefinition: messageSend ]]].	binding := Policies packagePolicy		forcePackage: packageModel		while: [self invokeCreationMessage: messageSend].	binding needsInitialization ifTrue: [bindingsToInitialize add: binding]</body><body package="Atomic Compiling and Loading">recompileNewExternalInterfacesFrom: aResult	| classes externalClasses orderedClasses recompileClasses |	classes := aResult shadowedObjects select: [:each | each isBehavior].	classes := classes collect: [:each | self realFromShadow: each].	externalClasses := classes select: [:each | each isMeta not and: [each includesBehavior: External.ExternalInterface]].	orderedClasses := Kernel.SystemUtils sortForLoading: externalClasses.	orderedClasses do:		[:each |		each recompileMethods].	(recompileClasses := aResult externalClassesNeedingRecompile) ifNil: [^self].	recompileClasses := (recompileClasses select: [:each | each notNil]) collect: [:each | self realFromShadow: each].	(recompileClasses reject: [:each | (orderedClasses includes: each) or: [each isMeta]]) do:		[:each | each recompileMethods]</body><body package="Atomic Compiling and Loading">recompileScannerClassesIn: aPackageModel		| allClasses scannerClasses sortedClasses |	allClasses := aPackageModel allDefinedClasses.	scannerClasses := allClasses select: [:each | each includesBehavior: Kernel.Scanner].	sortedClasses := Kernel.SystemUtils sortForLoading: scannerClasses.	sortedClasses do:		[:each | 		aPackageModel recompileMethodsFor: each class.		aPackageModel recompileMethodsFor: each]</body><body package="Atomic Compiling and Loading">updateSourcePackageFor: aCompiledMethod in: aClass	| sourcePackage |	sourcePackage := Registry		containingPackageForSelector: aCompiledMethod selector		class: aClass.	sourcePackage 		removeChangeTypes: #(#remove #override) 		forClass: aClass 		selector: aCompiledMethod selector</body></methods><methods><class-id>Store.AtomicLoader</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">resetInitializerCollections	classesToInitialize := OrderedCollection new.	bindingsToInitialize := OrderedCollection new.	classesToNotify := IdentityDictionary new.	overrides := OrderedCollection new.	doNotMarkClean := false.	overriddenClassesInPackage := OrderedCollection new.</body></methods><methods><class-id>Store.GraphTool</class-id> <category>graph actions</category><body package="Store-UI-Graphs">beGraph	| focus |	self graphView bm visualBuilderClass: Lens.LDMGraphBuilder.	focus := self graphView focus value.	self graphView onPerspective: self perspective.	self graphView focus: focus.</body><body package="Store-UI-Graphs">beIndentedList	self graphView bm visualBuilderClass: IndentedListBuilder</body><body package="Store-UI-Graphs">closeAllIn	graphView selectionDo: [:e | graphView browserModel body closeAllFrom: e side: 2]</body><body package="Store-UI-Graphs">closeAllOut	graphView selectionDo: [:e | graphView browserModel body closeAllFrom: e side: 1]</body></methods><methods><class-id>Store.GraphTool</class-id> <category>menu enabling</category><body package="Store-UI-Graphs">makePundleMenuDynamic: menu  	super makePundleMenuDynamic: menu.	self makeDynamicItem: #openOneOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openOneIn selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #closeOneOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #closeOneIn selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #open4Out selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #open4In selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openAllOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openAllIn selectionBlock: [self nonEmptySelection] inMenu: menu.	^menu</body></methods><methods><class-id>Store.GraphTool</class-id> <category>accessing</category><body package="Store-UI-Graphs">focus: aFocus	self graphView focus: aFocus</body><body package="Store-UI-Graphs">graphView	""	^graphView isNil		ifTrue:			[graphView := LensGraphView onPerspective: self perspective]		ifFalse:			[graphView]</body></methods><methods><class-id>Store.GraphTool</class-id> <category>selection</category><body package="Store-UI-Graphs">nonEmptySelection	self graphView selectionDo: [:sel | ^true].	^false</body><body package="Store-UI-Graphs">pundles	| sels |	sels := List new.	self graphView selectionDo: [:each | sels add: each element].	^sels</body><body package="Store-UI-Graphs">pundleVersions	| sels |	sels := List new.	self graphView selectionDo: [:each | sels add: each element].	^sels</body><body package="Store-UI-Graphs">selectPundle: aPundle	self needsMoreWork. "due to element proxy"	self graphView select: aPundle</body></methods><methods><class-id>Store.GraphTool</class-id> <category>actions</category><body package="Store-UI-Graphs">closeIn	self graphView closeIn</body><body package="Store-UI-Graphs">closeOut	self graphView closeIn</body><body package="Store-UI-Graphs">open4In	self graphView open4In</body><body package="Store-UI-Graphs">open4Out	self graphView open4Out</body><body package="Store-UI-Graphs">openAllIn	self graphView openInLevels: 0</body><body package="Store-UI-Graphs">openAllOut	self graphView openOutLevels: 0</body><body package="Store-UI-Graphs">openOneIn	self graphView   openInLevels: 1</body><body package="Store-UI-Graphs">openOneOut	self graphView  openOutLevels: 1</body><body package="Store-UI-Graphs">updatePundleContents	"Reconstructs the entire graph"	self graphView focus: self graphView focus value</body><body package="Store-UI-Graphs">updatePundleVersion	"Updates the visual representation of each graph element, but no 	elements are added to or removed from the graph."	(self graphView bm body) releaseVisuals; rebuild</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>actions</category><body package="Store-UI">accept	"set new blessings and comments...."	self newGlobalState.	Announcements announce: (StorePrePublish for: self specifications: self specList).	self specList publishBlessing.	Announcements announce: (StorePostPublish for: self specifications: self specList).	self specList do:		[:each | each dbPundle blessingLevel: each blessing printString].	self setDetailState.	dialog accept; closeRequest</body><body package="Store-UI">cancel	dialog doCancel</body><body package="Store-UI">publishAllYes	self forAllItemsDo: 		[ :ar | ar publish: true ].	labelDict := nil.	self newSelection</body><body package="Store-UI">resetBundleOnly	self forAllItemsDo: 		[ :ar | ar publish: false ].	items list first publish: true.		labelDict := nil.	self newSelection</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>interface opening</category><body package="Store-UI">localPostOpenWith: aBuilder	self items selectionIndexHolder onChangeSend: #newSelection to: self.	Announcements announce: (StorePublishDialogOpening for: self).	self setVisualBlocks.	self items selectionIndex: 1.</body><body package="Store-UI">localRebuild		self setVisualBlocks.</body><body package="Store-UI">userData: userData	self items list: userData.	labelDict := nil.</body><body package="Store-UI">windowLabel	^(#ResettingBlessingLevelsAndComments &lt;&lt; #store &gt;&gt; 'Resetting Blessing Levels and Comments on: &lt;1s&gt; for: &lt;2s&gt;')		expandMacrosWith: self connectionLabel		with: self userNameLabel</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>help</category><body package="Store-UI">mainHelp	^(#TheBlessingLevelAnAllPublishedItems &lt;&lt; #store &gt;&gt; 'The Blessing Level and Blessing Comment can be set individually for each component. It will apply to the selected item. Set Current Blessing Level and Comment for All, sets the same level and comment for all published items.') asString</body><body package="Store-UI">publishHelp	^(#TheDefaultIsToResSelectedComponent &lt;&lt; #store &gt;&gt; 'The default is to reset the blessing level/comment for all modified subcomponents.Select Reset All to publish all components.Select Reset Only Modified to reset the default, which does not reset any unmodified components.Select Reset Bundle Only to reset only the topmost bundle.Reset and Do not Reset allow you to change the setting of the currently selected component.') asString</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>private</category><body package="Store-UI">enableDetails	"The opposite of the publish dialog -- only modified guys can be changed."	self enablePublishBox.	self items selection notNil		ifTrue: 			[ self publish value				ifTrue: 					[ self details do: 						[:sym | self enableComponentAt: sym enable: true ] 					]			]</body><body package="Store-UI">open	self openDialogInterface: #windowSpec</body><body package="Store-UI">openDialogInterface: aSymbol 		dialog := SimpleDialog new.	builder := dialog builder.	dialog postOpenBlock: [:dlg :bld |		self postOpenWith: bld].	dialog openFor: self interface: aSymbol</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>accessing</category><body package="Store-UI">dialog	^dialog</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>interface opening</category><body package="Store-UI">setBlessingFor: aPundle	aPundle isBundle 			ifTrue: [ self setBlessingForBundle: aPundle ]		ifFalse: [ self setBlessingForPackage: aPundle ].</body><body package="Store-UI">setBlessingForBundle: aBundle	"self setBlessingForBundle: ( Registry packageNamed: 'Store-Base' ) parentRecord."		| specificationList files instance |	(self validateForPublishing:		((aBundle containedItems)			addFirst: aBundle;			yourself)) ifFalse: [^self].	specificationList := self publishSpecsFrom: aBundle.		files := self publishFileSpecsFrom: aBundle.	instance := self new.	instance items list: specificationList.	instance blessingLevel value: aBundle blessingLevelNumber.	instance openWith: specificationList with: files.	instance dialog accept value ifTrue:		[instance accept.		aBundle blessingLevel: instance blessingLevel value]</body><body package="Store-UI">setBlessingForPackage: aStorePackage	"Redirect to existing dialog for a single package."		"self setBlessingForBundle: ( Registry packageNamed: 'Store-Base' ) parentRecord."	| dialog publishSpecification |	dialog := CommentPrompt forPundle: aStorePackage.	dialog blessingLevel value: aStorePackage blessingLevelNumber.	dialog open.	dialog accept value ifTrue: 		[publishSpecification := self publishSpecFrom: aStorePackage.		publishSpecification publish: true.		publishSpecification blessing: dialog blessingLevel value.		publishSpecification comment: dialog text value asString.		publishSpecification publishBlessing.		aStorePackage blessingLevel: dialog blessingLevel value]</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>class initialization</category><body package="Store-UI">initialize	"self initialize "	| complexList |	complexList := 		OrderedCollection new			add: 'Blessing' -&gt; #(#mainSpec #mainHelp);			add: 'Reset Options' -&gt; #(#publishSpec #publishHelp);			asArray.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new: 1.</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>private</category><body package="Store-UI">publishSpecFrom: aPackage	 ^PublishSpecification dbPundle: aPackage</body><body package="Store-UI">publishSpecsFrom: aBundle  	 ^PublishSpecificationList fromDbBundle: aBundle</body><body package="Store-UI">userData: anUserData forPundle: aPundle 	"Set the common items in the user data."	anUserData 		at: #publish put: true;		at: #pundle put: aPundle;		at: #comment put: '';		at: #level put: 0;		at: #modified put: true;		at: #version put: aPundle version;		at: #parentVersion put: aPundle version;		at: #description put: nil;		at: #blessing put: aPundle blessingLevelNumber;		yourself.</body><body package="Store-UI">userData: anUserData forPundle: aPundle traceItems: traceItems	"Set the common items in the user data."	| mod |	 mod := traceItems contains: [ :p | p primaryKey = aPundle primaryKey ].	anUserData 		at: #publish put: mod not;		at: #pundle put: aPundle;		at: #comment put: '';		at: #level put: 0;		at: #modified put: mod not;		at: #description put: nil;		at: #version put: aPundle version;		at: #parentVersion put: aPundle version;		at: #blessing put: aPundle blessingLevelNumber;		yourself.</body><body package="Store-UI">userDataFrom: aBundle  	| dict coll items traceItems trace |	dict := Dictionary new.	items := aBundle uniqueItemsAndLevels.	( trace := aBundle parentRecord ) == nil		ifTrue: [ traceItems := Set new ]		ifFalse: [ traceItems := trace allItems ].	self userData: dict forPundle: aBundle traceItems: traceItems.	dict 		at: #publish put: true;		at: #modified put: true.	coll := List with: dict.	items do: 		[ :pair | 	| pndl comp |		comp := pair at: 1.		pndl := comp.		dict := Dictionary new.		self userData: dict forPundle: pndl traceItems: traceItems.		dict at: #description put: comp.		dict at: #level put: ( pair at: 2 ).		coll add: dict		].	^coll</body></methods><methods><class-id>Store.Glorp.StoreLogin</class-id> <category>accessing</category><body package="Store-Database Model">connectionIdentifierString	^self connectString , '~' , self schema</body><body package="Store-Database Model">driverClassName		^driverClassName</body><body package="Store-Database Model">driverClassName: aString	"Set the database platform from the driver class."	driverClassName := aString.	self database: self glorpPlatformFromDriverClassName new.</body><body package="Store-Database Model">schema: aString	"If my database supports table owners, i.e. expects Store table names of the form Bern.TW_* rather than just TW_* in its SQL, then we must set the schema to achieve this.  Otherwise, the schema should be the empty string."	self database supportsTableOwners ifTrue: [schema := aString]</body></methods><methods><class-id>Store.Glorp.StoreLogin</class-id> <category>printing</category><body package="Store-Database Model">printOn: aStream	aStream nextPutAll: 'a StoreLogin('.	database printOn: aStream.	aStream nextPutAll: ', '.	driverClassName printOn: aStream.	aStream nextPutAll: ', '.	username printOn: aStream.	aStream nextPutAll: ', '.	connectString printOn: aStream.	aStream nextPutAll: ', '.	schema printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Store.Glorp.StoreLogin</class-id> <category>mapping</category><body package="Store-Database Model">glorpPlatformFromDriverClassName	"It seems to be the case that this method will never be called unless #isConnectable is true for the profile from which this login was created.  However we code the appropriate error in case it was not."	^(ConnectionProfile concreteDatabaseDriverClasses		detect: [:ea | ea name = self driverClassName]		ifNone: [Store.StoreWarning raiseSignal:				(#UnableToConnectToPresentInTheImage &lt;&lt; #store &gt;&gt; 'Unable to connect to "&lt;1s&gt;" because the database driver class&lt;n&gt;"&lt;2s&gt;" is not present in the image.'					expandMacrosWith: self name					with: self driverClassName asString)])			glorpStoreDatabasePlatformClass</body></methods><methods><class-id>Store.Glorp.StoreLogin</class-id> <category>session creation</category><body package="Store-Database Model">vwConnectionClass	^self driverClassName asQualifiedReference value</body></methods><methods><class-id>Store.Glorp.StoreLogin</class-id> <category>login</category><body package="Store-Database Model">postLoginInitializeFromAccessor: aDatabaseAccessor	super postLoginInitializeFromAccessor: aDatabaseAccessor.	self database postLoginInitializeStoreFromAccessor: aDatabaseAccessor.</body><body package="Store-Database Model">preLoginInitializeFromAccessor: anAccessor	"The acccessor's connection object exists, but is not connected, when this is called."	super preLoginInitializeFromAccessor: anAccessor.	self database preLoginInitializeStoreFromAccessor: anAccessor.</body></methods><methods><class-id>Store.Glorp.StoreLogin class</class-id> <category>instance creation</category><body package="Store-Database Model">newFromConnectionProfile: aStoreConnectionProfile	^self new		secure: false;		username: aStoreConnectionProfile userName;		password: aStoreConnectionProfile password;		name: aStoreConnectionProfile name;		connectString: aStoreConnectionProfile environment;		driverClassName: aStoreConnectionProfile driverClassName;		schema: aStoreConnectionProfile tableOwner;		yourself</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>accessing</category><body package="Store-Publishing Support">blessing	^blessing</body><body package="Store-Publishing Support">blessing: anInteger	blessing := anInteger</body><body package="Store-Publishing Support">comment	^comment</body><body package="Store-Publishing Support">comment: aString	comment := aString</body><body package="Store-Publishing Support">description	^description</body><body package="Store-Publishing Support">description: aString	description := aString</body><body package="Store-Publishing Support">level	^level</body><body package="Store-Publishing Support">level: anInteger	level := anInteger</body><body package="Store-Publishing Support">modified	^modified</body><body package="Store-Publishing Support">modified: aBoolean	modified := aBoolean</body><body package="Store-Publishing Support">parentVersion	^parentVersion</body><body package="Store-Publishing Support">parentVersion: aString	parentVersion := aString</body><body package="Store-Publishing Support">publish	^publish</body><body package="Store-Publishing Support">publish: aBoolean	publish := aBoolean</body><body package="Store-Publishing Support">pundle	^object</body><body package="Store-Publishing Support">pundle: aPundleModel	self privateSetObject: aPundleModel.		pundleModel := object.	modified := object hasBeenModified or: [object hasTrace not].	publish := modified.	parentVersion := aPundleModel extractVersionFromVersionDisplayString.	version := parentVersion isEmpty		ifTrue: [Policies versionPolicy initialVersionForPundle: aPundleModel]		ifFalse: [Policies versionPolicy nextVersion: parentVersion forPundle: aPundleModel]</body><body package="Store-Publishing Support">pundle: aPundleModel in: aSession	self privateSetObject: aPundleModel.		pundleModel := object.		modified := object hasBeenModified or: [object hasTrace not].	publish := modified.	parentVersion := aPundleModel extractVersionFromVersionDisplayString.	version := parentVersion isEmpty		ifTrue: [Policies versionPolicy initialVersionForPundle: aPundleModel]		ifFalse: [Policies versionPolicy nextVersion: parentVersion forPundle: aPundleModel in: aSession]</body><body package="Store-Publishing Support">pundleModel	^pundleModel</body><body package="Store-Publishing Support">version	^version</body><body package="Store-Publishing Support">version: aString	version := aString</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>initialize-release</category><body package="Store-Publishing Support">initialize	comment := ''.	version := ''.	description := nil.	level := 0.	publish := false.	modified := false.	blessing := Policies blessingPolicy defaultBlessing.</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>private - accessing</category><body package="Store-Publishing Support">privateSetObject: aPundleOrPundleModel	object := aPundleOrPundleModel</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>accessing-calculated</category><body package="Store-Publishing Support">at: aKey	"backward compatibility for when dictionary expected."	^self perform: aKey</body><body package="Store-Publishing Support">at: aKey ifAbsent: aBlock	"backward compatibility for when dictionary expected. If absent (shouldn't be, but can), answer the value of the block"	(self respondsTo: aKey) ifFalse: [^aBlock value].	^self perform: aKey</body><body package="Store-Publishing Support">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: self parcelDirectory ) asString</body><body package="Store-Publishing Support">padded	"compatibilty"	^self parcelPadded</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>accessing</category><body package="Store-Publishing Support">binarySave	^binarySave</body><body package="Store-Publishing Support">binarySave: aBoolean	binarySave := aBoolean</body><body package="Store-Publishing Support">bundleStructure	^bundleStructure</body><body package="Store-Publishing Support">bundleStructure: aBoolean	bundleStructure := aBoolean</body><body package="Store-Publishing Support">databaseLinks	^databaseLinks</body><body package="Store-Publishing Support">databaseLinks: aBoolean	databaseLinks := aBoolean</body><body package="Store-Publishing Support">dbPundle	^object.</body><body package="Store-Publishing Support">dbPundle: aStorePundle	self privateSetDbPundle: aStorePundle.	pundleModel := aStorePundle storeModel.	modified := publish := false.	parentVersion := object version.	version := object version.</body><body package="Store-Publishing Support">mergeData	^mergeData</body><body package="Store-Publishing Support">mergeData: aMergeData	mergeData := aMergeData</body><body package="Store-Publishing Support">parcelBackup	^parcelBackup</body><body package="Store-Publishing Support">parcelBackup: aBoolean	parcelBackup := aBoolean</body><body package="Store-Publishing Support">parcelDirectory	^parcelDirectory</body><body package="Store-Publishing Support">parcelDirectory: aFilename	parcelDirectory := aFilename</body><body package="Store-Publishing Support">parcelHideSource	^parcelHideSource</body><body package="Store-Publishing Support">parcelHideSource: aBoolean	parcelHideSource := aBoolean</body><body package="Store-Publishing Support">parcelOverwrite	^parcelOverwrite</body><body package="Store-Publishing Support">parcelOverwrite: aBoolean	parcelOverwrite := aBoolean</body><body package="Store-Publishing Support">parcelPadded	^parcelPadded</body><body package="Store-Publishing Support">parcelPadded: aBoolean	parcelPadded := aBoolean</body><body package="Store-Publishing Support">parcelRepublish	^parcelRepublish</body><body package="Store-Publishing Support">parcelRepublish: aBoolean	parcelRepublish := aBoolean</body><body package="Store-Publishing Support">parcelSave	^parcelSave</body><body package="Store-Publishing Support">parcelSave: aBoolean	parcelSave := aBoolean</body><body package="Store-Publishing Support">parcelSaveSource	^parcelSaveSource</body><body package="Store-Publishing Support">parcelSaveSource: aBoolean	parcelSaveSource := aBoolean</body><body package="Store-Publishing Support">parcelVersionString	^parcelVersionString</body><body package="Store-Publishing Support">parcelVersionString: aString	parcelVersionString := aString</body><body package="Store-Publishing Support">privateSetDbPundle: aStorePundle		self privateSetObject: aStorePundle.</body><body package="Store-Publishing Support">publisher	^publisher</body><body package="Store-Publishing Support">pundle: aPundle	super pundle: aPundle.	aPundle isPackage ifTrue: [binarySave := aPundle hasRelatedParcel].</body><body package="Store-Publishing Support">pundle: aPundle in: aSession	super pundle: aPundle in: aSession.	aPundle isPackage ifTrue: [binarySave := aPundle hasRelatedParcelIn: aSession].</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>initialize-release</category><body package="Store-Publishing Support">initialize	super initialize.	binarySave := false.	parcelSave := false.	bundleStructure := false.	databaseLinks := false.	parcelDirectory := ''.	parcelRepublish := false. 	parcelBackup := false. 	parcelOverwrite := false. 	parcelSaveSource := true. 	parcelHideSource := false. 	parcelPadded := false.</body><body package="Store-Publishing Support">pundle: aStorePundleModel binary: aBoolean 	super pundle: aStorePundleModel.	aStorePundleModel isPackage ifTrue: [binarySave := aBoolean].</body><body package="Store-Publishing Support">pundle: aStorePundleModel binary: aBoolean in: aSession	super pundle: aStorePundleModel in: aSession.	aStorePundleModel isPackage ifTrue: [binarySave := aBoolean].</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>publishing</category><body package="Store-Publishing Support">prepareBinary		| packageModel |	self pundle isBundle ifTrue: [^self].	packageModel := self pundle storeModel.	packageModel propertyAt: #packageName put: packageModel name.	self pundle propertyAt: #packageName put: packageModel name.	self pundle binFile: ''</body><body package="Store-Publishing Support">publishBlessing	"Create new blessing/comment records for the pundle."		| newBlessing previous session |	self publish ifFalse: [^true].	DbRegistry clearPundleCaches.	session := self pundle isGlorpObject		ifTrue: [self pundle session]		ifFalse: [StoreLoginFactory currentStoreSession].	publisher ifNil: 		[publisher := StorePundleWriter newForSession: session].	^[publisher pundle: (self pundle asStorePundleIn: publisher targetSession).	newBlessing := StoreBlessing 				newForBlessingLevel: self blessing value 				comment: self comment asString.	previous := publisher pundle previous.	publisher pundle previous: previous.	publisher addBlessing: newBlessing.	true] value.		"on: Error 		do: [:exception | exception return: false]"</body><body package="Store-Publishing Support">publishInformativeBlessing: aBoolean	"Create new blessing/comment records for the pundle."		| newBlessing previous session |	self publish ifFalse: [^true].	DbRegistry clearPundleCaches.	session := self pundle isGlorpObject		ifTrue: [self pundle session]		ifFalse: [StoreLoginFactory currentStoreSession].	publisher ifNil: 		[publisher := StorePundleWriter newForSession: session].	^[publisher pundle: (self pundle asStorePundleIn: publisher targetSession).	newBlessing := StoreBlessing 				newForBlessingLevel: self blessing value 				comment: self comment asString.	previous := publisher pundle previous.	publisher pundle previous: previous.	aBoolean		ifTrue: [publisher addBlessingOnly: newBlessing]		ifFalse: [publisher addBlessing: newBlessing].	true] value.		"on: Error 		do: [:exception | exception return: false]"</body><body package="Store-Publishing Support">publishParcel		self pundle storeModel saveAsParcelFromSpecs: self</body><body package="Store-Publishing Support">publishPundle	"Publish. Answer false if aborted."	| pundle |	(Publishing for: self) started.	pundle := self publishSilently.	self updateRelatedIntegratedVersions.		(Publishing for: self) finished.	^pundle</body><body package="Store-Publishing Support">publishSilently	"	***This is decompiled code.*** 	No source was available"	self publish ifTrue: [^self publishSilentlyUsingSession: StoreLoginFactory currentStoreSession informativeBlessing: false].	^nil</body><body package="Store-Publishing Support">publishSilentlyUsingSession: aSession	"Publish. Answer false if aborted."		| newPundle currentPundleModel targetPundles |	self publish ifFalse: [^nil].	DbRegistry clearPundleCaches.	publisher ifNil:		[publisher := StorePundleWriter newForSession: aSession].	self binarySave ifFalse:		[currentPundleModel := self pundleModel.		currentPundleModel runPreSave.		currentPundleModel isBundle ifFalse:			[currentPundleModel allDefinedClasses do: [:eachClass | eachClass preSave: currentPundleModel]]].	^[targetPundles := self updateStorePundleItems.	newPundle := [publisher writePundle: self pundle withChangesBasedOn: self pundle storeModel using: targetPundles]		on: GlorpDatabaseWriteError		do: 			[:exception |			StorePublishingError raiseErrorString: exception messageText.			exception return: nil].	newPundle ifNil: [^nil].	newPundle applyPundleVersionsToTheImage: false.	self parcelSave ifTrue: [self publishParcel].	newPundle ifNotNil:		[newPundle storeModel markNotModified].	newPundle] value</body><body package="Store-Publishing Support">publishSilentlyUsingSession: aSession informativeBlessing: aBoolean	"Publish. Answer false if aborted."	| newPundle currentPundleModel targetPundles |	self publish ifFalse: [^nil].	DbRegistry clearPundleCaches.	publisher		ifNil: [publisher := StorePundleWriter newForSession: aSession].	self binarySave		ifFalse: 			[currentPundleModel := self pundleModel.			currentPundleModel runPreSave.			currentPundleModel isBundle				ifFalse: 					[currentPundleModel allDefinedClasses						do: [:eachClass | eachClass preSave: currentPundleModel]]].	^[targetPundles := self updateStorePundleItemsForInformativeBlessings: aBoolean.	newPundle := 			[publisher				writePundle: self pundle				withChangesBasedOn: self pundle storeModel				using: targetPundles]					on: GlorpDatabaseWriteError					do: 						[:exception |						StorePublishingError raiseErrorString: exception messageText.						exception return: nil].	newPundle ifNil: [^nil].	newPundle applyPundleVersionsToTheImage: false.	self parcelSave ifTrue: [self publishParcel].	newPundle ifNotNil: [newPundle storeModel dbTrace: newPundle primaryKey; markNotModified].	self privateSetDbPundle: newPundle minimizeFootprintInImage.	newPundle]			value</body><body package="Store-Publishing Support">updateRelatedIntegratedVersions	"This must be called AFTER the related publish is complete, never before"	| integrations |	self pundleModel mergeInformation ifNil: [^self].	Policies integratedBlessingChangePolicy = #change		ifTrue: [			integrations := self pundleModel mergeInformation integratedVersions.			(Publishing for: self dbPundle) started.			integrations do: 				[:each |				| targetVersion newLevel |				targetVersion := self dbPundle storeForGlorpPundleClass pundleWithName: self dbPundle name version: each.				targetVersion ifNotNil: 					[targetVersion						addBlessingLevel: (newLevel := Policies mergePolicy integratedBlessingLevelForPackage: targetVersion)							andComment: (#IntegratedIntoVersion1s &lt;&lt; #store &gt;&gt; 'Integrated into version &lt;1s&gt;.' expandMacrosWith: version)							informativeBlessing: (self useInformativeBlessingOn: targetVersion forLevel: newLevel)]].			(Publishing for: self dbPundle) finished].	self pundleModel mergeInformation: nil.</body><body package="Store-Publishing Support">updateStorePundleItems		| pundle storeBlessing newPundle |	newPundle := self pundle storeModel asNewStorePundleIn: publisher targetSession.	self privateSetDbPundle: newPundle.	self binarySave 		ifTrue: [self prepareBinary]		ifFalse: [self pundle isPackage ifTrue: [self pundle binFile: nil]].	self publish ifFalse: [^self].	pundle := self pundle.	pundle version: self version.	storeBlessing := StoreBlessing				newForBlessingLevel: self blessing value				comment: self comment asString.	pundle bless: storeBlessing.	^Array with: pundle</body><body package="Store-Publishing Support">updateStorePundleItemsForInformativeBlessings: aBoolean		| pundle storeBlessing newPundle |	newPundle := self pundle storeModel asNewStorePundleIn: publisher targetSession.	self privateSetDbPundle: newPundle.	self binarySave 		ifTrue: [self prepareBinary]		ifFalse: [self pundle isPackage ifTrue: [self pundle binFile: nil]].	self publish ifFalse: [^self].	pundle := self pundle.	pundle version: self version.	storeBlessing := StoreBlessing				newForBlessingLevel: self blessing value				comment: self comment asString.	aBoolean 		ifTrue: [pundle addBlessingOnly: storeBlessing]		ifFalse: [pundle bless: storeBlessing].	^Array with: pundle</body><body package="Store-Publishing Support">useInformativeBlessingOn: targetVersion forLevel: newLevel	^MergeTool downgradeBlessingOnMerge not and: 		[MergeTool informativeBlessingsOnly or: 		[((targetVersion currentBlessingLevel ifNil: [100]) &lt; newLevel) not]]</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>private</category><body package="Store-Publishing Support">setPublisher: aStorePundleWriter	publisher := aStorePundleWriter</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>testing</category><body package="Store-Publishing Support">isConsistentForPublishing	"If it has been modified and marked for publishing we say Ok, you pass	If it has NOT been modified no matter if it is marked for publishing or not, we say OK, you pass.	Otherwise, fail"	^self pundleModel isNil or:		[(self pundleModel hasBeenModified and: [self publish]) or:		[self pundleModel hasBeenModified not]]</body></methods><methods><class-id>Store.PublishSpecification class</class-id> <category>instance creation</category><body package="Store-Publishing Support">dbPundle: aPundle	^self new dbPundle: aPundle</body><body package="Store-Publishing Support">new	^self basicNew initialize.</body><body package="Store-Publishing Support">pundle: aPundle	^(aPundle isLoaded and: [aPundle isImageObject])		ifTrue: [self new pundle: aPundle]		ifFalse: [self dbPundle: aPundle]</body><body package="Store-Publishing Support">pundle: aPundle binary: aBoolean	^(aPundle isLoaded and: [aPundle isImageObject])		ifTrue: [self new pundle: aPundle binary: aBoolean]		ifFalse: [self dbPundle: aPundle]</body><body package="Store-Publishing Support">pundle: aPundle binary: aBoolean in: aSession	^(aPundle isLoaded and: [aPundle isImageObject])		ifTrue: [self new pundle: aPundle binary: aBoolean in: aSession]		ifFalse: [self dbPundle: aPundle]</body><body package="Store-Publishing Support">pundle: aPundle in: aSession	^(aPundle isLoaded and: [aPundle isImageObject])		ifTrue: [self new pundle: aPundle in: aSession]		ifFalse: [self dbPundle: aPundle]</body></methods><methods><class-id>Store.Glorp.GeneralResolution</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^false</body><body package="Store-Merge Management">isAbsentResolution	^false</body><body package="Store-Merge Management">isDoNothingResolution	^false</body><body package="Store-Merge Management">isNoOpResolution	^false</body><body package="Store-Merge Management">isRemovalResolution	^false</body><body package="Store-Merge Management">isStandardResolution	^false</body><body package="Store-Merge Management">isUserInputResolution	^false</body></methods><methods><class-id>Store.Glorp.GeneralResolution</class-id> <category>accessing</category><body package="Store-Merge Management">key	^package</body><body package="Store-Merge Management">package	^package</body><body package="Store-Merge Management">package: anObject	package := anObject</body><body package="Store-Merge Management">value	self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.GeneralResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management">forPackage: aPundle	| instance |	instance := self new.	instance package: aPundle.	^instance</body><body package="Store-Merge Management">new	^super new initialize</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>testing</category><body package="Store-Change Management">isEmpty		^classes1 isEmpty and: 		[classes2 isEmpty and: 		[meta1 isEmpty and: 		[meta2 isEmpty and: 		[ nameSpaces1 isEmpty and:		[ nameSpaces2 isEmpty and:		[methods1 isEmpty and: 		[methods2 isEmpty and: 		[data1 isEmpty and: 		[data2 isEmpty]]]]]]]]]</body><body package="Store-Change Management">isNewClassDefinition: aClass	"Anser true if aClass is in one of the class lists."	^(IdentitySet withAll: (classes1, classes2, meta1, meta2)) includes: aClass</body><body package="Store-Change Management">isNewNameSpaceDefinition: aNameSpace	"Anser true if aNameSpace is in one of the nameSpace lists."	^(IdentitySet withAll: (nameSpaces1, nameSpaces2)) includes: aNameSpace</body><body package="Store-Change Management">isPackageComparitor	^false</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>filing out</category><body package="Store-Change Management">classesToRemove	^classes2 select: 		[ :each | 		( classes1 detect: [:cl1 | cl1 absoluteName = each absoluteName] ifNone: [ nil] ) 				isNil		]</body><body package="Store-Change Management">dataToRemove	^data2 		select: [:each | 			(data1 detect: [:m1 | m1 name = each name 							and: [m1 environmentString = each environmentString]]						ifNone: [nil]) isNil]</body><body package="Store-Change Management">fileDiffsOn: fileManager	"Create a file containing differences between package1 and package2. 	If the package2 is currently loaded into an image, filing in the 	differences will change it into package1"	| class2  nameSpace2 toFileOut  classNamesToRemove nameSpacesToRemove |	fileManager deferInitializations.	"New namespaces or namespaces with new definitions."	nameSpaces1 do: 		[ :each | 		nameSpace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName] ifNone: [ nil ].		each fileOutDifferencesBetween: nameSpace2 on: fileManager		].	"New classes or classes with new definitions."	classes1 do: 		[ :each | 		class2 := classes2 detect: [:cl2 | cl2 absoluteName = each absoluteName] ifNone: [nil].		each fileOutDifferencesBetween: class2 on: fileManager		].	"Removed classes."	classNamesToRemove := self classesToRemove collect: [ :cls | cls absoluteName ].	classNamesToRemove reverseDo: 		[ :className | fileManager removeObject: className type: #class ].	classNamesToRemove := classNamesToRemove, 		( classNamesToRemove collect: [ :cn | cn fullMetaName ] ).		"Removed namespaces."	nameSpacesToRemove := self nameSpacesToRemove collect: [ :ns | ns absoluteName ].	nameSpacesToRemove reverseDo:		[ :nsname | fileManager removeObject: nsname type: #nameSpace	].	"New method definitions."	toFileOut := self modifiedMethods.	toFileOut keysAndValuesDo: 		[ :k :v | fileManager fileOutTTMessages: v for: k logging: false ].	"Removed methods."	self methodsToRemove do: 		[ :method | 		( classNamesToRemove includes: method className )			ifFalse: [ fileManager storeExpression: 						method className , ' removeSelector: ' , method selector storeString 					  ]		].</body><body package="Store-Change Management">isNotLoaded	^LoadAnalyzer		preDBLoadOverlapCheckOf: pkg2		classes: classes1		nameSpaces: nameSpaces1		methods: methods1		data: data1</body><body package="Store-Change Management">methodsToRemove	^methods2 select: 		[ :each | 		( methods1 detect: 			[ :m1 | 			( ( m1 isMeta = each isMeta ) and:				[ m1 name = each name ] ) and:				[ m1 className asClassNameOnly = each className asClassNameOnly ] 			] ifNone: [ nil] ) isNil		]</body><body package="Store-Change Management">nameSpacesToRemove	^nameSpaces2 select: 		[:each | (nameSpaces1 					detect: [:ns1 | ns1 absoluteName = each absoluteName ]					ifNone: [nil]					) isNil 		]</body><body package="Store-Change Management">preLoadCheckWithin: aBundle	^LoadAnalyzer		preDBLoadOverlapCheckOf: pkg2		within: aBundle		classes: classes1		nameSpaces: nameSpaces1		methods: methods1		data: data1</body><body package="Atomic Compiling and Loading">sortedClassesToRemove	| namedClassesToRemove sortedClasses sortedObjects |	namedClassesToRemove := self classesToRemove.	sortedClasses := SystemUtils sortForLoading: (namedClassesToRemove collect: [:each | each actual]).	sortedObjects := OrderedCollection new: namedClassesToRemove size.	1 to: sortedClasses size do:		[:index |		sortedObjects add: (namedClassesToRemove detect: [:each | each absoluteName = (sortedClasses at: index) absoluteName])].	^(sortedObjects reject: [:each | each isNil]) reverse</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing - diff browser</category><body package="Store-Change Management">diffClasses	"Answer an array contianing collection of classes that are either modified in one package	or contain methods that are modified.  Note that meta side is included in the answer."	| names1 aditionalClasses1 names2 aditionalClasses2 allClasses answ1 answ2 names |	names1 := Set new.	methods1 do: [ :m| names1 add: m className ].	data1 do: [ :m | m  isInClass ifTrue: [ names1 add: m ownerName ] ].	allClasses := classes1, meta1.	(allClasses) do: [:cl| names1 remove: cl absoluteName ifAbsent: []].	aditionalClasses1 := pkg1 classesNamed: names1.	answ1 := (allClasses, aditionalClasses1) asSortedCollection: [:x :y | x name &lt; y name].	names2 := Set new.	methods2 do: [:m| names2 add: m classNameWithMeta].	data2 do: [ :m| m  isInClass ifTrue: [names2 add: m ownerName] ].	allClasses := classes2, meta2.	(allClasses) do: [:cl| names2 remove: cl absoluteName ifAbsent: []].	aditionalClasses2 := pkg2 classesNamed: names2.	answ2 := (allClasses, aditionalClasses2) asSortedCollection: [:x :y | x name &lt; y name].	"Check if additional classes are in both packages."	names := names1 - names2.	answ2 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ2 addAll: (pkg2 classesNamed: names).	names := names2 - names1.	answ1 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ1 addAll: (pkg1 classesNamed: names).	^Array with: answ1 with: answ2</body><body package="Store-Change Management">diffNameSpaces	"Answer an array contianing collection of namespaces that are either modified in one package	or contain methods that are modified. "	| names1 aditional1 names2 aditional2 allNameSpaces answ1 answ2 names |	names1 := Set new.	data1 do: [ :m| m  isInNameSpace ifTrue: [ names1 add: m ownerName ] ].	allNameSpaces := nameSpaces1.	allNameSpaces do: [:ns | names1 remove: ns absoluteName ifAbsent: []].	aditional1 := pkg1 nameSpacesNamed: names1.	answ1 := (allNameSpaces, aditional1) asSortedCollection: [:x :y | x absoluteName &lt; y absoluteName].	names2 := Set new.	data2 do: [:m| m  isInNameSpace ifTrue: [ names2 add: m ownerName] ].	allNameSpaces := nameSpaces2.	(allNameSpaces) do: [:ns| names2 remove: ns absoluteName ifAbsent: []].	aditional2 := pkg2 nameSpacesNamed: names2.	answ2 := (allNameSpaces, aditional2) asSortedCollection: [:x :y | x name &lt; y name].	"Check if additional namespaces are in both packages."	names := names1 - names2.	answ2 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ2 addAll: (pkg2 nameSpacesNamed: names).	names := names2 - names1.	answ1 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ1 addAll: (pkg1 nameSpacesNamed: names).	^Array with: answ1 with: answ2</body><body package="Store-Change Management">methodsAndDataSide: side forClassNamed: cName andProtocol: pName 	"If 'pName' is a method protocol select from methods	only those that are from a class named 'cName' and 	classified under protocol 'pName'.  If 'pName' is a data	protocol (*data*) select from data only those that	are from a class named 'cName'."	^(pName = '*data*'		ifTrue: [(self dataSide: side) 				select: [:datum | datum ownerName = cName]]		ifFalse: [(self methodsSide: side) 				select: [:method | method className = cName 					and: [method protocolName = pName]]])		asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-Change Management">methodsSide: side remove: aMethodDescriptor		(self methodsSide: side) remove: aMethodDescriptor</body><body package="Store-Change Management">newMethods	^methods1 asList, methods2 asList</body><body package="Store-Change Management">protocolsSide: side forClassNamed: cName 	"Answer a collection of protocol names (strings)	that are from a class named cName"	| protocols mthds |	protocols := Set new: (self methodsSide: side) size.	mthds := (self methodsSide: side) select: [:method | method classNameWithMeta = cName].	mthds do: [:method| protocols add: method protocolName].	((self dataSide: side) 		detect: [:datum | datum ownerName = cName] 		ifNone: [nil]) notNil ifTrue: [			protocols add: '*data*'].	^protocols asSortedCollection</body><body package="Store-Change Management">reverse	"Swap pkg1 with pkg2"	| tmp |	tmp := pkg1.	pkg1 := pkg2.	pkg2 := tmp.	tmp := classes1.	classes1 := classes2.	classes2 := tmp.	tmp := meta1.	meta1 := meta2.	meta2 := tmp.	tmp := methods1.	methods1 := methods2.	methods2 := tmp.	tmp := data1.	data1 := data2.	data2 := tmp.</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing</category><body package="Store-Change Management">classesSide: side	^side = 1 		ifTrue: [classes1] 		ifFalse: [classes2]</body><body package="Store-Change Management">classesSide: side put: aValue 	side = 1		ifTrue: [classes1 := aValue asOrderedCollection]		ifFalse: [classes2 := aValue asOrderedCollection]</body><body package="Store-Change Management">dataSide: side	^side = 1 ifTrue: [data1] ifFalse: [data2]</body><body package="Store-Change Management">dataSide: side put: aValue 	side = 1		ifTrue: [data1 := aValue asOrderedCollection]		ifFalse: [data2 := aValue asOrderedCollection]</body><body package="Store-Change Management">hasDifferences	"*** adapted from 17 November 1994 at 1:35:56 pm by IA (Image Administrator	) in b940919 ***"	"Returns a boolean indicating whether or not some differences were found"	^(self classesSide: 1)	isEmpty not or: [	 (self classesSide: 2) 	isEmpty not or: [	 (self metaSide: 1) 		isEmpty not or: [	 (self metaSide: 2)		isEmpty not or: [	(self nameSpacesSide:  1) isEmpty not or: [	(self nameSpacesSide:  2) isEmpty not or: [	 (self methodsSide: 1) 	isEmpty not or: [	 (self methodsSide: 2) 	isEmpty not or: [	 (self dataSide: 1) 	isEmpty not or: [	 (self dataSide: 2) 	isEmpty not]]]]]]]]]</body><body package="Store-Change Management">itemCount	^classes1 size + nameSpaces1 size + methods1 size +  data1 size</body><body package="StoreForGlorpVWUI">makeEmpty	classes1 := classes2 := meta1 := meta2 := nameSpaces1 := nameSpaces2 := methods1 := methods2 := data1 := data2 := #().</body><body package="Store-Change Management">metaSide: side	^side = 1 ifTrue: [meta1] ifFalse: [meta2]</body><body package="Store-Change Management">metaSide: side put: aValue 	side = 1		ifTrue: [meta1 := aValue asOrderedCollection]		ifFalse: [meta2 := aValue asOrderedCollection]</body><body package="Store-Change Management">methodsSide: side	^side = 1 ifTrue: [methods1] ifFalse: [methods2]</body><body package="Store-Change Management">methodsSide: side put: aValue 	side = 1		ifTrue: [methods1 := aValue asOrderedCollection]		ifFalse: [methods2 := aValue asOrderedCollection]</body><body package="Store-Change Management">nameSpacesSide: side	^side = 1 		ifTrue: [ nameSpaces1 ] 		ifFalse: [ nameSpaces2 ]</body><body package="Store-Change Management">nameSpacesSide: side put: aValue 	side = 1		ifTrue: [nameSpaces1 := aValue asOrderedCollection]		ifFalse: [nameSpaces2 := aValue asOrderedCollection]</body><body package="Store-Change Management">pkgSide: side	^side = 1 ifTrue: [pkg1] ifFalse: [pkg2]</body><body package="Store-Change Management">pkgSide: side put: aValue 	side = 1		ifTrue: [pkg1 := aValue]		ifFalse: [pkg2 := aValue]</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>private</category><body package="Store-Change Management">cleanUpClassDiffsIn: cls1 and: cls2	"Check if classes are really 	different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	cls1 do: 		[:cl1 |		| idx cl2 |		idx := cls2 findFirst: [:cl| cl absoluteName = cl1 absoluteName].		idx isZero 			ifFalse:				[cl2 := cls2 at: idx.				cl2 definitionAndComment = cl1 definitionAndComment					ifTrue: 						[toRemove1 add: cl1.						cls2 removeAtIndex: idx]]].	cls1 removeAll: toRemove1.</body><body package="Store-Change Management">cleanUpDiffs	"Check if method and classes are really 	different or just came from different sources."	methods1 := methods1 asOrderedCollection.	methods2 := methods2 asOrderedCollection.	self cleanUpSubdefDiffsIn: methods1 and: methods2.	data1 := data1 asOrderedCollection.	data2 := data2 asOrderedCollection.	self cleanUpSubdefDiffsIn: data1 and: data2.	classes1 := classes1 asOrderedCollection.	classes2 := classes2 asOrderedCollection.	self cleanUpClassDiffsIn: classes1 and: classes2.	nameSpaces1 := nameSpaces1 asOrderedCollection.	nameSpaces2 := nameSpaces2 asOrderedCollection.	self cleanUpNameSpaceDiffsIn: nameSpaces1 and: nameSpaces2.</body><body package="Store-Change Management">cleanUpNameSpaceDiffsIn: namespaces1 and: namespaces2	"Check if namespaces are really different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	namespaces1 do: 		[ :ns1 |		| idx ns2 |		idx := namespaces2 findFirst: [ :ns | ns absoluteName = ns1 absoluteName ].		idx isZero 			ifFalse:				[ ns2 := namespaces2 at: idx.				ns2 definitionAndComment = ns1 definitionAndComment					ifTrue: 						[ toRemove1 add: ns1.						namespaces2 removeAtIndex: idx						]				]		].	namespaces1 removeAll: toRemove1.</body><body package="Store-Change Management">cleanUpSubdefDiffsIn: subdefs1 and: subdefs2	"Check if method/data are really 	different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	subdefs1 do: 		[:m1 | 		| idx m2|		idx := m1 isForData			ifTrue: [ subdefs2 findFirst: [:m | m absoluteName = m1 absoluteName ] ]			ifFalse: 				[ subdefs2 findFirst: 					[ :d | d selector = m1 selector and: 							[ d classNameWithMeta = m1 classNameWithMeta ] 					]				].		idx isZero ifFalse: 			[m2 := subdefs2 at: idx.			(m2 sourceMatches: m1)				ifTrue: 					[toRemove1 add: m1.					subdefs2 removeAtIndex: idx]]].	subdefs1 removeAll: toRemove1.</body><body package="Store-Change Management">combineDiffsFrom: aDiffHolder	"Add differences from aDiffHolder into my differences."	1 to: 2 do: 		[ :side | 		self methodsSide: side 			put: ((self methodsSide: side) , (aDiffHolder methodsSide: side)).		self dataSide: side 			put: ((self dataSide: side) , (aDiffHolder dataSide: side)).		self classesSide: side 			put: ((self classesSide: side) , (aDiffHolder classesSide: side)).		self metaSide: side 			put: ((self metaSide: side) , (aDiffHolder metaSide: side)).		self nameSpacesSide: side 			put: ((self nameSpacesSide: side) , (aDiffHolder nameSpacesSide: side))		].	"Remove differences that are in both."	self removeDuplicateDifferencesIn: methods1 and: methods2.	self removeDuplicateDifferencesIn: data1 and: data2.	self removeDuplicateDifferencesIn: classes1 and: classes2.	self removeDuplicateDifferencesIn: meta1 and: meta2.	self removeDuplicateDifferencesIn: nameSpaces1 and: nameSpaces2.</body><body package="Store-Change Management">computeDiffs		pkg1 computeDiffsBetween: pkg2 into: self. 	pkg2 pseudoPackage ifFalse: [self cleanUpDiffs].</body><body package="Store-Change Management">removeDuplicateDifferencesIn: defs1 and: defs2 	"Remove differences that are in both."	| toRemove |	toRemove := List new.	defs1 do: 		[:each | 		| idx |		(idx := defs2 indexOf: each ifAbsent: [nil]) notNil			ifTrue: 				[defs2 removeAtIndex: idx.				toRemove add: each]].	defs1 removeAll: toRemove</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>change set</category><body package="Store-Change Management">changeSet	"Answer a change set reflecting differences between package1 and package2. 	If package2 is currently loaded into an image, this change set reflects changes since	package1."	| cset |	cset := XChangeSet new.	self defClassChanges do:		[ :change | cset doClassChange: change ].	self defNameSpaceChanges do:		[ :change | cset doNameSpaceChange: change ].	self subdefChanges do:		[ :change | cset doSubdefChange: change ].	self propertyChanges do:		[ :change | cset addPropertyChange: change ].	self otherChanges do:		[ :change | cset addOtherChange: change ].	^cset.</body><body package="Store-Change Management">defClassChanges	"Answer a collection of definition changes for all Classes."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	classes1 do:		[ :cls |  | sym c2 |		sym := cls absoluteName.		( c2 := classes2 detect: [ :c | c comparesTo: cls ] ifNone: nil ) notNil			ifTrue: 				[ cls definition = c2 definition  					ifFalse: [ changes add: ( Change new classSymbol: sym ) change ].				( cls comment string equalsAcrossPlatforms:  c2 comment string )					ifFalse: [ changes add: ( Change new classSymbol: sym ) comment ]				]			ifFalse: 				[ changes add: ( Change new classSymbol: sym ) removeDefinition ].		].	classes2 do:		[ :cls | 		( classes1 contains: [ :c | c comparesTo: cls ] )			ifFalse: 				[ changes add: ( Change new classSymbol: cls absoluteName ) add.				cls comment isEmpty					ifFalse: [ changes add: ( Change new classSymbol: cls absoluteName ) comment ]				].		].	^changes</body><body package="Store-Change Management">defNameSpaceChanges	"Answer a collection of definition changes for all NameSpaces."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	nameSpaces1 do:		[ :ns |  | sym n2 |		sym := ns absoluteName.		( n2 := nameSpaces2 detect: [ :c | c comparesTo: ns ] ifNone: nil ) notNil			ifTrue: 				[ ns definition = n2 definition  					ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) change ].				( ns comment string equalsAcrossPlatforms:  n2 comment string )					ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) comment ]				]			ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) removeDefinition ].		].	nameSpaces2 do:		[ :ns | 		( nameSpaces1 contains: [ :c | c comparesTo: ns ] )			ifFalse: 				[ changes add: ( Change new nameSpaceSymbol: ns absoluteName ) add.				ns comment isEmpty					ifFalse: [ changes add: ( Change new nameSpaceSymbol: ns absoluteName ) comment ]				].		].	^changes</body><body package="Store-Change Management">otherChanges	"Answer a collection of 'other' changes. Compare bundle structures"	"The changes should move from pkg1 to pkg2"	pkg1 isBundle		ifFalse: [ ^#() ].	^pkg1 structure = pkg2 structure		ifTrue: [ #() ]		ifFalse: [ BundleModel structureMark ]." nice thought, but not what we need right now		ifFalse: [ Array with: ( BundleStructureChange new component: pkg1 ) ]."</body><body package="Store-Change Management">propertyChanges	"Answer a collection of 'other' changes. Compare properties."	"The changes should move from pkg1 to pkg2"	| changes props1 props2 |	changes := Set new.	props1 := pkg1 propertiesForFileOut.	props2 := pkg2 propertiesForFileOut.	props1 associationsDo:		[ :assoc |		( props2 includesKey: assoc key )			ifTrue: 				[ ( assoc value = ( props2 at: assoc key ) )					ifFalse: [ changes add: assoc key ]				]			ifFalse: [ changes add: assoc key ].		].	props2 associationsDo:		[ :assoc |		( props1 includesKey: assoc key )			ifTrue: 				[ ( assoc value = ( props1 at: assoc key ) )					ifFalse: [ changes add: assoc key ]				]			ifFalse: [ changes add: assoc key ].		].	^changes asOrderedCollection.</body><body package="Store-Change Management">subdefChanges	"Answer a collection of subdef changes."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	methods1 do:		[ :meth |  | chg |		chg := Change new classSymbol: meth className; selector: meth selector.		( methods2 includes: meth )			ifTrue: [ chg change ]			ifFalse: [ chg remove ].		changes add: chg.		].	methods2 do:		[ :meth |  | chg |		chg := Change new classSymbol: meth className; selector: meth selector.		( methods1 includes: meth )			ifTrue: [ chg change ]			ifFalse: [ chg add ].		changes add: chg.		].	data1 do:		[ :data |  | chg |		chg := Change new.		data isInClass			ifTrue: [ chg classSymbol: data ownerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: data ownerName asSymbol ].		chg dataKey: data dataKey.		( data2 includes: data )			ifTrue: [ chg change ]			ifFalse: [ chg remove ].		changes add: chg.		].	data2 do:		[ :data |  | chg |		chg := Change new.		data isInClass			ifTrue: [ chg classSymbol: data ownerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: data ownerName asSymbol ].		chg dataKey: data dataKey.		( data1 includes: data )			ifTrue: [ chg change ]			ifFalse: [ chg add ].		changes add: chg.		].	^changes</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing-merge tool</category><body package="Store-Change Management">modifiedClassComment	"Answer a collection of classes that have modified comment."	|coll class2|	coll := List new.	classes1 do: 		[:each | 		class2 := classes2 			detect: [ :cl2 | cl2 name = each name ] ifNone: [ nil ].		( class2 isNil or: [ each comment ~= class2 comment ] )			ifTrue: [coll add: each]].	^coll</body><body package="Store-Change Management">modifiedClassDefinitions	"Answer a collection of classes that have modified definition."	| coll class2 |	coll := List new.	classes1 do: 		[ :each | 		class2 := classes2 			detect: [:cl2 | cl2 name = each name ] ifNone: [ nil ].		(class2 isNil or: [ each definition ~= class2 definition ] )				ifTrue: [ coll add: each ]		]." we don't do metaclasses no more ....	meta1		do: 			[:each | 			class2 := meta2 detect: [:cl2 | cl2 name = each name]						ifNone: [nil].			(class2 isNil or: [each definition ~= class2 definition])				ifTrue: [coll add: each]]."	^coll</body><body package="Store-Change Management">modifiedData	"Added by Philippe F. Monnet of Andersen Consulting 	New data definitions."	| modified byClass |	modified := Dictionary new.	data1 		do: 			[:each | 			byClass := modified at: each className ifAbsent: [Set new].			byClass add: each.			modified at: each className put: byClass].	^modified</body><body package="Store-Change Management">modifiedMethods	"New method definitions."	| modified byClass byProtocol |	modified := Dictionary new.	methods1		do: 			[:each | 			byClass := modified at: each className ifAbsent: [Dictionary new].			byProtocol := byClass at: each protocolName ifAbsent: [Set new].			byProtocol add: each.			byClass at: each protocolName put: byProtocol.			modified at: each className put: byClass].	^modified</body><body package="Store-Change Management">modifiedNameSpaceComment	"Answer a collection of namespaces that have modified comment."	|coll namespace2|	coll := List new.	nameSpaces1 do: 		[:each | 		namespace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName ] ifNone: [ nil ].		( namespace2 isNil or: [ each comment ~= namespace2 comment ] )			ifTrue: [coll add: each]].	^coll</body><body package="Store-Change Management">modifiedNameSpaceDefinitions	"Answer a collection of namespaces that have modified definitions."	| coll namespace2 |	coll := List new.	nameSpaces1 do: 		[ :each | 		namespace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName ] ifNone: [ nil ].		( namespace2 isNil or: [ each definition ~= namespace2 definition ] )				ifTrue: [ coll add: each ]		].	^coll</body><body package="Store-Change Management">modifiedProperties	"Answer a collection of property symbols that have been modified."	| coll  |	coll := Set new.	pkg1 propertiesForSave keys asOrderedCollection, 		pkg2 propertiesForSave keys asOrderedCollection do:		[ :prop |		( ( pkg1 propertyAt: prop ifAbsent: nil ) = ( pkg2 propertyAt: prop ifAbsent: nil ) )			ifFalse: [ coll add: prop ].		].	^coll asOrderedCollection asList</body><body package="Store-Change Management">modifiedStructures	"Answer a collection of bundles whose structure has changed."	| list |	list := OrderedCollection new.	pkg1 isBundle		ifFalse: [ ^list ].	pkg1 structure = pkg2 structure		ifFalse: [ list add: pkg1 ].	^list</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing - loader</category><body package="Atomic Compiling and Loading">classesToLoad		^classes1</body><body package="Atomic Compiling and Loading">dataToLoad	^data1</body><body package="Atomic Compiling and Loading">methodsToLoad	^methods1</body><body package="Atomic Compiling and Loading">nameSpacesToLoad		^nameSpaces1</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>glorp faking</category><body package="StoreForGlorpVWUI">mainPackageClasses: aCollection	self classesSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI">mainPackageMethods: aCollection	self methodsSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI">mainPackageNamespaces: aCollection	self nameSpacesSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI">mainPackageShareds: aCollection	self dataSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI">otherPackageClasses: aCollection	self classesSide: 2 put: aCollection</body><body package="StoreForGlorpVWUI">otherPackageMethods: aCollection	self methodsSide: 2 put: aCollection</body><body package="StoreForGlorpVWUI">otherPackageNamespaces: aCollection	self nameSpacesSide: 2 put: aCollection</body><body package="StoreForGlorpVWUI">otherPackageShareds: aCollection	self dataSide: 2 put: aCollection</body></methods><methods><class-id>Store.PackageDifferences class</class-id> <category>instance creation</category><body package="Store-Change Management">with: pkg1 with: pkg2	^(self new) pkgSide: 1 put: pkg1; pkgSide: 2 put: pkg2; computeDiffs; yourself</body></methods><methods><class-id>Store.UserManagementPoliciesNotInstalledNotice</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog warn:		(#ToAddUserManagementStallUserManagement &lt;&lt; #store &gt;&gt;		'To add user management policies later, execute:&lt;n&gt;''StoreDescriptorSystem installUserManagementPolicies''') expandMacros</body></methods><methods><class-id>Store.UserManagementPoliciesNotInstalledNotice class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>copying</category><body package="Store-Database Model">postCopy	super postCopy.	definition := definition copy.	comment := comment copy.</body><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	definition := definition glorpCopyIn: aDictionary.	comment := comment glorpCopyIn: aDictionary.	(comment notNil and: [comment source isEmpty]) ifTrue: [comment := nil].</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>printing</category><body package="Store-Database Model">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self environmentName;		nextPut: $.;		nextPutAll: self name;		nextPut: $)</body><body package="StoreForGlorpVWUI">shortItemString	^self name</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>comparing</category><body package="Store-Database Model">&lt; aStoreDefinitionObject	^self definition &lt; aStoreDefinitionObject definition.</body><body package="Store-Database Model">&lt;= aStoreDefinitionObject	^self definition &lt;= aStoreDefinitionObject definition.</body><body package="Store-Database Model">= aStoreDefinitionObject	^self class == aStoreDefinitionObject class and: [self reconcilesWith: aStoreDefinitionObject].</body><body package="Store-Database Model">hash	^self class hash hashMultiply bitXor: name hash</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>accessing</category><body package="Store-Database Model">absoluteSymbol	^self longName asSymbol</body><body package="Store-Database Model">asText	^self source asText.</body><body package="Store-Database Model">basicDefinition	^definition.</body><body package="Store-Database Model">basicDefinition: aStoreBlob	definition := aStoreBlob.</body><body package="Store-Database Model">comment: aString	comment := StoreBlob forString: aString.</body><body package="Store-Database Model">commentID	^comment ifNotNil: [:value | value primaryKey]</body><body package="Store-Database Model">definition	^definition source</body><body package="Store-Database Model">definition: aString	definition := StoreBlob forString: aString.</body><body package="Store-Database Model">definitionAndComment	"ummmm"	^self definition, 'COMMENT:', self comment.</body><body package="Store-Database Model">definitionID	^definition ifNotNil: [:value | value primaryKey]</body><body package="StoreForGlorpVWUI">definitionObject	^self</body><body package="Store-Database Model">definitionString	^definition source.</body><body package="Store-Database Model">environmentName	^environmentName</body><body package="Store-Database Model">environmentName: aString	environmentName := aString.</body><body package="Store-Database Model">environmentNameFromSmalltalk		| index startingFromSmalltalk |	index := self environmentName findString: '.Smalltalk' startingAt: 1.	startingFromSmalltalk := self environmentName copyFrom: index + 1 to: self environmentName size.	index isZero ifTrue: [(self environmentName findString: 'Root' startingAt: 1) isZero ifFalse: [index := 1]].	index isZero ifFalse: [index := startingFromSmalltalk indexOf: $.].	^startingFromSmalltalk copyFrom: index + 1 to: startingFromSmalltalk size</body><body package="Store-Database Model">environmentString	^self environmentName.</body><body package="Store-Database Model">fullName	^self longName.</body><body package="Store-Database Model">longName	^longName ifNil: [longName := self privateGetLongName].</body><body package="Store-Database Model">source	^self definition.</body><body package="Store-Database Model">symbol	^self absoluteSymbol</body><body package="Store-Database Model">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printString with: self userName)</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>reconciling</category><body package="Store-Database Model">reconcilesWith: aStoreDefinitionObject	(super reconcilesWith: aStoreDefinitionObject) ifFalse: [^false].	self environmentName = aStoreDefinitionObject environmentName ifFalse: [^false].	self comment = aStoreDefinitionObject comment ifFalse: [^false].	self definition = aStoreDefinitionObject definition ifFalse: [^false].	^true.</body><body package="Store-Database Model">unreconcile	super unreconcile.	comment isNil ifFalse: [comment unreconcile].	definition unreconcile.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>private</category><body package="Store-Database Model">basicComment	^comment</body><body package="Store-Database Model">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model">basicSource	^definition.</body><body package="Store-Database Model">basicSource: aStoreBlob	definition := aStoreBlob.</body><body package="Store-Database Model">privateGetLongName	| ownerName |	ownerName := self environmentName.	^(ownerName isNil or: [ownerName isEmpty])		ifTrue: [self name]		ifFalse: [ownerName , '.' , self name]</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>testing</category><body package="Store-Database Model">isExtension	^false</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>filling out</category><body package="Store-Database Model">fileOutDefinitionOn: aStream	aStream storeObjectDefinition: self.</body><body package="Store-Database Model">fileOutOn: aSourceFileManager		aSourceFileManager storeObjectDefinition: self.	(self comment notNil and: [self comment notEmpty]) ifTrue:		[aSourceFileManager comment: self value: self comment]</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self longNameFromSmalltalk		with: self timeStampString		with: self username</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>fileIn/Out</category><body package="Store-Database Model">fileOutDifferencesBetween: aStoreDefinitionObject on: aSourceCodeStream	self definitionString = aStoreDefinitionObject definitionString ifFalse:		[self fileOutSourceOn: aSourceCodeStream].	self comment = aStoreDefinitionObject comment ifFalse:		[aSourceCodeStream comment: self value: self comment]</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject class</class-id> <category>instance creation</category><body package="Store-Database Model">allNamesMatching: aString		^self allNamesMatching: aString in: nil</body><body package="Store-Database Model">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copy replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body><body package="Store-Database Model">allVersionsNamed: aString in: aSessionOrNil		| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">allVersionsWithName: aString		^self allVersionsNamed: aString in: nil</body><body package="Store-Database Model">selectVersionNamed: aString	^self selectVersionNamed: aString in: nil</body><body package="Store-Database Model">selectVersionNamed: aName in: aSessionOrNil		| versions |	versions := self allVersionsNamed: aName in: aSessionOrNil.	versions isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	versions size == 1 ifTrue: [^versions first].	^Dialog 		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (versions collect: [:m | m fullDisplayString])		values: versions		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>accessing</category><body package="Store-Database Model">definition	^self object.</body><body package="Store-Database Model">object	^self basicDefinition object.</body><body package="Store-Database Model">searchString	^searchString</body><body package="Store-Database Model">searchString: aString	"Clean up TwoByteString objects, etc. before accepting them.	Return a search string for anObject, or empty string.  To prevent db encoding complaints, convert to ascii, or use empty string."	| bytes |	searchString := aString isString		ifTrue:			[bytes := [aString asByteArrayEncoding: #ascii]				on: Error 				do: [:exception | exception return: #[]].			bytes asString]		ifFalse: ['']</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>reconciling</category><body package="Store-Database Model">reconcilesWith: aStoreDefinitionObject	self searchString = aStoreDefinitionObject searchString ifFalse: [^false].	(super reconcilesWith: aStoreDefinitionObject) ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	"See class creation method."	super postCopyIn: aDictionary.	searchString isNil ifFalse: [searchString := searchString copyFrom: 1 to: (250 min: searchString size)].</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>printing</category><body package="Store-Database Model">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $)</body></methods><methods><class-id>Store.Glorp.StoreProperty class</class-id> <category>instance creation</category><body package="Store-Database Model">named: aString forObject: anObject in: aPundle	| objectName |	objectName := anObject displayString asString.	^self new		username: aPundle username;		timestamp: (aPundle timestamp ifNil: [Dialect storeTimestampIn: aPundle session]);		name: aString;		basicDefinition: (StoreBlob forObject: anObject);		searchString: (objectName copyFrom: 1 to: (255 min: objectName size)).	"We allow 255 characters, but on some databases the field we are writing to is 255 bytes long, so non-ascii characters might pad that. The descriptorForStoreProperty: 'searchString' Mapping therefore uses a #stringToTrimmedString converter to write as many characters as the database can accept."</body></methods><methods><class-id>Store.CleanUp</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">actionText	^(#CleanUp &lt;&lt; #store &gt;&gt; 'Clean Up') asString</body><body package="Atomic Compiling and Loading">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.Glorp.StorePundlePropertyRelationship</class-id> <category>accessing</category><body package="Store-Database Model">propertyID		^propertyID</body><body package="Store-Database Model">propertyID: anObject		propertyID := anObject</body><body package="Store-Database Model">pundleID		^pundleID</body><body package="Store-Database Model">pundleID: anObject		pundleID := anObject</body><body package="Store-Database Model">recordType		^recordType</body><body package="Store-Database Model">recordType: anObject		recordType := anObject</body></methods><methods><class-id>Store.Glorp.StorePundlePropertyRelationship class</class-id> <category>instance creation</category><body package="Store-Database Model">relationshipBundlesContainingPropertyID: anInteger	^self relationshipBundlesContainingPropertyID: anInteger in: nil</body><body package="Store-Database Model">relationshipBundlesContainingPropertyID: anInteger in: aSessionOrNil	^self 		relationshipOfType: StoreBundle propertyTypeCode 		containingPropertyID: anInteger 		in: aSessionOrNil</body><body package="Store-Database Model">relationshipOfType: aTypeInteger containingPropertyID: anInteger in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: 		[:each |		each propertyID = anInteger AND: (each recordType = aTypeInteger)].	^session execute: query</body><body package="Store-Database Model">relationshipPackagesContainingPropertyID: anInteger	^self relationshipPackagesContainingPropertyID: anInteger in: nil</body><body package="Store-Database Model">relationshipPackagesContainingPropertyID: anInteger in: aSessionOrNil	^self 		relationshipOfType: StorePackage propertyTypeCode 		containingPropertyID: anInteger 		in: aSessionOrNil</body></methods><methods><class-id>Store.DBAccess</class-id> <category>accessing</category><body package="Store-Repository Access">cachedNames	cachedNames isNil ifTrue: [cachedNames := IdentityDictionary new].	^cachedNames</body><body package="Store-Repository Access">cachedNames: aDictionary	cachedNames := aDictionary</body><body package="Store-Repository Access">connectedProfile	^connectedProfileHolder value</body><body package="Store-Repository Access">connectedProfileHolder	"A ValueHolder which always contains a ConnectionProfile for the	currently connected repository, or nil if there is no connection."	^connectedProfileHolder</body><body package="Store-Repository Access">connectionClass	^connection notNil 		ifTrue: [ connection class]		ifFalse: 	[ExternalDatabaseConnection].</body><body package="Store-Repository Access">currentConnectString	^self currentDatabaseAccessor ifNotNil: 		[:value | value currentLogin connectString]</body><body package="Store-Repository Access">currentDatabaseAccessorForLogin: aGlorpLogin	"The ifTrue* branch is already logged in (so is already configured for Store).  All other branches return a not-logged-in accessor, so are sent login.  This act of logging in using a StoreLogin configures the platform and connection for Store."	^(currentDatabaseAccessor notNil		and: [currentDatabaseAccessor isLoggedIn			and: [self connectedProfile notNil]])		ifTrue: [self connectedProfile asGlorpLogin = aGlorpLogin				ifTrue: [currentDatabaseAccessor]				ifFalse: [(Glorp.DatabaseAccessor forLogin: aGlorpLogin) login]]		ifFalse: [currentDatabaseAccessor := (Glorp.DatabaseAccessor forLogin: aGlorpLogin) login]</body><body package="Store-Repository Access">currentUserName	^self userName</body><body package="Store-Repository Access">databaseIdentifier	(self hasDatabaseIdentifier not and: [self isOnline])		ifTrue: [databaseIdentifier := StoreObject databaseIdentifier asString].	^databaseIdentifier</body><body package="Store-Repository Access">databaseIdentifier: aString	databaseIdentifier := aString.</body><body package="Store-Repository Access">dbIdentifier		^self databaseIdentifier ifNotNil: [:value | value asSymbol]</body><body package="Store-Repository Access">debugger	^debugger isNil		ifTrue: [ debugger := StoreLogEnvironment new ]		ifFalse: [ debugger ]</body><body package="Store-Repository Access">doIfImageAdministrator: aBlock label: aString 	"Evaluate aBlock if we are online and the current user has admistration rights.	Otherwise display an error message"	self doIfOnlineImage: 			[self isSystemAdministrator 				ifTrue: [aBlock value]				ifFalse: 					[Dialog 						warn: (#OnlyTheImageAdministratorCan1s &lt;&lt; #store  &gt;&gt; 'Only the image administrator can &lt;1s&gt;.' expandMacrosWith: aString)]]</body><body package="Store-Repository Access">doIfOnlineImage: aBlock	| choice |	self isOnlineImage ifTrue: [^aBlock value].	choice := Dialog confirm: (#TheImageIsDisconnecOuLikeToReconnect &lt;&lt; #store &gt;&gt; 'The image is disconnected from the Database.&lt;n&gt;Would you like to reconnect?') expandMacros.	choice ifFalse: [^self].	self restoreConnection.	self isOnlineImage ifFalse: [^self].	^aBlock value</body><body package="Store-Repository Access">hasDatabaseIdentifier	^databaseIdentifier notNil</body><body package="Store-Repository Access">highestPrimaryKeyChecked	highestPrimaryKeyChecked isNil ifTrue: [highestPrimaryKeyChecked := IdentityDictionary new].	^highestPrimaryKeyChecked</body><body package="Store-Repository Access">highestPrimaryKeyChecked: anObject	highestPrimaryKeyChecked := anObject</body><body package="Store-Repository Access">isSystemAdministrator		^[self isOnline 		ifFalse: [false] 		ifTrue: [Store.Glorp.StoreUserGroup dbHasAdmin not or: [Store.Glorp.StoreUserGroup isInAdmin: self currentUserName]]]			on: self errorSignals			do:				[:ex | 				Transcript					cr;					show: ex description.				ex return: false]</body><body package="Store-Repository Access">recentProfile	^recentProfile</body><body package="Store-Repository Access">resetConnection	connection := nil.	connectedProfileHolder value: nil.	currentDatabaseAccessor := nil</body><body package="Store-Broker-Obsolete">storeBroker	^(self connection ifNil:	"user cancelled connection invite"		[Dialog warn: #BrokerDisconnectedFromDB &lt;&lt; #store &gt;&gt; 'Broker: Disconnected from DB'.		^StoreError raiseSignal]) class storeBroker</body><body package="Store-Repository Access">storeDescriptorSystemFor: aString	storeDescriptorSystems ifNil: [storeDescriptorSystems := Dictionary new].	^storeDescriptorSystems at: aString ifAbsent: [nil]</body><body package="Store-Repository Access">storeDescriptorSystemFor: aString ifAbsentPut: aStoreDescriptorSystemBlock	storeDescriptorSystems ifNil: [storeDescriptorSystems := Dictionary new].	^storeDescriptorSystems at: aString ifAbsentPut: aStoreDescriptorSystemBlock</body><body package="Store-Repository Access">storeDescriptorSystemForAccessor: aDatabaseAccessor	| identifierString systemClass |	identifierString := aDatabaseAccessor currentLogin connectionIdentifierString.	systemClass := self 		storeDescriptorSystemFor: identifierString		ifAbsentPut: 			[(StoreDescriptorSystem				checkStoreVersionFor: aDatabaseAccessor) class].	^systemClass forPlatform: aDatabaseAccessor platform.</body><body package="Store-Repository Access">tableOwner	^self tablePrefix</body><body package="Store-Repository Access">tablePrefix	tablePrefix isNil ifTrue: [tablePrefix := self defaultTablePrefix].	^tablePrefix</body><body package="Store-Repository Access">tablePrefix: aString	tablePrefix := aString</body><body package="Store-Repository Access">useAtomicLoader	^self class useAtomicLoader</body><body package="Store-Repository Access">useAtomicLoader: aBoolean	^self class useAtomicLoader: aBoolean</body></methods><methods><class-id>Store.DBAccess</class-id> <category>initialize-release</category><body package="Store-Database Model">clearPundleCaches	StorePundle withAllSubclasses do:		[:each | each initializeCache].</body><body package="Store-Repository Access">cloneFrom: existingDBAccess	connectedProfileHolder := existingDBAccess connectedProfileHolder.	(existingDBAccess tablePrefix isEmpty not and: [existingDBAccess  tablePrefix last == $.])		ifTrue: [self tablePrefix: (existingDBAccess  tablePrefix copyUpTo: $.)]		ifFalse: [self tablePrefix: existingDBAccess   tablePrefix].	self tablePrefix: existingDBAccess tablePrefix.	"If we have a connection, we will have discarded it. Make sure we cleanly log out from the other connection, and force ourselves to reconnect."	self connection: existingDBAccess connection.	recentProfile := existingDBAccess recentProfile.	databaseIdentifier := existingDBAccess databaseIdentifier.	currentDatabaseAccessor := existingDBAccess currentDatabaseAccessor.	storeDescriptorSystems := existingDBAccess storeDescriptorSystems</body><body package="Store-Repository Access">initialize	connectedProfileHolder := nil asValue</body></methods><methods><class-id>Store.DBAccess</class-id> <category>actions</category><body package="Store-Repository Access">createInstallScript	self createInstallScriptForProfile: self defaultInstallScriptProfile.</body><body package="Store-Repository Access">createInstallScriptForProfile: scriptProfile	| chosenProfile |	installScript := true.		[RepositoryManager addRepository: scriptProfile.	chosenProfile := Store.ConnectionDialog openProfile: scriptProfile.	chosenProfile isNil ifTrue: [^self].	self openLogTool.	StoreDescriptorSystem newRepositoryDescriptorSystemClass		createTablesFor: (StoreLoginFactory convertStoreLogin: chosenProfile)]			ensure: 				[RepositoryManager removeRepository: scriptProfile.				installScript := nil]</body><body package="Store-Repository Access">createUpdateScripts		installScript := true.	self openLogTool.	[self update77.	self update771.	self update78.	self update710]		ensure:			[installScript := nil]</body><body package="Store-Repository Access">defaultInstallScriptProfile	^(ConnectionProfile new)		name: 'Set Interface';		userName: 'Ignore This';		environment: 'Ignore This';		yourself</body><body package="Store-Repository Access">deinstallDatabaseTables	"Views (to provide backward-compatibility with VW7.6 and earlier images) will always be present in a database created in 7.7.1 and earlier, or in 7.9.1.  They may have been added in a database created in 7.8, 7.8.1 or 7.9.  On some platforms (e.g. Oracle), their definitions will (perhaps surprisingly) survive deletion of the tables they depend on, so delete them explicitly.  Treat any error raised while deleting them as indicating they are absent and nothing needs doing.  (If it has another meaning, the following dropTables call is almost sure to reraise it.)"	| connectionProfile login session |	(connectionProfile := Store.ConnectionDialog chooseProfile) ifNil: [^self].		[(UninstallingDatabaseTables for: 'Store') started.	login := StoreLoginFactory convertStoreLogin: connectionProfile.	login notNil ifTrue:		[session := self createSessionForLogin: login.		[session accessor executeSQLStringsNoResult: session platform dropStoreSpecificViewsSQL]			on: Error do: [:ex | ].		session dropTables.		self storeDescriptorSystems removeKey: login connectionIdentifierString].	"Overridden to avoid errors if no VisualLauncher is open"	(UninstallingDatabaseTables for: 'Store') finished]		withStoreFeedbackOn: VisualLauncher singleInstanceWindow.</body><body package="Store-Repository Access">goToScript	^installScript notNil</body><body package="Store-Repository Access">installDatabaseTables	| connectionProfile login session |	(connectionProfile := Store.ConnectionDialog chooseProfile) ifNil: [^self].		[(InstallingDatabaseTables for: 'Store') started.	login := StoreLoginFactory convertStoreLogin: connectionProfile.	login notNil ifTrue: [session := self createSessionForLogin: login].	"Overridden to avoid errors if no VisualLauncher is open"	(InstallingDatabaseTables for: 'Store') finished]		withStoreFeedbackOn: VisualLauncher singleInstanceWindow.</body><body package="Store-Repository Access">oldDeinstallDatabaseTables		self deprecated: #(#initial '5i' #obsolete '7.8' #for 'reference only').	self error: 'This code should NOT be run, and is here for research and reference only'.	"[self reconnect: false.	Package deinstallPkgs.	Privileges dropTables.	(Dialog confirm: #DoYouWantToDropTablespacesDatabases &lt;&lt; #store &gt;&gt; 'Do you want to drop tablespaces/databases?') 			ifTrue: [DBObject dropDatabases].	self goOffLine] 			on: Error			do: 				[:ex | 				self goOffLine.				ex return]"</body><body package="Store-Repository Access">oldInstallDatabaseTables	self deprecated: #(#initial '5i' #obsolete '7.8' #for 'reference only').	self error: 'This method is deprecated, and here for research and reference only'.	"self reconnect: false.	DBObject installPhysicalSpaces isNil 		ifTrue: 			[self goOffLine.			^false].	Package installPkgs.	self goToScript ifFalse: [DatabaseIdentifier installInDatabase].	Privileges installUserManagementTables.	self goToScript 		ifFalse: 			[(Dialog confirm: #InstallManagementPolicies &lt;&lt; #store &gt;&gt; 'Install management policies?') 				ifTrue: [Privileges installUserManagement]				ifFalse: 					[Dialog 						warn: (#ToAddUserManagementStallUserManagement &lt;&lt; #store &gt;&gt;									'To add user management policies later, execute:&lt;n&gt;''StoreDescriptorSystem installUserManagementPolicies''') expandMacros.					self printDebug: (#YouDidNotCreatedUsStallUserManagement &lt;&lt; #store &gt;&gt;			'You did not create user management policies. To add user management policies later execute: ''StoreDescriptorSystem installUserManagementPolicies''') asString]].	self goOffLine"</body><body package="Store-Repository Access">openLogTool		self debugger reset.	StoreLoggingTool clear.	self debugger dependents isEmpty ifTrue: [StoreLoggingTool openWith: self debugger]</body><body package="Store-Repository Access">update5i2		self deprecated: #(#initial '5i.2' #sunset '7.0').	self error: 'This method is deprecated, and here for research and reference only'.	"Store.DatabaseIdentifier createDatabaseTable.	(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: self databaseIdentifier.	Store.Package update5i2"</body><body package="Store-Repository Access">update5i3	"Fix for databases created with 5i.2. Alter STORAGE PSTINCREASE from 0 to 1"	self deprecated: #(#initial '5i.2' #sunset '7.0').	self error: 'This method is deprecated, and here for research and reference only'.	#{Store.Package} ifDefinedDo: [:value | value alterTablesPctincrease].	#{Store.Privileges} ifDefinedDo: [:value | value alterTablesPctincrease]</body><body package="Store-Repository Access">update7	"Adds sourceViews."	self deprecated: #(#initial '7.0' #sunset '7.7').	self error: 'This method is deprecated, and here for research and reference only'.	#{Store.DBObject} ifDefinedDo: [:value | value broker 		createSourcesViewForClass: #{Store.MethodsAndSourcesView} value;		createSourcesViewForClass: #{Store.DataAndSourcesView} value;		createSourcesViewForClass: #{Store.PkgClassesAndSourcesView} value;		createSourcesViewForClass: #{Store.PkgNameSpacesAndSourcesView} value].</body><body package="Store-Repository Access">update710	"This update makes sure that the indexes for the Garbage Collectorare correct, since we have added new indexes"	"Store.DbRegistry update710"		| session |	Cursor execute showWhile: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		[Store.DbRegistry goToScript ifTrue:			[session accessor logOnlyOn: Store.DbRegistry debugger debugStream].		session system update710] ensure: 			[session accessor endLogging]]</body><body package="Store-Repository Access">update77	"Adds the indexes for tables... First remove the one from Method, then proceed with the rest"	"Store.DbRegistry update77"		| session |	Cursor execute showWhile: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		[Store.DbRegistry goToScript ifTrue:			[session accessor logging: true.			session accessor logOnly: true.			session accessor logger: Store.DbRegistry debugger debugStream].		session system update77] ensure: 			[session accessor logging: false.			session accessor logOnly: false.			session accessor logger: nil]]</body><body package="Store-Repository Access">update771	"Adds the indexes for Method and Methods tables and adds Unique Constraints for Bundle and Package on version+name	Note: If either the Package or Bundle table have duplicate version+name rows, the adding of unique constraints will fail"	"Store.DbRegistry update771"		| session |	Cursor execute showWhile: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		[Store.DbRegistry goToScript ifTrue:			[session accessor logging: true.			session accessor logOnly: true.			session accessor logger: Store.DbRegistry debugger debugStream].		session system update771] ensure: 			[session accessor logging: false.			session accessor logOnly: false.			session accessor logger: nil]]</body><body package="Store-Repository Access">update78	"This update makes sure that the indexes for TW_PkgClasses are correct, since we have modified that table's descriptor"	"Store.DbRegistry update78"		| session |	Cursor execute showWhile: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		[Store.DbRegistry goToScript ifTrue:			[session accessor logging: true.			session accessor logOnly: true.			session accessor logger: Store.DbRegistry debugger debugStream].		session system update78] ensure: 			[session accessor logging: false.			session accessor logOnly: false.			session accessor logger: nil]]</body></methods><methods><class-id>Store.DBAccess</class-id> <category>defaults</category><body package="Store-Repository Access">defaultEnvironmentString	^''</body><body package="Store-Repository Access">defaultTablePrefix	^'BERN'</body></methods><methods><class-id>Store.DBAccess</class-id> <category>debug</category><body package="Store-Repository Access">debug		^ debug == nil		ifTrue: [ debug := false]		ifFalse: [ debug].</body><body package="Store-Repository Access">debug: aBoolean		debug := aBoolean</body><body package="Store-Repository Access">debugOff		self debug: false.</body><body package="Store-Repository Access">debugOn		self debug: true.</body><body package="Store-Repository Access">log		^ log == nil		ifTrue: [ log := false]		ifFalse: [ log ].</body><body package="Store-Repository Access">log: aBoolean		log := aBoolean</body><body package="Store-Repository Access">logFile	^ logFile isNil 		ifTrue: [ logFile := (Filename named: 'StoreLog.txt') readAppendStream]		ifFalse: [ logFile]</body><body package="Store-Repository Access">logOff		self log: false.</body><body package="Store-Repository Access">logOn		self log: true.</body><body package="Store-Repository Access">printDebug: anObj	self debug		ifTrue: [ Transcript cr; show: (self printString: anObj)].	self printLog: anObj.</body><body package="Store-Repository Access">printLog: anObj	self log		ifTrue: 			[				self logFile nextPutAll: (self printString: anObj); cr.				self logFile flush.				self logFile close.			]</body><body package="Store-Repository Access">printString: anObj	| stream |	stream := ( String new: 50) writeStream.		anObj printOn: stream.	^ stream contents.</body></methods><methods><class-id>Store.DBAccess</class-id> <category>utilities</category><body package="Store-Repository Access">checkForUpdates		^true</body><body package="Store-Repository Access">connectProfileNamed: aString	| profile |	profile := RepositoryManager repositories		detect: [:each | each name = aString]		ifNone: [^self error: ((#NoSuchConnectionNamed1s &lt;&lt; #store &gt;&gt; 'No Connection Named &lt;1s&gt;') expandMacrosWith: aString)].	self connectedProfile ifNotNil: [ :connectedProfile |		( connectedProfile name = profile name) ifTrue: [			(AlreadyConnected raiseRequestWith: aString) ifFalse: [^self] ] ].	self connectTo: profile</body><body package="Store-Repository Access">withUpgradeExpression: upgradeMethod andWarningDo: twoArgumentBlockClosure	| upgradeExpression warning |	upgradeExpression := 'Please, ask your DBA to evaluate the expression:&lt;nntt&gt;Store.DbRegistry &lt;1s&gt;.' expandMacrosWith: upgradeMethod.	warning := 'You need to update your database.  &lt;1s&gt;&lt;nn&gt;This expression is also in the Transcript and will not affect the ability of older clients to access the database.&lt;n&gt;You should not attempt to perform Store database operations until the update is complete.&lt;nn&gt;Continue to connect so that the expression can be evaluated?' expandMacrosWith: upgradeExpression.	^twoArgumentBlockClosure value: upgradeExpression value: warning</body></methods><methods><class-id>Store.DBAccess</class-id> <category>private-utilities</category><body package="Store-Repository Access">connectedImageMessage	^(#SinceThisImageCannoAbleToSeeSources &lt;&lt; #store &gt;&gt; 'Since this image cannot be used without the database connection if you choose "Cancel" you will not be able to see sources.') asString</body><body package="Store-Repository Access">detachedImageMessage	^(#SinceThisImageCanBAbaseAtThisMoment &lt;&lt; #store &gt;&gt; 'Since this image can be used without the database connection you can choose "Detach" if you do not wish to be connected to the database at this moment.') asString</body><body package="Store-Repository Access">resetSystemDescriptorDictionary	storeDescriptorSystems := nil</body><body package="Store-Repository Access">userName	^(self connectedProfile) notNil		ifTrue: [ self connectedProfile userName ]		ifFalse: [ '' ].</body></methods><methods><class-id>Store.DBAccess</class-id> <category>signal constants</category><body package="Store-Repository Access">currentlyNotConnectedSignal	^self class currentlyNotConnectedSignal</body><body package="Store-Repository Access">errorSignals	^self class errorSignals</body><body package="Store-Repository Access">notConnectedSignal	^StoreNotConnectedError</body></methods><methods><class-id>Store.DBAccess</class-id> <category>connecting</category><body package="Store-Repository Access">collectOpenBrowsers	"We need protected binding references here because the classes in question come later in load order."	| browsers |	browsers := OrderedCollection new.	#{Store.Glorp.StoreRefactoringBrowser} bindingOrNil		ifNotNil: [:binding | browsers addAll: binding value allInstances].	#{Store.Glorp.DefinitionForListTool} bindingOrNil		ifNotNil: [:binding | browsers addAll: binding value allInstances].	^browsers select: [:each | each mainWindow notNil and: [each mainWindow isOpen]]</body><body package="Store-Repository Access">connectTo: aProfile	| glorpSession |	aProfile isConnectable ifFalse:		[StoreWarning			raiseSignal:				(#UnableToConnectToPresentInTheImage &lt;&lt; #store &gt;&gt; 'Unable to connect to "&lt;1s&gt;" because the database driver class&lt;n&gt;"&lt;2s&gt;" is not present in the image.'					expandMacrosWith: aProfile displayString					with: aProfile driverClassName).			^false].	self isConnected ifTrue: [self disconnect].	glorpSession := [Store.Glorp.StoreLoginFactory currentStoreSessionFromProfile: aProfile]		on: Error		do:			[:exception | 			(StoreDescriptorSystem userInputlExceptionsToIgnore includes: exception class) ifTrue: [exception pass].			StoreWarning raiseSignal:				(#UnableToConnectToLlowingErrorN2s &lt;&lt; #store &gt;&gt; 'Unable to connect to "&lt;1s&gt;" because of the following error:&lt;n&gt;&lt;2s&gt;'					expandMacrosWith: aProfile displayString					with: (exception messageText isEmpty ifTrue: [exception defaultMessageText] ifFalse: [exception messageText])).			exception return: nil].	glorpSession isNil ifTrue: [^false].	self		updateTablePrefix: aProfile tableOwner;		updateDatabaseIdentifierTo: glorpSession system databaseIdentifier.	self checkForUpdates ifFalse: [^self goOffLine].	self connectedProfileHolder value: aProfile.	recentProfile := aProfile.	self isOnline ifTrue: [self announce: StoreConnect].	self refreshBrowsers.	^self isOnline</body><body package="Store-Repository Access">createPrivateSessionForLogin: aGlorpLogin	"As #createSessionForLogin: but do not reuse the current database accessor nor reset it to derive from this login."	| accessor session |	accessor := (Glorp.DatabaseAccessor forLogin: aGlorpLogin) login.	accessor insertOnly.	session := Glorp.GlorpSession new.	session accessor: accessor.	session system: (self storeDescriptorSystemForAccessor: accessor).	session system setUpDefaults.	connection := accessor connection.	^session</body><body package="Store-Repository Access">createSessionForLogin: aGlorpLogin	| accessor session |	accessor := self currentDatabaseAccessorForLogin: aGlorpLogin.	accessor insertOnly.	session := Glorp.GlorpSession new.	session accessor: accessor.	session system: (self storeDescriptorSystemForAccessor: accessor).	session system setUpDefaults.	connection := accessor connection.	^session</body><body package="Store-Repository Access">disconnect	self handleDisconnectWithOpenBrowsers ifFalse: [^self].	self announce: StoreDisconnect.	self closeConnection.	self connectedProfileHolder value: nil.	self refreshBrowsers</body><body package="Store-Repository Access">handleDisconnectWithOpenBrowsers	"Allow user to terminate disconnect request if there are any open Store Browsers.	 If the user confirms the disconnect request, proactively terminate any open Store Browsers."	| answer openBrowsers |	(openBrowsers := self collectOpenBrowsers) isEmpty ifTrue: [^true].	(answer := Dialog				confirm: (#DisconnectingWithOpenBrowsers &lt;&lt; #store						&gt;&gt; 'There are open Store Browser windows connected to the database with content which will become obsolete.&lt;n&gt;Disconnecting will close these browser windows.  Do you want to continue?')							expandMacros				for: Dialog defaultParentWindow)			ifTrue: [openBrowsers do: [:ea | ea terminateBrowser]].	^answer</body><body package="Store-Repository Access">refreshBrowsers	| refactoryObject |	refactoryObject := #{Refactory.Browser.HierarchyPundleNavigatorPart} valueOrDo: [nil].	refactoryObject ifNotNil: [refactoryObject allGeneralInstancesDo: 		[:each | 		each builder ifNotNil: [each changeSetUpdate: #loadPundle: with: nil]]].	refactoryObject := #{Refactory.Browser.BrowserNavigator} valueOrDo: [nil].	refactoryObject ifNotNil: [refactoryObject updatePackageListsInOpenWindows]</body><body package="Store-Repository Access">restoreConnection	self isConnected ifTrue: [^self].	self closeConnectionIfNewOrPaused.	(connection isNil or: [self isConnected not])		ifTrue: 			[| profile |			profile := ConnectionDialog chooseProfileInitially: recentProfile.			[profile isNil ifTrue: [self disconnect] ifFalse: [self connectTo: profile]] 				ifCurtailed: [self disconnect]].	^self isConnected</body></methods><methods><class-id>Store.DBAccess</class-id> <category>private-accessing</category><body package="Store-Broker-Obsolete">brokerOrNil	"Use storeBroker in all cases where nil is not an acceptable response."	^connection isNil ifFalse: [connection class storeBroker]</body><body package="Store-Repository Access">currentDatabaseAccessor	^currentDatabaseAccessor</body><body package="Store-Repository Access">nilOutConnection	"self nilOutConnection"	"This method is sent when we cannot close connection, 	and we can do is to nuke them."	self resetSessions.	connection notNil 		ifTrue:			[connection nilParams.			connection := nil].</body><body package="Store-Repository Access">resetDatabaseIdentifier		self databaseIdentifier: nil.	[(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: nil] 		on: Error 		do: [:exception | ]</body><body package="Store-Repository Access">resetSessions	Store.Glorp.StorePackage initializeCache.	Store.Glorp.StoreBundle initializeCache.	cachedNames := nil.	highestPrimaryKeyChecked := nil.</body><body package="Store-Repository Access">showYouNeedToUpdateDatabaseDialog		^Dialog		warn:			(#TtYouNeedToUpdateStallFromLogWindow &lt;&lt; #store &gt;&gt;					'&lt;tt&gt;You need to update your database.&lt;n&gt;Please, ask DBA to evaluate (Do It) the expression:&lt;nt&gt;"Store.DbRegistry update5i2".&lt;n&gt;&lt;tt&gt; or if you just install database using installation script &lt;n&gt; run PostInstall from Log Window')				expandMacros</body><body package="Store-Repository Access">storeDescriptorSystems	^storeDescriptorSystems</body><body package="Store-Repository Access">updateDatabaseIdentifier: repositoryShouldHaveIdentifier	"Update the database identifier from information held in the repository. 	If repositoryShouldHaveIdentifier is false, just ignore (swallow) exceptions."		| identifierString |	self deprecated: #(#initial '5i' #obsolete '7.8' #use '#updateDatabaseIdentifierTo: aString').	[identifierString := (StoreObject databaseIdentifier) asString.	self databaseIdentifier: identifierString.	(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: identifierString]		on: Error		do:			[:exception | 			repositoryShouldHaveIdentifier ifTrue: [exception pass]]</body><body package="Store-Repository Access">updateDatabaseIdentifierTo: aString	"Update the database identifier from information held in the repository. 	If repositoryShouldHaveIdentifier is false, just ignore (swallow) exceptions."		self databaseIdentifier: aString asString.	(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: aString</body><body package="Store-Repository Access">updateTablePrefix: aString		self tablePrefix: aString.	(Store.StoreSettings preferenceModelFor: #tablePrefix) value: aString</body></methods><methods><class-id>Store.DBAccess</class-id> <category>privileged-connecting</category><body package="Store-Repository Access">closeConnection	"Close and forget the datebase connection if it exists."	"DbRegistry closeConnection"	connection notNil ifTrue: 		[self resetSessions.		[connection disconnect] 			on: Error			do: 				[:ex | 				Transcript cr; show: ex description.				ex return].		connection := nil].	currentDatabaseAccessor := nil</body><body package="Store-Repository Access">closeConnectionIfNewOrPaused	connection notNil 		ifTrue: 			[(connection state == #paused or: [connection state == #new]) 				ifTrue: [self closeConnection]]</body><body package="Store-Repository Access">connection	"Connection disconnect. Connection := nil. Session := nil"	self closeConnectionIfNewOrPaused.	connection isNil ifTrue: [self restoreConnection].	^connection</body><body package="Store-Repository Access">connection: aDbConnection		connection := aDbConnection.</body><body package="Store-Repository Access">connectionOrNil	self closeConnectionIfNewOrPaused.	connection == nil ifTrue: [self goOffLine].	^connection</body><body package="Store-Repository Access">goOffLine	"This message is used when we want to go off line."	"self goOffLine"	self disconnect.	^self isOnline</body><body package="Store-Repository Access">goOnLine	"This message is used when we want to go back on line."	"self goOnLine"	self connection</body><body package="Store-Repository Access">reconnect	"Reconnect to the same database we were connnected to."	self closeConnectionIfNewOrPaused.	[ self connectTo: recentProfile ]		ifCurtailed: [ self disconnect ].	^self isConnected.</body><body package="Store-Repository Access">reconnect: storeTablesShouldExist	self goToScript ifTrue: [^nil].	self setConnection.	connection notNil ifTrue:		[self updateDatabaseIdentifier: storeTablesShouldExist.		storeTablesShouldExist ifTrue: [self checkForUpdates]].	^self isOnline</body><body package="Store-Repository Access">setConnection	self resetSessions.	self disconnect.	connection := ConnectionDialog connection.</body></methods><methods><class-id>Store.DBAccess</class-id> <category>testing</category><body package="Store-Repository Access">isConnected	^connectedProfileHolder value notNil</body><body package="Store-Repository Access">isConnectionAlive	"Checks if at this moment we are connected to the database."	"self isConnectionAlive"	^connection notNil</body><body package="Store-Repository Access">isConnectionConnected	"Checks if at this moment we are connected to the database."	"self isConnectionAlive"	^self isConnected and: [self isConnectionAlive]</body><body package="Store-Repository Access">isConnectionFullyAvailable	^[StoreObject databaseIdentifier.	true]		on: Error		do: 			[:exception | 			exception return: false].</body><body package="Store-Repository Access">isDb73Enabled	^true</body><body package="Store-Repository Access">isOnline	^self currentDatabaseAccessor notNil	and: [self currentDatabaseAccessor connection notNil	and: [self isConnected	and: [self currentDatabaseAccessor connection isConnected]]]</body><body package="Store-Repository Access">isOnlineImage		"Answer true if we are attached to the database."	^self isOnline</body><body package="Store-Repository Access">shouldWriteLoadRecords	^self class shouldWriteLoadRecords</body><body package="Store-Repository Access">useAnalysisLoader	^self class useAnalysisLoader</body><body package="Store-Repository Access">useAnalysisLoader: aBoolean	self class useAnalysisLoader: aBoolean</body></methods><methods><class-id>Store.DBAccess</class-id> <category>announcements</category><body package="Store-Repository Access">subscriptionRegistry: anObject		subscriptionRegistry := anObject</body><body package="Store-Repository Access">subscriptionRegistryOrNil	^subscriptionRegistry</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>class initialization</category><body package="Store-Repository Access">initialize	"Need only be executed on first installation or on change in definition."	"self initialize"	DbRegistry := DbRegistry == nil		ifTrue: [ self new ]		ifFalse: [ self new cloneFrom: DbRegistry ].	"Make myself dependent on ObjectMemory so I'm	notified when the image returns from snapshot."	( ExternalDatabaseConnection dependents includes: self )		ifFalse:	[ ExternalDatabaseConnection addDependent: self ]</body><body package="Store-Repository Access">obsolete	"Remove dependancies"	ExternalDatabaseConnection removeDependent: self.	super obsolete.</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>private</category><body package="Store-Repository Access">update: anAspect with: arguments from: anObject 	anAspect == #returnFromSnapshot ifTrue: 		[DbRegistry resetSessions.		DbRegistry resetSystemDescriptorDictionary]</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>instance creation</category><body package="Store-Repository Access">new	^super new initialize</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>accessing</category><body package="Store-Repository Access">currentlyNotConnectedSignal	^LostConnectionError</body><body package="Store-Repository Access">errorSignals	^self currentlyNotConnectedSignal</body><body package="Store-Repository Access">loadingFromStore	LoadingFromStore ifNil: [#{LoadingFromStore} initialize].	^LoadingFromStore</body><body package="Store-Repository Access">loadingFromStore: aBoolean	LoadingFromStore := aBoolean</body><body package="Store-Repository Access">shouldWriteLoadRecords	ShouldWriteLoadRecords ifNil: [#{ShouldWriteLoadRecords} initialize].	^ShouldWriteLoadRecords</body><body package="Store-Repository Access">shouldWriteLoadRecords: aBoolean	ShouldWriteLoadRecords := aBoolean</body><body package="Store-Repository Access">useAnalysisLoader	UseAnalysisLoader ifNil: [#{UseAnalysisLoader} initialize].	^UseAnalysisLoader</body><body package="Store-Repository Access">useAnalysisLoader: aBoolean	UseAnalysisLoader := aBoolean</body><body package="Store-Repository Access">useAtomicLoader	UseAtomicLoader ifNil: [#{UseAtomicLoader} initialize].	^UseAtomicLoader</body><body package="Store-Repository Access">useAtomicLoader: aBoolean	UseAtomicLoader := aBoolean</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>accessing</category><body package="Store-User Management">defaultIncludeBranchBlessingCommentHistoryPolicy	^true</body><body package="Store-User Management">defaultIntegratedBlessingChangePolicy	^#change</body><body package="Store-User Management">defaultMergeToolMaxInitialTreeSize	^999</body><body package="Store-User Management">includeBranchBlessingCommentHistory	includeBranchBlessingCommentHistory isNil		ifTrue: [^self defaultIncludeBranchBlessingCommentHistoryPolicy].	^includeBranchBlessingCommentHistory</body><body package="Store-User Management">includeBranchBlessingCommentHistory: aSymbol	includeBranchBlessingCommentHistory := aSymbol</body><body package="Store-User Management">integratedBlessingChangePolicy	integratedBlessingChangePolicy isNil		ifTrue: [^self defaultIntegratedBlessingChangePolicy].	^integratedBlessingChangePolicy</body><body package="Store-User Management">integratedBlessingChangePolicy: aSymbol	integratedBlessingChangePolicy := aSymbol</body><body package="Store-User Management">integratedBlessingLevelForPackage: aPackage	^self integratedBlessingChangePolicy == #change		ifTrue: [self blessingForIntegrated]		ifFalse: [aPackage blessingLevel asNumber].</body><body package="Store-User Management">mergeToolMaxInitialTreeSize	mergeToolMinInitialTreeSize isNil		ifTrue: [^self defaultMergeToolMaxInitialTreeSize].	^mergeToolMinInitialTreeSize</body><body package="Store-User Management">mergeToolMaxInitialTreeSize: anObject	mergeToolMinInitialTreeSize := anObject</body><body package="Store-User Management">selectVersionsReadyForIntegration: aCollectionOfVersion	"Given a collection of versions select only integration ready versions."	^aCollectionOfVersion select: [:each| self isReadyForIntegration: each]</body><body package="Store-User Management">shouldPublishAll	^true</body><body package="Store-User Management">versionsReadyForIntegration: aName	| versions |	versions := Store.Glorp.StorePackage allVersionsWithName: aName.	^self selectVersionsReadyForIntegration: versions</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>blessings</category><body package="Store-User Management">blessingForIntegrated	^Policies blessingPolicy integratedBlessing</body><body package="Store-User Management">blessingForMerged	^Policies blessingPolicy mergedBlessing</body><body package="Store-User Management">blessingForReadyForIntegration	^Policies blessingPolicy integrationReadyBlessing</body><body package="Store-User Management">blessingsForReadyForIntegration	"Use the array so  this can be extended to use other blessings if desired."		^Array with: ( self blessingForReadyForIntegration )</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>testing</category><body package="Store-User Management">isReadyForIntegration: aPackageVersion	"Answer true if aPackageVersion is ready for integration."	^aPackageVersion blessingLevelNumber = self blessingForReadyForIntegration</body></methods><methods><class-id>Store.BasicOwnershipPolicy</class-id> <category>accessing</category><body package="Store-Ownership">currentUserIsOwner: aPundle	"Answer true if the current user has ownership rights over a pundle."	^true		"not looking"</body><body package="Store-Ownership">currentUserName	^DbRegistry currentUserName</body><body package="Store-Ownership">isImageAdministrator	"Returns a boolean indicating whether or not the user is the Image Administrator"	^DbRegistry isSystemAdministrator</body><body package="Store-Ownership">ownerOfPundle: aPundle	^nil.</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>private</category><body package="Store-User Management">existsVersionString: aString forPundle: aPundleModel		^aPundleModel storeForGlorpPundleClass pundleWithName: aPundleModel name hasVersion: aString</body><body package="Store-User Management">existsVersionString: aString forPundle: aPundleModel in: aSession		^aPundleModel storeForGlorpPundleClass pundleWithName: aPundleModel name hasVersion: aString in: aSession</body><body package="Store-User Management">increment: aString 	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"	| lastNonDigit incrementedVersionNumber | 	lastNonDigit := aString findLast: [ :char | char isDigit not ]. 	lastNonDigit = aString size ifTrue: [ ^aString ]. 	incrementedVersionNumber := ( aString copyFrom: lastNonDigit + 1 to: aString size ) asNumber + 1. 	^( aString copyFrom: 1 to: lastNonDigit ) 		, incrementedVersionNumber printString</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>accessing</category><body package="Store-User Management">initialVersionForPundle: aPundle   "Answer a string describing the first version of the package."	^'1.0'</body><body package="Store-User Management">nextVersion: aString forPundle: aPundle in: aSession	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit	sequence in 'aString'.  If 'aString' does not end with a digit, returns	'aString'"	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	^self increment: aString.</body><body package="Store-User Management">versionStringForPundle: aPundleModel initialVersion: initVerString 	"If a pundle with the same name and type (package/bundle) as aPundle doesn't	exist already, returns initVerString if initVerString is not nil.  Otherwise, returns 	another version string that doesn't conflict with a database entry.  Returns	nil if the user cancels the operation."	| verString |	verString := initVerString isNil 				ifTrue: [self initialVersionForPundle: aPundleModel]				ifFalse: [initVerString].		[(self existsVersionString: verString forPundle: aPundleModel) and: 			[verString := Dialog 						request: ((#Version1sOf2sAHerVersionFor3s &lt;&lt; #store &gt;&gt; 'Version &lt;1s&gt; of &lt;2s&gt; already exists.&lt;n&gt;Enter another version for &lt;3s&gt;.') 								expandMacrosWith: verString								with: aPundleModel name								with: aPundleModel name)						initialAnswer: verString						onCancel: [nil].			verString notNil]] 			whileTrue.	^verString</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>deprecated</category><body package="Store-User Management">nextVersion: aString forPundle: aPundle	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit	sequence in 'aString'.  If 'aString' does not end with a digit, returns	'aString'"	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	^self increment: aString.</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>accessing</category><body package="Store-User Management">nextVersion: aString forPundle: aPundle in: aSession	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit sequence in 'aString'. 	If this version already exists, creates a branch off the original.	 If 'aString' does not end with a digit, returns 'aString'"	| versionString |	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	versionString := self increment: aString.	(self existsVersionString: versionString forPundle: aPundle in: aSession) ifFalse: [^versionString].	versionString := aString, self initialBranchString.	(self existsVersionString: versionString forPundle: aPundle in: aSession) ifFalse: [^versionString].	versionString := aString, self nullBranchString.	^self nextVersion: versionString forPundle: aPundle in: aSession</body><body package="Store-User Management">nullBranchString	^'.0'</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>private</category><body package="Store-User Management">increment: aString	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"		| lastNonDigit incrementedVersionNumber numberPortion newVersionString |	lastNonDigit := aString findLast: [:char | char isDigit not].	lastNonDigit = aString size ifTrue: [^aString].	numberPortion := aString copyFrom: lastNonDigit + 1 to: aString size.	incrementedVersionNumber :=  numberPortion asNumber + 1.	newVersionString := incrementedVersionNumber printString.	[numberPortion size &gt; newVersionString size] whileTrue: [newVersionString := '0' , newVersionString].	^(aString copyFrom: 1 to: lastNonDigit) , newVersionString</body><body package="Store-User Management">initialBranchString	^'.1'</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>deprecated</category><body package="Store-User Management">nextVersion: aString forPundle: aPundle	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit sequence in 'aString'. 	If this version already exists, creates a branch off the original.	 If 'aString' does not end with a digit, returns 'aString'"	| versionString |	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	versionString := self increment: aString.	(self existsVersionString: versionString forPundle: aPundle) ifFalse: [^versionString].	versionString := aString, self initialBranchString.	(self existsVersionString: versionString forPundle: aPundle) ifFalse: [^versionString].	versionString := aString, self nullBranchString.	^self nextVersion: versionString forPundle: aPundle</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>accessing</category><body package="Store-User Management">downloadDirectory	^downloadDirectory</body><body package="Store-User Management">downloadDirectory: aFilename	downloadDirectory := aFilename asLogicalFileSpecification</body><body package="Store-User Management">downloadPreference	^downloadPreference</body><body package="Store-User Management">downloadPreference: symbol	downloadPreference := symbol</body><body package="Store-User Management">useDownloadDirectory	^useDownloadDirectory</body><body package="Store-User Management">useDownloadDirectory: aBoolean	useDownloadDirectory := aBoolean</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>private</category><body package="Store-User Management">downloadFile: aStoreFile 	| logicalFilename |	logicalFilename := aStoreFile filename.	self useDownloadDirectoryIfNotNil: 		[:directory | 		(logicalFilename hasSystemVariable or: [logicalFilename isAbsolute]) ifTrue: 			[logicalFilename := LogicalFilename fromComponents: (logicalFilename componentStrings allButFirst: 1)].		logicalFilename := directory construct: logicalFilename asString].	self ensureDirectoryExistsFor: logicalFilename.	aStoreFile downloadTo: logicalFilename</body><body package="Store-User Management">ensureDirectoryExistsFor: aFilename	| path current|	path := (aFilename asLogicalFileSpecification componentStrings) asOrderedCollection.	path removeLast.	path isEmpty ifTrue: [^self].	current := path removeFirst asFilename asLogicalFileSpecification.	[current definitelyExists ifFalse: [current asFilename makeDirectory].	path isEmpty] whileFalse: [current := current construct: path removeFirst]</body><body package="Store-User Management">useDownloadDirectoryIfNotNil: aBlock	self useDownloadDirectory ifFalse: [^self].	self downloadDirectory ifNotNil: [:directory | aBlock value: directory]</body><body package="Store-User Management">userSelectedFiles: fileRecords 	^SimpleDialog new 		chooseMultiple: #downloadFilesDotDotDot &lt;&lt; #store &gt;&gt; 'Download files...'		fromList: (fileRecords collect: [:n | n filename asString])		values: fileRecords		initialSelections: #()		buttons: #()		values: #()		lines: (12 min: fileRecords size) + 1		cancel: [List new]		for: Dialog defaultParentWindow</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>testing</category><body package="Store-User Management">alwaysDownload	^downloadPreference = #always</body><body package="Store-User Management">neverDownload	^downloadPreference = #never</body><body package="Store-User Management">promptForDownload	^downloadPreference = #prompt</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>initialize-release</category><body package="Store-User Management">initialize	downloadPreference := #prompt.	downloadDirectory := Filename currentDirectory asLogicalFileSpecification.	useDownloadDirectory := false</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>actions</category><body package="Store-User Management">downloadFiles: aCollection 	| filesToDownload |	self neverDownload ifTrue: [^self].	filesToDownload := self promptForDownload 		ifTrue: [self userSelectedFiles: aCollection]		ifFalse: [aCollection].	filesToDownload do: [:each | self downloadFile: each]</body><body package="Store-User Management">downloadFiles: fileRecords using: aBundleCompilationResult	| filesToDownload |	self neverDownload ifTrue: [^self].	filesToDownload := self promptForDownload		ifTrue: [self userSelectedFiles: fileRecords]		ifFalse: [fileRecords].	(DownloadingFiles for: aBundleCompilationResult pundle) started.	filesToDownload do: 		[:each |		self downloadFile: each].	(DownloadingFiles for: aBundleCompilationResult pundle) finished</body></methods><methods><class-id>Store.BasicFilePolicy class</class-id> <category>class initialization</category><body package="Store-User Management">new	^super new initialize</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>accessing preferences</category><body package="Store-UI">preferenceFor: aSubject 	^(self preferenceModelFor: aSubject) value</body><body package="Store-UI">preferenceModelFor: aSubject 	UserPreferences isNil ifTrue: [self initializeUserPreferences].	^(UserPreferences at: aSubject ifAbsent: [^nil])</body><body package="Store-UI">preferenceModelFor: aSubject put: aModel	UserPreferences isNil ifTrue: [self initializeUserPreferences].	^UserPreferences at: aSubject put: aModel</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>class initialization</category><body package="Store-UI">initialize	"self initialize "	self initializeUserPreferences.</body><body package="Store-UI">initializeUserPreferences	"The user preference profile is a Dictionary with of value models against subject keys."	"self initializeUserPreferences"	UserPreferences == nil ifTrue: [ UserPreferences := Dictionary new ].	UserPreferences		at: #databaseIdentifier  put: (self databaseIdentifier asValue);		at: #fileoutOption ifAbsentPut: [ #always asValue ];		at: #tablePrefix ifAbsentPut: [self tablePrefix asValue];		at: #newClassUseCurrent put: Policies packagePolicy newClassUseCurrent asValue;		at: #methodPlacement ifAbsentPut: [self methodPlacementInitialize asValue];		at: #datumPlacement ifAbsentPut: [self datumPlacementInitialize asValue];		at: #versionManagerView ifAbsentPut: [#listPresentation asValue];		yourself.</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>load/unload</category><body package="Store-UI">prerequisitesForLoading	"DBAcess initializes DBRegistry."	^super prerequisitesForLoading		add: DBAccess;		add: Access;		yourself</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>private</category><body package="Store-UI">databaseIdentifier	"Answer the current database indentifier, nil if none"	^ #{DbRegistry} ifDefinedDo:		[ :reg | reg databaseIdentifier ]</body><body package="Store-UI">datumPlacementInitialize	Policies packagePolicy newDatumUseCurrent		ifTrue: [Policies packagePolicy newDatumUseClass				ifTrue: [^#currentINUTCP]				ifFalse: [^#currentINAU]]		ifFalse: [Policies packagePolicy newDatumUseClass				ifTrue: [Policies packagePolicy newDatumUseClassIfNoCurrent						ifTrue: [Policies packagePolicy newDatumUseClassIfCurrentSame								ifTrue: [^#TCPICON]								ifFalse: [^#TCPIC]]						ifFalse: [^#useTCP]]				ifFalse: [^#alwaysAsk]].	^#alwaysAsk</body><body package="Store-UI">methodPlacementInitialize	Policies packagePolicy newMethodUseCurrent		ifTrue: [Policies packagePolicy newMethodUseClass				ifTrue: [^#currentINUTCP]				ifFalse: [^#currentINAU]]		ifFalse: [Policies packagePolicy newMethodUseClass				ifTrue: [Policies packagePolicy newMethodUseClassIfNoCurrent						ifTrue: [Policies packagePolicy newMethodUseClassIfCurrentSame								ifTrue: [^#TCPICON]								ifFalse: [^#TCPIC]]						ifFalse: [^#useTCP]]				ifFalse: [^#alwaysAsk]].	^#alwaysAsk</body><body package="Store-UI">tablePrefix		^DbRegistry tablePrefix</body></methods><methods><class-id>Store.DownloadingFiles</class-id> <category>accessing</category><body package="Store-User Management">actionText	^(#DowlindingFiles &lt;&lt; #store &gt;&gt; 'Downloading Files') asString</body></methods><methods><class-id>Core.RequestNilSuperClassNotification</class-id> <category>actions</category><body package="Atomic Compiling and Loading">defaultResumeValue	^Class</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>name style</category><body package="Store-Merge Management">setShowLongNames	self subclassResponsibility</body><body package="Store-Merge Management">setShowShortNames	self subclassResponsibility</body><body package="Store-Merge Management">showCompressedNamesAction	mergeTool showCompressedNamesAction</body><body package="Store-Merge Management">showLongNames	self setShowLongNames.	self updateResolutions</body><body package="Store-Merge Management">showLongNamesAction	mergeTool showLongNamesAction</body><body package="Store-Merge Management">showShortNames	self setShowShortNames.	self updateResolutions</body><body package="Store-Merge Management">showShortNamesAction	mergeTool showShortNamesAction</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>testing</category><body package="Store-Merge Management">canApplyResolution	^mergeTool canApplyResolution</body><body package="Store-Merge Management">canBrowseVersions	^mergeTool canBrowseVersions</body><body package="Store-Merge Management">canChooseDoNotResolve	^mergeTool canChooseDoNotResolve</body><body package="Store-Merge Management">canExpandHierarchy	^mergeTool canExpandHierarchy</body><body package="Store-Merge Management">canUnresolve	^mergeTool canUnresolve</body><body package="Store-Merge Management">isResolutionSelected	^mergeTool isResolutionSelected</body><body package="Store-Merge Management">isShowAll	^mergeTool isShowAll</body><body package="Store-Merge Management">isShowConflicts	^mergeTool isShowConflicts</body><body package="Store-Merge Management">isShowLongNames	^mergeTool isShowLongNames</body><body package="Store-Merge Management">isShowShortNames	^mergeTool isShowShortNames</body><body package="Store-Merge Management">isShowUnresolved	^mergeTool isShowUnresolved</body><body package="Store-Merge Management">isShowingCodeDifferences	^mergeTool isShowingCodeDifferences.</body><body package="Store-Merge Management">isShowingSourceDifferences	^mergeTool isShowingSourceDifferences.</body><body package="Store-Merge Management">methodSelected	^mergeTool methodSelected</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>menu actions</category><body package="Store-Merge Management">applyResolution	^mergeTool applyResolution</body><body package="Store-Merge Management">browseImplementors	^mergeTool browseImplementors</body><body package="Store-Merge Management">browseSenders	^mergeTool browseSenders</body><body package="Store-Merge Management">browseVersions	^mergeTool browseVersions</body><body package="Store-Merge Management">doNotResolve	mergeTool doNotResolve</body><body package="Store-Merge Management">expandHierarchy	^mergeTool expandHierarchy</body><body package="Store-Merge Management">showAll	^mergeTool showAll</body><body package="Store-Merge Management">showConflicts	^mergeTool showConflicts</body><body package="Store-Merge Management">showUnresolved	^mergeTool showUnresolved</body><body package="Store-Merge Management">toggleFullNames	^mergeTool toggleFullNames</body><body package="Store-Merge Management">unresolve	^mergeTool unresolve</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>updating</category><body package="Store-Merge Management">finishOpening</body><body package="Store-Merge Management">updateResolutions	self subclassResponsibility</body><body package="Store-Merge Management">updateResolutionsWithoutRebuild	self updateResolutions</body><body package="Store-Merge Management">updateSelection	self widget updateAt: self list selectionIndex.</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>accessing</category><body package="Store-Merge Management">mergeTool: aMergeTool	mergeTool := aMergeTool.</body><body package="Store-Merge Management">resolutionSelectionChanged	mergeTool selectedResolution: list selection</body><body package="Store-Merge Management">selectionIndex	^list selectionIndex</body><body package="Store-Merge Management">selectionIndex: anInteger	list selectionIndex: anInteger.</body><body package="Store-Merge Management">widget	^(self builder componentAt: #ModSet) widget</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>initialize-release</category><body package="Store-Merge Management">doInitialExpansion</body><body package="Store-Merge Management">release	list := nil.	builder := nil.	super release.</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>aspects</category><body package="Store-Merge Management">list	self subclassResponsibility</body><body package="Store-Merge Management">modificationMenu	^mergeTool modificationMenu</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>interface opening</category><body package="Store-Merge Management">preBuildWith: aBuilder	super preBuildWith: aBuilder.	self list selectionIndexHolder onChangeSend: #resolutionSelectionChanged to: self.</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>private</category><body package="Store-Merge Management">setListWidgetDisplayStringSelector		builder isNil ifTrue: [^self].	self widget displayStringSelector: nameStyle</body></methods><methods><class-id>Store.ResolutionsPane class</class-id> <category>instance creation</category><body package="Store-Merge Management">new	^super new initialize</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>private</category><body package="StoreForGlorpVWUI">noticeOfWindowClose: aWindow	self logout</body><body package="StoreForGlorpVWUI">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self login</body><body package="StoreForGlorpVWUI">resetWorkbook	(locals keys reject: [:each | each = #session]) do: [:each | locals removeKey: each ifAbsent: [nil]].	self logout.	self login</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>actions</category><body package="StoreForGlorpVWUI">logging: aBoolean	session accessor logging: aBoolean</body><body package="StoreForGlorpVWUI">login	"A failed initial login will simply raise an error.  By contrast, if an image is saved with an open workbook, and later reopened when that image can no longer connect to the database behind a saved workbook, it will reach this method.  Show DISCONNECTED- in the window label;  this is better for users, who don't want to see errors on reopening an image and who may wish to see scripts they'd written in the workbook."	session reset.	self privateLogin.	builder window label:		('&lt;1s&gt; &lt;2?(:(DISCONNECTED-&gt;&lt;3s&gt;)'			expandMacrosWith: self class workbookLabel			with: session isLoggedIn			with: session accessor currentLogin name).</body><body package="StoreForGlorpVWUI">logout	session accessor logout.		session reset.	builder window label: (self class workbookLabel,  ' (&lt;1s&gt; - not connected)' expandMacrosWith: session accessor currentLogin name)</body><body package="StoreForGlorpVWUI">privateLogin	#{Database.StatementCachingNotSupported} 		ifDefinedDo: 			[:errorClass |			[session accessor loginIfError: [:ex | ex return: nil]]				on: errorClass				do: [:exception | exception resume: nil]]		elseDo: [session accessor loginIfError: [:ex | ex return: nil]].</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>initialize-release</category><body package="StoreForGlorpVWUI">session: aSession	session := aSession.	self addLocal: #session value: session.</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>aspects</category><body package="StoreForGlorpVWUI">isLogging	^session accessor logging</body><body package="StoreForGlorpVWUI">loggedIn	^session accessor isLoggedIn</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook class</class-id> <category>examples</category><body package="StoreForGlorpVWUI">exampleHeader	^'"This page contains some useful examples of Glorp expressions you can use or modify"'.</body><body package="StoreForGlorpVWUI">examplesOneByOne	"Return a list of alternating comments and examples for the workspace. Do this so we can automatically emphasize the text to make them stand out."^#( '"Find all bundle versions published within the last 30 days whose name starts with G (either upper or lower case) and which were published by someone whose username starts with lowercase a"''session read: StoreBundle where: [:each |	((each name asUppercase like: ''G%'') AND: [each username like: ''a%'']) AND: [each timestamp &gt; (Date today subtractDays: 30)]].''"Find all packages in the system." ''session read: StoreVersionlessPackage.''"Find all packages for which any version has a blessing level of ''Internal Release'' or higher"''session read: StoreVersionlessPackage where: [:each |	each versions anySatisfy: [:eachVersion |		eachVersion currentBlessingLevel &gt; Store.Access defaultBlessingPolicy internalReleaseBlessing]].''"Find all the packages that define the method #yourself. Note this can be slow on a large database." ''session read: StorePackage where: [:each |	each methods anySatisfy: [:eachMethod | 		eachMethod definition name = ''yourself'']].''"Find all the packages that define the class Object. Note this can be slow on a large database." ''session read: StorePackage where: [:each |	each classDefinitions anySatisfy: [:eachClass | 		eachClass definition name = ''Object'']].''"Find all the packages that define less than 5 classes"''session read: StorePackage where: [:each |	each classDefinitions sqlCount &lt; 5].''"Find the latest version of all bundles in the system. Restrict to those where the latest version is published by user aknight. Also does this by creating a separate query object and executing it, rather than using the session convenience protocol."''| query |query := Query read: StoreBundle where: [:each |	| q |	q := Query read: StoreBundle where: [:eachBundle |		eachBundle name = each name].	q retrieve: [:x | x primaryKey max].	each username = ''aknight''  &amp; (each primaryKey = q)].query orderBy: [:each | each timestamp descending].session execute: query.''"Empty out all of our caches"''session reset.''"The expressions above are safe, because they only read from the database. Those below this point can modify the database. This is ***DANGEROUS!!!***. Inserting something incorrect can add invalid packages or other structures to your database. Deleting or updating can cause you to lose data. By default, the ability to update or delete is disabled in the Store workbook, to prevent accidental damage to the database. Any attempt to do that will cause an ''Illegal Command'' error or will fail validation in the StoreDescriptorSystem, which checks for updates and deletes, which are not normally valid Store operations. In order to allow the session to delete or update rows, evaluate the following expression."''session accessor permitEverything.''"Stop the session from deleting or updating rows. This restore the default setting in the Store workbook, to prevent accidental damage to the database"''session accessor insertOnly.''"Delete version 1.0 of the package named Foo. Note that this just deletes the package record, it won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the package disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	query := Query 		readOneOf: StorePackage 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	thePackage := session execute: query.	thePackage isNil 		ifTrue: [self error: ''No such package''] 		ifFalse: [thePackage delete].	(session execute: query) isNil ifFalse: [self error: ''Package was not deleted''].''"Delete version 1.0 of the bundle named Foo. Note that this is recursive - it will delete the bundle record, and the packages/sub-bundles that it contains, if they aren''t used as part of any other bundles. But it only deletes the bundle/package record. It won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the bundle disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	query := Query 		readOneOf: StoreBundle 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	theBundle := session execute: query.	theBundle isNil 		ifTrue: [self error: ''No such bundle'']		ifFalse: [theBundle delete].	(session execute: query) isNil ifFalse: [self error: ''Bundle was not deleted''].''"Change the name of the package Foo (all versions) to Bar. Again, you might want to think twice before doing this to a real live database with important source code in it. Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level."''	oldName := ''Foo''.	newName := ''Bar''.	versions := session read: StorePackage where: [:each | each name = oldName].	versions isEmpty ifTrue: [self error: ''No such package''].	session modify: versions in: [		versions do: [:each | each name: newName]].	newVersions := session read: StorePackage where: [:each | each name = oldName].	newVersions isEmpty ifFalse: [self error: ''Package was not properly renamed''].	newVersions := session read: StorePackage where: [:each | each name = newName].	newVersions isEmpty ifTrue: [self error: ''Package was not properly renamed''].''"Create the indexes that StoreGlorp defines into the database. Useful if you want to set up some indexes into a default Store setup database. Requires permissions, and will probably have problems if some of them already exist."''session system allTables do: [:each |			session accessor createTableIndexes: each ifError: [self halt]]. ').</body><body package="StoreForGlorpVWUI">examplesPage	^WorkspacePage		labeled: self workbookLabel		on: (WorkspacePage cautiousAdaptorOn: self examplesText asValue).</body><body package="StoreForGlorpVWUI">examplesText	| text examples |	text := TextStream on: String new.	text nextPutAllText: self exampleHeader asText allBold.	text cr; cr.	examples := self examplesOneByOne.	1 to:  examples size by: 2 do: [:i |		text nextPutAllText: (examples at: i) asText allBold.		text cr.		text nextPutAllText: (examples at: i + 1).		text cr; cr].	^text contents.</body><body package="StoreForGlorpVWUI">workbookLabel	^'Glorp Examples'.</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook class</class-id> <category>instance creation</category><body package="StoreForGlorpVWUI">openOnSession: aSession	"We obtain both our login and our descriptor system from the (un-logged-in) session parameter."	^(self on: self examplesText asValue labeled: self workbookLabel)		session: aSession;		open</body><body package="StoreForGlorpVWUI">openRequestingDatabase	"For subclasses that use a specific DescriptorSystem subclass."	^self subclassResponsibility</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook class</class-id> <category>private</category><body package="StoreForGlorpVWUI">cleanUpObsoleteInstances	"Once a repository connection is closed, any open instances are not revivable, even if the repository is connected again."	self allGeneralInstances do: [:each | each resetWorkbook]</body></methods><methods><class-id>Store.UninstallingDatabaseTables</class-id> <category>accessing</category><body package="Store-Base">actionText	^(#UninstallingDatabaseTables &lt;&lt; #store &gt;&gt; 'Uninstalling Database Tables') asString</body><body package="Store-Base">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>descriptors</category><body package="Store-Database Model">addPackageMappingTo: aDescriptor 	"For any of the Store&lt;X&gt;InPackage classes, add the mapping to the containing package"	| |	(aDescriptor newMapping: OneToOneMapping)				attributeName: #package;				join: (Join 							from: (aDescriptor table fieldNamed: 'packageRef')							to: ((self tableNamed: 'TW_Package') fieldNamed: 'primaryKey')).	^aDescriptor</body><body package="Store-Database Model">addPropertiesMappingTo: aDescriptor	"Add the properties mapping. Different between versions of Store schema"	(aDescriptor newMapping: OneToOneMapping)		attributeName: #propertiesBlob;		join: (Join 			from: (aDescriptor table fieldNamed: 'propertiesID') 			to: self blobId).	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #propertiesBlobID 		to: (aDescriptor table fieldNamed: 'propertiesID').</body><body package="Store-Database Model">addStandardStoreDescriptorTo: aDescriptor forTable: table andClass: aClass	"I hate typing 'primaryKey' so often, so allow 'id' as a synonym"	(aDescriptor newMapping: DirectMapping) 		from: #primaryKey		to: (table fieldNamed: 'primaryKey').	(aDescriptor directMapping from: #id to: 'primaryKey') beForPseudoVariable.	(aDescriptor newMapping: DirectMapping) 		from: #name		to: (table fieldNamed: 'name').	self addTimestampTo: aDescriptor fromTable: table.	self addUsernameTo: aDescriptor fromTable: table.	self		addTraceMappingNamed: #trace		in: aDescriptor		forTable: table		andClass: aClass.	(self		addTraceMappingNamed: #previous		in: aDescriptor		forTable: table		andClass: aClass) beForPseudoVariable.	(self		addTraceMappingNamed: #parent		in: aDescriptor		forTable: table		andClass: aClass) beForPseudoVariable</body><body package="Store-Database Model">addTraceMappingNamed: aSymbol in: aDescriptor forTable: table andClass: aClass	"We want this under a couple of aliases, so extract it to a method."	| traceMapping |	traceMapping := (aDescriptor newMapping: OneToOneMapping)				attributeName: aSymbol;				referenceClass: aClass;				join: (Join from: (table fieldNamed: 'trace')							to: (table fieldNamed: 'primaryKey'));				shouldProxy: true.	"Add something to let us query on whether or not there's a trace"	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: (aSymbol, 'ID') asSymbol to: (table fieldNamed: 'trace').	^traceMapping.</body><body package="Store-Database Model">descriptorForStoreAccessPrivilege: aDescriptor 	| table |	table := self tableNamed: 'TW_DBPundlePrivileges'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #pundleName				to: (table fieldNamed: 'pundleName')).	aDescriptor  addMapping: (DirectMapping from: #pundleType				to: (table fieldNamed: 'pundleType')).	aDescriptor  addMapping: (DirectMapping from: #userName				to: (table fieldNamed: 'userName')).	aDescriptor  addMapping: (DirectMapping from: #userType				to: (table fieldNamed: 'userType')).	aDescriptor  addMapping: (DirectMapping from: #privilege				to: (table fieldNamed: 'privilege')).	(aDescriptor newMapping: ConstantMapping) attributeName: #session; constantValueIsSession.	^aDescriptor</body><body package="Store-Database Model">descriptorForStoreBinaryBlob: aDescriptor 	^self descriptorForStoreBlob: aDescriptor class: StoreBinaryBlob inTable: 'TW_BinaryBlob'.</body><body package="Store-Database Model">descriptorForStoreBlessing: aDescriptor 	| table commentMapping |	table := self tableNamed: 'TW_Blessing'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #primaryKey to: (table fieldNamed: 'primaryKey').	self addTimestampTo: aDescriptor fromTable: table.	self addUsernameTo: aDescriptor fromTable: table.	commentMapping := (aDescriptor newMapping: OneToOneMapping)				attributeName: #comment;				join: (Join 							from: (table fieldNamed: 'commentID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey')).	commentMapping query expectedRows: self commonMaximumBlobRows.	(aDescriptor newMapping: DirectMapping) from: #blessingLevel to: (table fieldNamed: 'blessingLevel').	(aDescriptor newMapping: OneToOneMapping)				attributeName: #trace;				join: (Join from: (table fieldNamed: 'trace')							to: (table fieldNamed: 'primaryKey'));				shouldProxy: true.	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #pundleID 		to: (table fieldNamed: 'pkgID').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #recordType		to: (table fieldNamed: 'recType').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #commentID 		to: (table fieldNamed: 'commentID').</body><body package="Store-Database Model">descriptorForStoreBlob: aDescriptor 	^self descriptorForStoreBlob: aDescriptor class: StoreBlob inTable: 'TW_Blob'.</body><body package="Store-Database Model">descriptorForStoreBlob: aDescriptor class: aClass inTable: aTableName	| table field conditional pkField |	table := self tableNamed: aTableName.	aDescriptor table: table.	field := table fieldNamed: 'blobType'.	conditional := aDescriptor newMapping: ConditionalMapping.	conditional 		forField: field		attribute: [:object | object validTypeField]		if: #valueIsNil: useMapping: ConstantMapping new.	conditional otherwise: (DirectMapping from: #type to: field).	pkField := table fieldNamed: 'primaryKey'.	(aDescriptor newMapping: DirectMapping) from: #primaryKey to: pkField.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #next		fromDb:			[:row :elementBuilder :context || id |			id := elementBuilder valueOfField: (context translateField: field) in: row.			id := id isNil ifTrue: [-1] ifFalse: [id negated].			id &gt; 0 ifTrue:	"we omit ifFalse: [nil] since ifTrue: returns nil when receiver false"				[self canRecurse					ifFalse: [Proxy readOneOf: aClass where: [:each | each primaryKey = id] in: aDescriptor session]					ifTrue: [self							recursiveSuccessorBlobChainOfBlob: elementBuilder instance							id: (elementBuilder valueOfField: (context translateField: pkField) in: row)							class: aClass inTable: aTableName]]]		toDb:			[:rows :nextBlob :nextBlobRows |			self blobToDatabaseForRows: rows nextBlob: nextBlob nextBlobRows: nextBlobRows]		mappingFields: (Array with: field).	(aDescriptor newMapping: DirectMapping) from: #data to: (table fieldNamed: 'blobData').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #blobTypeOrNextKey 		to: (table fieldNamed: 'blobType').</body><body package="Store-Database Model">descriptorForStoreBundle: aDescriptor	| table linkTable |	table := self tableNamed: 'TW_Bundle'.	linkTable := self tableNamed: 'TW_Bundles'.	self descriptorForStorePundle: aDescriptor class: StoreBundle inTable: table.	(aDescriptor newMapping: ToManyMapping)		attributeName: #blessings;		collectionType: SortedCollection;			join:			(Join					from: (table fieldNamed: 'primaryKey')					to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'pkgID')					from: 'B'					to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'recType')).	(aDescriptor newMapping: BasicDictionaryMapping)			attributeName: #bundles;			referenceClass: StoreBundle;			orderBy: [:each | (each getTable: 'TW_Bundles') getField: 'seqNumber'];			keyField: (linkTable fieldNamed: 'seqNumber');			join:					(Join							from: (table fieldNamed: 'primaryKey')							to: (linkTable fieldNamed: 'bundleRef'));			relevantLinkTableFields:					(Array with: (linkTable fieldNamed: 'subBundleRef')).	(aDescriptor newMapping: BasicDictionaryMapping)			attributeName: #packages;			referenceClass: StorePackage;			orderBy: [:each | (each getTable: 'TW_Packages') getField: 'seqNumber'];			keyField: ((self tableNamed: 'TW_Packages') fieldNamed: 'seqNumber');			join:				(Join					from: (table fieldNamed: 'primaryKey')					to: ((self tableNamed: 'TW_Packages') fieldNamed: 'bundleRef'));			relevantLinkTableFields:					(Array with: ((self tableNamed: 'TW_Packages') fieldNamed: 'packageRef')).</body><body package="Store-Database Model">descriptorForStoreBundleInBundle: aDescriptor	| table bundleMapping subbundleMapping |	table := self tableNamed: 'TW_Bundles'.	aDescriptor table: table.	(aDescriptor directMapping from: #bundleRef to: 'bundleRef') beForPseudoVariable.	aDescriptor directMapping from: #sequence to: 'seqNumber'.	(aDescriptor directMapping from: #subbundleRef to: 'subbundleRef') beForPseudoVariable.	bundleMapping := (aDescriptor newMapping: OneToOneMapping)		attributeName: #containingBundle;		join: (Join from: (table fieldNamed: 'bundleRef') to: self bundleId).	subbundleMapping := (aDescriptor newMapping: OneToOneMapping) 		attributeName: #subbundle;		join: (Join from: (table fieldNamed: 'subbundleRef') to: self bundleId).</body><body package="Store-Database Model">descriptorForStoreBundlePackageRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Packages'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #bundleID				to: (table fieldNamed: 'bundleRef')).	aDescriptor  addMapping: (DirectMapping from: #packageID				to: (table fieldNamed: 'packageRef')).	aDescriptor  addMapping: (DirectMapping from: #sequence				to: (table fieldNamed: 'seqNumber')).	aDescriptor  addMapping: (DirectMapping from: #expressionID				to: (table fieldNamed: 'expressionID')).</body><body package="Store-Database Model">descriptorForStoreBundleSubBundleRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Bundles'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #bundleID				to: (table fieldNamed: 'bundleRef')).	aDescriptor  addMapping: (DirectMapping from: #subbundleID				to: (table fieldNamed: 'subbundleRef')).	aDescriptor  addMapping: (DirectMapping from: #sequence				to: (table fieldNamed: 'seqNumber')).	aDescriptor  addMapping: (DirectMapping from: #expressionID				to: (table fieldNamed: 'expressionID')).</body><body package="Store-Database Model">descriptorForStoreClassDefinition: aDescriptor	| table commentMapping definitionMapping |	table := self tableNamed: 'TW_ClassRecord'.	aDescriptor table: table.	self		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: aDescriptor describedClass.	aDescriptor		addMapping:			(DirectMapping				from: #environmentName				to: (table fieldNamed: 'environmentString')).	aDescriptor		addMapping:			(DirectMapping from: #superclassName to: (table fieldNamed: 'superclass')).	aDescriptor		addMapping:			(definitionMapping := (OneToOneMapping new)				attributeName: #definition;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'definitionID') to: self blobId)).	definitionMapping query expectedRows: self commonMaximumBlobRows.	aDescriptor		addMapping:			(commentMapping := (OneToOneMapping new)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'commentID') to: self blobId)).	commentMapping query expectedRows: self commonMaximumBlobRows.	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #commentID 		to: (table fieldNamed: 'commentID').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #definitionID 		to: (table fieldNamed: 'definitionID').</body><body package="Store-Database Model">descriptorForStoreClassDefinitionInPackage: aDescriptor	| table orderMapping |	table := self tableNamed: 'TW_PkgClasses'.	aDescriptor table: table.	(aDescriptor newMapping: OneToOneMapping) attributeName: #package.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #definition;		join: (Join from: (table fieldNamed: 'classRef') to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey')).	orderMapping := aDescriptor newMapping: DirectMapping. 	orderMapping from: #definitionOrder to: (table fieldNamed: 'definitionOrder').	orderMapping beForPseudoVariable.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #metaclass;		join: (Join from:  (table fieldNamed: 'metaclassRef') to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey')).	(aDescriptor directMapping from: #packageRef to: 'packageRef') beForPseudoVariable.	(aDescriptor directMapping from: #classRef to: 'classRef') beForPseudoVariable.	(aDescriptor directMapping from: #metaclassRef to: 'metaclassRef') beForPseudoVariable.</body><body package="Store-Database Model">descriptorForStoreClassExtension: aDescriptor 	| table defLinkTable defTable methodTable methodLinkTable fullClassName sharedTable sharedLinkTable |	table := self tableNamed: 'IMAGINARY_CLASS_EXTENSION'.	aDescriptor table: table."	(aDescriptor newMapping: DirectMapping) from: #shortName to: (table fieldNamed: 'SHORTNAME').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'SHORTNAME')."	(aDescriptor newMapping: DirectMapping) from: #longName to: (table fieldNamed: 'LONGNAME').			(aDescriptor newMapping: OneToOneMapping)			attributeName: #package;			referenceClass: StorePackage.		defLinkTable := self tableNamed: 'TW_PkgClasses'.	defTable := self tableNamed: 'TW_ClassRecord'.	fullClassName := [:each |  | envString name |		envString := (each getTable: defTable) getField: (defTable fieldNamed: 'environmentString').		name := (each getTable: defTable) getField: (defTable fieldNamed: 'name').		(envString , '.'),  name] asGlorpExpression.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #classDefinition;			referenceClass: StoreClassDefinition;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (defLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: fullClassName);			relevantLinkTableFields: (Array with: (defLinkTable fieldNamed: 'classRef')).	methodTable := self tableNamed: 'TW_Method'.	methodLinkTable := self tableNamed: 'TW_Methods'.	(aDescriptor newMapping: ToManyMapping)			attributeName: #instanceMethods;			referenceClass: StoreMethod;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (methodLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: (methodTable fieldNamed: 'className')				from: 'F' 				to: (methodTable fieldNamed: 'metaString')).	(aDescriptor newMapping: ToManyMapping)			attributeName: #classMethods;			referenceClass: StoreMethod;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (methodLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: (methodTable fieldNamed: 'className')				from: 'T' 				to: (methodTable fieldNamed: 'metaString')).	sharedTable := self tableNamed: 'TW_DataElement'.	sharedLinkTable := self tableNamed: 'TW_Data'.	(aDescriptor newMapping: ToManyMapping)			attributeName: #sharedVariables;			referenceClass: StoreSharedVariable;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (sharedLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: (sharedTable fieldNamed: 'environmentString')).	"A complicated way of saying that the package plus one other attribute has to be there"	aDescriptor imaginaryTableIsDefinedByRelationFrom: #package to: #classDefinition.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #package to: #instanceMethods.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #package to: #classMethods.	aDescriptor buildReplacementTableSelect.</body><body package="Store-Database Model">descriptorForStoreDatabaseIdentifier: aDescriptor 	| table |	table := self tableNamed: 'TW_DatabaseIdentifier'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'identityName').</body><body package="Store-Database Model">descriptorForStoreMethod: aDescriptor	"Mapping to version was missing and has been added. N.B. this version is the method type e.g. CType and has nothing to do with Store's CM versioning.  Type is needed to load ExternalInterface methods in right order - see fromDescription:trace:package:"	| table metaclassField sourceMapping |	table := self tableNamed: 'TW_Method'.	aDescriptor table: table.	self 		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreMethod.	sourceMapping := (aDescriptor newMapping: OneToOneMapping)				attributeName: #source;				join: (Join 							from: (table fieldNamed: 'sourceCodeID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey')).	self recursifySourceMappingIn: aDescriptor.	sourceMapping query expectedRows: self commonMaximumBlobRows.	(aDescriptor newMapping: DirectMapping) from: #className				to: (table fieldNamed: 'className').	metaclassField := table fieldNamed: 'metaString'.	(aDescriptor newMapping: AdHocMapping) 				forAttribute: #isMetaclass				fromDb: [:row :elementBuilder :context| (elementBuilder valueOfField: (context translateField: metaclassField) in: row) includes: $T]				toDb: 					[:rows :attribute :attributeRows | 					(rows at: table) at: metaclassField 						put: (attribute ifTrue: ['T'] ifFalse: ['F'])]				mappingFields: (Array with: metaclassField).	(aDescriptor newMapping: DirectMapping)		 from: #protocol		to: (table fieldNamed: 'protocolName').	(aDescriptor newMapping: DirectMapping)		 from: #version		to: (table fieldNamed: 'version').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #definitionID	"this seems a poor name for it - the definition is one thing, the source another;  rename?"		to: (table fieldNamed: 'sourcecodeID').</body><body package="Store-Database Model">descriptorForStoreMethodInPackage: aDescriptor	| table |	table := self tableNamed: 'TW_Methods'.	aDescriptor table: table.	(aDescriptor directMapping from: #methodRef to: 'methodRef') beForPseudoVariable.	(aDescriptor directMapping from: #packageRef to: 'packageRef') beForPseudoVariable.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #package.	(aDescriptor newMapping: OneToOneMapping) attributeName: #definition.</body><body package="Store-Database Model">descriptorForStoreNameSpace: aDescriptor	| table commentMapping definitionMapping |	table := self tableNamed: 'TW_NameSpaceRecord'.	aDescriptor table: table.	self		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreNameSpace.	aDescriptor		addMapping:			(DirectMapping				from: #environmentName				to: (table fieldNamed: 'environmentString')).	aDescriptor		addMapping:			(definitionMapping := (OneToOneMapping new)				attributeName: #definition;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'definitionID') to: self blobId)).	definitionMapping query expectedRows: self commonMaximumBlobRows.	aDescriptor		addMapping:			(commentMapping := (OneToOneMapping new)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'commentID') to: self blobId)).	commentMapping query expectedRows: self commonMaximumBlobRows.	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #definitionID 		to: (table fieldNamed: 'definitionID').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #commentID 		to: (table fieldNamed: 'commentID').</body><body package="Store-Database Model">descriptorForStoreNamespaceInPackage: aDescriptor	| table orderMapping |	table := self tableNamed: 'TW_PkgNameSpaces'.	aDescriptor table: table.	(aDescriptor directMapping from: #packageRef to: 'packageref') beForPseudoVariable.	(aDescriptor directMapping from: #namespaceRef to: 'namespaceref') beForPseudoVariable.	orderMapping := aDescriptor newMapping: DirectMapping. 	orderMapping from: #definitionOrder to: (table fieldNamed: 'definitionOrder').	orderMapping beForPseudoVariable.	(aDescriptor newMapping: OneToOneMapping) attributeName: #package.	(aDescriptor newMapping: OneToOneMapping) attributeName: #definition.	^aDescriptor.</body><body package="Store-Database Model">descriptorForStorePackage: aDescriptor	"For a while now, we construct 'StoreClassExtension' objects on the fly when needed, and not in the descriptor"	| table methodMapping classDefinitionsMapping blessingMapping sharedVariableMapping nameSpaceMapping |	table := self tableNamed: 'TW_Package'.	self descriptorForStorePundle: aDescriptor class: StorePackage inTable: table.	nameSpaceMapping := aDescriptor newMapping: ToManyMapping.	nameSpaceMapping		attributeName: #nameSpaces;		referenceClass: StoreNamespaceInPackage;		orderBy: #definitionOrder;		writeTheOrderField;		beExclusive.	nameSpaceMapping query alsoFetch: [:each | each definition].	nameSpaceMapping query alsoFetch: [:each | each definition definition].	classDefinitionsMapping := aDescriptor newMapping: ToManyMapping.	classDefinitionsMapping		attributeName: #classDefinitions;		referenceClass: StoreClassDefinitionInPackage;		orderBy: [:each | each definitionOrder];		writeTheOrderField;		beExclusive.	classDefinitionsMapping query alsoFetch: [:each | each definition].	classDefinitionsMapping query alsoFetch: [:each | each definition definition].	classDefinitionsMapping query alsoFetch: [:each | each definition comment beOuterJoin].	classDefinitionsMapping query alsoFetch: [:each | each metaclass].	classDefinitionsMapping query alsoFetch: [:each | each metaclass definition].	classDefinitionsMapping query alsoFetch: [:each | each metaclass comment beOuterJoin].	sharedVariableMapping := (aDescriptor newMapping: ToManyMapping)		shouldProxy: true;		attributeName: #sharedVariables;		referenceClass: StoreSharedVariableInPackage;		beExclusive.	sharedVariableMapping query alsoFetch: [:each | each definition].	sharedVariableMapping query alsoFetch: [:each | each definition definition].	sharedVariableMapping query alsoFetch: [:each | each definition comment beOuterJoin].	methodMapping := aDescriptor toManyMapping		attributeName: #methods;		referenceClass: StoreMethodInPackage;		beExclusive.	methodMapping query alsoFetch: [:each | each definition].	methodMapping query alsoFetch: [:each | each definition source].	"Order matters here:  call the next line after the one above and before the two below it."	self alsoFetchDefinitionSourceRecursivelyInMapping: methodMapping.	methodMapping query expectedRows: 1000.	methodMapping collectionType: GlorpVirtualCollection.	blessingMapping := aDescriptor newMapping: ToManyMapping.	blessingMapping		attributeName: #blessings;		collectionType: SortedCollection;		join: (Join				from: (table fieldNamed: 'primaryKey')				to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'pkgID')				from: 'P'				to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'recType')).	blessingMapping query alsoFetch: [:each | each comment beOuterJoin].	(aDescriptor newMapping: DirectMapping) 		from: #binFile 		to: (table fieldNamed: 'binFile').	(aDescriptor newMapping: OneToOneMapping)		attributeName: #parcel;		join: (Join 			from: (table fieldNamed: 'parcelID') 			to: ((self tableNamed: 'TW_ParcelRecord') fieldNamed: 'primaryKey')).	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #parcelID 		to: (table fieldNamed: 'parcelID').</body><body package="Store-Database Model">descriptorForStorePackageInBundle: aDescriptor	| table bundleMapping subbundleMapping |	table := self tableNamed: 'TW_Packages'.	aDescriptor table: table.	(aDescriptor directMapping from: #bundleRef to: 'bundleRef') beForPseudoVariable.	(aDescriptor directMapping from: #packageRef to: 'packageRef') beForPseudoVariable.	aDescriptor directMapping from: #sequence to: 'seqNumber'.	bundleMapping := (aDescriptor newMapping: OneToOneMapping)		attributeName: #containingBundle;		join: (Join from: (table fieldNamed: 'bundleRef') to: self bundleId).	subbundleMapping := (aDescriptor newMapping: OneToOneMapping) 		attributeName: #package;		join: (Join from: (table fieldNamed: 'packageRef') to: self packageId).</body><body package="Store-Database Model">descriptorForStoreParcelRecord: aDescriptor 	| table |	table := self tableNamed: 'TW_ParcelRecord'.	aDescriptor table: table.	self 		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreParcelRecord.	(aDescriptor newMapping: DirectMapping) from: #filename to: (table fieldNamed: 'filename').	(aDescriptor newMapping: DirectMapping) from: #version to: (table fieldNamed: 'version').	(aDescriptor newMapping: OneToOneMapping)		attributeName: #blob;		referenceClass: StoreBinaryBlob;		join: (Join 			from: (table fieldNamed: 'blobID')			to: ((self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey')).	(aDescriptor newMapping: OneToOneMapping)		attributeName: #source;		referenceClass: StoreBinaryBlob;		join: (Join 			from: (table fieldNamed: 'sourceID')			to: ((self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey')).	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #blobID 		to: (table fieldNamed: 'blobID').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #sourceID 		to: (table fieldNamed: 'sourceID').</body><body package="Store-Database Model">descriptorForStorePundle: aDescriptor class: aClass inTable: table	"We can't do the inheritance thing, because it will make us use the same cache, and these share primary keys."	| commentMapping |	aDescriptor table: table.	self		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: aClass.	(aDescriptor newMapping: DirectMapping)		from: #version to: (table fieldNamed: 'version').	(aDescriptor newMapping: DirectMapping)				from: #currentBlessingLevel				to: (table fieldNamed: 'blessingLevel').	commentMapping := (aDescriptor newMapping: OneToOneMapping)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'commentID') to: self blobId).	commentMapping query expectedRows: self commonMaximumBlobRows.	self addPropertiesMappingTo: aDescriptor.	(aDescriptor newMapping: ConstantMapping) attributeName: #session; constantValueIsSession.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #versionless;		readOnly: true;		join: (Join from: (table fieldNamed: 'name') to: (table fieldNamed: 'name')).	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #commentID 		to: (table fieldNamed: 'commentID').</body><body package="Store-Database Model">descriptorForStoreSharedVariable: aDescriptor 	| table typeField commentMapping definitionMapping |	table := self tableNamed: 'TW_DataElement'.	aDescriptor table: table.	self 		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreSharedVariable.	aDescriptor addMapping: (DirectMapping from: #environmentName				to: (table fieldNamed: 'environmentString')).	aDescriptor addMapping: (DirectMapping from: #protocol				to: (table fieldNamed: 'protocolName')).	typeField := table fieldNamed: 'typeString'.	aDescriptor addMapping: (AdHocMapping 				forAttribute: #isClassVariable				fromDb: [:row :elementBuilder :context | (elementBuilder valueOfField: (context translateField: typeField) in: row) includes: $C]				toDb: 					[:rows :attribute :attributeRows | 					(rows at: table) at: typeField						put: (attribute ifTrue: ['C'] ifFalse: ['N'])]				mappingFields: (Array with: typeField)).	aDescriptor addMapping: (definitionMapping := (OneToOneMapping new)				attributeName: #definition;				referenceClass: StoreBlob;				join: (Join 							from: (table fieldNamed: 'definitionID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey'))).	definitionMapping query expectedRows: self commonMaximumBlobRows.	aDescriptor addMapping: (commentMapping := (OneToOneMapping new)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join 							from: (table fieldNamed: 'commentID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey'))).	commentMapping query expectedRows: self commonMaximumBlobRows.	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #definitionID 		to: (table fieldNamed: 'definitionID').	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #commentID 		to: (table fieldNamed: 'commentID').</body><body package="Store-Database Model">descriptorForStoreSharedVariableInPackage: aDescriptor	| table |	table := self tableNamed: 'TW_Data'.	aDescriptor table: table.	(aDescriptor directMapping from: #packageRef to: 'packageRef') beForPseudoVariable.	(aDescriptor directMapping from: #dataRef to: 'dataRef') beForPseudoVariable.	(aDescriptor newMapping: OneToOneMapping) attributeName: #package.	(aDescriptor newMapping: OneToOneMapping) attributeName: #definition.	^aDescriptor.</body><body package="Store-Database Model">descriptorForStoreUserGroup: aDescriptor 	| table |	table := self tableNamed: 'TW_DBUserGroup'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #groupName				to: (table fieldNamed: 'groupName')).	aDescriptor  addMapping: (DirectMapping from: #userName				to: (table fieldNamed: 'userName')).	aDescriptor  addMapping: (DirectMapping from: #type				to: (table fieldNamed: 'type')).	(aDescriptor newMapping: ConstantMapping) attributeName: #session; constantValueIsSession.	^aDescriptor</body><body package="Store-Database Model">descriptorForStoreVersionlessBundle: aDescriptor	| table |	table := self tableNamed: 'TW_Bundle'.	self descriptorForStoreVersionlessPundle: aDescriptor class: StoreVersionlessBundle table: table</body><body package="Store-Database Model">descriptorForStoreVersionlessPackage: aDescriptor	| table |	table := self tableNamed: 'TW_Package'.	self descriptorForStoreVersionlessPundle: aDescriptor class: StoreVersionlessPackage table: table</body><body package="Store-Database Model">descriptorForStoreVersionlessPundle: aDescriptor class: aClass table: table	| nameMapping field nameExpression versionMapping commentMapping |	aDescriptor table: table.	field := table fieldNamed: 'name'.	nameExpression := [:each | ((each getTable: table) getField: field) distinct] asGlorpExpression.	nameMapping := DirectMapping from: #name to: nameExpression.	nameMapping readOnly: true.	aDescriptor addMapping: nameMapping.	aDescriptor keyFields: (Array with: nameExpression).	versionMapping := OneToManyMapping new		attributeName: #versions;		referenceClass: aClass pundleClass;		orderBy: [:each | each timestamp descending];		join: (Join 				from: nameExpression				to: field).	versionMapping readOnly: true.	versionMapping controlsTables: false.	aDescriptor addMapping: versionMapping."	timestampField := table fieldNamed: self timestampFieldName.""	maximumTimestampExpression := [:each | ((each getTable: table) getField: timestampField) max] asGlorpExpression."	"I'd really rather have these as a 1-1 to the most recent version, but that requires a group by that I'm not sure how to manage"	commentMapping := (aDescriptor newMapping: ToManyMapping)		attributeName: #comment;		referenceClass: StoreBlob;		useLinkTable;		orderBy: [:each | ((each getTable: table) getField: self timestampFieldName) descending];		readOnly: true;		join: (Join			from: nameExpression			to: field);		relevantLinkTableFields: (Array with: (table fieldNamed: 'commentID')).	commentMapping query limit: 1."	propertyMapping := (aDescriptor newMapping: ToManyMapping)		attributeName: #properties;		referenceClass: StoreBlob;		useLinkTable;		readOnly: true;		orderBy: [:each | ((each getTable: table) getField: self timestampFieldName) descending];		join: (Join			from: nameExpression			to: field);		relevantLinkTableFields: (Array with: (table fieldNamed: 'propertiesID')).	propertyMapping query limit: 1."</body><body package="Store-Database Model">typeResolverForStorePundle	| resolver |	resolver := HorizontalTypeResolver forRootClass: StorePundle.	resolver useSingleQuery: true.	^resolver.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>tables</category><body package="Store-Database Model">allTableNames	^#('TW_Package' 'TW_Method' 'TW_Methods' 'TW_ClassRecord' 'TW_PkgClasses' 'TW_DataElement' 'TW_Data' 'TW_NameSpaceRecord' 'TW_PkgNameSpaces' 'TW_Bundle' 'TW_Bundles' 'TW_Packages' 'TW_Blob' 'TW_Blessing' 'TW_BinaryBlob' 'TW_ParcelRecord' 'TW_DatabaseIdentifier' 'TW_DBUserGroup' 'TW_DBPundlePrivileges')</body><body package="Store-Database Model">createStandardAndVersionRecordFieldsIn: aTable	| nameField timeStampField field |	(aTable 		createFieldNamed: 'primaryKey' 		type: (self sequenceFor: aTable)) bePrimaryKey.	(nameField := aTable 		createFieldNamed: 'name' 		type: (platform varChar: 255)) beIndexed.	nameField beNullable: false.	(timeStampField := aTable 		createFieldNamed: self timestampFieldName		type: platform int4) beIndexed.	timeStampField beNullable: false.	field := aTable 		createFieldNamed: 'version' 		type: (platform varChar: 255).	field 		beIndexed;		beNullable: false.	aTable 		createFieldNamed: 'userName' 		type: (platform varChar: 255).	((aTable 		createFieldNamed: 'trace' 		type: platform int4) defaultValue: 0) beIndexed</body><body package="Store-Database Model">createStandardRecordFieldsIn: aTable	| nameField timeStampField traceField |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable))		bePrimaryKey.	(nameField := aTable createFieldNamed: 'name' type: (platform varChar: 255)) beIndexed.	nameField beNullable: false.	(timeStampField := aTable createFieldNamed: self timestampFieldName type: platform int4) beIndexed.	timeStampField beNullable: false.	aTable createFieldNamed: 'userName' type: (platform varChar: 255).	(traceField := (aTable createFieldNamed: 'trace' type: platform int4) defaultValue: 0) beIndexed.	traceField beNullable: false.</body><body package="Store-Database Model">createVersionedRecordFieldsIn: aTable	| field |	field := aTable createFieldNamed: 'version' type: (platform varChar: 255).	field beIndexed.	field beNullable: false.	self createStandardRecordFieldsIn: aTable.</body><body package="Store-Database Model">tableForIMAGINARY_CLASS_EXTENSION: aTable 	| pkgId |	aTable isImaginary: true.	(aTable createFieldNamed: 'LONGNAME' type: (platform varChar: 255)) bePrimaryKey.	pkgId := aTable createFieldNamed: 'packageID' type: platform int4.	aTable addForeignKeyFrom: pkgId		to: ((self tableNamed: 'TW_Package') fieldNamed: 'primaryKey').</body><body package="Store-Database Model">tableForTW_BINARYBLOB: aTable 	| typeField fKey |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable)) 		bePrimaryKey.	typeField := aTable createFieldNamed: 'blobType' type: platform int4.	typeField beNullable: false.	fKey := aTable addForeignKeyFrom: typeField to: self binaryBlobId.	fKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'blobData' type: platform binary32k.	aTable propertyAt: #tableSpaceName put: StoreBinaryBlob tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBinaryBlob tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_BLESSING: aTable 	| commentId packageId foreignKey |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable)) 		bePrimaryKey.	(aTable createFieldNamed: self timestampFieldName type: platform int4) beIndexed.	aTable createFieldNamed: 'userName' type: (platform varChar: 255).	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId		to: self blobId.	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'blessingLevel' type: platform int4.	((aTable createFieldNamed: 'trace' type: platform int4) defaultValue: 0) beIndexed.		packageId := aTable createFieldNamed: 'pkgID' type: platform int4.	"This is an internal foreign key, and thus is always supported"	aTable createFieldNamed: 'recType' type: (platform varChar: 255).	aTable addIndexForField: packageId.	aTable propertyAt: #tableSpaceName put: StoreBlessing tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBlessing tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_BLOB: aTable 	| typeField fKey |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable)) 		bePrimaryKey.	typeField := aTable createFieldNamed: 'blobType' type: platform int4.	typeField beNullable: false.	fKey := aTable addForeignKeyFrom: typeField to: self blobId.	fKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'blobData' type: platform binary32k.	aTable propertyAt: #tableSpaceName put: StoreBlob tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBlob tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_BUNDLE: aTable	| commentId propId foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	aTable createFieldNamed: 'blessingLevel' type: platform int4.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	"This foreignKey has a default, so we never actually create it"		foreignKey shouldCreateInDatabase: false.	propId := aTable createFieldNamed: 'propertiesID' type: platform int4.	propId beIndexed.	foreignKey := aTable addForeignKeyFrom: propId to: self blobId.	"This foreignKey has a default, so we never actually create it"	foreignKey shouldCreateInDatabase: false.	aTable		createFieldNamed: 'vanguardID'		type: (platform varChar: 255).	aTable		createFieldNamed: 'rearguardID'		type: (platform varChar: 255).	aTable addUniqueConstraintFor: (Array with: (aTable fieldNamed: 'version') with: (aTable fieldNamed: 'name')).	aTable createFieldNamed: 'vanguardStr' type: (platform varChar: 255).	aTable createFieldNamed: 'rearguardStr' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreBundle tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBundle tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_BUNDLES: aTable 	| constraint expId bundleRef subBundleRef foreignKey |	bundleRef := aTable createFieldNamed: 'bundleRef' type: platform int4.	bundleRef bePrimaryKey.	constraint := aTable addForeignKeyFrom: bundleRef		to: self bundleId.	constraint name: 'BUNDLEREF_CONSTRAINT'.	expId := aTable createFieldNamed: 'expressionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: expId		to: self blobId.		"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	(aTable createFieldNamed: 'seqNumber' type: platform int4) beNullable: false.	subBundleRef := aTable createFieldNamed: 'subBundleRef' type: platform int4.	subBundleRef bePrimaryKey.	constraint := aTable addForeignKeyFrom: subBundleRef		to: self bundleId.	constraint name: 'SUBBUNDLEREF_CONSTRAINT'.	"This seems to make a big difference for postgresql."	aTable addIndexForField: subBundleRef.	aTable propertyAt: #tableSpaceName put: StoreBundle tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBundle tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_CLASSRECORD: aTable	| defId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	defId := aTable createFieldNamed: 'definitionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: defId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	"This foreignKey has a default, so we never create it"	foreignKey shouldCreateInDatabase: false.	(aTable createFieldNamed: 'environmentString' type: (platform varChar: 255)) beIndexed.	aTable createFieldNamed: 'superclass' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreClassDefinition tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreClassDefinition tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_DATA: aTable 	"All foreign keys talk to tables in the same tableSpace"	| packageRef dataRef |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	aTable addForeignKeyFrom: packageRef		to: self packageId.	packageRef bePrimaryKey.	dataRef := aTable createFieldNamed: 'dataRef' type: platform int4.	aTable addForeignKeyFrom: dataRef		to: ((self tableNamed: 'TW_DataElement') fieldNamed: 'primaryKey').	dataRef bePrimaryKey.	aTable addIndexForField: dataRef.	(aTable addIndexForField: dataRef and: packageRef) name: 'Shared_Variables_GC'.	aTable propertyAt: #tableSpaceName put: StoreSharedVariable tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreSharedVariable tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_DATABASEIDENTIFIER: aTable 	(aTable createFieldNamed: 'identityName' type: (platform varChar: 255)) 		bePrimaryKey.	aTable propertyAt: #tableSpaceName put: StoreObject tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreObject tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_DATAELEMENT: aTable	| defId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	defId := aTable createFieldNamed: 'definitionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: defId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	"This foreignKey has a Default, so we never create it"	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'environmentString' type: (platform varChar: 255).	aTable createFieldNamed: 'protocolName' type: (platform varChar: 255).	aTable createFieldNamed: 'typeString' type: (platform varChar: 1).	aTable propertyAt: #tableSpaceName put: StoreSharedVariable tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreSharedVariable tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_DBPUNDLEPRIVILEGES: aTable 	(aTable createFieldNamed: 'pundleName' type: (platform varChar: 255)) 		bePrimaryKey.	(aTable createFieldNamed: 'pundleType' type: (platform varChar: 1)) 		bePrimaryKey.	(aTable createFieldNamed: 'userName' type: (platform varChar: 255)) 		bePrimaryKey.	(aTable createFieldNamed: 'userType' type: (platform varChar: 1)) 		bePrimaryKey.	aTable createFieldNamed: 'privilege' type: (platform varChar: 32).	aTable propertyAt: #tableSpaceName put: StoreAccessPrivilege tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreAccessPrivilege tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_DBUSERGROUP: aTable 	(aTable createFieldNamed: 'groupName' type: (platform varChar: 255)) 		bePrimaryKey.	(aTable createFieldNamed: 'userName' type: (platform varChar: 255)) 		bePrimaryKey.	aTable createFieldNamed: 'type' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreUserGroup tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreUserGroup tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_METHOD: aTable	"Mapping to version was missing and has been added.  N.B. this version is the method type e.g. CType and has nothing to do with Store's CM versioning.	At the bottom, we remove the automatically created 'name' index (from createStandardRecordFieldsInTable:) and add it back as a compound index on name and classNameField	Unlike other tables with version field, this one CAN be nil (and usually is)"	| srcId classNameField versionField foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	versionField := (aTable fieldNamed: 'version').	versionField beNullable: true.		srcId := aTable createFieldNamed: 'sourceCodeID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: srcId		to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	(classNameField := aTable createFieldNamed: 'className' type: (platform varChar: 255)) beIndexed.	aTable createFieldNamed: 'metaString' type: (platform varChar: 4).	(aTable createFieldNamed: 'protocolName' type: (platform varChar: 255)) beIndexed.	(aTable fieldNamed: 'name' ifAbsent: [nil] caseSensitive: false) ifNotNil: 		[:value | 		aTable indexes removeAllSuchThat: [:each | each indexesField: value]. 		aTable addIndexForField: value and: classNameField].	aTable propertyAt: #tableSpaceName put: StoreMethod tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreMethod tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_METHODS: aTable 	| packageRef methodRef foreignKey |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	foreignKey := aTable addForeignKeyFrom: packageRef		to: self packageId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	packageRef bePrimaryKey.	methodRef := aTable createFieldNamed: 'methodRef' type: platform int4.	aTable addForeignKeyFrom: methodRef		to: ((self tableNamed: 'TW_Method') fieldNamed: 'primaryKey').	"This foreignKey is in the same tableSpace"	methodRef bePrimaryKey.	"This seems to make a big difference for postgresql"	aTable addIndexForField: methodRef.	(aTable addIndexForField: methodRef and: packageRef) name: 'Methods_GC'.	aTable propertyAt: #tableSpaceName put: StoreMethod tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreMethod tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_NAMESPACERECORD: aTable	| defId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	defId := aTable createFieldNamed: 'definitionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: defId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'environmentString' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreNameSpace tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreNameSpace tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_PACKAGE: aTable	| commentId propId parcelId foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	aTable createFieldNamed: 'blessingLevel' type: platform int4.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	"We never create this FK because it has a default"	foreignKey shouldCreateInDatabase: false.	(propId := aTable createFieldNamed: 'propertiesID' type: platform int4) beIndexed.	foreignKey := aTable addForeignKeyFrom: propId to: self blobId.	foreignKey name: 'TW_Package_TW_Blob_PropID'.	"We never create this FK because it has a default"	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'binFile' type: (platform varChar: 255).	parcelId := aTable createFieldNamed: 'parcelID' type: platform int4.	aTable addUniqueConstraintFor: (Array with: (aTable fieldNamed: 'version') with: (aTable fieldNamed: 'name')).	"We always create this FK because both tables are always in the same table space"	aTable addForeignKeyFrom: parcelId to: ((self tableNamed: 'TW_ParcelRecord') fieldNamed: 'primaryKey').	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_PACKAGES: aTable	| expId bundleRef packageRef foreignKey |	bundleRef := aTable createFieldNamed: 'bundleRef' type: platform int4.	bundleRef bePrimaryKey.	aTable		addForeignKeyFrom: bundleRef		to: ((self tableNamed: 'TW_Bundle') fieldNamed: 'primaryKey').	expId := aTable createFieldNamed: 'expressionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: expId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	(aTable createFieldNamed: 'seqNumber' type: platform int4) beNullable: false.	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	packageRef bePrimaryKey.	"This foreignKey is always in the same tableSpace so we always create it"	aTable addForeignKeyFrom: packageRef to: self packageId.	"This seems to make a big difference for Postgresql."	aTable addIndexForField: packageRef.	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_PARCELRECORD: aTable 	| blobId sourceId pundleId foreignKey versionField |	self createStandardAndVersionRecordFieldsIn: aTable.	versionField := (aTable fieldNamed: 'version').	versionField beNullable: true.	pundleId := aTable createFieldNamed: 'pundleID' type: platform int4.	pundleId defaultValue: 0.	blobId := aTable createFieldNamed: 'blobID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: blobId		to: self binaryBlobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	sourceId := aTable createFieldNamed: 'sourceID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: sourceId		to: self binaryBlobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	aTable createFieldNamed: 'filename' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_PKGCLASSES: aTable	"Primary key is packageRef + classRef, and thus an system index will be created for that"		| constraint packageRef classRef metaclassRef |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	packageRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	aTable addForeignKeyFrom: packageRef to: self packageId.	classRef := aTable createFieldNamed: 'classRef' type: platform int4.	classRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	constraint := aTable addForeignKeyFrom: classRef to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey').	constraint name: 'CLASSREF_CONSTRAINT'.	metaclassRef := aTable createFieldNamed: 'metaclassRef' type: platform int4.	"This foreignKey is always in the same table space, so we always create it"	constraint := aTable addForeignKeyFrom: metaclassRef to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey').	constraint name: 'METACLASSREF_CONSTRAINT'.	aTable createFieldNamed: 'definitionOrder' type: platform int4.	"This seems to make a big difference for postgresql."	aTable addIndexForField: classRef.	(aTable addIndexForField: classRef and: packageRef) name: 'Classes_GC'.	(aTable addIndexForField: metaclassRef and: packageRef) name: 'Metaclasses_GC'.	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_PKGNAMESPACES: aTable 	| packageRef nameSpaceRef |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	packageRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	aTable addForeignKeyFrom: packageRef		to: (self packageId).	nameSpaceRef := aTable createFieldNamed: 'nameSpaceRef' type: platform int4.	nameSpaceRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	aTable addForeignKeyFrom: nameSpaceRef		to: ((self tableNamed: 'TW_NamespaceRecord') fieldNamed: 'primaryKey').	(aTable createFieldNamed: 'definitionOrder' type: platform int4).	"This seems to make a big difference for postgresql"	aTable addIndexForField: nameSpaceRef.	(aTable addIndexForField: nameSpaceRef and: packageRef) name: 'NameSpaces_GC'.	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>classes</category><body package="Store-Database Model">addPropertiesToClassModel: aClassModel	"Varies by schema version"	aClassModel newAttributeNamed: #propertiesBlob type: StoreBlob.</body><body package="Store-Database Model">addTimestampTo: aDescriptor fromTable: table	"Work around the hack they did in StoreForInterbase to avoid using reserved words"	| field fieldName |	fieldName := self timestampFieldName.	field := table fieldNamed: fieldName.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #timestamp		fromDb: 			[:row :elementBuilder :context |			| value index |			index := context canTranslateFields						ifTrue: [context translateField: field]						ifFalse: [context].			value := elementBuilder valueOfField: index in: row.			value isNil				ifTrue: [nil]				ifFalse: 					[value &lt; 0 ifTrue: [value := 0].					Dialect timestampClass fromSeconds: value + self timestampOffset]]		toDb: 			[:rows :attribute :targetRows |			"The timestamp can actually be a query object if we're doing a subselect"			self				convertTimestampToDbInRows: rows				attribute: attribute				forTable: table				field: field]		mappingFields: (Array with: field)</body><body package="Store-Database Model">addUsernameTo: aDescriptor fromTable: table 	"We could use a DirectMapping, but that wouldn't allow us to have default values:"	aDescriptor addMapping: (DirectMapping from: #username				to: (table fieldNamed: 'userName'))."This doesn't let us query, and we're only reading right now anyway...	| field |	field := table fieldNamed: 'USERNAME'.	aDescriptor addMapping: (AdHocMapping 				forAttribute: #username				fromDb: [:row | row atIndex: field position]				toDb: 					[:rows :attribute | 					| name |					name := attribute first 								ifNil: [aDescriptor session accessor currentLogin username].					(rows at: table) atIndex: field position put: name]				mappingFields: (Array with: field))"</body><body package="Store-Database Model">blobToDatabaseForRows: thisBlobRows nextBlob: nextBlob nextBlobRows: nextBlobRows	"In the image, thisBlob holds nextBlob in its 'next' instVar.  In the database, the type field of thisBlob's row will hold the negative (negative to distinguish it from an actual type value) of the pimaryKey of nextBlob's row.  We unify the fields so that whenever a value is set to either, the other is updated (in practice, nextBlob gets a primaryKey and thisBlob-&gt;type gets the negation;  it would be very strange to update the other way round.)"	| rowMap thisBlob table pkField field rowArray |	nextBlob isNil ifTrue: [^nil].	rowArray := thisBlobRows asArray.	table := rowArray first table.	pkField := table fieldNamed: 'primaryKey'.	field := table fieldNamed: 'blobType'.	rowMap := RowMap forRows: thisBlobRows.	"somewhat of a hack"	nextBlobRows do: [:each | rowMap addRow: each].	thisBlob := rowArray first owner.	rowMap		unifyField: pkField		key: nextBlob		withField: field		key: thisBlob		transformationForward: [:value | value isNil ifTrue: [nil] ifFalse: [value * -1]]		inverse: [:value | value isNil ifTrue: [nil] ifFalse: [value * -1]].		"If debugging, inspecting the expression below gives a start point		(thisBlobRows at: table) at: field."</body><body package="Store-Database Model">classModelForStoreAccessPrivilege: aClassModel	aClassModel newAttributeNamed: #pundleName type: String.	aClassModel newAttributeNamed: #pundleType type: String.	aClassModel newAttributeNamed: #userName type: String.	aClassModel newAttributeNamed: #userType type: String.	aClassModel newAttributeNamed: #privilege type: String.</body><body package="Store-Database Model">classModelForStoreBinaryBlob: aClassModel	^self classModelForStoreBlob: aClassModel.</body><body package="Store-Database Model">classModelForStoreBlessing: aClassModel	aClassModel newAttributeNamed: #primaryKey.	aClassModel newAttributeNamed: #blessingLevel.	aClassModel newAttributeNamed: #comment type: StoreBlob.	aClassModel newAttributeNamed: #timestamp.	aClassModel newAttributeNamed: #username.	aClassModel newAttributeNamed: #trace type: StoreBlessing.</body><body package="Store-Database Model">classModelForStoreBlob: aClassModel	aClassModel newAttributeNamed: #type.	aClassModel newAttributeNamed: #primaryKey.	aClassModel newAttributeNamed: #next.	aClassModel newAttributeNamed: #data.</body><body package="Store-Database Model">classModelForStoreBundle: aClassModel	self classModelForStorePundle: aClassModel.	aClassModel newAttributeNamed: #bundles collection: Dictionary of: StoreBundle.	aClassModel newAttributeNamed: #packages collection: Dictionary of: StorePackage.	aClassModel newAttributeNamed: #versionless type: StoreVersionlessBundle.</body><body package="Store-Database Model">classModelForStoreBundleInBundle: aClassModel	aClassModel newAttributeNamed: #containingBundle type: StoreBundle.	aClassModel newAttributeNamed: #sequence type: Integer.	aClassModel newAttributeNamed: #subbundle type: StoreBundle.</body><body package="Store-Database Model">classModelForStoreBundlePackageRelationship: aClassModel	aClassModel newAttributeNamed: #bundleID.	aClassModel newAttributeNamed: #packageID.	aClassModel newAttributeNamed: #sequence.	aClassModel newAttributeNamed: #expressionID.</body><body package="Store-Database Model">classModelForStoreBundleSubBundleRelationship: aClassModel	aClassModel newAttributeNamed: #bundleID.	aClassModel newAttributeNamed: #subbundleID.	aClassModel newAttributeNamed: #sequence.	aClassModel newAttributeNamed: #expressionID.</body><body package="Store-Database Model">classModelForStoreClassDefinitionInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreClassDefinition.	aClassModel newAttributeNamed: #metaclass type: StoreClassDefinition.</body><body package="Store-Database Model">classModelForStoreClassExtension: aClassModel	aClassModel newAttributeNamed: #classDefinition type: StoreClassDefinition.	aClassModel newAttributeNamed: #classMethods collectionOf: StoreMethod.	aClassModel newAttributeNamed: #instanceMethods collectionOf: StoreMethod.	aClassModel newAttributeNamed: #sharedVariables type: StoreSharedVariable.	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #longName type: String.	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #longName type: StoreMetaclassExtension.</body><body package="Store-Database Model">classModelForStoreDatabaseIdentifier: aClassModel	aClassModel newAttributeNamed: #name type: Symbol.</body><body package="Store-Database Model">classModelForStoreMetaclassExtension: aClassModel	aClassModel newAttributeNamed: #mainClass type: StoreClassExtension.</body><body package="Store-Database Model">classModelForStoreMethod: aClassModel	self classModelForStoreSourceObject: aClassModel.	aClassModel newAttributeNamed: #source type: StoreBlob.	aClassModel newAttributeNamed: #className type: String.	aClassModel newAttributeNamed: #isMetaclass type: Boolean.	aClassModel newAttributeNamed: #protocol type: Symbol.</body><body package="Store-Database Model">classModelForStoreMethodInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreMethod.</body><body package="Store-Database Model">classModelForStoreNamespaceInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreNameSpace.</body><body package="Store-Database Model">classModelForStorePackage: aClassModel	self classModelForStorePundle: aClassModel.	aClassModel newAttributeNamed: #methods collectionOf: StoreMethodInPackage.	aClassModel newAttributeNamed: #classDefinitions collectionOf: StoreClassDefinitionInPackage.	aClassModel newAttributeNamed: #nameSpaces collectionOf: StoreNamespaceInPackage.	aClassModel newAttributeNamed: #sharedVariables collectionOf: StoreSharedVariableInPackage.	aClassModel newAttributeNamed: #parcel type: StoreParcelRecord.	aClassModel newAttributeNamed: #binFile type: String.	aClassModel newAttributeNamed: #versionless type: StoreVersionlessPackage.</body><body package="Store-Database Model">classModelForStorePackageInBundle: aClassModel	aClassModel newAttributeNamed: #containingBundle type: StoreBundle.	aClassModel newAttributeNamed: #sequence type: Integer.	aClassModel newAttributeNamed: #package type: StorePackage.</body><body package="Store-Database Model">classModelForStoreParcelRecord: aClassModel	aClassModel newAttributeNamed: #primaryKey.	aClassModel newAttributeNamed: #timestamp.	aClassModel newAttributeNamed: #username type: String.	aClassModel newAttributeNamed: #trace type: StoreParcelRecord.	aClassModel newAttributeNamed: #blob type: StoreBinaryBlob.	aClassModel newAttributeNamed: #source type: StoreBinaryBlob.	aClassModel newAttributeNamed: #filename type: String.	aClassModel newAttributeNamed: #version type: String.</body><body package="Store-Database Model">classModelForStorePundle: aClassModel	self classModelForStoreSourceObject: aClassModel.	aClassModel newAttributeNamed: #comment type: StoreBlob.	self addPropertiesToClassModel: aClassModel.	aClassModel newAttributeNamed: #version type: String.	aClassModel newAttributeNamed: #blessings collectionOf: StoreBlessing.	aClassModel newAttributeNamed: #currentBlessingLevel type: Number.</body><body package="Store-Database Model">classModelForStorePundlePropertyRelationship: aClassModel	aClassModel newAttributeNamed: #pundleID.	aClassModel newAttributeNamed: #propertyID.	aClassModel newAttributeNamed: #recordType.</body><body package="Store-Database Model">classModelForStoreSharedVariableInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreSharedVariable.</body><body package="Store-Database Model">classModelForStoreSourceObject: aClassModel	aClassModel newAttributeNamed: #primaryKey type: Integer.	aClassModel newAttributeNamed: #trace type: aClassModel describedClass.	aClassModel newAttributeNamed: #username type: String.	aClassModel newAttributeNamed: #timestamp.	aClassModel newAttributeNamed: #name type: String.</body><body package="Store-Database Model">classModelForStoreUserGroup: aClassModel	aClassModel newAttributeNamed: #groupName type: String.	aClassModel newAttributeNamed: #userName type: String.	aClassModel newAttributeNamed: #type type: String.</body><body package="Store-Database Model">convertTimestampToDbInRows: rows attribute: attribute forTable: table field: field	| offset |	"The timestamp can actually be a query object if we're doing a subselect"	offset := attribute isNil ifTrue: [nil]		ifFalse: [attribute isGlorpExpression						ifTrue: [attribute]						ifFalse: [attribute asSeconds - self timestampOffset]].	^(rows at: table) at: field put: offset</body><body package="Store-Database Model">timestampFieldName	^self platform class == FirebirdPlatform 		ifTrue: ['timeStmp']		ifFalse: ['timeStamp']</body><body package="Store-Database Model">typeResolverForStoreVersionlessPundle	^HorizontalTypeResolver forRootClass: StoreVersionlessPundle.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>testing</category><body package="Store-Database Model">hasMethodComments	^false.</body><body package="Store-Database Model">hasPropertiesAsBlob	^true.</body><body package="Store-Database Model">supportsTableSpaceBasedForeignKey	platform supportsPhysicalSpaces ifFalse: [^true].	platform class = SQLServerPlatform and: [^Store.Policies tableSpacePolicy allTableSpacesAreEqual].	^true</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>validation</category><body package="Store-Database Model">validateRows: aUnitOfWork	| bundleTable timestampField blobId packageTable packageVersionField bundleVersionField bundleTraceField packageTraceField allPackageKeys packageField packageNames methodsTable |	super validateRows: aUnitOfWork.	"If this is a non-replicator session, for example a Store-on-Glorp publish or write-enabled Store workbook, then we want to allow updates so these validations aren't correct."	aUnitOfWork session accessor permitsUpdates ifTrue: [^self].	aUnitOfWork rowsToWrite		do:			[:each |			each table hasCompositePrimaryKey				ifFalse:					[each primaryKey notNil						ifTrue: [self error: 'Row already has a primary key']]].	bundleTable := self tableNamed: 'TW_Bundle'.	timestampField := bundleTable fieldNamed: self timestampFieldName.	packageTable := self tableNamed: 'TW_Package'.	packageVersionField := packageTable fieldNamed: 'version'.	bundleVersionField := bundleTable fieldNamed: 'version'.	bundleTraceField := bundleTable fieldNamed: 'trace'.	packageTraceField := packageTable fieldNamed: 'trace'.	methodsTable := self tableNamed: 'TW_Methods'.	aUnitOfWork rowsToWrite		do: [:each | (each table = bundleTable and: [(each at: timestampField) isNil]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: [:each | (each table = bundleTable and: [(each at: bundleVersionField) isNil]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: [:each | (each table = bundleTable and: 				[ | storeModel |				(storeModel := each owner storeModel) notNil and: [				storeModel versionString = each owner version and: [					storeModel databaseInformation notNil and: [						storeModel databaseInformation dbTrace notNil and: [							(each at: bundleTraceField) isNil]]]]]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: [:each | (each table = packageTable and: [(each at: packageVersionField) isNil]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: [:each | (each table = packageTable and: 				[ | storeModel |				(storeModel := each owner storeModel) notNil and: [				storeModel versionString = each owner version and: [					storeModel databaseInformation notNil and: [						storeModel databaseInformation dbTrace notNil  and: [							(each at: packageTraceField) isNil]]]]]) ifTrue: [self halt]]."We believe the problem of methods with trace zero is now long solved and so skip this check.	methodTable := self tableNamed: 'TW_Method'.	methodTrace := methodTable fieldNamed: 'trace'.	aUnitOfWork rowsToWrite		do: [:each | (each table = methodTable and: [(each at: methodTrace) = 0]) ifTrue: [self halt]]."	blobId := self blobId.	aUnitOfWork rowsToWrite do: [:each |		(each table = blobId table and: [(each at: blobId) = 0]) ifTrue: [self halt]].	"Check if we are publishing any methods that refer to packages that don't exist, or multiple copies of the same package"	packageField := methodsTable fieldNamed: 'packageRef'.	allPackageKeys := (aUnitOfWork rowsToWrite select: [:each | each table = packageTable]) collect: [:each | each primaryKey].	aUnitOfWork rowsToWrite do: [:each |		each table = methodsTable ifTrue: [(allPackageKeys includes: (each at: packageField)) ifFalse: [self halt]]].	packageNames := (aUnitOfWork rowsToWrite select: [:each | each table = packageTable]) collect: [:each | each owner name].	packageNames size = packageNames asSet size ifFalse: [self halt].</body><body package="Store-Database Model">validateRowsPostWrite: aUnitOfWork	"Validate after writing. This is a bit late, but some things may not be catchable ahead of time"	| table field |	super validateRowsPostWrite: aUnitOfWork.	aUnitOfWork session accessor permitsUpdates ifTrue: [^self].	table := self tableNamed: 'TW_Blob'.	field := table fieldNamed: 'blobType'.	aUnitOfWork rowsToWrite		do:			[:each | (each table = table and: [(each at: field) isNil]) ifTrue: [self halt]].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>other</category><body package="Store-Database Model">constructAllClasses	^(super constructAllClasses)		add: StoreBlessing;		add: StoreBlob;		add: StoreBundle;		add: StoreNameSpace;		add: StoreSharedVariable;		add: StoreClassDefinition;		add: StoreMethod;		add: StorePackage;		add: StoreVersionlessBundle;		add: StoreVersionlessPackage;		add: StoreClassExtension;		add: StoreDatabaseIdentifier;		add: StoreParcelRecord;		add: StoreBinaryBlob;		add: StoreClassDefinitionInPackage;		add: StoreMethodInPackage;		add: StoreNamespaceInPackage;		add: StoreSharedVariableInPackage;		add: StoreUserGroup;		add: StoreAccessPrivilege;	"link table objects"		add: StoreBundleInBundle;		add: StorePackageInBundle;		add: StoreBundleSubBundleRelationship;		add: StoreBundlePackageRelationship;		yourself</body><body package="Store-Database Model">justSelectTheMaximumCurrentValueAndAddOneSequenceFor: aTable 	^self databaseSequenceNamed: aTable name ifAbsentPut: [JustSelectTheMaximumSequenceValueAndAddOne new table: aTable].</body><body package="Store-Database Model">sequenceFor: aTable	| name sequence |	name := self platform storeSequenceNameFor: aTable name.	(platform isAccessPlatform or: [platform isSQLite3Platform])		ifTrue:			["Ick. SQL Server used to work this way, but at least for Access it's single-user, so it shouldn't crash.			Can Access now use SQLServerSequence, as its code suggests, or not?  TBC."			"SQLite3Platform is only here because I (Niall) have not yet checked whether it has a valid sequence construct."			sequence := self justSelectTheMaximumCurrentValueAndAddOneSequenceFor: aTable]		ifFalse: [sequence := self databaseSequenceNamed: name].	sequence schema: aTable schema.	^self platform serial sequence: sequence.</body><body package="Store-Database Model">timestampOffset	^2922938387</body><body package="Store-Database Model">valueIsNil: aValue	^aValue = nil.</body><body package="Store-Database Model">valueIsNonNil: aValue	^aValue ~= nil.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>hooks</category><body package="Store-Database Model">shouldForeignKeyValueBeTreatedAsNull: aValue	"Return true if this foreign key value should be treated as null, meaning there's no relationship. Normally this means just nil, but descriptor systems can override if they have special values which they use (e.g. 0) that indicate a missing relationship. This can improve performance by avoiding unnecessary queries to the database for things we know will never return a result"	^aValue isNil or: [aValue = 0].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>private</category><body package="Store-Database Model">initializeTable: newTable	super initializeTable: newTable.	(self platform isKindOf: OraclePlatform) ifTrue: 		[session schema isEmpty			ifTrue: [newTable schema: Store.DbRegistry tablePrefix asUppercase]			ifFalse: [newTable schema: session schema asUppercase]].</body><body package="Store-Database Model">privateSetDatabaseIdentifier	(self session cacheFor: StoreDatabaseIdentifier) do: [:each | ^dbIdentifier := each name].	self session isLoggedIn ifTrue:		[(session readOneOf: StoreDatabaseIdentifier) ifNotNil: [:result | ^dbIdentifier := result name]].	dbIdentifier := nil.	"We attempted and failed;  clear any prior value (unlikely)."</body><body package="Store-Database Model">updateGCIndexesForTableNamed: aString	| indexes table |	table := self tableNamed: aString.	indexes := table indexes select: [:each | '*_GC' match: each name].	indexes do: 		[:each |		session accessor			createIndex: each			forTable: table			ifError: 				[:exception |				Transcript					cr;					show: table name , ' ' , each name, ' : ', exception description.				exception isResumable 					ifTrue: [exception resume: nil]					ifFalse: [exception return]]]</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>optimization parameters</category><body package="Store-Database Model">commonMaximumBlobRows	commonMaximumBlobRows isNil 		ifTrue: [commonMaximumBlobRows := self class defaultCommonMaximumBlobRows].	^commonMaximumBlobRows</body><body package="Store-Database Model">commonMaximumBlobRows: anInteger	commonMaximumBlobRows := anInteger</body><body package="Store-Database Model">maximumSizeToGroupWriteFor: aRowBasedCommand	"We can get some really large row collections, which could be a problem in 2004 when Store on Glorp was first in use, so this method capped the maximum size.  It may be time to review this."	^1000 min: (super maximumSizeToGroupWriteFor: aRowBasedCommand)</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>convenience</category><body package="Store-Database Model">databaseIdentifier	"Convenience method. Return the database identifier name in cache. If there isn't one, read and then do so"	dbIdentifier isNil		ifTrue: [self privateSetDatabaseIdentifier].	^dbIdentifier</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>utility methods</category><body package="Store-Database Model">alsoFetchDefinitionSourceRecursivelyInMapping: aMapping	"The parameter mapping's query has been asked to alsoFetch definition source - this implementation assumes no other #alsoFetch (or #retrieve:) was called between that and this call.  The mapping's query is to become the intersect query of the overall recursive query.  TBR: as soon as correctness is completely verified, replace this with a much simpler API."	| recursiveBlobQuery startingDepth intersectQuery |	self canRecurse ifFalse: [^self].	intersectQuery := aMapping query.	startingDepth := 0 asGlorpExpression alias: #depth.	recursiveBlobQuery := intersectQuery		alsoFetchRecursively: [:each | each definition source nextPseudoBlobRecursively beOuterJoin]		retrieveAll: (Array			with: [:each | each definition source primaryKey]			with: [:each | each definition source nextPseudoBlob primaryKey]			with: [:each | startingDepth])		defineThenFollow: [:anotherDescriptor |				anotherDescriptor oneToOneMapping					attributeName: #nextPseudoBlob;					beForPseudoVariable;					referenceClass: StoreBlob;					join: (Join							from: ([:each | ((each getTable: 'TW_Blob') getField: 'blobType') negated alias: 'blobTypeNegated']												asGlorpExpressionForDescriptor: anotherDescriptor)							to: (anotherDescriptor table fieldNamed: 'primaryKey'))]		recursivelyRetrievingAll: (Array			with: [:each | each definitionsourceprimaryKey]			with: [:each | each recurse nextPseudoBlob primaryKey]			with: [:each | each depth + 1 cast: Integer]).	recursiveBlobQuery unionQuery queries first AND: [:each | each definition source blobTypeOrNextKey &lt; 0].	intersectQuery orderBy: [:each | each definition primaryKey].	intersectQuery orderBy: [:each | each definition source nextPseudoBlobRecursively recursed beOuterJoin depth].	"recursiveBlobQuery collectionType: GlorpRecursiveCollection."	recursiveBlobQuery collectionType: aMapping collectionType.	aMapping privateAndBasicSetQuery: recursiveBlobQuery.</body><body package="Store-Database Model">canRecurse	"Later, this may be pushed up to support descriptor systems generally and/or callers may instead subclass descriptor systems with recursive descriptor systems chosen at the point of login and/or an instance side instvar can be set from this at login.  For now, it provides a system-specific switch if desired.  (Could this ever meaningfully be called when platform was nil?)"	^UseRecursionIfSupported		and: [platform canRecurse		and: [platform isDB2Platform not]]"DB2 cannot tolerate ANSI joins in recursion but also cannot handle outer joins in where clauses (it replies false to replies false to #useMicrosoftOuterJoins).  Thus a recursive #methods mapping that uses outer-joins is impossible for it."</body><body package="Store-Database Model">latestVersionOf: aPundle	"Find the latest version of aPundle, defined by having the highest timestamp."	| query |	query := Query readOneOf: aPundle storeForGlorpPundleClass where: [:each |		| q |		q := Query read: aPundle storeForGlorpPundleClass where: [:eachPundle |			eachPundle name = aPundle name].		q retrieve: [:x | x timestamp max].		each timestamp = q].	^session execute: query.</body><body package="Store-Database Model">recursifySourceMappingIn: aDescriptor	"Leave the mapping data unchanged, but replace its first-blob-recovering query with an all-blobs-recovering recursive query.  The effects of this change are as follows.1) If StoreMethods are read and source is not alsoFetch:ed, each read StoreMethod has a proxy in its 'source' instvar.  When the proxy is instantiated, all blobs are fetched as a chain, not just the first one.2) If #source is alsoFetch:ed, each read StoreMethod fetches only its first blob, just as before (because the outer query is not recursive and it uses the mapping, not the mapping's query, to augment the generated SQL.)  When that first blob's 'next' proxy is triggered, _all_ remaining blobs are then returned, not just another one (N.B. that is due to the code #recursiveSuccessorBobChainOfBlob:id:, not the code below).3) If something else is read and StoreMethods are themselves alsoFetched as part of that, then (1) applies.  If StoreMethod and StoreMethod #source are both alsoFetch:ed then (2) applies.  However if the source is alsoFetchRecursively: then the recursion CTE is moved to the outer query and all the blob chains of all the read methods are also fetched."	| sourceMapping |	self canRecurse ifFalse: [^self].	sourceMapping := aDescriptor mappingForAttributeNamed: #source.	"In the next iteration, RecursiveMapping&gt;&gt;buildQuery will compute the above;  for now, hardcode it."	sourceMapping privateAndBasicSetQuery: self sourceRecursiveQuery.</body><body package="Store-Database Model">recursiveSuccessorBlobChainOfBlob: aBlob id: anInteger class: aClass inTable: aTableName	"Hev the Proxy's query return a blob with successor chain of next blobs in a single recursive read."	| startingDepth recursionProxy recursiveBlobQuery |	recursionProxy := Proxy new session: session.	startingDepth := 0 asGlorpExpression alias: #depth.	recursiveBlobQuery := (Query read: aBlob class where: [:each | each primaryKey = anInteger])		retrieveAll: (Array					with: [:each | each nextPseudoBlob primaryKey]					with: [:each | startingDepth])		defineThenFollow: [:anotherDescriptor |					anotherDescriptor oneToOneMapping						attributeName: #nextPseudoBlob;						beForPseudoVariable;						referenceClass:  aClass;						join: (Join								from: ([:each | ((each getTable: aTableName) getField: 'blobType') negated alias: 'blobTypeNegated']													asGlorpExpressionForDescriptor: anotherDescriptor)								to: (anotherDescriptor table fieldNamed: 'primaryKey'))]		recursivelyRetrievingAll: (Array								with: [:each | each recurse nextPseudoBlob primaryKey]								with: [:each | each depth + 1 cast: Integer])		intersect: ((Query read: aBlob class) orderBy: [:each | each recursed depth]).	recursionProxy query: recursiveBlobQuery.	recursiveBlobQuery collectionType: GlorpRecursiveCollection.	^recursionProxy</body><body package="Store-Database Model">sourceRecursiveQuery	"We pull this query out into its own method so that it is simple to call it again and get a cloned one for use in the alsoFetch case."	| sourceMappingJoin1 recursiveBlobQuery sourceMappingJoin2 |	sourceMappingJoin1 := Join	"duplicate the join to avoid any confusion in recursive/non-recursive manipulations"		from: ((self tableNamed: 'TW_Method') fieldNamed: 'sourceCodeID')		to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey').	"Build the recursive query on a copy of the mapping's query (N.B. cannot use buildQuery as it sets the descriptor and we clone it)."	recursiveBlobQuery := (Query read: StoreBlob where: sourceMappingJoin1)		retrieve: [:each | each nextPseudoBlob primaryKey]		defineThenFollow: [:anotherDescriptor |				anotherDescriptor oneToOneMapping					attributeName: #nextPseudoBlob;					beForPseudoVariable;					referenceClass: StoreBlob;					join: (Join							from: ([:each | ((each getTable: 'TW_Blob') getField: 'blobType') negated alias: 'blobTypeNegated']												asGlorpExpressionForDescriptor: anotherDescriptor)							to: (anotherDescriptor table fieldNamed: 'primaryKey'))]		recursivelyRetrieving: [:each | each recurse nextPseudoBlob primaryKey]		intersect: (Query read: StoreBlob).	sourceMappingJoin2 := Join	"again, we duplicate the join just in case - drop this later"		from: ((self tableNamed: 'TW_Method') fieldNamed: 'sourceCodeID')		to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey').	recursiveBlobQuery := recursiveBlobQuery unionAll: (Query read: StoreBlob where: sourceMappingJoin2).	recursiveBlobQuery expectedRows: self commonMaximumBlobRows.	"The type value of the end blob in the chain is positive, while towards the front of the chain the type field holds increasingly negative id numbers, so ordered recovery is easy."	recursiveBlobQuery orderBy: [:each | each blobTypeOrNextKey].	recursiveBlobQuery collectionType: GlorpRecursiveCollection.	^recursiveBlobQuery</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>updating</category><body package="Store-Database Model">update710	#('TW_Data' 'TW_PkgClasses' 'TW_Bundles' 'TW_Methods' 'TW_PkgNameSpaces' 'TW_Properties') do:		[:each | self updateGCIndexesForTableNamed: each]</body><body package="Store-Database Model">update77	| table |	table := self tableNamed: 'TW_PACKAGE'.	self session accessor 		createTableIndexes: table 		ifError: 			[:exception | 			Transcript cr; show: exception description. 			exception resume: nil]</body><body package="Store-Database Model">update771	| table versionField nameField constraint |	#('TW_BUNDLE' 'TW_PACKAGE') do:		[:each |		table := self tableNamed: each.		versionField := table fieldNamed: 'version'.		nameField := table fieldNamed: 'name'.		constraint := UniqueConstraint forTable: table fields: (Array with: versionField with: nameField).		session accessor addConstraint: constraint].	#('TW_METHOD' 'TW_METHODS') do:		[:each |		table := self tableNamed: each.		self session accessor 			createTableIndexes: table 			ifError: 				[:exception | 				Transcript cr; show: exception description. 				exception resume: nil]]</body><body package="Store-Database Model">update78	| packageClassesTable |	packageClassesTable := self tableNamed: 'TW_PkgClasses'.	self session accessor 		createTableIndexes: packageClassesTable 		ifError: 			[:exception | 			Transcript show: (#_nExceptionCreatingTWPkgClassIndexs &lt;&lt; #store &gt;&gt; '&lt;n&gt;Exception while creating indexes for TW_PkgClasses table : &lt;1s&gt;' expandMacrosWith: exception description). 			exception return: nil].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>accessing</category><body package="Store-Database Model">cachePolicy	"Return the cache policy that will be used for Store"	cachePolicy isNil ifTrue: [cachePolicy := CachePolicy new].	^cachePolicy.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>tables - common fields</category><body package="Store-Database Model">binaryBlobId	^(self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey'.</body><body package="Store-Database Model">blobId	^(self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey'.</body><body package="Store-Database Model">bundleId	^(self tableNamed: 'TW_Bundle') fieldNamed: 'primaryKey'.</body><body package="Store-Database Model">packageId	^(self tableNamed: 'TW_Package') fieldNamed: 'primaryKey'.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>instance creation</category><body package="Store-Database Model">modifyForPublicStore	| mapping |	self databaseIdentifier = #psql_public_cst		ifTrue: [			mapping := (self descriptorFor: StorePackage) mappingForAttributeNamed: #propertiesRecordDictionary.			mapping isNil ifTrue: [^self].			mapping shouldUseFilteredRead: false.			mapping := (self descriptorFor: StoreBundle) mappingForAttributeNamed: #propertiesRecordDictionary.			mapping shouldUseFilteredRead: false].</body><body package="Store-Database Model">setUpDefaults	"Adjust mappings for the (somewhat old, unupdated) Cincom Open Repository.  Call of databaseIdentifier ensures lazy getter caches value."	self modifyForPublicStore.	self platform configureSystemForStore: self.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>schema selection</category><body package="Store-Database Model">checkStoreVersionFor: aDatabaseAccessor	"Create the appropriate descriptor system for this login, by checking what version of store this appears to be."	aDatabaseAccessor isLoggedIn ifFalse: [aDatabaseAccessor login].	^self		checkStoreVersionFor: aDatabaseAccessor		forTable: 'TW_LoadRecord'		ifExistingUse: Store74DescriptorSystem		elseDo: 			[self				checkStoreVersionFor: aDatabaseAccessor				forTable: 'TW_PropertyRecord'				ifExistingUse: Store73DescriptorSystem				elseDo: 					[self						checkStoreVersionFor: aDatabaseAccessor						forTable: 'TW_DatabaseIdentifier'						ifExistingUse: StoreDescriptorSystem						elseDo: 							[self goToScriptOrCreateDatabaseTables								ifFalse: 									[Transcript show: self storeSchemaNotInstalledMessage.									Store.DbRegistry currentlyNotConnectedSignal raiseSignal]								ifTrue: 									[self installStoreDatabaseTablesUsing: aDatabaseAccessor currentLogin.									StoreDescriptorSystem newRepositoryDescriptorSystemClass forPlatform: aDatabaseAccessor platform]]]]</body><body package="Store-Database Model">checkStoreVersionFor: accessor forTable: tableName ifExistingUse: aClass elseDo: aBlock	"Create the appropriate descriptor system for this login, by checking what version of store this appears to be."	| schema |	schema := StoreDescriptorSystem 		platformSpecificSchemaFor: accessor		tableName: tableName.	^(accessor isExistingTable: tableName inSchema: schema)		ifTrue: [aClass forPlatform: accessor platform]		ifFalse: [aBlock value]</body><body package="Store-Database Model">platformSpecificSchemaFor: aDatabaseAccessor	| platformSpecificSchema |	platformSpecificSchema := aDatabaseAccessor schema notNil		ifTrue: [aDatabaseAccessor schema]		ifFalse: [''].	(aDatabaseAccessor platform isSQLServerPlatform) ifTrue:		[platformSpecificSchema := Store.Policies tableSpacePolicy defaultTableSpace].	^platformSpecificSchema</body><body package="Store-Database Model">platformSpecificSchemaFor: aDatabaseAccessor tableName: aString	| platformSpecificSchema |	platformSpecificSchema := aDatabaseAccessor schema notNil		ifTrue: [aDatabaseAccessor schema]		ifFalse: [''].	(aDatabaseAccessor platform isSQLServerPlatform) ifTrue:		[platformSpecificSchema := (self tableSpacesMap			at: aString asUppercase			ifAbsent: [Store.Policies tableSpacePolicy defaultTableSpace])].	^platformSpecificSchema</body><body package="Store-Database Model">storeSchemaNotInstalledMessage	^(#StoreSchemaNotInstalled &lt;&lt; #store		&gt;&gt; '&lt;n&gt;Store Schema is not installed in database.&lt;n&gt;Execute: &lt;nt&gt;''Store.DbRegistry installDatabaseTables''&lt;n&gt;')			expandMacros</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>connection detection</category><body package="Store-Database Model">goToScriptOrCreateDatabaseTables		^DbRegistry goToScript or: [RequestInstallDatabaseTables raiseSignal]</body><body package="Store-Database Model">userInputlExceptionsToIgnore		| list |	list := OrderedCollection new.	list add: RequestUniqueDatabaseIdentifierString.	list add: RequestInstallDatabaseTables.	list add: InstallUserManagementPolicies.	list add: RequestImageAdministatorName.	list add: UserManagementPoliciesNotInstalledNotice.	^list</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>store schema creation</category><body package="Store-Database Model">askToInstallUserManagementPoliciesIn: aSession		InstallUserManagementPolicies raiseSignal		ifTrue: [self installUserManagementPoliciesIn: aSession]		ifFalse:			[UserManagementPoliciesNotInstalledNotice raiseSignal.			self logDidNotCreateManagementPolicies]</body><body package="Store-Database Model">createTablesFor: aLogin	"Create the tables for this descriptor system in the given database. This will fail if the tables already exist. Use recreateTables for that."	| session accessor useBinding |	session := self sessionForLogin: aLogin.	accessor := session accessor.	Store.DbRegistry goToScript		ifTrue: [accessor logOnlyOn: Store.DbRegistry debugger debugStream]		ifFalse: [session login].	[[session platform supportsPhysicalSpaces		ifTrue: [self installPhysicalSpacesIn: session].	session createTables.	accessor logOnly ifTrue:	"We're just writing a script, so ensure we do not bind values"		[useBinding := accessor platform useBinding.		accessor platform useBinding: false].	[self createUniqueDatabaseIdentifierIn: session.	self askToInstallUserManagementPoliciesIn: session]		ensure:			[useBinding isNil ifFalse:				[accessor platform useBinding: useBinding]].	accessor grantStoreDeveloperSpecificPermissionsToUserOrRole: 'PUBLIC'.	(Warning raiseSignal: #VW76CanConnect &lt;&lt; #store &gt;&gt; 'Should VisuaWorks 7.6 and earlier images be able to connect to this database?') == true ifTrue:		[accessor createStoreSpecificViewsAndGrantViewPermissionsToUserOrRole: 'PUBLIC']]		ensure: [session logout]]		on: Error		do: [:ex| ex messageText = accessor platform installationCanceledMessage			ifTrue: [Transcript cr; nextPutAll: ex messageText]			ifFalse: [ex pass]]</body><body package="Store-Database Model">createUniqueDatabaseIdentifier: identifier in: aSession	| identifierObject |	identifierObject := StoreDatabaseIdentifier new.	^aSession inUnitOfWorkDo: 			[aSession register: identifierObject.			identifierObject name: identifier]</body><body package="Store-Database Model">createUniqueDatabaseIdentifierIn: aSession	| identifierString |	identifierString := RequestUniqueDatabaseIdentifierString raiseSignal.	^self createUniqueDatabaseIdentifier: identifierString in: aSession</body><body package="Store-Database Model">installPhysicalSpacesIn: aSession	aSession platform installPhysicalSpacesIn: aSession accessor.</body><body package="Store-Database Model">installStoreDatabaseTablesUsing: aLogin		[(InstallingDatabaseTables for: 'Store') started.	Store74DescriptorSystem createTablesFor: aLogin.	"Overridden to avoid errors if no VisualLauncher is open"	(InstallingDatabaseTables for: 'Store') finished] withStoreFeedbackOn: VisualLauncher singleInstanceWindow</body><body package="Store-Database Model">installUserManagementPolicies	self installUserManagementPoliciesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">installUserManagementPoliciesIn: aSession	| session admin |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	StoreUserGroup newGroupNamed: StoreUserGroup adminGroupName in: session.	StoreUserGroup newGroupNamed: 'QA' in: session.	admin := RequestImageAdministatorName raiseRequest.	StoreUserGroup newUserNamed: admin inGroupNamed: StoreUserGroup adminGroupName in: session</body><body package="Store-Database Model">isDefaultForNewRepository	^false</body><body package="Store-Database Model">logDidNotCreateManagementPolicies		DbRegistry printDebug:		(#YouDidNotCreatedUsStallUserManagement &lt;&lt; #store &gt;&gt;			'You did not create user management policies. To add user management policies later execute: ''StoreDescriptorSystem installUserManagementPolicies''') asString</body><body package="Store-Database Model">newRepositoryDescriptorSystemClass	NewRepositoryDescriptorSystemClass isNil		ifTrue: [NewRepositoryDescriptorSystemClass := Store74DescriptorSystem].	^NewRepositoryDescriptorSystemClass</body><body package="Store-Database Model">newRepositoryDescriptorSystemClass: aStoreDescriptorSystemSubclass	NewRepositoryDescriptorSystemClass := aStoreDescriptorSystemSubclass</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>class defaults</category><body package="Store-Database Model">databaseTableClass	^StoreDatabaseTable</body><body package="Store-Database Model">defaultCommonMaximumBlobRows	^5</body><body package="Store-Database Model">defaultValidateValue	^#never</body><body package="Store-Database Model">tableSpacesMap	| map |	map := Dictionary new.	map at: 'TW_BLOB' put: Store.Policies tableSpacePolicy blobTableSpace.	map at: 'TW_BINARYBLOB' put: Store.Policies tableSpacePolicy blobTableSpace.	map at: 'TW_METHODS' put: Store.Policies tableSpacePolicy methodsTableSpace.	map at: 'TW_METHOD' put: Store.Policies tableSpacePolicy methodsTableSpace.	map at: 'TW_DBUSERGROUP'  put: Store.Policies tableSpacePolicy userAndOwnershipTableSpace.	map at: 'TW_DBPUNDLEPRIVILEGES' put: Store.Policies tableSpacePolicy userAndOwnershipTableSpace.	^map</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>configuring</category><body package="Store-Database Model">useRecursionIfSupported	"If the platform supports recursive queries, do we use them (e.g. to read blob chains)?"	^UseRecursionIfSupported</body><body package="Store-Database Model">useRecursionIfSupported: aBoolean	"If the platform supports recursive queries, do we use them (e.g. to read blob chains)?"	UseRecursionIfSupported := aBoolean</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>descriptors</category><body package="Store-Database Model">addPropertiesMappingTo: aDescriptor	"Add the properties mapping. Different between versions of Store schema, but this one can have both"	| linkTable propertyTable propertiesMapping |	super addPropertiesMappingTo: aDescriptor.	linkTable := self tableNamed: 'TW_Properties'.	propertyTable := self tableNamed: 'TW_PropertyRecord'.	propertiesMapping := (aDescriptor newMapping: BasicDictionaryMapping)		attributeName: #propertiesRecordDictionary;		useLinkTable;		keyField: (propertyTable fieldNamed: 'name');		join: (Join 			from: (aDescriptor table fieldNamed: 'primaryKey')			to: (linkTable fieldNamed: 'pundleRef')			from: aDescriptor describedClass propertyTypeCode			to: (linkTable fieldNamed: 'recType'));		yourself.	propertiesMapping query alsoFetch: [:each | each definition].	"Make it more convenient to query development prerequisites"	aDescriptor oneToOneMapping		attributeName: #developmentPrerequisites;		beForPseudoVariable;		useLinkTable;		join: (Join 			from: (aDescriptor table fieldNamed: 'primaryKey')			to: (linkTable fieldNamed: 'pundleRef')			from: aDescriptor describedClass propertyTypeCode			to: (linkTable fieldNamed: 'recType')			from: 'developmentPrerequisites'			to: (propertyTable fieldNamed: 'name')).</body><body package="Store-Database Model">descriptorForStoreBundle: aDescriptor	super descriptorForStoreBundle: aDescriptor.	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #files.</body><body package="Store-Database Model">descriptorForStoreBundleFileRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Files'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping 		from: #bundleID		to: (table fieldNamed: 'bundleRef')).	aDescriptor addMapping: (DirectMapping 		from: #expressionID		to: (table fieldNamed: 'expressionID')).	aDescriptor addMapping: (DirectMapping 		from: #sequence		to: (table fieldNamed: 'seqNumber')).	aDescriptor addMapping: (DirectMapping 		from: #fileID		to: (table fieldNamed: 'fileRef'))</body><body package="Store-Database Model">descriptorForStoreFile: aDescriptor	| table filenameMapping |	table := self tableNamed: 'TW_FileRecord'.	aDescriptor table: table.	self addStandardStoreDescriptorTo: aDescriptor forTable: table andClass: StoreFile.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #contents;		join: (Join from: (table fieldNamed: 'fileID') to: self binaryBlobId).	(aDescriptor newMapping: DirectMapping) from: #fileSize to: (table fieldNamed: 'fileSize').	filenameMapping := (aDescriptor newMapping: DirectMapping) from: #filename to: (table fieldNamed: 'components').	filenameMapping query expectedRows: 1.		"not commonMaximumBlobRows - filename+path not routinely &gt; 32k."	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #fileID 		to: (table fieldNamed: 'fileID').</body><body package="Store-Database Model">descriptorForStoreProperty: aDescriptor	"We copy the first part of the comment blob's text into a searchString (as we cannot search blobs).  We set the converter to trim the Smalltalk-provided 'maximum possible length that could fit' string to be the maximum that will actually fit into the searchString's database field, since that is by definition the best we can do."	| table definitionMapping |	table := self tableNamed: 'TW_PropertyRecord'.	aDescriptor table: table.	self addStandardStoreDescriptorTo: aDescriptor forTable: table andClass: StoreProperty.	definitionMapping := (aDescriptor newMapping: OneToOneMapping)		attributeName: #definition;		join: (Join from: (table fieldNamed: 'definitionID') to: self blobId).	definitionMapping query expectedRows: self commonMaximumBlobRows.	(aDescriptor newMapping: DirectMapping)		from: #searchString to: (table fieldNamed: 'searchString');		converter: (self platform converterNamed: #stringToTrimmedString).</body><body package="Store-Database Model">descriptorForStorePundlePropertyRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Properties'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #pundleID				to: (table fieldNamed: 'pundleRef')).	aDescriptor addMapping: (DirectMapping from: #propertyID				to: (table fieldNamed: 'propertyRef')).	aDescriptor addMapping: (DirectMapping from: #recordType				to: (table fieldNamed: 'recType'))</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>tables</category><body package="Store-Database Model">allTableNames	^super allTableNames, #('TW_Files' 'TW_FileRecord' 'TW_PropertyRecord' 'TW_Properties')</body><body package="Store-Database Model">tableForTW_FILERECORD: aTable 	| fileId foreignKey versionField |	self createStandardAndVersionRecordFieldsIn: aTable.	versionField := aTable fieldNamed: 'version'.	versionField beNullable: true.	fileId := aTable createFieldNamed: 'fileID' type: platform int4.	fileId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: fileId to: self blobId.	"This is a foreignKey with a default 0, so we never put in database"	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'fileSize' type: platform int4.	aTable createFieldNamed: 'components' type: platform binary32k.	aTable propertyAt: #tableSpaceName put: StoreFile tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreFile tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_FILES: aTable 	| bundleRef fileRef |	bundleRef := aTable createFieldNamed: 'bundleRef' type: platform int4.	bundleRef bePrimaryKey.	aTable addForeignKeyFrom: bundleRef		to: ((self tableNamed: 'TW_Bundle') fieldNamed: 'primaryKey').	"This foreignKey is always in the same table space, so we always create it"	aTable createFieldNamed: 'expressionID' type: platform int4.	aTable createFieldNamed: 'seqNumber' type: platform int4.	fileRef := aTable createFieldNamed: 'fileRef' type: platform int4.	fileRef bePrimaryKey.	aTable addForeignKeyFrom: fileRef		to: ((self tableNamed: 'TW_FileRecord') fieldNamed: 'primaryKey').	"This foreignKey is always in the same table space, so we always create it"	aTable addIndexForField: fileRef.	aTable propertyAt: #tableSpaceName put: StoreFile tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreFile tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_METHOD: aTable 	| commentId |	super tableForTW_METHOD: aTable."	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	aTable addForeignKeyFrom: commentId		to: self blobId."</body><body package="Store-Database Model">tableForTW_PROPERTIES: aTable 	| pundleRef propertyRef foreignKey |	pundleRef := aTable createFieldNamed: 'pundleRef' type: platform int4.	pundleRef bePrimaryKey.	propertyRef := aTable createFieldNamed: 'propertyRef' type: platform int4.	propertyRef bePrimaryKey.	aTable addIndexForField: propertyRef.	(aTable addIndexForField: propertyRef and: pundleRef) name: 'Properties_GC'.	foreignKey := aTable addForeignKeyFrom: propertyRef		to: ((self tableNamed: 'TW_PropertyRecord') fieldNamed: 'primaryKey').	foreignKey name: 'TW_Props_TW_PropRec_PriKY'.	"This foreignKey is always in the same table space, so we always create it"	(aTable createFieldNamed: 'recType' type: platform int4) bePrimaryKey.	aTable propertyAt: #tableSpaceName put: StoreProperty tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreProperty tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_PROPERTYRECORD: aTable 	| definitionId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	definitionId := aTable createFieldNamed: 'definitionID' type: platform int4.	definitionId defaultValue: 0.	definitionId beIndexed.	foreignKey := aTable addForeignKeyFrom: definitionId to: self blobId.	foreignKey name: 'TW_PropRec_TW_Blob_DefID'.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	foreignKey name: 'TW_PropRec_TW_Blob_ComtID'.	"This foreignKey has a Default so we never create it"	foreignKey shouldCreateInDatabase: false.	(aTable createFieldNamed: 'environmentString' type: (platform varchar: 255)).	(aTable createFieldNamed: 'searchString' type: (platform varchar: 255)) beIndexed.	aTable propertyAt: #tableSpaceName put: StoreProperty tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreProperty tableSpaceName , '.' , session schema].</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>classes</category><body package="Store-Database Model">addPropertiesToClassModel: aClassModel	"Varies by schema version"	super addPropertiesToClassModel: aClassModel.	aClassModel newAttributeNamed: #propertiesRecordDictionary collection: Dictionary of: StoreProperty.	aClassModel newAttributeNamed: #developmentPrerequisites type: StoreProperty.</body><body package="Store-Database Model">classModelForStoreBundle: aClassModel	super classModelForStoreBundle: aClassModel.	aClassModel newAttributeNamed: #files collectionOf: StoreFile.</body><body package="Store-Database Model">classModelForStoreBundleFileRelationship: aClassModel	aClassModel newAttributeNamed: #bundleRef type: Integer.	aClassModel newAttributeNamed: #expressionId type: Integer.	aClassModel newAttributeNamed: #seqNumber type: Integer.	aClassModel newAttributeNamed: #fileRef type: Integer.</body><body package="Store-Database Model">classModelForStoreFile: aClassModel	self classModelForStoreSourceObject: aClassModel.	aClassModel newAttributeNamed: #contents type: StoreBinaryBlob.	aClassModel newAttributeNamed: #fileSize type: Integer.	aClassModel newAttributeNamed: #filename type: ByteArray.</body><body package="Store-Database Model">classModelForStoreProperty: aClassModel	self classModelForStoreSourceObject: aClassModel.	(aClassModel attributeNamed: #name) type: Symbol.	aClassModel newAttributeNamed: #definition type: StoreBlob.	aClassModel newAttributeNamed: #searchString type: String.</body><body package="Store-Database Model">constructAllClasses	^(super constructAllClasses)		add: StorePundlePropertyRelationship;		add: StoreFile;		add: StoreProperty;		add: StoreBundleFileRelationship;		yourself</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>testing</category><body package="Store-Database Model">hasMethodComments	"true"	^false.</body><body package="Store-Database Model">hasPropertiesAsBlob	^false.</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>testing</category><body package="Store-Change Management">belongsToClass	^self isInClass</body><body package="Store-Change Management">existsInImage	^self subclassResponsibility</body><body package="Store-Change Management">is: aRecord meaningfulChangeOf: aPackage	"Determine if modification is a meaningful change"	^aRecord == nil or: [self isMeaningfulChange: aRecord]</body><body package="Store-Change Management">isClassCommentTag	^false</body><body package="Store-Change Management">isClassTag	^false</body><body package="Store-Change Management">isCommentChange		^self isClassCommentTag | self isNameSpaceCommentTag</body><body package="Store-Change Management">isCommentTag		^self isClassCommentTag | self isNameSpaceCommentTag</body><body package="Store-Change Management">isComponentTag	^false</body><body package="Store-Change Management">isDataTag	^false</body><body package="Store-Change Management">isForClass	^false</body><body package="Store-Change Management">isForData	^false</body><body package="Store-Change Management">isForMethod	^false</body><body package="Store-Change Management">isForNameSpace	^false</body><body package="Store-Change Management">isInClass	^false</body><body package="Store-Change Management">isMeaningfulChange: aRecord	^aRecord sameAsImage not</body><body package="Store-Change Management">isMethodTag	^false</body><body package="Store-Change Management">isNameSpaceCommentTag	^false</body><body package="Store-Change Management">isNameSpaceTag	^false</body><body package="Store-Change Management">isPropertyTag	^false</body><body package="Store-Change Management">isStructureTag	^false</body><body package="Store-Change Management">isSubdefTag	^false</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: aRecord	"Load the change. Answer true is the operation is successful."	self subclassResponsibility</body><body package="Store-Change Management">canLoad	"Answer true if a record with my tag	can be load into the image.	For methods and meta classes the class has to be already	loaded."	^self actualClass notNil</body><body package="Store-Change Management">loadIntoPackage: aPackage from: aRecord 	"Make sure that modification goes to the proper package."	self canLoad		ifFalse: 			[ Dialog warn: ( (#DefinitionFor1sCaE2sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Definition for &lt;1s&gt; cannot be loaded since &lt;2s&gt; is not loaded.') expandMacrosWith: self printString with: symbol ).			^false 			].	Policies packagePolicy forcePackage: aPackage while: 		[ ^aRecord == nil			ifTrue: 				[ self existsInImage 					ifTrue: [ self removeFromSystemTolerant: false fromPackage: aPackage ].				true				]			ifFalse: [ self applyDefinitionFrom: aRecord ]		].</body><body package="Store-Change Management">removeFromSystem	self removeFromSystemTolerant: true fromPackage: self containingPackage</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>accessing</category><body package="Store-Change Management">absoluteName	^self name</body><body package="Store-Change Management">actual	^self actualClass</body><body package="Store-Change Management">actualClass	"Answer the class in the image that the reciever applies to. nil if none."	^symbol asStrictReference ifDefinedDo: 		[ :cls | self isMeta 					ifTrue: [ cls class ]					ifFalse: [ cls ].		].</body><body package="Store-Change Management">class: aClass	isMeta := aClass isMeta.	symbol := 		( isMeta 			ifTrue: [ aClass soleInstance ] 			ifFalse: [aClass]		) absoluteName asSymbol</body><body package="Store-Change Management">className	"Return the name as a string, in 'Foo' or 'Foo class' form."	^self isMeta ifTrue: [symbol asString, ' class'] ifFalse: [symbol asString]</body><body package="Store-Change Management">className: aClassName 	"Set the class from a name string."	symbol := aClassName asClassNameOnly asSymbol</body><body package="Store-Change Management">classSymbol	^symbol</body><body package="Store-Change Management">classSymbol: aSymbol	symbol := aSymbol asClassNameOnly asSymbol</body><body package="Store-Change Management">containingPackage	"Answer a packge that contians the defintion described by me."	^self subclassResponsibility</body><body package="Store-Change Management">description	self subclassResponsibility</body><body package="Store-Change Management">fullClassName	^symbol</body><body package="Store-Change Management">isMeta	^isMeta</body><body package="Store-Change Management">isMeta: aBoolean	isMeta := aBoolean</body><body package="Store-Change Management">meta: aBoolean	isMeta := aBoolean</body><body package="Store-Change Management">name	"Return the name as a string."	^symbol asString</body><body package="Store-Change Management">name: aName 	"Set the class/namespace from a name string."	symbol := aName asSymbol.</body><body package="Store-Change Management">nonMetaClassName	^symbol asClassNameOnly asSymbol</body><body package="Store-Change Management">package: aPackage	"most of us don't need this"</body><body package="Store-Change Management">sourceTextForImage	^self subclassResponsibility</body><body package="Store-Change Management">sourceTextForImage: aPackage	^self sourceTextForImage</body><body package="Store-Change Management">symbol	^symbol</body><body package="Store-Change Management">symbol: aSymbol	symbol := aSymbol</body><body package="Store-Change Management">tagBaseIndex	^self class tagBaseIndex</body><body package="Store-Change Management">tagIndex	^self tagBaseIndex + 		( self isMeta			ifTrue: [self class metaOffset ]			ifFalse: [0]		)</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>printing</category><body package="Store-Change Management">printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self name.	aStream nextPut: $].</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>actions</category><body package="Store-Change Management">browseVersions	Dialog warn: (#NotYetImplemented &lt;&lt; #store &gt;&gt; 'Not yet implemented')</body><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	self subclassResponsibility.	^nil</body><body package="Store-Change Management">moveFromPackage: oldPackage toPackage: newPackage 	self moveFromPackage: oldPackage toPackage: newPackage	ifNotLoaded: 		[self error: (#AttemptingToMoveADNThatIsNotLoaded &lt;&lt; #store &gt;&gt; 'Attempting to move a definition that is not loaded.')]</body><body package="Store-Change Management">moveFromPackage: oldPackage toPackage: newPackage ifNotLoaded: aBlock	^self moveToPackage: newPackage ifNotLoaded: aBlock</body><body package="Store-Change Management">moveToPackage: newPackage 	self moveToPackage: newPackage	ifNotLoaded: 		[self error: (#AttemptingToMoveADNThatIsNotLoaded &lt;&lt; #store &gt;&gt; 'Attempting to move a definition that is not loaded.')]</body><body package="Store-Change Management">moveToPackage: newPackage ifNotLoaded: aBlock  	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersion	^self subclassResponsibility</body><body package="Store-Change Management">browseSystemVersionIfExists	"Open a browser on the system version of this override if possible.	 Answer if it was possible."	self existsInImage		ifFalse: [ ^false ].	self browseSystemVersion.	^true</body><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord in: aPackage	"Fileout the change onto aStream."		(aRecord == nil and: [self existsInImage not]) ifTrue: 		[^self fileOutRemovalOn: aStream].	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[(aStream sourceFormatter)			attributeFor: #package compute: [:ignore | aPackage name];			attributeForMethods: #package compute: [:ignore :moreIgnore | aPackage name]].	aRecord isNil 		ifTrue: [self fileOutOn: aStream] 			ifFalse: [self fileOutOn: aStream from: aRecord]</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#other</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>converting</category><body package="Store-Change Management">asChange	"Answer the receiver as an instance of Change."	^Change new classSymbol: self classSymbol.		"good enough for most"</body><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>comparing</category><body package="Store-Change Management">= aTag	| obj |	aTag class == self class		ifFalse: [^false].	obj := self actual.	^obj notNil		ifTrue: [obj == aTag actual]		ifFalse:			[aTag class == self class and:				[symbol == aTag symbol and: [isMeta == aTag isMeta]]]</body></methods><methods><class-id>Store.AbstractTag class</class-id> <category>accessing</category><body package="Store-Change Management">classTagIndices	"The indices for class like things (no subsequent key)."	"Class, Class comment, Meta-Class, Meta-Class comment"	^Array 		with: ClassTag tagBaseIndex		with: ClassCommentTag tagBaseIndex		with: ClassTag tagBaseIndex + self metaOffset		with: ClassCommentTag tagBaseIndex + self metaOffset.</body><body package="Store-Change Management">componentTagIndices	"The indices for component related things, like properties 	and bundle structure."	^Array 		with: PropertyTag tagBaseIndex		with: BundleStructureTag tagBaseIndex</body><body package="Store-Change Management">maxTagIndex	^11</body><body package="Store-Change Management">metaOffset	"Offset added to class and class methods to get meta side"	^4</body><body package="Store-Change Management">nameSpaceTagIndices	"The indices for namespace like things (no subsequent key)."	"NameSpace, NameSpace comment (?)"	^Array 		with: NameSpaceTag tagBaseIndex		with: NameSpaceCommentTag tagBaseIndex</body><body package="Store-Change Management">subdefTagIndices	"The indices for method like things (subsequent key)."	"instance methods, data, class methods"	^( OrderedCollection 			with: MethodTag tagBaseIndex			with: DataTag tagBaseIndex				with: MethodTag tagBaseIndex + self metaOffset	  ) addAll: self componentTagIndices;	    asArray</body><body package="Store-Change Management">tagBaseIndex	"Answer the unique index for each subclass."	^self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag class</class-id> <category>instance creation</category><body package="Store-Change Management">newClass: aClass	^self new class: aClass</body><body package="Store-Change Management">newClassName: aString	^self new className: aString</body><body package="Store-Change Management">newClassName: aString  isMeta: aBoolean	^self new className: aString;  isMeta: aBoolean</body><body package="Store-Change Management">newClassSymbol: aSymbol isMeta: aBoolean	^self new classSymbol: aSymbol; isMeta: aBoolean</body></methods><methods><class-id>Store.DataTag</class-id> <category>testing</category><body package="Store-Change Management">existsInImage	| own |	^( own := self owner ) ~~ nil		and: [ own includesDataKey: self dataKey ]</body><body package="Store-Change Management">isDataTag	^true</body><body package="Store-Change Management">isForData	^true</body><body package="Store-Change Management">isInClass	^( forClass == nil ) | forClass</body><body package="Store-Change Management">isSubdefTag	^true</body></methods><methods><class-id>Store.DataTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: aRecord 	"Load the new data."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body></methods><methods><class-id>Store.DataTag</class-id> <category>accessing</category><body package="Store-Change Management">actual	^self bindingReference</body><body package="Store-Change Management">containingPackage	"Answer a packge that contians the data described by me."	^ Registry containingPackageForDataKey: self dataKey symbol: symbol.</body><body package="Store-Change Management">dataKey	^dataKey asSymbol</body><body package="Store-Change Management">dataKey: aSymbol	dataKey := aSymbol</body><body package="Store-Change Management">description	^dataKey , ' (shared variable)'</body><body package="Store-Change Management">environmentString	^symbol asString</body><body package="Store-Change Management">forClass: aBoolean	forClass := aBoolean.</body><body package="Store-Change Management">isMeta	^false</body><body package="Store-Change Management">name	^symbol, '.', dataKey</body><body package="Store-Change Management">owner		"Answers the owning class/namespace"	^self actualClass</body><body package="Store-Change Management">ownerName		"Answers the owning class/namespace"	^symbol</body><body package="Store-Change Management">sourceTextForImage	| owner |	^( owner := self owner ) == nil		ifTrue: [ nil ]		ifFalse: [ owner asNameSpace definitionOf: self dataKey ifAbsent: [ nil ] ]</body><body package="Store-Change Management">symbolKey	^dataKey</body></methods><methods><class-id>Store.DataTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag.  Return True if sucessful and False on failure."	| changed |	Cursor execute showWhile: 		[ changed := Object evaluatorClass 				evaluate: someText string				notifying: aController				logged: true		].	^changed ~~ nil"  was...	Dialog warn: 'The text representation of data cannot be used to generate data.'.	^false"</body><body package="Store-Change Management">moveToPackage: newPackage ifNotLoaded: aBlock 	| owner | 	owner := self owner.	( owner notNil and: [ owner includesDataKey: self dataKey ] )		ifTrue: [ XChangeSet current					moveDataKey: self dataKey					owner: owner					toPackage: newPackage				]		ifFalse: [ aBlock value ]</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	| owner |	owner := self owner.	owner isNil 		ifTrue: 			[tolerantBoolean 				ifFalse: 					[self 						error: (#_1sDoesNotExistInTheImage &lt;&lt; #store 								&gt;&gt; '&lt;1s&gt; does not exist in the image.' expandMacrosWith: symbol)]]		ifFalse: 			[(aPackage hasDataKey: self dataKey in: owner) 				ifTrue: 					[((Override 						unloadDataKey: self dataKey						in: owner						from: aPackage) not 						and: [tolerantBoolean not]) 							ifTrue: 								[(owner asNameSpace includesKey: self dataKey) 									ifFalse: 										[self 											error: (#Quotes1sDoesNotExistInTheImage &lt;&lt; #store 													&gt;&gt; '"&lt;1s&gt;" does not exist in the image.' expandMacrosWith: self name)]]]]</body></methods><methods><class-id>Store.DataTag</class-id> <category>change list support</category><body package="Store-Change Management">bindingReference	^BindingReference pathString: self owner fullName, '.', self dataKey.</body><body package="Store-Change Management">browseSystemVersion	"Open a browser on the system version of this shared variable definition."	|bindingReference|	bindingReference := self bindingReference.	bindingReference isDefined ifFalse: [^self].	SmalltalkWorkbench browseBindingReference: bindingReference</body><body package="Store-Change Management">fileOutObjectType	^#variable</body><body package="Store-Change Management">fileOutOn: aStream	"Fileout the change onto aStream."	| owner obj |	( owner := self owner ) == nil		ifTrue: [ ^nil ].	obj := owner asNameSpace fullyQualifiedReferenceOf: dataKey.	aStream storeObjectDefinition: obj.	obj fileOutInitializerOn: aStream.</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutOn: aStream.</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	aStream removeObject: symbol, '.', dataKey type: self fileOutObjectType</body></methods><methods><class-id>Store.DataTag</class-id> <category>converting</category><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForDataTag: self.</body></methods><methods><class-id>Store.DataTag</class-id> <category>comparing</category><body package="Store-Change Management">= aTag	^super = aTag and:		[dataKey == aTag dataKey and: [self isInClass == aTag isInClass]]</body></methods><methods><class-id>Store.DataTag class</class-id> <category>instance creation</category><body package="Store-Change Management">newClassName: aString dataKey: dataKey	^self new 		className: aString; 		isMeta: false; 		dataKey: dataKey;		forClass: true.</body><body package="Store-Change Management">newClassSymbol: aSymbol dataKey: dataKey	^self new 		classSymbol: aSymbol; 		isMeta: false; 		dataKey: dataKey;		forClass: true.</body><body package="Store-Change Management">newNameSpaceName: aString dataKey: dataKey	^self new 		name: aString; 		isMeta: false; 		dataKey: dataKey;		forClass: false.</body><body package="Store-Change Management">newNameSpaceSymbol: aSymbol dataKey: dataKey	^self new 		symbol: aSymbol; 		isMeta: false; 		dataKey: dataKey;		forClass: false.</body></methods><methods><class-id>Store.DataTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^4</body></methods><methods><class-id>Store.MergingMayCausePublish</class-id> <category>private - actions</category><body package="Store-Merge Management">defaultAction	^Dialog 		choose: (#x1snn2QIsAreNotLoadedContinuingWillCauseLoading &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&lt;nn&gt;&lt;2?Is:Are&gt; not currently loaded in the image.&lt;nn&gt;Continuing will load these Packages and/or Bundles&lt;n&gt;'			expandMacrosWith: messageText			with: parameter)		labels: (Array with: (#LoadMissingAndContinue &lt;&lt; #store &gt;&gt; 'Load Missing and Continue') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))		values: #(#continue #cancel)		default: #continue</body></methods><methods><class-id>Store.MergingMayCausePublish</class-id> <category>constants</category><body package="Store-Merge Management">defaultResumeValue	^#continue</body></methods><methods><class-id>Store.MergingMayCausePublish class</class-id> <category>testing</category><body package="Store-Merge Management">mayResume	^true</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>event driven</category><body package="Store-UI">getEventHandler		^self</body><body package="Store-UI">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-UI">handlerForMouseEvent: aMouseEvent	^(super handlerForMouseEvent: aMouseEvent)		ifNil: [(self containsMouseEvent: aMouseEvent) ifTrue: [self] ifFalse: [nil]]</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>private</category><body package="Store-UI">computeFrameFor: aChild in: rect	| left right bottom top |	top := (aChild propertyAt: #row) * self lineGrid.	bottom := top + self lineGrid.	right := (aChild propertyAt: #column) * rect width half + rect left.	left := right - rect width half				+ ((aChild propertyAt: #indent) * self indentGrid).	^(left @ top corner: right @ bottom) rounded insetBy: 3 @ 0</body><body package="Store-UI">highlightRectangle	targetView ifNil: [^nil].	^(targetView frame origin leftBy: 3) corner: targetView frame corner</body><body package="Store-UI">iconFor: aCodeComponent	^aCodeComponent isImageModel		ifTrue: [aCodeComponent toolListIcon]		ifFalse: 			[aCodeComponent isBundle				ifTrue: [BehaviorIcons BundleDisconnected]				ifFalse: [BehaviorIcons PackageDisconnected]]</body><body package="Store-UI">indentGrid	^15</body><body package="Store-UI">isPressed: aBoolean	aBoolean == isPressed ifTrue: [^self].	isPressed := aBoolean.	self highlightRectangle ifNotNil: [:rect | self invalidateRectangle: rect]</body><body package="Store-UI">left: aLeftComponent right: aRightComponent enumerateChildren: a2ArgBlock	| diff |	diff := SequenceableCollectionDifferences new				comparisonFunction: [:a :b | a name = b name and: [a isBundle = b isBundle]].	(diff differencesFrom: aLeftComponent containedItems		to: aRightComponent containedItems) do: 				[:eachDifference |				eachDifference isInsert					ifTrue: [eachDifference do: [:each | a2ArgBlock value: nil value: each]].				eachDifference isMatch					ifTrue: 						[eachDifference do: 								[:eachLeft |								a2ArgBlock value: eachLeft									value: (self partnerFor: eachLeft in: aRightComponent)]].				eachDifference isDelete					ifTrue: [eachDifference do: [:each | a2ArgBlock value: each value: nil]]]</body><body package="Store-UI">lineGrid	^20</body><body package="Store-UI">minorDeviationOfColor: aPaint	| baseColor |	baseColor := aPaint asColorValue.	^baseColor brightness = 1		ifTrue: 			[ColorValue				hue: baseColor hue				saturation: baseColor saturation				brightness: 0.97]		ifFalse: 			[ColorValue				hue: baseColor hue				saturation: baseColor saturation				brightness: (baseColor brightness + 0.03 min: 1)]</body><body package="Store-UI">partnerFor: aChildComponent in: anOppositeContainer	^aChildComponent		ifNotNil: 			[anOppositeContainer containedItems detect: 					[:eachChild |					eachChild name = aChildComponent name						and: [aChildComponent isBundle = eachChild isBundle]]				ifNone: [nil]]</body><body package="Store-UI">targetView: aChild	| rectangles |	targetView == aChild ifTrue: [^self].	rectangles := OrderedCollection new.	self highlightRectangle ifNotNil: [:rect | rectangles add: rect].	targetView := aChild.	self highlightRectangle ifNotNil: [:rect | rectangles add: rect].	rectangles		do: [:each | self invalidateRectangle: (each expandedBy: 4 @ 0)]</body><body package="Store-UI">versionString: aCodeComponent	^aCodeComponent isImageModel		ifTrue: [(aCodeComponent traceVersionString allButLast: 1) allButFirst: 1]		ifFalse: [aCodeComponent simpleVersionString]</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>view construction</category><body package="Store-UI">addLeft: aLeftComponent partner: aLeftPartner right: aRightComponent partner: aRightPartner indent: anIndent row: aRowIndex	"The partner arguments are the corresponding entity (same version or not) from the same container, it may not be on the same row as the component, if reording has taken place. This method is the workhorse of the tree traversal, if one side or another is nil, then there is no corresponding part to traverse in parallel, so we branch off into solo mode. This method returns the number of rows it added. If both are non nil, then we add views on both sides, and then use special enumeration method."	| rowsAdded |	aLeftComponent		ifNil: 			[^self				addSolo: aRightComponent				partner: aRightPartner				column: 2				indent: anIndent				row: aRowIndex].	aRightComponent		ifNil: 			[^self				addSolo: aLeftComponent				partner: aLeftPartner				column: 1				indent: anIndent				row: aRowIndex].	self		addView: aLeftComponent		partner: aLeftPartner		column: 1		indent: anIndent		row: aRowIndex.	self		addView: aRightComponent		partner: aRightPartner		column: 2		indent: anIndent		row: aRowIndex.	rowsAdded := 1.	self		left: aLeftComponent		right: aRightComponent		enumerateChildren: 			[:leftChild :rightChild |			rowsAdded := rowsAdded + (self								addLeft: leftChild								partner: (self partnerFor: leftChild in: aRightComponent)								right: rightChild								partner: (self partnerFor: rightChild in: aLeftComponent)								indent: anIndent + 1								row: aRowIndex + rowsAdded)].	^rowsAdded</body><body package="Store-UI">addSolo: aCodeComponent partner: anOppositePartner column: aColumnIndex indent: anIndent row: aRowIndex	"We're in a mode where we're adding solely to one column for aCodeComponent and all of its children."	| rowsAdded |	self		addView: aCodeComponent		partner: anOppositePartner		column: aColumnIndex		indent: anIndent		row: aRowIndex.	rowsAdded := 1.	aCodeComponent containedItems do: 			[:child |			rowsAdded := rowsAdded + (self								addSolo: child								partner: nil								column: aColumnIndex								indent: anIndent + 1								row: aRowIndex + rowsAdded)].	^rowsAdded</body><body package="Store-UI">addView: aCodeComponent partner: anOppositeComponent column: aColumnIndex indent: anIndent row: aRowIndex	"This is where we put the view together for the given parameters."	| newView nameText versionText |	newView := Panel new beRow: 0.5 gap: 4.	nameText := aCodeComponent name asText.	versionText := (self versionString: aCodeComponent) asText.	anOppositeComponent		ifNil: 			[nameText := nameText emphasizeAllWith: (aColumnIndex = 1								ifTrue: [TextFragment emphasisForDelete]								ifFalse: [TextFragment emphasisForInsert])]		ifNotNil: 			[(self isSame: anOppositeComponent versionAs: aCodeComponent)				ifFalse: 					[versionText := versionText emphasizeAllWith: (aColumnIndex = 1										ifTrue: [TextFragment emphasisForDelete]										ifFalse: [TextFragment emphasisForInsert])]].	newView		add: (self iconFor: aCodeComponent);		add: nameText;		add: '(' asText , versionText , ')' asText.	newView		propertyAt: #codeComponent put: aCodeComponent;		propertyAt: #codeComponentPeer put: anOppositeComponent;		propertyAt: #column put: aColumnIndex;		propertyAt: #row put: aRowIndex;		propertyAt: #indent put: anIndent.	self add: newView</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>menu</category><body package="Store-UI">browseMenuTarget	self selectedCodeComponent isImageModel		ifTrue:			[(Refactory.Browser.BrowserEnvironment new				forCodeComponents: (Array with: self selectedCodeComponent)) openEditor]		ifFalse:			[(StoreForGlorpBrowserEnvironment				on: self selectedCodeComponent) openEditor].</body><body package="Store-UI">fileoutChangesToGetToMenuTarget	| dialog targetFile session comparitor fileManager menuTarget |	menuTarget := self selectedCodeComponent.	dialog := SaveFileDialog new.	dialog		addFileFilter: 'Smalltalk source (*.st)' pattern: '*.st';		fileCondition: #new;		defaultFilename: (Filename					filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st'							expandMacrosWith: menuTarget name))						asFilename.	(targetFile := dialog select) ifNil: [^self].	session := StoreLoginFactory currentStoreSession.		[(Store.FilingOut for: menuTarget) started.	comparitor := Store.PackageComparitor				differencesWithPropertiesBetween: (self selectedCodeComponentPeer						asStoreComparisonObjectIn: session)				and: (menuTarget asStoreComparisonObjectIn: session).	fileManager := SourceCodeStream write: targetFile encoding: #Source.		[fileManager timeStamp.	fileManager sourceFormatter attributeFor: #package		compute: [:ignore | menuTarget name].	fileManager sourceFormatter attributeForMethods: #package		compute: [:ignore :igmore | menuTarget name].	comparitor fileOutMainToOtherDifferencesOn: fileManager]			ensure: [fileManager close].	(Store.FilingOut for: menuTarget) finished]			withStoreFeedbackOn: self topComponent</body><body package="Store-UI">menu		| menu |	menu := Menu new.	menu		augmentFrom: self class		to: self class		menuName: #menu		for: self.	^menu</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>displaying</category><body package="Store-UI">displayBackgroundStripeOn: aGC	| box clip oldPaint strip |	box := self bounds.	clip := aGC clippingBounds.	oldPaint := aGC paint.	aGC		paint: (self minorDeviationOfColor: SymbolicPaint background asColorValue).	0 to: self children last frame top		by: self lineGrid * 2		do: 			[:y |			strip := box left @ y extent: box width @ self lineGrid.			(strip intersects: clip) ifTrue: [aGC displayRectangle: strip]].	aGC paint: oldPaint</body><body package="Store-UI">displayOn: aGC	self displayBackgroundStripeOn: aGC.	self displayTargetOn: aGC.	super displayOn: aGC</body><body package="Store-UI">displayTargetOn: aGC	| oldPaint highlightRect |	targetView ifNil: [^self].	oldPaint := aGC paint.	highlightRect := self highlightRectangle.	isPressed		ifTrue: 			[aGC				paint: SymbolicPaint selectionBackground;				displayRectangle: highlightRect].	aGC		paint: (SymbolicPaint background asColorValue					blendWith: SymbolicPaint selectionForeground asColorValue					weight: 0.2);		displayRectangularBorder: (highlightRect origin					corner: highlightRect corner - 1).	aGC paint: oldPaint</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>public</category><body package="Store-UI">left: aLeftBundle right: aRightBundle	"Shut down updating while we're building, otherwise we may add views that don't have enough properties for our layout algorithm."	isInUpdate := true.	self		addLeft: aLeftBundle		partner: aRightBundle		right: aRightBundle		partner: aLeftBundle		indent: 0		row: 0.	isInUpdate := false.	self relayout</body><body package="Store-UI">openScrolledWindow	"Open a window around me with a vertical scroll bar."	| scroller |	scroller := BorderDecorator on: self.	scroller		noHorizontalScrollbar;		noBorder;		useVerticalScrollbar.	(ScheduledWindow new)		useDisplayBuffer;		label: #CompareBundleStructure &gt;&gt; 'Compare Bundle Structure' &lt;&lt; #IDE;		component: scroller;		openWithExtent: 800 @ self preferredHeight</body><body package="Store-UI">selectedCodeComponent	"Returns the current codeComponent that the menu was raised over."	^targetView ifNotNil: [targetView propertyAt: #codeComponent]</body><body package="Store-UI">selectedCodeComponentPeer	"Returns the otherside commpliment to the selectedCodeComponentPeer. It may be nil."	^targetView ifNotNil: [targetView propertyAt: #codeComponentPeer]</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	isPressed := false.	targetView := nil</body><body package="Store-UI">initializeLayoutAlgorithm	self layoutAlgorithm: 			[:rect :views |			views collect: [:each | self computeFrameFor: each in: rect]]</body><body package="Store-UI">scrollOffsetHolder: aScrollOffsetHolder	aScrollOffsetHolder grid: 1 @ self lineGrid</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>testing</category><body package="Store-UI">isLeftSideSelection	^(targetView propertyAt: #column) = 1</body><body package="Store-UI">isSame: aCodeComponent versionAs: anotherComponent	"Have to treat inImageModel's specially."	anotherComponent isImageModel		ifTrue: 			[^anotherComponent hasBeenModified not				and: [anotherComponent dbTrace = aCodeComponent primaryKey]].	aCodeComponent isImageModel		ifTrue: 			[^aCodeComponent hasBeenModified not				and: [aCodeComponent dbTrace = anotherComponent primaryKey]].	^aCodeComponent = anotherComponent</body><body package="Store-UI">isSelectedPeerDifferent	^(self selectedCodeComponent notNil		and: [self selectedCodeComponentPeer notNil]) and: 				[(self isSame: self selectedCodeComponent					versionAs: self selectedCodeComponentPeer) not]</body></methods><methods><class-id>ShadowNameSpaceBuilder</class-id> <category>creation</category><body package="Atomic Compiling and Loading">createShadowRoot	"Create and answer an instance of the shadowed Root, populated with the existing NameSpace heirarachy.	First we carefully populate the Root namespace for any other than itself and Smalltalk rooted namspaces."		| smalltalk visited |	root := self createShadowOf: Root.	self createVariableBindingFor: root environment: root.	root environment: nil.	smalltalk := self setupShadowSmalltalk.	visited := OrderedCollection new.	(Root nameSpaces reject: [:each | each = Root or: [each = Smalltalk]]) do: 		[:eachRootedNamespace | 		self populateShadow: eachRootedNamespace parent: root visited: visited].	Smalltalk nameSpaces do: 		[:eachRegularNamespace | 		self populateShadow: eachRegularNamespace parent: smalltalk visited: visited].	^root</body></methods><methods><class-id>ShadowNameSpaceBuilder</class-id> <category>private</category><body package="Atomic Compiling and Loading">createShadowOf: aNameSpace 	^NameSpace new 			name: aNameSpace name asSymbol;			imports: aNameSpace importString;			yourself</body><body package="Atomic Compiling and Loading">createVariableBindingFor: nameSpaceName environment: parentNameSpace 	| vb |	vb := VariableBinding key: nameSpaceName name asSymbol value: nameSpaceName.	vb setReservedFlag: true.	parentNameSpace simpleAddBinding: vb.	nameSpaceName environment: parentNameSpace.	^vb</body><body package="Atomic Compiling and Loading">populateShadow: nameSpace parent: parent visited: visited 	| shadowSpace variableBinding |	( visited includes: nameSpace ) 		ifTrue: [ ^self ].	visited addLast: nameSpace.	shadowSpace := self createShadowOf: nameSpace.	variableBinding := self createVariableBindingFor: shadowSpace environment: parent.	"We need to ensure that the binding is actually marked as a 	 NameSpace binding."	variableBinding forNameSpace.	nameSpace nameSpaces do: 		[:localNameSpace | 		self 			populateShadow: localNameSpace			parent: shadowSpace			visited: visited		]</body><body package="Atomic Compiling and Loading">setupShadowSmalltalk	"Create and return the shadow of Smalltalk as a special 	 case, ensuring that it is linked to Root properly."	| smalltalk variableBinding |	smalltalk := self createShadowOf: Smalltalk.	variableBinding := self createVariableBindingFor: smalltalk environment: root.	variableBinding forNameSpace.	self createVariableBindingFor: smalltalk environment: smalltalk.	self createVariableBindingFor: root environment: smalltalk.	root environment: nil.	smalltalk environment: root.	^smalltalk</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-utilities</category><body package="Store-Broker-Obsolete">answerFromQuery: aSQLString bindInput: anObject	^self process: aSQLString bindInput: anObject.</body><body package="Store-Broker-Obsolete">existsInDatabase: anObj	| res |	res := self process: 				(( self newSQLFor: anObj class)					selectCountAll;					whereSqlString)  bindInput: anObj.	^res first first &gt; 0</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>drop objects</category><body package="Store-Broker-Obsolete">dropDatabaseFor: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">dropIndexForClass: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">dropIndexForClass: aClass index: aName	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">dropSequenceForClass: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">dropTable: aTable 		Transcript cr; show: 'Dropping table ' , aTable.	self performDrop: [self processSQL: 'DROP TABLE ' , aTable]</body><body package="Store-Broker-Obsolete">dropTableForClass: aClass 	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">dropUser: aName	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">dropView: aViewName	self performDrop: [self processSQL:  ('DROP VIEW ' , aViewName) asString]</body><body package="Store-Broker-Obsolete">dropViewForClass: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">performDrop: aBlock		[aBlock value]		on: Error		do:			[:exception | 			(self doesNotExistErrors includes: exception parameter first dbmsErrorCode)				ifTrue:					[Transcript cr; show: exception parameter first dbmsErrorString.					exception return]				ifFalse:					[exception appendNewLineToMessageText: (self messageFor: exception).					self registry goOffLine.					exception pass]]</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>grant statements</category><body package="Store-Broker-Obsolete">grant: aPermissionList on: aTableName columnList: aColumnList  to: aUserNameList	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">grant: aPermissionList on: aTableName to: aUserNameList	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  (' ON ' , aTableName, ' TO ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.		self processGrantStatement: aStream contents.</body><body package="Store-Broker-Obsolete">grant: aStatementList to: aNameList	|  aStream |		aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aStatementList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  ' TO ' .	aNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	self processGrantStatement: aStream contents.</body><body package="Store-Broker-Obsolete">grantAllForClass: aClass to: aUserName	self processGrantStatement:  'GRANT ALL ON ',  (self tableNameWithPrefix: aClass), ' TO ', aUserName.</body><body package="Store-Broker-Obsolete">grantAllTo: aName	self processGrantStatement:  'GRANT ALL TO ', aName.</body><body package="Store-Broker-Obsolete">grantForClass: aClass permissions: aPermissionList columns: aColumnList toUsers: aUserNameList	self grant:aPermissionList		on: (self tableNameWithPrefix: aClass)		columnList: (self columnList: aColumnList for: aClass)		to: aUserNameList</body><body package="Store-Broker-Obsolete">grantForClass: aClass permissions: aPermissionList toUsers: aUserNameList	self grant: aPermissionList on: (self tableNameWithPrefix: aClass) to: aUserNameList.</body><body package="Store-Broker-Obsolete">grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList	self grant: aPermissionList on: (self sequenceNameWithPrefix: aClass) to: aUserNameList.</body><body package="Store-Broker-Obsolete">processGrantStatement: aString	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">processRevokeStatement: aString		[self processSQL: aString]		on: Error		do:			[:exception | 			exception appendNewLineToMessageText: (self messageFor: exception).			exception pass]</body><body package="Store-Broker-Obsolete">revoke: aPermissionList on: aTableName from: aUserNameList	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'REVOKE ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  (' ON ' , aTableName, ' FROM ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.		self processRevokeStatement: aStream contents.</body><body package="Store-Broker-Obsolete">revokeForClass: aClass permissions: aPermissionList fromUsers: aUserNameList	self revoke: aPermissionList on: (self tableNameWithPrefix: aClass) from: aUserNameList.</body><body package="Store-Broker-Obsolete">setDatabasePrivilegesForTable: aClass	"Defines who can do what wtih the table"	| aColl |	self grantForClass: aClass permissions: #('INSERT' 'SELECT' ) toUsers: #('PUBLIC').	aColl := self allUpdatableColumnsFor: aClass.	aColl isEmpty 		ifFalse: [ self grantForClass: aClass permissions: #('UPDATE') columns: aColl toUsers: #('PUBLIC').].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-accessing</category><body package="Store-Broker-Obsolete">closeConnection	self registry closeConnection</body><body package="Store-Broker-Obsolete">dismissSession: aSession	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">getNewSession	^ self connection getSession</body><body package="Store-Broker-Obsolete">reconnect	self registry reconnect</body><body package="Store-Broker-Obsolete">resetSessionCursorFor: aSession	^self</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>connection class</category><body package="Store-Broker-Obsolete">connectionClass	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>error handling</category><body package="Store-Broker-Obsolete">alreadyExistErrors	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">brokerSignals	"self brokerSignals"	self subclassResponsibility.</body><body package="Store-Broker-Obsolete">cannotCloseCursorErrorCode	"Answer a number that database uses in case whe the cursor cannot be closed."		^self subclassResponsibility</body><body package="Store-Broker-Obsolete">currentlyNotConnectedSignal	^self registry currentlyNotConnectedSignal</body><body package="Store-Broker-Obsolete">doesNotExistErrors	^#()</body><body package="Store-Broker-Obsolete">errorSignals	^self registry errorSignals</body><body package="Store-Broker-Obsolete">indexConflictSignal	^ self connectionClass indexConflictSignal</body><body package="Store-Broker-Obsolete">invalidObjectErrorNumber	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">notConnectedSignal	^self registry notConnectedSignal</body><body package="Store-Broker-Obsolete">objectAlreadyExistisErrorNumber	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">objectAlreadyGoneErrorNumber	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">reconnectSignals: ex	"Should we offer the user the choice of reconnecting when we get this signal. By default, yes to everything"	^true.</body><body package="Store-Broker-Obsolete">serverDiedErrorCodes	"Answer a number that database uses in case of 	server going away while we are connected."	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>accessing</category><body package="Store-Broker-Obsolete">connection	^self registry connection</body><body package="Store-Broker-Obsolete">connectionOrNil	^self registry connectionOrNil</body><body package="Store-Broker-Obsolete">currentTimestampSQLString	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">databaseName	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">fullTableName: aClass	"Override as required -	 Answer the full, database qualified table name for aClass."	^ self tableNameWithPrefix: aClass</body><body package="Store-Broker-Obsolete">getBlobData: aData	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">indexNameFor: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">isConnectionAlive	^self registry isConnectionAlive</body><body package="Store-Broker-Obsolete">maxLongBytes	^32000</body><body package="Store-Broker-Obsolete">maxPropertySearchStringSize	"Return the mazimum length of property record search string. Should be &lt;= 255.	Override this value in subclasses if the searchable varchars are shorter on your DB."	^255</body><body package="Store-Broker-Obsolete">maxSqlString	"Answer the maximum length of a sql string.	Subclasses should implement platform specific limitations."	^8000</body><body package="Store-Broker-Obsolete">needsSequenceFor: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">permissionsForSequence	"Answer an array of permissions to grant to sequence tables."	^#( 'SELECT' ).</body><body package="Store-Broker-Obsolete">sequenceNameWithPrefix: aClass		^(self tableNameWithPrefix: aClass), 'Seq'</body><body package="Store-Broker-Obsolete">tableName: aClass	^'TW_', aClass name asString</body><body package="Store-Broker-Obsolete">tableNameWithPrefix: aClass	^(self tablePrefix isNil or: [self tablePrefix isEmpty])		ifTrue: [self tableName: aClass]		ifFalse: [self tablePrefix, '.', (self tableName: aClass)]</body><body package="Store-Broker-Obsolete">tablePrefix	^self registry tablePrefix</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private</category><body package="Store-Broker-Obsolete">messageFor: exception	| errs msg |	exception signal == self connectionClass authenticationFailureSignal 		ifTrue: [ ^exception errorString ].	errs := exception parameter.	^errs notNil 		ifTrue: 			[ errs isSignalledException ifTrue: [ ^ errs errorString].			(errs isEmpty not				and: [ (msg := (exception parameter at: 1) dbmsErrorString) notNil				and: [ msg isEmpty not ] ] )					ifTrue: [msg ]					ifFalse:  [exception errorString ]			]		ifFalse: [exception errorString ]</body><body package="Store-Broker-Obsolete">registry	^DbRegistry</body><body package="Store-Broker-Obsolete">sessionFromOutputObject: anObject		#{Store.DBObject}		ifDefinedDo: 			[:value | 			^[anObject class session] 				on: MessageNotUnderstood 				do: [:exception | exception return: value session]]		elseDo: [self error: #OldStoreDatabaseNeeded &lt;&lt; #store &gt;&gt; 'Package/Parcel "OldStoreDatabase" is required to execute this request']</body><body package="Store-Broker-Obsolete">typeToStringMap	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>sql processing</category><body package="Store-Broker-Obsolete">getAnswerFromSession: getSessionBlock bindInput: bindInputBlock 		^self safelyExecuteBlock: 		[ | session ans res |		session := getSessionBlock value.		bindInputBlock value: session.		session execute.		[ ans := session answer.		ans == #noMoreAnswers		] whileFalse: 			[ ans == #noAnswerStream 				ifFalse: [ res := ans upToEnd ]			].		self registry printDebug: 'Output'; printDebug: res.		^ res.		]</body><body package="Store-Broker-Obsolete">process: sqlString	"Return the result not the answer stream."	^self registry goToScript 		ifTrue: [	self log: sqlString  level: #SQLBroker ]		ifFalse: 	[ self process: sqlString bindInput: nil  bindOutput: nil.]</body><body package="Store-Broker-Obsolete">process: sqlString bindInput: anObject	"Return the result not the answer stream."	^self process: sqlString bindInput: anObject bindOutput: nil</body><body package="Store-Broker-Obsolete">process: sqlString bindInput: inputObj bindOutput: outputObj 	"Return the result not the answer stream. 	Watch for the server going away."	^self safelyExecuteBlock: 		[ self			process: sqlString			bindInput: inputObj			bindOutput: outputObj			usingSession: ( self sessionFromOutputObject: outputObj )		]</body><body package="Store-Broker-Obsolete">process: sqlString bindInput: anObj bindOutput: anObject onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: anObj 		bindOutput: anObject 		usingSession: ( self sessionFromOutputObject: anObject )		onError: aSignal 		do: aBlock</body><body package="Store-Broker-Obsolete">process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session	| res ans |	"Return the result not the answer stream."	self isConnectionAlive ifFalse: [self currentlyNotConnectedSignal raise].	self log: sqlString  level: #SQLBroker.	session bindInput: inputObj.	session bindOutput: outputObj.	session prepare: sqlString. 	session execute.	[ans := session answer.	ans == #noMoreAnswers]		whileFalse: [ans == #noAnswerStream ifFalse: [res := ans upToEnd]].	self log: 'Done ! '  level: #SQLBroker.	^ res</body><body package="Store-Broker-Obsolete">process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session onError: aSignal do: aBlock	^[		self process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session 	] 	on: aSignal	do:		[:exception |			aBlock notNil ifTrue: [exception return: (aBlock value: exception)].			exception pass		]</body><body package="Store-Broker-Obsolete">process: sqlString bindOutput: anObject 	"Return the result not the answer stream."	^self process: sqlString bindInput: nil bindOutput: anObject</body><body package="Store-Broker-Obsolete">process: sqlString bindOutput: anObject onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: nil 		bindOutput: anObject 		usingSession: ( self sessionFromOutputObject: anObject )		onError: aSignal 		do: aBlock</body><body package="Store-Broker-Obsolete">process: sqlString onError: aSignal do: aBlock	"Return the result not the answer stream."	#{Store.DBObject} 		ifDefinedDo:			[:value |			^self process: sqlString 				bindInput: nil 				bindOutput: nil				usingSession: value session 				onError: aSignal 				do: aBlock]		elseDo: [self error: #OldStoreDatabaseNeeded &lt;&lt; #store &gt;&gt; 'Package/Parcel "OldStoreDatabase" is required to execute this request']</body><body package="Store-Broker-Obsolete">processPublishException: anException note: aString	| newNote | 	anException appendNewLineToMessageText: 'ERROR: ', (self messageFor: anException).	newNote := aString.	newNote notEmpty ifTrue: [newNote := newNote, ' --- '].	newNote := newNote, 'Operation was not completed.'.	anException appendNewLineToMessageText: newNote.	self registry goOffLine.</body><body package="Store-Broker-Obsolete">processSQL: sqlString	^self registry goToScript 		ifTrue: [	self log: sqlString  level: #SQLBroker ]		ifFalse:  [ self processSQL: sqlString bindInput: nil bindOutput: nil.]</body><body package="Store-Broker-Obsolete">processSQL: sqlString bindInput: anObject	^ self 	processSQL: sqlString bindInput: anObject bindOutput: nil</body><body package="Store-Broker-Obsolete">processSQL: sqlString bindInput: anObjectInp bindOutput: anObjectOut	^self  process: sqlString		bindInput: anObjectInp		bindOutput: anObjectOut		usingSession: ( self sessionFromOutputObject: anObjectOut )</body><body package="Store-Broker-Obsolete">processSQL: sqlString bindOutput: anObject	^ self processSQL: sqlString bindInput: nil bindOutput: anObject</body><body package="Store-Broker-Obsolete">publishTransaction: aBlock	"If not already in transaction mode then start one. Assumes progress dialog already up.	Answer either a value returned by aBlock or nil if the transaction fails."	^[ | res connection |	 ( connection := self connection ) isNil		ifTrue: [ ^nil ].	connection inTransactionMode 		ifTrue: [ res := aBlock value	"We are already inside a transaction." ]		ifFalse: 			[ [ connection begin.				  res := aBlock value.				  connection commit			   ] ifCurtailed:				[ self registry isOnline ifTrue: [ connection rollback ].				res := nil				]			].		res	] on: ( ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex |  			self processPublishException: ex  note: ''. 			ex outer. 			ex return]</body><body package="Store-Broker-Obsolete">publishTransaction: aBlock showing: aNote 	"If not already in transaction mode than put a notice on the screen and start 	transaction. Answer either a value returned by aBlock or nil if the transaction fails."	^ [| res |		self connection inTransactionMode 			ifTrue: [ res := aBlock value	"We are already inside a transaction." ]			ifFalse: 				[ Notice show: aNote while: 					[ [ self connection begin.					  res := aBlock value.					  self connection commit					  ] ifCurtailed:						[ self registry isOnline ifTrue: [self connection rollback].						res := nil						]					]				].		res	] 	on: (ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex | self processPublishException: ex  note: aNote.				ex outer.			ex return.]</body><body package="Store-Broker-Obsolete">publishTransaction: aBlock showing: aNote count: anInteger	"If not already in transaction mode than put a progress dialog on the screen and start 	transaction. Answer either a value returned by aBlock or nil if the transaction fails."	^[ | res connection |	 ( connection := self connection ) isNil		ifTrue: [ ^nil ].	connection inTransactionMode 		ifTrue: [ res := aBlock value	"We are already inside a transaction." ]		ifFalse: 			[Notice 				showProgress: aNote 				complete: anInteger 				while: 					[[connection begin.					  res := aBlock value.					  connection commit] ifCurtailed:						[self registry isOnline ifTrue: [connection rollback].						res := nil]]				title: 'Store'].		res	] 	on: (ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex |  			self processPublishException: ex  note: aNote. 			ex outer. 			ex return]</body><body package="Store-Broker-Obsolete">safelyExecuteBlock: aBlock	"Catch errors that arise. Do not offer reconnect for certain errors during transaction."	(self registry connectionOrNil == nil or: [self registry isOnline not])		ifTrue: [^self currentlyNotConnectedSignal raiseSignal].	^[[Cursor database showWhile: [aBlock value]]		on: self brokerSignals		do:			[:exception | 			| inTransaction |			self registry debug ifTrue: [self hardHalt].			inTransaction := self connection inTransactionMode.			self registry goOffLine.			(inTransaction not and: [self reconnectSignals: exception])				ifTrue:					[(Dialog confirm: 'Currently disconnected. Do you want to reconnect?')						ifTrue: [self registry reconnect ifTrue: [exception retry]].					exception resignalAs: self currentlyNotConnectedSignal new]]]		on: UnhandledException		do:			[:ex | 			(ControlInterrupt handles: ex parameter) ifTrue: [ex pass].			self processPublishException: ex note: ''.			self currentlyNotConnectedSignal raiseSignal.			ex return].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>create objects</category><body package="Store-Broker-Obsolete">addIdentityFor: aColumn	"Most databases don't use this, but some may require a special identity(xx) function call in the definition string"	^String new.</body><body package="Store-Broker-Obsolete">allocateSpaceForObjectsIn: fileName		^self subclassResponsibility</body><body package="Store-Broker-Obsolete">createDatabaseSequence: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">createDatabaseTable:  aClass		self deprecated: #(#version '7.9' #sunset '8.0' #use #Glorp).	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">createIndex: indName onTable: aTable columns: aNameCollection	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE INDEX ' , indName, ' ON ' , aTable, ' ( '.	aNameCollection 		do: [ :each | aStream nextPutAll: each, ', ' ].	aStream skip: -2.	aStream nextPutAll: ' )'.	self performCreate: [ self processSQL: aStream contents]</body><body package="Store-Broker-Obsolete">createIndexForClass: aClass index: indName columns: aNameCollection	"Creates an index on a given table that either 		changes the physical ordering of the table or		provides the optimizer with a logical ordering of the table to increase efficiency for queries."	self createIndex: indName 			onTable: (self fullTableName: aClass) 			columns: (self columnList: aNameCollection for: aClass)</body><body package="Store-Broker-Obsolete">createTable: aTableName columns: columnString	"Creates a new table."	| aStream |	Transcript cr; show: 'Creating table for ' , aTableName.	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE TABLE ' , aTableName,  columnString.	self performCreate: [self processSQL: aStream contents]</body><body package="Store-Broker-Obsolete">createTablePrimaryKeySectionFor: aClass keys: aKeyCollection		^self subclassResponsibility</body><body package="Store-Broker-Obsolete">createView: aViewName selectStatement: aSelectString	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE VIEW ' ,  aViewName , ' as	SELECT ', aSelectString.	self performCreate: [self processSQL: aStream contents]</body><body package="Store-Broker-Obsolete">fileNameForBlobs	^Store.Policies tableSpacePolicy blobTableSpace</body><body package="Store-Broker-Obsolete">fileNameForClasses	^Store.Policies tableSpacePolicy defaultTableSpace</body><body package="Store-Broker-Obsolete">installPhysicalSpaces	"Create the physical table spaces/device spaces   used by Store."	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">isPrimaryKeyType: aType	"Returns whether or not aType is a primary key type"	"Added by Philippe F. Monnet of Andersen Consulting"		^self primaryKeyTypes includes: aType</body><body package="Store-Broker-Obsolete">performCreate: aBlock		[aBlock value]		on: Error		do:			[:exception | 			(self alreadyExistErrors includes: exception parameter first dbmsErrorCode)				ifTrue:					[Transcript cr; show: exception parameter first dbmsErrorString.					exception return]				ifFalse:					[exception appendNewLineToMessageText: (self messageFor: exception).					self registry goOffLine.					exception pass]]</body><body package="Store-Broker-Obsolete">primaryKeyTypes	"Returns the primary key types"	^#( #PrimaryKey #PrimaryKeyInteger #PrimaryKeyString 		#PrimaryKeyChar #PrimaryKeyShortString)</body><body package="Store-Broker-Obsolete">spaceForBlobs"MB"	^ '16'</body><body package="Store-Broker-Obsolete">spaceForClasses"MB"	^'32'</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>queries</category><body package="Store-Broker-Obsolete">alterTableFor: aClass  pctIncreaseBy: aNumber	| sql |	sql :=  (self newSQLFor: aClass)			alterPstincrease: aNumber printString.	self process: sql.	Transcript cr; show: sql, '-- Done!'.</body><body package="Store-Broker-Obsolete">newSQLFor: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">nextIDQuery: aClass	^self subclassResponsibility</body><body package="Store-Broker-Obsolete">sqlAssistClass	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>debugging</category><body package="Store-Broker-Obsolete">debugLabelsAndValues	^List new		add: ('Sql Statements'-&gt;#SQLBroker);		yourself</body><body package="Store-Broker-Obsolete">log: aString level: aLevel	[ self registry debugger log: aString  level: aLevel ] on: Error do: [ :ex | ex return ]</body><body package="Store-Broker-Obsolete">menuItemName	^(#StoreMessages &lt;&lt; #store &gt;&gt; 'Store Messages') asString</body><body package="Store-Broker-Obsolete">registerToDebug	[self registry debugger addToDebug: self] on: Error do: [ :ex | ]</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>class initialization</category><body package="Store-Broker-Obsolete">initialize	self registerToDebug</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-column names</category><body package="Store-Broker-Obsolete">allColumnsFor: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	To override method, invoke super #allColumnsFor: 		and then convert names as required by specific database"	^aClass columnNames.</body><body package="Store-Broker-Obsolete">allUpdatableColumnsFor: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	To override method, invoke super #allUpdatableColumnsFor: 		and then convert names as required by specific database"	| aColl |	aColl := OrderedCollection new.	#( 'version'  'versionComment'  'blessingLevel' )  do: [ :each  |		(aClass columnNames includes:	each) ifTrue: [ aColl add: each ]	].	^aColl</body><body package="Store-Broker-Obsolete">columnList: aCollection for: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	Override method to convert names as required by specific database table."	^ aCollection.</body><body package="Store-Broker-Obsolete">columnName: aStringOrSymbol for: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	Override method to convert name as required by specific database table."	^aStringOrSymbol.</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>testing</category><body package="Store-Broker-Obsolete">ansiOuterJoins	"Return true if we use ansi outer joins."	^true.</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>obsolete</category><body package="Store-Broker-Obsolete">performCreate: aBlock for: aName	"This method is obsolete. use #performCreate: instead, since the for parameter is not used"		^self performCreate: aBlock</body><body package="Store-Broker-Obsolete">performDrop: aBlock for: aName	"This method is obsolete. use #performDrop: instead, since the for parameter is not used"		^self performDrop: aBlock</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>reconciling</category><body package="Store-Database Model">reconcilesWith: aStoreDefinitionObject	(super reconcilesWith: aStoreDefinitionObject) ifFalse: [^false].	self protocol = aStoreDefinitionObject protocol ifFalse: [^false].	self isClassVariable = aStoreDefinitionObject isClassVariable ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>accessing</category><body package="Store-Database Model">absoluteOwnerName	^self environmentName asSymbol.</body><body package="Store-Database Model">actual	^self correspondingImageSharedVariable</body><body package="StoreForGlorpVWUI">allStoreVersions	| session |	^[(Store.Gathering for: self name) started.		session := StoreLoginFactory currentStoreSession.	StoreSharedVariableInPackage		allVersionsWithName: self name		inOwner: self absoluteOwnerName		in: session]		ensure: [(Store.Gathering for: self name) finished]</body><body package="Store-Database Model">classNameWithoutMeta	^self longName</body><body package="Store-Database Model">dataKey	^self name asSymbol.</body><body package="Store-Database Model">key	^self dataKey</body><body package="StoreForGlorpVWUI">ownerName	| stream |	stream := self environmentName reverse readStream.	^(stream upTo: $.) reverse asSymbol.</body><body package="Store-Database Model">protocol	^protocol</body><body package="Store-Database Model">protocol: aString	protocol := aString.</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineSharedVariable:' startingAt: 1.	insertPoint isZero ifTrue: [insertPoint := definitionString indexOfSubCollection: 'defineStatic:' startingAt: 1].	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Store-Database Model">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>testing</category><body package="Store-Database Model">belongsToClass	^self isClassVariable.</body><body package="Store-Database Model">definitionForShared: aVariableBinding		| namespace |	namespace := Root whoDefinesBinding: aVariableBinding.	^namespace isNil 		ifTrue: [''] 		ifFalse: [namespace definitionOfStatic: aVariableBinding]</body><body package="Store-Database Model">isClassVariable	^isClassVariable</body><body package="Store-Database Model">isClassVariable: aBoolean	isClassVariable := aBoolean.</body><body package="Store-Database Model">isForData	^true.</body><body package="Store-Database Model">isForSharedVariable	^true</body><body package="Store-Database Model">isInClass	^self isClassVariable</body><body package="Store-Database Model">isInNameSpace	^isClassVariable not</body><body package="Store-Database Model">sameAsImage	"Answer true if the receiver is the same as the image version.	We compare the definition string of me vs the definition string of my binding in the image if there is one"		| theSharedVariable sharedDefinition |	theSharedVariable := self correspondingImageBinding.	theSharedVariable isNil ifTrue: [^false].	sharedDefinition := theSharedVariable isForGeneral		ifTrue: [self definitionForShared: theSharedVariable]		ifFalse: [theSharedVariable value definition].	^self definitionString = sharedDefinition</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>converting</category><body package="Store-Database Model">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage sharedVariables		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session		readOneOf: StoreSharedVariableInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="StoreForGlorpVWUI">asStoreSharedVariable	^self</body><body package="Store-Database Model">correspondingImageBinding	"Return the image binding variable that corresponds to our name. Note that they may not have the same information."	| owner |	owner := (Dialect smalltalkAt: self absoluteOwnerName asString ifAbsent: [^nil]).	^owner bindingFor: self dataKey</body><body package="Store-Database Model">correspondingImageOwner	"Return the image owner (class or namespace) that this shared variable is defined in (or nil)"	^Dialect smalltalkAt: self absoluteOwnerName asString ifAbsent: [nil]</body><body package="Store-Database Model">correspondingImageSharedVariable	"Return the image shared variable that corresponds to our name. Note that they may not have the same information."	^(Dialect smalltalkAt: self longName ifAbsent: [nil])</body><body package="Store-Database Model">removeFromImage	self correspondingImageSharedVariable ifNotNil: [self longName asQualifiedReference removeFromSystem]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>private</category><body package="Store-Database Model">convertToXML: aString	| parse driver data sName eName init |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'shared-variable' atts: nil.	sName := (data at: 'defineSharedVariable:' ifAbsent: [data at: 'defineStatic:']) value asString.	self sax: driver tag: 'name' value: sName.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'constant' value: (data at: 'constant:') value printString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	init := ( init := (data at: 'initializer:' ) value ) == nil		ifFalse: [ self sax: driver tag: 'initializer' value: init asString ].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>loading</category><body package="Store-Database Model">loadSource	"Answer nil if there is a failure, otherwise the real thing"	| pkg binding |	pkg := Store.Policies packagePolicy forcedPackage.	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableSharedMessageForUnspecifiedClass inPackage: pkg].	binding := self evaluateDefinition: self definitionString		onError: [:exception | ^self raiseUnloadableError: exception inPackage: pkg].	Undeclared purgeUnusedBindings.	(Undeclared includesKey: binding name) ifTrue:		[| msg |		msg := AbstractPundleLoader unloadableSharedMessageForPossibleLoadOrder: binding name. binding name.		Transcript show: msg.		^self raiseUnloadableError: msg inPackage: pkg].	^self</body><body package="Store-Database Model">loadSourceDirect	"Answer nil if there is a failure, otherwise the real thing"	^self loadSourceDirectInPackage: Store.Policies packagePolicy forcedPackage</body><body package="Store-Database Model">loadSourceDirectInPackage: aPackage	"Compile the shared var definition. On failure raise UnloadableDefinitionError and answer nil."	| binding |	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableSharedMessageForUnspecifiedClass inPackage: aPackage].	self correspondingImageBinding ifNotNil: 		[:existingBinding |		| knownOverrides target |		knownOverrides := Override overridesForStatic: existingBinding binding in: existingBinding environment.		knownOverrides ifNotNil: [target := knownOverrides detect: [:each | each sources includes: aPackage] ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: self messageSendFromDefinition]].		binding := self evaluateDefinition: self definitionString			onError: [:ex | ^self raiseUnloadableError: ex inPackage: aPackage].	(Undeclared includesKey: binding name) ifTrue:		[Undeclared removeKey: binding name.		self correspondingImageBinding isNil 			ifTrue: [^self raiseUnloadableError: 'Binding is nil after moving from Undeclared' inPackage: aPackage]]</body><body package="Store-Database Model">messageSendFromDefinition	| methodNodeHolder messageNode |	methodNodeHolder := Compiler new parse: self definitionString in: nil class noPattern: true notifying: nil.	messageNode := methodNodeHolder node block body statements first.	^MessageSend		receiver: messageNode receiver name value		selector: messageNode selector		arguments: (messageNode arguments collect: #value)</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>fileIn/Out</category><body package="Store-Database Model">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#variable</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>printing</category><body package="StoreForGlorpVWUI">displayString	^self name</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>comparing</category><body package="StoreForGlorpVWUI">comparesTo: anObject		^self class == anObject class and: [self absoluteName = anObject absoluteName]</body><body package="Store-Database Model">equalsSignatureIn: aStoreDefinitionObject	self environmentName = aStoreDefinitionObject environmentName ifFalse: [^false].	self name = aStoreDefinitionObject name ifFalse: [^false].	^true.</body><body package="Store-Database Model">signatureHash	^self environmentName hash bitXor: self name hash</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI">owner	^Dialect smalltalkAt: self environmentName ifAbsent: [nil]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeShared: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedSharedVariableObject</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>filling out</category><body package="Store-Database Model">fileOutOn: aStream	self fileOutDefinitionOn: aStream</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable class</class-id> <category>instance creation</category><body package="Store-Database Model">allVersionsNamed: aSharedVariableName inOwner: anOwnerNameString in: aSessionOrNil		| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aSharedVariableName AND: each environmentName = anOwnerNameString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">selectVersionNamed: aSharedVariableName inOwner: anOwnerNameString	^self selectVersionNamed: aSharedVariableName inOwner: anOwnerNameString in: nil</body><body package="Store-Database Model">selectVersionNamed: aSharedVariableName inOwner: anOwnerNameString in: aSessionOrNil		| versions |	versions := self allVersionsNamed: aSharedVariableName inOwner: anOwnerNameString in: aSessionOrNil.	versions isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	versions size == 1 ifTrue: [^versions first].	^Dialog 		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (versions collect: [:m | m fullDisplayString])		values: versions		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable class</class-id> <category>constants</category><body package="Store-Database Model">inPackageClass	^StoreSharedVariableInPackage</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>private</category><body package="Store-Broker-Obsolete">allColumnNames	"Answer array of all column names from instance variables of aClass. 	Implemented here so we can re-map column names, if necessary."	^alias notNil		ifTrue: [self tableClass columnNames collect: [:name | alias , '.' , name]]		ifFalse: [self tableClass columnNames]</body><body package="Store-Broker-Obsolete">allHostVariableNames 	"Answer array of all column names from instance variables of aClass.		These will be used as accessors."	^ self tableClass columnNames collect: [ :each | ':', each ]</body><body package="Store-Broker-Obsolete">columnName: aStringOrSymbol 	"Answer the column name. 		Implemented here so we can re-map column names, as necessary.		Override for conversions as required by specific Database Table."	^alias notNil ifTrue: [alias , '.', aStringOrSymbol] ifFalse: [aStringOrSymbol]</body><body package="Store-Broker-Obsolete">removePrimaryKeyColumn: anArray	"Some databases do not allow CREATE and/or INSERT statements		to specify columns whose values are auto-generated.	 Override this method to exclude column 'primaryKey', as required.		This method is invoked before any column name re-mapping."	^anArray</body><body package="Store-Broker-Obsolete">removePrimaryKeyValue: anArray	"Some databases do not allow CREATE and/or INSERT statements		to specify columns whose values are auto-generated.	 Override this method to exclude host variable ':primaryKey', as required."	^anArray</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>accessing</category><body package="Store-Broker-Obsolete">alias	^alias</body><body package="Store-Broker-Obsolete">alias: aString	alias := aString</body><body package="Store-Broker-Obsolete">newSQLStream	^ sqlStream := (String new: 150) writeStream.</body><body package="Store-Broker-Obsolete">sqlString	^ sqlStream contents</body><body package="Store-Broker-Obsolete">tableClass	^ tableClass</body><body package="Store-Broker-Obsolete">tableClass: aClass	tableClass := aClass</body><body package="Store-Broker-Obsolete">tableName	^ alias notNil ifTrue: [tableName, ' ', alias] ifFalse: [tableName]</body><body package="Store-Broker-Obsolete">tableName: aString	tableName := aString</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>utility</category><body package="Store-Broker-Obsolete">smalltalkWildcardToSql: aString	"Translates a smalltalk wild card string to a sql wildcard string."	"* becomes % and ? becomes _"	| string index |	string := aString copy.	[ ( index := string indexOfSubCollection: '*' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $% ].	[ ( index := string indexOfSubCollection: '?' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $_ ].	^string</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>queries</category><body package="Store-Broker-Obsolete">addColumn: aString dbType: aColType	sqlStream nextPutAll: 'ALTER TABLE ', self tableName, ' ADD '.	self column: aString.	sqlStream nextPutAll: aColType.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">addString: aString	sqlStream nextPutAll: aString.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">alterPstincrease: aNumber	sqlStream nextPutAll: 'ALTER TABLE ', self tableName, ' STORAGE (  PCTINCREASE ', aNumber, ' )'.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">and	sqlStream nextPutAll: ' AND '</body><body package="Store-Broker-Obsolete">beginClause 	sqlStream nextPutAll: ' ( '</body><body package="Store-Broker-Obsolete">column: column	sqlStream nextPutAll: ' ', (self columnName: column), ' '.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">column: column equalTo: value	self column: column.	sqlStream nextPutAll: '= ',  value.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">column: column equalToArray: values	"Add a where clause that selects the value equal to one in an array of values."	self column: column; in.	self beginClause.	values 		do: [ :each | sqlStream nextPutAll: each ]		separatedBy:[ sqlStream nextPutAll: ', ' ].	self endClause.	^sqlStream contents</body><body package="Store-Broker-Obsolete">column: column greaterThan: value	self column: column.	sqlStream nextPutAll:  '&gt; ' ,  value.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">column: column lessThan: value	self column: column. 	sqlStream nextPutAll: '&lt; ' , value.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">column: column like: value	self column: column. 	sqlStream nextPutAll: 'like ' ,  value.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">column: column  notEqualTo: value	sqlStream nextPutAll: ' ', column, ' &lt;&gt; ',  value.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">column: column notEqualToArray: values	"Add a where clause that selects the value not equal to one in an array of values."	self beginClause.	values 		do: [ :each | self column: column notEqualTo: each ]		separatedBy:[ self and ].	self endClause.	^sqlStream contents</body><body package="Store-Broker-Obsolete">column: column wildcard: string	| param |	param := self smalltalkWildcardToSql: string.	self column: column.	sqlStream nextPutAll: 'like ',  param.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">columnSAVE: column equalToArray: values	"Add a where clause that selects the value equal to one in an array of values."	self column: column; in.	self beginClause.	values 		do: [ :each | sqlStream nextPutAll: each ]		separatedBy:[ sqlStream nextPutAll: ', ' ].	self endClause.	^sqlStream contents</body><body package="Store-Broker-Obsolete">delete	sqlStream nextPutAll: 'DELETE FROM ', self tableName.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">endClause 	sqlStream nextPutAll: ' ) '.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">equal	sqlStream nextPutAll: ' = '.</body><body package="Store-Broker-Obsolete">in	sqlStream nextPutAll: ' IN '</body><body package="Store-Broker-Obsolete">in: aString	sqlStream nextPutAll: ' IN (', aString, ' ) '.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">innerJoin: joinSql 		^ self join: joinSql  type: ' INNER JOIN '</body><body package="Store-Broker-Obsolete">insert: aColumnArray	| arr |	arr := self removePrimaryKeyColumn: aColumnArray.	sqlStream nextPutAll: 'INSERT INTO ', self tableName, ' ('.	arr do:		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' ) '.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">insertColumns: aColumnArray values: aValueArray	self insert: aColumnArray.	self insertValues: aValueArray.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">insertColumnsValues: aColumnArray	"Column names are used as host variables / accessors"	self insertColumns: aColumnArray 		values: (aColumnArray collect: [ :each | ':' , each ] ).	^ sqlStream contents</body><body package="Store-Broker-Obsolete">insertValues: aValueArray	| arr |	" aValueArray is a list of host variable names (each preceeded by a colon).		Colon is stripped and the name is used as accessor. "	arr := self removePrimaryKeyValue: aValueArray.	sqlStream nextPutAll: ' VALUES ('.	arr do: 		[ :col | sqlStream nextPutAll: col , ', ' ].	sqlStream skip: -2.	sqlStream nextPut: $).	^ sqlStream contents</body><body package="Store-Broker-Obsolete">isNull	sqlStream nextPutAll: ' IS NULL '</body><body package="Store-Broker-Obsolete">join: joinSql type: aType	"insert join statement"	sqlStream nextPutAll: aType ;		nextPutAll: joinSql tableName;		nextPutAll: ' ON '.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">joinedColumn: column"Like column: but without modifying of sqlStream"	^' ', (self columnName: column), ' '.</body><body package="Store-Broker-Obsolete">leftJoin: joinSql 		^ self join: joinSql  type: ' LEFT OUTER JOIN '</body><body package="Store-Broker-Obsolete">notEqual	sqlStream nextPutAll: ' &lt;&gt; '.</body><body package="Store-Broker-Obsolete">notIn	sqlStream nextPutAll: ' NOT IN '</body><body package="Store-Broker-Obsolete">notIn: aString	sqlStream nextPutAll: ' NOT IN (', aString, ')'.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">notNull	sqlStream nextPutAll: ' NOT NULL '</body><body package="Store-Broker-Obsolete">or	sqlStream nextPutAll: ' OR '</body><body package="Store-Broker-Obsolete">orderBy: column	sqlStream nextPutAll: ' ORDER BY ', (self columnName: column). 	^ sqlStream contents</body><body package="Store-Broker-Obsolete">rightJoin: joinSql 		^ self join: joinSql  type: ' RIGHT OUTER JOIN '</body><body package="Store-Broker-Obsolete">select: aColumnArray	sqlStream nextPutAll: 'SELECT '.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' FROM ', self tableName.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">selectAll	sqlStream nextPutAll: 'SELECT 	'.	alias notNil ifTrue: [	sqlStream nextPutAll: alias, '.' ].	sqlStream nextPutAll: '* FROM ', self tableName.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">selectCountAll	sqlStream nextPutAll: 'SELECT COUNT (*) FROM ', self tableName.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">selectDistinct: aColumnArray	sqlStream nextPutAll: 'SELECT  DISTINCT '.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' FROM ', self tableName.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">selectMax: aColumnArray	sqlStream nextPutAll: 'SELECT MAX ('.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1. 	sqlStream nextPutAll: ') FROM ', self tableName.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">setColumns: columnArray equalTo: valueArray	"For set commands. Sets each column equal to cooresponding value in valueArray"	self update.	columnArray with: valueArray do:		[ :column :value |		self column: column.		sqlStream nextPutAll: '= ',  value.		sqlStream nextPutAll: ', '.		].	sqlStream skip: -2.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">update	sqlStream nextPutAll: 'UPDATE ', self tableName, ' SET '.	^ sqlStream contents</body><body package="Store-Broker-Obsolete">where	sqlStream nextPutAll: ' WHERE '</body><body package="Store-Broker-Obsolete">whereSqlString	| columns values |	" Column names might need to be re-mapped 		but host variables for values must be the attribute names (accessors).		Therefore, we need to iterate over both lists concurrently. "	self where.	columns := self allColumnNames.		values := self allHostVariableNames.	columns with: values do: 		[ : column :value |		sqlStream 			cr; tab;			nextPutAll: column;			nextPutAll: ' = ';			nextPutAll: value;			nextPutAll: ' AND '.		].	sqlStream skip: -4.	sqlStream cr.	^sqlStream contents</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>special</category><body package="Store-Broker-Obsolete">classNamesInPackages: pkgIds	^self 	  selectDistinct: #( #className );	  where;	   column: #packageRef equalToArray: 		( pkgIds collect: [ :pkg | pkg primaryKey printString ] );	sqlString</body></methods><methods><class-id>Store.SQLAssist class</class-id> <category>instance creation</category><body package="Store-Broker-Obsolete">newSQLFor: aClass table: aString	^ super new 		newSQLStream;		tableName: aString;		tableClass: aClass</body></methods><methods><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">iconFor: aMethodCategory	^nil</body></methods><methods><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">showIcons		^false</body></methods><methods><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id> <category>private-selectors</category><body package="StoreForGlorpBrowserUI">allMethodDefinitionsFor: aProtocol in: class	| selectors |	selectors := OrderedCollection new.	self inheritedClassesOf: class		do: 			[:each |			selectors				addAll: ((navigator environment selectorsFor: aProtocol in: each) collect: 							[:eachSelector |							StoreMethodDefinition 								class: class 								implementor: each 								selector: eachSelector])].	^selectors</body><body package="StoreForGlorpBrowserUI">methodDefinitionsIn: aProtocol	"Unlike our parent NavigatorPart, Store navigators for protocols and selectors do show inherited methods	so the special select my parent does just isn't needed and slows me down"	| class defs |	class := navigator selectedClass.	class isNil ifTrue: [^#()].	defs := self allMethodDefinitionsFor: aProtocol in: class.	defs isEmpty ifTrue: [^#()].	^defs</body></methods><methods><class-id>Store.UnloadableDefinition</class-id> <category>forwarding</category><body package="Store-UI-Unloadables Support">definition	^userDefinition ifNil: [storeObject definition]</body><body package="Store-UI-Unloadables Support">fileOutDefinitionOn: aCodeStream	^storeObject fileOutDefinitionOn: aCodeStream</body><body package="Store-UI-Unloadables Support">fullDisplayString	^storeObject fullDisplayString</body><body package="Store-UI-Unloadables Support">fullDisplayStringWithUnloadableReason	^problem fullDisplayStringWithUnloadableReason</body><body package="Store-UI-Unloadables Support">loadNewSource: aString	loaded ifFalse: 		[loaded := (storeObject loadNewSource: aString) notNil.		loaded ifTrue: [userDefinition := aString]]</body><body package="Store-UI-Unloadables Support">loadSrcInto: aPackageModel	loaded ifFalse: [loaded := (storeObject loadSrcInto: aPackageModel) notNil]</body><body package="Store-UI-Unloadables Support">name	^storeObject name</body><body package="Store-UI-Unloadables Support">package	"If the StoreObject does not know its package (which is the case for all descendants of StoreDefinitionObject),	then grab it from the underlying UnloadableDefinitionError."	^storeObject package ifNil: [problem package]</body><body package="Store-UI-Unloadables Support">removeFromPackage: aPackageModel	^storeObject removeFromPackage: aPackageModel</body><body package="Store-UI-Unloadables Support">versions	^storeObject versions</body></methods><methods><class-id>Store.UnloadableDefinition</class-id> <category>accessing</category><body package="Store-UI-Unloadables Support">icon	^loaded		ifTrue: [MergeIcons applied]		ifFalse: [MergeIcons unresolved]</body><body package="Store-UI-Unloadables Support">loaded		^loaded</body><body package="Store-UI-Unloadables Support">loaded: anObject		loaded := anObject</body><body package="Store-UI-Unloadables Support">notLoaded		^self loaded not</body><body package="Store-UI-Unloadables Support">problem: anUnloadableDefinitionError	problem := anUnloadableDefinitionError</body><body package="Store-UI-Unloadables Support">problemString	^problem problemString</body><body package="Store-UI-Unloadables Support">storeObject		^storeObject</body><body package="Store-UI-Unloadables Support">storeObject: anObject		storeObject := anObject</body><body package="Store-UI-Unloadables Support">userDefinition		^userDefinition</body><body package="Store-UI-Unloadables Support">userDefinition: anObject		userDefinition := anObject</body></methods><methods><class-id>Store.UnloadableDefinition</class-id> <category>initialize-release</category><body package="Store-UI-Unloadables Support">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	loaded := false.</body></methods><methods><class-id>Store.UnloadableDefinition</class-id> <category>printing</category><body package="Store-UI-Unloadables Support">printOn: aStream	aStream nextPutAll: 'unloadable '.	storeObject printOn: aStream</body></methods><methods><class-id>Store.UnloadableDefinition class</class-id> <category>instance creation</category><body package="Store-UI-Unloadables Support">fromUnloadableError: anUnloadableDefinitionError	^(self on: anUnloadableDefinitionError definitionRecord)		problem: anUnloadableDefinitionError</body><body package="Store-UI-Unloadables Support">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Store-UI-Unloadables Support">on: aStoreObjectInPackage	| instance |	instance := self new.	instance storeObject: aStoreObjectInPackage.	^instance</body></methods><methods><class-id>Tools.AbstractPropertyComparisonRollupView</class-id> <category>private</category><body package="Store-Code Comparison">printProperty: aPropertyObject	"The default is to use printString (unless it is already a string). But before we use the default, we check to see if we have any tagged methods whose tag is #printProperty: and paramter matches my propertyKey. If we do, we defer to that method to produce a stringified representation of the argument."	(Pragma		allNamed: #printProperty:		from: self class		to: AbstractComparisonRollupView) do: 				[:each |				(each argumentAt: 1) == self propertyKey					ifTrue: [^self perform: each selector with: aPropertyObject]].	^aPropertyObject isCharacters		ifTrue: [aPropertyObject]		ifFalse: [aPropertyObject printString]</body><body package="Store-Code Comparison">propertyKey	^self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI">asTag	^Store.MethodTag 		newClassName: self className 		meta: self isMeta		selector: self selector asSymbol		protocol: self protocol.</body><body package="Store-Database Model">owner		| class |	class := self fullClassName asStrictReference valueOrDo: [^nil].	^self isMeta		ifTrue: [class class]		ifFalse: [class]</body><body package="Store-Database Model">selector	selector isNil ifTrue: [selector := self name asSymbol].	^selector.</body><body package="StoreForGlorpVWUI">setCTypeForPre77StoreFrom: aCompiledMethod	"Pre-Glorp Store ensured that C type definitions were loaded first in ExternalInterface classes by a hack:  they put 'CTYPE' into an old, unused (and inappropriately-named but available) instVar called 'version' which had a mapping to a column of the same name in the store schema.  In old Store (i.e. as released in VW7.6 and earlier), look at #fromDescription:trace:package: and #newNamed:inClass:trace:package: to see this being set, and #sortForLoading:package: and #sortMethodModifications: to see it being used in load ordering.	Glorp-using Store has another solution to this, but any ExternalInterface-subclass-containing packages that it publishes will not load into 7.6 and earlier unless 'CTYPE' is set in their CType-defining StoreMethods before publishing.  Thus we must call this when creating StoreMethods for publishing, at least until compatibility with 7.6 and earlier becomes unimportant (or sufficiently so that an in-place-rewriting Glorp script run periodically on the database will do instead)."	aCompiledMethod isNil ifTrue: [^nil].		"to simplify calling code"	(aCompiledMethod mclass isKindOf: ExternalInterface class) ifTrue:		[aCompiledMethod returnsStaticVariable ifNotNil:			[:variableAssoc |			(variableAssoc value isKindOf: CType) ifTrue:				[version := 'CTYPE']]].	"otherwise version is nil"</body><body package="StoreForGlorpVWUI">textRepresentationForTag: aTag	^self source</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>comparing</category><body package="Store-Database Model">&lt; aStoreMethod	| n1 n2 sel |	n1 := self classNameWithMeta.	n2 := aStoreMethod classNameWithMeta.	^n1 = n2		ifTrue:			[(self selector isString					ifTrue: [self selector]					ifFalse: [self selector printString])				&lt; ((sel := aStoreMethod selector) isString						ifTrue: [sel]						ifFalse: [sel printString])]		ifFalse: [n1 &lt; n2]</body><body package="Store-Database Model">&lt;= aStoreMethod	^self = aStoreMethod or: [self &lt; aStoreMethod].</body><body package="Store-Database Model">= aStoreMethod	^self class = aStoreMethod class and: [self reconcilesWith: aStoreMethod]</body><body package="StoreForGlorpVWUI">comparesTo: anObject		^self class == anObject class and: [self name = anObject name and: [self classNameWithMeta = anObject classNameWithMeta]]</body><body package="Store-Database Model">displayString	^self selector.</body><body package="Store-Database Model">equalsSignatureIn: aStoreMethod	self class = aStoreMethod class ifFalse: [^false].	self classNameWithMeta = aStoreMethod classNameWithMeta ifFalse: [^false].	self selector = aStoreMethod selector ifFalse: [^false].	self isMeta = aStoreMethod isMeta ifFalse: [^false].	^true.</body><body package="Store-Database Model">hash	"Just hash on the presumably most selective of the equality criteria, which is anything but PK"	^self classNameWithMeta hash bitXor: self name hash.</body><body package="Store-Database Model">sameAsImage	| method |	method := self correspondingImageMethod.	method isNil ifTrue: [^false].	^self = method asStoreMethodDefinition.</body><body package="Store-Database Model">signatureHash	^(self classNameWithMeta hash		bitXor: self selector stringhash)			bitXor: self isMeta hash</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>accessing</category><body package="Store-Database Model">absoluteSymbol	^self longName asSymbol</body><body package="StoreForGlorpVWUI">allStoreVersions	| session |	^[(Store.Gathering for: self selector asString) started.		session := StoreLoginFactory currentStoreSession.	StoreMethodInPackage		allVersionsWithName: self selector asString		inClass: self classNameWithMeta		in: session] 			ensure: [(Store.Gathering for: self selector asString) finished]</body><body package="Store-Database Model">basicComment	^comment.</body><body package="Store-Database Model">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model">basicSource	^source.</body><body package="Store-Database Model">basicSource: aStoreBlob	source := aStoreBlob.</body><body package="Store-Database Model">className	^self classNameWithoutMeta.</body><body package="Store-Database Model">className: aString	className := aString.</body><body package="Store-Database Model">classNameWithMeta	^className.</body><body package="Store-Database Model">classNameWithoutMeta	^isMetaclass		ifTrue: [longName ifNil: [longName := self privateGetLongName]]		ifFalse: [className]</body><body package="Store-Database Model">comment	^comment isNil ifTrue: [nil] ifFalse: [comment source].</body><body package="Store-Database Model">comment: aString	comment := StoreBlob forString: aString.</body><body package="Store-Database Model">correspondingImageClass	"Return the image class that corresponds to our name. Note that they may not have the same information"	| basicClass |	basicClass := Dialect smalltalkAt: self className ifAbsent: [^nil].	^self isMetaclass ifTrue: [basicClass class] ifFalse: [basicClass].</body><body package="Store-Database Model">definition	^self source.</body><body package="StoreForGlorpVWUI">definitionObject	^self</body><body package="Store-Database Model">definitionString	^self definition</body><body package="Store-Database Model">environment	"This isn't right, but our real environment may not even exist in the image"	^Smalltalk.</body><body package="Store-Database Model">environmentString	^self classNameWithoutMeta</body><body package="Store-Database Model">fullClassName	^self className.</body><body package="Store-Database Model">getSource	^self source.</body><body package="Store-Database Model">longName	^self classNameWithoutMeta</body><body package="Store-Database Model">methodSources	^MethodSourceCollection source: self definitionString</body><body package="Store-Database Model">name: aStringOrSymbol	"This is a Glorp object that uses 'name' as the database field. This value returned by 2 accessors,	#name and #selector. Ensure that they are both set.  Allow this setter to accept a symbol if we have	one, since converting to a string, then passing in and converting to a symbol again is unnecessarily	expensive."	aStringOrSymbol isSymbol		ifTrue: [			super name: aStringOrSymbol asString.			selector := aStringOrSymbol ]		ifFalse: [			super name: aStringOrSymbol.			selector := aStringOrSymbol asSymbol]</body><body package="Store-Database Model">protocol	^protocol isNil ifTrue: [#'unknown protocol'] ifFalse: [protocol].</body><body package="Store-Database Model">protocol: aString	protocol := aString.</body><body package="Store-Database Model">setVersionTo: aString	"We appear not to have been capturing CTypes, very bad when ExternalInterface methods are loaded as their ordering matters and is controlled by this inside sortForLoading:package:."	version := aString.</body><body package="Store-Database Model">signature	^self longNameWithMetaFromSmalltalk, ' &gt;&gt; ', self name</body><body package="Store-Database Model">source	^source source</body><body package="Store-Database Model">source: aString	source := StoreBlob forString: aString.</body><body package="Store-Database Model">sourceCode	^self source.</body><body package="Store-Database Model">version	^version</body><body package="Store-Database Model">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>testing</category><body package="Store-Database Model">belongsToClass	^true.</body><body package="Store-Database Model">isMeta	^self isMetaclass.</body><body package="Store-Database Model">isMetaclass	^isMetaclass</body><body package="Store-Database Model">isMetaclass: aBoolean	isMetaclass := aBoolean.</body><body package="Store-Database Model">sameAsSelector: aSymbol class: aClass	| myProtocol |	myProtocol := aClass organization categoryOfElement: aSymbol.	myProtocol == nil ifTrue: [myProtocol := 'As yet unclassified'].	(myProtocol isSameSequenceAs: self protocol) ifFalse: [^false].	self className = aClass absoluteName ifFalse: [^false].	(self name isSameSequenceAs: aSymbol) ifFalse: [^false].	(aClass selectors includes: aSymbol) ifFalse: [^false].	self source = ((aClass compiledMethodAt: aSymbol) getSource ifNil: [^false]).	^true</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>reconciling</category><body package="Store-Database Model">isSource: mySource sameAs: otherSource	| isSourceSame |	isSourceSame := mySource size = otherSource size				ifTrue: [mySource = otherSource]				ifFalse: 					[mySource size &gt; otherSource size						ifTrue: 							[(mySource size - 1 = otherSource size and: [mySource last = Character cr])								ifTrue: [(mySource sameCharacters: otherSource) = otherSource size]								ifFalse: [false]]						ifFalse: 							[(otherSource size - 1 = mySource size								and: [otherSource last = Character cr])									ifTrue: [(mySource sameCharacters: otherSource) = mySource size]									ifFalse: [false]]].	^isSourceSame</body><body package="Store-Database Model">reconcilesWith: aStoreMethod	"Return true if we appear to be the same entry, but potentially in a different database	Leave out the timestamp. Leave out version, since that is only used for External Methods and is not really a compare thing"	(self selector isSameSequenceAs: aStoreMethod selector) ifFalse: [^false].	(self classNameWithMeta isSameSequenceAs: aStoreMethod classNameWithMeta) ifFalse: [^false].	self isMeta = aStoreMethod isMeta ifFalse: [^false].	(self protocol isSameSequenceAs: aStoreMethod protocol) ifFalse: [^false].	"This is tricky. If we have no proxy for our source - that is, we're created from in-memory data, and the other method has an uninstantiated proxy, then we treat that as meaning that it has been read in such a way that only those methods in the change set have had source read. Therefore, we say that we match"	((self basicSource isGlorpProxy not or: 			[self basicSource class == AdHocProxy				and: [self basicSource isInstantiated not]])		and: 			[aStoreMethod basicSource isGlorpProxy and: 					[aStoreMethod basicSource class ~~ AdHocProxy						and: [aStoreMethod basicSource isInstantiated not]]])			ifTrue: [^true]			ifFalse: 				["And as a special bonus, apparently when things are put into parcel sources they may, but don't necessarily, get an extra newline appended to the end. So ignore those."				(self isSource: self source sameAs: aStoreMethod source)					ifFalse: [^false].				self comment = aStoreMethod comment ifFalse: [^false]].	^true</body><body package="Store-Database Model">unreconcile	super unreconcile.	(comment yourSelf notNil and: [comment source isEmpty]) ifTrue: [comment := nil].</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	source := source glorpCopyIn: aDictionary.	comment := comment glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>loading</category><body package="Store-Database Model">loadSource	| mySelector class myProtocol result currentPackage |	currentPackage := Store.Policies packagePolicy forcedPackage.	(class := self correspondingImageClass) ifNil: 		[| msg |		msg := AbstractPundleLoader unloadableMethodMessageForUnloadedClass: self className.		^self raiseUnloadableError: msg inPackage: currentPackage].	mySelector := self selector.	myProtocol := self protocol.	((class includesSelector: mySelector)		and: [(class organization categoryOfElement: mySelector) = myProtocol 		and: [(class compiledMethodAt: selector) getSource string = self definitionString]])			ifTrue: 				[result := class compiledMethodAt: selector.				currentPackage ifNotNil: 					[Store.XChangeSet current moveSelector: mySelector class: class toPackage: currentPackage]]			ifFalse:				[| environment |				environment := currentPackage ifNotNil:					[currentPackage environmentFor: mySelector in: class].				result := class					compile: self definitionString					classified: myProtocol					notifying: nil					environment: environment].	^result</body><body package="Store-Database Model">loadSourceDirect	^self loadSourceDirectInPackage: Store.Policies packagePolicy forcedPackage.</body><body package="Store-Database Model">loadSourceDirectInPackage: aPackage	| mySelector class myProtocol result environment |	aPackage ifNil: [^self loadSource].	(class := self correspondingImageClass) ifNil: 		[| msg |		msg := AbstractPundleLoader unloadableMethodMessageForUnloadedClass: self className.		^self raiseUnloadableError: msg inPackage: aPackage].	mySelector := self selector.	myProtocol := self protocol.	(Override overrideForSelector: mySelector class: class in: aPackage) ifNotNil:		[:existingOverride |		| compiledMethod |		compiledMethod := (class compilerClass new parse: self definitionString in: class notifying: nil) generate.		compiledMethod sourcePointer: self definitionString.		existingOverride setOverriddenDefinition: compiledMethod.		^existingOverride setOverriddenProtocol: myProtocol].	((class includesSelector: mySelector)		and: [(class organization categoryOfElement: mySelector) = myProtocol 		and: [(class compiledMethodAt: mySelector) getSource string = self definitionString		and: [aPackage = (Registry containingPackageForSelector: mySelector class: class)]]])			ifTrue: [^nil].	environment := aPackage ifNotNil: [aPackage environmentFor: mySelector in: class].	result := class		compile: self definitionString		classified: myProtocol		notifying: nil		environment: environment.	^result</body><body package="Store-Database Model">removeFromImage	self correspondingImageClass ifNotNil: [:value | value removeSelector: self selector]</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>printing</category><body package="Store-Database Model">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self classNameWithMeta.	aStream		nextPutAll: '&gt;&gt;';		nextPutAll: self name;		nextPut: $)</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStoreMethodDefinition	^self</body><body package="Store-Database Model">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage methods		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session		readOneOf: StoreMethodInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="StoreForGlorpVWUI">asText	^self source asText.</body><body package="Store-Database Model">correspondingImageMethod	| class |	class := (Dialect smalltalkAt: self className ifAbsent: [^nil]).	^(self isMeta 		ifTrue: [class class]		ifFalse: [class]) compiledMethodAt: self selector asSymbol ifAbsent: [nil].</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>fileIn/Out</category><body package="Store-Database Model">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	| dictionary |	dictionary := Dictionary new.	dictionary at: self protocol put: (Set with: self).	aStream fileOutTTMessages: dictionary for: self classNameWithMeta logging: false.</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeMethod: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedMethodObject</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>displaying</category><body package="Store-Database Model">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self signature		with: self timeStampString		with: self username</body><body package="StoreForGlorpVWUI">itemString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self name		with: self timeStampString		with: self username</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>private</category><body package="Store-Database Model">privateGetLongName	"The size of ' class' is 6, so we don't bother measuring that"	^className allButLast: 6</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>database utility</category><body package="Store-Database Model">allMethodVersionsNamed: aString inClass: aClassName meta: aBoolean	"Wildcard search and select for methods that are in a class in the image"	| query session classNameString |	session := StoreLoginFactory currentStoreSession.	classNameString := (aBoolean and: [aClassName namesMetaClass not]) 		ifTrue: [aClassName , ' class'] 		ifFalse: [aClassName].	query := Query		read: self		where: [:eachMethod | (eachMethod name = aString) AND: (eachMethod className = classNameString)].	^session execute: query.</body><body package="Store-Database Model">allNamesMatching: aString		^self allNamesMatching: aString in: nil</body><body package="Store-Database Model">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copy replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body><body package="Store-Database Model">allNamesMatching: aString inClassNamed: aClassName	"Wildcard search and select for methods that are in a class in the image"	| query session likeString |	likeString := aString copy replaceAll: $* with: $%.	session := StoreLoginFactory currentStoreSession.	query := Query		read: self		where: [:eachMethod | (eachMethod name like: likeString) AND: [eachMethod className = aClassName]].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query.</body><body package="Store-Database Model">chooseAvailableMethodMatching: aString notIn: aClass	"Wildcard search and select for methods not currently in the image for a particular class"	"StoreMethodInPackage chooseAvailableMethodMatching: '*' notIn: Store.Method "	| list names |	(Gathering for: aClass) started.	list := self allNamesMatching: aString inClassNamed: aClass absoluteName.	(Gathering for: aClass) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#NoSelectorsMatching1s &lt;&lt; #store &gt;&gt; 'No selectors matching &lt;1s&gt;'						expandMacrosWith: aString)].	names := list reject: [:each | aClass includesSelector: each asSymbol].	names := names asSortedCollection.	names isEmpty		ifTrue: 			[^Dialog				warn: (#NoRemovedMethodsIn1s &lt;&lt; #store &gt;&gt; 'No removed methods in &lt;1s&gt;'						expandMacrosWith: aClass fullName)].	^SimpleDialog new		chooseMultiple: #ChooseSelectors &lt;&lt; #store &gt;&gt; 'Choose selectors...'		fromList: names		values: names		buttons: #()		values: #()		lines: 12		cancel: nil		for: nil</body><body package="Store-Database Model">selectVersionNamed: aName in: ownerName meta: aBoolean		| list |	list := self allMethodVersionsNamed: aName inClass: ownerName meta: aBoolean.	list isEmpty		ifTrue:			[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.			^nil].	list size == 1 ifTrue: [^list first].	^Dialog		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (list collect: [:m | m itemString])		values: list		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>installation</category><body package="Store-Database Model">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy methodsTableSpace</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>instance creation</category><body package="StoreForGlorpVWUI">newFromMethodDescriptor: aMethodDescriptor	"If the StoreMethod created by this call is for a method that is a CType definition and if it will be published to a Store Database and if we care that our published version be loadable in a 7.6 or earlier image, then we need to set the ridiculously-named 'version' instVar to 'CTYPE' in the code below."	| method |	method := self new name: aMethodDescriptor selector.	method className: aMethodDescriptor classNameWithMeta.	method isMetaclass: aMethodDescriptor isMeta.	method basicSource: (AdHocProxy readBlock: [StoreBlob forString: aMethodDescriptor sourceCode asString]).	aMethodDescriptor protocol notNil		ifTrue: [method protocol: aMethodDescriptor protocol].	method setCTypeForPre77StoreFrom: aMethodDescriptor method.	^method.</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>constants</category><body package="Store-Database Model">inPackageClass	^StoreMethodInPackage</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>field list</category><body package="Store-UI">fieldAll	^(#AsterisksAllAsterisks &lt;&lt; #store &gt;&gt; '*** all ***') asString</body><body package="Store-UI">fieldList	"Answer a collection of the keys of the inspected dictionary."	| keys | 	keys := OrderedCollection new.	object keysDo: [:each | keys add: each].	keys add: self fieldAll.	^keys asSortedCollection</body><body package="Store-UI">fieldMenu	^(InputState default ctrlDown or: [self object isMainChangeSet])		ifTrue: [field isSymbol				ifTrue: [Menu						labels: (#inspectChangesToClaEmptyAllChanges &lt;&lt; #store &gt;&gt; 'inspect changes to class&lt;n&gt;file out changes to class as...&lt;n&gt;empty changes to class...&lt;n&gt;file out all changes as ...&lt;n&gt;empty all changes...') expandMacros						lines: #(3)						values: #(#inspectField #fileOutField #emptyField #fileOut #empty)]				ifFalse: [Menu labels: (#fileOutAllChangesAEmptyAllChanges &lt;&lt; #store &gt;&gt; 'file out all changes as ...&lt;n&gt;empty all changes...') expandMacros values: #(#fileOut #empty)]]		ifFalse: [field isSymbol				ifTrue: [Menu						labels: (#fileOutChangesToClUtAllChangesAs &lt;&lt; #store &gt;&gt; 'file out changes to class as...&lt;n&gt;file out all changes as ...') expandMacros						lines: #(1)						values: #(#fileOutField #fileOut)]				ifFalse: [Menu labels: (#fileOutAllChangesAs &lt;&lt; #store &gt;&gt; 'file out all changes as ...') asString  values: #(#fileOut)]]</body><body package="Store-UI">fieldValue	field = self fieldAll ifTrue: [ ^object ].	^object at: field		ifAbsent: 	['no longer any changes to this class']</body><body package="Store-UI">printItems	"Answer whether the elements of the list of fields needs to be converted to strings"	^false</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>menu commands</category><body package="Store-UI">empty	(Dialog confirm: #ReallyEmptyThisChangeSet &lt;&lt; #store &gt;&gt; 'Really empty this change set?'for: self interfaceWindow) ifTrue: 		[self object initialize.		self changed: #text]</body><body package="Store-UI">emptyField	(Dialog confirm: ((#ReallyEmptyAllChangesToClass1s &lt;&lt; #store &gt;&gt; 'Really empty all changes to class &lt;1s&gt;?') asString				expandMacrosWith: self field)		for: self interfaceWindow) 			ifTrue: 				[self object doClassChange: ((Change new)							classSymbol: self field;							removeChanges).				field := nil.				self changed: #field]</body><body package="Store-UI">fileOut	| fileName |	fileName := Dialog 				requestNewFileName: #FileOutAsFileNamed &lt;&lt; #store &gt;&gt; 'File out as file named'				default: 'filename.st'.	fileName isEmpty ifTrue: [^self].	fileName := Filename named: fileName.	Transcript 		show: (#NnFilingOutChangesOnNt1s &lt;&lt; #store &gt;&gt; '&lt;nn&gt;Filing out changes on:&lt;nt&gt;&lt;1s&gt;' expandMacrosWith: fileName asString).	Cursor write showWhile: 			[| strm |			strm := SourceCodeStream write: fileName.						[strm timeStamp.			self object fileOutOn: strm] ensure: [strm close]]</body><body package="Store-UI">fileOutField	| fileName |	fileName := Dialog 				requestNewFileName: (#FileOutChangeTo1sAsFileNamed &lt;&lt; #store &gt;&gt; 'File out change to &lt;1s&gt; as file named' expandMacrosWith: self field)				default: 'filename.st'.	fileName isEmpty ifTrue: [^self].	fileName := Filename named: fileName.	Transcript 		show: (#NnFilingOutChangesOnNt1s &lt;&lt; #store &gt;&gt; '&lt;nn&gt;Filing out changes on:&lt;nt&gt;&lt;1s&gt;' expandMacrosWith: fileName asString).	Cursor write showWhile: 			[| strm |			strm := SourceCodeStream write: fileName.						[strm timeStamp.			self object fileOutOn: strm classSymbol: self field] 					ensure: [strm close]]</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>initialize-release</category><body package="Store-UI">inspect: anObject 	super inspect: anObject .	self field: self fieldAll.</body><body package="Store-UI">viewLabel	^windowLabel == nil 		ifTrue: 			[self object isMainChangeSet 				ifTrue: [(#MainChanges &lt;&lt; #store &gt;&gt; 'Main Changes') asString]				ifFalse: [(#PackageChanges &lt;&lt; #store &gt;&gt; 'Package Changes') asString]]		ifFalse: [windowLabel]</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>accessing</category><body package="Store-UI">windowLabel: aString	windowLabel := aString</body></methods><methods><class-id>Store.ChangeSetInspector class</class-id> <category>view creation</category><body package="Store-UI">inspect: anObject label: aLabel	"Answer an instance of me to provide an inspector for anObject."	^self open: 		( self new 			windowLabel: aLabel;			inspect: anObject		)</body><body package="Store-UI">open: anInspector 	"Create and schedule a window on the model, anInspector."	| window |	anInspector allButOpenInterface: #windowSpec.	window := anInspector builder window.	anInspector finallyOpenIn: (window defaultRectangle: (300 @ 200) rounded)		withType: #normal</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>fileIn/Out</category><body package="Store-UI">fileOutOn: aSourceCodeStream	| sublist |	sublist := list reject: [ :mod | removed includes: mod ].	aSourceCodeStream deferInitializations.	sublist do: [ :next | next fileOutOn: aSourceCodeStream ].	aSourceCodeStream checkMethodChunkClass: nil protocol: nil.	aSourceCodeStream finishInitializations.</body><body package="Store-UI">includesFileName: aString	"Answer true if any of the non-removed changes in the list is 	from a file named aString."	^false</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>private</category><body package="Store-UI">conflictObjectFor: anItem	"Answer the object to compare to. nil if there is none."	^( self conflictPundle == nil ) 		ifFalse: 			[ conflictCache at: anItem ifAbsentPut:				[ conflictPundle recordForTag: anItem tag ]			]</body><body package="Store-UI">conflictSummaryForChange: change 	| protocol |	^( ( change isMethodRelated and: 		[ ( protocol := ( self conflictObjectFor: change ) protocol ) ~= ( change systemCategory ) ] ) 			ifTrue: [ #protocol1s &lt;&lt; #dialogs &gt;&gt; 'protocol &lt;1s&gt;'  expandMacrosWith: protocol ]			ifFalse: [#NoConflict &lt;&lt; #dialogs &gt;&gt; 'no conflict' ] 		  ) asText emphasizeAllWith: #italic</body><body package="Store-UI">doFrom: firstIndex 	"Replay all the changes from the supplied index. Reset selection each time through the loop,	 so that if an error occurs, the selection is left at the item which caused it."	DbRegistry isOnlineImage ifFalse: 		[^Dialog warn: #NotConnectedToTheDatabase &lt;&lt; #store &gt;&gt; 'Not connected to the database.'].	super doFrom: firstIndex</body><body package="Store-UI">doThis: listIndex 	"Revert the change at listIndex to it's parent and update the entry."	| rec mod |	DbRegistry isOnlineImage ifFalse: 		[^Dialog warn: #NotConnectedToTheDatabase &lt;&lt; #store &gt;&gt; 'Not connected to the database.'].	mod := list at: listIndex.	(rec := self conflictObjectFor: mod) == nil ifTrue: 		[^Dialog warn: (#_1sCannotBeReverted &lt;&lt; #store &gt;&gt; '&lt;1s&gt; cannot be reverted.' expandMacrosWith: mod tag name)].	mod isCommentChange 		ifTrue: [rec loadCommentFor: mod tag actual]		ifFalse: 			[rec loadSrcIntoPackage: mod package confirm: false.			mod package changeSet forgetTag: mod tag.	"just the current one"			mod text: rec definition].	self updateSelection: listIndex</body><body package="Store-UI">fieldTemplates	"return the templates for the fields (show file etc)"	^#(	#( showComponent showProtocol showConflicts )		#( componentString category conflicts))</body><body package="Store-UI">filterTemplates	"return the templates for the filters"	^#(	#( filterByPackage filterByType filterByClass filterByProtocol filterBySelector )		#( packageName type className category selector )        )</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>aspects</category><body package="Store-UI">labelFor: aKey 	"Return a label for the existingText view."	| mod protocol conflictString |	aKey == #windowLabel ifTrue: [^self windowLabel].	conflictString := self conflictPundle == nil 				ifTrue: [(#notConnected &lt;&lt; #store &gt;&gt; 'not connected') asString]				ifFalse: [self conflictPundle versionString].	selectionIndex &gt; 0 		ifTrue: 			[mod := self selection.			(aKey == #imageLabel 				and: [mod tag isForMethod and: [(protocol := mod protocol) notNil]]) 					ifTrue: ['&lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: conflictString with: protocol]].	aKey == #imageLabel 		ifTrue: 			[^#FromDatabase1s2s &lt;&lt; #store &gt;&gt; 'From database: &lt;1s&gt;: &lt;2s&gt;' 				expandMacrosWith: dbIdentifier				with: conflictString].	aKey == #changeLabel 		ifTrue: 			[^selectionIndex &gt; 0 				ifTrue: [(#From1s &lt;&lt; #store &gt;&gt; 'From &lt;1s&gt;') expandMacrosWith: mod componentString]				ifFalse: [(#SelectedChange &lt;&lt; #store &gt;&gt; 'Selected Change') asString]].	^nil</body><body package="Store-UI">windowLabel	^pundle == nil 		ifTrue: [(#PundleChangesList &lt;&lt; #store &gt;&gt; 'Pundle Changes List') asString]		ifFalse: 			[#_1s2sChangeListFrom3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt; Change List from &lt;3s&gt;' 				expandMacrosWith: pundle name				with: (pundle versionStringFor: dbIdentifier)				with: dbIdentifier asString]</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>accessing</category><body package="Store-UI">conflictPundle	"Answer the pundle used for comparisons. Defualt is pundle's parent."	conflictPundle == nil		ifTrue: 			[ conflictPundle := pundle parentRecord.			conflictCache := IdentityDictionary new.			 ]		ifFalse: 			[ conflictPundle isInCurrentDatabase				ifFalse:  					[ conflictPundle := pundle parentRecord.	"try to rehook"					conflictCache := IdentityDictionary new.					].			].	^conflictPundle</body><body package="Store-UI">conflictTextFor: anItem	"Asnwer the text to display in the conflict text window."	| obj |	obj := self conflictObjectFor: anItem.	^anItem tag isCommentTag		ifTrue: [ obj comment ]		ifFalse: [ obj text ]</body><body package="Store-UI">dbIdentifier	^dbIdentifier</body><body package="Store-UI">dbIdentifier: aSymbol	^dbIdentifier := aSymbol asSymbol</body><body package="Store-UI">noConflictTextFor: mod 	"Answer a Text corresponding to the conflicting text of the selected item in the system.	This is in fact, the reason why there is no text to compare to. Answer nil if okay to compare."	DbRegistry isOnlineImage ifFalse: 		[^(#NotConnectedToTheDatabase &lt;&lt; #store &gt;&gt; 'Not connected to the database.') asString].	(pundle validateDatabaseId not and: [self conflictPundle == nil]) ifTrue: 		[^#NotConnectedToDatabase1s &lt;&lt; #store &gt;&gt; 'Not connected to database: &lt;1s&gt;' expandMacrosWith: dbIdentifier].	self conflictPundle isInCurrentDatabase ifFalse: 		[^#NoLongerConnectedToDatabase1s &lt;&lt; #store &gt;&gt; 'No longer connected to database: &lt;1s&gt;' expandMacrosWith: conflictPundle dbIdentifier].	(self conflictObjectFor: mod) == nil ifTrue: 		[^((#notIn1s &lt;&lt; #store &gt;&gt; 'not in &lt;1s&gt;') expandMacrosWith: self conflictPundle displayString) asText emphasizeAllWith: #italic].	^nil</body><body package="Store-UI">pundle	^pundle</body><body package="Store-UI">pundle: aPundle	pundle := aPundle</body><body package="Store-UI">selectionText	"Answer the text of the item currently selected, or nil if none."	| txt |	(txt := super selectionText) == nil 		ifTrue: 			[txt := (self selection == nil or: [self selection existsInPackage]) 						ifFalse: 							[#notIn1s &lt;&lt; #store &gt;&gt; 'not in &lt;1s&gt;' 								expandMacrosWith: self pundle displayString]						ifTrue: ['']].	^txt</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>menu messages</category><body package="Store-UI">findPackage	"Prompt and search for all changes of a given package. Select these changes"	self find: #packageName prompt: #package filter: #packageName</body><body package="Store-UI">removeConflictsWithParent	"Remove those changes that conflict with the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | | rec |				( removed includes: mod ) not					and: [ ( ( rec := self conflictObjectFor: mod ) == nil							or: [ ( ( rec textRepresentationForTag: mod tag ) = mod text ) not ] )						]				]			)		].	self redisplayList</body><body package="Store-UI">removeEverythingNotInParent	"Remove those changes in methods not in the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | 				( removed includes: mod ) not and: 					[ ( self conflictObjectFor: mod ) == nil ] 				]			)		].	self redisplayList</body><body package="Store-UI">removeMethodsNotInParent	"Remove those changes in methods not in the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | 				( removed includes: mod ) not and: 					[ mod isMethodRelated and: [ ( self conflictObjectFor: mod ) == nil ] ]				]			)		].	self redisplayList</body><body package="Store-UI">removeSameSourceAsParent	"Remove those changes that are exactly the same as the conflict."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list reject: 				[ :mod | | rec |				( removed includes: mod )					or: [ ( ( rec := self conflictObjectFor: mod ) == nil							or: [ ( ( rec textRepresentationForTag: mod tag ) = mod text ) not ] )						]				]			)		].	self redisplayList</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>menu bar actions</category><body package="Store-UI">toggleShowComponent	self fieldMessage: #showComponent</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>instance creation</category><body package="Store-UI">openOn: aPundle 	^self openOn: aPundle for: aPundle anyDatabaseId</body><body package="Store-UI">openOn: aPundle for: dbid 	^(self new)		pundle: aPundle;		dbIdentifier: dbid;		openOn: (aPundle modificationsFor: dbid)</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>aspects</category><body package="Store-Merge Management">list	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^list isNil		ifTrue:			[list := SelectionInList new]		ifFalse:			[list]</body><body package="Store-Merge Management">reset	self list list: List new.</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>interface opening</category><body package="Store-Merge Management">labelForConflictAtIndex: anIndex inView: aView  nameStyle: aSymbol	^(self list list at: anIndex)		labelInView: aView		nameStyle: aSymbol</body><body package="Store-Merge Management">postBuildWith: aBuilder	| widget |	super postBuildWith: aBuilder.	widget := self widget.	widget selectedVisualBlock: 		[ :view :index | self reverseLabel: (self labelForConflictAtIndex: index inView: view  nameStyle: nameStyle) ].	widget visualBlock: 		[ :view :index | BoundedWrapper on: (self labelForConflictAtIndex: index inView: view  nameStyle: nameStyle) ].</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>accessing</category><body package="Store-Merge Management">tabLabel	^(#ModificationList &lt;&lt; #store &gt;&gt; 'Modification List') asString</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>name style</category><body package="Store-Merge Management">setShowLongNames	nameStyle := #longListName.</body><body package="Store-Merge Management">setShowShortNames	nameStyle := #shortListName.</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>private</category><body package="Store-Merge Management">reverseLabel: aLabel 	"Build the wrappers needed to reverse the label to show it selected."	| rw |	rw := ReversingWrapper on: aLabel.	rw reverse setValue: true.	^BoundedWrapper on: rw</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>updating</category><body package="Store-Merge Management">updateResolutions		| currentResolution |	currentResolution := mergeTool selectedResolution.	self setListWidgetDisplayStringSelector.	self list list: (mergeTool filteredResolutions sorted: [:each :other | each shortListName &lt;= other shortListName]).	self list selection: currentResolution</body></methods><methods><class-id>Store.ResolutionsListPane class</class-id> <category>accessing</category><body package="Store-Merge Management">tabLabel	^(#ModificationList &lt;&lt; #store &gt;&gt; 'Modification List') asString</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>aspects</category><body package="Store-UI">fromVersionLabel	^self printText: from</body><body package="Store-UI">swapButton	| button |	button := ClickableGraphic new.	button		idleGraphic: ComparisonIcons swapFileoutDirection;		mouseOverGraphic: ComparisonIcons swapFileoutDirectionActive;		mouseDownGraphic: ComparisonIcons swapFileoutDirectionPressed.	button		tooltip: #FileoutDialogSwapButtonTooltip				&gt;&gt; 'Toggle direction of the fileout (switch from with to).' &lt;&lt; #IDE.	button when: Clicked send: #swap to: self.	^button</body><body package="Store-UI">toVersionLabel	^self printText: to</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>private</category><body package="Store-UI">computePreferredWidth	^50 + ((Label with: (self printText: from)) width				max: (Label with: (self printText: to)) width)		+ 10 + 35		max: 280</body><body package="Store-UI">printText: aStorePundleObject	| versionString |	versionString := aStorePundleObject isImageModel		ifTrue: [aStorePundleObject traceVersion]		ifFalse: [aStorePundleObject version].	^versionString asText allBold</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>interface opening</category><body package="Store-UI">fixAnnotationLabels	(self widgetAt: #FromLabel) label text emphasizeAllWith: nil.	(self widgetAt: #ToLabel) label text emphasizeAllWith: nil</body><body package="Store-UI">interfaceSpecFor: aSymbol	| spec |	spec := super interfaceSpecFor: aSymbol.	spec window bounds: (Point zero				corner: self computePreferredWidth @ spec window bounds height).	^spec</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self fixAnnotationLabels</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>accessing</category><body package="Store-UI">from	^from</body><body package="Store-UI">from: anObject	from := anObject</body><body package="Store-UI">to	^to</body><body package="Store-UI">to: anObject	to := anObject</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>actions</category><body package="Store-UI">swap	| swap |	swap := from.	from := to.	to := swap.	(self widgetAt: #fromVersionLabel) labelString: (self printText: from).	(self widgetAt: #toVersionLabel) labelString: (self printText: to)</body></methods><methods><class-id>Store.FileoutDifferencesDialog class</class-id> <category>instance creation</category><body package="Store-UI">from: anOriginal to: aTarget	^(self new)		from: anOriginal;		to: aTarget;		yourself</body></methods><methods><class-id>Store.Glorp.StoreClassNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">classForName: aString	^self classForName: aString ifAbsent: [nil]</body><body package="StoreForGlorpBrowserUI">classForName: aString ifAbsent: aBlock	^self environment classForName:  aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">displayTextFor: classNameWrapper		| type each simpleName |	each := self objectForName: classNameWrapper fullName.	type := (each notNil and: [each isPatched])		ifTrue: [Array with: #color -&gt; self overriddenColor]		ifFalse: [#()].	simpleName := (each isNil		ifTrue: ['']		ifFalse: [each longNameFromSmalltalk]) asText.	(self class shouldBoldDefinedItems		and: [each notNil and: [self isClassOrNameSpaceDefinedInSelection: each]])		ifTrue: [simpleName emphasizeAllWith: (type copyWith: #bold)]		ifFalse: [simpleName emphasizeAllWith: type].	^simpleName</body></methods><methods><class-id>Store.Glorp.StoreClassNavigatorPart</class-id> <category>accessing-navigator</category><body package="StoreForGlorpBrowserUI">fillInState: aNavigatorState	aNavigatorState environment isNil		ifTrue: [aNavigatorState environment: self environment].	super fillInState: aNavigatorState</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>publishing</category><body package="Store-Ownership">allowedBlessingLevelsForPundle: aPundle 	"*** adapted from Philippe F. Monnet ***"	"Returns the list of allowed blessing levels for this pundle and the current 	owner"	| disallowedBlessings |	disallowedBlessings := OrderedCollection new.	self isImageAdministrator		ifFalse: 	[ disallowedBlessings addAll: self administratorBlessings ].	disallowedBlessings addAll: ( self disallowedBlessingsForPundle: aPundle ).	^self blessings reject: [ :b | disallowedBlessings includes: b level ].</body><body package="Store-Ownership">basicCanPublish: aPundle atBlessing: aBlessing	(self allowedBlessingLevelsForPundle: aPundle) do:		[ :bless | bless level = aBlessing 			ifTrue: [ ^true ] 		].	^false</body><body package="Store-Ownership">disallowedBlessingsForPundle: aPundle	self isImageAdministrator	      ifTrue:[ ^#( ) ].	self shouldValidateOwnership	ifFalse: [ ^#( ) ].	( Policies ownershipPolicy currentUserHasOwnershipPrivilegesFor: aPundle )		ifTrue:[ ^self administratorBlessings ].	^( Policies ownershipPolicy currentUserHasPublishingPrivilegesFor: aPundle )		ifTrue: [ self administratorBlessings, self ownerBlessings ]		ifFalse: [ self blessingNumbers ]</body><body package="Store-Ownership">objectionsToPublishingBundle: aBundle atBlessingLevel: aBlessingLevel 	"Return a string specifying why this bundle may 	not be published.  Return nil if it may."	^self objectionsToPublishingPundle: aBundle atBlessingLevel: aBlessingLevel</body><body package="Store-Ownership">objectionsToPublishingPackage: aPackage atBlessingLevel: aBlessingLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^self objectionsToPublishingPundle: aPackage atBlessingLevel: aBlessingLevel</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-Ownership">initialize	"OwnerBlessingPolicy blessingPolicy initialize"	super initialize.	( blessings at: #Integrated ) beOwnerOnly.	( blessings at: #ReadyToMerge ) beOwnerOnly.	( blessings at: #Merged ) beOwnerOnly.	( blessings at: #Release ) beAdminOnly.	( blessings at: #Tested ) beQaOnly.</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>administrator</category><body package="Store-Ownership">isImageAdministrator	"Returns a boolean indicating whether or not the user is the Image Administrator"	^DbRegistry isSystemAdministrator</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>private</category><body package="Store-Ownership">currentUserName	^DbRegistry currentUserName</body><body package="Store-Ownership">isOwnershipOn	^true</body><body package="Store-Ownership">objectionsToPublishingPundle: aPundle atBlessingLevel: aBlessingLevel 	"Return a string specifying why this Pundle may not be published.  Return nil if it may.	PRIVATE - public access through package/bundle versions of this method."	^self shouldValidateOwnership		ifTrue: 			[ | res1 res2 |			res1 := self validateOwnershipForPundle: aPundle blessingLevel: aBlessingLevel.			res2 := super objectionsToPublishingPundle: aPundle atBlessingLevel: aBlessingLevel.			( res1 notNil and: [ res2 notNil ] )				ifTrue: [ res1 , res2 ]				ifFalse: [ res1 notNil							ifTrue: [ res1 ]							ifFalse: [  res2 ]						]			]		ifFalse: [ nil ]</body><body package="Store-Ownership">shouldValidateOwnership		^self isOwnershipOn and: [#{Store.Glorp.StoreAccessPrivilege} isDefined]</body><body package="Store-Ownership">validateOwnershipForPundle: aPundle blessingLevel: aBlessingLevel 	^(self basicCanPublish: aPundle atBlessing: aBlessingLevel) 		ifTrue: [nil]		ifFalse: 			[#YouDoNotHaveTheRiLessingLevelOf2s &lt;&lt; #store 				&gt;&gt; 'You do not have the rights to publish &lt;1s&gt; at a blessing level of &lt;2s&gt;' 					expandMacrosWith: aPundle name					with: (self blessingName: aBlessingLevel)]</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>blessings</category><body package="Store-Ownership">administratorBlessings	"Returns a list of priviledged blessing numbers that should only be used by the Administrator"	^( self blessings select: [ :bless | bless isAdminOnly ] )		collect: [ :bless | bless level ]</body><body package="Store-Ownership">ownerBlessings	"Returns a list of priviledged blessing numberss that should only be used by the pundle owner."	" OwnerBlessingPolicy new ownerBlessings"	^( self blessings select: [ :bless | bless isOwnerOnly ] )		collect: [ :bless | bless level ]</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>blessing menus</category><body package="Store-Ownership">blessingLevelsMenu	"Answer a menu with all existing blessing names and levels."	| menu labels values list |	list := self blessings.	self isImageAdministrator		ifFalse: 			[ | adminBlessings |			adminBlessings := self administratorBlessings.			list  := list reject: [ :x | adminBlessings includes: x level ]			].	list := list asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body><body package="Store-Ownership">blessingLevelsMenuForPundle: aPundle	"*** from 9 January 1995 at 3:44:13 pm by PHM (Philippe F. Monnet	) in B941220 ***"	"Modified to filter out the privileged values for users other than the image administrator"	| list menu labels values  |	list := ( self allowedBlessingLevelsForPundle: aPundle ) asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>accessing</category><body package="Store-Database Model">groupName	^groupName</body><body package="Store-Database Model">groupName: aString	groupName := aString</body><body package="Store-Database Model">name	"Answer the receiver's userName."	^self userName</body><body package="Store-Database Model">session	^session</body><body package="Store-Database Model">session: anObject	session := anObject</body><body package="Store-Database Model">type	^type</body><body package="Store-Database Model">type: aString	type := aString</body><body package="Store-Database Model">userName	^userName</body><body package="Store-Database Model">userName: aString	userName := aString</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>comparing</category><body package="Store-Database Model">&lt;= aStoreUserGroup		aStoreUserGroup class == self class ifFalse: 		[^userName &lt;= aStoreUserGroup name].	^self isGroup = aStoreUserGroup isGroup 		ifTrue: [userName &lt;= aStoreUserGroup userName] 		ifFalse: [self isGroup]</body><body package="Store-Database Model">= aStoreUserGroup		aStoreUserGroup class == self class ifFalse: [^false].	^type = aStoreUserGroup type and: 		[userName = aStoreUserGroup userName and: 		[groupName = aStoreUserGroup groupName]]</body><body package="Store-Database Model">hash		^type hash bitXor: (userName hash bitXor: groupName hash)</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>printing</category><body package="Store-Database Model">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: userName;		nextPut: $~;		nextPutAll: type;		nextPutAll: ') '</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>testing</category><body package="Store-Database Model">isGroup	^type = 'G'</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>relationships</category><body package="Store-Database Model">relatedBy: relToken	"Anwer set of relations. Main relationship is owner-&gt;pundle."		relToken == #tt_ownsRel ifTrue: 		[^(self class pundlePrivilegesClass pundlesUser: self privilege: #owner) asSet].	relToken == #readRel ifTrue: 		[^(self class pundlePrivilegesClass pundlesUser: self privilege: #read) asSet].	relToken == #publishRel ifTrue: 		[^(self class pundlePrivilegesClass pundlesUser: self privilege: #publish) asSet].	^super relatedBy: relToken</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>instance creation</category><body package="Store-Database Model">newGroupNamed: aGroupName	^self newGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">newGroupNamed: aGroupName in: aSessionOrNil	| session instance |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	instance := self new.	session inUnitOfWorkDo:		[session register: instance.		instance groupName: aGroupName.		instance userName: aGroupName.		instance type: self groupType].</body><body package="Store-Database Model">newUserNamed: aUserName inGroupNamed: aGroupName	^self newUserNamed: aUserName inGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">newUserNamed: aUserName inGroupNamed: aGroupName in: aSessionOrNil	| session instance |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	instance := self new.	session inUnitOfWorkDo:		[session register: instance.		instance groupName: aGroupName.		instance userName: aUserName.		instance type: self userType].</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>query</category><body package="Store-Database Model">allDistinctUserGroups	^self allDistinctUserGroupsIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allDistinctUserGroupsIn: aSessionOrNil	| session groupNames userNames result |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	userNames := self allUserNamesIn: session.	groupNames := self allGroupNamesIn: session.	result := OrderedCollection new: userNames size + groupNames size.	result addAll: (userNames collect:		[:each | 		(self new)			userName: each;			session: session;			type: 'U']).	result addAll: (groupNames collect:		[:each | 		(self new)			userName: each;			session: session;			type: 'G']).	^result</body><body package="Store-Database Model">allGroupNames	^self allGroupNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allGroupNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each type = 'G'].	query retrieve: [:each | each groupName distinct].	query orderBy: #groupName.	^session execute: query</body><body package="Store-Database Model">allUserNames	^self allUserNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allUserNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each type = 'U'].	query retrieve: [:each | each userName distinct].	query orderBy: #userName.	^session execute: query</body><body package="Store-Database Model">dbHasAdmin	"self dbHasAdmin"		^self tableExists and: [(self userNamesInGroupNamed: self adminGroupName) notEmpty]</body><body package="Store-Database Model">groupNamesForUserNamed: aString	^self groupNamesForUserNamed: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">groupNamesForUserNamed: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each userName = aString AND: (each type = 'U')].	query retrieve: [:each | each groupName distinct].	^session execute: query</body><body package="Store-Database Model">groupsForUser: aStoreUser	| groupNames result session |	session := aStoreUser session ifNil: [StoreLoginFactory currentStoreSession].	groupNames := self groupNamesForUserNamed: aStoreUser userName in: session.	result := OrderedCollection new: groupNames size.	result addAll: (groupNames collect:		[:each | 		(self new)			userName: each;			session: session;			type: 'G']).	^result</body><body package="Store-Database Model">isInAdmin: aString		^self isInAdmin: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">isInAdmin: aString in: aSession		^(self userNamesInGroupNamed: self adminGroupName in: aSession) includes: aString</body><body package="Store-Database Model">tableExists	^self tableExistsIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">tableExistsIn: aSessionOrNil	| session schema tableName accessor |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	accessor := session accessor.	schema := StoreDescriptorSystem		platformSpecificSchemaFor: accessor		tableName: (tableName := 'TW_DBUserGroup').	^(accessor isExistingTable: tableName inSchema: schema)</body><body package="Store-Database Model">userNamed: aString	^self userNamed: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">userNamed: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each userName = aString AND: (each type = 'U')].	^session execute: query</body><body package="Store-Database Model">userNamed: aUserName inGroupNamed: aGroupName	^self userNamed: aUserName inGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">userNamed: aUserName inGroupNamed: aGroupName in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: 		[:each | 		each groupName = aGroupName AND: (each userName = aUserName) AND: (each type = 'U')].	^session execute: query</body><body package="Store-Database Model">userNamesInGroupNamed: aString	^self userNamesInGroupNamed: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">userNamesInGroupNamed: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each groupName = aString AND: (each type = 'U')].	query retrieve: [:each | each userName distinct].	^session execute: query</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>database utility</category><body package="Store-Database Model">removeUserNamed: aUserName inGroupNamed: aGroupName	self removeUserNamed: aUserName inGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">removeUserNamed: aUserName inGroupNamed: aGroupName in: aSessionOrNil	| session instance |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	instance := self userNamed: aUserName inGroupNamed: aGroupName in: session.	session accessor permitEverythingDuring:		[session inUnitOfWorkDo: [session delete: instance]].</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>installation</category><body package="Store-Database Model">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy userAndOwnershipTableSpace</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>accessing</category><body package="Store-Database Model">adminGroupName	^'ADMINISTRATOR'</body><body package="Store-Database Model">groupType	^'G'</body><body package="Store-Database Model">pundlePrivilegesClass	^StoreAccessPrivilege</body><body package="Store-Database Model">userType	^'U'</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>private</category><body package="Store-User Management">initialVersionOf: reqName fromList: pundleList version: reqVersion	"Answer the inital version for testing. nil means user cancelled."		| versionToUse |	self versionSelection == #ask ifFalse: 		[versionToUse := pundleList detect: [:aPundle | self isSatisfiedBy: aPundle] ifNone: [nil]].	versionToUse ifNil: 		[versionToUse := self selectPrereqVersionOf: reqName fromList: pundleList version: reqVersion.		versionToUse isSymbol ifTrue: [^self processPrereqResultFor: versionToUse]].	^versionToUse</body><body package="Store-User Management">isSatisfiedBy: p		^p blessingLevelNumber &gt;= self blessingLevel.</body><body package="Store-User Management">processPrereqResultFor: aSymbol	aSymbol == #quitLoading ifTrue: [^LoadCanceled raiseSignal].	aSymbol == #tryParcel ifTrue: [^nil].	SkipPrerequisite raiseSignal</body><body package="Store-User Management">selectPrereqVersionOf: aPundleName fromList: aList version: aString	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."		^PrerequisiteSelector openWith: aList</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>accessing</category><body package="Store-User Management">blessingLevel	blessingLevel == nil		ifTrue: [ blessingLevel := Policies blessingPolicy defaultBlessing ].	^blessingLevel</body><body package="Store-User Management">blessingLevel: anInteger	blessingLevel := anInteger</body><body package="Store-User Management">searchOrder	searchOrder == nil		ifTrue: [ searchOrder := #parcelsFirst ].	^searchOrder</body><body package="Store-User Management">searchOrder: aSymbol		searchOrder := aSymbol</body><body package="Store-User Management">versionSelection	versionSelection == nil		ifTrue: [ versionSelection := #ask ].	^versionSelection</body><body package="Store-User Management">versionSelection: aSymbol	versionSelection := aSymbol</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>selecting</category><body package="Store-User Management">getPrereq: reqName from: pundleList version: reqVersion for: aPundle 	"Removed loop. Enabled to enforce loading of differing package version"	| pundle |	( pundle := self 				initialVersionOf: reqName				fromList: pundleList				version: reqVersion ) == nil 		ifTrue: [ ^ nil ].	"user cancelled selection"	( pundle == nil or: 			[ aPundle 				checkPrerequisiteNamed: reqName				withVersion: pundle version				requiredVersion: reqVersion ] ) 		ifTrue: [ ^pundle ].	( Dialog confirm: ( (#_1sRequiresNt2sAdNt4sNInstead &lt;&lt; #store &gt;&gt; '&lt;1s&gt; requires&lt;nt&gt;&lt;2s&gt; version: &lt;3s&gt;&lt;n&gt;Do you want to load&lt;nt&gt;&lt;4s&gt;&lt;n&gt;instead?') 						expandMacrosWith: aPundle displayString with: reqName with: reqVersion with: pundle displayString ) )			ifTrue: [ ^pundle ].	^self selectPrereqVersionOf: reqName fromList: pundleList version: reqVersion.</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentTabNavigatorPart</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">classes	| classes |	classes := self componentNamed: #classes.	classes isNil 		ifTrue: 			[classes := StoreClassNavigatorPart new.			navigator notNil ifTrue: [classes navigator: navigator].			self componentNamed: #classes put: classes].	^classes</body><body package="StoreForGlorpBrowserUI">packages	| packages |	packages := self componentNamed: #packages.	packages isNil 		ifTrue: 			[packages := StorePundleNavigatorPart new.			navigator notNil ifTrue: [packages navigator: navigator].			self componentNamed: #packages put: packages].	^packages</body></methods><methods><class-id>Store.PackageObjectsToInitialize</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">addClass: aClass	^classes add: aClass</body><body package="Atomic Compiling and Loading">addSharedVariable: aSharedVariable	^sharedVariables add: aSharedVariable</body><body package="Atomic Compiling and Loading">classes	^classes</body><body package="Atomic Compiling and Loading">classes: anObject	classes := anObject</body><body package="Atomic Compiling and Loading">package	^package</body><body package="Atomic Compiling and Loading">package: anObject	package := anObject</body><body package="Atomic Compiling and Loading">sharedVariables	^sharedVariables</body><body package="Atomic Compiling and Loading">sharedVariables: anObject	sharedVariables := anObject</body></methods><methods><class-id>Store.PackageObjectsToInitialize</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize	classes := OrderedCollection new.	sharedVariables := OrderedCollection new.</body></methods><methods><class-id>Store.PackageObjectsToInitialize class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Atomic Compiling and Loading">newFor: aPackage	"Answer a newly created and initialized instance."	^self new		package: aPackage</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>actions</category><body package="Store-UI">compareSelectionWith	| method target |	method := self itemsInList selections first.	target := StoreMethodInPackage 		selectStoreVersionOf: method name 		inClass: method classNameWithMeta 		in: method package session.	target ifNotNil: [MethodDifferenceBrowser 		compare: method definitionString 		with: target definitionString 		protocol: method protocol 		with: target protocol]</body><body package="Store-UI">compareVersions	| method target |	method := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	MethodDifferenceBrowser compare: method definitionString with: target definitionString protocol: method protocol with: target protocol</body><body package="Store-UI">compareWithImage	| method target |	method := self itemsInList selections first.	target := method definition correspondingImageMethod.	target ifNotNil: [MethodDifferenceBrowser 		compare: method definitionString 		with: target getSource asString 		protocol: method protocol 		with: target protocol]</body><body package="Store-UI">containingPackages	| method packages |	method := self itemsInList selections first.	[(Gathering for: method name) started.	packages := StoreMethodInPackage allPackagesContaining: method.	(Gathering for: method name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: method signature</body><body package="Store-UI">fileOut	| method fileName fileManager |	method := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (method longNameFromSmalltalk, '-', (method name copyWithout: $:) replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: method package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			method fileOutOn: fileManager]				ensure: [fileManager close].			(FilingOut for: method package) finished].</body><body package="Store-UI">loadMethod		| package method |	method := self itemsInList selections first.	package := method package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: (package storeModel  ifNil: [Registry packageNamed: package name])				while: 					[method loadSource].			(Loading for: package) finished].</body><body package="Store-UI">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText nextPutAllText: (each definitionString asText makeSelectorBoldIn: each classOrNameSpace).				updateText cr.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body><body package="Store-UI">setUpForRemovedMethodsIn: aClass	| methodNames list className skip session |		[((methodNames := StoreMethod				chooseAvailableMethodMatching: '*'				notIn: aClass) == nil		or: [methodNames isEmpty]) ifTrue: [^nil].	list := List new: methodNames size * 2.	className := aClass absoluteName.	skip := 100.	session := StoreLoginFactory currentStoreSession.	(Gathering for: aClass) started.	1 to: methodNames size		by: skip		do: 			[:index |			| subList |			subList := methodNames copyFrom: index						to: index + (methodNames size - index + 1 min: skip) - 1.			list addAll: (StoreMethodInPackage						allVersionsWithNameIn: subList						inClass: className						in: session)].	list := list asSortedCollection: 					[:each :other |					each name &lt; other name or: 							[each name = other name								and: [each definition timestamp &gt; other definition timestamp]]].	(Gathering for: aClass) finished]			withStoreFeedbackOn: self mainWindow.	self itemsInList list: list asList</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>accessing</category><body package="Store-UI">listTitle	self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title.</body><body package="Store-UI">title	^title ifNil: [(#VersionsOfMethod1s &lt;&lt; #store &gt;&gt; 'Versions of method &lt;1s&gt;' expandMacrosWith: self itemsInList list first signature)]</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>menu</category><body package="Store-UI">existsInImage	| method |	^self onlyOneItemSelected and: 		[method := self itemsInList selections first.		method definition correspondingImageMethod notNil]</body><body package="Store-UI">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection definition correspondingImageClass notNil]</body><body package="Store-UI">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>interface opening</category><body package="Store-UI">compositeViewUsing: aMethod nameSize: longestName protocolSize: longestProtocol longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView selected: aBoolean	|  currentStart nameLabel timestampLabel mainThing protocolLabel emphasis usernameLabel packageNameLabel |	currentStart := 4.	nameLabel := Label with: aMethod selector asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	emphasis := aBoolean 		ifTrue: [#bold]		ifFalse: [Array with: #bold with: #color -&gt; ColorValue darkGreen].	protocolLabel := Label with: (('"', aMethod protocol , '"') asText emphasizeAllWith: emphasis) attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestProtocol + 8.	timestampLabel := Label with: aMethod definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aMethod definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: (aMethod package name, ' ') asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing		add: nameLabel;		add: protocolLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestProtocol longestTimestamp longestUsername |	widget := (self widgetAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestProtocol := longestTimestamp := longestUsername := 0.	items do:		[:each | 		longestName := (Label with: each selector asText allBold attributes: widget textStyle) width max: longestName.		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestProtocol := (Label with: (each protocol , '""') asText allBold attributes: widget textStyle) width max: longestProtocol].	widget visualBlock:		[:view :index | 		| compositeView |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestName			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: false.		BoundedWrapper on: compositeView].	widget selectedVisualBlock:		[:view :index | 		| compositeView wrapper |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestName			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: true.		wrapper := ReversingWrapper on: compositeView.		wrapper reverse setValue: true.		BoundedWrapper on: wrapper].	widget tooltip: nil</body></methods><methods><class-id>Store.Glorp.MethodVersionsListPane</class-id> <category>interface opening</category><body package="Store-UI">compositeViewUsing: aMethod nameSize: longestPackage protocolSize: longestProtocol longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView selected: aBoolean	| currentStart timestampLabel mainThing protocolLabel emphasis usernameLabel packageNameLabel |	currentStart := 4.	timestampLabel := Label with: aMethod definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aMethod definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	emphasis := aBoolean 		ifTrue: [#bold]		ifFalse: [Array with: #bold with: #color -&gt; ColorValue darkGreen].	protocolLabel := Label with: (('"', aMethod protocol , '"') asText emphasizeAllWith: emphasis) attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestProtocol + 8.	packageNameLabel := Label with: (aMethod package name, ' ') asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: timestampLabel;		add: usernameLabel;		add: protocolLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestPackage longestProtocol longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestPackage := longestProtocol := longestTimestamp := longestUsername := 0.	items do:		[:each | 		longestPackage := (Label with: each package name asText allBold attributes: widget textStyle) width max: longestPackage.		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestProtocol := (Label with: (each protocol , '""') asText allBold attributes: widget textStyle) width max: longestProtocol].	widget visualBlock:		[:view :index | 		| compositeView |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestPackage			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: false.		BoundedWrapper on: compositeView].	widget selectedVisualBlock:		[:view :index | 		| compositeView wrapper |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestPackage			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: true.		wrapper := ReversingWrapper on: compositeView.		wrapper reverse setValue: true.		BoundedWrapper on: wrapper].	widget tooltip: nil</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>private</category><body package="Atomic Compiling and Loading">shadowBindingAt: aPath elseDo: aBlock	"Find and return the binding at aPath.  First look for the binding in the shadow 	 of Smalltalk. If no binding can be found, then use an instance of NameSpaceSearchRules	 to modify the look-up to try to find the binding in the system.   Finally, if no binding is found	 evaluate aBlock."	|modifiers|	modifiers := NameSpaceSearchRules new.	modifiers substitutions: Root.	^(self shadowRoot at: #Smalltalk)		bindingForPath: aPath		modifiers: modifiers		onMiss: [:env :aName | aBlock value]</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(';		print: self shadowRoot;		nextPutAll: ')'</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">shadowRoot	^shadowRoot</body><body package="Atomic Compiling and Loading">shadowRoot: aNameSpace	shadowRoot := aNameSpace</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>resolving</category><body package="Atomic Compiling and Loading">resolveBindingForShadow: binding protection: protection elseDo: aBlock 	((binding isKindOf: LiteralBindingReference) and: 			[binding isAbsolute 				and: [binding method environment = (self shadowRoot)]]) 		ifTrue: [^self shadowBindingAt: binding path elseDo: aBlock].	^aBlock value</body></methods><methods><class-id>Store.RequestImageAdministatorName</class-id> <category>constants</category><body package="Store-Base">defaultResumeValue	^DbRegistry userName</body><body package="Store-Base">defaultReturnValue	^DbRegistry userName</body></methods><methods><class-id>Store.RequestImageAdministatorName</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	| adminName |	[(adminName := Dialog 		request: #ImageAdministratorName &lt;&lt; #store &gt;&gt; 'Image Administrator Name:'								initialAnswer: DbRegistry tableOwner) notEmpty] whileFalse.	^adminName</body></methods><methods><class-id>Store.RequestImageAdministatorName class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.LoadingError</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">package	^package</body><body package="Atomic Compiling and Loading">package: anObject	package := anObject</body></methods><methods><class-id>Store.LoadingActionError</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">action	^action</body><body package="Atomic Compiling and Loading">action: anObject	action := anObject</body><body package="Atomic Compiling and Loading">error	^parameter</body><body package="Atomic Compiling and Loading">error: anError	parameter := anError</body></methods><methods><class-id>Store.LoadingActionError</class-id> <category>printing</category><body package="Atomic Compiling and Loading">defaultMessageText	^#_1sActionFor2sCHeErrorN3s4s &lt;&lt; #store 		&gt;&gt; '&lt;1s&gt; action for &lt;2s&gt; caused the error:&lt;n&gt;&lt;3s&gt;:&lt;4s&gt;' 			expandMacrosWith: action			with: package name			with: self error displayString			with: self error description</body></methods><methods><class-id>Store.LoadingActionError</class-id> <category>actions</category><body package="Atomic Compiling and Loading">defaultAction	"What to do when the exception is unhandled."	^Dialog confirm: ((#_1sNttContinue &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&lt;ntt&gt;Continue?') expandMacrosWith: self defaultMessageText)</body></methods><methods><class-id>Store.LoadingActionError class</class-id> <category>testing</category><body package="Atomic Compiling and Loading">mayResume	^true</body></methods><methods><class-id>Store.LoadingActionError class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">pundle: aPundle action: aSymbol error: anError	^self new		package: aPundle;		action: aSymbol;		error: anError;		raise</body></methods><methods><class-id>Store.Glorp.StoreBrowserCommentTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.IgnorePossibleOverrideNotice</class-id> <category>private - actions</category><body package="Store-Merge Management">defaultAction	^false</body></methods><methods><class-id>Store.IgnorePossibleOverrideNotice class</class-id> <category>testing</category><body package="Store-Merge Management">mayResume	^true</body></methods><methods><class-id>Store.EnvyStyleBlessingPolicy</class-id> <category>blessing names</category><body package="Store-Ownership">integrationReadyBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"		^(blessings at: #Development) level</body></methods><methods><class-id>Store.EnvyStyleBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-Ownership">initialize	"Policies blessingPolicy initializeBlessings"	self initializeBlessings.	self defaultBlessing: self developmentBlessing.	( blessings at: #Development ) beOwnerOnly.	( blessings at: #Integrated ) beOwnerOnly.	( blessings at: #Merged ) beOwnerOnly.	( blessings at: #Release ) beAdminOnly.</body><body package="Store-Ownership">initializeBlessings	"Policies blessingPolicy initializeBlessings"	blessings := IdentityDictionary new		at: #Broken put: ( BlessingLevel name: 'Broken' level: 10 );		at: #WorkInProgress put: ( BlessingLevel name: 'Scratch' level: 15 );	 	at: #Development put: ( BlessingLevel name:  'Edition' level: 20 );		at: #Integrated put: ( BlessingLevel name:  'Version' level: 50 );		at: #Merged put: ( BlessingLevel name:  'Release'  level: 60 );		at: #Release put: ( BlessingLevel name:  'Product' level:  99 );		yourself.</body></methods><methods><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">buildSelectorSubcanvas	| subcanvases |	subcanvases := self components.	(subcanvases size = 1 		and: [subcanvases first class = StoreSelectorNavigatorPart]) 			ifFalse: [self installSubcanvas: #selectorWithProtocolWindowSpec using: self]</body></methods><methods><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">categories	| categories |	categories := self componentNamed: #categories.	categories isNil 		ifTrue: 			[categories := StoreSharedVariableProtocolNavigatorPart new.			navigator notNil ifTrue: [categories navigator: navigator].			self componentNamed: #categories put: categories].	^categories</body><body package="StoreForGlorpBrowserUI">fillInState: aNavigatorState	aNavigatorState environment isNil		ifTrue: [aNavigatorState environment: self environment].	aNavigatorState type: type.	super fillInState: aNavigatorState</body><body package="StoreForGlorpBrowserUI">protocols		| protocols |	protocols := self componentNamed: #protocols.	protocols isNil		ifTrue:			[protocols := StoreSelectorProtocolNavigatorPart new.			navigator notNil ifTrue: [protocols navigator: navigator].			self componentNamed: #protocols put: protocols].	^protocols</body><body package="StoreForGlorpBrowserUI">selectors		| selectors |	selectors := self componentNamed: #selectors.	selectors isNil		ifTrue:			[selectors := StoreSelectorNavigatorPart new.			navigator notNil ifTrue: [selectors navigator: navigator].			self componentNamed: #selectors put: selectors].	^selectors</body><body package="StoreForGlorpBrowserUI">selectorsWithProtocol	| selectorsWithProtocol |	selectorsWithProtocol := self componentNamed: #selectorsWithProtocol.	selectorsWithProtocol isNil 		ifTrue: 			[selectorsWithProtocol := StoreSelectorNavigatorPart new.			selectorsWithProtocol listSelector: #allSelectorsIn:.			navigator notNil ifTrue: [selectorsWithProtocol navigator: navigator].			self componentNamed: #selectorsWithProtocol put: selectorsWithProtocol].	^selectorsWithProtocol</body><body package="StoreForGlorpBrowserUI">sharedVariables	| sharedVariables |	sharedVariables := self componentNamed: #sharedVariables.	sharedVariables isNil 		ifTrue: 			[sharedVariables := StoreSharedVariableNavigatorPart new.			navigator notNil ifTrue: [sharedVariables navigator: navigator].			self componentNamed: #sharedVariables put: sharedVariables].	^sharedVariables</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableNavigatorPart</class-id> <category>private-selectors</category><body package="StoreForGlorpBrowserUI">allSharedVariableDefinitionsFor: aProtocol in: class 	| sharedVariables |	sharedVariables := OrderedCollection new.	self inheritedClassesOf: class do: 		[:each | 		sharedVariables addAll: ((self environment sharedVariablesFor: aProtocol in: each) 			collect: [:eachVariable | StoreRBInitializerDefinition nameSpace: each key: eachVariable])].	^sharedVariables</body><body package="StoreForGlorpBrowserUI">allSharedVariablesIn: aNavigatorState		| sharedVariables nameSpaces nameSpace |	nameSpaces := aNavigatorState classesAndNameSpaces.	nameSpaces size ~= 1 ifTrue: [^#()].	nameSpace := nameSpaces asArray first.	sharedVariables := self environment sharedVariablesForClass: nameSpace.	^sharedVariables collect: [:each | StoreRBInitializerDefinition nameSpace: nameSpace key: each]</body></methods><methods><class-id>Store.Compiling</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">actionText	^(#Compiling &lt;&lt; #store &gt;&gt; 'Compiling') asString</body></methods><methods><class-id>Store.LoadOrSaveCompilationError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog warn: (#_1sCompilationErrorIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: Compilation error in &lt;2s&gt;' 		expandMacrosWith: messageText first 		with: messageText last)</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">comparison: aComparison	comparison := aComparison.	self isSimple ifTrue: [expandedFraction := 1].	self populate</body><body package="Store-Code Comparison">initialize	super initialize.	expandedFraction := 0.	filteredComponents := Set new</body><body package="Store-Code Comparison">initializeLayoutAlgorithm	self		layoutAlgorithm: [:rect :parts | self computeLayouts: parts bounds: rect]</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>event driven</category><body package="Store-Code Comparison">getEventHandler		^self</body><body package="Store-Code Comparison">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-Code Comparison">handlerForMouseEvent: aMouseEvent	^(aMouseEvent yellowButtonPressed		and: [(menuTarget := self menuTargetAt: aMouseEvent) notNil])			ifTrue: [self]			ifFalse: [super handlerForMouseEvent: aMouseEvent]</body><body package="Store-Code Comparison">menuTargetAt: aMouseEvent	self detailsPanel childrenDo: 			[:eachRow |			(eachRow containsMouseEvent: aMouseEvent)				ifTrue: 					[eachRow childrenDo: 							[:eachLabel |							(eachLabel containsMouseEvent: aMouseEvent)								ifTrue: [^eachLabel propertyAt: #codeComponent]]]].	^nil</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>private</category><body package="Store-Code Comparison">adjustScrollBars	self children size = 4 ifFalse: [^self].	(expandedFraction = 1		and: [self detailsPanel preferredHeight &gt; self detailsDecorator frame height])			ifTrue: 				[self detailsDecorator hasVerticalScrollbar					ifFalse: [self detailsDecorator useVerticalScrollbar]]			ifFalse: 				[self detailsDecorator hasVerticalScrollbar					ifTrue: [self detailsDecorator noVerticalScrollbar]]</body><body package="Store-Code Comparison">anticipateNewDisclosureButtonLabel	self disclosureButton idleGraphic: (self isExpanded				ifTrue: [self collapsedIndicator]				ifFalse: [self expandedIndicator])</body><body package="Store-Code Comparison">collapsedIndicator	| label |	label := Label with: '+' asText allBold.	^VisualBlock block: 			[:gc :box |			gc				paint: SymbolicPaint background;				displayRectangle: box;				paint: SymbolicPaint foreground;				display: label at: box center - label extent half]		extent: 16 @ 16</body><body package="Store-Code Comparison">compareCodeComponent: aCodeComponent equalTo: bCodeComponent	^aCodeComponent name = bCodeComponent name		and: [aCodeComponent isBundle = bCodeComponent isBundle]</body><body package="Store-Code Comparison">compareCodeComponent: aCodeComponent lessThan: bCodeComponent	^aCodeComponent name = bCodeComponent name		ifTrue: [aCodeComponent isBundle]		ifFalse: [aCodeComponent name &lt;= bCodeComponent name]</body><body package="Store-Code Comparison">computeLayouts: aVisualPartSequence bounds: aRectangle	| summaryBox detailsBox disclosureBox disclosureExtent swapBox |	aVisualPartSequence size = 4		ifFalse: [^aVisualPartSequence collect: [:ignored | Rectangle zero]].	summaryBox := aRectangle origin extent: aRectangle width						@ (self summaryPanel preferredHeight * (1 - expandedFraction)).	disclosureExtent := self disclosureButton preferredExtent.	disclosureBox := aRectangle bottomCenter				- (disclosureExtent x half @ disclosureExtent y) extent: disclosureExtent.	detailsBox := summaryBox bottomLeft				corner: aRectangle right @ (disclosureBox top * expandedFraction).	swapBox := (detailsBox topCenter leftBy: 8)				corner: (detailsBox bottomCenter rightBy: 8).	^Array		with: summaryBox		with: detailsBox		with: swapBox		with: disclosureBox</body><body package="Store-Code Comparison">disclosureClicked	self toggleExpansion</body><body package="Store-Code Comparison">expandedFraction: aFraction	expandedFraction := aFraction.	self changedPreferredGeometry.	self invalidateNow</body><body package="Store-Code Comparison">expandedIndicator	| label |	label := Label with: '-' asText allBold.	^VisualBlock block: 			[:gc :box |			gc				paint: SymbolicPaint background;				displayRectangle: box;				paint: SymbolicPaint foreground;				display: label at: box center - label extent half]		extent: 16 @ 16</body><body package="Store-Code Comparison">expansionChangeBeginning	self anticipateNewDisclosureButtonLabel</body><body package="Store-Code Comparison">expansionChangeFinished	self adjustScrollBars</body><body package="Store-Code Comparison">filterChanged	self neighborComparisonShell comparisonSource: self filteredComparison</body><body package="Store-Code Comparison">filteredComparison	filteredComponents isEmpty ifTrue: [^comparison].	^comparison withoutComponents: filteredComponents</body><body package="Store-Code Comparison">menuTargetCompliment	"Return the codeComponent which is the counterpart to the current menuTarget"	| search |	search := (comparison leftCodeComponents includes: menuTarget)				ifTrue: [comparison rightCodeComponents]				ifFalse: [comparison leftCodeComponents].	^search detect: 			[:each |			each name = menuTarget name and: [each isBundle = menuTarget isBundle]]		ifNone: [nil]</body><body package="Store-Code Comparison">neighborComparisonShell	^self parent mainArea component</body><body package="Store-Code Comparison">selectOnly: aCodeComponentCollection	filteredComponents removeAll.	self leftComponents do: 			[:each |			(aCodeComponentCollection includes: each)				ifFalse: [filteredComponents add: each]].	self rightComponents do: 			[:each |			(aCodeComponentCollection includes: each)				ifFalse: [filteredComponents add: each]].	self filterChanged</body><body package="Store-Code Comparison">similiarStringFrom: aComponentSequence	| prefix suffix |	aComponentSequence isEmpty ifTrue: [^''].	prefix := aComponentSequence inject: aComponentSequence first name				into: [:accum :each | accum first: (each name sameCharacters: accum)].	suffix := aComponentSequence inject: aComponentSequence first name				into: [:accum :each | accum last: (each name reverse sameCharacters: accum reverse)].	(prefix isEmpty and: [suffix isEmpty]) ifTrue: [^''].	^'(' , prefix , '...' , suffix , ') '</body><body package="Store-Code Comparison">summaryPanel	^self children first</body><body package="Store-Code Comparison">swapSides	comparison invert.	self populateDetailRows.	self filterChanged.	self topComponent ifNotNil: [:window | window label: self summaryLabel]</body><body package="Store-Code Comparison">toggleExpansion	self expansionChangeBeginning.	self expandedFraction: 1 - expandedFraction.	self expansionChangeFinished.	"TODO: ASB - move into #expansionChangeFinished"	self relayout.	self invalidate</body><body package="Store-Code Comparison">toggleFiltered: aCodeComponentCollection	(self areComponentsFiltered: aCodeComponentCollection)		ifTrue: 			[aCodeComponentCollection				do: [:each | filteredComponents remove: each ifAbsent: []]]		ifFalse: [filteredComponents addAll: aCodeComponentCollection].	self filterChanged</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>menu</category><body package="Store-Code Comparison">browseMenuTarget	menuTarget isImageModel		ifTrue: 			[(Refactory.Browser.BrowserEnvironment new				forCodeComponents: (Array with: menuTarget)) openEditor]		ifFalse: 			[(Store.Glorp.StoreForGlorpBrowserEnvironment on: menuTarget) openEditor]</body><body package="Store-Code Comparison">fileoutChangesToGetToMenuTarget	| dialog targetFile session comparitor fileManager |	dialog := SaveFileDialog new.	dialog		addFileFilter: 'Smalltalk source (*.st)' pattern: '*.st';		fileCondition: #new;		defaultFilename: (Filename					filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st'							expandMacrosWith: menuTarget name))						asFilename.	(targetFile := dialog select) ifNil: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.		[(Store.FilingOut for: menuTarget) started.	comparitor := Store.PackageComparitor				differencesWithPropertiesBetween: (self menuTargetCompliment						asStoreComparisonObjectIn: session)				and: (menuTarget asStoreComparisonObjectIn: session).	fileManager := SourceCodeStream write: targetFile encoding: #Source.		[fileManager timeStamp.	fileManager sourceFormatter attributeFor: #package		compute: [:ignore | menuTarget name].	fileManager sourceFormatter attributeForMethods: #package		compute: [:ignore :igmore | menuTarget name].	comparitor fileOutMainToOtherDifferencesOn: fileManager]			ensure: [fileManager close].	(Store.FilingOut for: menuTarget) finished]			withStoreFeedbackOn: self topComponent</body><body package="Store-Code Comparison">menu		| menu |	menu := Menu new.	menu		augmentFrom: self class		to: self class		menuName: #menu		for: self.	^menu</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>displaying</category><body package="Store-Code Comparison">displayOn: aGC	| myBox buttonBox buttonHalf oldPaint |self children isEmpty ifTrue: [^super displayOn: aGC].	myBox := self bounds.	buttonBox := self disclosureButton frame.	buttonHalf := buttonBox center y.	oldPaint := aGC paint.	aGC		paint: (ColorValue red: 0.85 green: 0.85 blue: 0.9);		displayRectangle: (myBox topLeft corner: myBox right @ buttonHalf).	aGC paint: oldPaint.	super displayOn: aGC.	aGC		paint: ColorValue black;		displayRectangularBorder: (buttonBox topLeft					corner: buttonBox bottomRight - 1);		displayLineFrom: buttonBox leftCenter to: myBox left @ buttonHalf;		displayLineFrom: buttonBox rightCenter to: myBox right @ buttonHalf</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>view construction</category><body package="Store-Code Comparison">addDetailsLeft: aCodeComponent right: bCodeComponent	| newRow label |	newRow := Panel new.	newRow add: (self				filterToggleFor: (Array with: aCodeComponent with: bCodeComponent)).	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: aCodeComponent);		add: aCodeComponent toolListText.	label propertyAt: #codeComponent put: aCodeComponent.	newRow add: label.	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: bCodeComponent);		add: bCodeComponent toolListText.	label propertyAt: #codeComponent put: bCodeComponent.	newRow add: label.	self layoutDetailsRow: newRow.	self detailsPanel add: newRow</body><body package="Store-Code Comparison">addDetailsPanel	| details scrolled |	details := Panel new.	details beFullColumn.	scrolled := (BorderDecorator on: details)				useVerticalScrollbar;				noBorder.	self add: scrolled.	self populateDetailRows</body><body package="Store-Code Comparison">addDetailsSolitaryLeft: aCodeComponent	| newRow label |	newRow := Panel new.	newRow add: (self filterToggleFor: (Array with: aCodeComponent)).	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: aCodeComponent);		add: aCodeComponent toolListText.	label propertyAt: #codeComponent put: aCodeComponent.	newRow add: label.	newRow add: self notPresentLabel.	self layoutDetailsRow: newRow.	self detailsPanel add: newRow</body><body package="Store-Code Comparison">addDetailsSolitaryRight: aCodeComponent	| newRow label |	newRow := Panel new.	newRow add: (self filterToggleFor: (Array with: aCodeComponent)).	newRow add: self notPresentLabel.	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: aCodeComponent);		add: aCodeComponent toolListText.	label propertyAt: #codeComponent put: aCodeComponent.	newRow add: label.	self layoutDetailsRow: newRow.	self detailsPanel add: newRow</body><body package="Store-Code Comparison">addDisclosureButton	| disclosure |	(self isSimple or: [self isEmpty])		ifTrue: [disclosure := PixelSpace extent: Point zero]		ifFalse: 			[disclosure := ClickableGraphic new.			disclosure idleGraphic: (self isExpanded						ifTrue: [self expandedIndicator]						ifFalse: [self collapsedIndicator]).			disclosure				tooltip: #ComparisonHeaderDisclosureButtonTooltip						&gt;&gt; 'Toggle between showing all changed components or a one line summary view.'							&lt;&lt; #IDE.			disclosure when: Clicked send: #disclosureClicked to: self].	self add: disclosure</body><body package="Store-Code Comparison">addSummaryPanel	| summary |	summary := Panel new beColumn: 0.5.	summary add: self summaryLabel.	self add: summary</body><body package="Store-Code Comparison">addSwapSidesButton	| button |	button := ClickableGraphic new.	button		idleGraphic: (VisualBlock block: 						[:gc :box |						gc							paint: SymbolicPaint inactiveBackground;							displayRectangle: box;							paint: SymbolicPaint inactiveForeground;							displayRectangularBorder: (box origin corner: box corner - 1);							display: ComparisonIcons swapSides								at: box center - ComparisonIcons swapSides extent half]);		mouseOverGraphic: (VisualBlock block: 						[:gc :box |						gc							paint: SymbolicPaint buttonBackground;							displayRectangle: box;							paint: SymbolicPaint buttonForeground;							displayRectangularBorder: (box origin corner: box corner - 1);							display: ComparisonIcons swapSides								at: box center - ComparisonIcons swapSides extent half]).	button		tooltip: #ComparisonHeaderSwapButtonTooltip				&gt;&gt; 'Toggle direction of the compare (switch left with right).' &lt;&lt; #IDE.	button when: Clicked send: #swapSides to: self.	self add: button</body><body package="Store-Code Comparison">componentIcon: aCodeComponent	^aCodeComponent isImageModel		ifTrue: [aCodeComponent toolListIcon]		ifFalse: 			[aCodeComponent isBundle				ifTrue: [BehaviorIcons BundleDisconnected]				ifFalse: [BehaviorIcons PackageDisconnected]]</body><body package="Store-Code Comparison">detailsDecorator	^self children at: 2</body><body package="Store-Code Comparison">detailsPanel	^self detailsDecorator component</body><body package="Store-Code Comparison">disclosureButton	^self children last</body><body package="Store-Code Comparison">filterToggleFor: aCodeComponentCollection	| clicker |	clicker := Refactory.Browser.ClickableGraphic new.	clicker		idleGraphic: (VisualBlock block: 					[:gc :box |					| graphic |					graphic := (self areComponentsFiltered: aCodeComponentCollection)								ifTrue: [ComparisonIcons hidePackage]								ifFalse: [ComparisonIcons seePackage].					graphic displayOn: gc at: box center - graphic extent half]				extent: ComparisonIcons hidePackage extent).	clicker		mouseOverGraphic: (VisualBlock block: 					[:gc :box |					| graphic |					graphic := (self areComponentsFiltered: aCodeComponentCollection)								ifTrue: [ComparisonIcons hidePackageActive]								ifFalse: [ComparisonIcons seePackageActive].					graphic displayOn: gc at: box center - graphic extent half]				extent: ComparisonIcons hidePackageActive extent).	clicker when: Refactory.Browser.Clicked		do: 			[InputState default shiftDown				ifTrue: 					[self selectOnly: aCodeComponentCollection.					self invalidate]				ifFalse: 					[self toggleFiltered: aCodeComponentCollection.					clicker invalidate]].	clicker tooltip: #ComparisonHeaderToggleTooltip &lt;&lt; #IDE				&gt;&gt; 'Toggles whether changes from this package are shown below.&lt;shift-click&gt; Makes this row the sole selection.'.	^clicker</body><body package="Store-Code Comparison">layoutDetailsRow: aRowPanel	"Should only be called after all 3 of its children are set."	| sumHeight |	aRowPanel layoutAlgorithm: 			[:rectangle :parts |			| boxes |			boxes := parts						collect: [:each | rectangle origin extent: each preferredExtent].			sumHeight := boxes inject: 0 into: [:max :each | max max: each height].			boxes				keysAndValuesDo: [:index :each | each moveBy: 0 @ (sumHeight - each height) half].			(boxes at: 2) moveTo: (boxes first right + 5) @ (boxes at: 2) top.			(boxes at: 3) moveTo: (rectangle center x + 13) @ (boxes at: 3) top.			boxes]</body><body package="Store-Code Comparison">newDetailsRow	| row |	row := Panel new.	row layoutAlgorithm: 			[:rectangle :parts |			| boxes lastRight |			boxes := parts						collect: [:each | rectangle origin extent: each preferredExtent].			lastRight := rectangle left.			boxes keysAndValuesDo: 					[:index :each |					each moveBy: (lastRight + 5) @ (rectangle height - each height) half.					lastRight := each right].			boxes last right: rectangle right.			boxes].	^row</body><body package="Store-Code Comparison">notPresentLabel	^Label with: ((#NotPresent &gt;&gt; 'Not Present' &lt;&lt; #IDE) asText				emphasizeAllWith: (Array with: #italic						with: #color -&gt; SymbolicPaint inactiveForeground))</body><body package="Store-Code Comparison">populate	self releaseAllComponents.	self updateFramesAfter: 			[self addSummaryPanel.			self addDetailsPanel.			self addSwapSidesButton.			self addDisclosureButton]</body><body package="Store-Code Comparison">populateDetailRows	| rightStack leftStack |	self detailsPanel releaseAllComponents.	leftStack := OrderedCollection withAll: self leftComponents.	rightStack := OrderedCollection withAll: self rightComponents.	[rightStack isEmpty and: [leftStack isEmpty]] whileFalse: 			[rightStack isEmpty				ifTrue: [self addDetailsSolitaryLeft: leftStack removeFirst]				ifFalse: 					[leftStack isEmpty						ifTrue: [self addDetailsSolitaryRight: rightStack removeFirst]						ifFalse: 							[(self compareCodeComponent: rightStack first equalTo: leftStack first)								ifTrue: 									[self addDetailsLeft: leftStack removeFirst right: rightStack removeFirst]								ifFalse: 									[(self compareCodeComponent: rightStack first lessThan: leftStack first)										ifTrue: [self addDetailsSolitaryRight: rightStack removeFirst]										ifFalse: [self addDetailsSolitaryLeft: leftStack removeFirst]]]]]</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>testing</category><body package="Store-Code Comparison">areComponentsFiltered: aCodeComponentCollection	^aCodeComponentCollection		allSatisfy: [:eachCodeComponent | filteredComponents includes: eachCodeComponent]</body><body package="Store-Code Comparison">isEmpty	^self leftComponents isEmpty and: [self rightComponents isEmpty]</body><body package="Store-Code Comparison">isExpanded		^expandedFraction = 1</body><body package="Store-Code Comparison">isSimple	^self leftComponents size = 1 and: 			[self rightComponents size = 1 and: 					[self leftComponents any name = self rightComponents any name						and: [self leftComponents any isBundle = self rightComponents any isBundle]]]</body><body package="Store-Code Comparison">menuTargetIsLeftSide	^comparison leftCodeComponents includes: menuTarget</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>bounds accessing</category><body package="Store-Code Comparison">bounds: aRectangle	super bounds: aRectangle.	self adjustScrollBars</body><body package="Store-Code Comparison">preferredExtent	"Make sure we leave enough room in the color backed section to show a help icon"	| backedHeight borderHeight remainingDisclosureHeight |	backedHeight :=		self summaryPanel preferredHeight * (1 - expandedFraction)		+ (self detailsPanel preferredHeight * expandedFraction)		+ self disclosureButton preferredHeight half.	backedHeight := backedHeight max: GeneralIcons help height.	borderHeight := 1.	remainingDisclosureHeight := self disclosureButton preferredHeight half.	^super preferredExtent x @ (backedHeight + borderHeight + remainingDisclosureHeight)</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>accessing</category><body package="Store-Code Comparison">leftComponents	^comparison leftCodeComponents</body><body package="Store-Code Comparison">rightComponents	^comparison rightCodeComponents</body><body package="Store-Code Comparison">summaryLabel	^self isEmpty		ifTrue: [(#NoChanges &lt;&lt; #IDE &gt;&gt; 'No Changes') asText]		ifFalse: 			[self isSimple				ifTrue: 					[#ComparingSingleCodeComponentHeader &lt;&lt; #IDE &gt;&gt; 'Changes from &lt;1s&gt; to &lt;2s&gt;'						expandMacrosWith: self leftComponents any toolListText						with: self rightComponents any toolListText]				ifFalse: 					[#ComparingCodeComponentsHeader &lt;&lt; #IDE						&gt;&gt; 'Changes from &lt;1p&gt; components &lt;2s&gt; to &lt;3p&gt; other components &lt;4s&gt;'							expandMacrosWithArguments: (Array									with: self leftComponents size									with: (self similiarStringFrom: self leftComponents)									with: self rightComponents size									with: (self similiarStringFrom: self rightComponents))]]</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>relationships</category><body package="Store-UI-Graphs">elementRelatedBy: relToken 	^element relatedBy: relToken</body><body package="Store-UI-Graphs">relatedBy: relToken 	^related at: relToken		ifAbsent: 			[| bag relElems |			relElems := self elementRelatedBy: relToken.			bag := Set new.			relElems do: [:elem | bag add: (self class element: elem cache: cache)].			related at: relToken put: bag]</body><body package="Store-UI-Graphs">stringKey: hints	^element stringKey: hints</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>initialize-release</category><body package="Store-UI-Graphs">element: anElement cache: aCache	element := anElement.	cache := aCache.	related := IdentityDictionary new.</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>accessing</category><body package="Store-UI-Graphs">element	^element</body><body package="Store-UI-Graphs">itemString	^element itemString</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>printing</category><body package="Store-UI-Graphs">printOn: aStream	aStream nextPut: ${.	element printOn: aStream.	aStream nextPut: $}.	^self</body></methods><methods><class-id>Store.ElementProxy class</class-id> <category>instance creation</category><body package="Store-UI-Graphs">element: anElement cache: aCache 	^aCache at: anElement ifAbsent: [aCache at: anElement put: (self new element: anElement cache: aCache)]</body></methods><methods><class-id>Store.GroupElement</class-id> <category>relationships</category><body package="Store-UI-Graphs">elementRelatedBy: relToken		relToken == #tt_containsRel ifTrue: 		[^StoreUserGroup userNamesInGroupNamed: element].	relToken == #tt_containsRRel ifTrue: 		[^StoreUserGroup groupNamesForUserNamed: element].	^super relatedBy: relToken</body><body package="Store-UI-Graphs">stringKey: hints	^element</body></methods><methods><class-id>Store.GroupElement</class-id> <category>accessing</category><body package="Store-UI-Graphs">itemString	^element</body></methods><methods><class-id>Store.Glorp.StoreBundleInBundle</class-id> <category>accessing</category><body package="Store-Database Model">containedPundle	^subbundle</body><body package="Store-Database Model">containingBundle	^containingBundle</body><body package="Store-Database Model">containingBundle: anObject	containingBundle := anObject</body><body package="Store-Database Model">expression	^expression</body><body package="Store-Database Model">expression: anObject	expression := anObject</body><body package="Store-Database Model">sequence	^sequence</body><body package="Store-Database Model">sequence: anObject	sequence := anObject</body><body package="Store-Database Model">subbundle	^subbundle</body><body package="Store-Database Model">subbundle: anObject	subbundle := anObject</body></methods><methods><class-id>Store.Glorp.StoreBundleInBundle</class-id> <category>printing</category><body package="Store-Database Model">printOn: aStream	super printOn: aStream.	aStream nextPut: $(;		nextPutAll: self subbundle shortItemString;		nextPutAll: ' in: ';		nextPutAll: self containingBundle shortItemString;		nextPut: $)</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>execute</category><body package="Store-Broker-Obsolete">executeAll: aStream" Execute SQL statements from the stream. Statements should be separated by two cr's" 	| string  pattern |	DbRegistry isOnline ifFalse: [ DbRegistry reconnect: false].	pattern := '\\'  withCRs. 	[aStream peekFor: Character cr]		whileTrue: [].	self safelyExecuteBlock: 				[[ aStream atEnd ]					whileFalse:						[ string := aStream upToAll: pattern. 						DbRegistry storeBroker processSQL: string. 						aStream  atEnd ifFalse: [ aStream skip: 2] ].				DbRegistry goOffLine]		note: (#ExecuteAll &lt;&lt; #store &gt;&gt; 'Execute All: ') asString</body><body package="Store-Broker-Obsolete">executeSelection: aString	self safelyExecuteBlock: 			[ | onlineState |				aString isEmpty not 				ifTrue:					[onlineState := DbRegistry isOnline.					onlineState ifFalse: [ DbRegistry reconnect: false ].					DbRegistry storeBroker processSQL: aString ].					onlineState ifFalse: [ DbRegistry goOffLine ]]		note: (#ExecuteSelection &lt;&lt; #store &gt;&gt; 'Execute Selection: ') asString</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>actions</category><body package="Store-Base">installInfo	StoreDescriptorSystem installUserManagementPolicies</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>accessing</category><body package="Store-Base">logFileName	logFileName isNil		ifTrue: [ logFileName  := 'StoreLog.txt'].	^ logFileName</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>debugging</category><body package="Store-Base">log: aStringOrBlock level: aLevel	| stream aMsg |	self 		debug:			[(stream := self debugStream) == nil ifTrue: [^self].			(aStringOrBlock isKindOf: BlockClosure)				ifTrue: [ aMsg := aStringOrBlock value]				ifFalse: [ aMsg := aStringOrBlock ].			stream cr; nextPutAll: aMsg; cr; flush]		level: aLevel</body><body package="Store-Base">traceOff	self trace: false.</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>private</category><body package="Store-Broker-Obsolete">safelyExecuteBlock: aBlock note: aNote 		[Notice 		show: #ExecutingSQLStatements &lt;&lt; #store &gt;&gt; 'Executing SQL statements..'		while: 			[Cursor database showWhile: 					[aBlock value.					Dialog 						warn: #SQLExecutedSuccessfully &lt;&lt; #store &gt;&gt; 'SQL executed successfully!']]] 			on: Error			do: [:ex | DbRegistry storeBroker processPublishException: ex note: aNote]</body></methods><methods><class-id>Store.Glorp.PundleFilter</class-id> <category>accessing</category><body package="Store-Database Model">greaterThanBlessing	^greaterThanBlessing</body><body package="Store-Database Model">greaterThanBlessing: anIntegerOrNil	greaterThanBlessing := anIntegerOrNil</body><body package="Store-Database Model">lessThanBlessing	^lessThanBlessing</body><body package="Store-Database Model">lessThanBlessing: anIntegerOrNil	lessThanBlessing := anIntegerOrNil</body><body package="Store-Database Model">newerThanDate	^newerThanDate</body><body package="Store-Database Model">newerThanDate: aDateOrNil	newerThanDate := aDateOrNil</body><body package="Store-Database Model">olderThanDate	^olderThanDate</body><body package="Store-Database Model">olderThanDate: aDateOrNil	olderThanDate := aDateOrNil</body><body package="Store-Database Model">showBundles	^showBundles</body><body package="Store-Database Model">showBundles: aBoolean	showBundles := aBoolean</body><body package="Store-Database Model">showPackages	^showPackages</body><body package="Store-Database Model">showPackages: anObject	showPackages := anObject</body></methods><methods><class-id>Store.Glorp.PundleFilter</class-id> <category>query utility</category><body package="Store-Database Model">applyFilterToQuery: aGlorpQuery	self applyWhereBlessingTo: aGlorpQuery.	self applyWhereDateTo: aGlorpQuery.</body><body package="Store-Database Model">applyWhereBlessingTo: aGlorpQuery	(greaterThanBlessing isNil and: [lessThanBlessing isNil]) ifTrue: [^self].	self setupWhereBlessingFor: aGlorpQuery</body><body package="Store-Database Model">applyWhereDateTo: aGlorpQuery	(olderThanDate isNil and: [newerThanDate isNil]) ifTrue: [^self].	self setupWhereDateFor: aGlorpQuery</body></methods><methods><class-id>Store.Glorp.PundleFilter</class-id> <category>private</category><body package="Store-Database Model">convertLowerDateForUTC	"We could use either a Date or Timestamp result, but the code is simpler for Timestamp"	^newerThanDate ifNotNil: 		[Timestamp fromSeconds: newerThanDate asSeconds - TimeZone default secondsFromUniversal]</body><body package="Store-Database Model">convertUpperDateForUTC	"We add a day to the upper date, because days start at 0 seconds, and everything ON that date would be otherwise	greater than the upper date.	We could use either a Date or Timestamp result, but the code is simpler for Timestamp"		^olderThanDate ifNotNil: 		[Timestamp fromSeconds: (olderThanDate addDays: 1) asSeconds - TimeZone default secondsFromUniversal]</body><body package="Store-Database Model">setupWhereBlessingFor: aGlorpQuery	(greaterThanBlessing notNil and: [lessThanBlessing notNil])		ifTrue: 			[aGlorpQuery AND: 				[:each | each currentBlessingLevel &gt;= greaterThanBlessing AND: each currentBlessingLevel &lt;= lessThanBlessing]]		ifFalse: 			[greaterThanBlessing isNil				ifTrue: [aGlorpQuery AND: [:each | each currentBlessingLevel &lt;= lessThanBlessing]]				ifFalse: [aGlorpQuery AND: [:each | each currentBlessingLevel &gt;= greaterThanBlessing]]]</body><body package="Store-Database Model">setupWhereDateFor: aGlorpQuery	| upperDate lowerDate |	upperDate := self convertUpperDateForUTC.	lowerDate := self convertLowerDateForUTC.	(upperDate notNil and: [lowerDate notNil])		ifTrue:  [aGlorpQuery AND: [:each | each timestamp &gt;= lowerDate AND: each timestamp &lt;= upperDate]]		ifFalse: 			[lowerDate isNil				ifTrue: [aGlorpQuery AND: [:each | each timestamp &lt;= upperDate]]				ifFalse: [aGlorpQuery AND: [:each | each timestamp &gt;= lowerDate]]]</body></methods><methods><class-id>Store.Glorp.PundleFilter</class-id> <category>constants</category><body package="Store-Database Model">defaultShowBundles	^true</body><body package="Store-Database Model">defaultShowPackages	^true</body></methods><methods><class-id>Store.Glorp.PundleFilter</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize	self setFilterDefaults</body><body package="Store-Database Model">setFilterDefaults	showBundles := self defaultShowBundles.	showPackages := self defaultShowPackages.	lessThanBlessing := greaterThanBlessing := newerThanDate := olderThanDate := nil</body></methods><methods><class-id>Store.Glorp.PundleFilter</class-id> <category>testing</category><body package="Store-Database Model">hasVersionFilterSet	"Ignoring showBundle and showPackage, are there settings that can apply to versions of a pundle?"	^olderThanDate notNil or:		[newerThanDate notNil or: 		[lessThanBlessing notNil or:		[greaterThanBlessing notNil]]]</body></methods><methods><class-id>Store.Glorp.PundleFilter class</class-id> <category>accessing</category><body package="Store-Database Model">lastAppliedFilter	^lastAppliedFilter ifNil: [lastAppliedFilter := self new].</body><body package="Store-Database Model">lastAppliedFilter: aPundleFilter	lastAppliedFilter := aPundleFilter</body></methods><methods><class-id>Store.Glorp.PundleFilter class</class-id> <category>instance creation</category><body package="Store-Database Model">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model">allItems	"Default to just me"	^Array with: self</body><body package="Store-Database Model">allModifiedItems	| allItems |	allItems := self allItems.	^allItems select: [:each | each isNotLoaded]</body><body package="StoreForGlorpVWUI">allStoreVersions	^[(Gathering for: self name) started.		self class allVersionsInitiallyNamed: self name in: self session]		ensure: [(Gathering for: self name) finished]</body><body package="StoreForGlorpVWUI">allStoreVersionsIn: aSession	^[(Gathering for: self name) started.		self class allVersionsInitiallyNamed: self name in: (self session ifNil: [aSession])]		ensure: [(Gathering for: self name) finished]</body><body package="Store-Database Model">allUniqueItems	"Answer a list of unique pundles contianed in this pundle. 	The list preserves the pundle order. 	Remove duplicates from the list."		| items present |	items := self allItems.	present := Set new: items size.	^items select:		[:each | 		| result |		result := present includes: each.		present add: each.		result not].</body><body package="Store-Database Model">asStorePundle	^self</body><body package="Store-Database Model">basicComment	^comment</body><body package="Store-Database Model">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model">blessings	^blessings</body><body package="Store-Database Model">blessings: aCollection	blessings := aCollection.</body><body package="Store-Merge Management">classAndName	^self class name, '-', self name</body><body package="Store-Database Model">comment: aString	self basicComment: (StoreBlob forString: aString).</body><body package="Store-Database Model">copyrightNotice	^self propertyAt: #notice ifAbsent: [nil].</body><body package="Store-Database Model">correspondingImagePundle	^self isBundle		ifTrue: [Registry bundleNamed: self name]		ifFalse: [Registry packageNamed: self name]</body><body package="Store-Database Model">currentBlessingLevel	^currentBlessingLevel</body><body package="Store-Database Model">currentBlessingLevel: anInteger	currentBlessingLevel := anInteger.</body><body package="StoreForGlorpVWUI">dbIdentifier	^self session databaseIdentifier.</body><body package="Store-Database Model">deploymentPrerequisites	^self properties at: #prerequisiteParcels ifAbsent: [ #() ]</body><body package="Store-Database Model">developmentPrerequisites	^self properties at: #developmentPrerequisites ifAbsent: [#()]</body><body package="StoreForGlorpVWUI">elementLabel: hints	"This method returns a visual component used to represent me in a browser graph."	| label |	label := LabelAndIcon with: (self stringKey: hints).	label icon: (AbstractTool iconForPundle: self).	^label</body><body package="Store-Database Model">enclosingComponents	^StoreBundle enclosingComponentsFor: self in: self session</body><body package="Store-Database Model">environment	^ nil</body><body package="StoreForGlorpVWUI">glorpReconciledVersionIn: aSession	^self</body><body package="Store-Database Model">nameSpaces	self subclassResponsibility.</body><body package="Store-Database Model">namespaces	self subclassResponsibility.</body><body package="Store-Database Model">package	^self.</body><body package="Store-Database Model">parentRecord	^self previous</body><body package="Store-Database Model">parentVersionString	| parentRecord |	^(parentRecord := self parentRecord) isNil		ifTrue: [''] 		ifFalse: [parentRecord version ifNil: ['']]</body><body package="Store-Database Model">postLoadBlock	^self properties at: #postLoadBlock ifAbsent: [nil].</body><body package="Store-Database Model">postUnloadBlock	^self properties at: #postUnloadBlock ifAbsent: [nil].</body><body package="Store-Database Model">preLoadBlock	"Dummy method template.  This was installed by the debugger	define method command."	^self properties at: #preLoadBlock ifAbsent: [nil].</body><body package="Store-Database Model">preReadBlock	"Dummy method template.  This was installed by the debugger	define method command."	^self properties at: #preReadBlock ifAbsent: [nil].</body><body package="Store-Database Model">preSaveBlock	^self properties at: #preSaveBlock ifAbsent: [nil].</body><body package="Store-Database Model">preUnloadBlock	^self properties at: #preUnloadBlock ifAbsent: [nil].</body><body package="Store-Database Model">prefetchAllFromDatabase	"Resursively fetch all children to populate the browser environment."	self fullClasses;		nameSpaces;		sharedVariables</body><body package="Store-Database Model">prerequisiteDescriptions	^(PrerequisiteDescription		descriptionsFrom: (self properties at: #prerequisiteDescriptions				ifAbsent: [nil])		orDeployment: self deploymentPrerequisites		andDevelopment: self developmentPrerequisites)			collect: [:each | each client: self]</body><body package="Store-Database Model">properties	properties yourSelf isNil ifTrue: [self convertProperties].	(properties anySatisfy: [: each | each isNil]) ifTrue: [self convertProperties].	^properties.</body><body package="Store-Database Model">properties: aDictionary	properties := aDictionary.</body><body package="Store-Database Model">propertiesBlob	^propertiesBlob</body><body package="Store-Database Model">propertiesBlob: aStoreBlob	propertiesBlob := aStoreBlob</body><body package="Store-Database Model">propertiesForFileOut	^self properties copy.</body><body package="Store-Database Model">propertiesRecordDictionary	^propertiesRecordDictionary</body><body package="Store-Database Model">propertiesRecordDictionary: aDictionaryOfStoreProperty	propertiesRecordDictionary := aDictionaryOfStoreProperty</body><body package="Store-Difference Management">propertiesWithoutVolatileKeys	| propertiesCopy |	propertiesCopy := self properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body><body package="Store-Database Model">propertyAt: aSymbol	"Answer the property at the symbol"	^properties at: aSymbol ifAbsent: nil</body><body package="Store-Database Model">propertyAt: aKey ifAbsent: aBlock	^self properties at: aKey ifAbsent: aBlock</body><body package="Store-Database Model">propertyAt: aSymbol put: anObject	properties isNil ifTrue: [self initializeProperties].	^properties at: aSymbol put: anObject</body><body package="Store-Code Comparison">propertyBlueprints	| output |	output := Array new writeStream.	self propertiesWithoutVolatileKeys keysAndValuesDo: 			[:propertyName :propertyValue |			propertyName = #version				ifFalse: 					[output nextPut: ((CodeComponentPropertyBlueprint new)								codeComponent: self;								key: propertyName;								value: propertyValue)]].	^output contents</body><body package="StoreForGlorpVWUI">pundleListIcon	^self storeModel ifNil: [nil] ifNotNil: [:model | model pundleListIcon].</body><body package="StoreForGlorpVWUI">pundleModel	"Used by initializer error handler for Store loading"	^self storeModel</body><body package="Store-Database Model">relatedParcel	"Store compatibility"	storeModel isNil ifTrue: [^nil] ifFalse: [^storeModel relatedParcel].</body><body package="StoreForGlorpVWUI">selectStoreVersion	^self selectStoreVersionIn: StoreLoginFactory currentStoreSession.</body><body package="StoreForGlorpVWUI">selectStoreVersionIn: aSession	^self class selectStoreVersionOf: self name in: aSession</body><body package="StoreForGlorpVWUI">selectStoreVersionIn: aSession warnIfNone: aBoolean	^self class selectStoreVersionOf: self name in: aSession warnIfNone: aBoolean</body><body package="Store-Database Model">session	^session.</body><body package="Store-Database Model">session: aGlorpSession	session := aGlorpSession.</body><body package="Store-Database Model">sharedVariables	^self subclassResponsibility</body><body package="Store-Database Model">simpleVersionString	"Return a string describing this version of the form (&lt;version&gt;,&lt;username&gt;)"	(version isNil and: [username isNil]) ifTrue: [^''].	^(version ifNil: [self timeStampString]) , ',' , (username ifNil: ['unknown'])</body><body package="StoreForGlorpVWUI">storeModel	storeModel isNil ifTrue: [storeModel := self correspondingImagePundle].	^storeModel</body><body package="Store-Database Model">storeModel: aPundleModel	storeModel := aPundleModel</body><body package="Store-Database Model">streamDirectory	"parcel loading call-back"	^nil</body><body package="Store-Database Model">textForItem	^self printString</body><body package="Store-Database Model">typeStringForBlessing	^self class typeStringForBlessing</body><body package="Store-Database Model">version	^version</body><body package="Store-Database Model">version: aString	version := aString.</body><body package="Store-Database Model">versionComment	^self blessings inject: String new into: [:sum :each | sum, each printString].</body><body package="Store-Database Model">versionSelectionBlock	^self propertyAt: #versionSelectionBlock ifAbsent: [nil]</body><body package="Store-Database Model">versionString	"Return a string describing this version of the form (&lt;version&gt;,&lt;username&gt;)"	(version isNil and: [username isNil]) ifTrue: [^''].	^'(' , self simpleVersionString , ')'</body><body package="Store-Database Model">versionless	^versionless</body><body package="Store-Database Model">versionless: anObject	versionless := anObject</body><body package="Store-Database Model">warningSuppressionBlock	^self propertyAt: #warningSuppressionBlock ifAbsent: [nil].</body><body package="Store-Database Model">withAllContainedItems	^(Array with: self), self allContainedItems.</body><body package="Store-Database Model">withAllItems	"Default to just me"	^Array with: self</body><body package="Store-Database Model">withAllUniqueItems	"Answer a list of unique pundles contianed in this pundle. 	The list preserves the pundle order, but unlike allUniqueItems, it puts the Bundle first.	Remove duplicates from the list."		| items present |	items := self withAllItems.	present := Set new: items size.	^items select:		[:each | 		| result |		result := present includes: each.		present add: each.		result not].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>enumerating</category><body package="Store-Database Model">allComponentsDo: aBlock	self subclassResponsibility.</body><body package="Store-Database Model">allVersionsWithName: aString	^self class allVersionsWithName: aString in: self session</body><body package="Store-Database Model">allVersionsWithName: aString after: anInteger	^self class allVersionsWithName: aString after: anInteger in: self session</body><body package="Store-Database Model">componentsCollect: aBlock</body><body package="Store-Database Model">componentsDo: aBlock</body><body package="Store-Database Model">newComponentsDo: aBlock 	"Loop over all our sub-components, but only those which are instantiated and new - that is, have no primary key"</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>loading</category><body package="StoreForGlorpVWUI">asDBComponent	"So that Store thinks we're something it can load from"	^self.</body><body package="Store-Database Model">basicPostLoad: aPundleModel	aPundleModel 		properties: self properties;						runComponentPostLoad</body><body package="Store-Database Model">cleanOverrides	Override cleanseLists.	Override cleanseLists</body><body package="Store-Database Model">directCompileAndLoad	self subclassResponsibility</body><body package="Store-Database Model">directLoadSource	"Lead method to non-atomically load the receiver.  	Ensure that the prerequisite recursion detection mechanism gets reset after the load."	[[^Parcel withFileCachesDo: [self directCompileAndLoad]]		on: LoadCanceled		do: 			[:exception | 			Transcript 				cr;				show: ((#LoadingOf1sHasBeenCanceled &lt;&lt; #store &gt;&gt; 'Loading of &lt;1s&gt; has been canceled') expandMacrosWith: self name)]] ensure:			[self prerequisiteRecursionReset.			self resetStoreModel.			self applyPundleVersionsToTheImage: true.			self cleanOverrides.			Registry cleanseModels]</body><body package="Glorp Atomic Compiling">doActionEvalualtion: aString withArguments: args for: aDescription		| block val |	block := Cursor execute		showWhile:			[nil class evaluatorClass new				evaluate: (ReadStream on: aString asString)				in: nil				allowReceiver: false				receiver: nil				environment: CodeComponent environmentForActionBlocks				notifying: nil				ifFail:					[LoadOrSaveCompilationError raiseRequestErrorString: (Array with: self name with: aDescription).					^false]].	block numArgs == args size		ifFalse:			[LoadOrSaveInvalidArgumentsError raiseRequestErrorString: (Array with: self name with: aDescription).			^false].	[val := block valueWithArguments: args]		on: Error		do:			[:exception | 			LoadOrSaveEvaluationError raiseRequestErrorString: (Array with: self name with: aDescription).			^false].	^val ~~ false</body><body package="StoreForGlorpVWUI">forceStoreConnectionDuring: aBlock	"Store has a lot of code that depends on, if not the current database connection, then the current database identifier. It makes it very difficult to reuse that code if we're using a different database. So instead, we explicitly disconnect the connection (which will make some things like trace code just accept that they can't get that information right now) and we force the database identifier to be the database we're using, for the duration of the operation"	| oldIdentifier wasConnected newIdentifier |	[	wasConnected := DbRegistry isConnected.	oldIdentifier := DbRegistry dbIdentifier.	newIdentifier := session system databaseIdentifier.	newIdentifier == oldIdentifier ifFalse: [		DbRegistry disconnect.		DbRegistry databaseIdentifier: newIdentifier].	aBlock value] 		ensure: [			DbRegistry databaseIdentifier: oldIdentifier.			(newIdentifier ~~ oldIdentifier) &amp; wasConnected ifTrue: [DbRegistry reconnect]].</body><body package="Store-Database Model">isNotLoaded	^self asComponentDescriptionForReal isNotLoaded.</body><body package="Store-Database Model">loadSource	"Lead method to atomically load the receiver.  Ensure that the prerequisite recursion detection mechanism gets reset after the load."	^[Parcel withFileCachesDo: [self quietlyLoadSource]] 		ensure: 		[(CleanUp for: (#UndeclaredBindings &lt;&lt; #store &gt;&gt; 'Undeclared Bindings') asString) started.		Undeclared purgeUnusedBindings.		(CleanUp for: (#UndeclaredBindings &lt;&lt; #store &gt;&gt; 'Undeclared Bindings') asString) finished]</body><body package="Store-Database Model">loadSourceWith: aCompilationManager	"Lead method to atomically load the receiver.  Ensure that the prerequisite recursion detection mechanism gets reset after the load."		| pundleCompilerManger |	DbRegistry useAtomicLoader ifFalse: [^Parcel withFileCachesDo: [self directCompileAndLoad]].	aCompilationManager ifNil: [^Parcel withFileCachesDo: [self quietlyLoadSource]].	pundleCompilerManger := self newDefaultCompileManagerWith: aCompilationManager.	^Parcel withFileCachesDo: [pundleCompilerManger atomicCompileWith: aCompilationManager]</body><body package="Store-Database Model">loadSrc	"Call loadSource which now does all the dirty work"	^self loadSource</body><body package="Store-Publishing Support">noteLoad	(DbRegistry shouldWriteLoadRecords and: [session hasDescriptorFor: StoreLoadRecord])		ifTrue: [ | loadRecord |			loadRecord := StoreLoadRecord from: self.			session save: loadRecord].</body><body package="Store-Database Model">postLoad: aPundleModel	self basicPostLoad: aPundleModel.	ChangeSet loadPundle: self.	SourceFileManager default loadPundle: self.	Root allNameSpaces do: [:each | each organization removeEmptyCategories].</body><body package="Store-Database Model">quietlyLoadSource	"Lead method to atomically load the receiver.  Ensure that the prerequisite recursion detection mechanism gets reset after the load."	DbRegistry useAtomicLoader		ifFalse: [^self directLoadSource].	^[[Store.DBAccess loadingFromStore: true.	Parcel withFileCachesDo: 		[Store.DBAccess useAnalysisLoader			ifTrue: [self analyzeAndLoad]			ifFalse: [self atomicCompileAndLoad]]]			on: LoadCanceled			do: 				[:exception | 				Transcript 					cr;					show: ((#LoadingOf1sHasBeenCanceled &lt;&lt; #store &gt;&gt; 'Loading of &lt;1s&gt; has been canceled') expandMacrosWith: self name)]] ensure: 		[(CleanUp for: self) started.		Store.DBAccess loadingFromStore: false.		self prerequisiteRecursionReset.		self resetStoreModel.		self applyPundleVersionsToTheImage: true.		Store.DbRegistry refreshBrowsers.		(CleanUp for: self) finished]</body><body package="Store-Database Model">resetStoreModel	"Our Store model will change when we load a new version. Nil ours out so that we will recalculate it if required"	storeModel := nil.</body><body package="Store-Database Model">runPreLoad		| action |	(action := self preLoadBlock) ifNil: [^true].	[self		unprotectedActionEvaluation: action		withArguments: (Array with: self)]		on: Error		do: [:exception | (LoadingActionError pundle: self action: #preLoad error: exception) ifFalse: [^false]].	^true</body><body package="Store-Database Model">runPreRead		| preReadBlockAction |	(preReadBlockAction := self preReadBlock) ifNil: [^true].	(self		doActionEvalualtion: preReadBlockAction		withArguments: Array new		for: 'PreRead') ifTrue: [^true].	^PreReadActionConfirmation raiseRequestErrorString: name</body><body package="Glorp Atomic Compiling">unprotectedActionEvaluation: aString withArguments: args		| block |	block := Cursor execute		showWhile:			[nil class evaluatorClass new				evaluate: (ReadStream on: aString asString)				in: nil				allowReceiver: false				receiver: nil				environment: CodeComponent environmentForActionBlocks				notifying: nil				ifFail: [^Error signalWith: #CompilationError &lt;&lt; #store &gt;&gt; 'Compilation Error']].	^(block valueWithArguments: args) ~~ false</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>printing</category><body package="StoreForGlorpVWUI">blessingLevel: aString	self currentBlessingLevel: aString asNumber</body><body package="StoreForGlorpVWUI">blessingLevelNumber	^currentBlessingLevel.</body><body package="StoreForGlorpVWUI">blessingLevelString	"Answer the name of my blessing.."	^Policies blessingPolicy blessingName: currentBlessingLevel.</body><body package="Store-Database Model">displayString	^name, self versionString</body><body package="StoreForGlorpVWUI">longItemString	^self itemString</body><body package="Store-Database Model">mergeItemString	| postfix |	postfix := self isVersionLoaded				ifTrue: [' [Image]']				ifFalse: [''].	^self itemString , postfix</body><body package="Store-Merge Management">printPremergeBlessingCommentHistoryOn: aStream withLeadingCR: aBoolean		aBoolean ifTrue: [aStream cr].	aStream nextPutAll: self displayString asString.	aStream cr.	(blessings select: [:blessing | blessing blessingLevel &gt;= 0])		do: [:blessing | blessing printMergeCommentHistoryOn: aStream]		separatedBy: [aStream cr]</body><body package="Store-Merge Management">printPremergeCommentHistoryOn: aStream from: aString withLeadingCR: aBoolean		self printPremergeBlessingCommentHistoryOn: aStream withLeadingCR: aBoolean.	(self version = aString or: [self parentRecord isNil]) ifTrue: [^self].	self parentRecord 		printPremergeCommentHistoryOn: aStream 		from: aString 		withLeadingCR: true</body><body package="Store-Database Model">shortItemString	^self name, self shortVersionString.</body><body package="StoreForGlorpVWUI">stringKey: hints 	"A string used to represent myself in browsers, for example in a menu. The 	default is to use my displayString"	^(hints includes: #blessing)		ifTrue: [Policies blessingPolicy stringKeyFor: self versionString blessingLevel: self blessingLevelNumber]		ifFalse: [primaryKey == nil				ifTrue: [name]				ifFalse: [self name, self versionString]]</body><body package="StoreForGlorpVWUI">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body><body package="StoreForGlorpVWUI">toolListText	^self displayString</body><body package="StoreForGlorpVWUI">traceVersionString	^self version ifNil: ['(???)'].</body><body package="Store-Database Model">versionStringAlternate	^self versionString</body><body package="Store-Database Model">versionStringWithUserName	^self versionString</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>reconciling</category><body package="Store-Database Model">addBlessingOnly: aStoreBlessing	"Unlike our cousin #bless: we just add a new blessing, but we make our blessing level our parent's blessing level.	This has the effect of adding an informative blessing, while not changing the blessing level of the pundle itself"	(aStoreBlessing username isNil or: [aStoreBlessing username = '???']) ifTrue: [aStoreBlessing username: username].	aStoreBlessing timestamp isNil ifTrue: [aStoreBlessing timestamp: timestamp].	blessings add: aStoreBlessing.	currentBlessingLevel := trace currentBlessingLevel</body><body package="Store-Database Model">bless: aStoreBlessing	"Prior versions of this method set the currentBlessingLevel to a string but it is an integer in the database and retrieved as an integer by the descriptor system."	(aStoreBlessing username isNil or: [aStoreBlessing username = '???']) ifTrue: [aStoreBlessing username: username].	aStoreBlessing timestamp isNil ifTrue: [aStoreBlessing timestamp: timestamp].	blessings add: aStoreBlessing.	currentBlessingLevel := aStoreBlessing blessingLevel.</body><body package="Store-Database Model">ifMatchesWith: aStorePundle do: matchBlock else: noMatchBlock	"Check if we are a match with the argument. Note that this is very specialized, and expects the blocks to return from the outer scope. Also note that if we can't tell for sure, we just return, and let the caller figure out. Expected to be called from matchesWith:"	aStorePundle isNil ifTrue: [^noMatchBlock value].	self name = aStorePundle name ifFalse: [^noMatchBlock value].	"If the version name doesn't match, don't even bother looking. Note that in a different database, the version name could have a prefix, but we should only ever get this far if we're publishing. When replicating, we'd get a timestamp match on two versions that were really the same but the version had been renamed due to a conflict"	(self version notNil and: [self version ~= aStorePundle version]) ifTrue: [^noMatchBlock value].	"Short circuit if name and timestamp match. It's a go"	(self timestamp notNil and: [self timestamp = aStorePundle timestamp]) ifTrue: [^matchBlock value].	self reconcileWith: aStorePundle.	self basicComment yourSelf = aStorePundle basicComment yourSelf ifFalse: [^noMatchBlock value].	self propertiesMatch ifFalse: [^noMatchBlock value].	^self</body><body package="Store-Database Model">ignorableProperties	"Return a list of the properties that we don't really care if they match, 	because they're likely to have been set on an image level, 	and the corresponding database package won't have them"		^#(#parcelName #bundleName #packageName #version #parcelDirectory)</body><body package="Store-Database Model">propertiesMatch	| previousProperties myProperties previousSize mySize |	self previous isNil ifTrue: [^false].	previousProperties := self previous properties copy.	Dialect volatilePropertyKeys do: [:each | previousProperties removeKey: each ifAbsent: []].	myProperties := self properties.	myProperties isNil ifTrue: [^previousProperties == myProperties].	myProperties keysAndValuesDo: [:eachKey :eachValue |		(self ignorableProperties includes: eachKey)			ifFalse: [				(previousProperties at: eachKey ifAbsent: [Object new]) = eachValue					ifFalse: [^false]]].	previousSize := 0.	previousProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [previousSize := previousSize + 1]].	mySize := 0.	myProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [mySize := mySize + 1]].	^mySize = previousSize.</body><body package="Store-Database Model">reconcile	self reconcileComment.	self reconcileProperties.	self reconcileBlessings.</body><body package="Store-Database Model">reconcileBlessings	" I don't believe that blessings are ever shared between versions"	blessings do: [:each | each trace: nil].</body><body package="Store-Database Model">reconcileComment	self comment = self previous comment		ifTrue: [comment := self previous basicComment]		 ifFalse: [self markModified].</body><body package="Store-Database Model">reconcileProperties	"I suspect this and propertiesMatch could be refactored to read more simply."	self reconcilePropertiesRecords.	(self properties isNil or: [self properties isEmpty]) ifTrue:		[propertiesBlob := nil.		(self previous isNil or: [self propertiesMatch]) ifFalse: [self markModified].		^self].	(self propertiesMatch and: [self previous propertiesBlob notNil and: [self previous propertiesBlob primaryKey ~= 0]]) 		ifTrue: [propertiesBlob := self previous propertiesBlob]			ifFalse:			[self markModified.			propertiesBlob := StoreBlob forObject: self properties].</body><body package="Store-Database Model">reconcilePropertiesRecords	"Instvar properties are keyed by symbol but instvar propertiesRecords are keyed by string."	| newRecords previousRecords volatile |	newRecords := Dictionary new.	previousRecords :=		(self previous isNil or: [self previous propertiesRecordDictionary isNil])			ifTrue: [Dictionary new]			ifFalse: [self previous propertiesRecordDictionary].			self properties keysAndValuesDo:		[:eachKey :eachObject || previousObject |		previousObject := previousRecords at: eachKey asString ifAbsent: [nil].		newRecords			at: eachKey asString			put: ((previousObject notNil and: [previousObject basicDefinition object = eachObject])					ifTrue: [previousObject]					ifFalse:						[self markModified.						StoreProperty named: eachKey asString forObject: eachObject in: self])].	volatile := Dialect volatilePropertyKeys select: [:each | previousRecords includesKey: each asString].	newRecords size = (previousRecords size - volatile size) ifFalse: [self markModified].	propertiesRecordDictionary := newRecords.</body><body package="Store-Database Model">reconcileWith: aPundle	"When we share source with aPundle, use it instead of our own"	self previous: aPundle.	aPundle isNil ifTrue: [self unreconcile] ifFalse: [self reconcile].	self removeDuplicates.</body><body package="Store-Database Model">reconcilesWith: aStorePundle	self version = aStorePundle version ifFalse: [^false].	self timestamp =aStorePundle timestamp ifFalse: [^false].	self username = aStorePundle username ifFalse: [^false].	^super reconcilesWith: aStorePundle.</body><body package="Store-Database Model">uninstantiateSubcomponentProxies	"Only applies to bundles."</body><body package="Store-Database Model">unreconcile	super unreconcile.	self unreconcileStoreModel.	self basicComment isNil ifFalse: [self basicComment unreconcile].	self propertiesBlob isNil		ifTrue: [propertiesBlob := StoreBlob forObject: self properties]		ifFalse: [self propertiesBlob unreconcile].	self propertiesRecordDictionary isNil		ifTrue: [self reconcilePropertiesRecords]		ifFalse: [self propertiesRecordDictionary do: [:each | each unreconcile]].	blessings do: [:each | each unreconcile].</body><body package="Store-Database Model">unreconcileStoreModel	"We are asserting we have no previous.  If our storeModel has no previous then it may still be legitimate for us."	storeModel isNil ifFalse:		[storeModel parentRecord isNil ifFalse:			[storeModel parentRecord parentRecord isNil ifTrue: [^self]]].	self markModified.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>testing</category><body package="Store-Database Model">canLoadNewOrReplaceExistingVersion	^self storeModel isNil		ifTrue: [true]		ifFalse: [self storeModel canReplaceVersions]</body><body package="Store-Database Model">hasCodeOverridden	"Store compatibility. Answer false because we don't care if we have overridden code or not"	^false.</body><body package="Store-Database Model">hasRelatedParcel	^self subclassResponsibility</body><body package="Store-Database Model">hasRelatedParcelIn: aSession	^self subclassResponsibility</body><body package="Store-Database Model">isBundle	^false.</body><body package="Store-Database Model">isComponentLoaded	^self storeModel notNil.</body><body package="Store-Database Model">isImageModel	^false</body><body package="Store-Database Model">isPackage	^self isBundle not.</body><body package="Store-Database Model">isPublishedBinary	^self subclassResponsibility</body><body package="Store-Database Model">isSameAsImage	"We first send self storeModel to make sure that it is in me"	self storeModel.	self isLoaded ifFalse: [^false].	^self sameVersionAs: self storeModel.</body><body package="Store-Database Model">isValid	^true.</body><body package="Store-Database Model">isValidAsNew	"Return true if we are valid as a newly created pundle. This is the same as normal validation, but short-circuits if we already have a primary key, meaning that we're not actually new. So validating e.g. a new bundle, but which contains references to old packages, won't need to revalidate the packages. This assumes that they have already been validated"		self primaryKey isNil ifFalse: [^true].	^self isValid.</body><body package="Store-Database Model">needsPublishing	"Return true if this is a sub-component (or main component) that needs to be published. We know this, because it won't have a primary key, so it's not in the database, but it has been assigned a version number. It's even possible we don't actually care if there's a version number."	^self primaryKey isNil and: [self version notNil].</body><body package="StoreForGlorpVWUI">sameAsImage	| imageModel |	imageModel := self storeModel.	imageModel isNil ifTrue: [^false].	^imageModel sameVersionAs: self</body><body package="Store-Database Model">sameVersionAs: aStorePundleOrPundleModel		^aStorePundleOrPundleModel sameVersionAsPublished: self</body><body package="Store-Database Model">sameVersionAsPublished: aStorePundle	^self primaryKey = aStorePundle primaryKey		and: [self isPackage = aStorePundle isPackage]</body><body package="Store-Database Model">youngerThan: aPackage		^(aPackage isLoaded and: [aPackage isImageObject])		ifTrue: [(aPackage youngerThan: self) not] 		ifFalse: [self primaryKey &gt; aPackage primaryKey]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>fixups</category><body package="Store-Database Model">convertBlobProperties	properties := propertiesBlob object.	properties isNil ifTrue: [self initializeProperties]</body><body package="Store-Database Model">convertProperties	"Create an in-memory representation of properties as a dictionary from symbols to objects"	(propertiesRecordDictionary yourSelf notNil		and: [propertiesRecordDictionary yourSelf isEmpty not])			ifTrue: [^self convertRecordProperties].	propertiesBlob yourSelf isNil ifFalse: [^self convertBlobProperties].	self initializeProperties</body><body package="Store-Database Model">convertRecordProperties	self initializeProperties.	propertiesRecordDictionary		keysAndValuesDo: [:eachKey :eachValue | properties at: eachKey asSymbol put: eachValue object]</body><body package="Store-Database Model">removeDuplicates</body><body package="Store-Database Model">replicationNoticeBlessing	^Dialect isVWWithNameSpaces		ifTrue: [(Dialect smalltalkAt: #'Store.Policies') blessingPolicy blessingNumber: 'Replication Notice']		ifFalse: [-1].</body><body package="Store-Database Model">validateVersionString	"Check to see if the receiver's version string is already used. This is way too late in the game to cancel, so insist on a new version string."		^[Policies versionPolicy existsVersionString: version forPundle: self]		whileTrue:			[version := PundleVersionAlreadyExistsError signalWith: self.			(version isNil or: [version isEmpty])				ifTrue: [^UserCancelledPublish signal]]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>prerequisites</category><body package="Store-Database Model">attemptToLoadBundleNamed: aBundleName version: aVersionString	"Attempt to load a bundle that satifies the prerequisite."	"We know an acceptable version is not already loaded."		| bundles |	(aVersionString notNil and: [aVersionString notEmpty])		ifTrue: [ 			(StoreBundle loadWithName: aBundleName 				version: aVersionString 				in: self session) ifNotNil: [^true]].	bundles := StoreBundle allVersionsWithName: aBundleName in: self session.	bundles isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aBundleName from: bundles version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:bundle | bundle loadSource notNil]</body><body package="Store-Database Model">attemptToLoadBundleNamed: aBundleName version: aVersionString with: aCompilationManager	"Attempt to load a bundle that satifies the prerequisite."	"We know an acceptable version is not already loaded."		| bundles |	(aVersionString notNil and: [aVersionString notEmpty])		ifTrue: [ 			(StoreBundle loadWithName: aBundleName 				version: aVersionString 				with: aCompilationManager 				in: self session) ifNotNil: [^true]].	bundles := StoreBundle allVersionsWithName: aBundleName in: self session.	bundles isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aBundleName from: bundles version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:bundle | (Parcel withFileCachesDo: [bundle loadSourceWith: aCompilationManager]) notNil]</body><body package="Store-Database Model">attemptToLoadPackageNamed: aPackageName version: aVersionString	"Attempt to load a package that satifies the prerequisite.	We know an acceptable version is not already loaded."		| packages |	(aVersionString notNil and: [aVersionString notEmpty])		ifTrue: [ 			(StorePackage loadWithName: aPackageName 				version: aVersionString 				in: self session) ifNotNil: [^true]].	packages := StorePackage allVersionsWithName: aPackageName in: self session.	packages isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aPackageName from: packages version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:value | value quietlyLoadSource notNil]</body><body package="Store-Database Model">attemptToLoadPackageNamed: aPackageName version: aVersionString with: aCompilationManager	"Attempt to load a package that satifies the prerequisite.	We know an acceptable version is not already loaded."		| packages |	(aVersionString notNil and: [aVersionString notEmpty])		ifTrue: [ 			(StorePackage loadWithName: aPackageName 				version: aVersionString 				with: aCompilationManager 				in: self session) ifNotNil: [^true]].	packages := StorePackage allVersionsWithName: aPackageName in: self session.	packages isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aPackageName from: packages version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:value | (Parcel withFileCachesDo: [value loadSourceWith: aCompilationManager]) notNil]</body><body package="Store-Database Model">checkParcelPrerequisite: aParcelName version: aVersionString	"Validate the existense of a parcel as a prerequisite. Answer true if loaded"		^([Parcel ensureLoadedParcel: aParcelName withVersion: aVersionString forPundle: self]		on: Parcel missingParcelSignal		do: [:exp | exp return: nil]) notNil</body><body package="Store-Database Model">checkParcelPrerequisite: aParcelName version: aVersionString with: aCompilationManager	"Validate the existense of a parcel as a prerequisite. Answer true if loaded"		^([Parcel ensureLoadedParcel: aParcelName withVersion: aVersionString forPundle: self with: aCompilationManager]		on: Parcel missingParcelSignal, CodeReader incompatibleVersionIdSignal		do: [:exp | exp return: nil]) notNil</body><body package="Store-Database Model">checkPrerequisite: aPrerequisiteDescription with: aCompilationManager	"Validate the existence of a prerequisite. Either by verifying an appropriate match is loaded, or by loading one that does. Answer true if okay to finish loading"	| message loadSources |	(self checkPrerequisiteLoaded: aPrerequisiteDescription) ifTrue: [^true].	loadSources := aPrerequisiteDescription possibleLoadSources.	[loadSources do: 		[:eachSourceType |		(self prerequisiteRecursionIncludes: (aPrerequisiteDescription name -&gt; eachSourceType))			ifTrue: [^true].		self prerequisiteRecursionAdd: (aPrerequisiteDescription name -&gt; eachSourceType).		#parcel = eachSourceType ifTrue: 			[(self				checkParcelPrerequisite: aPrerequisiteDescription name				version: aPrerequisiteDescription versionFilter				with: aCompilationManager) ifTrue:[^true]].		#package = eachSourceType ifTrue: 			[(self				attemptToLoadPackageNamed: aPrerequisiteDescription name				version: aPrerequisiteDescription versionFilter				with: aCompilationManager) ifTrue: [^true]].		#bundle = eachSourceType ifTrue: 			[(self				attemptToLoadBundleNamed: aPrerequisiteDescription name				version: aPrerequisiteDescription versionFilter				with: aCompilationManager) ifTrue: [^true]]]]		on: SkipPrerequisite		do: 			[:exception |			Transcript 				cr;				show: ((#Prerequisite1sSkipped2s &lt;&lt; #store &gt;&gt; 'Prerequisite &lt;1s&gt; has been skipped for: &lt;2s&gt;') 					expandMacrosWith: aPrerequisiteDescription name					with: self name).			^true].	message := #UnableToLoadPrerequ2sNtttContinue &lt;&lt; #store		&gt;&gt; 'Unable to load prerequisite &lt;1s&gt; &lt;2s&gt;&lt;nttt&gt;Continue?'				expandMacrosWith: aPrerequisiteDescription name				with: (#version1s &lt;&lt; #store &gt;&gt; 'version &lt;1s&gt;' expandMacrosWith: aPrerequisiteDescription versionFilter).	^PrerequisiteUnableToLoadConfirmation raiseRequestErrorString: message</body><body package="Store-Database Model">checkPrerequisiteLoaded: aPrerequisiteDescription	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications |	verifications := aPrerequisiteDescription possibleLoadSources				collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: 			[:each |			self				perform: each				with: aPrerequisiteDescription name				with: aPrerequisiteDescription versionFilter]</body><body package="Store-Database Model">checkPrerequisiteLoaded: aPrereqType named: aNameString version: aVersionString	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications prereqTypes |	prereqTypes := self classicPrereqTypeAsList: aPrereqType.	verifications := prereqTypes collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: [:each | self perform: each with: aNameString with: aVersionString]</body><body package="Store-Database Model">checkPrerequisiteLoaded: aPrereqType named: aNameString version: aVersionString with: aCompilationManager	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications prereqTypes |	prereqTypes := self classicPrereqTypeAsList: aPrereqType.	verifications := prereqTypes collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: 			[:each |			self				perform: each				with: aNameString				with: aVersionString				with: aCompilationManager]</body><body package="Store-Database Model">checkPrerequisiteNamed: prerequisiteName withVersion: prerequisiteVersionString requiredVersion: requiredVersionString	"Answer if the version of the prerequisite prerequisiteName is acceptable.	Callback for prerequiste loading"		| actionBlock |	(actionBlock := CodeComponent asActionBlock: self versionSelectionBlock) ifNil:		[^(requiredVersionString isNil or: [requiredVersionString isEmpty])			ifTrue: [true]			ifFalse: [prerequisiteVersionString = requiredVersionString]].	^actionBlock value: prerequisiteName value: prerequisiteVersionString value: requiredVersionString</body><body package="Store-Database Model">checkPrerequisitesWithin: aBundle with: aCompilationManager	"Check the prereqs, but reject those belonging to aBundle. 	Answer true if it's okay to load."	| prereqs |	(prereqs := self prerequisiteDescriptions) ifNil: [^true].	prereqs isEmpty ifTrue: [^true].	self prerequisiteRecursionAdd: self name -&gt; self componentType.	(prereqs select: #isForStore) do: 		[:each |		(self checkPrerequisite: each within: aBundle with: aCompilationManager) ifFalse: [^false]].	^true</body><body package="Store-Database Model">checkPundlePrerequisiteContained: aPrerequisiteDescription	| typeSelector |	typeSelector := #(#isPackage #isBundle #notNil)				at: (#(#package #bundle nil)						indexOf: aPrerequisiteDescription componentType).	^self withAllUniqueItems anySatisfy: 			[:item |			item name = aPrerequisiteDescription name				and: [item perform: typeSelector]]</body><body package="Store-Database Model">checkPundlePrerequisiteContained: aPrereqType named: aCodeComponentName	| items typeSelector prereqVector |	items := self allUniqueItems.	prereqVector := self classicPrereqTypeAsList: aPrereqType.	^prereqVector anySatisfy:		[:eachPrereqType | 		typeSelector := #(#isPackage #isBundle #notNil) at: (#(#package #bundle #parcel) indexOf: eachPrereqType).		items anySatisfy: [:item | item name = aCodeComponentName and: [item perform: typeSelector]]]</body><body package="Store-Database Model">loadedVerificationMethodForType: aLoadSourrceType	"What method should we use against ourself to verify aPundleType of given name and version is loaded?"	aLoadSourrceType = #parcel ifTrue: [^#verifyLoadedParcelNamed:version:].	aLoadSourrceType = #package ifTrue: [^#verifyLoadedPackageNamed:version:].	aLoadSourrceType == #bundle ifTrue: [^#verifyLoadedBundleNamed:version:].	^self error: ('Unknown code component type: &lt;1p&gt;'				expandMacrosWith: aLoadSourrceType)</body><body package="Store-Database Model">prerequisiteRecursion		^PrerequisiteRecursion ifNil: [PrerequisiteRecursion := Set new].</body><body package="Store-Database Model">prerequisiteRecursionAdd: anAssociation		^self prerequisiteRecursion add: anAssociation</body><body package="Store-Database Model">prerequisiteRecursionIncludes: anAssociation		^self prerequisiteRecursion includes: anAssociation</body><body package="Store-Database Model">prerequisiteRecursionReset		PrerequisiteRecursion := nil</body><body package="Store-Database Model">verifyLoadedBundleNamed: aNameString version: aVersionString	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry bundleNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model">verifyLoadedBundleNamed: aNameString version: aVersionString with: aCompilationManager	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry bundleNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model">verifyLoadedPackageNamed: aNameString version: aVersionString	"Validate the existense of a package by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry packageNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model">verifyLoadedPackageNamed: aNameString version: aVersionString with: aCompilationManager	"Validate the existense of a package by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry packageNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model">verifyLoadedParcelNamed: aNameString version: aVersionString	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Parcel parcelNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value version				requiredVersion: aVersionString]</body><body package="Store-Database Model">verifyLoadedParcelNamed: aNameString version: aVersionString with: aCompilationManager	"Validate the existense of a parcel by a given name and version. 	Answer true if acceptable version is already loaded"		^(Parcel parcelNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value version				requiredVersion: aVersionString]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>full classes</category><body package="Store-Database Model">allClasses	^self fullClasses.</body><body package="Store-Database Model">definedObjectNamed: aString	^(self fullClasses asArray, self nameSpaces, self sharedVariables) detect: [:each | each longName = aString] ifNone: [nil].</body><body package="Store-Database Model">fullClassNamed: aString	^self fullClasses detect: [:each | each longName = aString] ifNone: [nil].</body><body package="Store-Database Model">fullClasses	self subclassResponsibility.</body><body package="Store-Database Model">fullClassesAndMetaClasses	self subclassResponsibility.</body><body package="Store-Database Model">fullClassesDetect: aBlock ifFound: anObject	self subclassResponsibility</body><body package="Store-Database Model">nameSpaceNamed: aString	^self nameSpaces detect: [:each | each longName = aString] ifNone: [nil].</body><body package="Store-Database Model">nameSpacesDetect: aBlock ifFound: foundBlock	self subclassResponsibility</body><body package="Store-Database Model">objectNamed: aString	self fullClassesDetect: [:each | each longName = aString] ifFound: [:item | ^item].	self nameSpacesDetect: [:each | each longName = aString] ifFound: [:item | ^item].	self sharedVariablesDetect: [:each | each longName = aString] ifFound: [:item | ^item].	^nil</body><body package="Store-Database Model">resetFullClasses	self subclassResponsibility.</body><body package="Store-Database Model">sharedVariablesDetect: aBlock ifFound: foundBlock	self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>copying</category><body package="Store-Database Model">= aStorePundle	"Compare two database pundles."	^self class = aStorePundle class and: 		[ self primaryKey = aStorePundle primaryKey			and: [ self primaryKey notNil or: [ self name = aStorePundle name ] ] ]</body><body package="Store-Database Model">postCopyIn: aDictionary	| newProps |	super postCopyIn: aDictionary.	comment := (comment isNil or: [comment unchainedBinaryData isNil]) ifTrue: [nil] ifFalse: [comment glorpCopyIn: aDictionary].	properties := properties glorpCopyIn: aDictionary.	propertiesBlob := propertiesBlob glorpCopyIn: aDictionary.	newProps := Dictionary new.	propertiesRecordDictionary isNil ifFalse: [		propertiesRecordDictionary keysAndValuesDo: [:eachKey :eachValue |				newProps at: eachKey put: (eachValue glorpCopyIn: aDictionary)].		propertiesRecordDictionary := newProps].	blessings := blessings collect: [:each | each glorpCopyIn: aDictionary].	session := nil.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>constants</category><body package="Store-Database Model">componentType		self subclassResponsibility</body><body package="Store-Database Model">propertyTypeCode	^self class propertyTypeCode.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>utilities</category><body package="Store-Database Model">addBlessingLevel: anInteger andComment: aString	| publishSpecification |	publishSpecification := PublishSpecification pundle: self.	publishSpecification blessing: anInteger.	publishSpecification comment: aString.	publishSpecification publish: true.	publishSpecification publishBlessing.</body><body package="Store-Database Model">addBlessingLevel: anInteger andComment: aString informativeBlessing: aBoolean	| publishSpecification |	publishSpecification := PublishSpecification pundle: self.	publishSpecification blessing: anInteger.	publishSpecification comment: aString.	publishSpecification publish: true.	publishSpecification publishInformativeBlessing: aBoolean.</body><body package="Store-Database Model">allVersionPrimaryKeysWithProperty: aStoreProperty	^self class allVersionPrimaryKeysWithProperty: aStoreProperty in: session</body><body package="Store-Database Model">allVersionsWithTrace: anInteger	^self class allVersionsWithTrace: anInteger in: session</body><body package="Store-Database Model">classicPrereqTypeAsList: aTypeSymbol	"Convert simple prereq types (#any, #bundle, #package, #parcel) into the appropriate sequence of specific prereqs, which means converting #any based on the search order preferences, wrapping anything else as any array."	aTypeSymbol == #any		ifTrue: 			[^Policies prerequisitePolicy searchOrder = #parcelsFirst				ifTrue: [#(#parcel #bundle #package)]				ifFalse: [#(#bundle #package #parcel)]].	^Array with: aTypeSymbol</body><body package="Store-Database Model">sharesProperty: aStoreProperty	^self class sharesProperty: aStoreProperty in: session</body><body package="Store-Database Model">withName: aNameString version: aVersionString	^self class withName: aNameString version: aVersionString in: self session</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>deleting</category><body package="Store-Database Model">delete	"Delete this pundle from the database"	self session delete: self.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>comparing</category><body package="Store-Database Model">&lt;= aStorePundle	self name &lt; aStorePundle name ifTrue: [^true].	self name = aStorePundle name ifTrue: [^self timestamp &gt;= aStorePundle timestamp].	^false.</body><body package="Store-Difference Management">allPropertiesAndValuesIn: firstDictionary butNotIn: secondDictionary	| dictionary |	dictionary := Dictionary new.	firstDictionary notEmpty 		ifTrue: [			firstDictionary keysAndValuesDo: 				[:key :value | dictionary at: key put: key -&gt; value].			secondDictionary keysAndValuesDo: 				[:key :value | 					(dictionary at: key ifAbsent: [nil -&gt; nil]) value = value 						ifTrue: [							dictionary removeKey: key ifAbsent: []]]].	^dictionary</body><body package="Store-Difference Management">allPropertiesAndValuesInPundle: aStorePundle butNotIn: anotherStorePundle	^self		allPropertiesAndValuesIn: (aStorePundle ifNil: [#()] ifNotNil: [aStorePundle propertiesWithoutVolatileKeys])		butNotIn: (anotherStorePundle ifNil: [#()] ifNotNil: [anotherStorePundle propertiesWithoutVolatileKeys]).</body><body package="StoreForGlorpVWUI">compareToImage	^self getImagePundle		ifNil: [#notLoaded]		ifNotNil: [:value | value compareToPundle: self]</body><body package="Store-Database Model">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."		^aCodeComponent isPackage = self isPackage and: [name = aCodeComponent name]</body><body package="Store-Difference Management">computePropertyDifferencesBetween: aPundle into: aPackageComparitor	"If aPackage is already a StorePackage, compute the diffs ourselves. 	Otherwise, convert it into one, either by reading it from the database if it's a Package, or by converting the image packageModel"		| other |	other := (aPundle pseudoPackage or: [aPundle class = self class])		ifTrue: [aPundle]		ifFalse:			[aPundle primaryKey = 0				ifTrue: [aPundle asStorePundleIn: self session]				ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aPundle primaryKey]]].	^other computePropertyDiffsBetweenDBPundle: self into: aPackageComparitor</body><body package="Store-Difference Management">computePropertyDiffsBetweenDBPundle: aStorePundle into: aPackageComparitor	"Store differences between receiver and a aStorePackage into an instance of PackageComparitor.	Counterintuitively, this puts the receiver's definitions in the comparitor's 'other' instVars and the definitions 	of the parameter (i.e. aStorePundle which is mapped to realMainPackage, named to help understanding) 	into the comparitor's 'main' instVars, since this method is called with arguments reversed."	| realMainPackage |	realMainPackage := (aStorePundle isNil or: [aStorePundle class == self class]) 		ifTrue: [aStorePundle] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aStorePundle primaryKey]].	self = realMainPackage ifTrue: [aPackageComparitor makeEmpty. ^self].	aPackageComparitor otherPackageProperties: (self allPropertiesAndValuesInPundle: self butNotIn: realMainPackage).	aPackageComparitor mainPackageProperties: (self allPropertiesAndValuesInPundle: realMainPackage butNotIn: self).	aStorePundle isBundle ifTrue:		[self structure = realMainPackage structure ifFalse:			[aPackageComparitor otherPackageProperties add: (#structure -&gt; self structure).			aPackageComparitor mainPackageProperties add: (#structure -&gt;  realMainPackage structure)]].	^aPackageComparitor</body><body package="Store-Database Model">hash	^(self class hash bitXor: self primaryKey hash) bitXor: self name hash</body><body package="StoreForGlorpVWUI">itemString	^self name , self versionString.</body><body package="StoreForGlorpVWUI">itemStringWithBlessing	^self displayString , ' ', self blessingLevelString</body><body package="Store-Database Model">sameVersionAsLoadedPundle: anImPundle	^anImPundle sameVersionAsPublished: self</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>converting</category><body package="Store-Database Model">asIndividualProxy	"Construct a proxy that reads me back."	| query |	self isGlorpProxy ifTrue: [^self].	"This should never happen, but let's be sure."	self primaryKey isNil ifTrue: [self error: 'Attempt to construct an individual proxy for a package or bundle with no primary key'].	"Construct a slightly sneaky query, to run quickly, because the fields are indexed, but be sure that we don't get a cache hit, which would defeat the proxying."	query := Query readOneOf: self class where: [:each | each primaryKey = self primaryKey &amp; (each timestamp = self timestamp)].	query returnProxies: true.	"Executing the query means it will actually go to the database, then return a proxy, which is a bit of waste of time, but a good deal simpler than constructing a proxy manually"	^self session execute: query.</body><body package="Store-Database Model">asPrerequisiteDescription	^(PrerequisiteDescription new)		name: self name;		componentType: self componentType;		yourself</body><body package="Store-Database Model">asStoreComparisonObjectIn: ignore	^self</body><body package="Store-Database Model">asStorePundleIn: aSession	"I don't care about the session, at least I don't think so	aSession = self session ifFalse: [self error: 'Incompatible sessions']."	^self.</body><body package="Store-Publishing Support">minimizeFootprintInImage	self trace notNil		ifTrue: [self trace privateUninstantiate].</body><body package="StoreForGlorpVWUI">recordForPropertyTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"		^(self properties includesKey: aTag property)		ifFalse: [nil]		ifTrue:			[(aTag copy)				package: self;				yourself]</body><body package="Store-Database Model">storeForGlorpPundleClass	^self class</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize	super initialize.	blessings := OrderedCollection new</body><body package="Store-Database Model">initializeProperties	"Warning - this is called from convertBlobProperties, convertRecordProperties and propertyAt:put:.  	It should not be included in initialize, or it will prevent database properties from being loaded."	properties := Dictionary new</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>image model</category><body package="Store-Database Model">createImagePundle	"Check if there if already loaded versions of the receiver and answer it. 	If not create a new pundle and register it."		| pundleModel |	pundleModel := self getImagePundle.	pundleModel ifNil:		[pundleModel := self class imageClass named: self name.		pundleModel dbIdentifier: self dbIdentifier].	^pundleModel</body><body package="StoreForGlorpVWUI">getImagePundle	^self storeModel.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>browsing</category><body package="StoreForGlorpVWUI">browseContents	^GlorpHelper dialect isVWWithNameSpaces		ifTrue: [(StoreForGlorpBrowserEnvironment on: self) openEditor]		ifFalse: 			[Refactory.Browser.RefactoringBrowser				openOnEnvironment: self asBrowserEnvironment]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>publishing</category><body package="Store-Publishing Support">applyPundleVersionsToTheImage	"After we have been published, or loaded, take all of our version and trace information and set it into the image pundles. We want to do this after loading because the component descriptions we return during loading are our own objects, and we want to put them back to normal store descriptions.  Also reset the contentDescriptions of any other databaseInformations of bundles so the image knows what subpundles it has loaded whoever we then connect to."	| databaseIdentifier |	databaseIdentifier := session databaseIdentifier.	self allComponentsDo:		[:each |		| imageModel | 		imageModel := each storeModel.		imageModel isNil ifFalse:			[each noteLoad.			imageModel databaseInfomationForOrCreate: databaseIdentifier.			imageModel setDbTraceAndVersionUsing: each for: databaseIdentifier.			imageModel resetNoDatabaseInformation.			imageModel isPackage ifTrue: [imageModel removeEmptyProtocols].			each isBundle ifTrue:				[imageModel					setContentsFromDB: each asPundleWithComponentDescriptions for: databaseIdentifier;					initializeFromImage: (Registry bundleNamed: imageModel name) for: databaseIdentifier]]].</body><body package="Store-Publishing Support">applyPundleVersionsToTheImage: aBoolean	"After we have been published, or loaded, take all of our version and trace information and set it into the image pundles. We want to do this after loading because the component descriptions we return during loading are our own objects, and we want to put them back to normal store descriptions.  Also reset the contentDescriptions of any other databaseInformations of bundles so the image knows what subpundles it has loaded whoever we then connect to."	| databaseIdentifier |	databaseIdentifier := session databaseIdentifier.	self allComponentsDo:		[:each |		| imageModel | 		imageModel := each storeModel.		imageModel isNil ifFalse:			[aBoolean ifTrue: 				[each noteLoad.				imageModel mergeInformation: nil].			imageModel databaseInfomationForOrCreate: databaseIdentifier.			imageModel setDbTraceAndVersionUsing: each for: databaseIdentifier.			imageModel resetNoDatabaseInformation.			imageModel isPackage ifTrue: [imageModel removeEmptyProtocols].			each isBundle ifTrue:				[imageModel					setContentsFromDB: each asPundleWithComponentDescriptions for: databaseIdentifier;					initializeFromImage: (Registry bundleNamed: imageModel name) for: databaseIdentifier]]].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI">asComponentDescription	"Return a representation of ourselves as a store component description, used to update the image after a publish, or while loading"	^self descriptionClass new		id: primaryKey;		dbIdentifier: self session databaseIdentifier;		componentName: name;		yourself</body><body package="Store-Database Model">asComponentDescriptionForReal	"Return a representation of ourselves as a store component description, used to update the image after a publish, or while loading"	^self descriptionClass new		id: primaryKey;		dbIdentifier: self session databaseIdentifier;		componentName: name;		yourself</body><body package="Store-Publishing Support">asPundleWithComponentDescriptions	"I should never be sent!"	| copy |	copy := self copy.	^copy.</body><body package="StoreForGlorpVWUI">binarySave	^self propertyAt: #binarySave ifAbsent: [nil]</body><body package="StoreForGlorpVWUI">blessingLevel	^self blessingLevelNumber printString</body><body package="Store-Database Model">canBePublishedToCurrentDatabase	^self isInCurrentDatabase</body><body package="StoreForGlorpVWUI">changeSet	^self storeModel changeSet.</body><body package="Store-Database Model">checkPrerequisite: aPrerequisiteDescription within: aBundle with: aCompilationManager	"Validate the existence of a prerequisite of given name and type within a bundle. Answer true if okay to finish loading"	aBundle ifNotNil: 		[(aBundle checkPundlePrerequisiteContained: aPrerequisiteDescription) ifTrue: [^true]].	^self checkPrerequisite: aPrerequisiteDescription with: aCompilationManager</body><body package="Store-Database Model">classOfDbRecord	^self.</body><body package="Store-Database Model">cleanse	"I do nothing, since I'm in the Database"</body><body package="Store-Database Model">cleanse: ignore	"I do nothing, since I'm in the Database"</body><body package="Store-Database Model">component	^self storeModel.</body><body package="Store-Database Model">databaseList	^Array with: self session databaseIdentifier</body><body package="Store-Database Model">dbTrace	^self previous ifNotNil: [self previous primaryKey]</body><body package="StoreForGlorpVWUI">describesPackageNamed: aString	"Copied from Store.ComponentDescription"	"Answer true if the description refers to a package named aString."	^false</body><body package="StoreForGlorpVWUI">descriptionClass	self subclassResponsibility.</body><body package="Store-Database Model">hasBeenModified	"If the storeModel is nil we cannot meaningfully say we are unmodified.  (Standard store takes a similar approach;  pundle models with no db info are regarded as modified.)"	^storeModel isNil or: [storeModel hasBeenModified]</body><body package="Store-Database Model">hasTrace	"Since we are using this to imitate a pundleModel, we return true if we have a primary key of our own, which means we correspond to a database entry. Otherwise, it can get confused about a version 1.0 not having version information"	^self primaryKey notNil or: [self previous yourSelf notNil].</body><body package="Store-Database Model">isInCurrentDatabase	^true</body><body package="Store-Database Model">isLoaded	^storeModel notNil.</body><body package="Store-Database Model">isVersionLoaded	| result |	self session ifNil: [^false].	result := self compareToImage.	^(result == #same or: [result == #modified])</body><body package="StoreForGlorpVWUI">loadingPropertyRecords	^self properties yourSelf.</body><body package="Store-Database Model">markModified	"If this is called, our storeModel should agree.  If it does not, it does not correspond to our state and so is nilled."	self hasBeenModified ifFalse: [storeModel := nil].</body><body package="Store-Database Model">parcelName	^storeModel isNil		ifTrue: ['']		ifFalse: [storeModel parcelName].</body><body package="Store-Database Model">propertiesForSave	^self properties</body><body package="Store-Database Model">pseudoPackage	^false.</body><body package="Store-Database Model">pundle	^self</body><body package="StoreForGlorpVWUI">pundleChangesClass	^self isBundle ifTrue: [BundleChanges] ifFalse: [PackageChanges].</body><body package="Store-Database Model">pundleWithName: aString version: versionString		^self class pundleWithName: aString version: versionString in: self session</body><body package="StoreForGlorpVWUI">resetProperties	^self.</body><body package="Store-Database Model">runPreReadAndLoad	"Run the preload and answer it's result. If there's no pre-load, don't bother doing the relatively expensive conversion to a store record."	self isNotLoaded ifFalse: [^true].	self runPreRead ifFalse: [^false].	^self runPreLoad</body><body package="StoreForGlorpVWUI">shortVersionString		| string |	string := self version.	string ifNil: [^''].	(string isNil or: [string class = Object]) ifTrue: [string := self timeStampString].	^'(' , string , ')'</body><body package="Store-Database Model">storeTracePackage	^self previous.</body><body package="Store-Database Model">tracePackage	^self previous.</body><body package="Store-Database Model">userWantsFullCompare	^PundleModel useChangeSetsForCompare not or: [InputState default ctrlDown]</body><body package="Store-Database Model">validateLoadOrder	^self storeModel isNil ifTrue: [''] ifFalse: [self storeModel validateLoadOrder].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>private-file out</category><body package="StoreForGlorpVWUI">fileOut		| fileName |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: self name)).	fileName isEmpty ifTrue: [^nil].	self fileOutOnFileNamed: fileName</body><body package="StoreForGlorpVWUI">fileOutOn: aFileManager withoutRepeatingAnyOf: aSet	"File out package on aFileManager"	(aSet includes: self) ifTrue: [^self].	self fileOutOn: aFileManager</body><body package="StoreForGlorpVWUI">fileOutOnFileNamed: aString 	| fileManager |	fileManager := SourceCodeStream write: aString encoding: #Source.	[fileManager timeStamp.	self fileOutOn: fileManager]		ensure: [fileManager close]</body><body package="StoreForGlorpVWUI">fileOutPropertiesOn: aSourceFileManager		self propertiesForFileOut associationsDo: 		[:each | 		aSourceFileManager 			component: self componentType 			named: self name 			property: each key 			value: each value]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>displaying</category><body package="Store-Merge Management">mergeDisplayString	| result versionString textString |	versionString := self simpleVersionString.	result := self compareToImage.	result == #modified ifTrue: [versionString := #x1sStar &lt;&lt; #store &gt;&gt; '&lt;1s&gt; *' expandMacrosWith: versionString].	textString := versionString asText.	(result == #same or: [result == #modified]) ifTrue: [textString := textString allBold].	^textString</body><body package="StoreForGlorpVWUI">toolListIcon	self isVersionLoaded ifFalse: [^self class toolListIcon].	^self getImagePundle class toolListIcon</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>relationships</category><body package="StoreForGlorpVWUI">relatedBy: aSymbol 	"This answers the relationship between objects when used in a Version Graph"	aSymbol == #tt_derivesRel		ifTrue: 			[| children pundleModel |			children := (self allVersionsWithTrace: self primaryKey) asOrderedCollection.			pundleModel := self getImagePundle.			(pundleModel notNil and: [pundleModel dbTrace = self primaryKey])				ifTrue: [children add: pundleModel].			^children].	aSymbol == #tt_derivesRRel ifTrue: [^Set with: (self class cachedItemFor: self tracePackage yourSelf)].	^super relatedBy: aSymbol</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">analyzeAndLoad	(AtomicAnalysisLoader pundle: self) analyze.	^self getImagePundle</body><body package="Glorp Atomic Compiling">asAtomicInstallObject	| instance |	instance := self pundleInstallClass new.	instance pundle: self.	^instance</body><body package="Glorp Atomic Compiling">atomicCompileAndLoad	"Do the actual atomic compiling and loading, with UI feedback. 	If all doesn't go well we throw up the Unloadables dialol"		| compilerManager |	DbRegistry clearPundleCaches.		compilerManager := AtomicCompilationManager newForPundle: self.	compilerManager compileAndInstall ifNil: [^nil].	(compilerManager isCompilationResult not and: [compilerManager isPackage])		ifTrue: [^compilerManager].	compilerManager isFullyLoaded ifFalse: [compilerManager applyLoadingPolicyAfterLoadError].	self prerequisiteRecursionReset.	^compilerManager pundle getImagePundle</body><body package="Glorp Atomic Compiling">defaultCompileManagerClass	self subclassResponsibility</body><body package="Glorp Atomic Compiling">pundleInstallClass	^self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>fileIn/Out</category><body package="Store-Database Model">fileOutProperties: aDictionary on: aFileManager		aDictionary associationsDo: 		[:each | 		aFileManager 			component: self componentType 			named: self name 			property: each key 			value: each value]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>private</category><body package="Store-Publishing Support">privateUninstantiate	"My primaryKey is used in a number of mappings.  The primaryKeys of those of my instVars' values that have primaryKeys are only ever used, if at all, by the mapping for that instVar, so if any of them are proxies, we won't need their values in the fake row.  We test isGlorpProxy before isNil to avoid instantiating a proxy only to discover it is nil."	| descriptor mappings tempRow builder |	descriptor := self session system descriptorFor: self.	mappings :=  descriptor mappings select:		[:each | each isRelationship and: [each shouldProxy and: [each canWrite]]].	tempRow := Array new: descriptor primaryTable fields size.	tempRow at: 1 put: self primaryKey.	(self trace isGlorpProxy or: [self trace isNil]) ifFalse:		[tempRow at: 6 put: self trace primaryKey].	(self basicComment isGlorpProxy or: [self basicComment isNil]) ifFalse:		[tempRow at: 8 put: self basicComment primaryKey].	(self propertiesBlob isGlorpProxy or: [self propertiesBlob isNil]) ifFalse:		[tempRow at: 9 put: self propertiesBlob primaryKey].	builder := ObjectBuilder new				row: tempRow;				requiresPopulating: true.	mappings do:		[:eachMapping || attributeValue |		attributeValue := eachMapping getValueFrom: self.		attributeValue isGlorpProxy 			ifTrue: [attributeValue uninstantiate]			ifFalse: [attributeValue notNil ifTrue:					[eachMapping mapObject: self inElementBuilder: builder]]].</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>query utility</category><body package="Store-Database Model">allNames	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	^self allNamesIn: StoreLoginFactory currentStoreSession.</body><body package="Store-Database Model">allNamesIn: asSessionOrNil	"This does DbRegistry caching"	| session query highestKnownPrimaryKey maxPrimary newNames oldNames allNames |	session := asSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self.	query retrieve: [:each | each primaryKey max].	maxPrimary := (session execute: query) ifNil: [^OrderedCollection new].	(maxPrimary &gt; (DbRegistry highestPrimaryKeyChecked at: self ifAbsent: [0])) ifFalse:		[^DbRegistry cachedNames at: self].	highestKnownPrimaryKey := DbRegistry highestPrimaryKeyChecked at: self ifAbsent: [0].	query := Query read: self.	(DbRegistry cachedNames at: self ifAbsent: [#()]) isEmpty ifFalse:		[query whereClause: [:each | each primaryKey &gt; highestKnownPrimaryKey]]. 	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	newNames := session execute: query.	oldNames := DbRegistry cachedNames at: self ifAbsent: [nil].	allNames := oldNames isNil 		ifTrue: [newNames asSet] 		ifFalse: [oldNames addAll: newNames; yourself].	DbRegistry cachedNames at: self put: allNames.	DbRegistry highestPrimaryKeyChecked at: self put: (maxPrimary ifNil: [0]).	^allNames</body><body package="Store-Database Model">allNamesSorted	"Answer back all unique names for versions of this class that exist in the database, sorted by name"	^(self allNamesSortedIn: StoreLoginFactory currentStoreSession)</body><body package="Store-Database Model">allNamesSortedIn: aSession	"Answer back all unique names for versions of this class that exist in the database, sorted by name, using aSession"	"This doesn't do DbRegistry caching"	| results allNames |	results := self getNamesAndMaxTimestampsIn: aSession.	allNames := results collect: [:ea | ea first].	^allNames</body><body package="Store-Database Model">allNamesSortedIn: aSession usingPundleFilter: aPundleFilter	"Answer back all unique names for versions of this class that exist in the database, sorted by name, using aSession"	"This doesn't do DbRegistry caching"	| results allNames |	results := self 		getNamesAndItemCountIn: aSession 		usingPundleFilter: aPundleFilter.	allNames := results collect: [:ea | ea first].	^allNames</body><body package="Store-Database Model">allPundlesIn: pundleCollection withNewerInDBIn: aSession	"Answer a collection of pundles with newer published versions."	| result session newestPundleDict |	result := OrderedCollection new.	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	self updateTimestampsFor: pundleCollection in: session.	newestPundleDict := self newestVersionsInSession: aSession.	pundleCollection do:			[:each |			| mostRecentTimestamp |			mostRecentTimestamp := newestPundleDict				at: each name				ifAbsent: [Timestamp fromSeconds: 0].			(each publishedBefore: mostRecentTimestamp) ifTrue: [result add: each]].	^result</body><body package="Store-Database Model">allVersionPrimaryKeysWithProperty: aStoreProperty in: aSession	"Answer back all versions of this class that share the passed in Property"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each propertiesRecordDictionary includes: aStoreProperty].	query retrieve: [:each | each primaryKey distinct].	^(session execute: query)</body><body package="Store-Database Model">allVersionsInitiallyNamed: aString	"Answer back all versions of this class that match aString for the name and any parent names, ordered by their timestamp in newest first order"	^self allVersionsInitiallyNamed: aString in: nil</body><body package="Store-Database Model">allVersionsInitiallyNamed: aString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query sameNamed otherNames result oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	(sameNamed := session execute: query) isEmpty ifTrue: [^#()].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed inject: OrderedCollection new into:		[:sum :each |		(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not]])			ifTrue: [sum add: each parent name].		sum].	result := otherNames copy inject: sameNamed copy into:		[:sum :each |		sum, (self allVersionsInitiallyNamed: each in: aSession notIn: (otherNames copy add: aString; yourself) olderThan: oldestTimestamp)].	^result sorted: [:each :other | each timestamp &gt; other timestamp]</body><body package="Store-Database Model">allVersionsInitiallyNamed: aString in: aSession usingPundleFilter: aPundleFilter	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order	with optional range of blessing(s) and date(s)"	| session query sameNamed otherNames result oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	aPundleFilter applyFilterToQuery: query.	query orderBy: [:each | each timestamp descending].	(sameNamed := session execute: query) isEmpty ifTrue: [^#()].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed 		inject: OrderedCollection new		into: 			[:sum :each |			(each parent notNil and: 				[each parent name ~= aString and: 					[(sum includes: each parent name) not]])					ifTrue: [sum add: each parent name].			sum].	result := otherNames 		copy inject: sameNamed copy		into: 			[:sum :each |			sum , (self 				allVersionsInitiallyNamed: each				in: aSession				notIn: ((otherNames copy) add: aString; yourself)				olderThan: oldestTimestamp				usingPundleFilter: aPundleFilter)].	^result sorted: [:each :other | each timestamp &gt; other timestamp]</body><body package="StoreForGlorpVWUI">allVersionsWithBlessingLevel: anInteger in: aSession	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each currentBlessingLevel = anInteger].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">allVersionsWithName: aString	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	^self allVersionsWithName: aString in: StoreLoginFactory currentStoreSession.</body><body package="Store-Database Model">allVersionsWithName: aString after: anInteger	"Answer back all versions of this class that match aString for the name whos primaryKey (anInteger) is larger"	^self allVersionsWithName: aString after: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allVersionsWithName: aString after: anInteger in: aSession	"Answer back all versions of this class that match aString for the name whos primaryKey (anInteger) is larger"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: (each primaryKey &gt; anInteger)].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">allVersionsWithName: aString blessingLevels: aCollection	^self allVersionsWithName: aString blessingLevels: aCollection in: nil</body><body package="Store-Database Model">allVersionsWithName: aString blessingLevels: aCollection in: aStoreSessionOrNil	| session query |	session := aStoreSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: (each currentBlessingLevel in: aCollection)].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">allVersionsWithName: aString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">allVersionsWithName: aName newerThan: aStorePundle	"Answer back all versions of this class that match aString for the name, and have a timestamp newer than aStorePundle's"	^self allVersionsWithName: aName newerThan: aStorePundle in: nil</body><body package="Store-Database Model">allVersionsWithName: aString newerThan: aStorePundle in: aSessionOrNil	"Answer back all versions of this class that match aString for the name, and have a timestamp newer than aStorePundle's"	| session query targetTimeStamp |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	targetTimeStamp := aStorePundle timestamp.	query := Query read: self where: [:each | each name = aString AND: (each timestamp &gt; targetTimeStamp)].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">allVersionsWithName: aString version: aBlock	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock,	or nil if there is no match.	Examples: 		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage allVersionsWithName: 'PackageCategories' version: [:version | '*47769*' match: version]"	^self allVersionsWithName: aString version: aBlock in: nil</body><body package="Store-Database Model">allVersionsWithName: aString version: aBlock in: aSessionOrNil	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock,	or nil if there is no match.	Examples: 		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage allVersionsWithName: 'PackageCategories' version: [:version | '*47769*' match: version]"	| session query result matching versionValues blessingValues |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	query retrieve: [:each | each currentBlessingLevel].	query retrieve: [:each | each version].	result := session execute: query.	matching := aBlock numArgs = 1		ifTrue: [result select: [:each | aBlock value: each last]]		ifFalse: [result select: [:each | aBlock value: each last value: each first]].	matching isEmpty ifTrue: [^nil].	versionValues := matching collect: [:each | each last].	blessingValues := matching collect: [:each | each first].	query := aBlock numArgs = 1		ifTrue: [Query read: self where: [:each | each name = aString AND: (each version in: versionValues)]]		ifFalse: [Query read: self where: [:each | each name = aString AND: (each version in: versionValues) AND: (each currentBlessingLevel in: blessingValues)]].	^session execute: query</body><body package="Store-Database Model">allVersionsWithNameLike: aWildcardString	"Answer back all versions of this class that match aWildcardString for the name, ordered by their timestamp in newest first order"	^self allVersionsWithNameLike: aWildcardString in: StoreLoginFactory currentStoreSession.</body><body package="Store-Database Model">allVersionsWithNameLike: aWildcardString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name like: aWildcardString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">allVersionsWithTrace: anInteger in: aSession	"Answer back all versions of this class that match the previous (trace) primaryKey equals anInteger, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each trace ~= nil AND: [each trace primaryKey = anInteger]].	query orderBy: [:each | each timestamp descending].	^(session execute: query) collect: [:each | self cachedItemFor: each yourSelf]</body><body package="Store-Database Model">allVersionsWithVersionNameLike: aWildcardString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each version like: aWildcardString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model">firstVersionOfPundleWithName: aName 	"This method takes advantage of the key generation schema: 	the more recent the version the higher key."	| storePundles |	storePundles := self allVersionsWithName: aName.	^storePundles isEmpty		ifTrue: [nil]		ifFalse: [storePundles last]</body><body package="Store-Database Model">getNamesAndItemCountIn: aSession usingPundleFilter: aPundleFilter	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self.	query retrieve: #name.	aPundleFilter applyFilterToQuery: query.	query retrieve: [:ea | ea name count].	query groupBy: #name.	query orderBy: #name.	^session execute: query</body><body package="Store-Database Model">getNamesAndMaxTimestampsIn: aSession	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self.	query retrieve: #name.	query retrieve: [:ea | ea timestamp max].	query groupBy: #name.	query orderBy: #name.	^session execute: query</body><body package="Store-Database Model">getNamesAndTimestampsForKeys: keys in: aSession	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each| each primaryKey in: keys ].	query retrieve: #name.	query retrieve: #timestamp.	query orderBy: #name.	^session execute: query</body><body package="Store-Database Model">getTraceDataFor: anInteger in: aSessionOrNil	| session query result |	(anInteger isNil or: [anInteger isZero]) ifTrue: [^nil].	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each primaryKey = anInteger].	query retrieve: #timestamp.	query retrieve: #version.	query retrieve: #username.	result := (session execute: query).	^(result isNil or: [result isEmpty])		ifTrue: [nil]		ifFalse: [(Dictionary new)					at: #timestamp put: result first;					at: #version put: (result at: 2);					at: #username put: result last;					yourself]</body><body package="Store-Database Model">latestOf: aString version: aBlock	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock.	Examples: 		StoreBundle latestOf: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage latestOf: 'PackageCategories' version: [:version | '*47769*' match: version]"	^self latestOf: aString version: aBlock in: nil</body><body package="Store-Database Model">latestOf: aString version: aBlock in: aSessionOrNil	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock,	or nil if there is no match.	Examples: 		StoreBundle latestOf: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage latestOf: 'PackageCategories' version: [:version | '*47769*' match: version]"	| session query result matching targetValues |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	query retrieve: [:each | each currentBlessingLevel].	query retrieve: [:each | each version].	result := session execute: query.	matching := aBlock numArgs = 1		ifTrue: [result select: [:each | aBlock value: each last]]		ifFalse: [result select: [:each | aBlock value: each last value: each first]].	matching isEmpty ifTrue: [^nil].	targetValues := matching first.	query := aBlock numArgs = 1		ifTrue: [Query readOneOf: self where: [:each | each name = aString AND: (each version = targetValues last)]]		ifFalse: [Query readOneOf: self where: [:each | each name = aString AND: (each version = targetValues last) AND: (each currentBlessingLevel = targetValues first)]].	^session execute: query</body><body package="Store-Database Model">newerVersionsOf: aStorePundle	^self newerVersionsOf: aStorePundle in: nil</body><body package="Store-Database Model">newerVersionsOf: aStorePundle in: aSession	| session query key |	session := aSession.	session ifNil: [session := aStorePundle session ifNil: [StoreLoginFactory currentStoreSession]].	key := aStorePundle isImageModel ifTrue: [aStorePundle dbTrace] ifFalse: [aStorePundle primaryKey].	query := Query read: self where: [:each | each trace primaryKey = key].	query alsoFetch: [:each | each trace].	^session execute: query.</body><body package="Store-Database Model">newestVersionWithName: aString	| session query |	session := StoreLoginFactory currentStoreSession.	query := Query readOneOf: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	^session execute: query.</body><body package="Store-Database Model">newestVersionsInSession: aSession	| session namesAndTimestamps newestDict |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	namesAndTimestamps := self getNamesAndMaxTimestampsIn: session.	newestDict := Dictionary new.	namesAndTimestamps		do: [:eaArray | newestDict at: (eaArray first) put: (eaArray last)].	^newestDict</body><body package="Store-Database Model">pundleWithName: aName hasVersion: aString	^self pundleWithName: aName hasVersion: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">pundleWithName: aName hasVersion: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each name = aName AND: (each version = aString)].	query retrieve: #name.	^(session execute: query) notNil</body><body package="Store-Database Model">pundleWithName: aNameString version: aVersionString	^self pundleWithName: aNameString version: aVersionString in: nil</body><body package="Store-Database Model">pundleWithName: aNameString version: aVersionString in: aSession		| session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	^session readOneOf: self where: [:each | each name = aNameString &amp; (each version = aVersionString)]</body><body package="Store-Database Model">sharesProperty: aStoreProperty in: aSession	"Answer back if  versions of this class that share the passed in Property"	| session query primaryKey |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	primaryKey := aStoreProperty primaryKey.	query := Query count: self where: [:each | each propertiesRecordDictionary primaryKey =  primaryKey].	^(session execute: query) ~= 1</body><body package="Store-Database Model">traceVersionFor: anInteger	^self traceVersionFor: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">traceVersionFor: anInteger in: aSessionOrNil	| session query |	(anInteger isNil or: [anInteger isZero]) ifTrue: [^nil].	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each primaryKey = anInteger].	query retrieve: #version.	^(session execute: query).</body><body package="Store-Database Model">traceVersionStringFor: anInteger	^self traceVersionStringFor: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">traceVersionStringFor: anInteger in: aSessionOrNil	| session query result |	(anInteger isNil or: [anInteger isZero]) ifTrue: [^nil].	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each primaryKey = anInteger].	query retrieve: #version.	query retrieve: #username.	result := (session execute: query).	^(result isNil or: [result isEmpty])		ifTrue: [nil]		ifFalse: ['(', result first, ',', result last, ')']</body><body package="Store-Database Model">updateTimestampsFor: aCollection in: aSession	"This is necessary since we don't keep timestamps when we load pundles into the image.  If we added dbTimestamp	to DatabaseConnectionInformation and maintained it, this query would be redundant in most cases."	| keys session namesAndTimestamps |	aCollection isEmpty ifTrue: [^self].	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	keys := aCollection inject: OrderedCollection new 		into: [:collection :each| (each dbTrace notNil and: [each dbTimestamp isNil]) 			ifTrue: [collection add: each dbTrace]. collection].	namesAndTimestamps := self getNamesAndTimestampsForKeys: keys in: session.	namesAndTimestamps do: [:eachArray| | pundle |	 	pundle := aCollection at: (eachArray first) ifAbsent: [nil].		pundle notNil ifTrue: [pundle dbTimestamp: (eachArray last)]].</body><body package="Store-Database Model">withName: aNameString version: aVersionString		^self withName: aNameString version: aVersionString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">withName: aNameString version: aVersionString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aNameString AND: (each version = aVersionString)].	query orderBy: [:each | each timestamp descending].	^session execute: query</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>load utilities</category><body package="Store-Database Model">chooseReloadActionFor: pundleNameString	^Dialog		choose: (#_1s2sWasLoadedOrPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt; was loaded or published.'					expandMacrosWith: self instanceBehavior name					with: pundleNameString)		labels: (Array				with: #ReloadFromTheDatabase &lt;&lt; #store &gt;&gt; 'Reload From the Database'				with: #SetTheParent &lt;&lt; #store &gt;&gt; 'Set the Parent'				with: #DoNothing &lt;&lt; #store &gt;&gt; 'Do Nothing')		values: #(#reload #reset #cancel)		default: #reset</body><body package="Store-Database Model">loadPundleId: anInteger	"Loads a pundle by key. Note: must be sent to a particular subclass - not the abstract Pundle class."		(self withPrimaryKey: anInteger) loadSource</body><body package="Store-Database Model">loadWithName: aNameString version: aVersionString		^self loadWithName: aNameString version: aVersionString in: nil</body><body package="Store-Database Model">loadWithName: aNameString version: aVersionString in: aSession		| storePundle session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	storePundle := self pundleWithName: aNameString version: aVersionString in: session.	storePundle ifNotNil: [Parcel withFileCachesDo: [storePundle quietlyLoadSource]].	aSession ifNil: [Undeclared purgeUnusedBindings].	^storePundle</body><body package="Store-Database Model">loadWithName: aNameString version: aVersionString with: aCompilationManager in: aSession		| storePundle session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	storePundle := self pundleWithName: aNameString version: aVersionString in: session.	storePundle ifNotNil: [Parcel withFileCachesDo: [storePundle loadSourceWith: aCompilationManager]].	aSession ifNil: [Undeclared purgeUnusedBindings].	^storePundle</body><body package="Store-Database Model">reloadPundle: pundleNameString id: anInteger fromDatabase: dbIdentifierString	"Loads a pundle based on the primary key."	"Note: must be sent to a subclass, not the abstract Pundle class."	| choice |	(DbRegistry databaseIdentifier = dbIdentifierString		or: [DbRegistry databaseIdentifier asSymbol printString = dbIdentifierString])			ifFalse: 				[^Dialog					warn: (#CannotLoad1sFrom2sNotLoggedOn &lt;&lt; #store							&gt;&gt; 'Cannot load &lt;1s&gt; from &lt;2s&gt; - not logged on'								expandMacrosWith: pundleNameString								with: dbIdentifierString printString)].	choice := self chooseReloadActionFor: pundleNameString.	choice == #cancel ifTrue: [^self].	choice == #reload		ifTrue: [self loadPundleId: anInteger]		ifFalse: [self resetPundleId: anInteger]</body><body package="Store-Database Model">reloadPundle: aSymbol named: aString id: anInteger fromDatabase: aDatabaseIDSymbol	(self subclassFromType: aSymbol)		reloadPundle: aString 		id: anInteger 		fromDatabase: aDatabaseIDSymbol.</body><body package="Store-Database Model">resetPundleId: anInteger	"Resets the image pundle to match the database pundle indetified by key.	Note: must be sent to a particular subclass - not the abstract StorePundle class."		| storePundle pundleModel |	(storePundle := self withPrimaryKey: anInteger) ifNil:		[^Dialog warn: (#DatabaseVersionDoesNotExist &lt;&lt; #store &gt;&gt; 'Database does not have a version with primaryKey &lt;1p&gt;' expandMacrosWith: anInteger)].	(pundleModel := storePundle getImagePundle) ifNil:		[^(Dialog confirm:			(#ImageVersionOf1sAdFromTheDatabase &lt;&lt; #store &gt;&gt; 'Image version of &lt;1s&gt; does not exist.&lt;ntt&gt;Load from the database?' expandMacrosWith: storePundle name))				ifTrue: [self loadPundleId: anInteger]].	pundleModel		dbTrace: storePundle primaryKey;		markNotModified</body><body package="Store-Database Model">subclassFromType: aSymbol	"Answer the subclass that is represented by a type symbol."		^aSymbol == #package 		ifTrue: [StorePackage] 		ifFalse: [StoreBundle]</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>testing</category><body package="Store-Database Model">isBundle	^false.</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>database-utilities</category><body package="Store-Database Model">allNonBinaryNamesIn: aSessionOrNil	^self allNamesIn: aSessionOrNil</body><body package="StoreForGlorpVWUI">hasVersionNamed: aString	"Answer a boolean if there is any version of myself that has the name aString"	^self hasVersionNamed: aString in: nil</body><body package="StoreForGlorpVWUI">hasVersionNamed: aString in: aSessionOrNil	"Answer a boolean if there is any version of myself that has the name aString"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query count: self where: [:each | each name = aString].	^(session execute: query) &gt; 0</body><body package="Store-Database Model">initializeCache	cache := WeakDictionary new.</body><body package="StoreForGlorpVWUI">rename	| names session oldName targetWindow newName |	session := StoreLoginFactory currentStoreSession.	targetWindow := VisualLauncher raiseSingleInstance.	[names := self allNonBinaryNamesIn: session] withStoreFeedbackOn: targetWindow.	names := names asSortedCollection asOrderedCollection.	names isEmpty ifTrue: 		[^Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	oldName := Dialog 		choose: ((#Choose1s &lt;&lt; #store &gt;&gt; 'Choose &lt;1s&gt;...') expandMacrosWith: self class name asClassNameOnly)		fromList: names		values: names		lines: 15		cancel: [^nil]		for: nil.	[newName := SmalltalkWorkbench requestNewPackageName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(names includes: newName)		ifTrue:			[Dialog warn: (#_1sAlreadyExists &lt;&lt; #store &gt;&gt; '&lt;1s&gt; already exists.' expandMacrosWith: newName).			false]		ifFalse: [true]] whileFalse.	[(Renaming for: self from: oldName to: newName) announce.	self rename: oldName to: newName inSession: session] withStoreFeedbackOn: targetWindow.</body><body package="Store-Database Model">rename: anOldName to: aNewName inSession: aSession	"This method is dangerous. It does not check if aNewName already exists. Also, you MUST have aSession.	Also, after execution, we get rid of the cachedNames for my class "	| targets |	aSession ifNil: [^self].	(targets := self allVersionsWithName: anOldName in: aSession) isEmpty ifTrue: 		[^Dialog warn: #NoPublishedVersions &lt;&lt; #store &gt;&gt; 'No published versions'].	aSession inUnitOfWorkDo:		[targets do:			[:each |			aSession register: each.			each name: aNewName]].	DbRegistry cachedNames removeKey: self ifAbsent: [nil].	DbRegistry highestPrimaryKeyChecked: nil</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString	"Produce a dialogue that answers a store pundle object or nil."		^self selectStoreVersionOf: aString in: nil</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString in: aSession	"Produce a dialogue that answers a store pundle object or nil."		^self selectStoreVersionOf: aString in: aSession warnIfNone: true</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString in: aSession warnIfNone: aBoolean	"Produce a dialogue that answers a store pundle object or nil."		| list session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	list := self allVersionsWithName: aString in: session.	list isEmpty ifTrue:		[aBoolean ifTrue: [Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions') asString].		^nil].	list size == 1 ifTrue: [^list first].	^Dialog		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list collect: [:each | each displayString , ' ' , each blessingLevelString])		values: list		lines: 10		cancel: [^nil]		for: nil</body><body package="StoreForGlorpVWUI">selectStoreVersionOf: aString warnIfNone: aBoolean	"Produce a dialogue that answers a store pundle object or nil."		^self selectStoreVersionOf: aString in: nil warnIfNone: aBoolean</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>private</category><body package="Store-Database Model">allVersionsInitiallyNamed: aString in: aSession notIn: aCollection olderThan: aTimeStamp	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"		| session query sameNamed otherNames oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: each timestamp &lt;= aTimeStamp].	query orderBy: [:each | each timestamp descending].	sameNamed := session execute: query.	sameNamed isEmpty ifTrue: [^sameNamed].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed		inject: OrderedCollection new		into:			[:sum :each | 			(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not and: [(aCollection includes: each parent name) not]]])				ifTrue: [sum add: each parent name].			sum].	^otherNames copy		inject: sameNamed copy		into:			[:sum :each | 			sum , (self allVersionsInitiallyNamed: each in: aSession notIn: aCollection , otherNames olderThan: oldestTimestamp)]</body><body package="Store-Database Model">allVersionsInitiallyNamed: aString in: aSession notIn: aCollection olderThan: aTimeStamp usingPundleFilter: aPundleFilter	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order	with optional range of blessing(s) and date(s)"		| session query sameNamed otherNames oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each name = aString AND: each timestamp &lt;= aTimeStamp].	aPundleFilter applyFilterToQuery: query.	query orderBy: [:each | each timestamp descending].	sameNamed := session execute: query.	sameNamed isEmpty ifTrue: [^sameNamed].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed		inject: OrderedCollection new		into:			[:sum :each | 			(each parent notNil and: 				[each parent name ~= aString and: 				[(sum includes: each parent name) not and: 				[(aCollection includes: each parent name) not]]])					ifTrue: [sum add: each parent name].			sum].	^otherNames copy		inject: sameNamed copy		into:			[:sum :each | 			sum , (self 				allVersionsInitiallyNamed: each 				in: aSession 				notIn: aCollection , otherNames 				olderThan: oldestTimestamp 				usingPundleFilter: aPundleFilter)]</body><body package="Store-Database Model">cache	cache isNil ifTrue: [cache := WeakDictionary new].	^cache</body><body package="Store-Database Model">cachedItemFor: aStorePundle	| cachedPundle |	aStorePundle ifNil: [^aStorePundle].	cachedPundle := self cache at: aStorePundle primaryKey ifAbsent: [nil].	^(cachedPundle notNil and: [cachedPundle class == self])		ifTrue: [cachedPundle]		ifFalse: 			[self cache at: aStorePundle primaryKey put: aStorePundle.			aStorePundle].</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>instance creation</category><body package="Store-Database Model">newNamed: aString	| instance |	instance := self new.	instance name: aString.	^instance</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>class initialization</category><body package="Store-Database Model">componentNotFoundSignal	^ComponentNotFoundSignal</body><body package="Store-Database Model">initialize	"self initialize"	ComponentNotFoundSignal := Object informationSignal newSignal 		notifierString: 'Component not found';		nameClass: self message: #componentNotFoundSignal.</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>constants</category><body package="Store-Publishing Support">publishSpecificationClass	^PublishSpecification</body><body package="Store-Publishing Support">publishSpecificationListClass	^PublishSpecificationList</body><body package="Store-Database Model">typeStringForBlessing	self subclassResponsibility</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>analysis</category><body package="Atomic Compiling and Loading">addClass: aStoreClass	self shadowOrganizer addClass: (aStoreClass asShadowedObjectIn: pundle)</body><body package="Atomic Compiling and Loading">addMethod: aStoreMethod using: anAtomicAnalysisLoader	| shadowedMethod |	shadowedMethod := (aStoreMethod asShadowedObjectIn: pundle).	shadowedMethod ctype		ifTrue: [self shadowOrganizer addCTypeMethod: shadowedMethod]		ifFalse: [			shadowedMethod isExternalMethod				ifTrue: [self shadowOrganizer addExternalMethod: shadowedMethod]				ifFalse: [					(self isCOtherMethod: shadowedMethod using: anAtomicAnalysisLoader)						ifTrue: [self shadowOrganizer addCOtherMethod: shadowedMethod]						ifFalse: [							shadowedMethod extension								ifTrue: [self shadowOrganizer addExtensionMethod: shadowedMethod]								ifFalse: [self shadowOrganizer addDefinedClassMethod: shadowedMethod]]]]</body><body package="Atomic Compiling and Loading">addNamespace: aStoreNamespace	self shadowOrganizer addNamespace: (aStoreNamespace asShadowedObjectIn: pundle)</body><body package="Atomic Compiling and Loading">addShared: aStoreSharedVariable	self shadowOrganizer addSharedVariable: (aStoreSharedVariable asShadowedObjectIn: pundle)</body><body package="Atomic Compiling and Loading">analyzeUsing: anAtomicAnalysisLoader	(Analyzing for: pundle) started.	anAtomicAnalysisLoader lastPundleWorkedOn: pundle.	(pundle binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]) ifTrue: 		[EarlyInstallNotice raiseSignal.		pundle runPreLoad.		(Analyzing for: pundle) finished.		pundle binLoadWithin: self owningComponent using: nil.		^installed := completedAnalysis := true].	self gatherDefinitionsInto: anAtomicAnalysisLoader.	completedAnalysis := true.	(pundle propertyAt: #postLoadBlock) ifNotNil: [needsEarlyInstall := true].	(Analyzing for: pundle) finished.	(((pundle propertyAt: #installBeforeContinuing ifAbsent: [self]) == self) not  or: [needsEarlyInstall]) ifTrue: 		[EarlyInstallNotice raiseSignal].</body><body package="Atomic Compiling and Loading">copyLocalInstallTo: anAtomicAnalysisLoader	anAtomicAnalysisLoader shadowOrganizer addPackageShadowsFrom: self shadowOrganizer</body><body package="Atomic Compiling and Loading">gatherAndAnalyzeClass: aStoreClass using: anAtomicAnalysisLoader	"The analysis loader holds a world of namespaces and owners that we are going to install in the world.	We look and see, if there is a definition in the real world, OR in the analysis world that we are about to redefine.	If so, that means we're about to cause an early install. None the less, we have to continue gathering things"	(hasInstalledEarly not and: [anAtomicAnalysisLoader redefinesClass: aStoreClass]) ifTrue: 		[EarlyInstallNotice raiseSignal.		needsPackageRecompile := hasInstalledEarly := true].	needsEarlyInstall ifFalse:		[(self classCausesEarlyInstall: aStoreClass using: anAtomicAnalysisLoader) ifTrue: 			[needsPackageRecompile := needsEarlyInstall := true]].	self addClass: aStoreClass.</body><body package="Atomic Compiling and Loading">gatherAndAnalyzeMethod: aStoreMethod using: anAtomicAnalysisLoader	"We set needsEarlyInstall to true if there are scanner/compiler/externalInterface methods"	anAtomicAnalysisLoader dllccLoaded ifFalse:		[(self needsDLLCC: aStoreMethod) ifTrue: [NoDLLCCNotification raiseRequestWith: self pundle]].	needsEarlyInstall ifFalse:		[(self methodCausesEarlyInstall: aStoreMethod using: anAtomicAnalysisLoader) ifTrue: [needsEarlyInstall := true]].	self addMethod: aStoreMethod using: anAtomicAnalysisLoader</body><body package="Atomic Compiling and Loading">gatherAndAnalyzeNamespace: aStoreNamespace using: anAtomicAnalysisLoader	"The analysis loader holds a world of namespaces and owners that we are going to install in the world.	We look and see, if there is a definition in the real world, OR in the analysis world that we are about to redefine.	If so, that means we're about to cause an early install. None the less, we have to continue gathering things"	(hasInstalledEarly not and: [anAtomicAnalysisLoader redefinesNamespace: aStoreNamespace]) ifTrue:		[EarlyInstallNotice raiseSignal.		hasInstalledEarly := true].	self addNamespace: aStoreNamespace.</body><body package="Atomic Compiling and Loading">gatherAndAnalyzeShared: aStoreSharedVariable using: anAtomicAnalysisLoader	self addShared: aStoreSharedVariable.</body><body package="Atomic Compiling and Loading">gatherDefinitionsInto: anAtomicAnalysisLoader	pundle getImagePundle isNil		ifTrue: [self gatherNewDefinitionsInto: anAtomicAnalysisLoader]		ifFalse: [self gatherDeltaDefinitionsInto: anAtomicAnalysisLoader].	self copyLocalInstallTo: anAtomicAnalysisLoader</body><body package="Atomic Compiling and Loading">gatherDeltaDefinitionsInto: anAtomicAnalysisLoader	(pundle primaryKey = (pundleModel := pundle getImagePundle) dbTrace and: [pundleModel hasBeenModified not]) ifTrue: [^self].	packageComparitor := PackageComparitor differencesBetween: pundle and: pundleModel.	packageComparitor hasDifferences ifFalse: [^self].	packageComparitor mainPackageNamespaces do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	packageComparitor mainPackageClasses do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	packageComparitor mainPackageShareds do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	packageComparitor mainPackageMethods do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	self willClassRemovalAffectAnotherPackage ifTrue: [needsEarlyInstall := true].</body><body package="Atomic Compiling and Loading">gatherNewDefinitionsInto: anAtomicAnalysisLoader		pundle namespaces do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	pundle classDefinitions do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	pundle sharedVariables do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	pundle methods do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader]</body><body package="Atomic Compiling and Loading">isCOtherMethod: aShadowedMethod using: anAtomicAnalysisLoader	| className shadowedClassObject shadowClassHierarchy result |	(aShadowedMethod ctype or: [aShadowedMethod isExternalMethod])		ifTrue: [^false].	className := aShadowedMethod className.	shadowClassHierarchy := OrderedCollection new.	result := nil.	[result isNil]		whileTrue: [ | imageClass |			imageClass := Glorp.Dialect smalltalkAt: className ifAbsent: [nil]. 			imageClass isNil				ifTrue: [					shadowedClassObject := self shadowOrganizer classNamed: className ifAbsent: [nil].					shadowedClassObject ifNil:						[shadowedClassObject := anAtomicAnalysisLoader classNamed: className ifAbsent: [result := false]].					(shadowedClassObject notNil and: [shadowedClassObject isExternalInterface isNil])						ifTrue: [shadowClassHierarchy addLast: shadowedClassObject.							className := shadowedClassObject superclassName]						ifFalse: [result := shadowedClassObject isExternalInterface]]				ifFalse: [result := imageClass instanceBehavior includesBehavior: ExternalInterface]].		shadowClassHierarchy do: [:eachShadowClass| eachShadowClass isExternalInterface: result ].		^result and: [(aShadowedMethod definitionString findString: '&lt;C:' startingAt: 1) &gt; 0]</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>testing</category><body package="Atomic Compiling and Loading">hasSomethingAnalyzed	^completedAnalysis</body><body package="Atomic Compiling and Loading">isPackage	^true</body><body package="Atomic Compiling and Loading">methodCausesEarlyInstall: aStoreMethod using: anAtomicAnalysisLoader	"If the class is in the image, we can simply ask if it is of one of the gotcha classes or ExternalInterface"	| methodClassName shadowedClassObject |	aStoreMethod correspondingImageClass ifNotNil: [:imageClass |		^(imageClass instanceBehavior includesBehavior: Scanner) or: 			[(imageClass instanceBehavior includesBehavior: SmalltalkCompiler) or: 			[imageClass instanceBehavior class = ExternalInterface]]].	"If we get here, the class is not in the image, so we ask the analysis world if the class's superclass is a gotcha class"	methodClassName := aStoreMethod className.		shadowedClassObject := self shadowOrganizer classNamed: methodClassName ifAbsent: [nil].	shadowedClassObject ifNil:		[shadowedClassObject := anAtomicAnalysisLoader classNamed: methodClassName ifAbsent: [^false]].	^anAtomicAnalysisLoader isEarlyInstallRequiredByClassNamed: shadowedClassObject superclassName</body><body package="Atomic Compiling and Loading">willClassRemovalAffectAnotherPackage	"Are there classes NOT in my package that are subclasses of any class that I need to remove from myself"		^packageComparitor sortedClassesToRemoveAfterLoad anySatisfy:		[:each | 		each correspondingImageClass notNil and: 			[each correspondingImageClass subclasses anySatisfy: 				[:eachSubclass | (Registry packageForClass: eachSubclass) name ~= pundleModel name]]]</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">shadowExtensionMethods	^self shadowOrganizer extensionMethods</body><body package="Atomic Compiling and Loading">shadowOrganizer	^shadowOrganizer</body><body package="Atomic Compiling and Loading">shadowOrganizer: anObject	shadowOrganizer := anObject</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>private</category><body package="Atomic Compiling and Loading">classCausesEarlyInstall: aStoreClass using: anAtomicAnalysisLoader	"If the class is in the image then this must be an override, 	none the less, we can simply ask if it is of one of the gotcha classes"	aStoreClass correspondingImageClass ifNotNil: [:value |		^(value instanceBehavior includesBehavior: Scanner) or: 			[value instanceBehavior includesBehavior: SmalltalkCompiler]].	^anAtomicAnalysisLoader isEarlyInstallRequiredByClassNamed: aStoreClass superclassName</body><body package="Atomic Compiling and Loading">needsDLLCC: aStoreMethod	| result index |	result := [Scanner new scanTokens: aStoreMethod definitionString]		on: Error		do: [:exception | exception return: #()].	index := result indexOf: #C:.	^index &lt; 2		ifTrue: [false]		ifFalse: [(result at: index - 1) = #&lt;].</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize	super initialize.	shadowOrganizer := ShadowOrganizer new.	needsEarlyInstall := false.	hasInstalledEarly := false.	needsPackageRecompile := false</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>installation</category><body package="Atomic Compiling and Loading">gatherDefinitionsToRemoveInto: aDictionary		packageComparitor ifNotNil:		[self insertRemovals: packageComparitor nameSpacesToRemoveAfterLoad ofType: #nameSpaces into: aDictionary.		self insertRemovals: packageComparitor methodsToRemoveAfterLoad ofType: #methods into: aDictionary.		self insertRemovals: packageComparitor sharedsToRemoveAfterLoad ofType: #shareds into: aDictionary.		self insertRemovals: packageComparitor sortedClassesToRemoveAfterLoad ofType: #classes into: aDictionary]</body><body package="Atomic Compiling and Loading">insertRemovals: aCollection ofType: aSymbol into: aDictionary		| deletions |	^aCollection isEmpty ifFalse:		[deletions := aDictionary at: aSymbol ifAbsentPut: [OrderedCollection new].		aCollection do: 			[:each | | assoc |			assoc := each -&gt; pundleModel.			(deletions includes: assoc) ifFalse: [deletions add: assoc]]]</body><body package="Atomic Compiling and Loading">installPackageNamespaces	| nameSpace |	pundleModel ifNil: [^self].	nameSpace := pundle propertyAt: #namespace ifAbsent: [nil].	pundleModel environment: nameSpace</body><body package="Atomic Compiling and Loading">runPostLoadUsing: anAtomicAnalysisLoader	(installed not and: [hasRunPostload not and: [completedAnalysis]]) ifTrue: 		[pundle postLoad: pundleModel.		anAtomicAnalysisLoader hasUnloadableDefinitions			ifTrue: [pundleModel reconcileWithDbVersion: pundle]			ifFalse: [pundleModel markNotModified].		hasRunPostload := true].</body><body package="Atomic Compiling and Loading">runPreLoad	(completedAnalysis and: [hasRunPreload not]) ifTrue: 		[pundle runPreLoad ifFalse: [^false].		pundleModel := [pundle createImagePundle]			on: MessageNotUnderstood			do: [:exception | exception return: pundle storeModel].		hasRunPreload := true].	^true</body><body package="Atomic Compiling and Loading">updateForPackageRecompile	needsPackageRecompile ifTrue: 		[ | sortedClasses |		sortedClasses := SystemUtils sortForLoading: pundleModel definedClasses.		sortedClasses do:			[:each | 			pundleModel recompileMethodsFor: each class.			pundleModel recompileMethodsFor: each].		self shadowOrganizer extensionMethods do:			[:eachMethod |			eachMethod mclass ifNotNil: [:value | pundleModel recompileMethodsFor: value]]]</body></methods><methods><class-id>Store.LostConnectionError class</class-id> <category>accessing</category><body package="Store-Base">description	^(#TheDatabaseConnectionIsLost &lt;&lt; #store &gt;&gt; 'The database connection is lost') asString</body></methods><methods><class-id>Store.Glorp.InvalidStorePundleError</class-id> <category>accessing</category><body package="Store-Database Model">pundle	^pundle</body><body package="Store-Database Model">pundle: aPundle	pundle := aPundle</body></methods><methods><class-id>Store.Glorp.RemovalResolution</class-id> <category>testing</category><body package="Store-Merge Management">isCommentResolver	^false</body><body package="Store-Merge Management">isRemovalResolution	^true</body></methods><methods><class-id>Store.Glorp.RemovalResolution</class-id> <category>accessing</category><body package="Store-Merge Management">base	^base</body><body package="Store-Merge Management">base: aResolver	base := aResolver</body><body package="Store-Merge Management">definitionValue	^base value</body><body package="Store-Merge Management">original	^self package</body><body package="Store-Merge Management">protocol	^''</body><body package="Store-Merge Management">value	^base</body></methods><methods><class-id>Store.Glorp.RemovalResolution</class-id> <category>comparing</category><body package="Store-Merge Management">= anObject	^self class = anObject class and:		[self base = anObject base and:		[self package = anObject package]]</body></methods><methods><class-id>Store.Glorp.RemovalResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management">fromBaseResolution: aResolver	| instance |	instance := self new.	instance base: aResolver.	^instance</body><body package="Store-Merge Management">fromBaseResolution: aResolver fromPackage: aPackage	| instance |	instance := self new.	instance base: aResolver.	instance package: aPackage.	^instance</body></methods><methods><class-id>Store.StoreProgressOverlay</class-id> <category>initialize-release</category><body package="Store-UI">addProgressView	| view |	view := StoreProgressView new.	view notifications: StoreWorkActivity notifications.	self add: view</body><body package="Store-UI">initializeLayoutAlgorithm	self childFramingBlock: 			[:rect :child :index |			index = 1				ifTrue: [rect]				ifFalse: [rect topLeft + (20 @ 0) corner: rect topRight + (-20 @ 50)]]</body><body package="Store-UI">restoreOriginal	| window regularView |	self progressView release.	window := container.	window == nil ifTrue: [		"This situation arises when external events have caused the window		 to rebuild its widgets, leaving me out of the rebuild."		^self	].	regularView := self regularView.	regularView propertyAt: #constraints put: self originalViewConstraints.	container component: regularView.	regularView resetConstraintValues.	window damageRepairPolicy: originalDisplayPolicy.	window component invalidate.	window displayPendingInvalidation</body><body package="Store-UI">subsume: aWindow	| regularView |	originalDisplayPolicy := aWindow damageRepairPolicy.	aWindow damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	regularView := aWindow component.	aWindow component: self.	self originalViewConstraints: (regularView	propertyAt: #constraints).	regularView propertyAt: #constraints put: nil.	self add: regularView.	self addProgressView.	self invalidate.	aWindow displayPendingInvalidation</body></methods><methods><class-id>Store.StoreProgressOverlay</class-id> <category>private</category><body package="Store-UI">backdrop	"Return the regularView rendered on an Image and then darkened. If we've done it once already and the size of the window hasn't changed, just use the same one as last time."	| gc tempSurface |	(background notNil and: [background extent = self bounds extent])		ifTrue: [^background].	tempSurface := Pixmap extent: self bounds extent.	gc := tempSurface graphicsContext.	self regularView displayOn: gc.	background := tempSurface asImage.	self washOutBackdropImage.	^background</body><body package="Store-UI">dropdownGradient	| image pgc color pm f |	dropdownGradient ifNotNil: [^dropdownGradient].	pm := Pixmap extent: 1 @ self progressView frame height.	pgc := pm graphicsContext.	pgc		paint: (ColorValue brightness: 0.9);		displayRectangle: pm bounds.	image := pm asImage.	0 to: image height - 1		do: 			[:y |			color := image valueAtPoint: 0 @ y.			f := y / image height.			f &lt; (1 / 3)				ifTrue: 					[color := ColorValue								hue: color hue								saturation: color saturation								brightness: (1 - color brightness) * (1 - (f * 3)) + color brightness].			f &gt; (2 / 3)				ifTrue: 					[color := ColorValue								hue: color hue								saturation: color saturation								brightness: color brightness										- ((color brightness - (color brightness * 3 / 4)) * ((f - (2 / 3)) * 3))].			image				atX: 0				y: y				put: (image palette indexOfPaintNearest: color)].	^dropdownGradient := image asPattern</body><body package="Store-UI">dropdownRectangle	"Return the rectangle to show as the dropdown rectangle."	| box |	box := self progressView frame.	^box left @ 0 corner: box corner</body><body package="Store-UI">progressView	^self children last</body><body package="Store-UI">regularView	^self children first</body><body package="Store-UI">washOutBackdropImage	"In most cases, we have a FixedPalette of high depth and can do this much faster than using the palette, so take advantage of just having the bytes when we can."	| bits currentColor |	(background bitsPerPixel &gt;= 24		and: [background palette isKindOf: FixedPalette])			ifTrue: 				[bits := background bitsInstVar.				1 to: bits size do: [:n | bits at: n put: (bits at: n) * 6 // 10]]			ifFalse: 				[0 to: background width - 1					do: 						[:x |						0 to: background height - 1							do: 								[:y |								currentColor := background valueAtPoint: x @ y.								background									atX: x									y: y									put: (background palette indexOfPaintNearest: (ColorValue													red: currentColor red * 0.6													green: currentColor green * 0.6													blue: currentColor blue * 0.6))]]]</body></methods><methods><class-id>Store.StoreProgressOverlay</class-id> <category>displaying</category><body package="Store-UI">displayChild: aChild on: aGC	aChild = self regularView		ifTrue: 			["Don't bother displaying the washed out image if we're just going to overwrite that with the dropdown panel (which is true 99% of the time as the health process spinner fires updates."			(self dropdownRectangle contains: aGC clippingBounds)				ifFalse: [self backdrop displayOn: aGC]]		ifFalse: 			[self displayDropdownOn: aGC.			super displayChild: aChild on: aGC]</body><body package="Store-UI">displayDropdownOn: aGC	| box originalPaint |	box := self dropdownRectangle.	(aGC clippingBounds intersects: box) ifFalse: [^self].	originalPaint := aGC paint.	aGC paint: self dropdownGradient.	aGC displayRectangle: (box topLeft corner: box bottomRight).	"aGC displayRectangle: (box leftCenter + (box height half @ 0)				corner: box bottomRight - (box height half @ 0)).	aGC		displayWedgeBoundedBy: (box topLeft extent: box height asPoint)		startAngle: 90		sweepAngle: 360.	aGC		displayWedgeBoundedBy: (box topRight - (box height @ 0)				corner: box bottomRight)		startAngle: 0		sweepAngle: 360."	aGC paint: originalPaint</body></methods><methods><class-id>Store.StoreProgressOverlay</class-id> <category>temporary-constraints</category><body package="Store-UI">originalViewConstraints	^self propertyAt: #originalConstraints</body><body package="Store-UI">originalViewConstraints: aVisualConstraints	self propertyAt: #originalConstraints ifAbsentPut: [aVisualConstraints]</body></methods><methods><class-id>Store.StoreProgressOverlay class</class-id> <category>utility</category><body package="Store-UI">subsume: aWindowOrNil while: aBlock	^self subsumeAll: (Array with: aWindowOrNil) while: aBlock</body><body package="Store-UI">subsumeAll: aWindowCollection while: aBlock	"Only a ScheduledWindow should have an overlay."	| overlays windowsToSubsume |	windowsToSubsume := aWindowCollection				select: [:each | each notNil and: [each isOpen and: [each hasStoreProgressOverlay not]]].	^	[overlays := windowsToSubsume collect: 					[:each |					(self new)						subsume: each;						yourself].	aBlock value]			ensure: [overlays do: #restoreOriginal]</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>accessing</category><body package="Store-Difference Management">classListName	^self selectorListName</body><body package="Store-Difference Management">differenceName	^self selectorListName</body><body package="Store-Difference Management">mainDefinition	^mainObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management">mainPackage: aPackage definition: aString	| definition |	definition := aString ifNotNil: [aString isEmpty ifTrue: [nil] ifFalse: [aString]].	self mainPackage: aPackage object: definition</body><body package="Store-Difference Management">mainProtocol	^''</body><body package="Store-Difference Management">otherDefinition	^otherObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management">otherPackage: aPackage definition: aString	| definition |	definition := aString ifNotNil: [aString isEmpty ifTrue: [nil] ifFalse: [aString]].	self otherPackage: aPackage object: definition</body><body package="Store-Difference Management">otherProtocol	^''</body><body package="Store-Difference Management">resolutionClass	^ClassChangeResolver</body><body package="Store-Difference Management">selectorListIcon	^GeneralIcons gear</body><body package="Store-Difference Management">selectorListName	^(#BracketClassDefinition &lt;&lt; #store &gt;&gt; '[Class Definition]') asString</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>loading</category><body package="Store-Difference Management">loadMainDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: mainPackage storeModel		while: [aStoreClassOrNamepace classDefinition loadSource].</body><body package="Store-Difference Management">loadOtherDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: [aStoreClassOrNamepace classDefinition loadSource].</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>testing</category><body package="Store-Difference Management">isMeta	"Definition is always regarded a property of a class, not a metaclass.	A concrete use case is in ComparePackages where we don't want to see definition diffs in metaclass view."	^false</body><body package="Store-Difference Management">isNotMeta	"should be removed (equal to super implementor)"	^self isMeta not</body><body package="Store-Difference Management">isShownInMethodList	^true</body><body package="Store-Difference Management">isStandin	^true</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	| targetObject |	targetObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream saveClassSource: targetObject</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	| targetObject |	targetObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream saveClassSource: targetObject</body></methods><methods><class-id>Store.Glorp.MergeInformation</class-id> <category>accessing</category><body package="Store-Merge Management">addBlessingComment: aString	blessingComment isNil		ifTrue: [self blessingComment: aString]		ifFalse: [self blessingComment: self blessingComment , '&lt;n&gt;' expandMacros , aString]</body><body package="Store-Merge Management">addIntegratedVersion: aString	integratedVersions add: aString</body><body package="Store-Merge Management">blessingComment	^blessingComment</body><body package="Store-Merge Management">blessingComment: anObject	blessingComment := anObject</body><body package="Store-Merge Management">blessingLevel	^blessingLevel</body><body package="Store-Merge Management">blessingLevel: anObject	blessingLevel := anObject</body><body package="Store-Merge Management">integratedVersions	^integratedVersions</body></methods><methods><class-id>Store.Glorp.MergeInformation</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	integratedVersions := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.MergeInformation class</class-id> <category>instance creation</category><body package="Store-Merge Management">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>accessing</category><body package="Store-Database Model">absoluteName	^self longName.</body><body package="Store-Database Model">absoluteSymbol	^self longName asSymbol.</body><body package="Store-Database Model">allInstVarNames	^#().</body><body package="Store-Database Model">allSubclasses	^#()</body><body package="StoreForGlorpVWUI">allSubclassesDo: aBlock	"I Do Nothing"	^self</body><body package="Store-Database Model">allSuperclasses	^Array with: Object.</body><body package="StoreForGlorpVWUI">binding	^self</body><body package="StoreForGlorpVWUI">bindingOrNil	^self</body><body package="Store-Database Model">browserIcon	^nil.</body><body package="Store-Database Model">classDefinition	self subclassResponsibility.</body><body package="Store-Database Model">classNameWithMeta	^self absoluteName</body><body package="Store-Database Model">comment	| definition |	definition := self classDefinition.	^definition isNil ifTrue: [(#CommentNotVisible &lt;&lt; #store &gt;&gt; 'Comment not visible') asString] ifFalse: [definition comment].</body><body package="Store-Database Model">compiledMethodAt: aSelector	^self compiledMethodAt: aSelector ifAbsent: [nil]</body><body package="Store-Database Model">compiledMethodAt: aSelector ifAbsent: aBlock	| selectorString |	aSelector ifNil: [^aBlock value].	selectorString := aSelector asString.	^self instanceMethods detect: [:each | each name = selectorString]		ifNone: aBlock</body><body package="Store-Database Model">compilerClass	"Answer a compiler class appropriate for source methods of this class."	^Compiler</body><body package="Store-Database Model">correspondingImageClass	"Return the image class that corresponds to our name. Note that they may not have the same information"	^(Dialect smalltalkAt: self longName ifAbsent: [nil])</body><body package="Store-Database Model">definition	^self definitionString.</body><body package="Store-Database Model">definitionObject	^self classDefinition</body><body package="Store-Database Model">definitionString	^self classDefinition isNil ifTrue: [''] ifFalse: [self classDefinition definitionString].</body><body package="Store-Database Model">editionStampFrom: aPundle	^aPundle version.</body><body package="Store-Database Model">fullName	^self longName.</body><body package="Store-Database Model">instVarNames	| def |	def := self classDefinition.	def isNil ifTrue: [^#()].	^def instVarNames</body><body package="Store-Database Model">instanceMethods	^self subclassResponsibility.</body><body package="Store-Database Model">longName	^self subclassResponsibility.</body><body package="Store-Database Model">mainClass	^self</body><body package="StoreForGlorpVWUI">organization	organization isNil ifTrue: [organization := ClassOrganizer new.		self instanceMethods do: [:each | organization classify: each selector under: each protocol asSymbol]].	^organization.</body><body package="Store-Database Model">parserClass	^self compilerClass preferredParserClass</body><body package="Store-Database Model">protocols	^(self instanceMethods collect: [:each |  each protocol]) asSet.</body><body package="StoreForGlorpVWUI">selectorsAndMethodsDo: aBlock	self instanceMethods do: [:each | aBlock value: each selector value: each]</body><body package="StoreForGlorpVWUI">simpleName	^self name</body><body package="Store-Database Model">simpleNameWithMeta	^self name</body><body package="Store-Database Model">subclasses	^#()</body><body package="Store-Database Model">superclass	^nil.</body><body package="Store-Database Model">timestamp	^self subclassResponsibility.</body><body package="Store-Database Model">withAllSubclasses	^Array with: self.</body><body package="Store-Database Model">withAllSuperclasses	^Array with: self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>image compatibility</category><body package="Store-Database Model">canUnderstand: aSelector	"If we're browsing the database, we don't really know what we can and can't understand. Just say we do."	^true.</body><body package="Store-Database Model">classBehavior	"StoreClassExtension overrides this to provide its corresponding StoreMetaClassExtension"	^self</body><body package="Store-Database Model">fullRootName	^self longName.</body><body package="Store-Database Model">instanceBehavior	"StoreMetaclassExtension overrides this to provide its corresponding StoreClassExtension."	^self</body><body package="Store-Database Model">key	^self name.</body><body package="Store-Database Model">value	^self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>testing</category><body package="Store-Database Model">includesBehavior: aClass	^false.</body><body package="Store-Database Model">inheritsFrom: aClass	^false.</body><body package="Store-Database Model">isClass	^true.</body><body package="Store-Database Model">isExtension	^self classDefinition isNil</body><body package="Store-Database Model">isForClass	^false.</body><body package="Store-Database Model">isForClassOrExtension	^true</body><body package="Store-Database Model">isForNameSpace	^false</body><body package="Store-Database Model">isForSharedVariable	^false</body><body package="Store-Database Model">isImageObject	^false</body><body package="Store-Database Model">isMeta	^false.</body><body package="StoreForGlorpVWUI">isPatched	^false</body><body package="Store-Database Model">isPseudo	^false</body><body package="Store-Database Model">isStoreDefinitionInPackage	^false</body><body package="Store-Database Model">needsComment	^false.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>printing</category><body package="Store-Database Model">asString	^self displayString.</body><body package="Store-Database Model">fileOutMethodsOn: aSourceFileManager	| allMethods |	allMethods := self instanceMethods copy.	allMethods addAll: self classMethods.	allMethods do:		[:each | each fileOutSourceOn: aSourceFileManager]</body><body package="Store-Database Model">fileOutOn: aSourceFileManager		aSourceFileManager addComment: 'Class ' , self longName.	self fileOutSourceOn: aSourceFileManager.	aSourceFileManager cr</body><body package="Store-Database Model">fileOutSourceOn: aSourceFileManager	"My class definition object knows how to do this, if it exists"	self classDefinition 		ifNil: [self fileOutMethodsOn: aSourceFileManager]		ifNotNil: [:value | value fileOutSourceOn: aSourceFileManager]</body><body package="Store-Database Model">printMethod: selector on: aStream	"Print the source code for the method associated with the argument selector onto	the stream."	| source emphasis range |	aStream cr; cr.	source := (self sourceCodeAt: selector) asString.	emphasis := aStream emphasis.	range := self parserClass new parseSelectorInterval: source.	aStream nextPutAll: (source copyFrom: 1 to: range first - 1).	aStream emphasis: #bold.	aStream nextPutAll: (source copyFrom: range first to: range last).	aStream emphasis: emphasis.	aStream nextPutAll: (source copyFrom: range last + 1  to: source size)</body><body package="Store-Database Model">printOn: aStream	aStream nextPutAll: self name.</body><body package="Store-Database Model">printOutCategory: aSymbol on: aStream 	"File a description of the receiver's category, aSymbol, onto aStream."	|saved|	saved := aStream emphasis.	aStream emphasis: #bold.	aStream cr.	aStream nextPutAll: self simpleNameWithMeta; nextPutAll: ' methodsFor: ' , aSymbol.	aStream emphasis: saved.	(self organization listAtCategoryNamed: aSymbol)		do: [:each | self printMethod: each on: aStream].	aStream cr</body><body package="Store-Database Model">printOutOn: aStream	"Print me out on a textStream"	|saved definitionString commentString |	definitionString := self definition.	commentString := self comment.	definitionString isEmpty ifTrue: 		[definitionString := self longName.		commentString := String new].	saved := aStream emphasis.	aStream emphasis: #bold.	aStream nextPutAll: definitionString.	commentString notEmpty ifTrue:		[aStream cr.		aStream emphasis: #italic.		aStream cr.		aStream nextPutAll: commentString].	aStream emphasis: saved.	aStream cr.	self organization categories do: 		[:heading | self printOutCategory: heading on: aStream].	self classBehavior organization categories do: 		[:heading | self classBehavior printOutCategory: heading on: aStream].	aStream cr.	aStream cr</body><body package="Store-Database Model">shortName	^self displayString.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>comparing</category><body package="Store-Database Model">&lt; aStoreClassExtension	^self timestamp &gt; aStoreClassExtension timestamp.</body><body package="Store-Database Model">&lt;= aStoreClassExtension	^self timestamp &gt;= aStoreClassExtension timestamp.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>browser support</category><body package="Store-Database Model">valueOrDo: aBlock	^self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>accessing method dictionary</category><body package="Store-Database Model">sourceCodeAt: messageSelector 	"Answer the string corresponding to the source code for the argument."	| method |	method := self instanceMethods detect: [:each | each selector asString = messageSelector asString].	^(self sourceCodeForMethod: method at: messageSelector) asText.</body><body package="Store-Database Model">sourceCodeForMethod: aMethod at: aSelector	^aMethod source</body><body package="StoreForGlorpVWUI">whichCategoryIncludesSelector: aByteSymbol	self instanceMethods		do: [:each | each selector == aByteSymbol ifTrue: [^each protocol]].	^nil</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">bindingFor: aKey	^VariableBinding key: aKey</body><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^StoreSourceObject longNameFromSmalltalkUsing: self longName</body><body package="StoreForGlorpVWUI">shortItemString	^self longNameFromSmalltalk</body><body package="Store-Database Model">sourceCodeTemplate	^Object sourceCodeTemplate.</body><body package="StoreForGlorpVWUI">toolListDisplayString	^self displayString.</body><body package="StoreForGlorpVWUI">toolListIcon	^self class toolListIcon.</body><body package="StoreForGlorpVWUI">unambiguousName	^self longName</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>testing method dictionary</category><body package="Store-Database Model">includesSelector: aSelector	^self instanceMethods anySatisfy: [:each | each name = aSelector asString].</body><body package="Store-Database Model">whichClassIncludesSelector: aSelector	^self</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>converting</category><body package="Store-Database Model">asQualifiedReference	^self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension class</class-id> <category>instance creation</category><body package="Store-Database Model">new	^super new initialize.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>metaclasses</category><body package="Store-Database Model">storeMetaClass	^self.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>accessing</category><body package="Store-Database Model">absoluteName	^self classNameWithMeta</body><body package="Store-Database Model">classDefinition	^mainClass classDefinition.</body><body package="Store-Database Model">classMethods	^#()</body><body package="Store-Database Model">classNameWithMeta	^classNameWithMeta ifNil: [classNameWithMeta := self privateGetClassNameWithMeta]</body><body package="Store-Database Model">instanceMethods	^mainClass classMethods.</body><body package="Store-Database Model">longName	^mainClass longName.</body><body package="Store-Database Model">mainClass	^mainClass</body><body package="Store-Database Model">mainClass: aStoreClassExtension	mainClass := aStoreClassExtension</body><body package="Store-Database Model">name	^mainClass name.</body><body package="Store-Database Model">package	^mainClass package.</body><body package="Store-Database Model">privateGetClassNameWithMeta	^self longName , ' class'</body><body package="Store-Database Model">sharedVariables	^self mainClass sharedVariables</body><body package="Store-Database Model">simpleNameWithMeta	^self name, ' class'</body><body package="StoreForGlorpVWUI">soleInstance	^mainClass</body><body package="Store-Database Model">timestamp	^self mainClass timestamp.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>testing</category><body package="Store-Database Model">includesMethod: aStoreMethodInPackage	^aStoreMethodInPackage isMetaclass		ifTrue: [self instanceMethods includes: aStoreMethodInPackage]		ifFalse: [false].</body><body package="Store-Database Model">isMeta	^true.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">initialMethodCategory		^Symbol new</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>image compatibility</category><body package="Store-Database Model">instanceBehavior	"Override to provide my corresponding StoreClassExtension."	^mainClass</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>comparing</category><body package="Store-Database Model">= anObject	^self class = anObject class and: [self mainClass = anObject mainClass]</body><body package="Store-Database Model">hash	^self classNameWithMeta hash bitXor: self package hash</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>copying</category><body package="Store-Database Model">postCopy	super postCopy.	mainClass := mainClass copy.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension class</class-id> <category>instance creation</category><body package="Store-Database Model">on: aStoreClassExtension	^self new mainClass: aStoreClassExtension.</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>accessing</category><body package="Store-Merge Management">alternative	^alternative</body><body package="Store-Merge Management">alternative: anObject	alternative := anObject</body><body package="Store-Merge Management">applied	^applied</body><body package="Store-Merge Management">applied: anObject	applied := anObject</body><body package="Store-Merge Management">base	^base</body><body package="Store-Merge Management">base: anObject	base := anObject</body><body package="Store-Merge Management">image	^image</body><body package="Store-Merge Management">image: anObject	image := anObject</body><body package="Store-Merge Management">package	^package</body><body package="Store-Merge Management">package: anObject	package := anObject</body><body package="Store-Merge Management">proposed	^proposed</body><body package="Store-Merge Management">proposed: anObject	proposed := anObject</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>comparing</category><body package="Store-Merge Management">= aResolutionPackageItem	^self class = aResolutionPackageItem class and:		[self package = aResolutionPackageItem package and:		[self image = aResolutionPackageItem image and:		[self base = aResolutionPackageItem base and:		[self alternative = aResolutionPackageItem alternative]]]]</body><body package="Store-Merge Management">hash	^self package hash</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	base := image := proposed := applied := false</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>private</category><body package="Store-Merge Management">addAndInTo: textStream		textStream		emphasis: (Array with: #bold with: #color -&gt; ColorValue red);		nextPutAll: (#and &lt;&lt; #store &gt;&gt; 'and') asString;		space;		emphasis: nil</body><body package="Store-Merge Management">addDoNotApplyChangeTo: textStream		textStream		emphasis: (Array with: #bold with: #color -&gt; ColorValue red);		nextPutAll: (#ThreeStars &lt;&lt; #store &gt;&gt; '***') asString;		space;		emphasis: #bold;		nextPutAll: (#DoNotApplyChange &lt;&lt; #store &gt;&gt; 'Do Not Apply Change') asString;		emphasis: (Array with: #bold with: #color -&gt; ColorValue red);		space;		nextPutAll: (#ThreeStars &lt;&lt; #store &gt;&gt; '***') asString;		emphasis: nil</body><body package="Store-Merge Management">addInBaseTo: textStream		textStream		emphasis: #bold;		nextPutAll: (#BaseColon &lt;&lt; #store &gt;&gt; 'Base:') asString;		space;		emphasis: nil</body><body package="Store-Merge Management">addInImageTo: textStream		textStream		emphasis: #bold;		nextPutAll: (#ImageColon &lt;&lt; #store &gt;&gt; 'Image:') asString;		space;		emphasis: nil</body><body package="Store-Merge Management">asGeneralResolution	| instance |	instance := self copy.	instance alternative: nil.	^instance</body><body package="Store-Merge Management">packageLabel		^package 		ifNil: [(#DashAbsentDash &lt;&lt; #store &gt;&gt; '- absent -') asString] 		ifNotNil: 			[:value | 			value pseudoPackage ifTrue: [^(#DashAbsentDash &lt;&lt; #store &gt;&gt; '- absent -') asString].			value displayString , ' ', 			(alternative isUserInputResolution				ifTrue: ['']				ifFalse: [value timeStampString])]</body><body package="Store-Merge Management">populateFrom: anAlternative in: aResolution	| inImageResolution |	alternative := anAlternative.	package := anAlternative isRemovalResolution ifTrue: [anAlternative base key] ifFalse: [anAlternative package].	aResolution proposed ifNotNil:		[aResolution proposed isNoOpResolution			ifTrue:  				[proposed := aResolution proposed = anAlternative.				applied := proposed and: [aResolution applied].				alternative = anAlternative]			ifFalse: 				[aResolution makeResolutionProposals.				anAlternative isAbsentResolution ifTrue: [alternative := nil].				anAlternative isRemovalResolution					ifTrue: 						[applied := aResolution applied and: [aResolution proposed = anAlternative].						proposed := aResolution proposed = anAlternative]					ifFalse: [	applied := (proposed := anAlternative = aResolution proposed) and: [aResolution applied]]]].	base := (anAlternative = aResolution base and: [anAlternative isRemovalResolution not]) or: [anAlternative isRemovalResolution and: [aResolution base = anAlternative]].	inImageResolution := aResolution alternatives detect: [:each | each isDoNothingResolution not and: [each package isImageObject]] ifNone: [nil].	anAlternative = inImageResolution 		ifTrue: [image := anAlternative value = inImageResolution value]		ifFalse: [image := (anAlternative = aResolution original and: [anAlternative isRemovalResolution not and: [anAlternative package isVersionLoaded]]) or: [anAlternative isRemovalResolution and: [aResolution original notNil and: [anAlternative package isVersionLoaded]]]].</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>relationships</category><body package="Store-Merge Management">sortKey	"Primary key can be nil if the underlying object is a PseudoPackage"	^self package ifNil: [-1] ifNotNil: [self package primaryKey ifNil: [-2]].</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>printing</category><body package="Store-Merge Management">printOn: aStream	super printOn: aStream.	aStream 		space;		nextPut: $(;		nextPutAll: (self package ifNil: [(#DashAbsentDash &lt;&lt; #store &gt;&gt; '- absent -') asString] ifNotNil: [:value | value displayString]);		nextPut: $)</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>testing</category><body package="Store-Merge Management">isAbsentResolution	^package isNil</body><body package="Store-Merge Management">isForGeneralResolution	^alternative isNil</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>displaying</category><body package="Store-Merge Management">definitionTextFrom: aChangeResolver	^aChangeResolver definitionTextFrom: self</body><body package="Store-Merge Management">icon	^applied 		ifTrue: [MergeIcons applied]		ifFalse: 			[proposed				ifTrue: [MergeIcons resolved]				ifFalse: [nil]]</body><body package="Store-Merge Management">labelText		| textStream |	textStream := TextStream on: String new.	(self alternative isNil or: [self alternative isUserInputResolution not])		ifTrue:			[image ifTrue: [self addInImageTo: textStream].			(image and: [base]) ifTrue: [self addAndInTo: textStream].			base ifTrue: [self addInBaseTo: textStream]].	(self alternative notNil and: [self alternative isNoOpResolution])		ifTrue: [self addDoNotApplyChangeTo: textStream] 		ifFalse: [textStream nextPutAll: self packageLabel].	(self alternative notNil and: [self alternative isUserInputResolution])		ifTrue:			[textStream emphasis: #color -&gt; ColorValue darkGreen.			textStream nextPutAll: MergeTool userSuppliedString].	^textStream contents</body><body package="Store-Merge Management">selectionText		| textStream |	textStream := TextStream on: String new.	textStream nextPutAll: self packageLabel.	^textStream contents</body></methods><methods><class-id>Store.ResolutionPackageItem class</class-id> <category>instance creation</category><body package="Store-Merge Management">forAbsentBase	| instance |	instance := self new.	instance base: true.	^instance</body><body package="Store-Merge Management">forAbsentBaseAndImage	| instance |	instance := self new.	instance base: true.	instance image: true.	^instance</body><body package="Store-Merge Management">forAbsentImage	| instance |	instance := self new.	instance image: true.	^instance</body><body package="Store-Merge Management">new	^super new initialize</body><body package="Store-Merge Management">on: anAlternative in: aResolution	| instance |	instance := self new.	instance populateFrom: anAlternative in: aResolution.	^instance</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>accessing</category><body package="Store-Code Comparison">isAddition	^isAddition</body><body package="Store-Code Comparison">isAddition: aBoolean	isAddition := aBoolean</body><body package="Store-Code Comparison">method: aMethodBlueprint	method := aMethodBlueprint</body><body package="Store-Code Comparison">parseTree	parseTree == 0		ifTrue: 			[parseTree := [Refactory.Browser.RBParser parseMethod: method source]						on: Error						do: [nil]].	^parseTree</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>row population</category><body package="Store-Code Comparison">computeDetailRows	| view |	view := TextEditorView model: method sourceText asValue.	view beReadOnly.	^Array with: view</body><body package="Store-Code Comparison">populateHeader	| header |	super populateHeader.	header := self header.	header add: (isAddition				ifTrue: [ComparisonIcons add]				ifFalse: [ComparisonIcons remove]).	header add: (Label with: method selectorDisplayText).	header add: self moreInfoTooltipHandle</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">initialize	super initialize.	parseTree := 0</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>private</category><body package="Store-Code Comparison">imageMethod	^self imageMethodDefinitionFrom: method</body><body package="Store-Code Comparison">storeMethod	^method originalStoreObject</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>testing</category><body package="Store-Code Comparison">hasMenu	^true</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison">categoryInfoTooltipText	| output |	output := TextStream on: String new.	output nextPutAll: (#MethodCategoryC &gt;&gt; 'Category:' &lt;&lt; #IDE) asString.	output space.	output		emphasis: #bold;		nextPutAll: method category;		emphasis: nil.	^output contents</body><body package="Store-Code Comparison">packageInfoTooltipText	| output |	output := TextStream on: String new.	output nextPutAll: (#DefinitionPackageC &gt;&gt; 'Package:' &lt;&lt; #IDE) asString.	output space.	output		emphasis: #bold;		nextPutAll: method packageName;		emphasis: nil.	^output contents</body><body package="Store-Code Comparison">tooltipTextChunks	^Array with: self categoryInfoTooltipText with: self packageInfoTooltipText</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^Array		with: #singleMethod		with: method selector		with: method isInstanceBehavior</body></methods><methods><class-id>Store.CreateParcelDirectoryConfirmation</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		^Dialog confirm: (#CreateDirectory1s &lt;&lt; #store &gt;&gt; 'Create directory &lt;1s&gt;?' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.CreateParcelDirectoryConfirmation class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>accessing</category><body package="Store-Database Model">absoluteClassName	^self classNameWithMeta</body><body package="StoreForGlorpVWUI">allStoreVersions	| session |	^[(Store.Gathering for: self selector asString) started.		session := StoreLoginFactory currentStoreSession.	self class		allVersionsWithName: self selector asString		inClass: self classNameWithMeta		in: session] 			ensure: [(Store.Gathering for: self selector asString) finished]</body><body package="Store-Database Model">className	^self definition className.</body><body package="Store-Database Model">classNameWithoutMeta	^self definition classNameWithoutMeta</body><body package="Store-Database Model">classOrNameSpace	^self package fullClassForMethod: self.</body><body package="Store-Database Model">correspondingImageClass	^self definition correspondingImageClass</body><body package="Store-Database Model">editionStamp	^''.</body><body package="Store-Database Model">environment	^self definition environment.</body><body package="StoreForGlorpVWUI">fullClassName	^self longName</body><body package="StoreForGlorpVWUI">implementingClass	^self myClass</body><body package="Store-Database Model">inheritingClass	"What is this for?  Just hard-code to the same class for the moment"	^self classOrNameSpace.</body><body package="Store-Database Model">isMetaclass	^self definition isMetaclass.</body><body package="Store-Database Model">longName	^self className</body><body package="Store-Database Model">methodClass	^self classOrNameSpace.</body><body package="Store-Database Model">methodSources	^self definition methodSources</body><body package="Store-Database Model">myClass	^self definition correspondingImageClass.</body><body package="Store-Database Model">name	^self definition name</body><body package="StoreForGlorpVWUI">ownerName	^self definition className.</body><body package="Store-Database Model">protocol	^self definition protocol.</body><body package="Store-Database Model">resourceType	^nil.</body><body package="Store-Database Model">selector	^self definition selector.</body><body package="Store-Database Model">source	^self definition source.</body><body package="Store-Database Model">sourceString	^self source.</body><body package="Store-Database Model">symbol	^self definition name asSymbol.</body><body package="StoreForGlorpVWUI">version	^self definition version.</body><body package="Store-Database Model">versions	| session methodDefinitionQuery methods uniqueKeys |	session := StoreLoginFactory currentStoreSession.	methodDefinitionQuery := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	methodDefinitionQuery alsoFetch: #definition.	methodDefinitionQuery orderBy: [:each | each definition timestamp descending].	methods := session execute: methodDefinitionQuery.	uniqueKeys := Set new.	^methods inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>printing</category><body package="Store-Database Model">classNameWithMeta	^self definition classNameWithMeta.</body><body package="Store-Database Model">displayString	^self definition displayString.</body><body package="Store-Database Model">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager</body><body package="Store-Database Model">fullDisplayText	^self displayString asText.</body><body package="Store-Database Model">printOn: aStream	| hasDefinition |	hasDefinition := 	(self definition isGlorpProxy not or: [self definition isInstantiated]).	aStream nextPutAll: self class name; space.	hasDefinition ifTrue: [aStream nextPutAll: self classNameWithMeta].	aStream nextPutAll: '&gt;&gt;'.	aStream nextPutAll: '#'.	hasDefinition ifTrue: [aStream nextPutAll: self definition name]		ifFalse: [aStream nextPutAll: 'Unknown'].</body><body package="Store-Database Model">signature	^self longNameWithMetaFromSmalltalk, ' &gt;&gt; ', self name</body><body package="StoreForGlorpVWUI">statusLineString	^self protocol</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>loading</category><body package="StoreForGlorpVWUI">loadAsNewIn: aPackageModel	Store.Policies packagePolicy 		forcePackage: aPackageModel		while: [self definition loadSource]</body><body package="StoreForGlorpVWUI">loadAsNewIn: aPackageModel withCommittingSource: aBoolean	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource or #loadAsNewIn:).	Store.Policies packagePolicy 		forcePackage: aPackageModel		while: [self definition loadSource]</body><body package="StoreForGlorpVWUI">loadNewSource: aString	| selector class protocol packageModel result |	(class := self correspondingImageClass) ifNil: 		[| msg |		msg := AbstractPundleLoader unloadableMethodMessageForUnloadedClass: self className.		^self raiseUnloadableError: msg inPackage: self package].	selector := self selector.	protocol := self protocol.	packageModel := self package storeModel ifNil: [Registry pundleNamed: self package name].	((class includesSelector: selector)		and: [(class organization categoryOfElement: selector) = protocol 		and: [(class compiledMethodAt: selector) getSource string = aString]])			ifTrue: 				[result := class compiledMethodAt: selector.				packageModel ifNotNil: [Store.XChangeSet current moveSelector: selector class: class toPackage: packageModel]]			ifFalse:				[| environment |				environment := packageModel 					ifNil: [class environment]					ifNotNil: [:value | value environmentFor: selector in: class].				result := class					compile: aString					classified: protocol					notifying: nil					environment: environment].	result ifNil: [self raiseUnloadableError: nil inPackage: self package].	^result</body><body package="Store-Database Model">loadSource	| selector class protocol packageModel result |	(class := self correspondingImageClass) ifNil: 		[| msg |		msg := AbstractPundleLoader unloadableMethodMessageForUnloadedClass: self className.		^self raiseUnloadableError: msg inPackage: self package].	selector := self selector.	protocol := self protocol.	packageModel := self package storeModel ifNil: [Registry pundleNamed: self package name].	((class includesSelector: selector)		and: [(class organization categoryOfElement: selector) = protocol 		and: [((class compiledMethodAt: selector) getSource ifNil: ['']) string = self sourceCode]])			ifTrue: 				[result := class compiledMethodAt: selector.				packageModel ifNotNil: [Store.XChangeSet current moveSelector: selector class: class toPackage: packageModel]]			ifFalse:				[| environment |				environment := packageModel 					ifNil: [class environment]					ifNotNil: [:value | value environmentFor: selector in: class].				result := class					compile: self sourceCode					classified: protocol					notifying: nil					environment: environment].	^result</body><body package="Store-Database Model">loadSourceDirect	^self definition loadSourceDirectInPackage: self package</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>testing</category><body package="Store-Database Model">isForMethod	^true.</body><body package="Store-Database Model">isMeta	^self definition isMeta</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>comparing</category><body package="Store-Database Model">= aStoreMethodInPackage	aStoreMethodInPackage class == self class ifTrue:		[^self package yourSelf = aStoreMethodInPackage package yourSelf			and: [self definition yourSelf = aStoreMethodInPackage definition yourSelf]].	(aStoreMethodInPackage respondsTo: #asStoreMethodDefinition) ifFalse: [^false].	^definition = aStoreMethodInPackage asStoreMethodDefinition</body><body package="Store-Database Model">equalsSignatureIn: aStoreMethodInPackage	aStoreMethodInPackage class == self class ifFalse: [		^self definition equalsSignatureIn: aStoreMethodInPackage asStoreMethodDefinition].	^self package yourSelf == aStoreMethodInPackage package yourSelf and: [self definition equalsSignatureIn: aStoreMethodInPackage definition].</body><body package="Store-Database Model">hash	^self definition yourSelf hash</body><body package="Store-Database Model">signatureHash	^self definition signatureHash</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>private</category><body package="Store-Database Model">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	| dictionary |	dictionary := Dictionary new.	dictionary at: self protocol put: (Set with: self).	aStream sourceFormatter attributeFor: #package compute: [:ignored | self package name].	aStream sourceFormatter attributeForMethods: #package compute: [:ignored :more | self package name].	aStream fileOutTTMessages: dictionary for: self classNameWithMeta logging: false.</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>converting</category><body package="Store-Database Model">asStoreMethodDefinition	^self definition</body><body package="Store-Database Model">asString	^self displayString.</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI">asTag	^Store.MethodTag 		newClassName: self className 		meta: self isMeta		selector: self selector asSymbol		protocol: self protocol.</body><body package="Store-Database Model">isProbed	^false.</body><body package="Store-Database Model">method	^nil.</body><body package="Store-Database Model">sourceCode	^self source</body><body package="Store-Database Model">textRepresentationForTag: aTag	^self source</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>compatiblity</category><body package="StoreForGlorpVWUI">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	Store.XMainChangeSet current		addRemoveSelector: self selector		className: self className asClassNameOnly		meta: self isMeta		package: aPackage</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeMethod: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedMethodObject</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>displaying</category><body package="Store-Database Model">fullDisplayString	^'[&lt;3s&gt;] &lt;1s&gt; &lt;2s&gt;' 		expandMacrosWith: self signature		with: self bracketedVersionString		with: self package name</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage class</class-id> <category>database utility</category><body package="Store-Database Model">allVersionsWithName: aString in: aSession	| query session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachObject | (eachObject definition name = aString)			AND: [eachObject package timestamp = (				(Query					readOneOf: self					where: [:eachObject2 | eachObject2 definition id = eachObject definition id]					)					retrieve: [:eachObject2 | eachObject2 package timestamp min];					yourself)]].	query alsoFetch: #definition.	query orderBy: [:eachObject | eachObject definition timestamp descending].	query orderBy: [:eachObject | eachObject package timestamp].	^(session execute: query) asOrderedCollection</body><body package="Store-Database Model">allVersionsWithName: aString inClass: aClassName	^self allVersionsWithName: aString inClass: aClassName in: nil</body><body package="Store-Database Model">allVersionsWithName: aString inClass: aClassName in: aSession	| query session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachLink | (eachLink definition name = aString)			AND: [(eachLink definition className = aClassName)			AND: [eachLink package timestamp = (				(Query readOneOf: self where: [:eachLink2 | eachLink2 definition id = eachLink definition id])					retrieve: [:eachLink2 | eachLink2 package timestamp min];					yourself)			]]].	query alsoFetch: #definition.	query alsoFetch: [:each | each definition source].	query alsoFetch: [:each | each package].	query orderBy: [:each | each definition timestamp descending].	query orderBy: [:each | each package timestamp].	^(session execute: query) asOrderedCollection</body><body package="Store-Database Model">allVersionsWithNameIn: aCollection inClass: aClassName	"Note the result is unordered, it is up to you to order it if you want"	^self allVersionsWithNameIn: aCollection inClass: aClassName in: nil</body><body package="Store-Database Model">allVersionsWithNameIn: aCollection inClass: aClassName in: aSession	"Note the result is unordered with respect to the definition names	in aCollection, it is up to you to order it if you want"	| query session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachLink | (eachLink definition name in: aCollection)			AND: [(eachLink definition className = aClassName)			AND: [eachLink package timestamp = (				(Query readOneOf: self where: [:eachLink2 | eachLink2 definition id = eachLink definition id])					retrieve: [:eachLink2 | eachLink2 package timestamp min];					yourself)			]]].	query alsoFetch: #definition.	query orderBy: [:each | each definition timestamp descending].	query orderBy: [:each | each package timestamp].	^(session execute: query) asOrderedCollection</body><body package="Store-Database Model">protocolOrNilFor: aSelector inClass: aString packageID: anInteger	"This is a very specific API used only by PackageModel&gt;&gt;reorganizedMethodDescriptors, and	since reorgs are not really tracked very often, this is rarely called.	WHEN it is called, it answers the very minimum info possible"	| query session |	session := StoreLoginFactory currentStoreSession.	query := Query		readOneOf: self		where: 			[:eachMethodInPackage |			eachMethodInPackage package primaryKey = anInteger AND: 			(eachMethodInPackage definition name = aSelector) AND:			(eachMethodInPackage definition className = aString)].	query retrieve: [:each | each definition protocol].	^session execute: query</body><body package="Store-Database Model">selectStoreVersionOf: aString inClass: aClassName in: aSession	"Produce a dialogue that answers a store class definitin in package object or nil."		| list session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	list := self allVersionsWithName: aString inClass: aClassName in: session.	list isEmpty		ifTrue:			[Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions') asString.			^nil].	list size == 1 ifTrue: [^list first].	^Dialog		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list collect: [:each | each longNameFromSmalltalk, ' ', each definition timeStampString])		values: list		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage class</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">toolListIcon	^BehaviorIcons Method</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage class</class-id> <category>instance creation</category><body package="Store-Database Model">newFor: aMethod package: aPackage		| methodDefinition |	methodDefinition := aMethod asStoreMethodDefinition.	methodDefinition updateUserAndTimestampFrom: aPackage.	^self new		definition: methodDefinition;		package: aPackage</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">addUnloadableDefinition: anUnloadableDefinition	unloadableDefinitions add: anUnloadableDefinition</body><body package="Atomic Compiling and Loading">dllccLoaded	^dllccLoaded</body><body package="Atomic Compiling and Loading">dllccLoaded: aBoolean		dllccLoaded := aBoolean</body><body package="Atomic Compiling and Loading">earlyInstallClassNames	^earlyInstallClassNames</body><body package="Atomic Compiling and Loading">fullLoadClasses	^fullLoadClasses , self shadowOrganizer classes</body><body package="Atomic Compiling and Loading">lastPundleWorkedOn	^lastPundleWorkedOn</body><body package="Atomic Compiling and Loading">lastPundleWorkedOn: aStorePundle	lastPundleWorkedOn := aStorePundle</body><body package="Atomic Compiling and Loading">name	^pundles first name</body><body package="Atomic Compiling and Loading">overrides	^overrides</body><body package="Atomic Compiling and Loading">shadowCOtherMethods	^self shadowOrganizer cOtherMethods</body><body package="Atomic Compiling and Loading">shadowCTypeMethods	^self shadowOrganizer cTypeMethods</body><body package="Atomic Compiling and Loading">shadowCompiler	^compilationManager shadowCompiler</body><body package="Atomic Compiling and Loading">shadowExtensionMethods	^self shadowOrganizer extensionMethods</body><body package="Atomic Compiling and Loading">shadowExternalMethods	^self shadowOrganizer externalMethods</body><body package="Atomic Compiling and Loading">shadowMethods	^self shadowOrganizer definedClassMethods</body><body package="Atomic Compiling and Loading">shadowOrganizer	^shadowOrganizer</body><body package="Atomic Compiling and Loading">shadowSharedVariables	^self shadowOrganizer sharedVariables</body><body package="Atomic Compiling and Loading">unloadableDefinitions	^unloadableDefinitions</body><body package="Atomic Compiling and Loading">unloadableDefinitionsForBrowsing	"We created these UnloadableError objects with ShadowedObjects in them, 	now we have to make them have their generic objects"	| objectInPackage shadowedObject |	unloadableDefinitions do:		[:each |		shadowedObject := each parameter.		objectInPackage := shadowedObject storeObject asStoreObjectInPackage: shadowedObject package.		each parameter: objectInPackage.		each package: shadowedObject package storeModel].	^unloadableDefinitions</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>analyze</category><body package="Atomic Compiling and Loading">analyze	DbRegistry clearPundleCaches.	self runPrerequisites.	self initializeEarlyInstallClassNames.	compilationManager := AtomicCompilationManager new.		[[installObjects do: [:each | each analyzeUsing: self]]		on: EarlyInstallNotice		do: 			[:notification |			self compileAndInstall.			self resetCompilationEnvironment.			notification resume]]			on: NoDLLCCNotification			do: 				[:notification |				(Registry packageNamed: 'DLLCC')					ifNotNil: 						[dllccLoaded := true.						notification resume].				Parcel loadParcelByName: 'DLLCC'.				(Registry packageNamed: 'DLLCC')					ifNil: [LoadCanceled raiseWith: notification parameter].				dllccLoaded := true.				self compileAndInstall.				self resetCompilationEnvironment.				notification resume].	self finalCompileAndInstall.	self retryUnloadables.	self hasUnloadableDefinitions ifTrue: [self applyLoadingPolicyAfterLoadError].	pundlesNeedPostInstallReconcile		ifTrue: 			[pundles do: 					[:each |					each applyPundleVersionsToTheImage: true.					each storeModel reconcileWithDbVersion: each]]</body><body package="Atomic Compiling and Loading">analyzeAndInstall	"I don't answer anything useful"		[[Store.DBAccess loadingFromStore: true.	self analyze]		on: LoadCanceled		do: 			[:exception | 			Transcript 				cr;				show: 					((#LoadingOf1sHasBeenCanceled &lt;&lt; #store &gt;&gt; 'Loading of &lt;1s&gt; has been canceled') 						expandMacrosWith: self name)]] ensure: 		[Store.DBAccess loadingFromStore: false.		pundles any prerequisiteRecursionReset.		pundles do: 			[:each |			each resetStoreModel.			each applyPundleVersionsToTheImage: true].		Undeclared purgeUnusedBindings.		Store.DbRegistry refreshBrowsers]</body><body package="Atomic Compiling and Loading">applyLoadingPolicyAfterLoadError	"Loading errors have occurred. Check out setting AbstractPundleLoader.LoadFailedOption 	and determine how to deal with them.	- #loadButNotify = Complete the load but open a tool to manage errors	- #load = Ignore errors and load what can be loaded	- #displayDialog = Open a dialog to ask what to do (if user confirmed to continue, answer is in ignoreUnloadables)	- #fail = Load only if there are no errors (not applicable, errors have prevented to arrive here)"	| option |	(#(#load #fail) includes: (option := self loadFailOption)) ifTrue: [^self].	option = #displayDialog &amp; ignoreUnloadables not		ifTrue: [^self	"errors handled immediately on load error"].	ViewUnloadableDefinitionsNotification openOnExceptions: self unloadableDefinitionsForBrowsing</body><body package="Atomic Compiling and Loading">cleanUpOverrides		installObjects do: [:each | each cleanUpOverrides]</body><body package="Atomic Compiling and Loading">compileAndInstall	"Always when we come in here first, we run the preCompile (prereqs)."		self runPreLoads.	self compileToShadow.	self hasUnloadableDefinitions ifTrue: 		[self proceedToLoad ifFalse: 			[LoadCanceled raiseWith: (lastPundleWorkedOn ifNil: [pundles first])]].	self installFromShadow.	self recompileExternalObjects.	self recompileOverriddenClasses.	self initializeBindingsAndClasses.	self runPostLoads.	(Installing for: (lastPundleWorkedOn ifNil: [pundles first])) finished.	self markInstalled</body><body package="Atomic Compiling and Loading">compileToShadow	(Compiling for: (lastPundleWorkedOn ifNil: [pundles first])) started.	SystemUtils modifySystem: 		[self compileAll: self sortedNamespaces.		self compileAll: self sortedClasses.		self compileAll: self shadowSharedVariables.		self compileAll: self sortedCTypeMethods.		self compileAll: self sortedCOtherMethods.		self compileAll: self sortedExternalMethods.		self compileAll: self sortedDefinedMethods.		self compileAll: self sortedExtensionMethods.		self compileUnloadables: self unloadableDefinitions].	(Compiling for: (lastPundleWorkedOn ifNil: [pundles first])) finished.</body><body package="Atomic Compiling and Loading">finalCompileAndInstall	"Always when we come in here first, we run the preCompile (prereqs)."		self runPreLoads.	self compileToShadow.	self installFromShadow.	SystemUtils modifySystem: 		[self updateDeltaDefinitionsAndPackageRecompile.		overrides do: [:each | each override cleanUpAfterLoad]].	self recompileExternalObjects.	self recompileOverriddenClasses.	self initializeBindingsAndClasses.	self hasUnloadableDefinitions ifTrue: 		[ | unloadableDefinitionRecords |		unloadableDefinitionRecords := (self unloadableDefinitions collect: #definitionRecord).		SystemUtils modifySystem: [self compileUnloadables: self unloadableDefinitions].		self installUnloadablesFromShadow: unloadableDefinitionRecords.		pundlesNeedPostInstallReconcile := true].	self hasUnloadableDefinitions ifTrue: 		[self proceedToLoad ifFalse: 			[LoadCanceled raiseWith: (lastPundleWorkedOn ifNil: [pundles first])]].	self runPostLoads.	self cleanUpOverrides.	(Installing for: (lastPundleWorkedOn ifNil: [pundles first])) finished.	self markInstalled.	SourceFileManager default endOfChunk</body><body package="Atomic Compiling and Loading">installFromShadow	(Installing for: (lastPundleWorkedOn ifNil: [pundles first])) started.	SystemUtils modifySystem: 		[shadowOrganizer namespaces do: [:each | each installWith: self].		(shadowOrganizer sharedVariables select: #isInNameSpace) do: [:each | each installWith: self].		shadowOrganizer classes do: [:each | each installWith: self].		(shadowOrganizer sharedVariables select: #isClassVariable) do: [:each | each installWith: self].		shadowOrganizer cOtherMethods do: [:each | each installWith: self].		shadowOrganizer cTypeMethods do: [:each | each installWith: self].		shadowOrganizer externalMethods do: [:each | each installWith: self].		shadowOrganizer definedClassMethods do: [:each | each installWith: self].		shadowOrganizer extensionMethods do: [:each | each installWith: self]].</body><body package="Atomic Compiling and Loading">installUnloadablesFromShadow: aCollection	(Installing for: (lastPundleWorkedOn ifNil: [pundles first])) started.	SystemUtils modifySystem: 		[(aCollection select: #isForNamespace) do: [:each | each installWith: self].		(aCollection select: #isForClass) do: [:each | each installWith: self].		(aCollection select: #isForSharedVariable) do: [:each | each installWith: self].		(aCollection select: #isForMethod) do: [:each | each installWith: self]].</body><body package="Atomic Compiling and Loading">markInstalled		installObjects do: [:each | each installed not ifTrue: [each smartMarkInstalled]]</body><body package="Atomic Compiling and Loading">retryUnloadables	self unloadableDefinitions copy do: [:each| | unloadable result packageModel |		each package isNil			ifTrue: [each package: each parameter storeObject package].		packageModel := each package storeModel.		unloadable := each parameter storeObject.				[result := unloadable loadSourceInto: packageModel]			on: Error			do: [:exception | exception return].		result isNil			ifFalse: [(unloadable isForMethod and: [unloadable isMeta and: [unloadable selector = #initialize]])					ifTrue: [each parameter correspondingImageClass instanceBehavior postLoad: packageModel].		self unloadableDefinitions remove: each]].</body><body package="Atomic Compiling and Loading">runPostLoads		installObjects do: [:each | each runPostLoadUsing: self]</body><body package="Atomic Compiling and Loading">runPreLoads		installObjects do:		[:each | 		(each installed not and: [each isBundle or: [each isPackage and: [each completedAnalysis]]]) ifTrue:			[(Preloading for: each pundle) started.			[each runPreLoad ifFalse: [LoadCanceled raiseWith: each pundle]] ensure: [(Preloading for: each pundle) finished]]]</body><body package="Atomic Compiling and Loading">runPrerequisites		installObjects do:		[:each | 		each hasRunPrerequisites ifFalse:			[(Preloading for: each pundle) started.			each pundle preCompileWith: nil.			each hasRunPrerequisites: true.			(Preloading for: each pundle) finished]]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-compiling</category><body package="Atomic Compiling and Loading">allExternalMethods	^self shadowOrganizer externalMethods</body><body package="Atomic Compiling and Loading">allRegularExternalInterfaceMethods	^self shadowOrganizer regularExternalInterfaceMethods</body><body package="Atomic Compiling and Loading">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass instanceBehavior == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: 					[(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: 						[(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]				ifFalse: 					[(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: 						[(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copy]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copy]].</body><body package="Atomic Compiling and Loading">extractCompilerFrom: aClassOrMetaClass andPutInto: aShadowClass	"If aClassOrMetaClass (the real not shadowed class) is NOT nil, then we don't have to touch it."	| workingShadow realOrNil method |	workingShadow := aShadowClass.	[realOrNil := self realFromShadow: workingShadow.	workingShadow := workingShadow ifNotNil: [:value | value superclass].	(realOrNil isNil and: [workingShadow isNil]) ifTrue: [^self].	(self leaveCompilerAloneWithRegardTo: realOrNil) ifTrue: [^self].	(method := self compilerMethodInShadow: workingShadow orRealClassDefinesCompiler: realOrNil) notNil] whileFalse.	aShadowClass isMeta		ifTrue: [aShadowClass replaceMethodAt: #classCompilerClass withMethod: method]		ifFalse: [aShadowClass class replaceMethodAt: #compilerClass withMethod: method]</body><body package="Atomic Compiling and Loading">leaveCompilerAloneWithRegardTo: realOrNil		^(realOrNil notNil and: 		[realOrNil instanceBehavior == Object]) or: 		[realOrNil notNil and: [realOrNil instanceBehavior includesBehavior: SmalltalkCompiler]]</body><body package="Atomic Compiling and Loading">orderedExternalInterfaceClasses	| externalClasses externalMethodClasses  |	externalClasses := OrderedCollection new: shadowOrganizer classes size.	self shadowOrganizer classes do: [:eachClass|		| shadowCompiledDefinition |		shadowCompiledDefinition := eachClass shadowCompiledDefinition.		shadowCompiledDefinition notNil			ifTrue: [| realClass  |				realClass := self realFromShadow: shadowCompiledDefinition.				(realClass notNil and: [realClass isMeta not and: [realClass includesBehavior: ExternalInterface]])					ifTrue: [externalClasses add: realClass]]].	externalMethodClasses := Set new.	self allExternalMethods inject: externalMethodClasses into: [:set :each | each mclass notNil ifTrue: [set add: each mclass]. set]. 	self allRegularExternalInterfaceMethods inject: externalMethodClasses into: [:set :each | each mclass notNil ifTrue: [set add: each mclass]. set].	externalMethodClasses := externalMethodClasses collect: [:each | self realFromShadow: each].	externalMethodClasses addAll: externalClasses.	^SystemUtils sortForLoading: externalMethodClasses</body><body package="Atomic Compiling and Loading">raiseUnloadableError: exceptionOrString for: aStoreObjectInPackage	"Return nil for convenience of callers, who will call this and wish to return (with nil) from wherever they are in checking the unload state and cause."	| unloadableError |	unloadableError := Store.UnloadableDefinitionError		for: aStoreObjectInPackage		inPackage: aStoreObjectInPackage package		error: exceptionOrString.	unloadableError raise.	^nil</body><body package="Atomic Compiling and Loading">realFromShadow: aShadowedObject	"Looks up aShadowedObject in the real world and answers it, or nil if it doesn't exist. 		Works for NameSpaces and Classes."	| real shadowObject |	aShadowedObject ifNil: [^nil].	shadowObject := aShadowedObject isBehavior		ifTrue: [aShadowedObject instanceBehavior]		ifFalse: [aShadowedObject].	real := shadowObject absoluteName asStrictReference 		ifDefinedDo: [:value | value]		elseDo: [^nil].	^(aShadowedObject isBehavior and: [aShadowedObject isMeta])		ifTrue: [real class]		ifFalse: [real]</body><body package="Atomic Compiling and Loading">resetCompilationEnvironment		self initializeEarlyInstallClassNames.	compilationManager reinitializeShadowRoot.	fullLoadClasses addAll: self shadowOrganizer classes.	shadowOrganizer := ShadowOrganizer new.	sortedFullClasses := nil.	overriddenClasses := OrderedCollection new.	objectsToInitialize := Dictionary new.	classesToInitialize := OrderedCollection new.	bindingsToInitialize := OrderedCollection new.</body><body package="Atomic Compiling and Loading">root	^compilationManager root</body><body package="Atomic Compiling and Loading">shadowAt: aPath	^(self root		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>install objects</category><body package="Atomic Compiling and Loading">addAllCTypeMethods: anOrderedCollection	anOrderedCollection notEmpty 		ifTrue: [self shadowOrganizer addAllCTypeMethods: anOrderedCollection].	^anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllClasses: anOrderedCollection	anOrderedCollection notEmpty 		ifTrue: [self shadowOrganizer addAllClasses: anOrderedCollection].	^anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllDefinedClassMethods: anOrderedCollection	anOrderedCollection notEmpty 		ifTrue: [self shadowOrganizer addAllDefinedClassMethods: anOrderedCollection].	^anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllExtensionMethods: anOrderedCollection	anOrderedCollection notEmpty 		ifTrue: [self shadowOrganizer addAllExtensionMethods: anOrderedCollection].	^anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllNamespaces: anOrderedCollection	anOrderedCollection notEmpty 		ifTrue: [self shadowOrganizer addAllNamespaces: anOrderedCollection].	^anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllShareds: anOrderedCollection	anOrderedCollection notEmpty 		ifTrue: [self shadowOrganizer addAllSharedVariables: anOrderedCollection].	^anOrderedCollection</body><body package="Atomic Compiling and Loading">addNamespace: aShadowedStoreNamespace	self shadowOrganizer addNamespace: aShadowedStoreNamespace</body><body package="Atomic Compiling and Loading">buildInstallObjects	pundles do:		[:each | 		each runPreRead ifTrue: [installObjects add: each asAtomicInstallObject]]</body><body package="Atomic Compiling and Loading">redefinesClass: aStoreClassDefinition	| className |	aStoreClassDefinition correspondingImageClass ifNotNil: [^true].	className := aStoreClassDefinition longName.	^self shadowOrganizer classes anySatisfy: [:each | each longName = className]</body><body package="Atomic Compiling and Loading">redefinesNamespace: aStoreNamespace	| namespaceName |	aStoreNamespace correspondingImageNamespace ifNotNil: [^true].	namespaceName := aStoreNamespace longName.	^self shadowOrganizer namespaces anySatisfy: [:each | each longName = namespaceName]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading">sortedCOtherMethods	| methods |	^(methods := self shadowOrganizer cOtherMethods) isEmpty		ifTrue: [#()]		ifFalse: [			self shadowOrganizer cOtherMethods: (self sortedMethods: methods).			self shadowOrganizer cOtherMethods]</body><body package="Atomic Compiling and Loading">sortedCTypeMethods	| methods |	^(methods := self shadowOrganizer cTypeMethods) isEmpty		ifTrue: [#()]		ifFalse: [			self shadowOrganizer cTypeMethods: (self sortedMethods: methods).			self shadowOrganizer cTypeMethods]</body><body package="Atomic Compiling and Loading">sortedClasses	| packageName orderedClasses workingClasses names |	self shadowOrganizer classes isEmpty ifTrue: [^#()].	workingClasses := self shadowOrganizer classes copy.	packageName := workingClasses first package name.	(Gathering for: packageName, ' - Classes') started.	orderedClasses := OrderedCollection new: workingClasses size.	[workingClasses isEmpty] whileFalse:		[names := (workingClasses collect: [:each | each longName]) asSet.		workingClasses copy do:			[:each |			(names contains: [:eachName | eachName = each superclassName]) ifFalse:				[orderedClasses add: each.				workingClasses remove: each]]].	self shadowOrganizer classes: orderedClasses.	(Gathering for: packageName, ' - Classes') finished.	^orderedClasses</body><body package="Atomic Compiling and Loading">sortedDefinedMethods		| methods |	^(methods := self shadowOrganizer definedClassMethods) isEmpty		ifTrue: [#()]		ifFalse: [			self shadowOrganizer definedClassMethods: (self sortedMethods: methods).			self shadowOrganizer definedClassMethods]</body><body package="Atomic Compiling and Loading">sortedExtensionMethods	| methods |	^(methods := self shadowOrganizer extensionMethods) isEmpty		ifTrue: [#()]		ifFalse: [			self shadowOrganizer extensionMethods: (self sortedMethods: methods).			self shadowOrganizer extensionMethods]</body><body package="Atomic Compiling and Loading">sortedExternalMethods	| methods |	^(methods := self shadowOrganizer externalMethods) isEmpty		ifTrue: [#()]		ifFalse: [			self shadowOrganizer externalMethods: (self sortedMethods: methods).			self shadowOrganizer externalMethods]</body><body package="Atomic Compiling and Loading">sortedFullClasses	| classes workingClasses names |	sortedFullClasses ifNotNil: [^sortedFullClasses].	(classes := self fullLoadClasses) isEmpty ifTrue: [^#()].	sortedFullClasses := OrderedCollection new: classes size.	workingClasses := classes copy.	[workingClasses isEmpty] whileFalse:		[names := workingClasses collect: [:each | each longName].		workingClasses copy do:			[:each |			(names contains: [:eachName | eachName = each superclassName]) ifFalse:				[sortedFullClasses add: each.				workingClasses remove: each]]].	^sortedFullClasses</body><body package="Atomic Compiling and Loading">sortedMethods: anOrderedCollection	"We go through three phases here to get everything in Hierarchy order as much as we can:	1) Gather all methods that are for superclasses of all known defined classes	2) Gather all methods that are for classes of all known defined classes	3) For the rest, gathered based on the known classes in the system (mostly extension methods)"			| methodsByClass orderedMethods sortedClasses orderedClassMethods |	(Gathering for: anOrderedCollection first package name , ' - Methods') started.	orderedMethods := OrderedCollection new: anOrderedCollection size.	orderedClassMethods := OrderedCollection new: anOrderedCollection size.	sortedClasses := self sortedFullClasses.	methodsByClass := Dictionary new: 1000.	anOrderedCollection do: [:each |		(methodsByClass at: each className ifAbsentPut: [OrderedCollection new]) add: each].	sortedClasses do: [:eachClass |		(methodsByClass at: eachClass superclassName ifAbsent: [#()]) do: [:eachMethod |			eachMethod isMeta				ifTrue: [orderedClassMethods add: eachMethod]				ifFalse: [orderedMethods add: eachMethod]].		methodsByClass removeKey: eachClass superclassName ifAbsent: []].	sortedClasses do: [:eachClass |		(methodsByClass at: eachClass longName ifAbsent: [#()]) do: [:eachMethod |			eachMethod isMeta				ifTrue: [orderedClassMethods add: eachMethod]				ifFalse: [orderedMethods add: eachMethod]].		methodsByClass removeKey: eachClass longName ifAbsent: []].	[methodsByClass isEmpty] whileFalse:		[ | nextClassName |		nextClassName := methodsByClass keys detect: [:key |			(methodsByClass includesKey: ((methodsByClass at: key) first superclassNameFrom: sortedClasses)) not].		(methodsByClass at: nextClassName) do: [:each |			each isMeta				ifTrue: [orderedClassMethods add: each]				ifFalse: [orderedMethods add: each]].			methodsByClass removeKey: nextClassName].	(Gathering for: anOrderedCollection first package name , ' - Methods') finished.	^orderedClassMethods asOrderedCollection		addAll: orderedMethods;		yourself</body><body package="Atomic Compiling and Loading">sortedNamespaces	"Sort the namespaces in the ShadowOrganizer by namespace hierarchy level.	Top level namespaces must precede bottom level namespaces.	Answer the sorted collection."	^self shadowOrganizer namespaces		sortWith: [:a :b | (a longName occurrencesOf: $.) &lt; (b longName occurrencesOf: $.)]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize		pundles := OrderedCollection new.	installObjects := OrderedCollection new.	shadowOrganizer := ShadowOrganizer new.	dllccLoaded := (Registry packageNamed: 'DLLCC') notNil.	fullLoadClasses := OrderedCollection new.	self initializeEarlyInstallClassNames.	unloadableDefinitions := OrderedCollection new.	pundlesNeedPostInstallReconcile := false.	objectsToInitialize := Dictionary new.	classesToInitialize := OrderedCollection new.	classesToNotify := IdentityDictionary new.	overrides := OrderedCollection new.	overriddenClasses := OrderedCollection new.	bindingsToInitialize := OrderedCollection new.	ignoreUnloadables := false</body><body package="Atomic Compiling and Loading">initializeEarlyInstallClassNames		earlyInstallClassNames := (Scanner withAllSubclasses collect: [:each | each longName]) asSet.	earlyInstallClassNames addAll: (SmalltalkCompiler withAllSubclasses collect: [:each | each longName])</body><body package="Atomic Compiling and Loading">pundle: aStorePackageOrBundle	pundles add: aStorePackageOrBundle.	self buildInstallObjects</body><body package="Atomic Compiling and Loading">pundles: aCollectionOfPundles	pundles addAll: aCollectionOfPundles.	self buildInstallObjects</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading">collectRedefinedClasses: aClassOverride	overriddenClasses add: aClassOverride</body><body package="Atomic Compiling and Loading">fixMClass: aMethod to: aNewClass	"Scans blocks to update references to the new (not in shadow) class."	| originalClass |	originalClass := aMethod mclass.	aMethod mclass: aNewClass.	aMethod withAllBlockMethodsDo:		[:method |		1 to: method basicSize do:			[:index |			originalClass  == (method basicAt: index) ifTrue:				[method basicAt: index put: aNewClass]]].	^aMethod</body><body package="Atomic Compiling and Loading">initializeBindingsAndClasses	"In the Atomic loader we try to recompile all classes that have shareds first. We'll try not doing this"	| bindingsThatFailedToInitialize classesThatFailedToInitialize failedInitializerCount lastFailedInitializerCount |	SystemUtils modifySystem: 		[self installPackageNamespaces.		bindingsThatFailedToInitialize := OrderedCollection new.		classesThatFailedToInitialize := OrderedCollection new.		installObjects do: [:eaTopLevelInstallObject |			eaTopLevelInstallObject visit: [:eaInstallObject |				eaInstallObject isPackage					ifTrue: [						bindingsThatFailedToInitialize addAll: (self initializeBindingsForPackage: eaInstallObject pundle).						classesThatFailedToInitialize addAll: (self initializeClassesForPackage: eaInstallObject pundle)]]].		self runClassExtensionInitializers.		failedInitializerCount := bindingsThatFailedToInitialize size + classesThatFailedToInitialize size.		lastFailedInitializerCount := failedInitializerCount + 1.		[failedInitializerCount &gt; 0 and: [failedInitializerCount &lt; lastFailedInitializerCount]]			whileTrue: [				lastFailedInitializerCount := failedInitializerCount.				bindingsThatFailedToInitialize := self initializeSharedVariableBindings: bindingsThatFailedToInitialize.				classesThatFailedToInitialize := self retryInitializeClassesFor: classesThatFailedToInitialize.				failedInitializerCount := bindingsThatFailedToInitialize size + classesThatFailedToInitialize size].		classesToNotify keysAndValuesDo: [:key :value | key extensionMethodsWereAdded: value].]</body><body package="Atomic Compiling and Loading">initializeBindingsForPackage: aPackage	^self initializeSharedVariableBindings: 		(self sharedVariablesToInitializeFor: aPackage)</body><body package="Atomic Compiling and Loading">initializeClasses: aCollectionOfClasses in: aPundle	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"		| sortedClasses workingClasses workingSize |	aCollectionOfClasses isEmpty 		ifTrue: [^aCollectionOfClasses].	aCollectionOfClasses do: [:each | each key postCopyFromShadow: each value].	sortedClasses := SystemUtils sortForLoading: (aCollectionOfClasses collect: [:each | each key]).	workingClasses := sortedClasses copy.	workingSize := -1.	[workingSize ~= sortedClasses size and: [sortedClasses notEmpty]] whileTrue:		[workingSize := sortedClasses size.		"packageDictionary := Dictionary new.		self putClasses: sortedClasses intoDictionary: packageDictionary.		self installFromPackagesIn: packageDictionary removingFrom: workingClasses."		sortedClasses do: [:eachClass|			[eachClass postLoad: aPundle pundleModel.			workingClasses remove: eachClass ifAbsent: [nil]] 				on: InitializerFailedError , MessageNotUnderstood				do: [:exception | exception return]].		sortedClasses := workingClasses copy].	^sortedClasses</body><body package="Atomic Compiling and Loading">initializeClassesForPackage: aPackage	^self initializeClasses: 		(self classesToInitializeFor: aPackage) in: aPackage</body><body package="Atomic Compiling and Loading">initializeSharedVariableBindings: aCollectionOfSharedVariableBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| workingSize copyBindings uninitializedBindings |	aCollectionOfSharedVariableBindings isEmpty		ifTrue: [^aCollectionOfSharedVariableBindings].	uninitializedBindings := aCollectionOfSharedVariableBindings copy.	copyBindings := uninitializedBindings copy.	workingSize := -1.	[workingSize ~= uninitializedBindings size and: [uninitializedBindings notEmpty]]		whileTrue: 			[workingSize := uninitializedBindings size.			uninitializedBindings do: 					[:each |										[each recompile.					each initialize.					each ifNotNil: [copyBindings remove: each]]							on: MessageNotUnderstood							do: [:exception | exception resume]].			uninitializedBindings := copyBindings copy].	^uninitializedBindings</body><body package="Atomic Compiling and Loading">installClass: aShadowedObject	"The KISS approach: 		execute the new class definition to install or replace the existing one."		| realEnvironment realClass messageSend shadowedClass |	(shadowedClass := aShadowedObject shadowCompiledDefinition) ifNil: [^self].	realEnvironment := self realFromShadow: shadowedClass environment.	messageSend := shadowedClass definitionMessage.	messageSend receiver: realEnvironment.	shadowedClass strictReference ifDefinedDo:		[:value |		(Override overridesForClassOrNameSpace: value) ifNotNil:			[:knownOverrides | | target |			target := knownOverrides detect: [:over | over sources includes: aShadowedObject packageModel] ifNone: [nil].			target ifNotNil: [^target setOverriddenDefinition: messageSend]]].	Policies packagePolicy		forcePackage: aShadowedObject packageModel		while:			[realClass := self invokeClassCreationMessage: messageSend.			(aShadowedObject comment notNil and: [aShadowedObject comment notEmpty]) 				ifTrue: [realClass comment: aShadowedObject comment]				ifFalse: [realClass comment: nil].			realClass addToSuper].	self addClassToInitialize: (realClass -&gt; shadowedClass) for: aShadowedObject package</body><body package="Atomic Compiling and Loading">installMethod: aShadowedObject	"If the new method is already in the REAL class, then throw a RedefinitionNotification	If this is a new method, just move it directly to the package we want. 	The system will think it's in the package of the class definition, since no other packages have information about it yet.	If the shadowCompiledDefinition is nil, then it had to be a unloadable definition.	If the method is NOT new, then this is an override. We need to move it to the package we want in a way that modifies other change sets."	| shadowClass realClass category selector existingMethod knownOverride compiledMethod |	(compiledMethod := aShadowedObject shadowCompiledDefinition)		ifNil: [^self].	shadowClass := compiledMethod mclass.	realClass := self realFromShadow: shadowClass.	selector := compiledMethod selector.	category := shadowClass whichCategoryIncludesSelector: selector.	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: 		[| methodNodeHolder |		methodNodeHolder := Compiler new			parse: compiledMethod getSource			in: realClass			notifying: nil.		methodNodeHolder ifNotNil:			[selector := aShadowedObject selector.			category := aShadowedObject protocol]].	(existingMethod := realClass compiledMethodAt: selector ifAbsent: nil) ifNotNil: 		[knownOverride := Override			overrideForSelector: selector			class: realClass			in: aShadowedObject packageModel.		knownOverride ifNotNil: 			[knownOverride setOverriddenDefinition: (self fixMClass: compiledMethod to: realClass).			self removeOverrideMatching: knownOverride.			^knownOverride setOverriddenProtocol: category].		RedefinitionNotification			redefinedSelector: selector			class: realClass			attributes: existingMethod attributes].	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: [^self].	self fixMClass: compiledMethod to: realClass.	realClass needsSafeRebinding ifTrue: 		[compiledMethod literalsDo: 			[:each |			(each isVariableBinding and: [each isDeferred]) ifTrue: [each resolveBinding]]].	(realClass		justAddSelectorUnsafe: selector		withMethod: compiledMethod		category: category) ifTrue: 			[(classesToNotify at: realClass ifAbsentPut: [OrderedCollection new]) add: selector].	existingMethod ifNotNil: 		[self updateSourcePackageFor: compiledMethod in: realClass].	aShadowedObject packageModel doSubdefChange: 		((Change new add)			selector: compiledMethod selector;			class: realClass).	(selector = #initialize and: [realClass isMeta and: [((self classesToInitializeFor: aShadowedObject package) anySatisfy: [:each | each key = realClass instanceBehavior]) not]])		ifTrue: [	self addClassToInitialize: (realClass instanceBehavior -&gt; shadowClass instanceBehavior) for: aShadowedObject package].	compiledMethod sourcePointer: (SourceFileManager default		storeMethodSource: compiledMethod getSource		class: realClass		selector: selector		category: category		safely: false)</body><body package="Atomic Compiling and Loading">installNameSpace: aShadowedObject	"The KISS approach: 		execute the new namespace definition to install or replace the existing one."		| realEnvironment namespace knownOverrides target shadowedNamepace |	(shadowedNamepace := aShadowedObject shadowCompiledDefinition) ifNil: [^self].	realEnvironment := self realFromShadow: shadowedNamepace environment.	(shadowedNamepace strictReference valueOrDo: [nil]) ifNotNil:		[:value |		knownOverrides := Override overridesForClassOrNameSpace: value.		knownOverrides ifNotNil: [target := knownOverrides detect: [:eachOverride | eachOverride sources includes: aShadowedObject packageModel] ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: ((shadowedNamepace definitionMessage) receiver: realEnvironment)]].	Policies packagePolicy		forcePackage: aShadowedObject packageModel		while:			[| msg |			(msg := shadowedNamepace shadowLoadDefinitionMessage) receiver: realEnvironment.			namespace := self invokeCreationMessage: msg.			(aShadowedObject comment notNil and: [aShadowedObject comment notEmpty]) 				ifTrue: [namespace comment: aShadowedObject comment]				ifFalse: [namespace comment: nil]]</body><body package="Atomic Compiling and Loading">installPackageNamespaces	installObjects do: #installPackageNamespaces</body><body package="Atomic Compiling and Loading">installSharedBinding: aShadowedObject	"At the end, we try to initialize the binding now... If we can't, we queue it up to try later"		| realEnvironment binding messageSend bindingReference |	(bindingReference := aShadowedObject shadowCompiledDefinition) ifNil: [^self].	realEnvironment := self realFromShadow: bindingReference environment.	messageSend := bindingReference environment asNameSpace definitionMessageOfStatic: bindingReference binding.	messageSend arguments: aShadowedObject shadowedArguments.	messageSend receiver: realEnvironment.	bindingReference environment strictReference ifDefinedDo:		[:value |		(Override overridesForStatic: bindingReference binding in: value) ifNotNil:			[:knownOverrides | | target |			target := knownOverrides 				detect: [:eachOverride | eachOverride sources includes: aShadowedObject packageModel] 				ifNone: [nil].			target ifNotNil: [^target setOverriddenDefinition: messageSend]]].	Policies packagePolicy		forcePackage: aShadowedObject packageModel		while: [binding := self invokeCreationMessage: messageSend].	binding needsInitialization ifTrue: 		[self addSharedToInitialize: binding for: aShadowedObject package]</body><body package="Atomic Compiling and Loading">proceedToLoad	"A loading error has occurred. Check out setting AbstractPundleLoader.LoadFailedOption whether to continue loading.	- #loadButNotify = Complete the load but open a tool to manage errors	- #load = Ignore errors and load what can be loaded	- #displayDialog = Open a dialog to ask what to do	- #fail = Load only if there are no errors"	| option |	(option := self loadFailOption) = #fail ifTrue: [^false].	option ~= #displayDialog | ignoreUnloadables		ifTrue: [^true	"option demands to continue or user has already opted to ignore"].	"ask whether to continue and remember the answer for next problems"	^ignoreUnloadables := Dialog confirm: #LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?'</body><body package="Atomic Compiling and Loading">removeOverrideMatching: anOverriddenMethod	| match |	match := self overrides detect: [:each | each override = anOverriddenMethod] ifNone: [^self].	self overrides remove: match.</body><body package="Atomic Compiling and Loading">retryInitializeClassesFor: allClassesWhichFailedToInitialize	allClassesWhichFailedToInitialize notEmpty		ifTrue: 			[pundlesNeedPostInstallReconcile := true.			allClassesWhichFailedToInitialize do: 					[:each |					[each postLoad: (Registry containingPackageForClass: each)]						on: InitializerFailedError						do: [:exception | exception resignalAs: MessageNotUnderstood new]]]</body><body package="Atomic Compiling and Loading">runClassExtensionInitializers	(self shadowOrganizer extensionMethods		select: [:each | each isMeta and: [each selector = #initialize]]) do: 				[:each |								[(self realFromShadow: each mclass) instanceBehavior					postLoad: each packageModel]						on: InitializerFailedError , MessageNotUnderstood						do: [:exception | exception return: nil]]</body><body package="Atomic Compiling and Loading">updateDeltaDefinitionsAndPackageRecompile	| definitionsToRemove targetPackages |	definitionsToRemove := Dictionary new.	installObjects do: [:each | each gatherDefinitionsToRemoveInto: definitionsToRemove].	(definitionsToRemove at: #methods ifAbsent: [#()]) do:		[:eachPair | Override unloadSelector: eachPair key selector class: eachPair key correspondingImageClass from: eachPair value logged: true].	(definitionsToRemove at: #shareds ifAbsent: [#()]) do:		[:eachPair | Override unloadStatic: eachPair key in: eachPair key owner from: eachPair value logged: #(#changes #file)].	(definitionsToRemove at: #classes ifAbsent: [#()]) do:		[:eachPair | Override unloadClassOrNameSpace: eachPair key actual from: eachPair value].	(definitionsToRemove at: #nameSpaces ifAbsent: [#()]) do:		[:eachPair | Override unloadClassOrNameSpace: eachPair key actual from: eachPair value].	installObjects do: [:each | each updateForPackageRecompile].	Override cleanseLists.	Override cleanseLists.	targetPackages := Set new.	definitionsToRemove do:		[:eachGroup |		eachGroup do: [:eachPair | targetPackages add: eachPair value]].	targetPackages do: [:each | each markNotModified].</body><body package="Atomic Compiling and Loading">updateSourcePackageFor: aCompiledMethod in: aClass	| sourcePackage |	sourcePackage := Registry		containingPackageForSelector: aCompiledMethod selector		class: aClass.	sourcePackage 		removeChangeTypes: #(#remove #override) 		forClass: aClass 		selector: aCompiledMethod selector</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>compiling</category><body package="Atomic Compiling and Loading">compileAll: aCollectionOfStoreObjects	aCollectionOfStoreObjects do: [:each| each compileWith: self]</body><body package="Atomic Compiling and Loading">compileUnloadables: aCollectionOfUnloadableDefinitionErrors	"Atttempt to compile the unloadableDefinitions definitions into shadow space"		unloadableDefinitions := OrderedCollection new.	aCollectionOfUnloadableDefinitionErrors do:		[:each | 		| definitionRecord |		definitionRecord := each definitionRecord.		definitionRecord compileWith: self.		definitionRecord shadowCompiledDefinition ifNotNil: [definitionRecord gatherInto: self]].	self hasUnloadableDefinitions ifFalse: [^self].	pundlesNeedPostInstallReconcile := true.	self proceedToLoad ifFalse: [LoadCanceled raiseWith: self]</body><body package="Atomic Compiling and Loading">recompileAllExternals: anOrderedCollection		anOrderedCollection do:		[:each | 		| failed |		failed := OrderedCollection new.		each selectors do:			[:eachSelector | 			[each recompile: eachSelector]				on: Error , UserNotification				do:					[:error | 					failed add: eachSelector.					error isResumable 						ifTrue: [error resume] 						ifFalse: [error return]]].		failed do: [:eachFailed | (each selectors includes: eachFailed) ifFalse: [each recompile: eachFailed]]]</body><body package="Atomic Compiling and Loading">recompileExternalObjects	| orderedClasses ctypeClasses |	orderedClasses := self orderedExternalInterfaceClasses.	self recompileAllExternals: orderedClasses.	ctypeClasses := Set new: orderedClasses size.	(self shadowCOtherMethods, self shadowCTypeMethods, self shadowExternalMethods)		inject: ctypeClasses 		into: [:set :eaMtd |			eaMtd mclass notNil ifTrue:				[set add: (self realFromShadow: eaMtd mclass instanceBehavior)].			set].	"ctypeClasses := ctypeClasses - orderedClasses asSet."	(SystemUtils sortForLoading: ctypeClasses) do: [:each | each recompileMethods].</body><body package="Atomic Compiling and Loading">recompileOverriddenClasses	| allClassesWithSubclasses classesToRecompile |	overriddenClasses isEmpty ifTrue: [^self].	pundlesNeedPostInstallReconcile := true.	allClassesWithSubclasses := Set new.	classesToRecompile := overriddenClasses collect: [:each | each actual].	classesToRecompile := classesToRecompile select: [:each | each notNil and: [each isBehavior]].	classesToRecompile do: [:each | allClassesWithSubclasses addAll: each withAllSubclasses].	(SystemUtils sortForAtomicLoading: allClassesWithSubclasses) do: 		[:eachClass | 		(Store.Registry allContainingPackagesForClass: eachClass) do:			[:eachPackage | eachPackage recompileMethodsFor: eachClass]].</body><body package="Atomic Compiling and Loading">shadowDbMethod: aMethodRecord	"Convert aMethodRecord into an object in shadow root.	Raise UnloadableDefinitionError if the method code cannot be compiled."		| realWorldClass selector shadowClass |	realWorldClass := aMethodRecord correspondingImageClass.	(shadowClass := self shadowCompiler findInShadow: aMethodRecord className asClassNameOnly asStrictReference)		ifNil:			[realWorldClass ifNil: 				[| msg |				msg := AbstractPundleLoader unloadableMethodMessageForUnloadedClass: aMethodRecord className. 				^self raiseUnloadableError: msg for: aMethodRecord].			shadowClass := self shadowCompiler createShadowClassFor: realWorldClass instanceBehavior].	aMethodRecord isMeta ifTrue: [shadowClass := shadowClass class].	self extractCompilerFrom: realWorldClass andPutInto: shadowClass.	selector := [[shadowClass		compileForShadow: aMethodRecord definitionString		classified: aMethodRecord protocol		notifying: nil		environment: (aMethodRecord package environmentFor: aMethodRecord selector in: shadowClass)		attributes: nil]			on: Error			do: [:exception | 				exception class = SyntaxErrorException					ifTrue: [^self raiseUnloadableError: exception for: aMethodRecord].				exception return: nil]]				on: UserNotification				do: 					[:exception | 					exception isResumable						ifTrue: [exception resume: nil]						ifFalse: [exception return: nil]].	selector ifNil: [^self raiseUnloadableError: nil for: aMethodRecord].	aMethodRecord className asClassNameOnly = shadowClass longName asClassNameOnly 		ifFalse: [pundlesNeedPostInstallReconcile := true].	^shadowClass compiledMethodAt: selector</body><body package="Atomic Compiling and Loading">shadowDefinedRecord: aStoreDefinitionInPackage	"Convert aStoreDefinitionInPackage into an object in shadow root. First make sure that a class dependent has a class in shadow to be installed into."	| newDefinitionObject |	(aStoreDefinitionInPackage isForClass or: [aStoreDefinitionInPackage isForNameSpace])		ifTrue: [			(self shadowCompiler findInShadow: aStoreDefinitionInPackage environmentString asStrictReference)			 	ifNil: [ | definitionOwnerClass |					(definitionOwnerClass := Glorp.Dialect smalltalkAt: aStoreDefinitionInPackage environmentString ifAbsent: [nil])						ifNil: [ | parentType msg |							parentType := aStoreDefinitionInPackage isForClass								ifTrue: ['Class']								ifFalse: ['Namespace'].							msg := AbstractPundleLoader unloadableClassOrNameSpaceMessageForMissingParent:								aStoreDefinitionInPackage environmentString type: parentType.							^self raiseUnloadableError: msg for: aStoreDefinitionInPackage].					self shadowCompiler createShadowClassOrNameSpaceFor: definitionOwnerClass.					self shadowCompiler addShadowedClassToEnvironment: definitionOwnerClass]].	aStoreDefinitionInPackage isForData		ifTrue: 			[(self shadowCompiler				findInShadow: aStoreDefinitionInPackage environmentString asStrictReference)					ifNil: 						[| definitionOwnerClass |						(definitionOwnerClass := aStoreDefinitionInPackage owner)							ifNil: [| parentType msg |								parentType := aStoreDefinitionInPackage isClassVariable									ifTrue: ['Class']									ifFalse: ['Namespace'].								msg := AbstractPundleLoader unloadableSharedMessageForMissingParent: 										aStoreDefinitionInPackage environmentString type: parentType.								^self raiseUnloadableError: msg for: aStoreDefinitionInPackage].						self shadowCompiler createShadowClassOrNameSpaceFor: definitionOwnerClass.						self shadowCompiler addShadowedClassToEnvironment: definitionOwnerClass]].	newDefinitionObject := self shadowCompiler				evaluate: aStoreDefinitionInPackage shadowLoadDefinition				with: Object evaluatorClass new				using: self.	newDefinitionObject isSignalledException		ifTrue: [^self raiseUnloadableError: newDefinitionObject for: aStoreDefinitionInPackage].	newDefinitionObject isNil		ifTrue: 			[(aStoreDefinitionInPackage isForNameSpace				and: [aStoreDefinitionInPackage name = 'Root'])					ifFalse: [self raiseUnloadableError: nil for: aStoreDefinitionInPackage]].	^newDefinitionObject</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>testing</category><body package="Atomic Compiling and Loading">hasUnloadableDefinitions	^unloadableDefinitions notEmpty</body><body package="Atomic Compiling and Loading">isEarlyInstallRequiredByClassNamed: aClassName	^earlyInstallClassNames includes: aClassName</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>accessing - objects to be initialized</category><body package="Atomic Compiling and Loading">addClassToInitialize: anAssociationOfRealClassAndShadowClass for: aPackage	| packageObjectsToInitialize |	packageObjectsToInitialize := self packageObjectsToInitializeFor: aPackage.	packageObjectsToInitialize addClass: anAssociationOfRealClassAndShadowClass</body><body package="Atomic Compiling and Loading">addSharedToInitialize: aSharedVariable for: aPackage	| packageObjectsToInitialize |	packageObjectsToInitialize := self packageObjectsToInitializeFor: aPackage.	packageObjectsToInitialize addSharedVariable: aSharedVariable</body><body package="Atomic Compiling and Loading">classNamed: aClassLongName ifAbsent: absentBlock	^shadowOrganizer classNamed: aClassLongName ifAbsent: absentBlock</body><body package="Atomic Compiling and Loading">classesToInitializeFor: aPackage	| packageObjectsToInitialize |	packageObjectsToInitialize := self packageObjectsToInitializeFor: aPackage ifAbsent: [nil].	^packageObjectsToInitialize isNil		ifTrue: [#()]		ifFalse: [packageObjectsToInitialize classes]</body><body package="Atomic Compiling and Loading">packageObjectsToInitializeFor: aPackage	| packageKey |	packageKey := aPackage isString ifTrue: [aPackage] ifFalse: [aPackage name].	^objectsToInitialize at: packageKey		ifAbsentPut: [PackageObjectsToInitialize newFor: packageKey]</body><body package="Atomic Compiling and Loading">packageObjectsToInitializeFor: aPackage ifAbsent: aBlock	| packageKey |	packageKey := aPackage isString 		ifTrue: [aPackage] 		ifFalse: [aPackage name].	^objectsToInitialize at: packageKey ifAbsent: aBlock</body><body package="Atomic Compiling and Loading">sharedVariablesToInitializeFor: aPackage	| packageObjectsToInitialize |	packageObjectsToInitialize := self packageObjectsToInitializeFor: aPackage ifAbsent: [nil].	^packageObjectsToInitialize isNil		ifTrue: [#()]		ifFalse: [packageObjectsToInitialize sharedVariables]</body></methods><methods><class-id>Store.AtomicAnalysisLoader class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new	^super new initialize</body><body package="Atomic Compiling and Loading">pundle: aStorePackageOrBundle	| instance |	instance := self new.	instance pundle: aStorePackageOrBundle.	^instance</body><body package="Atomic Compiling and Loading">pundles: aCollectionOfPundles	| instance |	instance := self new.	instance pundles: aCollectionOfPundles.	^instance</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>actions</category><body package="Store-UI">atLeastOnePundleVersionSelected	^self listOfThings selections notEmpty</body><body package="Store-UI">copySelection	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller copySelection</body><body package="Store-UI">find	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller find</body><body package="Store-UI">findNext	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller findNext</body><body package="Store-UI">selectEntireText	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller selectEntireText</body><body package="Store-UI">updateStatusPaneWith: aString	status labelString: aString.	statusBar invalidate</body><body package="Store-UI">updateTextPaneWith: aString	self definition value: aString</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>aspects</category><body package="Store-UI">definition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^definition isNil		ifTrue:			[definition := String new asValue]		ifFalse:			[definition]</body><body package="Store-UI">initializeStatusBar	statusBar := ToolBarView new.	statusBar variantName: #statusbar.	statusBar pragmas: self</body><body package="Store-UI">mainMenu	"The listPart must have a mainMenu which adds its action menu"	^[| menu item |	menu := self class mainMenu.	item := menu atNameKey: #Edit.	item submenu: self class textMenu.	item := MenuItem labeled: #_Version &lt;&lt; #store &gt;&gt; '&amp;Version'.	item submenu: [listPart listMenu value].	menu addItem: item atPosition: 9.015.	menu]</body><body package="Store-UI">statusBar	statusBar == nil ifTrue: [self initializeStatusBar].	^statusBar</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>accessing</category><body package="Store-UI">listOfThings	^listPart</body><body package="Store-UI">listPart: aListPart	listPart := aListPart</body><body package="Store-UI">listSpec	^listPart class windowSpec</body><body package="Store-UI">listTitle	^listPart listTitle</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>binding</category><body package="Store-UI">specificationFor: aKey	^self perform: aKey</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>error handling</category><body package="Store-UI">doesNotUnderstand: aMessage	"We host the listPane's menu, so enablement and actions may need to be sent to it.	This makes this tool generic in that it can host panes that have different enablement and actions"	^(listPart respondsTo: aMessage selector)		ifTrue: [listPart perform: aMessage selector withArguments: aMessage arguments]		ifFalse: [super doesNotUnderstand: aMessage]</body><body package="Store-UI">glorpSession	"Assuming that we're being used to view a list of definitions from the database, return the Glorp session used for that. Since this involves diving down into a bunch of things that might not even be there, especially if that assumption is wrong, guard against errors comprehensively."	| list |	list := listPart itemsInList list.	list isEmpty ifTrue: [^nil].	^[list any package session] on: Error do: [:ex | ex return: nil].</body><body package="Store-UI">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self glorpSession ifNil: [^self].	"We can have multiple store sessions with the same underlying connection. Make sure that we close our browsers if there's an error on any of them."	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn:( #DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printString)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>interface opening</category><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	Glorp.GlorpError.Announcements when: Store.ObsoleteBrowserContent send: #handleGlorpError: to: self</body><body package="Store-UI">postOpenWith: aBuilder	super postOpenWith: aBuilder.	listPart postOpenWith: aBuilder</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>interface closing</category><body package="Store-UI">noticeOfWindowClose: aWindow	"The ApplicationWindow aWindow is in the process of closing. 	You have been notified."	self release.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>private</category><body package="Store-UI">terminateBrowser	self release.	self builder ifNotNil: [self closeAndUnschedule]</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>initialize-release</category><body package="Store-UI">initialize	status := PassiveLabel new labelString: ''.	self initializeStatusBar</body><body package="Store-UI">release	"The statusBar is the component of an ArbitraryView, which does not automatically participate in	 the #release propagated through the view hierarchy when a window closes, so we need to explicitly	 release this widget owned by the UI."	statusBar == nil ifFalse: [statusBar release].	Glorp.GlorpError.Announcements unsubscribe: self.	super release</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>opening</category><body package="Store-UI">browseRemovedMethodsIn: aClass	| instance listPart | 	instance := self new.	listPart := MethodListPane new.	listPart tool: instance.	listPart title: (#VersionsOfRemovedMethodsIn1s &lt;&lt; #store &gt;&gt; 'Versions of Removed Methods In &lt;1s&gt;' expandMacrosWith: aClass name).	(listPart setUpForRemovedMethodsIn: aClass) ifNil: [^nil].	instance listPart: listPart.	instance open.</body><body package="Store-UI">forBundleContents: aStoreBundle	^self forListPart:		(BundleTreePane new			fillInFor: aStoreBundle;			title: (#ContentsOfBundle1s &lt;&lt; #store &gt;&gt; 'Contents of Bundle &lt;1s&gt;' expandMacrosWith: aStoreBundle displayString);			yourself)</body><body package="Store-UI">forClasses: aCollection	^self forListPart:		(ClassListPane new			fillListWith: aCollection;			yourself)</body><body package="Store-UI">forClassesOrNameSpaces: aCollection	aCollection isEmpty ifTrue: [^self].	^aCollection first isForNameSpace		ifTrue: [self forNameSpaces: aCollection]		ifFalse: [self forClasses: aCollection]</body><body package="Store-UI">forListPart: aDefinitionForListPane	| instance |	instance := self new.	aDefinitionForListPane tool: instance.	instance listPart: aDefinitionForListPane.	instance open.	^instance</body><body package="Store-UI">forMethodChangesInClass: aCollection	^self forListPart:		(MethodListPane new			fillListWith: aCollection;			title: (#MethodVersionsWithChangesIn1s &lt;&lt; #store							&gt;&gt; 'Method versions with changes in &lt;1s&gt;'								expandMacrosWith: aCollection first longNameFromSmalltalk);			yourself)</body><body package="Store-UI">forMethods: aCollection	^self forListPart:		(MethodListPane new			fillListWith: aCollection;			yourself)</body><body package="Store-UI">forNameSpaces: aCollection	^self forListPart:		(NameSpaceListPane new			fillListWith: aCollection;			yourself)</body><body package="Store-UI">forPackages: aCollection	^self forListPart:		(PackageListPane new			fillListWith: aCollection;			yourself)</body><body package="Store-UI">forPackages: aCollection containingString: aString	| listPart |	listPart := PackageListPane new.	listPart fillListWith: aCollection.	listPart title: listPart title, (#Defining1s &lt;&lt; #store &gt;&gt; ' defining: &lt;1s&gt;' expandMacrosWith: aString).	^self forListPart: listPart</body><body package="Store-UI">forSharedVariables: aCollection	^self forListPart:		(SharedVariableListPane new			fillListWith: aCollection;			yourself)</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>private</category><body package="Store-UI">cleanUpObsoleteInstances	"Once a repository connection is closed, any open instances are not revivable, even if the repository is connected again."	self allInstances do: [:ea | ea terminateBrowser]</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>initialize-release</category><body package="Store-Repository Access">initialize	classes := IdentitySet new.	nameSpaces := IdentitySet new.	methodDict := IdentityDictionary new.	classesWithoutSuper := IdentitySet new.	classesWithNoEnvironment := IdentitySet new.	overrides := OrderedCollection new.	nameSpacesWithNoEnvironment := IdentitySet new.	wholePackage := true.</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>load preparation</category><body package="Store-Repository Access">removeClasses	classes do: [:cls | cls removeFromSystem]</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>dialog</category><body package="Store-Repository Access">classEnvironmentProblemWarning: warnStream 	classesWithNoEnvironment isEmpty ifTrue: [^self].	warnStream		nextPutAll: (#WarningPackage1sNnotBeLoadedNN &lt;&lt; #store 					&gt;&gt; 'Warning: Package "&lt;1s&gt;" cannot be loaded.&lt;n&gt;&lt;n&gt;' 						expandMacrosWith: toPackage name);		nextPutAll: (#TheFollowingClassesCkageBeingLoaded &lt;&lt; #store 					&gt;&gt; 'The following classes cannot be loaded because their environment is not in the image nor in the package being loaded:  ') 						asString;		cr.	classesWithNoEnvironment do: 			[:cls | 			warnStream 				nextPutAll: (#_1sEnvironmentPath2sN &lt;&lt; #store 						&gt;&gt; '    &lt;1s&gt; (environment path: &lt;2s&gt;)&lt;n&gt;' expandMacrosWith: cls name							with: cls environmentString)].	warnStream cr</body><body package="Store-Repository Access">classWarning: warnStream 	classes isEmpty ifTrue: [^self].	classes do: 			[:cls | 			| pkg |			pkg := Registry containingPackageForClass: cls.			warnStream				nextPutAll: '    ';				nextPutAll: cls name.			pkg isNil 				ifTrue: 					[warnStream 						nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store								&gt;&gt; ' (already loaded but not packaged)') asString]				ifFalse: 					[warnStream 						nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name)].			warnStream cr].	warnStream cr</body><body package="Store-Repository Access">dataWarning: warnStream 	"Write to the warnStream a message describing which data overlap."	| writeHeader |	writeHeader := true.	dataDict keysAndValuesDo: 			[:ns :meths | 			( nameSpaces includes: ns ) 				ifFalse: 					[| pkgDict unpkg |					writeHeader 						ifTrue: 							[warnStream								nextPutAll: (#AffectedData &lt;&lt; #store &gt;&gt; 'Affected Data') asString;								cr;								nextPutAll: '-------------';								cr.							writeHeader := false].					pkgDict := IdentityDictionary new.					unpkg := OrderedCollection new.					meths do: 							[:dataKey | 							| pkg keys |							pkg := Registry containingPackageForDataKey: dataKey nameSpace: ns.							keys := pkg isNil 										ifTrue: [unpkg]										ifFalse: 											[pkgDict at: pkg ifAbsent: [pkgDict at: pkg put: OrderedCollection new]].							keys add: dataKey].					warnStream 						nextPutAll: (#DataFromClass1pN &lt;&lt; #store &gt;&gt; '    data from class &lt;1p&gt;:&lt;n&gt;' 								expandMacrosWith: ns).					pkgDict keysAndValuesDo: 							[:pkg :keys | 							keys do: 									[:aKey | 									warnStream										nextPutAll: '        ';										nextPutAll: aKey.									warnStream 										nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name); cr]].					unpkg do: 							[:aKey | 							warnStream								nextPutAll: '        ';								nextPutAll: aKey.							warnStream 								nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store 										&gt;&gt; ' (already loaded but not packaged)') asString.							warnStream cr]]].	writeHeader ifFalse: [warnStream cr]</body><body package="Store-Repository Access">methodWarning: warnStream 	"Write to the warnStream a message describing which methods overlap."	| writeHeader |	writeHeader := true.	methodDict keysAndValuesDo: 			[:cls :meths | 			( classes includes: (cls isMeta ifTrue: [ cls soleInstance ] ifFalse: [ cls ] ) ) 				ifFalse: 					[| pkgDict unpkg |					writeHeader 						ifTrue: 							[warnStream								nextPutAll: (#AffectedMethods &lt;&lt; #store &gt;&gt; 'Affected Methods') asString;								cr;								nextPutAll: '----------------';								cr.							writeHeader := false].					pkgDict := IdentityDictionary new.					unpkg := OrderedCollection new.					meths do: 							[:selector | 							| pkg sels |							pkg := Registry containingPackageForSelector: selector class: cls.							sels := (pkg == nil or: [pkg isNullPackage]) 										ifTrue: [unpkg]										ifFalse: 											[pkgDict at: pkg ifAbsent: [pkgDict at: pkg put: OrderedCollection new]].							sels add: selector].					warnStream 						nextPutAll: (#MethodsFromClass1pN &lt;&lt; #store &gt;&gt; '    methods from class &lt;1p&gt;:&lt;n&gt;' expandMacrosWith: cls).					pkgDict keysAndValuesDo: 							[:pkg :sels | 							sels do: 									[:aSel | 									warnStream										nextPutAll: '        ';										nextPutAll: aSel.									warnStream 										nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name).									warnStream cr]].					unpkg do: 							[:aSel | 							warnStream								nextPutAll: '        ';								nextPutAll: aSel.							warnStream 								nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store										&gt;&gt; ' (already loaded but not packaged)') asString.							warnStream cr]]].	methodDict isEmpty ifFalse: [warnStream cr]</body><body package="Store-Repository Access">nameSpaceEnvironmentProblemWarning: warnStream 	nameSpacesWithNoEnvironment isEmpty ifTrue: [^self].	warnStream		nextPutAll: ((#WarningPackage1sNnotBeLoadedNN &lt;&lt; #store &gt;&gt; 'Warning: Package "&lt;1s&gt;" cannot be loaded.&lt;n&gt;&lt;n&gt;') 					expandMacrosWith: toPackage name);		nextPutAll: (#TheFollowingNamespacCkageBeingLoaded &lt;&lt; #store &gt;&gt; 'The following namespaces cannot be loaded because their environment&lt;n&gt; is not in the image nor in the package being loaded:  ') 					expandMacros;		cr.	nameSpacesWithNoEnvironment do: 			[:ns | 			warnStream				nextPutAll: ((#_1sEnvironmentOf2s &lt;&lt; #store &gt;&gt; '    &lt;1s&gt; (environment of &lt;2s&gt;)') expandMacrosWith: ns name							with: ns environmentString);				cr].	warnStream cr</body><body package="Store-Repository Access">nameSpaceWarning: warnStream 	nameSpaces isEmpty ifTrue: [^self].	nameSpaces do: 			[:ns | 			| pkg |			pkg := Registry containingPackageForNameSpace: ns.			warnStream				nextPutAll: '    ';				nextPutAll: ns fullName.			pkg == nil 				ifTrue: 					[warnStream nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store &gt;&gt; ' (already loaded but not packaged)') asString]				ifFalse: 					[warnStream 						nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name)].			warnStream cr].	warnStream cr</body><body package="Store-Repository Access">overlapWarning: warnStream 	warnStream		nextPutAll: (#WarningOverlappingPackages &lt;&lt; #store 					&gt;&gt; 'Warning: Overlapping packages') asString;		cr;		nextPutAll: '-----------------------';		cr.	warnStream 		nextPutAll: (#_1sThePackageToErThan2sNN &lt;&lt; #store 				&gt;&gt; '"&lt;1s&gt;", the package to be loaded, contains method and/or class definitions which already exist in the image, but in packages other than "&lt;2s&gt;".&lt;n&gt;&lt;n&gt;' 					expandMacrosWith: toPackage name					with: toPackage name).	warnStream 		nextPutAll: (#ProceedingWillDeleteRomPackage1s &lt;&lt; #store 				&gt;&gt; 'Proceeding will delete the overlapping classes along with their methods and load the classes and methods from package "&lt;1s&gt;".  ' 				expandMacrosWith: toPackage name).	warnStream 		nextPutAll: (#ThePackagesCurrentlyPackage1sNN &lt;&lt; #store 				&gt;&gt; 'The packages currently containing the definitions will be modified and the newly loaded definitions will be in package "&lt;1s&gt;".&lt;n&gt;&lt;n&gt;' 					expandMacrosWith: toPackage name)</body><body package="Store-Repository Access">stopDialog	| warnStream theText |	warnStream := WriteStream on: (String new: 300).	self superclassProblemWarning: warnStream.	self classEnvironmentProblemWarning: warnStream.	self nameSpaceEnvironmentProblemWarning: warnStream.	theText := warnStream contents.	^LoadAnalysisError raiseRequestErrorString: theText</body><body package="Store-Repository Access">superclassProblemWarning: warnStream 	classesWithoutSuper isEmpty ifTrue: [^self].	warnStream		nextPutAll: (#WarningPackage1sNnotBeLoadedNN &lt;&lt; #store 					&gt;&gt; 'Warning: Package "&lt;1s&gt;" cannot be loaded.&lt;n&gt;&lt;n&gt;' 						expandMacrosWith: toPackage name);		nextPutAll: (#TheFollowingClassesAckageBeingLoaded &lt;&lt; #store 					&gt;&gt; 'The following classes cannot be loaded because their superclasses are neither in the image nor in the package being loaded: ') 						asString;		cr.	classesWithoutSuper do: 			[:cls | 			warnStream 				nextPutAll: (#_1sSubclassOf2sN &lt;&lt; #store 						&gt;&gt; '    &lt;1s&gt; (subclass of &lt;2s&gt;)&lt;n&gt;' expandMacrosWith: cls name							with: cls superclass)].	warnStream cr</body><body package="Store-Repository Access">warnDialog	| warnStream theText dialog |	warnStream := WriteStream on: (String new: 300).	self overlapWarning: warnStream.	self nameSpaceWarning: warnStream.	self classWarning: warnStream.	self methodWarning: warnStream.	self dataWarning: warnStream.	theText := warnStream contents asValue.	dialog := SimpleDialog new.	dialog builder aspectAt: #text put: theText.	^dialog openFrom: (UISpecification from: self class warningSpec)</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>accessing</category><body package="Store-Repository Access">classes: aClassList 	"Given a list of non-meta class definitions to be loaded (in the form of classes 	not  connected to the system (alien classes) or ClassDescriptions). 	Filter this list for classes which are loaded and in a different package. 	Set 'classes' to be these loaded classes. 	Also, into classesWithoutSuper put all classes to be loaded whose 	superclass is not in the image and is not in the package to be loaded."	"Contains hack 	Contrary to the comment, this method is sometimes given a list 	of MetaClasses. In this case we check if the class side is in the 	image."	self needsMoreWork.	classes := IdentitySet new.	classesWithoutSuper := IdentitySet new.	aClassList do: 		[ :each | 		self checkClassOrNameSpace: each absoluteName asClassNameOnly asSymbol.		each isMeta			ifFalse: 				[ self checkSuperClass: each against: aClassList.				self checkEnvironment: each against: #()				]			].</body><body package="Store-Repository Access">classes: aClassList nameSpaces: aNameSpaceList	"Given a list of non-meta class definitions to be loaded (in the form of classes 	not  connected to the system (alien classes) or ClassDescriptions).  And	NameSpaceDescriptions.	Filter these lists for classes/namespaces which are loaded and in a different package. 	Set 'classes' / 'namespaces' to be these loaded classes. 	Also, into classesWithoutSuper put all classes to be loaded whose 	superclass is not in the image and is not in the package to be loaded.	Into classesWithoutNameSpaces, namespaceWithoutNameSpaces-	all the classes/namespaces whose namespace is not in the image or the	package to be loaded."	"Contains hack 	Contrary to the comment, this method is sometimes given a list 	of MetaClasses. In this case we check if the class side is in the 	image. (??)"	self needsMoreWork. 	aClassList do: 		[ :each |		self checkClassOrNameSpace: each absoluteName asClassNameOnly asSymbol.		each isMeta			ifFalse: 				[ self checkSuperClass: each against: aClassList.				self checkEnvironment: each against: aNameSpaceList.				]		].	aNameSpaceList do:		[ : each | 			self checkClassOrNameSpace: each absoluteSymbol.		self checkEnvironment: each against: aNameSpaceList		].</body><body package="Store-Repository Access">dataTT: aCollectionOfDBData 	"Given a list of data definitions to be loaded (in the form of 	a collection of DataElements).	Set 'dataDict' to be a dictionary mapping classes to	a collection of dataKeys which are already loaded. We already 	know they are in a different package, since this one is empty."self needsMoreWork. "ripple clone"	dataDict := IdentityDictionary new.	aCollectionOfDBData do: 		[:each | 		| dataKey ownerName |		dataKey := each dataKey.		ownerName := each environmentString.		( toPackage includesDataKey: dataKey ownerName: ownerName )			ifFalse: 				[ | owner |				owner := each owner.				owner notNil ifTrue: [self add: owner dataKey: dataKey ]				]		].</body><body package="Store-Repository Access">datumArrays: aCollectionOfDatumArrays 	self needsMoreWork.  "ripple clone"</body><body package="Store-Repository Access">leafItems	leafItems == nil		ifTrue: 			[ leafItems := withinBundle == nil				ifTrue: [ Set new ]				ifFalse: [ withinBundle leafItems collect: [ :p | p name ] ]			].	^leafItems</body><body package="Store-Repository Access">methodArrays: aCollectionOfMethodArrays 	"Given a list of method definitions to be loaded (in the form of 	selector/compiledMethod/protocol triples).	Set 'methodDict' to be a dictionary mapping classes to	a collection of selectors which are already loaded. We already 	know they are in a different package, since this one is empty."	aCollectionOfMethodArrays do: 		[ :each |   | selector cName cls tcls |		selector := each at: 1.		tcls := (each at: 2) mclass.		cName := ( tcls isMeta						ifTrue: [ tcls soleInstance ]						ifFalse: [ tcls ]					) name.		cls := cName asStrictReference valueOrDo: [nil].		cls notNil			ifTrue: 				[ cls := tcls isMeta							ifTrue: [ cls class ]							ifFalse: [ cls ].				( cls includesSelector: selector )					ifTrue: 						[ | meths |						meths := methodDict at: cls ifAbsent: [ methodDict at: cls put: OrderedCollection new ].						meths add: selector						]				]		]</body><body package="Store-Repository Access">methodsTT: aCollectionOfDBMethods 	"Given a list of method definitions to be loaded (in the form of 	a collection of Method).	Set 'methodDict' to be a dictionary mapping classes to	a collection of selectors which are already loaded. We already 	know they are in a different package, since this one is empty."	aCollectionOfDBMethods		do: 			[:each | 			| selector cName |			selector := each selector.			cName := each className.			(toPackage				includesSelector: selector				className: cName				meta: each isMeta)				ifFalse: 					[| cls |					cls := each myClass.					cls notNil ifTrue: [self addClass: cls selector: selector ]]].</body><body package="Store-Repository Access">nameSpaces: aNameSpaceList	"Given a list of namespaces to be loaded produce a list of alien ns 	NameSpaceDescriptions.	Filter this list for namespaces which are loaded and in a different package. 	Set 'namespaces' to be these loaded namespaces. 	Also, into namespaceWithoutNameSpaces-	all the namespaces whose namespace is not in the image or the	package to be loaded."	aNameSpaceList do: 		[ : each | 	self checkEnvironment: each against: aNameSpaceList ].</body><body package="Store-Repository Access">toPackage: aPackageModel	toPackage := aPackageModel</body><body package="Store-Repository Access">wholePackage: aBoolean	wholePackage := aBoolean</body><body package="Store-Repository Access">withinBundle: aBundle	withinBundle := aBundle</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>public</category><body package="Store-Repository Access">loadCanProceed	^self loadCanProceed: false.</body><body package="Store-Repository Access">loadCanProceed: queryBoolean	classesWithoutSuper isEmpty &amp; classesWithNoEnvironment isEmpty &amp; nameSpacesWithNoEnvironment isEmpty 		ifFalse: [^self proceedToLoad].	^self checkOverrides: queryBoolean</body><body package="Store-Repository Access">loadWarnings	"Answer true if user appoved load depite warnings."	"obsoleted  by overrides"	| result |	( ( classes isEmpty ) &amp; ( nameSpaces isEmpty )			&amp; ( methodDict isEmpty ) &amp; ( dataDict isEmpty ) )		ifTrue: [ ^true ].	result := self warnDialog.	result  		ifTrue: [ self removeClasses ]. 	^result</body><body package="Store-Repository Access">proceedToLoad	"A loading error has occurred. Check out setting AbstractPundleLoader.LoadFailedOption whether to continue loading.	- #loadButNotify = Complete the load but open a tool to manage errors	- #load = Ignore errors and load what can be loaded	- #displayDialog = Open a dialog to ask what to do	- #fail = Load only if there are no errors"	| option |	(option := AbstractPundleLoader loadFailOption) = #fail		ifTrue: 			[self stopDialog.			^false].	^option = #displayDialog		ifTrue: [Dialog confirm: #LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?']		ifFalse: [true	"option demands to continue and handle problems later"]</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>private</category><body package="Store-Repository Access">add: owner dataKey: dataKey 	( owner includesDataKey: dataKey )		ifTrue: 			[ | data |			data := dataDict at: owner ifAbsent: [ dataDict at: owner put: OrderedCollection new ].			data add: dataKey			]</body><body package="Store-Repository Access">addClass: cls selector: selector 	 | meths pkg |	( cls includesSelector: selector )		ifTrue: 			[ pkg := Registry containingPackageForSelector: selector class: cls.			( ( pkg == nil ) or: [ self leafItems includes: pkg name ] )				ifFalse:					[ meths := methodDict at: cls ifAbsent: 						[ methodDict at: cls put: OrderedCollection new ].					meths add: selector					].			]</body><body package="Store-Repository Access">checkClassOrNameSpace: aName		"Add classes to classes (and namespaces namespaces ) that: 		1) are not contained in toPackage and 2) are in the image"	( toPackage includesDefinitionOf: aName )		ifFalse: 			[ | obj pkg |			pkg := Registry containingPackageForSymbol: aName asSymbol.			pkg == nil				ifFalse: [ ( self leafItems includes: pkg name ) ifTrue: [ ^self ] ].			obj := aName asStrictReference valueOrDo: [ nil ].			obj == nil 				ifFalse: 	[ obj isForNameSpace ifTrue: [ nameSpaces add: obj ] ifFalse: [ classes add: obj ] ]			].</body><body package="Store-Repository Access">checkEnvironment: model against: aNameSpaceList		"Check the superclass of the class. If it exists, or is in the image, ok.		Otherwise put the class into classesWithoutSuper."	| envName |	envName := model environmentString.	( envName == nil or: [ envName isEmpty ] )		ifTrue: [ ^self ].	( toPackage includesNameSpaceNamed: envName )		ifTrue: [ ^self ].	( ( envName asStrictReference isDefined ) or: 		[ aNameSpaceList contains: [ :ns | ns absoluteName = envName ] ]	) ifFalse: 		[ model isForNameSpace			ifTrue: [  nameSpacesWithNoEnvironment add: model ]			ifFalse: [ classesWithNoEnvironment add: model ].		].</body><body package="Store-Repository Access">checkSuperClass: classModel against: aClassList		"Check the superclass of the class. If it exists, or is in the image, ok.		Otherwise put the class into classesWithoutSuper."	| superName |	superName := classModel superclass.	( superName = 'nil' or: 			[ ( superName asStrictReference isDefined ) or: 				[ aClassList contains: [ : clsRecord | clsRecord absoluteName = superName ] ]			] )  ifFalse: [ classesWithoutSuper add: classModel ].</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>overrides</category><body package="Store-Repository Access">checkOverrides: queryBoolean	"Answer true if ok to continue, or false if the user canceled.	If queryBoolean is true,  the user will be queried, otherwise, all will be overriden.""	( self validateClassAndNameSpaceOverlaps: queryBoolean )		ifFalse: [ ^false ].	( self validateMethodOverlaps: queryBoolean )		ifFalse: [ ^false ].	( self validateStaticOverlaps: queryBoolean )		ifFalse: [ ^false ].	self registerOverrides."	^true</body><body package="Store-Repository Access">registerOverrides	"Load is continuing.... register the packages overrides."	overrides do:		[ :assoc | Override installOverride: assoc value for: assoc key ].</body><body package="Store-Repository Access">validateClassAndNameSpaceOverlaps: queryBoolean	"Answer true if user validates class redefinitions."	| coll pname |	( coll := nameSpaces copy ) addAll: classes.     	coll do: 		[ :obj | |  action |		action := queryBoolean			ifTrue: 				[ | pkg message |				pkg := Registry containingPackageForSymbol: obj absoluteSymbol.				pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].				message := (#_1sIsAlreadyDefinedIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is already defined in &lt;2s&gt;')					expandMacrosWith: obj fullName with: pname.				Override overrideReplaceOrCancel: message 				]			ifFalse: 				[ pname = Registry nullPackageName 							ifTrue: [ #replace ] ifFalse: [ #override ].				].		action == #cancel  			ifTrue: [ ^false ].		action == #override			ifTrue: [ overrides add: ( obj -&gt; ( Override forClassOrNameSpace: obj ) ) ]		].	^true.</body><body package="Store-Repository Access">validateMethodOverlaps: queryBoolean	"Answer true if user validates method redefinitions."	| action |	methodDict keysAndValuesDo: 		[ :cls :meths | 		( classes includes: ( cls instanceBehavior ) )			ifFalse: 				[ | pkgDict pname |				pkgDict := IdentityDictionary new.				meths do: 					[ :selector | 	| pkg sels |					pkg := Registry containingPackageForSelector: selector class: cls.					pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].					sels := pkgDict at: pname ifAbsent: [ pkgDict at: pname put: OrderedCollection new ].					sels add: selector					].				pkgDict keysAndValuesDo: 					[ :pkgName :sels | 					sels do: 						[:aSel | 						action := queryBoolean							ifTrue: 								[ | message |								message := (#_1s2sIsAlreadyDefinedIn3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&gt;&gt;&lt;2s&gt; is already defined in &lt;3s&gt;')									expandMacrosWith: cls fullName with: aSel with: pkgName.								Override overrideReplaceOrCancel: message 								]							ifFalse: 								[ pkgName = Registry nullPackageName 										ifTrue: [ #replace ] ifFalse: [ #override ].								].					action == #cancel  						ifTrue: [ ^false ].					action == #override						ifTrue: [ overrides add: ( aSel -&gt; ( Override forSelector: aSel class: cls ) ) ].						 ]					].			]		].	^true</body><body package="Store-Repository Access">validateStaticOverlaps: queryBoolean	"Answer true if user validates method redefinitions."	| action |	dataDict keysAndValuesDo: 		[ :owner :keys |  | pkgDict pname |		pkgDict := IdentityDictionary new.		keys do: 			[ :key | 	| pkg coll |			pkg := Registry containingPackageForDataKey: key symbol: owner absoluteSymbol.			pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].			coll := pkgDict at: pname ifAbsent: [ pkgDict at: pname put: OrderedCollection new ].			coll add: key			].		pkgDict keysAndValuesDo: 			[ :pkgName :coll | 			coll do: 				[:key | 				action := queryBoolean					ifTrue: 						[ | message |						message := (#S_1s2sIsAlreadyDefinedIn3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; is already defined in &lt;3s&gt;')							expandMacrosWith: owner fullName with: key with: pkgName.						Override overrideReplaceOrCancel: message 						]					ifFalse: 						[ pkgName = Registry nullPackageName 								ifTrue: [ #replace ] ifFalse: [ #override ].						].			action == #cancel  				ifTrue: [ ^false ].				action == #override			ifTrue: [ overrides add: ( key -&gt; ( Override forDataKey: key in: owner ) ) ].				 ]			].		].	^true</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>analysis</category><body package="Store-Repository Access">canLoadClass: aClassRecord from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: ( Array with: aClassRecord );		nameSpaces: Array new;		methodsTT: Array new;		dataTT: Array new.	^la loadCanProceed</body><body package="Store-Repository Access">canLoadClass: aClass methods: aTTMethodList data: aTTDatumList from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: (aClass isNil ifTrue: [Array new] ifFalse: [Array with: aClass]);		methodsTT: aTTMethodList;		dataTT: aTTDatumList.	^la loadCanProceed</body><body package="Store-Repository Access">canLoadDatum: aTTDatum from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: (Array new);		methodsTT: (Array new);		dataTT: (Array with: aTTDatum).	^la loadCanProceed</body><body package="Store-Repository Access">canLoadMethod: aTTMethod from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: (Array new);		methodsTT: (Array with: aTTMethod);		dataTT: (Array new).	^la loadCanProceed</body><body package="Store-Repository Access">canLoadNameSpace: aNameSpace data: aTTDatumList from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		nameSpaces: (aNameSpace isNil ifTrue: [Array new] ifFalse: [Array with: aNameSpace]);		dataTT: aTTDatumList.	^la loadCanProceed</body><body package="Store-Repository Access">canLoadNameSpace: aNameSpaceRecord from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: Array new;		nameSpaces: ( Array with: aNameSpaceRecord );		methodsTT: Array new;		dataTT: Array new.	^la loadCanProceed</body><body package="Store-Repository Access">checkUninstalledForPackage: aPackage classes: uninstalledClasses methods: uninstalledMethods data: uninstalledData	"Determine why the uninstalled can't be installed and display a message box informing the user."	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: uninstalledClasses;		nameSpaces: Array new;		methodsTT: uninstalledMethods;		dataTT: uninstalledData.	^la loadCanProceed</body><body package="Store-Repository Access">preDBLoadOverlapCheckOf: aPackage classes: aTTClassList nameSpaces: aTTNameSpaceList methods: aTTMethodList data: aTTDatumList	^self new		toPackage: aPackage; 		classes:  aTTClassList nameSpaces: aTTNameSpaceList; 		methodsTT: aTTMethodList;		dataTT: aTTDatumList;		loadCanProceed</body><body package="Store-Repository Access">preDBLoadOverlapCheckOf: aPackage within: aBundle classes: aTTClassList nameSpaces: aTTNameSpaceList methods: aTTMethodList data: aTTDatumList	^self new	 	toPackage: aPackage; 		withinBundle: aBundle;		classes:  aTTClassList nameSpaces: aTTNameSpaceList; 		methodsTT: aTTMethodList;		dataTT: aTTDatumList;		loadCanProceed</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>instance creation</category><body package="Store-Repository Access">new	^super new initialize</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>accessing</category><body package="Store-Publishing Support">binarySave	^self first binarySave</body><body package="Store-Publishing Support">parcelSave	^self first parcelSave</body><body package="Store-Publishing Support">pundle	^self first pundle</body><body package="Store-Publishing Support">version	^self first version</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>publishing</category><body package="Store-Publishing Support">applySpec: aPublishSpecification	| blessing pundle |	aPublishSpecification publish ifFalse: [^self].	self copyPundleIfNecessaryIn: aPublishSpecification.	pundle := aPublishSpecification pundle.	pundle version: aPublishSpecification version.	(pundle isPackage and: [aPublishSpecification binarySave]) ifTrue: [self prepareBinaryIn: pundle].	blessing := StoreBlessing				newForBlessingLevel: aPublishSpecification blessing				comment: aPublishSpecification comment asString.	pundle bless: blessing.	pundle timestamp: (Dialect storeTimestampIn: publisher targetSession)</body><body package="Store-Publishing Support">copyPundleIfNecessaryIn: aPublishSpecification	"If the image pundle wasn't modified, then we will have a reference to an existing database record, rather than something new to publish. Now we're being told to publish it anyway, so make a new version and replace it in any containing bundle"	| oldPundle newPundle |	aPublishSpecification pundle primaryKey isNil ifTrue: [^self].	oldPundle := aPublishSpecification pundle.	newPundle := oldPundle storeModel asNewStorePundleIn: oldPundle session.	self replacePundle: oldPundle with: newPundle in: aPublishSpecification.</body><body package="Store-Publishing Support">fillEmptyCommentsFromParent	"Look at the spec list and determine any publish spec which have empty comments where there is also a spec for the containing bundle 	that does have comment. When found, copy said bundle comment down."		| modifiedSpecs bundleSpecs subSpecs |	modifiedSpecs := self select: [:each | each modified].	bundleSpecs := modifiedSpecs select: [:each | each pundle isBundle].	bundleSpecs isEmpty ifTrue: [^self].	bundleSpecs		reverseDo:			[:eachBundleSpec | 			eachBundleSpec comment isEmpty				ifFalse:					[subSpecs := modifiedSpecs						select: [:eachSpec | eachBundleSpec pundle allContainedItems includes: eachSpec pundle].					subSpecs						do: [:eachSpec | eachSpec comment isEmpty ifTrue: [eachSpec comment: eachBundleSpec comment]]]]</body><body package="Store-Publishing Support">fillEmptyCommentsWith: aStringOrNil	"Look at the spec list and determine any publish spec which have empty comments. When found, insert the argument aStringOrNil"	(aStringOrNil notNil and: [aStringOrNil notEmpty]) 		ifTrue: [			self do: [:each | 				(each publish and: [each comment isEmpty])					ifTrue: [each comment: aStringOrNil]]]</body><body package="Store-Publishing Support">prepareBinaryIn: aStorePackage		| packageModel |	aStorePackage isBundle ifTrue: [^self].	packageModel := aStorePackage storeModel.	packageModel propertyAt: #packageName put: packageModel name.	aStorePackage binFile: ''</body><body package="Store-Publishing Support">publishBlessing	"Create new blessing/comment records for each item marked for publication."		| published session |	published := IdentitySet new.	session := self first pundle isGlorpObject		ifTrue: [self first pundle session]		ifFalse: [StoreLoginFactory currentStoreSession].	publisher := StorePundleWriter newForSession: session.	[self reverseDo:		[:eachSpecification | 		| pundle |		pundle := eachSpecification pundle.		(published includes: pundle) ifFalse:			[published add: pundle.			eachSpecification setPublisher: publisher.			eachSpecification publishBlessing ifFalse: [^false]]]] 				on: Error 				do: [:exception | exception return: false].	^true</body><body package="Store-Publishing Support">publishParcel	self pundle storeModel saveAsParcelFromSpecs: self first</body><body package="Store-Publishing Support">publishPundle	| pundle |	(Publishing for: self) started.	pundle := self publishSilently.	self updateRelatedIntegratedVersions.		(Publishing for: self) finished.	^pundle</body><body package="Store-Publishing Support">publishPundles	^self publishPundlesIn: nil</body><body package="Store-Publishing Support">publishPundlesForMerge	| session |	session := StoreLoginFactory currentStoreSession.	session inTransactionDo:		[self reverseDo: 			[:each |			(Publishing for: each) started.			each 				publishSilentlyUsingSession: session 				informativeBlessing: (MergeTool downgradeBlessingOnMerge not and: 					[MergeTool informativeBlessingsOnly or: 					[((each pundleModel parentRecord currentBlessingLevel ifNil: [100]) &lt; each blessing) not]]).			self markAsPublishedAnyMatching: each.			(Publishing for: each) finished]]</body><body package="Store-Publishing Support">publishPundlesIn: aSession	| session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	session inTransactionDo:		[self reverseDo: 			[:each |			(Publishing for: each) started.			each 				publishSilentlyUsingSession: session 				informativeBlessing: false.			self markAsPublishedAnyMatching: each.			each updateRelatedIntegratedVersions.				(Publishing for: each) finished]]</body><body package="Store-Publishing Support">publishSilently	"Publish the list in reverse order. Answer true if all went well.	As we publish each one, we go and make sure that any duplicate items in the list don't get published a second time" 	| newPundle targetPundles |	publisher := self first publisher.	DbRegistry clearPundleCaches.	publisher ifNil: 		[publisher := StorePundleWriter newForSession: StoreLoginFactory currentStoreSessionForPublishing].	self do: 		[:each | 		| pundleModel |		pundleModel := each pundleModel.		each binarySave ifFalse:			[pundleModel runPreSave.			pundleModel isBundle ifFalse:				[pundleModel allDefinedClasses do: [:eachClass | eachClass preSave: pundleModel]]]].	^[(self allButFirst: 1) reverseDo: 		[:each | 		each publishSilently. 		self markAsPublishedAnyMatching: each].	targetPundles := self updateStorePundleItems.	newPundle := [publisher writePundle: self pundle withChangesBasedOn: self pundle storeModel using: targetPundles]		on: GlorpDatabaseWriteError		do: 			[:exception |			StorePublishingError raiseErrorString: exception messageText.			exception return: nil].	newPundle ifNil: [^nil].	newPundle applyPundleVersionsToTheImage: false.	self parcelSave ifTrue: [self publishParcel].	newPundle ifNotNil: [newPundle storeModel markNotModified].	newPundle] value</body><body package="Store-Publishing Support">replace: oldPundle with: newPundle in: containingPundle	containingPundle isBundle ifFalse: [^self].	containingPundle isImageModel ifTrue: [^self].	containingPundle bundles		keysAndValuesDo:			[:eachKey :eachValue | 			eachValue storeModel = newPundle storeModel				ifTrue: [containingPundle bundles at: eachKey put: newPundle]].	containingPundle packages		keysAndValuesDo:			[:eachKey :eachValue | 			eachValue storeModel = newPundle storeModel				ifTrue: [containingPundle packages at: eachKey put: newPundle]].</body><body package="Store-Publishing Support">replacePundle: oldPundle with: newPundle in: aPublishSpecification	aPublishSpecification privateSetDbPundle: newPundle.	aPublishSpecification binarySave ifTrue: [self prepareBinaryIn: aPublishSpecification pundle].	self do:		[:each | 		self			replace: oldPundle			with: newPundle			in: each pundle].</body><body package="Store-Publishing Support">updatePundleIn: aPublishSpecification to: newPundle	"Update our pundles just in case anything changed in the image since they were created."	| oldPundle |	oldPundle := aPublishSpecification dbPundle asStorePundleIn: publisher targetSession.	self replacePundle: oldPundle with: newPundle in: aPublishSpecification.</body><body package="Store-Publishing Support">updateRelatedIntegratedVersions	"This must be called AFTER the related publish is complete, never before"	self do: [:eachPublishSpecification| eachPublishSpecification updateRelatedIntegratedVersions].</body><body package="Store-Publishing Support">updateStorePundleItems	| currentPundle currentPundleItems targetPundles |	currentPundle := self pundle storeModel asStorePundleIn: publisher targetSession.	currentPundleItems := currentPundle withAllContainedItems.	targetPundles := OrderedCollection new.	self do: 		[:eachSpec |		| eachPundle |		eachSpec publish ifTrue: 			[eachPundle := currentPundleItems 				detect: [:each | each storeModel = eachSpec dbPundle storeModel] 				ifNone: [nil].			eachPundle ifNotNil: 				[targetPundles add: eachPundle.				eachSpec binarySave 					ifTrue: [self prepareBinaryIn: eachPundle]					ifFalse: [eachPundle isPackage ifTrue: [eachPundle binFile: nil]].				self updatePundleIn: eachSpec to: eachPundle]]].	self do: [:each | self applySpec: each].	^targetPundles</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>testing</category><body package="Store-Publishing Support">isConsistentForPublishing	^self allSatisfy: #isConsistentForPublishing</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>private</category><body package="Store-Publishing Support">markAsPublishedAnyMatching: aPublishSpecification	aPublishSpecification publish: false.	(self select: [:each | each ~= aPublishSpecification and: [aPublishSpecification pundleModel = each pundleModel]]) 		do: [:each | each publish: false]</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>instance creation</category><body package="Store-Publishing Support">filesFromBundle: imageOrDatabaseBundle	| list specs |	list := self new.	imageOrDatabaseBundle fileDescriptions do: 		[:fileRec| 		specs := PublishFileSpecification new file: fileRec.		specs level: 2. 		list add: specs].	^list</body><body package="Store-Publishing Support">fromBundle: aBundleModel	| topLevelSpecification instance binaryPublishedPackages |	(topLevelSpecification := self specificationClass pundle: aBundleModel)		publish: true;		modified: true.	aBundleModel mergeInformation ifNotNil:		[:value | 		topLevelSpecification comment: value blessingComment.		topLevelSpecification blessing: value blessingLevel].	instance := self with: topLevelSpecification.	binaryPublishedPackages := self getBinaryPublishedPackagesIn: aBundleModel.	aBundleModel descriptionsAndLevels do: 		[:eachDescriptionAndLevel |		| pundleModel pundleDescription publishSpecification |		pundleDescription := eachDescriptionAndLevel at: 1.		pundleModel := pundleDescription component.		(Gathering for: pundleModel) started.		publishSpecification := self specificationClass pundle: pundleModel binary: (binaryPublishedPackages includes: pundleModel).		publishSpecification description: pundleDescription.		pundleModel mergeInformation ifNotNil:			[:value | 			publishSpecification comment: value blessingComment.			publishSpecification blessing: value blessingLevel].		publishSpecification level: eachDescriptionAndLevel last.		instance add: publishSpecification.		(Gathering for: pundleModel) finished].	((instance allButFirst: 1) allSatisfy: [:each | each binarySave])		ifTrue: [instance do: [:each | each binarySave: true]].	^instance</body><body package="Store-Publishing Support">fromBundle: aBundleModel in: aSession	| topLevelSpecification instance binaryPublishedPackages |	(topLevelSpecification := self specificationClass pundle: aBundleModel in: aSession)		publish: true;		modified: true.	aBundleModel mergeInformation ifNotNil:		[:value | 		topLevelSpecification comment: value blessingComment.		topLevelSpecification blessing: value blessingLevel].	instance := self with: topLevelSpecification.	binaryPublishedPackages := self getBinaryPublishedPackagesIn: aBundleModel in: aSession.	aBundleModel descriptionsAndLevels do: 		[:eachDescriptionAndLevel |		| pundleModel pundleDescription publishSpecification |		pundleDescription := eachDescriptionAndLevel at: 1.		pundleModel := pundleDescription component.		(Gathering for: pundleModel) started.		publishSpecification := self specificationClass 			pundle: pundleModel			binary: (binaryPublishedPackages includes: pundleModel)			in: aSession.		publishSpecification description: pundleDescription.		pundleModel mergeInformation ifNotNil:			[:value | 			publishSpecification comment: value blessingComment.			publishSpecification blessing: value blessingLevel].		publishSpecification level: eachDescriptionAndLevel last.		instance add: publishSpecification.		(Gathering for: pundleModel) finished].	((instance allButFirst: 1) allSatisfy: [:each | each binarySave])		ifTrue: [instance do: [:each | each binarySave: true]].	^instance</body><body package="Store-Publishing Support">fromDbBundle: aBundleOrStoreBundle	| list trace traceItems masterPublishSpecification |	list := self with: (masterPublishSpecification := self specificationClass pundle: aBundleOrStoreBundle).	masterPublishSpecification		publish: true;		modified: true.	(trace := aBundleOrStoreBundle parentRecord) isNil		ifTrue: [traceItems := Set new]		ifFalse: [traceItems := trace allItems].	aBundleOrStoreBundle uniqueItemsAndLevels do: 		[:pair |		| pundle publishSpecification |		pundle := pair first.		publishSpecification := self specificationClass pundle: pundle.		publishSpecification			modified: (traceItems contains: [:each | each primaryKey = aBundleOrStoreBundle primaryKey]);			description: pundle;			version: pundle version;			parentVersion: pundle version;			level: pair last;			yourself.		list add: publishSpecification].	^list</body><body package="Store-Publishing Support">fromPundles: aCollectionOfPundleModel	| instance |	instance := self new.	aCollectionOfPundleModel do:		[:each |		each isBundle 			ifTrue: 				[instance addAll: (self fromBundle: each)]			ifFalse: 				[ | spec |				instance add: (spec := (self specificationClass pundle: each)					publish: true;					modified: true).				each mergeInformation ifNotNil:					[:value | 					spec comment: value blessingComment.					spec blessing: value blessingLevel]]].	^instance</body><body package="Store-Publishing Support">fromPundles: aCollectionOfPundleModel comments: aCollectionOfComments defaultBlessing: anInteger	| publishSpecificationList |	publishSpecificationList := self new: aCollectionOfPundleModel size.	1 to: aCollectionOfPundleModel size do: 		[:index |		| publishSpecification |		publishSpecification := self specificationClass pundle: (aCollectionOfPundleModel at: index).		Policies mergePolicy shouldPublishAll			ifTrue: [publishSpecification publish: true].		publishSpecification blessing: anInteger.		publishSpecification comment: (aCollectionOfComments at: index).		publishSpecificationList add: publishSpecification].	^publishSpecificationList</body><body package="Store-Publishing Support">fromPundles: aCollectionOfPundleModel in: aSession	| instance |	instance := self new.	aCollectionOfPundleModel do:		[:each |		each isBundle 			ifTrue: 				[instance addAll: (self fromBundle: each in: aSession)]			ifFalse: 				[ | spec |				instance add: (spec := (self specificationClass pundle: each)					publish: true;					modified: true).				each mergeInformation ifNotNil:					[:value | 					spec comment: value blessingComment.					spec blessing: value blessingLevel]]].	^instance</body><body package="Store-Publishing Support">getBinaryPublishedPackagesIn: aBundleModel in: aSessionOrNil	| packagesPublishedBinary session packageKeys results |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	packageKeys := (aBundleModel descriptionsAndLevels				collect: [:each | each first isPackage ifTrue: [each first id] ifFalse: [nil]])					select: #notNil.	results := OrderedCollection new: packageKeys size.	1 to: packageKeys size		by: 100		do: 			[:index |			| subsetKeys query |			subsetKeys := packageKeys copyFrom: index						to: (index + 99 min: packageKeys size).			query := Query read: Store.Glorp.StorePackage						where: [:eachPundle | (eachPundle id in: subsetKeys) &amp; eachPundle parcel beOuterJoin id notNil].			query retrieve: [:each | each id].			results addAll: (session execute: query)].	packagesPublishedBinary := Set new: packageKeys size * 2.	aBundleModel descriptionsAndLevels do: 			[:each |			| pundleDesc |			pundleDesc := each first.			pundleDesc isPackage				ifTrue: 					[(results includes: pundleDesc id)						ifTrue: [packagesPublishedBinary add: pundleDesc component]]].	^packagesPublishedBinary</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>constants</category><body package="Store-Publishing Support">specificationClass	^PublishSpecification</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>deprecated</category><body package="Store-Publishing Support">getBinaryPublishedPackagesIn: aBundleModel	| packagesPublishedBinary session packageKeys results |	session := StoreLoginFactory currentStoreSession.	packageKeys := (aBundleModel descriptionsAndLevels				collect: [:each | each first isPackage ifTrue: [each first id] ifFalse: [nil]])					select: #notNil.	results := OrderedCollection new: packageKeys size.	1 to: packageKeys size		by: 100		do: 			[:index |			| subsetKeys query |			subsetKeys := packageKeys copyFrom: index						to: (index + 99 min: packageKeys size).			query := Query read: Store.Glorp.StorePackage						where: [:eachPundle | (eachPundle id in: subsetKeys) &amp; eachPundle parcel beOuterJoin id notNil].			query retrieve: [:each | each id].			results addAll: (session execute: query)].	packagesPublishedBinary := Set new: packageKeys size * 2.	aBundleModel descriptionsAndLevels do: 			[:each |			| pundleDesc |			pundleDesc := each first.			pundleDesc isPackage				ifTrue: 					[(results includes: pundleDesc id)						ifTrue: [packagesPublishedBinary add: pundleDesc component]]].	^packagesPublishedBinary</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>comparing</category><body package="Store-Database Model">&lt;= aVersionlessPundle	self precedence &lt;= aVersionlessPundle precedence ifFalse: [^false].	^name &lt;= aVersionlessPundle name</body><body package="Store-Database Model">packageFirstOrder: aVersionlessPundle	"Sort by name, but packages first"	self precedence &gt;= aVersionlessPundle precedence ifFalse: [^false].	^name &lt;= aVersionlessPundle name</body><body package="Store-Database Model">precedence	^self subclassResponsibility.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>accessing</category><body package="Store-Database Model">basicComment	comment = nil ifTrue: [^nil].	^comment isEmpty ifTrue: [nil] ifFalse: [comment first].</body><body package="Store-Database Model">comment	self basicComment isNil ifTrue: [^''].	^self basicComment source</body><body package="Store-Database Model">comment: anObject	comment := anObject</body><body package="Store-Database Model">name	^name</body><body package="Store-Database Model">name: anObject	name := anObject</body><body package="Store-Database Model">properties	^self versions first properties.</body><body package="Store-Database Model">versionComment	^self comment.</body><body package="Store-Database Model">versions	^versions</body><body package="Store-Database Model">versions: anObject	versions := anObject</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>printing</category><body package="Store-Database Model">displayString	^name.</body><body package="Store-Database Model">printOn: aStream	aStream nextPutAll: self name.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>testing</category><body package="Store-Database Model">isBundle	^false.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle class</class-id> <category>constants</category><body package="Store-Database Model">isBundle	^false.</body><body package="Store-Database Model">pundleClass	^self subclassResponsibility.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPackage</class-id> <category>comparing</category><body package="Store-Database Model">precedence	^2</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPackage</class-id> <category>testing</category><body package="Store-Database Model">isBundle	^false.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPackage class</class-id> <category>constants</category><body package="Store-Database Model">pundleClass	^StorePackage.</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>private</category><body package="Store-UI-Graphs">listChange	self setButtons.	self updateText.	^true.			"multi-lists  must answer true/false"</body><body package="Store-UI-Graphs">perspective	^#tt_ownsAdjacent</body><body package="Store-UI-Graphs">privilegeManager	^StoreAccessPrivilege</body><body package="Store-UI-Graphs">setButtons	"Set the enablement of the buttons. There must be a selection in both lists."	"Enable only when both a user and package are selected. Sets if the user does not	already have rights for any package selected. Revoke only if has rights for all packages selected."		| set revoke owner |	owner := userGroupList selection.	(owner isNil or: [packageList selections size &lt; 1])		ifTrue: [set := revoke := false]		ifFalse:			[set := true.			revoke := true.			packageList selections do:			[:each | 			(self privilegeManager privilegeForUser: owner pundle: each) isNil				ifTrue:					[set := set &amp; true.					revoke := false]				ifFalse:					[revoke := revoke &amp; true.					set := false]]].	(builder componentAt: #assignOwner) widget isEnabled: set.	(builder componentAt: #grantRead) widget isEnabled: set.	(builder componentAt: #grantPublish) widget isEnabled: set.	(builder componentAt: #revokeRights) widget isEnabled: revoke</body><body package="Store-UI-Graphs">setTextTo: aString 	self privilegeText value: aString.</body><body package="Store-UI-Graphs">updateGraph		| focus cache |	focus := Set new.	cache := Dictionary new.	packageList selection notNil ifTrue: 		[focus add: (PackageOwnerElement element: packageList selection cache: cache)].	userGroupList selection notNil ifTrue: 		[focus add: (PackageOwnerElement element: userGroupList selection cache: cache)].	self graphView focus: focus</body><body package="Store-UI-Graphs">updateGraphPLAY		| focus cache |	focus := Set new.	cache := Dictionary new.	packageList selection notNil ifTrue: 		[focus add: (PackageOwnerElement element: packageList selection cache: cache)].	userGroupList selection notNil ifTrue: 		[focus add: (StoreUserGroup userNamed: userGroupList selection)].	self graphView focus: focus</body><body package="Store-UI-Graphs">updatePackageList		| packages |	packages := Store.Registry allPackages.	StorePackage allNames do: 		[:name | 		(packages contains: [:each | each name = name]) ifFalse: [packages add: (StorePackage newNamed: name)]].	self packageList list: (packages asSortedCollection: [:a :b | a name &lt; b name]) asOrderedCollection</body><body package="Store-UI-Graphs">updateText		| stream privileges |	stream := (String new: 100) writeStream.	privileges := OrderedCollection new.	userGroupList selection notNil ifTrue: 		[privileges addAll: (self privilegeManager allPrivilegesForUser: userGroupList selection)].	packageList selections size &gt; 0 		ifTrue: [packageList selections do: [:each | privileges addAll: (self privilegeManager allPrivilegesForPundle: each)]].	privileges asSet asSortedCollection do:		[:each | 		stream			nextPutAll: each fullDescription;			cr].	self setTextTo: stream contents</body><body package="Store-UI-Graphs">updateUserGroupList	| users |	users := StoreUserGroup allDistinctUserGroups asSet.	users addAll: StoreAccessPrivilege allDistinctUserGroups.	userGroupList list: users asSortedCollection asOrderedCollection.</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>actions</category><body package="Store-UI-Graphs">assignOwner	self grant: #owner</body><body package="Store-UI-Graphs">grant: aSymbol		| owner |	owner := userGroupList selection.	packageList selections do: 		[:each | self privilegeManager grant: aSymbol to: owner for: each].	self updateText.	self setButtons</body><body package="Store-UI-Graphs">grantPublish	self grant: #publish</body><body package="Store-UI-Graphs">grantRead	self grant: #read</body><body package="Store-UI-Graphs">revokeRights		| owner |	owner := userGroupList selection.	packageList selections do: 		[:each | self privilegeManager revokeAllFor: owner for: each].	self updateText.	self setButtons</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>aspects</category><body package="Store-UI-Graphs">packageList	^packageList isNil		ifTrue: [ packageList := MultiSelectionInList new ]		ifFalse: 	[ packageList ]</body><body package="Store-UI-Graphs">privilegeText	^privilegeText isNil		ifTrue: [ privilegeText := String new asValue ]		ifFalse: 	[ privilegeText ]</body><body package="Store-UI-Graphs">userGroupList	^userGroupList isNil		ifTrue: [ userGroupList := SelectionInList new ]		ifFalse: 	[ userGroupList ]</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	(self widgetAt: #userGroupListID) displayStringSelector: #userName.</body><body package="Store-UI-Graphs">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	self updateUserGroupList.	self updatePackageList.	self setButtons.	self updateText.	self mainWindow label: #PackageUserGroupPrivliges &lt;&lt; #store &gt;&gt; 'Package - User / Group Privileges'</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs">initializePerspectives	"self initializePerspectives"	^List new 		add: ( ( Array new: 9 )			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: 	#(#(#V1 #F1 'tt_owns' true true false true true) 						   #(#F1 #V2 'tt_owns' true true false true true) );			at: 4 put: #arrLabelHints:;			at: 5 put: #();			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_owns';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue purple;					at: 5 put: 1; yourself);  yourself);			at: 8 put: #name:;			at: 9 put: #tt_ownsAdjacent; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs">initializeRelationships	"self initializeRelationships"	^List new 		add: #( #LDMFirstOrderRel #name: 'tt_owns'  #description: 'owns'  					#reverse: nil  #token: #tt_ownsRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_ownsR' #description: 'is owned' 					#reverse: nil #token: #tt_ownsRRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_read'  #description: 'reads'  					#reverse: nil  #token: #tt_readRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_readR' #description: 'is read' 					#reverse: nil #token: #tt_readRRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_publish'  #description: 'can publish'  					#reverse: nil  #token: #tt_publish ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_publishR' #description: 'can be published' 					#reverse: nil #token: #tt_publishRRel ) decodeAsLiteralArray; 		yourself</body></methods><methods><class-id>Store.Glorp.StorePundleNavigatorPart</class-id> <category>updating widgets</category><body package="StoreForGlorpBrowserUI">addBindingPackages: aNavigatorState to: pundles 	aNavigatorState classesAndNameSpaces do: 		[:each | 		self 			addPackagesIfAbsent: (self environment packagesContaining: each)			to: pundles]</body><body package="StoreForGlorpBrowserUI">addSharedVariablePackages: aNavigatorState to: pundles 	navigator showOnlyFiltered ifFalse: [^self].	aNavigatorState classesAndNameSpaces do:		[:each | 		| packages |		packages := self environment packagesContaining: each.		self addPackagesIfAbsent: packages to: pundles]</body></methods><methods><class-id>Store.ShadowedObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">package	^package</body><body package="Atomic Compiling and Loading">packageModel	^package storeModel</body><body package="Atomic Compiling and Loading">shadowCompiledDefinition	^shadowCompiledDefinition</body><body package="Atomic Compiling and Loading">storeObject	^storeObject</body></methods><methods><class-id>Store.ShadowedObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading">compileWith: anAtomicAnalysisLoader	self subclassResponsibility</body><body package="Atomic Compiling and Loading">gatherInto: anAtomicAnalysisLoader	self subclassResponsibility</body><body package="Atomic Compiling and Loading">installWith: anAtomicAnalysisLoader	self subclassResponsibility</body></methods><methods><class-id>Store.ShadowedObject</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isForClass	^false</body><body package="Atomic Compiling and Loading">isForMethod	^false</body><body package="Atomic Compiling and Loading">isForNamespace	^false</body><body package="Atomic Compiling and Loading">isForSharedVariable	^false</body></methods><methods><class-id>Store.ShadowedObject</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize	override := false.</body><body package="Atomic Compiling and Loading">initializeFrom: aStoreObjectInPackage	package := aStoreObjectInPackage package.	storeObject := aStoreObjectInPackage.</body></methods><methods><class-id>Store.ShadowedObject class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new	^super new initialize</body><body package="Atomic Compiling and Loading">newFrom: aStoreObjectInPackage	^self new initializeFrom: aStoreObjectInPackage</body><body package="Atomic Compiling and Loading">newFrom: aStoreObject in: aStorePackage	^self new initializeFrom: (aStoreObject asStoreObjectInPackage: aStorePackage)</body></methods><methods><class-id>Store.PrerequisiteUnableToLoadConfirmation</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	^Dialog confirm: messageText</body></methods><methods><class-id>Store.PrerequisiteUnableToLoadConfirmation</class-id> <category>constants</category><body package="Store-Base">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="Store-Base">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.PrerequisiteUnableToLoadConfirmation class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>ShadowPundleCompileManager</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $&lt;;		nextPutAll: pundle name;		nextPut: $&gt;.</body></methods><methods><class-id>ShadowPundleCompileManager</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">compilationManager	^compilationManager</body><body package="Atomic Compiling and Loading">compilationManager: anObject	compilationManager := anObject</body><body package="Atomic Compiling and Loading">notificationQueue	^notificationQueue</body><body package="Atomic Compiling and Loading">notificationQueue: anObject	notificationQueue := anObject</body><body package="Atomic Compiling and Loading">pundle	^pundle</body><body package="Atomic Compiling and Loading">pundle: anObject	pundle := anObject</body><body package="Atomic Compiling and Loading">root	^compilationManager root</body></methods><methods><class-id>ShadowPundleCompileManager class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">component	^pundle</body><body package="Atomic Compiling and Loading">externalClassesNeedingRecompile	^externalClassesNeedingRecompile</body><body package="Atomic Compiling and Loading">externalClassesNeedingRecompile: aCollection	externalClassesNeedingRecompile := aCollection</body><body package="Atomic Compiling and Loading">isAtomicallyLoadable		isAtomicallyLoadable isNil ifTrue: [isAtomicallyLoadable := true].	^isAtomicallyLoadable</body><body package="Atomic Compiling and Loading">isAtomicallyLoadable: aBoolean		isAtomicallyLoadable := aBoolean</body><body package="Atomic Compiling and Loading">methodsMovedFromOriginalBinding	^methodsMovedFromOriginalBinding</body><body package="Atomic Compiling and Loading">needsEarlyInstall	^needsEarlyInstall ifNil: [false]</body><body package="Atomic Compiling and Loading">overrides		^overrides</body><body package="Atomic Compiling and Loading">package	^pundle</body><body package="Atomic Compiling and Loading">package: anObject	pundle := anObject</body><body package="Atomic Compiling and Loading">packageDifferences	^packageComparitor</body><body package="Atomic Compiling and Loading">parentManager: ignore</body><body package="Atomic Compiling and Loading">shadowAt: aPath	^(self root		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body><body package="Atomic Compiling and Loading">shadowCompiler	^compilationManager shadowCompiler</body><body package="Atomic Compiling and Loading">shadowedObjects	^shadowObjects</body><body package="Atomic Compiling and Loading">unloadableDefinitions	^unloadableDefinitions</body><body package="Atomic Compiling and Loading">unloadableDefinitions: anObject	unloadableDefinitions := anObject</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>private</category><body package="Atomic Compiling and Loading">addToShadowed: anObject	shadowObjects addLast: anObject</body><body package="Atomic Compiling and Loading">collectShadowedRedefinition: aNotification	"We need to capture the overrides as the system notifies of them.  Unfortunately, the overrides	 are not in a state that is installable.  We will fix that later."		| targetOverride |	targetOverride := aNotification override.	targetOverride isForMethod ifTrue: 		[overrides add: targetOverride.		compilationManager setOverriddenForMethod: targetOverride].	targetOverride isForClass ifTrue: 		[(overrides includes: targetOverride) ifFalse:			[overrides add: targetOverride.			targetOverride actual ifNotNil: [RedefinitionOfClass raiseRequestWith: targetOverride]].		(overrides includes: targetOverride) ifFalse: [overrides add: targetOverride].		compilationManager setOverriddenForClass: targetOverride].	targetOverride isForNameSpace ifTrue: 		[overrides add: targetOverride.		RedefinitionOfClass raiseRequestWith: targetOverride].	aNotification resume</body><body package="Atomic Compiling and Loading">compileAllToShadow	"Compile all the packages definitions into shadow.	First the Namespaces, Classes and Shared (data) in that order, then the methods"	(Compiling for: pundle) started.	(Array with: pundle nameSpaces with: pundle classes with: pundle data)		do: [:eachColl |			eachColl do: [:eaStoreObjectInPackage | self shadowDefinedRecord: eaStoreObjectInPackage]].	self compileMethodRecords: pundle methodsWithSource.	(Compiling for: pundle) finished</body><body package="Atomic Compiling and Loading">compileDeltasToShadow	"Compile the deltas between the pundle and the image into shadow."		| pundleModel |	(pundle primaryKey = (pundleModel := pundle getImagePundle) dbTrace and: [pundleModel hasBeenModified not]) ifTrue: [^self].	packageComparitor := PackageComparitor differencesBetween: pundle and: pundleModel.	packageComparitor hasDifferences ifFalse: [^self].	(Compiling for: pundle) started.	(Array with: packageComparitor mainPackageNamespaces 			with: (StorePackage superclassOrder: packageComparitor mainPackageClasses)			with: packageComparitor mainPackageShareds)		do: [:eachColl|			eachColl do: [:eaStoreObjectInPackage | self shadowDefinedRecord: eaStoreObjectInPackage]].	self compileMethodRecords: packageComparitor mainPackageMethods.	(self willClassRemovalAffectAnotherPackage: pundleModel) ifTrue: [needsEarlyInstall := true].	(Compiling for: pundle) finished</body><body package="Atomic Compiling and Loading">compileMethodRecords: aCollectionOfMethodRecords	"Because SystemUtils class&gt;&gt;#sortForLoading: will rely on #prerequisitesForLoading to determine	 prerequisites, we want to sort those methods out first and compile the ahead of time. "		| groupedMethodRecords |	groupedMethodRecords := aCollectionOfMethodRecords groupedBy: 		[:each | each isMeta and: [each selector = #prerequisitesForLoading]].	(groupedMethodRecords at: true ifAbsent: [Array new]) do: 		[:each | self shadowDbMethod: each].	(self sortMethodsForLoading: (groupedMethodRecords at: false ifAbsent: [Array new])) do: 		[:each | self shadowDbMethod: each]</body><body package="Atomic Compiling and Loading">realFromShadow: aShadowedObject	"Looks up aShadowedObject in the real world and answers it, or nil if it doesn't exist. 		Works for NameSpaces and Classes."	| real shadowObject |	aShadowedObject ifNil: [^nil].	shadowObject := aShadowedObject isBehavior		ifTrue: [aShadowedObject instanceBehavior]		ifFalse: [aShadowedObject].	real := shadowObject absoluteName asStrictReference 		ifDefinedDo: [:value | value]		elseDo: [^nil].	^(aShadowedObject isBehavior and: [aShadowedObject isMeta])		ifTrue: [real class]		ifFalse: [real]</body><body package="Atomic Compiling and Loading">willClassRemovalAffectAnotherPackage: pundleModel	"Are there classes NOT in my package that are subclasses of any class that I need to remove from myself"		^packageComparitor sortedClassesToRemoveAfterLoad anySatisfy:		[:each | 		each correspondingImageClass notNil and: 			[each correspondingImageClass subclasses anySatisfy: 				[:eachSubclass | (Registry packageForClass: eachSubclass) name ~= pundleModel name]]]</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initializeWith: aCompilationManager		compilationManager := aCompilationManager.	shadowObjects := OrderedCollection new.	overrides := OrderedCollection new.	externalClassesNeedingRecompile := OrderedCollection new.	methodsMovedFromOriginalBinding := OrderedCollection new.	needsEarlyInstall := false.	isAtomicallyLoadable := true</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>actions</category><body package="Atomic Compiling and Loading">atomicCompileWith: aCompilationManager	"I was invoked by the UI (or directly) compile (or if binary, just binary load), and then answer back either nil or the compilation result?"	| result redefines |	compilationManager := aCompilationManager.	(pundle preCompileWith: aCompilationManager) ifFalse: [^nil].	(pundle binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]) ifTrue: 		[compilationManager installEarlyAndReInitialize.		compilationManager reinitializeShadowRoot.		^pundle binLoadWithin: nil using: compilationManager].	redefines := OrderedCollection new.	result := [[SystemUtils modifySystem: [self compile]]		on: RedefinitionOfClass		do: 			[:notification |			(redefines includes: notification parameter)				ifFalse: 					[compilationManager installEarlyAndReInitialize.					compilationManager reinitializeShadowRoot.					redefines add: notification parameter.					notification restart]				ifTrue: 					[notification resume]]]			on: NoDLLCCNotification			do: 				[:notification |				compilationManager installEarlyAndReInitialize.				compilationManager reinitializeShadowRoot.				notification restart].	result ifNotNil: 		[aCompilationManager addResult: result.		result needsEarlyInstall ifTrue: [aCompilationManager installEarlyWith: result]].	^result</body><body package="Atomic Compiling and Loading">basicCompileWithOnDoHandlingWith: isNew		^[[[isNew 		ifTrue: [self compileAllToShadow] 		ifFalse: [self compileDeltasToShadow].	self recompileMethods]		on: UnloadableDefinitionError		do:			[:exception | 			unloadableDefinitions add: exception.			exception resume]]					on: RedefinitionNotification					do: [:notification | self collectShadowedRedefinition: notification]]</body><body package="Atomic Compiling and Loading">compile	"Compile the package definitions into shadow space"		| isNew result block |	(isNew := pundle getImagePundle isNil) ifTrue: [pundle runPreRead ifFalse: [^nil]].	unloadableDefinitions := OrderedCollection new.	block := self basicCompileWithOnDoHandlingWith: isNew.	#{ExternalInterfaceTypeDefinitionCompiled} 		ifDefinedDo: [:value | self dllccBasedExceptionHandlerUsing: block with: value] 		elseDo: [block value].	result := AtomicCompilationResult from: self.	self hasChangesToLoad ifTrue:		[self processUnloadables: result.		result isFullyLoaded ifFalse: [^self shouldTryToLoad ifTrue: [result] ifFalse: [nil]]].	^result</body><body package="Atomic Compiling and Loading">compileUnloadables: aCollectionOfUnloadableDefinitionErrors	"Atttempt to compile the unloadableDefinitions definitions into shadow space"		unloadableDefinitions := OrderedCollection new.	[aCollectionOfUnloadableDefinitionErrors do:		[:each | 		| definitionRecord |		definitionRecord := each definitionRecord.		definitionRecord isForMethod			ifTrue: [self shadowDbMethod: definitionRecord]			ifFalse: [self shadowDefinedRecord: definitionRecord]]]				on: UnloadableDefinitionError				do:					[:exception | 					unloadableDefinitions add: exception.					exception resume].	^AtomicCompilationResult from: self</body><body package="Atomic Compiling and Loading">dllccBasedExceptionHandlerUsing: block with: value		^block		on: value		do:			[:notification | 			| class |			class := notification parameter.			(externalClassesNeedingRecompile includes: class) ifFalse: 				[externalClassesNeedingRecompile add: notification parameter].			notification resume]</body><body package="Atomic Compiling and Loading">processUnloadables: result		| comp newResult |	result isFullyLoaded ifTrue: [^self].	(Compiling for: pundle) started.	comp := self class newWith: self compilationManager.	comp package: result package.	newResult := [comp compileUnloadables: result unloadableDefinitions]		on: RedefinitionNotification		do: [:notification | notification resume].	result unloadableDefinitions: newResult unloadableDefinitions.	newResult shadowedObjects do: [:each | self addToShadowed: each].	newResult shadowedObjects notEmpty		ifTrue: [self processUnloadables: result].	(Compiling for: pundle) finished</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>compiling</category><body package="Atomic Compiling and Loading">augment: shadowClass usingBehaviorCompiler: compiler		| newMethod |	newMethod := (Behavior compiledMethodAt: #compilerClass) copy.	newMethod		at: 1		put: (ValueHolder new value: compiler).	shadowClass replaceMethodAt: #compilerClass withMethod: newMethod</body><body package="Atomic Compiling and Loading">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass instanceBehavior == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: [(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]				ifFalse: [(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copy]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copy]].</body><body package="Atomic Compiling and Loading">extractCompilerFrom: aClassOrMetaClass andPutInto: aShadowClass	"If aClassOrMetaClass (the real not shadowed class) is NOT nil, then we don't have to touch it."	| workingShadow realOrNil method |	workingShadow := aShadowClass.	[realOrNil := self realFromShadow: workingShadow.	workingShadow := workingShadow ifNotNil: [:value | value superclass].	(realOrNil isNil and: [workingShadow isNil]) ifTrue: [^self].	(self leaveCompilerAloneWithRegardTo: realOrNil) ifTrue: [^self].	(method := self compilerMethodInShadow: workingShadow orRealClassDefinesCompiler: realOrNil) notNil] whileFalse.	aShadowClass isMeta		ifTrue: [aShadowClass replaceMethodAt: #classCompilerClass withMethod: method]		ifFalse: [aShadowClass class replaceMethodAt: #compilerClass withMethod: method]</body><body package="Atomic Compiling and Loading">leaveCompilerAloneWithRegardTo: realOrNil	^(realOrNil notNil and: [realOrNil instanceBehavior == Object])		or: [realOrNil notNil and: [realOrNil instanceBehavior includesBehavior: SmalltalkCompiler]]</body><body package="Atomic Compiling and Loading">methodClassFor: aMethodRecord	"Return the class for which this method will be installed. If it's a new class, return the shadow, if it's an existing class, return that. If neither can be found, it's unloadable."		| methodClass |	methodClass := aMethodRecord correspondingImageClass		ifNil: [self shadowCompiler findInShadow: aMethodRecord className asClassNameOnly asStrictReference]		ifNotNil: [:value | value instanceBehavior].	^methodClass isNil		ifTrue:			[| msg |			msg := AbstractPundleLoader unloadableMethodMessageForUnloadedClass: aMethodRecord className.			self raiseUnloadableError: msg for: aMethodRecord]		ifFalse: [aMethodRecord isMeta ifTrue: [methodClass class] ifFalse: [methodClass]]</body><body package="Atomic Compiling and Loading">raiseUnloadableError: exceptionOrString for: aStoreObjectInPackage	"Return nil for convenience of callers, who will call this and wish to return (with nil) from wherever they are in checking the unload state and cause."	| unloadableError |	unloadableError := Store.UnloadableDefinitionError		for: aStoreObjectInPackage		inPackage: aStoreObjectInPackage package		error: exceptionOrString.	unloadableError raise.	^nil</body><body package="Atomic Compiling and Loading">recompileMethods	"Recompile all of the methods in the class to try and eliminate any ordering dependencies between them.	A sneaky way to find the compiled methods without using isKindOf:"	shadowObjects := shadowObjects collect:		[:each | 		(each isLikeNameSpace or: [each isBindingReference])			ifTrue: [each]			ifFalse: 				[| selector |				selector := each selector.				(each mclass compiledMethodAt: selector ifAbsent: [nil]) ifNotNil:					[[[each mclass recompileForSunshine: selector from: each mclass]						on: Error						do: [:exception | exception return]]							on: UserNotification							do: 								[:notification |								notification isResumable									ifTrue: [notification resume]									ifFalse: [notification return]].					each mclass compiledMethodAt: selector]]].</body><body package="Atomic Compiling and Loading">shadowDbMethod: aMethodRecord	"Convert aMethodRecord into an object in shadow root."		| realWorldClass selector shadowClass |	realWorldClass := aMethodRecord correspondingImageClass.	(shadowClass := self shadowCompiler findInShadow: aMethodRecord className asClassNameOnly asStrictReference) ifNil:		[realWorldClass ifNil: 			[| msg |			msg := AbstractPundleLoader unloadableMethodMessageForUnloadedClass: aMethodRecord className. 			^self raiseUnloadableError: msg for: aMethodRecord].		shadowClass := self shadowCompiler createShadowClassFor: realWorldClass instanceBehavior].	aMethodRecord isMeta ifTrue: [shadowClass := shadowClass class].	self extractCompilerFrom: realWorldClass andPutInto: shadowClass.	selector := [[shadowClass		compileForShadow: aMethodRecord definitionString		classified: aMethodRecord protocol		notifying: nil		environment: (pundle environmentFor: aMethodRecord selector in: shadowClass)		attributes: nil]			on: Error			do: [:exception | 				exception class = SyntaxErrorException					ifTrue: [^self raiseUnloadableError: exception for: aMethodRecord].												exception return: nil]]				on: UserNotification				do: 					[:exception | 					exception isResumable						ifTrue: [exception resume: nil]						ifFalse: [exception return: nil]].	selector ifNil: [^self raiseUnloadableError: nil for: aMethodRecord].	self addToShadowed: (shadowClass compiledMethodAt: selector).	aMethodRecord className asClassNameOnly = shadowClass longName asClassNameOnly 		ifFalse: [methodsMovedFromOriginalBinding add: (shadowClass compiledMethodAt: selector)].</body><body package="Atomic Compiling and Loading">shadowDefinedRecord: aStoreDefinitionInPackage	"Convert aStoreDefinitionInPackage into an object in shadow root. First make sure that a class dependant has a class in shadow to be installed into."	| newDefinitionObject |	(aStoreDefinitionInPackage isForClass or: [aStoreDefinitionInPackage isForNameSpace])		ifTrue: [			(self shadowCompiler findInShadow: aStoreDefinitionInPackage environmentString asStrictReference)			 	ifNil: [ | definitionOwnerClass |					(definitionOwnerClass := Dialect smalltalkAt: aStoreDefinitionInPackage environmentString ifAbsent: [nil])						ifNil: [ | parentType msg |							parentType := aStoreDefinitionInPackage isForClass								ifTrue: ['Class']								ifFalse: ['Namespace'].														msg := AbstractPundleLoader unloadableClassOrNameSpaceMessageForMissingParent:								aStoreDefinitionInPackage environmentString type: parentType.							^self raiseUnloadableError: msg for: aStoreDefinitionInPackage].					self shadowCompiler createShadowClassOrNameSpaceFor: definitionOwnerClass.					self shadowCompiler addShadowedClassToEnvironment: definitionOwnerClass]].	aStoreDefinitionInPackage isForData		ifTrue: 			[(self shadowCompiler				findInShadow: aStoreDefinitionInPackage environmentString asStrictReference)					ifNil: 						[| definitionOwnerClass |						(definitionOwnerClass := aStoreDefinitionInPackage owner)							ifNil: [| parentType msg |								parentType := aStoreDefinitionInPackage isClassVariable									ifTrue: ['Class']									ifFalse: ['Namespace'].								msg := AbstractPundleLoader unloadableSharedMessageForMissingParent: 										aStoreDefinitionInPackage environmentString type: parentType.								^self raiseUnloadableError: msg for: aStoreDefinitionInPackage].						self shadowCompiler createShadowClassOrNameSpaceFor: definitionOwnerClass.						self shadowCompiler addShadowedClassToEnvironment: definitionOwnerClass]].	newDefinitionObject := self shadowCompiler				evaluate: aStoreDefinitionInPackage shadowLoadDefinition				with: Object evaluatorClass new				using: self.	newDefinitionObject isSignalledException		ifTrue: [^self raiseUnloadableError: newDefinitionObject for: aStoreDefinitionInPackage].	newDefinitionObject isNil		ifTrue: 			[(aStoreDefinitionInPackage isForNameSpace				and: [aStoreDefinitionInPackage name = 'Root'])					ifFalse: [self raiseUnloadableError: nil for: aStoreDefinitionInPackage]]		ifFalse: [self addToShadowed: newDefinitionObject].	^newDefinitionObject</body><body package="Atomic Compiling and Loading">sortMethodsForLoading: aMethodRecord	"Sort methods by class order, with extension methods last."	| orderedMethods methodsGroupedByClass orderedClasses absoluteClassNames classifiedMethods |	orderedMethods := OrderedCollection new.		methodsGroupedByClass := aMethodRecord groupedBy: [:each | (self methodClassFor: each) ifNil: [#none]].	methodsGroupedByClass removeKey: #none ifAbsent: [].	absoluteClassNames :=  pundle classes collect: [:each | each absoluteName asClassNameOnly].	classifiedMethods := methodsGroupedByClass keys groupedBy: 		[:each | 		| absoluteName |		absoluteName := each instanceBehavior absoluteName.		(absoluteClassNames includes: absoluteName)			ifTrue: [#defined]			ifFalse: [#extended]].	orderedClasses := (SystemUtils metaclassesFirst: (SystemUtils sortForAtomicLoading: (classifiedMethods at: #defined ifAbsent: [#()])))		addAll: (SystemUtils metaclassesFirst: (SystemUtils sortForAtomicLoading: (classifiedMethods at: #extended ifAbsent: [#()])));		yourself.	orderedClasses do: [:each | orderedMethods addAll: (methodsGroupedByClass at: each)].	^orderedMethods.</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>testing</category><body package="Atomic Compiling and Loading">hasChangesToLoad	^shadowObjects notEmpty or:		[unloadableDefinitions notEmpty or:		[packageComparitor notNil and:		[packageComparitor hasDifferences]]]</body><body package="Atomic Compiling and Loading">proceedToLoad	"Any senders of #proceedToLoad are to self, but there is no sender in this hierarchy, so we can delete the method."	self halt.	^#displayDialog = AtomicLoader loadFailOption		ifTrue: [Dialog confirm: (#LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?')]		ifFalse: [true]</body><body package="Atomic Compiling and Loading">shouldTryToLoad	^#(#loadButNotify #displayDialog #load) includes: AtomicLoader loadFailOption</body></methods><methods><class-id>ShadowPackageCompileManager class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">newForPundle: aPundle with: aCompilationManager	^self new 		initializeWith: aCompilationManager;		package: aPundle</body><body package="Atomic Compiling and Loading">newWith: aCompilationManager	^self new 		initializeWith: aCompilationManager</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>initialize-release</category><body package="Store-Repository Access">initialize	super initialize.	self tableOwnerListHolder value: 		self knownTableOwners asSortedCollection.</body><body package="Store-Repository Access">initializeAspects	super initializeAspects.	tableOwnerHolder := self profileAspect: #tableOwner.</body><body package="Store-Repository Access">postBuildWith: aBuilder	super postBuildWith: aBuilder.	( builder componentAt: #tableOwnerCombo ) 			widget controller continuousAccept: true.	self profileChanged "cause update"</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>notifications</category><body package="Store-Repository Access">profileSelected	| profile name |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name] ifNone: [^self].	currentProfileHolder value: profile copy.	DbRegistry tablePrefix: profile tableOwner.	(StoreSettings preferenceModelFor: #tablePrefix) value: profile tableOwner</body><body package="Store-Repository Access">tableOwnerChanged	self resetProfileName</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>private</category><body package="Store-Repository Access">knownTableOwners	"Collect tableOwners used in the existing connection profiles."	^(self allProfiles collect: [:each | each tableOwner]) asSet</body><body package="Store-Repository Access">resetBrowseFilesButton	"The restoreConnection call happens before the browseFiles component is defined, hence the isNil guard."	(self builder componentAt: #browseFiles) isNil ifTrue: [^self].	super resetBrowseFilesButton.</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>aspects</category><body package="Store-Repository Access">tableOwnerHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerHolder isNil		ifTrue:[ tableOwnerHolder := String new asValue ]		ifFalse:	[ tableOwnerHolder ]</body><body package="Store-Repository Access">tableOwnerListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerListHolder isNil		ifTrue: [ tableOwnerListHolder := List new asValue ]		ifFalse: 	[ tableOwnerListHolder ]</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>store</category><body package="Store-Repository Access">connectionProfileClass	"We can get away with just writing ConnectionProfile here, because both the receiver and the ConnectionProfile class we desire live are in the Store namespace.  The superclass call returns Database.ConnectionProfile, not this same-name subclass Store.ConnectionProfile."	^ConnectionProfile</body><body package="Store-Repository Access">openConnectionUsing: aProfile	"Open the dialog with aProfile and then open the database connection that was selected.	Answer the opened connection or nil if the dialog was cancelled."	| profile connection |	profile := aProfile.	[ ( profile := self openProfile: profile ) == nil		ifTrue: [ ^nil ].	connection := self connect: profile.	connection == nil.	] whileTrue.	DbRegistry updateTablePrefix: profile tableOwner.	^connection.</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>accessing</category><body package="Store-Repository Access">profiles	^RepositoryManager repositories</body></methods><methods><class-id>Store.Glorp.StoreSelectorNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">allMethodDefinitionsFor: aProtocol in: class		| selectors |	selectors := OrderedCollection new.	self		inheritedClassesOf: class		do:			[:each | 			selectors addAll: ((navigator environment selectorsFor: aProtocol in: each)				collect: [:eachSelector | StoreMethodDefinition class: class implementor: each selector: eachSelector])].	^selectors</body><body package="StoreForGlorpBrowserUI">allSelectorsIn: aNavigatorState		| selectors classes class |	classes := aNavigatorState selectedClasses.	classes size ~= 1 ifTrue: [^#()].	class := classes asArray first.	selectors := self environment selectorsForClass: class.	^selectors collect: [:each | StoreMethodDefinition class: class selector: each]</body></methods><methods><class-id>Store.Glorp.StoreSelectorNavigatorPart</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">showIcons	^false</body></methods><methods><class-id>Store.Glorp.StoreSelectorNavigatorPart</class-id> <category>private-selectors</category><body package="StoreForGlorpBrowserUI">methodDefinitionsIn: aProtocol	"Unlike our parent NavigatorPart, Store navigators for protocols and selectors do show inherited methods	so the special select my parent does just isn't needed and slows me down"		| class defs |	class := navigator selectedClass.	class isNil ifTrue: [^#()].	defs := self allMethodDefinitionsFor: aProtocol in: class.	defs isEmpty ifTrue: [^#()].	^defs</body></methods><methods><class-id>Store.FileModel</class-id> <category>testing</category><body package="Store-Publishing Support">isBundle	^false.</body><body package="Store-Publishing Support">isForFile	^true</body></methods><methods><class-id>Store.FileModel</class-id> <category>accessing</category><body package="Store-Publishing Support">asStoreObject	^self class storeDatabaseClass withPrimaryKey: self primaryKey</body><body package="Store-Publishing Support">bundle	^bundle</body><body package="Store-Publishing Support">bundle: ourBundle	bundle := ourBundle</body><body package="Store-Publishing Support">component	"Find a component named componentName and answer it."	^self</body><body package="Store-Publishing Support">dbTrace	^dbtrace</body><body package="Store-Publishing Support">dbTrace: anIneger	dbtrace := anIneger</body><body package="Store-Publishing Support">filename	^name == nil		ifTrue: [ nil ]		ifFalse: [ LogicalFilename named: name ].</body><body package="Store-Publishing Support">itemCount	^1</body><body package="Store-Publishing Support">name	^portableFilename asString	"^name asString"</body><body package="Store-Publishing Support">name: aString	name := aString asFilename.</body><body package="Store-Publishing Support">portableFilename	^portableFilename</body><body package="Store-Publishing Support">portableFilename: anObject	portableFilename := anObject</body><body package="Store-Publishing Support">primaryKey	^dbtrace</body><body package="Store-Publishing Support">textForItem	^name</body></methods><methods><class-id>Store.FileModel</class-id> <category>printing</category><body package="Store-Publishing Support">printOn: aStream	aStream nextPutAll: self class name, '(', self portableFilename asString, ')'.</body></methods><methods><class-id>Store.FileModel</class-id> <category>converting</category><body package="Store-Publishing Support">asComponentDescription	^self.</body></methods><methods><class-id>Store.FileModel class</class-id> <category>constants</category><body package="Store-Publishing Support">storeDatabaseClass	^Store.Glorp.StoreFile</body></methods><methods><class-id>Store.FileModel class</class-id> <category>instance creation</category><body package="Store-Publishing Support">from: aFilename	^super new		name: aFilename;		portableFilename: aFilename asLogicalFileSpecification;		yourself.</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^false</body><body package="Store-Merge Management">isCommentResolver	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	| nameSpace |	proposed ifNil: [^true].	proposed isRemovalResolution ifFalse: [^true].	nameSpace := self longOwnerName asQualifiedReference valueOrDo: [^false].	^(((Registry containingPackageForNameSpace: nameSpace) name = proposed package name) or: 		[Override isOverriddenClassOrNameSpace: nameSpace in: proposed package storeModel])</body><body package="Store-Merge Management">sameDefinitionAs: aString	| reference |	(reference := self ownerName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value comment = aString</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isNoOpResolution]]]) 			ifTrue: [^true].	^proposed isRemovalResolution 		ifTrue: [self applyAsRemove]		ifFalse: [self applyChange]</body><body package="Store-Merge Management">applyAsRemove	| namespace changeManager |	namespace :=  self longOwnerName asQualifiedReference valueOrDo: [^true].	refactoring := CommentChange		object: namespace		comment: ''.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingRemovalCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: false]</body><body package="Store-Merge Management">applyChange	| namespace changeManager |	namespace :=  self longOwnerName asQualifiedReference valueOrDo: [^true].	^[refactoring := CommentChange		object: namespace		comment: proposed value asString.	changeManager := RefactoryChangeManager instance.	changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: false]</body><body package="Store-Merge Management">existingDefinitionPackage	^nil</body><body package="Store-Merge Management">existingOverrides	^#()</body><body package="Store-Merge Management">hasOverrideAndShouldApply		^true</body><body package="Store-Merge Management">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	^true</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">parseText: aString		^aString notNil</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management">listIcon	^NameSpace toolListIcon</body><body package="Store-Merge Management">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">mergeDisplayName		^(#BracketNameSpaceCommentBracket &lt;&lt; #store &gt;&gt; '[NameSpace Comment]') asString</body><body package="Store-Merge Management">shortListName	| string |	string := self ownerName, ' ' , self shortTreeName.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.Gathering</class-id> <category>accessing</category><body package="Store-Base">actionText	^(#Gathering &lt;&lt; #store &gt;&gt; 'Gathering') asString</body><body package="Store-Base">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.Relinking</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">actionText	^(#Relinking &lt;&lt; #store &gt;&gt; 'Relinking') asString</body></methods><methods><class-id>Store.MismatchedDatabaseError</class-id> <category>printing</category><body package="Store-Base">defaultMessageText	| databasesString |	^parameter isNil 		ifTrue: 			[(#TheImageIsNotReconTheCurrentDatabase &lt;&lt; #store &gt;&gt; 'The image is not reconciled with the current database.') asString]		ifFalse: 			[databasesString := parameter allDatabases isEmpty				ifTrue: [(#noDatabase &lt;&lt; #store &gt;&gt; 'no database') asString]				ifFalse: [parameter allDatabases printString].			#_1sIsReconciledTo2sTheEntDatabaseIs3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is reconciled to (&lt;2s&gt;). The current database is &lt;3s&gt;.' 					expandMacrosWith: parameter name					with: databasesString					with: DbRegistry databaseIdentifier]</body></methods><methods><class-id>Store.MismatchedDatabaseError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	| answer |	parameter ifNil: 		[^Dialog warn: ((#AbortingMergen1s &lt;&lt; #dialogs &gt;&gt; 'Aborting merge.&lt;n&gt;&lt;1s&gt;') expandMacrosWith: self defaultMessageText)].	answer := (Dialog confirm: (#_1snReconcileAndContinue 		&lt;&lt; #store 		&gt;&gt; '&lt;1s&gt;&lt;n&gt;Reconcile and continue?' expandMacrosWith: self defaultMessageText)).	^answer 		ifFalse: [nil]		ifTrue: [parameter reconcileWithDb].</body></methods><methods><class-id>Store.MismatchedDatabaseError class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.Glorp.ImagePundleDisplayRow</class-id> <category>accessing</category><body package="Store-UI">pundle	^pundleModel</body><body package="Store-UI">pundleModel	^pundleModel</body><body package="Store-UI">pundleModel: anObject	pundleModel := anObject</body></methods><methods><class-id>Store.Glorp.ImagePundleDisplayRow</class-id> <category>displaying</category><body package="Store-UI">displayNotFoundInRepositoryUsingTextStyle: aTextStyle		| currentStart imageFromLabel displayRow |	currentStart := 2.	imageFromLabel := Label		with: (#NoVersionsArePublishedInThisRep &lt;&lt; #store &gt;&gt; 'No versions of ''&lt;1s&gt;'' are published in this repository &lt;2?with the current filter:&gt;' 				expandMacrosWith: self pundleModel name				with: self parentModel hasFilterSet) asText		attributes: aTextStyle		offset: currentStart @ 0.	displayRow := CompositePart new		add: imageFromLabel;		yourself.	^displayRow</body><body package="Store-UI">displayRowUsingColumnWidths: columnWidthDictionary textStyle: aTextStyle	(columnWidthDictionary at: #version) isZero ifTrue: [^self displayNotFoundInRepositoryUsingTextStyle: aTextStyle].	^(columnWidthDictionary at: #name ifAbsent: [0])  &gt; 0		ifTrue: [self displayRowWithNameUsingTextStyle: aTextStyle]		ifFalse: [self displayRowUsingTextStyle: aTextStyle].</body><body package="Store-UI">displayRowUsingTextStyle: aTextStyle	| imageFromLabel displayRow |	imageFromLabel := self imageFromLabelWith: self versionLabelText usingTextStyle: aTextStyle.	displayRow := (CompositePart new)				add: imageFromLabel;				yourself.	^displayRow</body><body package="Store-UI">displayRowWithNameUsingTextStyle: aTextStyle	| labelString imageFromLabel displayRow |	labelString := '&lt;1s&gt;  &lt;2s&gt;'		expandMacrosWith: self nameLabelText with: self versionLabelText.	imageFromLabel := self imageFromLabelWith: labelString usingTextStyle: aTextStyle.	displayRow := CompositePart new		add: imageFromLabel;		yourself.	^displayRow</body><body package="Store-UI">imageFromLabelWith: aString usingTextStyle: aTextStyle	| labelString iconPart |	labelString := '&lt;1s&gt;  &lt;2s&gt;' expandMacrosWith: (#ImageFromC &lt;&lt; #store &gt;&gt; 'Image From:') with: aString.	iconPart := LabelAndIcon		with: labelString asText		attributes: aTextStyle.	iconPart icon: GeneralIcons gear.	iconPart offset: 2 @ 0.	^iconPart</body></methods><methods><class-id>Store.Glorp.ImagePundleDisplayRow</class-id> <category>testing</category><body package="Store-UI">alwaysShow	^true</body><body package="Store-UI">useForWidthCalculations	^false</body></methods><methods><class-id>Store.Glorp.ImagePundleDisplayRow</class-id> <category>labels</category><body package="Store-UI">versionLabelText	^self pundleModel traceVersionString asText</body></methods><methods><class-id>Store.Glorp.ImagePundleDisplayRow class</class-id> <category>instance creation</category><body package="Store-UI">newFor: aPundleModel parentModel: aPundleVersionPane	^self new		pundleModel: aPundleModel;		parentModel: aPundleVersionPane</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>accessing</category><body package="Store-Difference Management">changedMethodsSharedAndProperties	"We call classPseudoDifferences, which answers a definition and comment without regard to if they are different"	^self classPseudoDifferences , self sharedAndMethodDifferences.</body><body package="Store-Difference Management">classListIcon	^Class toolListIcon</body><body package="Store-Difference Management">classListName	^mainObject isNil 		ifTrue: 			[otherObject isNil				ifTrue: 					[self methodDifferences isEmpty						ifTrue: [self sharedDifferences first classListName]						ifFalse: [self methodDifferences first classListName]]				ifFalse: [otherObject longNameFromSmalltalk]]		ifFalse: [mainObject longNameFromSmalltalk]</body><body package="Store-Difference Management">classPseudoDifferences	"Answer an OrderedCollection with PseudoClassDefinitionDifference and PseudoClassCommentDifference,	each holding the definition and comment state of the underlying class in selected package versions.	If definitions are equal, no difference holder is returned. The same is true for comment.	Both is true for class extensions which cannot have definition nor comment. The result is empty in this case."	| diffs pseudoDefinition pseudoComment |	diffs := OrderedCollection new.	pseudoDefinition := PseudoClassDefinitionDifference new.	pseudoDefinition mainPackage: mainPackage definition: self definitionForMainClass.	pseudoDefinition otherPackage: otherPackage definition: self definitionForOtherClass.	pseudoDefinition isExtensionInMain &amp; pseudoDefinition isExtensionInOther		ifTrue: [^diffs].	pseudoDefinition mainObject = pseudoDefinition otherObject		ifFalse: [diffs add: pseudoDefinition].	pseudoComment := PseudoClassCommentDifference new.	pseudoComment mainPackage: mainPackage comment: self commentForMainClass.	pseudoComment otherPackage: otherPackage comment: self commentForOtherClass.	pseudoComment mainObject = pseudoComment otherObject		ifFalse: [diffs add: pseudoComment].	^diffs</body><body package="Store-Difference Management">commentForMainClass		^self mainObject ifNotNil: 		[:value | 		value isImageObject 			ifTrue: [(mainPackage definesClassOrNameSpace: value) ifTrue: [value comment]]			ifFalse: 				[| comment |				comment := value comment.				comment asString = ((#CommentNotVisible &lt;&lt; #store &gt;&gt; 'Comment not visible') asString) ifTrue: [nil] ifFalse: [comment]]]</body><body package="Store-Difference Management">commentForOtherClass		^self otherObject ifNotNil: 		[:value | 		| comment |		comment := value comment.		comment asString = ((#CommentNotVisible &lt;&lt; #store &gt;&gt; 'Comment not visible') asString) ifTrue: [nil] ifFalse: [comment]]</body><body package="Store-Difference Management">definitionForMainClass		^self mainObject ifNotNil: 		[:value | 		value isImageObject 			ifTrue: [(mainPackage definesClassOrNameSpace: value) ifTrue: [value definitionString]]			ifFalse: [value definitionString]]</body><body package="Store-Difference Management">definitionForOtherClass		^self otherObject ifNotNil: 		[:value | 		value isImageObject 			ifTrue: [(otherPackage definesClassOrNameSpace: value) ifTrue: [value definitionString]]			ifFalse: [value definitionString]]</body><body package="Store-Difference Management">mainClass	^self mainNonImageObject ifNil:		[(self methodDifferences 			detect: [:each | each mainObject notNil and: [each mainObject owner notNil]]			ifNone: [nil]) ifNotNil: [:value | value mainObject owner instanceBehavior asStoreClassDefinition]]</body><body package="Store-Difference Management">mainClassLongName	mainObject ifNotNil: [^mainObject longName].	self methodDifferences notEmpty ifTrue:		[self sampleMainMethodDifference ifNotNil: [:value | ^value mainObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[self sampleMainSharedDifference ifNotNil: [:value | ^value mainObject classNameWithoutMeta]].	^''</body><body package="Store-Difference Management">mainClassStoreObject	| targetObject |	self mainNonImageObject ifNotNil: [^mainObject].	self methodDifferences notEmpty ifTrue:		[targetObject := self sampleMainMethodDifference.		^targetObject ifNotNil: [targetObject mainPackage objectNamed: targetObject mainObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleMainSharedDifference.		^targetObject mainPackage objectNamed: targetObject mainObject classNameWithoutMeta].	^nil</body><body package="Store-Difference Management">mainNonImageObject	^mainObject ifNotNil: [mainObject isImageObject ifTrue: [nil] ifFalse: [mainObject]]</body><body package="Store-Difference Management">mainPackage: aPackage class: aStoreClassDefinition	self mainPackage: aPackage object: aStoreClassDefinition</body><body package="Store-Difference Management">mainPackage: aPackage method: aStoreMethod	| targetDifference |	targetDifference := self methodDifferenceAt: aStoreMethod selector meta: aStoreMethod isMeta ifAbsent: [nil].	targetDifference notNil		ifTrue: [targetDifference mainPackage: aPackage method: aStoreMethod]		ifFalse: [self methodDifferenceAt: aStoreMethod selector meta: aStoreMethod isMeta 							put: (PseudoMethodDifference mainPackage: aPackage method: aStoreMethod)]</body><body package="Store-Difference Management">mainPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference mainPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference mainPackage: aPackage shared: aStoreSharedVariable]</body><body package="Store-Difference Management">methodDifferenceAt: aSelector meta: aBoolean ifAbsent: aBlock	^self methodDifferenceDictionary		at: (Array with: aSelector with: aBoolean)		ifAbsent: aBlock</body><body package="Store-Difference Management">methodDifferenceAt: aSelector meta: aBoolean put: aPseudoMethodDifference	^self methodDifferenceDictionary		at: (Array with: aSelector with: aBoolean)		put: aPseudoMethodDifference</body><body package="Store-Difference Management">methodDifferenceDictionary	^methodDifferenceDictionary</body><body package="Store-Difference Management">methodDifferences	^self methodDifferenceDictionary values</body><body package="Store-Difference Management">modifiedClassPseudoDifferences	| pseudoDefinition pseudoComment trueDifferences otherDefinition |	trueDifferences := OrderedCollection new: 2.	self definitionForMainClass = (otherDefinition := self otherObject ifNotNil: [:value | value definitionString]) ifFalse:		[pseudoDefinition := PseudoClassDefinitionDifference new.		pseudoDefinition mainPackage: mainPackage definition: self definitionForMainClass.		pseudoDefinition otherPackage: otherPackage definition: otherDefinition.		trueDifferences add: pseudoDefinition].	self commentForMainClass = self commentForOtherClass ifFalse:		[pseudoComment := PseudoClassCommentDifference new.		pseudoComment mainPackage: mainPackage comment: self commentForMainClass.		pseudoComment otherPackage: otherPackage comment: self commentForOtherClass.		trueDifferences add: pseudoComment].	^trueDifferences</body><body package="Store-Difference Management">modifiedMethodsSharedAndProperties	"Answer the truly modified differences."	| classDifferences |	^(classDifferences := self classPseudoDifferences) notEmpty		ifTrue: [classDifferences, self sharedAndMethodDifferences]		ifFalse: [self sharedAndMethodDifferences].</body><body package="Store-Difference Management">otherClass	^otherObject ifNil:		[(self methodDifferences 			detect: [:each | each otherObject notNil and: [each otherObject owner notNil]]			ifNone: [nil]) ifNotNil: [:value | value otherObject owner instanceBehavior asStoreClassDefinition]]</body><body package="Store-Difference Management">otherClassLongName	otherObject ifNotNil: [^otherObject longName].	self methodDifferences notEmpty ifTrue:		[self sampleOtherMethodDifference ifNotNil: [:value | ^value otherObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[self sampleOtherSharedDifference ifNotNil: [:value | ^value otherObject classNameWithoutMeta]].	^''</body><body package="Store-Difference Management">otherClassStoreObject	| targetObject |	otherObject ifNotNil: [^otherObject].	self methodDifferences notEmpty ifTrue:		[targetObject := self sampleOtherMethodDifference.		targetObject ifNotNil: [^targetObject otherPackage objectNamed: targetObject otherObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleOtherSharedDifference.		targetObject ifNotNil: [^targetObject otherPackage objectNamed: targetObject otherObject classNameWithoutMeta]].	^nil</body><body package="Store-Difference Management">otherPackage: aPackage class: aStoreClassDefinition	self otherPackage: aPackage object: aStoreClassDefinition</body><body package="Store-Difference Management">otherPackage: aPackage method: aStoreMethod	| targetDifference |	targetDifference := self methodDifferenceAt: aStoreMethod selector meta: aStoreMethod isMeta ifAbsent: [nil].	targetDifference notNil		ifTrue: [targetDifference otherPackage: aPackage method: aStoreMethod]		ifFalse: [self methodDifferenceAt: aStoreMethod selector meta: aStoreMethod isMeta 							put: (PseudoMethodDifference otherPackage: aPackage method: aStoreMethod)]</body><body package="Store-Difference Management">otherPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference otherPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference otherPackage: aPackage shared: aStoreSharedVariable].	otherPackage ifNil: [otherPackage := aPackage].</body><body package="Store-Difference Management">referencesHolderClass 	^ClassResolutions</body><body package="Store-Difference Management">sampleMainMethodDifference		^self methodDifferences detect: [:each | each mainObject notNil] ifNone: [nil]</body><body package="Store-Difference Management">sampleMainSharedDifference		^self sharedDifferences detect: [:each | each mainObject notNil] ifNone: [nil]</body><body package="Store-Difference Management">sampleOtherMethodDifference		^self methodDifferences detect: [:each | each otherObject notNil] ifNone: [nil]</body><body package="Store-Difference Management">sampleOtherSharedDifference		^self sharedDifferences detect: [:each | each otherObject notNil] ifNone: [nil]</body><body package="Store-Difference Management">sharedDifferences	sharedDifferences ifNil: [sharedDifferences := OrderedCollection new].	^sharedDifferences</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>testing</category><body package="Store-Difference Management">hasBothDefinitions	^(mainObject isNil and: [otherObject isNil])		ifTrue: [self sharedDifferences, self methodDifferences anySatisfy: [:each | each hasBothDefinitions]]		ifFalse: [super hasBothDefinitions]</body><body package="Store-Difference Management">hasMainDifferences		self mainClass ifNotNil: [^true].	self sampleMainMethodDifference ifNotNil: [^true].	self sampleMainSharedDifference ifNotNil: [^true].	^false</body><body package="Store-Difference Management">hasOtherDifferences		self otherClass ifNotNil: [^true].	self sampleOtherMethodDifference ifNotNil: [^true].	self sampleOtherSharedDifference ifNotNil: [^true].	^false</body><body package="Store-Difference Management">isClass	^true</body><body package="Store-Difference Management">isClassExtension	^(self isMainDefinedInPackage or: [self isOtherDefinedInPackage]) not</body><body package="Store-Difference Management">isMainDefinedInPackage	mainPackage ifNil: [^false].	mainPackage isImageModel ifTrue: 		[ | imageObject |		imageObject := self mainClassStoreObject isImageObject			ifTrue: [self mainClassStoreObject]			ifFalse: [self mainClassStoreObject correspondingImageClass].		imageObject  ifNil: [^false].		^mainPackage definesClass: imageObject].	^mainPackage definesClass: (self mainClassStoreObject ifNil: [^false]).</body><body package="Store-Difference Management">isOtherDefinedInPackage	otherPackage ifNil: [^false].	^otherPackage definesClass: (self otherClassStoreObject ifNil: [^false])</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>printing</category><body package="Store-Difference Management">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: self classListName;		nextPut: $)</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>private</category><body package="Store-Difference Management">sharedAndMethodDifferences	^(self sharedDifferences collect: [:each | each selectorListName -&gt; each]),		(self methodDifferences collect: [:each | each selectorListName -&gt; each])			asSortedCollection collect: [:each | each value]</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>initialize-release</category><body package="Store-Difference Management">initialize	methodDifferenceDictionary := Dictionary new.</body></methods><methods><class-id>Store.PseudoClassDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage class: aStoreClassDefinition	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: aStoreClassDefinition;		yourself</body><body package="Store-Difference Management">new	^super new initialize</body><body package="Store-Difference Management">otherPackage: aPackage class: aStoreClassDefinition	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: aStoreClassDefinition;		yourself</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>comparing</category><body package="Store-Database Model">&lt;= aStoreBlessing 	^self hasNoticeBlessingLevel 		ifTrue: 			[(aStoreBlessing hasNoticeBlessingLevel and: [self timestamp notNil])				ifTrue: [self timestamp &gt;= aStoreBlessing timestamp]				ifFalse: [false]]		ifFalse: 			[(aStoreBlessing hasNoticeBlessingLevel or: [self timestamp isNil])				ifTrue: [true]				ifFalse: [self timestamp &gt;= aStoreBlessing timestamp]].</body><body package="Store-Database Model">= aStoreBlessing	self class = aStoreBlessing class ifFalse: [^false].	self timestamp = aStoreBlessing timestamp ifFalse: [^false].	self username = aStoreBlessing username ifFalse: [^false].	self blessingLevel = aStoreBlessing blessingLevel ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>accessing</category><body package="Store-Database Model">basicComment	^comment.</body><body package="Store-Database Model">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model">basicSource	^comment.</body><body package="Store-Database Model">basicSource: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model">blessingLevel	^blessingLevel</body><body package="Store-Database Model">blessingLevel: anInteger	anInteger isNil ifTrue: [self error: 'Invalid blessing level. Try running Glorp.ObsoleteBlessingPolicyManager initialize'].	blessingLevel := anInteger.</body><body package="Store-Database Model">blessingName	^((Dialect smalltalkAt: #Store ifAbsent: [^blessingLevel printString])		at: #Policies		ifAbsent: [blessingLevel printString]) blessingPolicy		blessingName: blessingLevel.</body><body package="Store-Database Model">comment	self basicComment yourSelf isNil ifTrue: [^''].	^self basicComment source</body><body package="Store-Database Model">comment: aString	comment := StoreBlob forString: aString.</body><body package="Store-Database Model">localTimestamp	^TimeZone default universalToLocal: timestamp</body><body package="Store-Database Model">printOn: aStream	self printWideOn: aStream.</body><body package="Store-Database Model">printTallOn: aStream	| blessingName |	blessingName := self blessingName.	aStream		nextPutAll: '--- Blessed: ' , blessingName;		cr.	aStream		nextPutAll: '--- By: ' , self username;		cr.	aStream		nextPutAll: '--- On ';		nextPutAll: self timeStampString;		cr.	comment yourSelf isNil ifFalse: [aStream nextPutAll: comment source].	aStream cr.</body><body package="Store-Database Model">printWideOn: aStream	aStream nextPutAll: '--- Blessed: ', self blessingName.	aStream nextPutAll: ' --- By: ', self username.	aStream 		nextPutAll: ' --- On ';		nextPutAll: self timeStampString; 		cr.	comment yourSelf isNil ifFalse: [		aStream nextPutAll: comment source].	aStream cr.</body><body package="Store-Database Model">timestamp	^timestamp.</body><body package="Store-Database Model">timestamp: aTimestamp	timestamp := aTimestamp.</body><body package="Store-Database Model">trace	^trace</body><body package="Store-Database Model">trace: aStoreBlessing	trace := aStoreBlessing.</body><body package="Store-Database Model">username	^(username isNil ifTrue: ['unknown user'] ifFalse: [username])</body><body package="Store-Database Model">username: aString	username := aString.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize	super initialize.	username := self currentUsername.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>reconciling</category><body package="Store-Database Model">unreconcile	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	comment := comment isNil ifTrue: [nil] ifFalse: [comment glorpCopyIn: aDictionary].	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>testing</category><body package="Store-Database Model">hasNoticeBlessingLevel	"Return true if we are a notice blessing, and should thus sort behind everything else. It would be more polite to ask Store for the numeric level, but less portable"	^self blessingLevel = -1</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>printing</category><body package="Store-Database Model">printMergeCommentHistoryOn: aStream 	| commentStream character |	aStream		nextPutAll: (#BlessedBy &lt;&lt; #store &gt;&gt; 'Blessed by: ') asString;		nextPutAll: self username;		nextPutAll: (#AtLevel &lt;&lt; #store &gt;&gt; ' at level: ') asString;		nextPutAll: self blessingName;		nextPutAll: (#On &lt;&lt; #store &gt;&gt; ' on: ') asString;		nextPutAll: self timeStampString.	commentStream := self comment readStream.	commentStream atEnd ifFalse: 		[aStream			cr;			tab].	[commentStream atEnd] whileFalse: 		[character := commentStream next.		aStream nextPut: character.		character = Character cr ifTrue: [aStream tab]]</body><body package="Store-Database Model">timeStampString	timestamp ifNil: [^(#Unknown &lt;&lt; #store &gt;&gt; 'Unknown') asString].	^Locale current 		printAsTime: self localTimestamp		policyNamed: (Locale isCLDR ifTrue: [#medium] ifFalse: [#editing])</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self displayString		with: self timeStampString		with: self username</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>compatibility</category><body package="Store-Database Model">timeStampAsTimestampObject	^self timestamp</body></methods><methods><class-id>Store.Glorp.StoreBlessing class</class-id> <category>instance creation</category><body package="Store-Publishing Support">newForBlessingLevel: aBlessingLevel comment: aString	| instance |	instance := StoreBlessing new.	instance blessingLevel: aBlessingLevel.	(aString notNil and: [aString notEmpty])		ifTrue: [instance comment: aString].	^instance</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>testing</category><body package="Store-Change Management">existsInImage	^self nameSpace notNil</body><body package="Store-Change Management">isForNameSpace	^true</body><body package="Store-Change Management">isNameSpaceTag	^true</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: aRecord 	"Load the new namespace from a definition contained in 	aRecord. Return true is the operation is successful."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body><body package="Store-Change Management">canLoad	"Answer true if a record with my tag can be load into the image."	^symbol asStrictReference environment ~~ nil</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>accessing</category><body package="Store-Change Management">actual	"Answer the namespace in the image that the reciever applies to. nil if none."	^symbol asStrictReference ifDefinedDo: 		[ :ns | ns ].</body><body package="Store-Change Management">containingPackage	"Answer a packge that contians the defintion described by me."	^Registry containingPackageForSymbol: symbol</body><body package="Store-Change Management">description	^'definition'</body><body package="Store-Change Management">nameSpace	^symbol asStrictReference valueOrDo: [ nil ].</body><body package="Store-Change Management">nameSpace: aNameSpace	symbol := aNameSpace absoluteSymbol</body><body package="Store-Change Management">nameSpaceName	^symbol asString</body><body package="Store-Change Management">sourceTextForImage	| ns |	ns := self nameSpace.	^ns == nil		ifTrue: [ nil ]		ifFalse: [ ns definition ]</body><body package="Store-Change Management">tagIndex	^self tagBaseIndex</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag.  Return True if	sucessful and False on failure."	| changed |	Cursor execute showWhile: 		[ changed := Object evaluatorClass 				evaluate: someText string				notifying: aController				logged: true		].	^changed ~~ nil</body><body package="Store-Change Management">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self nameSpace.	actual notNil		ifTrue: [ XChangeSet current				moveNameSpaceDefinition: actual				toPackage: newPackage				]		ifFalse: [ aBlock value ]</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	"Remove the receiver's definition from the image if aPackage owns it. If tolerantBoolean is false, 	display an error if the definition doesn't exist."	| ns |	ns := self nameSpace.	ns isNil 		ifTrue: 			[tolerantBoolean 				ifFalse: 					[self error: ((#NameSpace1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'NameSpace "&lt;1s&gt;" does not exist in the image.') 								expandMacrosWith: self name)]]		ifFalse: 			[(aPackage hasDefinitionFor: ns) 				ifTrue: [Override unloadClassOrNameSpace: ns from: aPackage]]</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseBindingReference: (self nameSpace fullyQualifiedReference)</body><body package="Store-Change Management">fileOutObjectType	^#nameSpace</body><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	( obj := self nameSpace ) == nil		ifFalse: 	[ obj fileOutDefinitionOn: aStream ]</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutDefinitionOn: aStream.</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	self isMeta		ifFalse: [ aStream removeObject: symbol type: self fileOutObjectType ]</body><body package="Store-Change Management">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'namespace definition'</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>converting</category><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForNameSpaceTag: self.</body></methods><methods><class-id>Store.NameSpaceTag class</class-id> <category>instance creation</category><body package="Store-Change Management">newClass: aClass	^self shouldNotImplement</body><body package="Store-Change Management">newClassName: aString	^self shouldNotImplement</body><body package="Store-Change Management">newClassSymbol: aSymbol isMeta: aBoolean	^self shouldNotImplement</body><body package="Store-Change Management">newNameSpace: aNameSpace	^self new nameSpace: aNameSpace</body><body package="Store-Change Management">newNameSpaceName: aString	^self new name: aString</body><body package="Store-Change Management">newNameSpaceSymbol: aSymbol	^self new symbol: aSymbol</body></methods><methods><class-id>Store.NameSpaceTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^8</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>testing</category><body package="Store-Change Management">isNameSpaceCommentTag	^true</body><body package="Store-Change Management">isNameSpaceTag	^false</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: aRecord 	"Load the new class comment from a definition contained in 	aRecord. 	Return true is the operation is successful."	| ns |	ns := aRecord nameSpace.	^ns == nil 		ifTrue: 			[self error: ((#NameSpace1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'NameSpace "&lt;1s&gt;" does not exist in the image.') expandMacrosWith: aRecord absoluteName).			false]		ifFalse: 			[aRecord loadCommentFor: ns.			true]</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>accessing</category><body package="Store-Change Management">description	^'Namespace comment'</body><body package="Store-Change Management">name	"Return the name as a string.."	^super name, ' comment'</body><body package="Store-Change Management">sourceTextForImage	| ns |	ns := self nameSpace.	^ns == nil		ifTrue: [ nil ]		ifFalse: [ ns comment ]</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| namespace |	namespace := self nameSpace.	namespace isNil 		ifTrue: 			[Dialog 				warn: ((#TheNameSpace1sMAndApplyResolved &lt;&lt; #store &gt;&gt; 'The NameSpace "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept an edited comment.&lt;n&gt;Resolve conflicts in the NameSpace definition, if any,&lt;n&gt;and "Apply Resolved".') 						expandMacrosWith: self symbol asString).			^false].	namespace comment: someText.	^true</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	tolerantBoolean ifFalse: 		[self error: #IDoNotKnowHowToRemoveComments &lt;&lt; #store &gt;&gt; 'I do not know how to remove comments']</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>change list support</category><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self namespace ) == nil		ifFalse: [ obj fileOutCommentOn: aStream ]</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutCommentOn: aStream.</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"don't bother to remove the comment"</body><body package="Store-Change Management">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'namespace comment'</body></methods><methods><class-id>Store.NameSpaceCommentTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^9</body></methods><methods><class-id>Store.Glorp.StoreProtocolEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">bindingReferencesDo: aBlock	^environment bindingReferencesDo: aBlock</body><body package="StoreForGlorpBrowserUI">classForName: aString ifAbsent: aBlock	^environment classForName:  aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI">methodDefinitions	| definitions |	definitions := OrderedCollection new.	self classesAndSelectorsDo: 		[:class :selector | 		definitions add: (StoreMethodDefinition class: class selector: selector)].	self sharedVariableReferencesDo: 		[:each | 		definitions add: (InitializerDefinition nameSpace: each environment key: each name)].	^definitions</body><body package="StoreForGlorpBrowserUI">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI">repositoryName	^environment repositoryName</body><body package="StoreForGlorpBrowserUI">sharedVariableReferencesDo: aBlock 	self bindingReferencesDo: 		[:each | 		| binding |		binding := each bindingOrNil.		(binding notNil and: [binding isForSharedVariable and: [binding isInClass]]) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Store.Glorp.StoreProtocolEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI">at: className ifAbsent: aBlock	^environment at: className ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">classesDo: aBlock 	environment allClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]].	environment allMetaClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>aspects</category><body package="Store-UI">tableOwnerHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerHolder isNil		ifTrue:			[tableOwnerHolder := String new asValue]		ifFalse:			[tableOwnerHolder]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>initialize-release</category><body package="Store-UI">initialize	"THis method is _not_ identical to its super implementation, despite appearances;  here ConnectionProfile means Store.ConnectionProfile, not Database.ConnectionProfile as it is in the superclass."	super initialize.	self initializeAspects.	self databaseListHolder value: ConnectionProfile concreteDatabaseDriverClassNames</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>private</category><body package="Store-UI">initializeAspects	super initializeAspects.	tableOwnerHolder := self profileAspect: #tableOwner.</body><body package="Store-UI">nameIsUnique	| name |	name := self nameHolder value.	^(RepositoryManager repositories anySatisfy: [:any | any name = name]) not		or: [profileHolder value name = name]</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>accessing</category><body package="Store-Repository Access">connectionStatus	^self isConnected		ifTrue: ['Connected']		ifFalse: ['']</body><body package="Store-Repository Access">isConnected	^DbRegistry connectedProfileHolder value = self</body><body package="Store-Repository Access">tableOwner	^tableOwner</body><body package="Store-Repository Access">tableOwner: aString 	tableOwner := aString</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>initialize-release</category><body package="Store-Repository Access">initialize	super initialize.	tableOwner := 'BERN'.</body><body package="Store-Repository Access">initializeFromXml: anElement	super initializeFromXml: anElement.	tableOwner := self valueOf: anElement childNamed: 'table-owner'.</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>private</category><body package="Store-Repository Access">addXmlElementsTo: anElement	anElement		addNode: (self elementFor: 'driver-class-name' with: self driverClassName);		addNode: (self elementFor: 'environment' with: self environment);		addNode: (self elementFor: 'user-name' with: self userName);		addNode: (self elementFor: 'password' with: self password);		addNode: (self elementFor: 'table-owner' with: self tableOwner)</body><body package="Store-Repository Access">asXmlNode	| root |	root := Element 		tag: 'store-repository' 		attributes: (Array with: (Attribute name: 'name' value: name))		elements: nil.	self addXmlElementsTo: root.	^root</body><body package="Store-Repository Access">elementFor: tagString with: contentsString	^(Element tag: tagString)		addNode: (XML.Text text: contentsString)</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asGlorpLogin	"It's not clear to me that we need this method:  it could be inlined away in its only (AFAICS) caller."	^Store.Glorp.StoreLogin newFromConnectionProfile: self</body></methods><methods><class-id>Store.ConnectionProfile class</class-id> <category>instance creation</category><body package="Store-Repository Access">defaultNew	^super defaultNew		tableOwner: 'BERN'		yourself.</body><body package="Store-Repository Access">fromXmlElement: anElement	^self new initializeFromXml: anElement</body></methods><methods><class-id>Store.ConnectionProfile class</class-id> <category>accessing</category><body package="Store-Repository Access">concreteDatabaseDriverClasses	^super concreteDatabaseDriverClasses select:		[:each | each glorpStoreDatabasePlatformClass notNil]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>aspects</category><body package="Store-UI">repositoryHolder	^nil asValue</body><body package="Store-UI">repositoryListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^repositoryListHolder isNil		ifTrue:			[repositoryListHolder :=  SelectionInListSortAware new.			repositoryListHolder selectionIndexHolder compute:				[:v |				self repositoryHolder value: repositoryListHolder selection].			repositoryListHolder]		ifFalse:			[repositoryListHolder]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>initialize-release</category><body package="Store-UI">manager: aManager	super manager: aManager.	manager triggerChannel onChangeSend: #triggered to: self</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self repositorySelectionChanged</body><body package="Store-UI">setting: aStoreRepositoryListSetting	setting := aStoreRepositoryListSetting.	self repositoryListHolder list: setting profiles.	self repositoryListHolder selectionIndexHolder		onChangeSend: #repositorySelectionChanged to: self.</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>private</category><body package="Store-UI">accept	setting installProfiles</body><body package="Store-UI">reset	setting resetProfiles.	self repositoryListHolder list: setting profiles</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>actions</category><body package="Store-UI">addRepository	| newProfile |	newProfile := ConnectionProfile new.	newProfile name: (#Repository1p &lt;&lt; #store &gt;&gt; 'Repository &lt;1p&gt;'  expandMacrosWith: self repositoryListHolder list size + 1).	(RepositoryPropertiesDialog openOn: newProfile) 		ifTrue: 			[(self repositoryListHolder list)				add: newProfile;				sortWith: [:a :b | a name &lt; b name].			self repositoryListHolder selection: newProfile.			manager tickle]</body><body package="Store-UI">importSnapshots: aCollection	| snapshot newProfiles |	snapshot := aCollection detect: [:some | some id = setting id] ifNone: [^self].	newProfiles := List new.	snapshot stateNodes do:		[:each |		newProfiles add: (ConnectionProfile fromXmlElement: each)].	self repositoryListHolder list		removeAllSuchThat: [:each | true];		addAll: newProfiles.	self tickle</body><body package="Store-UI">removeRepository	self repositoryListHolder selectionDo:		[:selection |		(Dialog confirm: #RemoveThisRepositoryQ &lt;&lt; #labels &gt;&gt; 'Remove this repository?')			ifTrue: 				[self repositoryListHolder list remove: selection.				manager tickle]]</body><body package="Store-UI">repositoryProperties	self repositoryListHolder selectionDo:		[:selection |		RepositoryPropertiesDialog openOn: selection.		manager tickle]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>notifications</category><body package="Store-UI">repositorySelectionChanged	| hasSelection |	builder isNil ifTrue: [^self].	hasSelection := self repositoryListHolder selection notNil.	#(removeButton propertiesButton) do:		[:each | (self wrapperAt: each) isEnabled: hasSelection]</body><body package="Store-UI">triggered	manager triggerChannel value 		ifTrue: [self accept]		ifFalse: [self reset]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>accessing</category><body package="Store-UI">settings	^Array with: setting</body></methods><methods><class-id>Store.Comparing</class-id> <category>accessing</category><body package="Store-Difference Management">actionText	^(#Comparing &lt;&lt; #store &gt;&gt; 'Comparing') asString</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI">at: className ifAbsent: aBlock	^environment at: className ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">classForName: aString	^self classForName: aString ifAbsent: [nil]</body><body package="StoreForGlorpBrowserUI">classForName: aString ifAbsent: aBlock	^environment classForName: aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">classesDo: aBlock 	classSelectors keysDo: 		[:each | 		aBlock value: (environment classForName: each)].	metaClassSelectors keysDo: 		[:each | 		aBlock value: (environment classForName: each) storeMetaClass]</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">methodDefinitions	| definitions |	definitions := OrderedCollection new.	self classesAndSelectorsDo: 		[:class :selector | 		definitions add: (StoreMethodDefinition class: class selector: selector)].	self sharedVariableReferencesDo: 		[:each | 		definitions add: (InitializerDefinition nameSpace: each environment key: each name)].	^definitions</body><body package="StoreForGlorpBrowserUI">methodNamed: aSelector inClass: aClass	^environment methodNamed: aSelector inClass: aClass</body><body package="StoreForGlorpBrowserUI">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass)</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI">implementorsMatching: aString in: anEnvironment 	^self implementorsOf: aString in: anEnvironment</body><body package="StoreForGlorpBrowserUI">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copy].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copy]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body><body package="StoreForGlorpBrowserUI">matches: aString in: anEnvironment		| newEnvironment |	newEnvironment := (self onEnvironment: anEnvironment)		label: (#Matching1s &lt;&lt; #browser &gt;&gt; 'Matching: &lt;1s&gt;' expandMacrosWith: aString);		searchStrings: (Array with: aString);		yourself.	anEnvironment		classesAndSelectorsDo:			[:eachClass :eachSelector | 			| method |			method := eachClass compiledMethodAt: eachSelector.			(aString match: method source) ifTrue: [newEnvironment addClass: eachClass selector: eachSelector]].	^newEnvironment</body><body package="StoreForGlorpBrowserUI">onMethods: aMethodDefinitionCollection in: anEnvironment	"We have to perserve the extra text in the original method definitions, so we defer to some specialized subclass.	Also, being a Store Browser object, we need to pass along the Store environment"	| result |	result := StoreMethodDefinitionEnvironment onMethods: aMethodDefinitionCollection.	result environment: anEnvironment.	^result</body></methods><methods><class-id>Store.ObsoleteBrowserContent</class-id> <category>accessing</category><body package="Store-Base">session	^session</body><body package="Store-Base">session: aGlorpSession	session := aGlorpSession</body><body package="Store-Base">wasUsed	^wasUsed</body><body package="Store-Base">wasUsed: anObject	wasUsed := anObject</body></methods><methods><class-id>Store.ObsoleteBrowserContent</class-id> <category>initialize-release</category><body package="Store-Base">initialize	super initialize.	wasUsed := false.</body></methods><methods><class-id>Store.ObsoleteBrowserContent class</class-id> <category>instance creation</category><body package="Store-Base">new	^super new initialize.</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>testing</category><body package="Store-Database Model">isForNameSpace	^true</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStoreNameSpace	^self</body><body package="Store-Database Model">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage namespaces		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: Store.Glorp.StoreNamespaceInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="Store-Database Model">correspondingImageNamespace	"Return the image namespace that corresponds to our name. Note that they may not have the same information"	^(Dialect smalltalkAt: self longName ifAbsent: [nil]).</body><body package="Store-Database Model">sameAsImage	"Answer true if the receiver is the same as the image version."	| theNamespace |	theNamespace := self correspondingImageNamespace.	theNamespace isNil ifTrue: [^false].	^self = theNamespace asStoreNameSpace.</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>accessing</category><body package="Store-Database Model">actual	^self correspondingImageNamespace</body><body package="StoreForGlorpVWUI">allStoreVersions	^[(Gathering for: self name) started.		StoreNamespaceInPackage allVersionsWithName: self name]		ensure: [(Gathering for: self name) finished]</body><body package="StoreForGlorpVWUI">bindingsDo: ignore	^self</body><body package="StoreForGlorpVWUI">organization	^NameSpaceOrganizer new environment: self</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := self definition.	insertPoint := definitionString indexOfSubCollection: 'defineNameSpace:' startingAt: 1.	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Store-Database Model">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>private</category><body package="Store-Database Model">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineNameSpace:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'imports' value: (data at: 'imports:') value.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>filling out</category><body package="Store-Database Model">fileOutObjectType	^#nameSpace</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>loading</category><body package="Store-Database Model">loadSource	| currentPackage binding cmt |	currentPackage := Store.Policies packagePolicy forcedPackage.	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableNamespaceMsgForUnspecifiedParent inPackage: currentPackage].	binding := self evaluateDefinition: self definitionString				onError: [:exception | ^self raiseUnloadableError: exception inPackage: currentPackage].	((cmt := self comment) notNil and: [cmt notEmpty]) 		ifTrue: [binding comment: cmt]		ifFalse: [binding comment: nil].</body><body package="Store-Database Model">loadSourceDirect	^self loadSourceDirectInPackage: Store.Policies packagePolicy forcedPackage.</body><body package="Store-Database Model">loadSourceDirectInPackage: aPackage	| binding existingNamespace knownOverrides target cmt |	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableNamespaceMsgForUnspecifiedParent inPackage: aPackage].	(existingNamespace := self correspondingImageNamespace) ifNotNil: 		[knownOverrides := Override overridesForClassOrNameSpace: existingNamespace.		knownOverrides ifNotNil: 			[target := knownOverrides 				detect: [:eachOverride | eachOverride sources includes: aPackage] 				ifNone: [nil]].			target ifNotNil: [^target setOverriddenDefinition: self messageSendFromDefinition]].	binding := self evaluateDefinition: self definitionString				onError: [:exception | ^self raiseUnloadableError: exception inPackage: aPackage].	(cmt := self comment) notEmpty 		ifTrue: [binding comment: cmt]		ifFalse: [binding comment: nil].</body><body package="Store-Database Model">messageSendFromDefinition	| methodNodeHolder messageNode |	methodNodeHolder := Compiler new parse: self definitionString in: nil class noPattern: true notifying: nil.	messageNode := methodNodeHolder node block body statements first.	^MessageSend		receiver: self correspondingImageNamespace environment		selector: messageNode selector		arguments: (messageNode arguments collect: #value)</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">toolListIcon		^BehaviorIcons Namespace</body><body package="StoreForGlorpVWUI">unambiguousName	^self longName</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>comparing</category><body package="StoreForGlorpVWUI">comparesTo: anObject	^self class == anObject class and: [		self absoluteName = anObject absoluteName].</body><body package="Store-Database Model">equalsSignatureIn: aStoreDefinitionObject	self environmentName = aStoreDefinitionObject environmentName ifFalse: [^false].	self name = aStoreDefinitionObject name ifFalse: [^false].	^true.</body><body package="Store-Database Model">signatureHash	^self environmentName hash bitXor: self name hash</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeNamespace: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedNamespaceObject</body></methods><methods><class-id>Store.Glorp.StoreNameSpace class</class-id> <category>constants</category><body package="Store-Database Model">inPackageClass	^StoreNamespaceInPackage</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>fileIn/Out</category><body package="Store-Change Management">fileIn	"File-in the receiver - ie. make the change to the system."	Store.Glorp.StorePundle 		reloadPundle: componentType 		named: componentName  		id: primaryKey  		fromDatabase: databaseId</body><body package="Store-Change Management">fileOutOn: aSourceFile	aSourceFile		loadPundleNamed: componentName		type: componentType		primaryKey: databaseId		databaseId: primaryKey</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>testing</category><body package="Store-Change Management">sameAsSystem	"Return true if the receiver represents an object that is the same as the system."	| comp |	( comp := self component ) == nil		ifTrue: [ ^false ].	^databaseId = comp databaseId and: [ primaryKey = comp dbTrace ]</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>comparing</category><body package="Store-Change Management">= aChange	^( super = aChange ) and:		[ ( databaseId = aChange databaseId ) &amp; ( primaryKey = aChange primaryKey ) ].</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>accessing</category><body package="Store-Change Management">actionString	"Answer a string for messages describing the receiver."	^(#LoadedFrom &lt;&lt; #store &gt;&gt; ' loaded from ') asString</body><body package="Store-Change Management">component: aCodeComponent	"Extract relevant information from aCodeComponent."	super component: aCodeComponent.	databaseId := aCodeComponent dbIdentifier.	primaryKey := aCodeComponent primaryKey.</body><body package="Store-Change Management">databaseId	^databaseId</body><body package="Store-Change Management">databaseId: aString	databaseId := aString</body><body package="Store-Change Management">parameters	"Return the parameters used for the 'same as' test"	^super parameters asOrderedCollection		add: databaseId;		add: primaryKey;		asArray.</body><body package="Store-Change Management">primaryKey	^primaryKey</body><body package="Store-Change Management">primaryKey: anInteger	primaryKey := anInteger</body><body package="Store-Change Management">systemVersion: aCodeComponent	"Answer an appropiate version string for aCodeComponent."	^aCodeComponent databaseId 		ifNil: [ (#NotInConnectedDatabase &lt;&lt; #store &gt;&gt; 'Not in Connected Database') asString ]		ifNotNil: [ :id | id , ': ' , aCodeComponent primaryKey printString ]</body><body package="Store-Change Management">type 	"Answer the sub-type of this kind of change."	^#componentLoaded</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>printing</category><body package="Store-Change Management">version	^databaseId, ': ', primaryKey printString</body></methods><methods><class-id>ShadowBundleCompileManager</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">bundle	^self pundle</body><body package="Atomic Compiling and Loading">bundle: aStoreBundle	pundle := aStoreBundle</body><body package="Atomic Compiling and Loading">parentManager: anObject	parentManager := anObject</body><body package="Atomic Compiling and Loading">results	^results</body><body package="Atomic Compiling and Loading">results: anObject	results := anObject</body><body package="Atomic Compiling and Loading">resultsFromParent	| reverseResults |	reverseResults := OrderedCollection new.	parentManager isNil		ifFalse: [reverseResults addAll: parentManager resultsFromParent].	reverseResults add: results.	^reverseResults.</body></methods><methods><class-id>ShadowBundleCompileManager</class-id> <category>actions</category><body package="Atomic Compiling and Loading">atomicCompileWith: aCompilationManager	"I was invoked by the UI (or directly) do the preCompile, compile and then answer back either nil or the compilation result"	| redefines |	compilationManager := aCompilationManager.	(self bundle preCompileWith: aCompilationManager) ifFalse: [^nil].	redefines := OrderedCollection new.	[[SystemUtils modifySystem: [self compile]]		on: RedefinitionOfClass		do: 			[:notification |			(redefines includes: notification parameter)				ifFalse: 					[compilationManager installEarlyAndReInitialize.					compilationManager reinitializeShadowRoot.					redefines add: notification parameter.					notification restart]				ifTrue: 					[notification resume]]]			on: NoDLLCCNotification			do: 				[:notification |				compilationManager installEarlyAndReInitialize.				compilationManager reinitializeShadowRoot.				notification restart]</body><body package="Atomic Compiling and Loading">compile	"Compile the bundle's package and sub-bundle definitions into shadow space"	self bundle isComponentLoaded ifFalse: [self bundle isNotLoaded ifFalse: [^nil]].	results := BundleCompilationResult new.	results bundle: self bundle.	compilationManager ifNotNil: [compilationManager addResult: results].	(self bundle containedItems select: [:each | each isNotLoaded]) do: 		[:each | 		| localResults pundleCompilerManager |		(each isBundle not and: [each binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]])			ifTrue: 				[compilationManager installEarlyAndReInitialize.				compilationManager reinitializeShadowRoot.				each binLoadWithin: self bundle using: compilationManager]			ifFalse: 				[pundleCompilerManager := each newDefaultCompileManagerWith: compilationManager.				pundleCompilerManager parentManager: self.				SystemUtils modifySystem: [localResults := pundleCompilerManager compile].				results add: localResults.				localResults needsEarlyInstall ifTrue: 					[compilationManager installEarlyWith: self]]].	^results</body><body package="Atomic Compiling and Loading">install	"I answer the results	Here I check to see if I can atomically load at all and if so, I call install on the results"		results isAtomicallyLoadable ifTrue: [results install].	^results</body></methods><methods><class-id>ShadowBundleCompileManager class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">newForPundle: aPundle with: aCompilationManager	^self new pundle: aPundle;		compilationManager: aCompilationManager</body><body package="Atomic Compiling and Loading">newWith: aCompilationManager	^self new compilationManager: aCompilationManager</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>accessing</category><body package="Store-Database Model">privilege	^privilege</body><body package="Store-Database Model">privilege: aString	privilege := aString</body><body package="Store-Database Model">pundleName	^pundleName</body><body package="Store-Database Model">pundleName: aString	pundleName := aString</body><body package="Store-Database Model">pundleType	^pundleType</body><body package="Store-Database Model">pundleType: aString	pundleType := aString</body><body package="Store-Database Model">rights		^#(#owner #read #publish)</body><body package="Store-Database Model">session	^session</body><body package="Store-Database Model">session: aGlorpSession	session := aGlorpSession</body><body package="Store-Database Model">setPundle: aPundle	self pundleName: aPundle name.	self pundleType: aPundle typeStringForBlessing</body><body package="Store-Database Model">setUser: aStoreUser	userName := aStoreUser userName.	userType := aStoreUser type.</body><body package="Store-Database Model">userName	^userName</body><body package="Store-Database Model">userName: aString	userName := aString</body><body package="Store-Database Model">userType	^userType</body><body package="Store-Database Model">userType: aString	userType := aString</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>comparing</category><body package="Store-Database Model">&lt;= aStoreAccessPrivilege		self class == aStoreAccessPrivilege class ifFalse: 		[^false].	self userName = aStoreAccessPrivilege userName ifFalse: 		[^self userName &lt;= aStoreAccessPrivilege userName].	self privilege = aStoreAccessPrivilege privilege ifFalse: 		[^self privilege &lt;= aStoreAccessPrivilege privilege].	^self pundleName &lt;= pundleName</body><body package="Store-Database Model">= aStoreAccessPrivilege		aStoreAccessPrivilege class == self class ifFalse: [^false].	^userType = aStoreAccessPrivilege userType and: 		[userName = aStoreAccessPrivilege userName and: 		[pundleName = aStoreAccessPrivilege pundleName and:		[pundleType = aStoreAccessPrivilege pundleType and:		[privilege = aStoreAccessPrivilege privilege]]]]</body><body package="Store-Database Model">hash		^(userType hash bitXor: pundleType hash) bitXor: ((userName hash bitXor: pundleName hash) bitXor: privilege hash)</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>testing</category><body package="Store-Database Model">isBundle	^pundleType = 'B'</body><body package="Store-Database Model">isGroup	^pundleType = 'G'</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>displaying</category><body package="Store-Database Model">fullDescription		| stream |	stream := (String new: 30) writeStream.	stream nextPutAll: userName.	self isGroup ifTrue: [stream nextPutAll: '(G)'].	stream nextPutAll: (privilege = 'owner'		ifTrue: [' owns ']		ifFalse:			[privilege = 'read' 				ifTrue: [' can read '] 				ifFalse: 					[privilege = 'publish' 						ifTrue: [' can publlish '] 					ifFalse: [' *' , privilege , '* ']]]) , pundleName.	self isBundle ifTrue: [stream nextPutAll: '(B)'].	^stream contents</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>query</category><body package="Store-Database Model">allDistinctUserGroups	^self allDistinctUserGroupsIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allDistinctUserGroupsIn: aSessionOrNil	| session groupNames userNames result |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	userNames := self allUserNamesIn: session.	groupNames := self allGroupNamesIn: session.	result := OrderedCollection new: userNames size + groupNames size.	result addAll: (userNames collect:		[:each | 		(StoreUserGroup new)			userName: each;			session: session;			type: 'U']).	result addAll: (groupNames collect:		[:each | 		(StoreUserGroup new)			userName: each;			session: session;			type: 'G']).	^result</body><body package="Store-Database Model">allGroupNames	^self allGroupNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allGroupNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each userType = 'G'].	query retrieve: [:each | each userName distinct].	query orderBy: #userName.	^session execute: query</body><body package="Store-Database Model">allPrivilegesForPundle: aStorePundleOrPundleModel	^self allPrivilegesForPundle: aStorePundleOrPundleModel in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allPrivilegesForPundle: aStorePundleOrPundleModel in: aSessionOrNil	| session query targetPundleType |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	targetPundleType := aStorePundleOrPundleModel typeStringForBlessing.	query := Query read: self where:		[:each | each pundleName = aStorePundleOrPundleModel name AND: (each pundleType = targetPundleType)].	^session execute: query</body><body package="Store-Database Model">allPrivilegesForUser: aStoreUserGroup	| session query |	session := StoreLoginFactory currentStoreSession.	query := Query read: self where:		[:each | each userName = aStoreUserGroup userName AND: (each userType = aStoreUserGroup type)].	^session execute: query</body><body package="Store-Database Model">allPrivilegesForUser: aStoreUserGroup pundle: aStorePundleOrPundleModel	| session query targetPundleType |	session := StoreLoginFactory currentStoreSession.	targetPundleType := aStorePundleOrPundleModel typeStringForBlessing.	query := Query read: self where:		[:each | 		each userName = aStoreUserGroup userName AND: 			(each userType = aStoreUserGroup type) AND:			(each pundleName = aStorePundleOrPundleModel name) AND:			(each pundleType = targetPundleType)].	^session execute: query</body><body package="Store-Database Model">allUserNames	^self allUserNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">allUserNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each userType = 'U'].	query retrieve: [:each | each userName distinct].	query orderBy: #userName.	^session execute: query</body><body package="Store-Database Model">ownerOfPundle: aPundle 	| result |	aPundle ifNil: [^nil].	result := self 		usersWithPrivilege: #owner		pundleName: aPundle name		pundleType: aPundle typeStringForBlessing		in: aPundle session.	result size == 0 ifTrue: [^nil].	result size &gt; 1 ifTrue: 		[Dialog warn: ((#_1sHasMoreThanOneOwner &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has more than one owner.') expandMacrosWith: aPundle name)].	^result first</body><body package="Store-Database Model">privilegeForUser: aStoreUserGroup pundle: aStorePundleOrPundleModel	| session query targetPundleType |	session := StoreLoginFactory currentStoreSession.	targetPundleType := aStorePundleOrPundleModel typeStringForBlessing.	query := Query readOneOf: self where:		[:each | 		each userName = aStoreUserGroup userName AND: 			(each userType = aStoreUserGroup type) AND:			(each pundleName = aStorePundleOrPundleModel name) AND:			(each pundleType = targetPundleType)].	^session execute: query</body><body package="Store-Database Model">pundlesUser: aStoreUserGroup privilege: aSymbol	"Answer a collection of pundles for which a user has given privilege."	^self pundlesUserName: aStoreUserGroup userName userType: aStoreUserGroup type privilege: aSymbol.</body><body package="Store-Database Model">pundlesUserName: aUserName userType: aString privilege: aSymbol	^self pundlesUserName: aUserName userType: aString privilege: aSymbol in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">pundlesUserName: aUserName userType: aString privilege: aSymbol in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: 		[:each |		each privilege = aSymbol AND: (each userName = aUserName) AND: (each userType = aString)].	^session execute: query</body><body package="Store-Database Model">user: aStoreUser hasPrivilege: aSymbol to: aPundle	| users groups |	users := self usersWithPrivilege: aSymbol pundle: aPundle in: aStoreUser session.	(users includes: aStoreUser) ifTrue: [^true].	groups := StoreUserGroup groupsForUser: aStoreUser.	^groups includes: aStoreUser</body><body package="Store-Database Model">usersWithPrivilege: aSymbol pundle: aPundle in: aSessionOrNil	^self usersWithPrivilege: aSymbol pundleName: aPundle name pundleType: aPundle typeStringForBlessing in: aSessionOrNil</body><body package="Store-Database Model">usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aString	^self usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aString in: aSessionOrNil	| session query results |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: 		[:each |		each privilege = aSymbol AND: (each pundleName = aPundleName) AND: (each pundleType = aString)].	query alsoFetch: #userName.	query alsoFetch: #userType.	results := session execute: query.	^results collect:		[:eachPair |		(StoreUserGroup new)			userName: eachPair userName;			session: session;			type: eachPair userType;			yourself]</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>installation</category><body package="Store-Database Model">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy userAndOwnershipTableSpace</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>instance creation</category><body package="Store-Database Model">forPundle: aStorePundle user: aStoreUserGroup privilege: aSymbol	| instance |	instance := self new.	instance setPundle: aStorePundle.	instance setUser: aStoreUserGroup.	instance privilege: aSymbol.	^instance</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>privilege management</category><body package="Store-Database Model">grant: aSymbol to: aStoreUser for: aStorePundle	"Set the access privilege to aStoreUser for aStorePundle."		| instance session |	aSymbol == #owner ifTrue: [^self updateOwnershipFor: aStorePundle to: aStoreUser].	instance := self forPundle: aStorePundle user: aStoreUser privilege: aSymbol.	session := aStorePundle session ifNil: [StoreLoginFactory currentStoreSession].	session inUnitOfWorkDo:		[session register: instance]</body><body package="Store-Database Model">revokeAllFor: aStoreUserGroup for: aStorePundle	| privileges session |	privileges := self allPrivilegesForUser: aStoreUserGroup pundle: aStorePundle.	session := aStorePundle session ifNil: [StoreLoginFactory currentStoreSession].	session accessor permitEverythingDuring:		[session inUnitOfWorkDo: [session deleteAll: privileges]].</body><body package="Store-Database Model">updateOwnershipFor: aStorePundle to: aStoreUser	"If there was no previous owner, make me the owner	Otherwise, remove the old owner, and make me the owner"	| instance session previousOwner oldPrivilege |	instance := self forPundle: aStorePundle user: aStoreUser privilege: #owner.	session := aStorePundle session ifNil: [StoreLoginFactory currentStoreSession].	((previousOwner := self ownerOfPundle: aStorePundle) isNil or: [previousOwner ~= aStoreUser])		ifTrue: [session inUnitOfWorkDo: [session register: instance]].	(previousOwner notNil and: [previousOwner ~= aStoreUser]) ifTrue:		[oldPrivilege := self privilegeForUser: previousOwner pundle: aStorePundle.		session inUnitOfWorkDo: [session delete: oldPrivilege].		session inUnitOfWorkDo: [session register: instance]].</body></methods><methods><class-id>Store.MethodTag</class-id> <category>testing</category><body package="Store-Change Management">belongsToClass	^true</body><body package="Store-Change Management">existsInImage	^self compiledMethod notNil</body><body package="Store-Change Management">isForMethod	^true</body><body package="Store-Change Management">isInClass	^true</body><body package="Store-Change Management">isMethodTag	^true</body><body package="Store-Change Management">isSubdefTag	^true</body></methods><methods><class-id>Store.MethodTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: aRecord 	"Load the new method from a definition contained in 	aPackage."	^aRecord loadAsNew</body></methods><methods><class-id>Store.MethodTag</class-id> <category>accessing</category><body package="Store-Change Management">actual	^self compiledMethod</body><body package="Store-Change Management">compiledMethod	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl compiledMethodAt: selector ifAbsent: [nil]]</body><body package="Store-Change Management">containingPackage	"Answer a packge that contains the 	defintion described by me."	"(MethodTag newClass: MethodTag selector: #containingPackage) 	containingPackage" 	^Registry		quickContainingPackageForSelector: self selector		classSymbol: self classSymbol		meta: self isMeta</body><body package="Store-Change Management">description	^'#', selector, 		(isMeta			ifTrue: [' (class method)']			ifFalse: [''])</body><body package="Store-Change Management">name	^self className, '&gt;&gt;', selector asString</body><body package="Store-Change Management">protocol	protocol == nil		ifTrue: [ protocol := self actualClass organization categoryOfElement: self selector ].	^protocol.</body><body package="Store-Change Management">protocol: aSymbol	protocol := aSymbol</body><body package="Store-Change Management">selector	^selector</body><body package="Store-Change Management">selector: aSymbol	selector := aSymbol</body><body package="Store-Change Management">sourceTextForImage	| cm |	cm := self compiledMethod.	^cm isNil		ifTrue: [nil]		ifFalse: [cm getSource]</body><body package="Store-Change Management">symbolKey	^selector</body></methods><methods><class-id>Store.MethodTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| actualClass newSelector |	actualClass := self actualClass.	actualClass isNil 		ifTrue: 			[Dialog warn: ((#TheClass1sMustAndApplyResolved &lt;&lt; #store &gt;&gt; 'The class "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept edited code.&lt;n&gt;Resolve conflicts in the class definition, if any,&lt;n&gt;and "Apply Resolved".') expandMacrosWith: self classSymbol asString).			^false].	newSelector := actualClass parserClass new parseSelector: someText.	newSelector isNil 		ifTrue: 			[Dialog warn: #ParseFailure &lt;&lt; #store &gt;&gt; 'Parse failure'.			^false].	newSelector ~~ self selector ifTrue: 		[Dialog warn: #selectorMustNotChange &lt;&lt; #store &gt;&gt; 'selector must not change'.		^false].	self protocol size = 0 ifTrue: 		[protocol := Dialog request: #UseWhatProtocol &lt;&lt; #store &gt;&gt; 'Use what protocol?'].	protocol size = 0 ifTrue: [protocol := ClassOrganizer defaultProtocol].	Cursor execute showWhile: 			[newSelector := actualClass 						compile: someText						classified: protocol						notifying: aController].	^newSelector ~~ nil</body><body package="Store-Change Management">moveFromPackage: oldPackage toPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	(actual notNil and: [actual includesSelector: self selector])		ifTrue: [XChangeSet current				moveSelector: self selector				class: actual				fromPackage: oldPackage				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	(actual notNil and: [actual includesSelector: self selector])		ifTrue: [XChangeSet current				moveSelector: self selector				class: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	| cls |	cls := self actualClass.	cls isNil 		ifTrue: 			[tolerantBoolean ifFalse: 				[self error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') expandMacrosWith: self className)]]		ifFalse: 			[(aPackage hasSelector: self selector in: cls) 				ifTrue: 					[((Override 						unloadSelector: self selector						class: cls						from: aPackage						logged: true) not 						and: [tolerantBoolean not]) 							ifTrue: 								[(cls includesSelector: self selector) 									ifFalse: 										[self error: ((#Quotes1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; '"&lt;1s&gt;" does not exist in the image.') expandMacrosWith: self name)]]]]</body></methods><methods><class-id>Store.MethodTag</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	MethodCollector new 		openListBrowserOn: (Array with: (MethodDefinition class: self actualClass selector: selector))		label: (#CurrentDefinition &lt;&lt; #store &gt;&gt; 'Current Definition') asString</body><body package="Store-Change Management">category	^protocol == nil		ifTrue: [ self systemCategory ]		ifFalse: [ protocol ].</body><body package="Store-Change Management">classProxy 	^( Kernel.ChangeSupportClassProxy pathString: self fullClassName asClassNameOnly ) 			meta: self isMeta</body><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	| cls |	( cls := self actualClass ) == nil		ifTrue: [ ^nil ].	aStream		saveSource: self sourceTextForImage		class: cls		protocol: self category		attributes: nil.	"to add the &lt;/methods&gt; tag, according to steve"	aStream checkMethodChunkClass: nil protocol: nil.</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutOn: aStream.</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	aStream removeSelector: selector from: self classProxy</body><body package="Store-Change Management">systemCategory	"Return the category of the corresponding method the system, if any"	| class |	^( class := self actualClass ) == nil		ifFalse: [ class whichCategoryIncludesSelector: self selector ]</body><body package="Store-Change Management">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'method definition'</body></methods><methods><class-id>Store.MethodTag</class-id> <category>converting</category><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForMethodTag: self.</body></methods><methods><class-id>Store.MethodTag</class-id> <category>comparing</category><body package="Store-Change Management">= aTag	^super = aTag and:		[selector == aTag selector and: [protocol = aTag protocol]]</body></methods><methods><class-id>Store.MethodTag class</class-id> <category>instance creation</category><body package="Store-Change Management">newClass: aClass selector: aSelector		^self new class: aClass; selector: aSelector</body><body package="Store-Change Management">newClassName: aString meta: aBoolean selector: aSelector protocol: protocol	^self new 		className: aString;		isMeta: aBoolean;  		selector: aSelector;		protocol: protocol</body><body package="Store-Change Management">newClassName: aString selector: aSelector meta: isMeta		^self new className: aString; meta: isMeta; selector: aSelector</body><body package="Store-Change Management">newClassSymbol: aSymbol isMeta: aBoolean selector: aSelector		^self new classSymbol: aSymbol; isMeta: aBoolean;  selector: aSelector</body></methods><methods><class-id>Store.MethodTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^3		"also reserves 7 for the meta-class methods"</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>private</category><body package="Store-Change Management">addComponentChanges	componentChanges := self compareComponents collect:		[ :array |		array first pundleChangesClass			with: array first with: array last.		]</body><body package="Store-Change Management">addComponentChangesNonRecursive	| items1 items2 |	items1 := pundle1 	containedItems.	items2 := pundle2 	containedItems.	items1 do:		[ :pundle |		items2 detect: 			[ :i | ( i isBundle == pundle isBundle ) and: [ i name = pundle name ] ]				ifNone: 					[ changeSet1 addOtherChange: BundleModel structureMark.					changeSet2 addOtherChange: BundleModel structureMark.					]			].	items2 do:		[ :pundle |		items1 detect: 			[ :i | ( i isBundle == pundle isBundle ) and: [ i name = pundle name ] ] 				ifNone: 					[ changeSet2 addOtherChange: BundleModel structureMark.					changeSet1 addOtherChange: BundleModel structureMark.					]		].</body><body package="Store-Change Management">addOtherChanges	"Add other changes to the changesets."	super addOtherChanges.	self addStructureChanges.</body><body package="Store-Change Management">addStructureChanges	pundle1 structure = pundle2 structure		ifFalse:			[ changeSet1 addOtherChange: BundleModel structureMark.			changeSet2 addOtherChange: BundleModel structureMark.			].</body><body package="Store-Change Management">calculateChanges	self addComponentChanges.	self addOtherChanges.</body><body package="Store-Change Management">calculateChangesNonRecursive"	self addComponentChangesNonRecursive. "	self addOtherChanges.</body><body package="Store-Change Management">compareComponents	"Compare the packages contained in the two bundles. Answer a collection of paired packages."	| diffs pdict bdict |	pdict := Dictionary new.	bdict := Dictionary new.	diffs := OrderedCollection new.	pundle2 allItems do: 		[ :pkg | pkg isPackage 					ifTrue: [ pdict at: pkg name put: pkg ]					ifFalse: [ bdict at: pkg name put: pkg ]		].	pundle1 allItems do: 		[ :pkg | 	| other dict |		dict := pkg isPackage ifTrue: [ pdict ] ifFalse: [ bdict ].		other := dict at: pkg name ifAbsent: [ PseudoPackage fromPackage: pkg ].		( other sameVersionAs: pkg )			ifFalse: [ diffs add: ( Array with: pkg with: other ) ].		dict removeKey: pkg  name ifAbsent: [ ].		].	pdict do: [ :pkg | diffs add: ( Array with: ( PseudoPackage fromPackage: pkg ) with: pkg ) ].	bdict do: [ :pkg | diffs add: ( Array with: ( PseudoPackage fromPackage: pkg ) with: pkg ) ].	^diffs</body><body package="Store-Change Management">comparePackages	"Compare the packages contained in the two bundles. Answer a collection of paired packages."	| dict diffs |	dict := Dictionary new.	diffs := OrderedCollection new.	pundle2 allItems do: [ :pkg | dict at: pkg name put: pkg ].	pundle1 allItems do: 		[ :pkg | 	| other |		other := dict at: pkg name					ifAbsent:						[ diffs add: ( Array with: pkg with: nil ).						nil						].		other notNil			ifTrue: 				[ ( other sameVersionAs: pkg )					ifFalse: [ diffs add: ( Array with: pkg with: other ) ].				dict at: pkg name put: nil				]		].	dict do: [ :pkg | pkg notNil ifTrue: [ diffs add: ( Array with: nil with: pkg ) ] ].	^diffs</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>initialization</category><body package="Store-Change Management">recurseChanges	"Calculate the changes for the bundle's subcomponents. Not always neccessary."	componentChanges == nil		ifFalse: [ ^self ].	self requiresFullCompare		ifTrue: [ self addComponentChanges ]		ifFalse:			[ Notice 				showProgress:  					( (#Comparing1sWith2s &lt;&lt; #store &gt;&gt; 'Comparing &lt;1s&gt; with &lt;2s&gt;.')  							expandMacrosWith: pundle1 displayString 							with: pundle2 displayString 					 )				complete: self calcItemCount 				while: [ self addComponentChanges ]				title: #Store &lt;&lt; #store &gt;&gt; 'Store'			].</body><body package="Store-Change Management">with: aBundle with: bBundle	pundle1 := aBundle.	pundle2 := bBundle.	changeSet1 := XChangeSet new.	changeSet2 := XChangeSet new.	[ self calculateChangesNonRecursive ] 		on: DbRegistry errorSignals do: [ :ex | ex outer ].</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>fileout</category><body package="Store-Change Management">fileOutChangesFor: id on: stream	self fileOutChangesFor: id within: ( self pundleFor: id ) on: stream</body><body package="Store-Change Management">fileOutChangesFor: anInteger within: aBundle on: aStream		| bundle |	bundle := self pundleFor: anInteger.	componentChanges ifNotNil:		[| block |		block := [componentChanges do: [:comp | comp fileOutChangesFor: anInteger within: aBundle on: aStream]].		self requiresFullCompare			ifTrue: [block value]			ifFalse:				[Notice					showProgress: (#FilingOut1sChanges &lt;&lt; #store &gt;&gt; 'Filing out &lt;1s&gt; changes.' expandMacrosWith: pundle1 name)					complete: self itemCount					while: block					title: #Store &lt;&lt; #store &gt;&gt; 'Store']].	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[bundle fileOutProperties: (self changedPropertiesFor: anInteger) on: aStream.		((self changeSetFor: anInteger) otherChangesInclude: BundleModel structureMark) ifTrue: 			[(BundleStructureChange new component: bundle) fileOutOn: aStream]]</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>accessing</category><body package="Store-Change Management">calcItemCount	^self requiresFullCompare		ifTrue: 			[ componentChanges inject: componentChanges size into: 				[ :count  :cc | count + cc calcItemCount ]				]		ifFalse: [ pundle1 leafItems size * 2 + 1 ].</body><body package="Store-Change Management">itemCount	componentChanges == nil		ifTrue: [ ^1 ].	^componentChanges 		inject: componentChanges size		into: [ :count :cc | count + cc itemCount ].</body></methods><methods><class-id>Store.PublishMergeDialog</class-id> <category>actions</category><body package="Store-UI">accept	"Publish a collection of pundles.  It's possible there have been changes to the bundle since we opened the dialog, so regenerate our model before applying the spec."	self validateParcelOptions ifFalse: [^self].	self validateFileOptions ifFalse: [^self].	(self specList allSatisfy: [:each | self canPublish: each])		ifFalse: [^self].	self newGlobalState.	self fillEmptyComments.	Announcements announce: (StorePrePublish for: self specifications: self specList).	StoreProgressOverlay subsume: builder window		while: 			[self specList publishPundlesForMerge.			callBackBlock ifNotNil: [callBackBlock value: items list]].	Announcements announce: (StorePostPublish for: self specifications: self specList).	self updatePackageListsAndClose</body></methods><methods><class-id>Store.PublishMergeDialog class</class-id> <category>class initialization</category><body package="Store-UI">initialize	super initialize</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>accessing</category><body package="Store-Change Management">containingPackage	"Answer a packge that contians the defintion described by me, nil if none."	^package == nil		ifTrue: [ Registry pundleNamed: symbol asString ]		ifFalse: 			[ package isPackage				ifTrue: [ Registry packageNamed: package name ]				ifFalse: [ Registry bundleNamed: package name ]			].</body><body package="Store-Change Management">package	"Answer the package/bundle from whence we came"	^package</body><body package="Store-Change Management">package: aPackage	"Set the package"	package := aPackage.	package == nil		ifFalse: [ symbol := aPackage name asSymbol ].</body><body package="Store-Change Management">packageName	^package == nil		ifTrue: [ '' ]		ifFalse: [ package name ].</body><body package="Store-Change Management">text	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>actions</category><body package="Store-Change Management">moveToPackage: newPackage	"meaningless in this context."	self shouldNotImplement.</body><body package="Store-Change Management">moveToPackage: newPackage ifNotLoaded: aBlock  	"meaningless in this context."	self shouldNotImplement.</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>testing</category><body package="Store-Change Management">isComponentTag	^true</body><body package="Store-Change Management">isMeta	^false</body><body package="Store-Change Management">isSubdefTag	^true</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>private-loading</category><body package="Store-Change Management">canLoad	"Answer true if a record with my tag can be load into the image."	^self shouldNotImplement</body><body package="Store-Change Management">loadIntoPackage: imgPackage from: dbPackage	"Make sure that modification goes to the proper package."	( imgPackage == nil ) | ( dbPackage == nil )		ifTrue: 			[ Dialog warn: ( (#_1sCannotBeLoadedAckageIsNotLoaded &lt;&lt; #store &gt;&gt; '&lt;1s&gt; cannot be loaded since the package is not loaded.') 				expandMacrosWith: self printString ).			^false 			].	self applyDefinitionFrom: dbPackage into: imgPackage.	^true</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>converting</category><body package="Store-Change Management">asChange	"Answer the receiver as an instance of Change."	^ComponentRelatedChange new tag: self</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>comparing</category><body package="Store-Change Management">= aTag	^super = aTag and:		[self text = aTag text]</body><body package="Store-Change Management">sameAsImage	^self text = self sourceTextForImage</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>comparing</category><body package="Store-Database Model">= anObject	^self class = anObject class and: [self isTheSameAs: anObject]</body><body package="Store-Database Model">hash	^self longName hash bitXor: self package hash</body><body package="Store-Database Model">isTheSameAs: aStoreClassExtension	"Return true if the set of methods, the definition, and so forth, are exactly the same"	aStoreClassExtension isNil ifTrue: [^false].	name = aStoreClassExtension name ifFalse: [^false].	longName = aStoreClassExtension longName ifFalse: [^false].	(aStoreClassExtension classDefinition = nil and: [self classDefinition ~= nil]) ifTrue: [^false].	(self classDefinition = nil and: [aStoreClassExtension classDefinition ~= nil]) ifTrue: [^false].	self classDefinition = nil ifFalse: [		aStoreClassExtension classDefinition definition yourSelf == self classDefinition definition yourSelf ifFalse: [^false]].	(self methodsFrom: self instanceMethods areIncludedIn: aStoreClassExtension instanceMethods) ifFalse: [^false].	(self methodsFrom: aStoreClassExtension instanceMethods areIncludedIn: self instanceMethods) ifFalse: [^false].	(self methodsFrom: self classMethods areIncludedIn: aStoreClassExtension classMethods) ifFalse: [^false].	(self methodsFrom: aStoreClassExtension classMethods areIncludedIn: self classMethods) ifFalse: [^false].	^true.</body><body package="Store-Database Model">matchesWith: aStoreClassExtension	"Return true if the set of methods, the definition, and so forth, are exactly the same"	^self isTheSameAs: aStoreClassExtension.</body><body package="Store-Database Model">methodsFrom: aMethodList areIncludedIn: otherMethodList	| otherMethodDict |	otherMethodDict := Dictionary new.	otherMethodList do: [:ea|		otherMethodDict at: ea definition put: ea].	aMethodList do: [:ea|		otherMethodDict at: ea definition ifAbsent: [^false]].	^true</body><body package="Store-Database Model">newMethodsFrom: aMethodList areIncludedIn: otherMethodList	| otherMethodDict |	otherMethodDict := Dictionary new.	otherMethodList do: [:ea|		otherMethodDict at: ea definition put: ea].	aMethodList do: [:ea|		otherMethodDict at: ea definition ifAbsent: [^false]].	^true</body><body package="Store-Database Model">oldMethodsFrom: aMethodList areIncludedIn: otherMethodList	^aMethodList allSatisfy: [:eachSource |		otherMethodList anySatisfy: [:eachTarget |			eachSource definition = eachTarget definition]].</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>accessing</category><body package="Store-Database Model">absoluteOwnerName	"If the class definition is nil, then I represent a class that has been extended in a package.	In that case, I take the ugly, garbage creation route of computing my owner name from my 	longName string, which is what #computedAbsoluteOwnerName does"	^classDefinition isNil		ifTrue: [self computedAbsoluteOwnerName]		ifFalse: [classDefinition environmentName]</body><body package="Store-Database Model">asNameSpace	"hack"	^StoreNameSpace new</body><body package="Store-Database Model">classDefinition	"Bad sneakiness here. Use special symbol as a marker to indicate that the class definition IS nil, and we don't need to lazy evaluate for it"	classDefinition == #thereIsNoClassDefinitionUseTheAccessorMethod ifTrue: [^nil].	classDefinition isNil ifTrue: [		classDefinition := self package classDefinitions detect: [:each | each longName = self longName] ifNone: [nil]].	^classDefinition.</body><body package="Store-Database Model">classDefinition: aStoreClassDefinitionInPackage	aStoreClassDefinitionInPackage yourSelf isNil		ifTrue: [classDefinition := #thereIsNoClassDefinitionUseTheAccessorMethod. ^self].	classDefinition := aStoreClassDefinitionInPackage.</body><body package="Store-Database Model">classMethods	^classMethods</body><body package="Store-Database Model">classMethods: aCollection	classMethods := aCollection</body><body package="Store-Database Model">commentKey	| comment |	self classDefinition isNil ifTrue: [^nil].	comment := self classDefinition comment.	comment isEmpty ifTrue: [^nil].	^comment.</body><body package="Store-Database Model">computedAbsoluteOwnerName	"Fortunately, instances of me are always created with a long name"	^self longName copyFrom: 1 to: (self longName lastIndexOf: $.) - 1</body><body package="Store-Database Model">instanceMethods	^instanceMethods</body><body package="Store-Database Model">instanceMethods: aCollection	instanceMethods := aCollection</body><body package="Store-Database Model">longName	^longName.</body><body package="Store-Database Model">longName: aString	longName := aString.	name isNil ifTrue: [name := (longName tokensBasedOn: $.) last].</body><body package="Store-Database Model">name	^name</body><body package="Store-Database Model">name: aString	name := aString</body><body package="Store-Database Model">package	^package</body><body package="Store-Database Model">package: aStorePackage	package := aStorePackage</body><body package="Store-Database Model">primaryKey	^self package primaryKey</body><body package="Store-Database Model">storeMetaClass	metaclass isNil ifTrue: [metaclass := StoreMetaclassExtension on: self].	^metaclass.</body><body package="Store-Database Model">superclassName	^classDefinition superclassName</body><body package="Store-Database Model">timestamp	^self package timestamp.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize	super initialize.	classMethods := IdentitySet new.	instanceMethods := IdentitySet new.	sharedVariables := IdentitySet new.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>adding</category><body package="Store-Database Model">addAllFrom: aStoreClassExtension	"We don't just add them all, since the values might be held onto, so we make a copy of our values	Just to make sure new values don't bleed into other owners.	Because of the possible existance of overrides, we do this the hard way. Overriden (last) gets priority"	| newMethods |	newMethods := OrderedSet withAll: aStoreClassExtension classMethods.	newMethods addAll: classMethods.	classMethods := newMethods.	newMethods := OrderedSet withAll: aStoreClassExtension instanceMethods.	newMethods addAll: instanceMethods.	instanceMethods := newMethods.	sharedVariables := sharedVariables copy. 	sharedVariables addAll: aStoreClassExtension sharedVariables.	(classDefinition isNil and: [aStoreClassExtension classDefinition notNil])		ifTrue: [classDefinition := aStoreClassExtension classDefinition].	metaclass := StoreMetaclassExtension on: self</body><body package="Store-Database Model">addClassMethod: aStoreMethodInPackage	classMethods add: aStoreMethodInPackage yourSelf.</body><body package="Store-Database Model">addInstanceMethod: aStoreMethodInPackage	self instanceMethods add: aStoreMethodInPackage yourSelf.</body><body package="Store-Database Model">addMethod: aStoreMethodInPackage	(self includesMethod: aStoreMethodInPackage) ifFalse: [		aStoreMethodInPackage isMetaclass			ifTrue: [self addClassMethod: aStoreMethodInPackage]			ifFalse: [self addInstanceMethod: aStoreMethodInPackage]].</body><body package="Store-Database Model">includesMethod: aStoreMethodInPackage	^aStoreMethodInPackage isMetaclass		ifTrue: [classMethods includes: aStoreMethodInPackage yourSelf]		ifFalse: [self instanceMethods includes: aStoreMethodInPackage yourSelf].</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>non-namespace</category><body package="Store-Database Model">sharedVariables	^self classDefinition 		ifNotNil: [self package sharedVariablesForClass: self classDefinition]		ifNil: [sharedVariables]</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>loading</category><body package="Store-Database Model">loadSource		| allMethods |	self classDefinition ifNotNil: [self classDefinition loadSource].	allMethods := self instanceMethods copy.	allMethods addAll: self classMethods.	allMethods do: [:each | each loadSource].	self sharedVariables do: [:each | each loadSource].</body><body package="Store-Database Model">loadSourceDirect		^self classDefinition ifNotNil: [self classDefinition loadSourceDirect].</body><body package="Store-Database Model">loadSourceInto: aPackageModelOrNil		^aPackageModelOrNil isNil		ifTrue: [self loadSource]		ifFalse: [Store.Policies packagePolicy forcePackage: aPackageModelOrNil while: [self loadSource]]</body><body package="Store-Database Model">loadSrcInto: aPackageModel	self loadSourceInto: aPackageModel</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>testing</category><body package="Store-Database Model">isAbstract	^false.</body><body package="Store-Database Model">isForGeneral	^false.</body><body package="Store-Database Model">isInClass	^false.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">initialMethodCategory	^Symbol new</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>converting</category><body package="StoreForGlorpVWUI">allStoreVersions	^[(Store.Gathering for: self name) started.		StoreClassDefinitionInPackage allVersionsWithName: self name inOwner: self absoluteOwnerName in: package session]		ensure: [(Store.Gathering for: self name) finished]</body><body package="Store-Database Model">asStoreClassDefinition	^self classDefinition ifNotNil: [:value | value definition]</body><body package="Store-Database Model">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage classDefinitions		detect: [:each | each definition = self classDefinition]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: StoreClassDefinitionInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self classDefinition primaryKey)].	^result</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>image compatibility</category><body package="Store-Database Model">classBehavior	"Override this to provide my corresponding StoreMetaClassExtension"	metaclass := StoreMetaclassExtension on: self.	^metaclass.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>copying</category><body package="Store-Database Model">postCopy	super postCopy.	instanceMethods := instanceMethods copy.	classMethods := classMethods copy.</body></methods><methods><class-id>Store.PackageConflicts</class-id> <category>private</category><body package="Store-Change Management">conflictingDataFrom: aDiffHolder	"Given a difference holder compute collections of conflicting data elements.  	Each collection contains data that are modified in both pkg1 and pkg2."	data2 := SortedCollection sortBlock: [ :x :y | x name &lt; y name].	data1 := ( aDiffHolder dataSide: 1 ) select: 		[ :datum |  | conflict |		conflict := ( aDiffHolder dataSide: 2 ) detect: 				[ :x | x name = datum name and: [ x ownerName = datum ownerName ] ]				ifNone: [ nil ].		conflict notNil			ifTrue: 				[ data2 add: conflict.				true]			ifFalse: [false]].	data1 := data1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management">conflictingMethodsFrom: aDiffHolder	"Given a difference holder compute collections of conflicting methods.  	Each collection contains classes that are modified in both pkg1 and pkg2."	methods2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	methods1 := ( aDiffHolder methodsSide: 1 ) select: 		[ :cl |  | cc |		cc := ( aDiffHolder methodsSide: 2 ) detect: 				[ :x | x name = cl name and: [ x className = cl className ] ]				ifNone: [ nil ].		cc notNil			ifTrue: 				[methods2 add: cc.				true]			ifFalse: [false]].	methods1 := methods1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management">conflictingNameSpacesFrom: aDiffHolder	"Given a difference holder compute collections of conflicting namespaces.  	Each collection contains classes that are modified in  both pkg1 and pkg2."	nameSpaces2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	nameSpaces1 := (aDiffHolder nameSpacesSide: 1) select: 		[:ns |   | cc |		cc := ( aDiffHolder nameSpacesSide: 2 ) 					detect: [:x | x absoluteName = ns absoluteName] ifNone: [nil].		cc notNil			ifTrue: [ nameSpaces2 add: cc.					true]			ifFalse: [ false ] 		].	nameSpaces1 := nameSpaces1 asSortedCollection: [ :x :y | x name &lt; y name ].</body></methods><methods><class-id>Store.FilingOut</class-id> <category>accessing</category><body package="Store-Difference Management">actionText	^(#FilingOut &lt;&lt; #store &gt;&gt; 'Filing Out') asString</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">environment: anEnvironment	environment := anEnvironment</body><body package="StoreForGlorpBrowserUI">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI">methodNamed: aSelector inClass: aClass	^environment methodNamed: aSelector inClass: aClass</body><body package="StoreForGlorpBrowserUI">nameSpaceForName: aString ifAbsent: aBlock	^environment nameSpaceForName: aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body><body package="StoreForGlorpBrowserUI">repositoryName	^environment repositoryName</body><body package="StoreForGlorpBrowserUI">sharedVariable: aName for: aClassOrNameSpace	^environment sharedVariable: aName for: aClassOrNameSpace asString</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id> <category>adding</category><body package="StoreForGlorpBrowserUI">addClass: aClass selector: aSymbol 	definitions add: (StoreMethodDefinition class: aClass selector: aSymbol).	super addClass: aClass selector: aSymbol</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI">at: className ifAbsent: aBlock	^environment at: className ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">classForName: aString ifAbsent: aBlock	^environment classForName:  aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">classesDo: aBlock 	classSelectors keysDo: 		[:each | 		| class |		class := environment classForName: each.		(class notNil and: [environment includesClass: class]) 			ifTrue: [aBlock value: class]].	metaClassSelectors keysDo: 		[:each | 		| class |		class := environment classForName: each.		(class notNil and: [environment includesClass: class storeMetaClass]) 			ifTrue: [aBlock value: class storeMetaClass]]</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI">implementorsMatching: aString in: anEnvironment	^self implementorsOf: aString in: anEnvironment</body><body package="StoreForGlorpBrowserUI">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copy].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copy]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body><body package="StoreForGlorpBrowserUI">new	^self onEnvironment: StoreForGlorpBrowserEnvironment new</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">refresh		propertyParts := object		ifNil: [List new]		ifNotNil:			[(object properties keys asList				collect: [:each | StoreCodeComponentInspectorField named: each in: object]) sorted].	super refresh</body><body package="StoreForGlorpBrowserUI">textAcceptAllowed	^false</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>actions-drag/drop</category><body package="StoreForGlorpBrowserUI">wantToDrag: aController	^false</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>actions</category><body package="StoreForGlorpBrowserUI">changeRequest	^true</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>decomposing</category><body package="StoreForGlorpBrowserUI">partAt: anIndex	^propertyParts at: anIndex</body><body package="StoreForGlorpBrowserUI">partCount	^object		ifNil: [0]		ifNotNil: [propertyParts size]</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>properties</category><body package="StoreForGlorpBrowserUI">dragControllerClass	^Tools.Trippy.ReplaceOnlyDragController</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>menu management</category><body package="StoreForGlorpBrowserUI">buildFieldListMenu	"Build the popup menu for the field list. Besides the usual things,	it should include items for actions published by the currently selected	object, if there is one."		| menu |	menu := self class fieldListMenu.	(menu atNameKey: #dive) visibility: [self canDive].	(menu atNameKey: #spawn) enabled: [self canDive].	(self hasSingleSelection and: [self selection hasValue])		ifTrue: [self addSelectionActionsToFieldMenu: menu].	menu		augmentFrom: PartListAbstractInspector		to: PartListAbstractInspector		menuName: #fieldList		for: self.	^menu</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>interface opening</category><body package="StoreForGlorpBrowserUI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(aBuilder componentAt: #document) widget isReadOnly: true</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">canPaste	^false</body></methods><methods><class-id>Store.AtomicLoadingError</class-id> <category>actions</category><body package="Atomic Compiling and Loading">abortLoad	"This is a helper method for users of this Error"	self return</body><body package="Atomic Compiling and Loading">defaultAction	"What to do when the exception is unhandled."		Dialog warn: self defaultMessageText.	^false</body></methods><methods><class-id>Store.AtomicLoadingError</class-id> <category>printing</category><body package="Atomic Compiling and Loading">defaultMessageText		^#_1sIsUnableToBeLoadedN2s3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is unable to be loaded' expandMacrosWith: package name</body></methods><methods><class-id>Store.AtomicLoadingError class</class-id> <category>testing</category><body package="Atomic Compiling and Loading">mayResume	^true</body></methods><methods><class-id>Store.AtomicLoadingError class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">pundle: aPundle	^self new		package: aPundle;		raise</body><body package="Atomic Compiling and Loading">pundle: aPundle failed: aShadowPackageCompileManager	^self new		package: aPundle;		parameter: aShadowPackageCompileManager;		raise</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>loading</category><body package="Store-Database Model">loadNewSource: aString	"Answer nil if there is a failure, otherwise the real thing"	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableSharedMessageForUnspecifiedClass inPackage: self package].	Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[| binding |			binding := self evaluateDefinition: aString 				onError: [:exception | ^self raiseUnloadableError: exception inPackage: self package].			(Undeclared includesKey: binding name) ifTrue:				[| msg |				msg := AbstractPundleLoader unloadableSharedMessageForPossibleLoadOrder: binding name.				Transcript show: msg.				^self raiseUnloadableError: msg inPackage: self package]].	^self</body><body package="Store-Database Model">loadSource	"Answer nil if there is a failure, otherwise the real thing"	self environmentString isEmpty ifTrue:		[^self raiseUnloadableError: AbstractPundleLoader unloadableSharedMessageForUnspecifiedClass inPackage: self package].	Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[| binding |			binding := self evaluateDefinition: self definitionString				onError: [:exception | ^self raiseUnloadableError: exception inPackage: self package].			(Undeclared includesKey: binding name) ifTrue:				[| msg |				msg := AbstractPundleLoader unloadableSharedMessageForPossibleLoadOrder: binding name.				^self raiseUnloadableError: msg inPackage: self package]].	^self</body><body package="Store-Database Model">loadSourceDirect	"Answer nil if there is a failure, otherwise the real thing"	^self definition loadSourceDirectInPackage: self package</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>accessing</category><body package="Store-Database Model">absoluteOwnerName	^self definition absoluteOwnerName.</body><body package="StoreForGlorpVWUI">allStoreVersions	| session |	^[(Store.Gathering for: self name) started.		session := StoreLoginFactory currentStoreSession.	self class		allVersionsWithName: self name		inOwner: self absoluteOwnerName		in: session]		ensure: [(Store.Gathering for: self name) finished]</body><body package="Store-Code Comparison">asBlueprint	| definitionParts myReference blueprint |	blueprint := SharedVariableBlueprint of: self.	definitionParts := blueprint parseDefinition: self definition definition.	myReference := self fullName asQualifiedReference.	blueprint reference: myReference.	blueprint category: self protocol.	blueprint isPrivate: (definitionParts at: #private:).	blueprint isConstant: (definitionParts at: #constant:).	blueprint initializer: (definitionParts at: #initializer:).	^blueprint</body><body package="Store-Database Model">classNameWithoutMeta	^self definition classNameWithoutMeta</body><body package="Store-Database Model">classOrNameSpace	^self owner</body><body package="Store-Database Model">comment	^definition comment</body><body package="StoreForGlorpVWUI">dataKey	^self definition dataKey.</body><body package="Store-Database Model">environment	^self owner</body><body package="Store-Database Model">environmentName	^self definition environmentName</body><body package="Store-Database Model">key	^self dataKey.</body><body package="Store-Database Model">owner	^self definition owner.</body><body package="StoreForGlorpVWUI">ownerName	^self definition ownerName.</body><body package="Store-Database Model">protocol	^self definition protocol</body><body package="Store-Database Model">versions	| session sharedDefinitionQuery shareds uniqueKeys |	session := StoreLoginFactory currentStoreSession.	sharedDefinitionQuery := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	sharedDefinitionQuery alsoFetch: #definition.	sharedDefinitionQuery orderBy: [:each | each definition timestamp descending].	shareds := session execute: sharedDefinitionQuery.	uniqueKeys := Set new.	^shareds inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>comparing</category><body package="Store-Database Model">= aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifTrue:		[^self package yourSelf = aStoreObjectInPackage package yourSelf			and: [self definition reconcilesWith: aStoreObjectInPackage definition]].	(aStoreObjectInPackage respondsTo: #asStoreSharedVariable) ifFalse: [^false].	^self definition = aStoreObjectInPackage asStoreSharedVariable</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>testing</category><body package="Store-Database Model">isBindingReference	^true</body><body package="Store-Database Model">isClassVariable	^self definition isClassVariable.</body><body package="Store-Database Model">isForData	^true.</body><body package="StoreForGlorpVWUI">isForGeneral	^false.</body><body package="Store-Database Model">isForSharedVariable	^true.</body><body package="Store-Database Model">isInNameSpace	^self definition isInNameSpace.</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>compatibility</category><body package="Store-Database Model">asNameSpace	"hack"	^Store.Glorp.StoreNameSpace new</body><body package="Store-Database Model">isInClass	^self definition isClassVariable.</body><body package="StoreForGlorpVWUI">loadSrc	^self loadSource</body><body package="StoreForGlorpVWUI">removeFromPackage: aPackageModel	Store.XMainChangeSet current		addRemoveStatic: self dataKey		ownerName: self environmentString		isInNameSpace: self definition isInNameSpace		package: aPackageModel</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>printing</category><body package="Store-Database Model">displayString	^self name</body><body package="Store-Database Model">printOutOn: aStream	"Print me out on a textStream"	| saved |	saved := aStream emphasis.	aStream emphasis: #bold.	aStream nextPutAll: self definitionString.	aStream cr.	aStream emphasis: #italic.	aStream cr.	aStream nextPutAll: self definition comment.	aStream emphasis: saved.	aStream cr.	aStream cr</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>filing out</category><body package="Store-Database Model">fileOutDifferencesBetween: aSharedInPackage on: aSourceCodeStream	self definitionString = aSharedInPackage definitionString ifFalse:		[self fileOutSourceOn: aSourceCodeStream]</body><body package="Store-Database Model">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#variable</body><body package="Store-Database Model">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>displaying</category><body package="StoreForGlorpVWUI">statusLineString	^self definition protocol.</body><body package="StoreForGlorpVWUI">variableName	^self dataKey</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStoreSharedVariable	^self definition</body><body package="Store-Database Model">correspondingImageBinding	^self definition ifNotNil: [:value | value correspondingImageBinding].</body><body package="Store-Database Model">correspondingImageSharedVariable	^self definition ifNotNil: [:value | value correspondingImageSharedVariable].</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>reconciling</category><body package="Store-Database Model">equalsSignatureIn: aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifFalse: [		^self definition equalsSignatureIn: aStoreObjectInPackage asStoreSharedVariable].	^self package yourSelf = aStoreObjectInPackage package yourSelf and: [self definition equalsSignatureIn: aStoreObjectInPackage definition].</body><body package="Store-Database Model">signatureHash	^self definition signatureHash</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeShared: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineSharedVariable:' startingAt: 1.	insertPoint isZero ifTrue: [insertPoint := definitionString indexOfSubCollection: 'defineStatic:' startingAt: 1].	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedSharedVariableObject</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage class</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">toolListIcon	^VisualStack with: BehaviorIcons Object with: BehaviorIcons SharedVariableOverlay</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage class</class-id> <category>instance creation</category><body package="Store-Database Model">newFor: aSharedVariable package: aPackage		| sharedVariableDefinition |	sharedVariableDefinition := aSharedVariable asStoreSharedVariable.	sharedVariableDefinition updateUserAndTimestampFrom: aPackage.	^(self new)		definition: sharedVariableDefinition;		package: aPackage</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>interface opening</category><body package="Store-Merge Management">postBuildWith: aBuilder	| iconComponent |	super postBuildWith: aBuilder.	(iconComponent := builder componentAt: #HelpIconList) isNil		ifTrue: [^self].	self setupVisualBlockFor: iconComponent widget.</body><body package="Store-Merge Management">postOpenWith: aBuilder	super postBuildWith: aBuilder.	self setCloseOnEscapeKeyboardHook.	(builder componentAt: #HelpText) ifNotNil: 		[:wrapper | 		wrapper takeKeyboardFocus.		self setHelpTextKeyboardHook: wrapper widget controller].	(builder componentAt: #HelpIconList) isNil		ifTrue: [^self].	self helpIconList list: self createIconList.</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>private</category><body package="Store-Merge Management">createIconList	| widget list style offset |	widget := (builder componentAt: #HelpIconList) widget.	widget lineGrid: 20.	style := widget textStyle.	offset := 6 @ 2.	list := List new.	list		add: ((LabelAndIcon				with: #Unresolved &lt;&lt; #store &gt;&gt; 'Unresolved'				attributes: style				offset: offset) icon: MergeIcons unresolved).	list		add: ((LabelAndIcon				with: #ResolvedOrResolution &lt;&lt; #store &gt;&gt; 'Resolved or resolution'				attributes: style				offset: offset) icon: MergeIcons resolved).	list		add: ((LabelAndIcon				with: #Applied &lt;&lt; #store &gt;&gt; 'Applied'				attributes: style				offset: offset) icon: MergeIcons applied).	list		add: ((LabelAndIcon				with: #Class &lt;&lt; #store &gt;&gt; 'Class'				attributes: style				offset: offset) icon: Behavior toolListIcon).	list		add: ((LabelAndIcon				with: #Namespace &lt;&lt; #store &gt;&gt; 'Namespace'				attributes: style				offset: offset) icon: GeneralNameSpace toolListIcon).	list		add: ((LabelAndIcon				with: #AddComponent &lt;&lt; #store &gt;&gt; 'Add component'				attributes: style				offset: offset) icon: MergeIcons add).	list		add: ((LabelAndIcon				with: #ModifiyComponent &lt;&lt; #store &gt;&gt; 'Modifiy component'				attributes: style				offset: offset) icon: MergeIcons modify).	list		add: ((LabelAndIcon				with: #RemoveComponent &lt;&lt; #store &gt;&gt; 'Remove component'				attributes: style				offset: offset) icon: MergeIcons remove).	list		add: ((LabelAndIcon				with: #MoveComponent &lt;&lt; #store &gt;&gt; 'Move component'				attributes: style				offset: offset) icon: MergeIcons move).	^list</body><body package="Store-Merge Management">helpText	^ (#MergeHelpText &lt;&lt; #store &gt;&gt; 'Overview&lt;n&gt;Merging of a package is done by merging a version from the repository into the version in the image. The image version is referred to as the trunk and the repository version is referred to as the branch. The merge process first finds the most recent version that is the ancestor of trunk and the branch, i.e. where branch forked off. Next, changes are computed from this common (base) version to both the trunk and the branch. For each component change, a modification set is created. Each modification set holds the changes made by the versions being merged.&lt;nn&gt;After all the modification sets have been created, the modifications are analyzed to calculate resolutions. If there is only one change from the base version then that change becomes the resolution. If there is more than one change then the modification set is left to the user to resolve. Additionally, if the computed resolution is already in the trunk then the modification is marked as having been applied. Also, if the "Hide Image Only Mods" option, under the View menu, is set then these mods are not shown in the modification view.&lt;nn&gt;Image Only Mods are modification sets that contain only changes between the base version and the image. When one considers the image version to be the trunk version the image only mods are of little interest because they are the desired changes and need no further review.&lt;nn&gt;The modification sets are displayed in either in a list or a hierarchy in the Modifications pane. The resolution status of each modification set is shown by the leftmost icon. Upon selecting a modification set, the individual modification versions are shown in the Versions pane. The user can then review, compare, and determine which version is to be the resolution. After the modification resolutions have been determined they must be applied. Applying a resolution modifies the image to correspond to the resolution. After all resolutions have been applied the bundles/packages can be published.&lt;nn&gt;Selecting packages to merge&lt;nt&gt;Open the package selection dialog either from the Packages menu or from "Select Packages..." button.&lt;nt&gt;Only bundles/packages loaded in the image will appear in the "Bundles and packages" list. Upon selecting a package/bundle the versions will appear in the "Versions:" list. The versions to merge can then be added to the "Selected versions:" list.&lt;nt&gt;When the "Selected versions:" list has all the desired versions, hit the OK button and the process to calculate the modification set will begin.&lt;nn&gt;Modifications Pane&lt;n&gt;The modification sets can be viewed (top left) either in a list or a hierrarchy. When viewed in a hierarchy the first level is either a package or a bundle. The second level items can be a namespace, a class, a property, or an aggregate class operation.&lt;nn&gt;Commands&lt;nt&gt;Unresolve&lt;tttt&gt;Marks the modification set as being unresolved. However, if a resolution had been applied the image state is not reverted.&lt;nt&gt;Apply Resolution&lt;tt&gt;Applies the selected resolution.&lt;nt&gt;Browse Senders&lt;ttt&gt;Opens a browser on the method senders.&lt;nt&gt;Browse Implementors&lt;t&gt;Opens a browser on the method implementors.&lt;nt&gt;Browse Versions&lt;tt&gt;Opens a version browser on the selected component.&lt;nt&gt;Show All&lt;tttt&gt;Unfiltered.&lt;nt&gt;Show Conflicts&lt;ttt&gt;Filters the modifications pane so only modification sets with conflicts are shown.&lt;nt&gt;Show Unresolved&lt;tt&gt;Filters the modifications pane so only unresolved modification sets are shown.&lt;nt&gt;Hide Image-only Mods&lt;t&gt;Hides modification sets that contain only changes between the image and base version.&lt;nn&gt;Versions Pane&lt;n&gt;The versions pane (top right) shows the different versions available, and can be used to choose a resolution for the item selected in the modifications pane.&lt;nn&gt;Commands&lt;nt&gt;Unresolve&lt;tttt&gt;Marks the modification set as being unresolved. However, if a resolution had been applied the image state is not reverted.&lt;nt&gt;Select as Resolution&lt;t&gt;Marks the selected version as the resolution for the current modification set.&lt;nt&gt;Apply Resolution&lt;tt&gt;Applies the current resolution of the selected modification set.&lt;nt&gt;Open comparison with Base&lt;ttt&gt;Opens a differator window comparing the base with the selected version.&lt;nt&gt;Open comparison with Resolution&lt;t&gt;Opens a differator window comparing the resolution with the selected version.&lt;nt&gt;Open comparison with Image&lt;tt&gt;Opens a differator window comparing the image with the selected version.&lt;nt&gt;Open Comparison of Selected&lt;tt&gt;Opens a differator window comparing the two selected versions.&lt;nn&gt;Code Pane&lt;n&gt;The lower left pane shows the code associated with a selected version. Sometimes when a conflict is encountered, there is no selection that represents the desired outcome. This pane may be used as a normal code editing pane to accept an entirely new resolution. The particular change will be marked as applied when changes are accepted in this pane.&lt;nn&gt;Comparison Pane&lt;n&gt;The lower right pane allows the user to choose different versions that are available as part of the merge and compare them against the version selected in the versions pane.') expandMacros</body><body package="Store-Merge Management">setCloseOnEscapeKeyboardHook	builder keyboardProcessor keyboardHook:		[:event :controller |		Character esc = event keyValue ifTrue: [self closeRequest].		event].</body><body package="Store-Merge Management">setHelpTextKeyboardHook: aController	aController keyboardHook:		[:event :controller |		(#(PageDown PageUp) includes: event keyValue)			ifTrue: [event]			ifFalse: [nil]]</body><body package="Store-Merge Management">setupVisualBlockFor: listView	listView visualBlock: 		[:view :index | BoundedWrapper on: (view sequence at: index)].	listView controller: NoController new.</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	super initialize.	self helpIconList list: List new.</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>aspects</category><body package="Store-Merge Management">helpIconList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^helpIconList isNil		ifTrue:			[helpIconList := SelectionInList new]		ifFalse:			[helpIconList]</body><body package="Store-Merge Management">helpTextHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^helpTextHolder isNil		ifTrue:			[helpTextHolder := self helpText asValue]		ifFalse:			[helpTextHolder]</body></methods><methods><class-id>Store.MergeToolHelp class</class-id> <category>interface opening</category><body package="Store-Merge Management">openHowToUseHelp	self openWithSpec: #howToUseHelpSpec</body><body package="Store-Merge Management">openIconHelp	self openWithSpec: #iconHelpSpec</body></methods><methods><class-id>Store.MethodDifferenceBrowser</class-id> <category>aspects</category><body package="Store-UI-Definition Comparison">protocol1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^protocol1 isNil		ifTrue:			[protocol1 := String new asValue]		ifFalse:			[protocol1]</body><body package="Store-UI-Definition Comparison">protocol2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^protocol2 isNil		ifTrue:			[protocol2 := Text new asValue]		ifFalse:			[protocol2]</body></methods><methods><class-id>Store.MethodDifferenceBrowser</class-id> <category>menu messages</category><body package="Store-UI-Definition Comparison">findDiffs	| firstProtocolText secondProtocolText prefix |	super findDiffs.	firstProtocolText := protocol1 value asText.	secondProtocolText := protocol2 value asText.	firstProtocolText = secondProtocolText		ifFalse: 			[firstProtocolText := firstProtocolText						emphasizeAllWith: #color -&gt; ColorValue red.			secondProtocolText := secondProtocolText						emphasizeAllWith: #color -&gt; ColorValue red].	prefix := (#ProtocolSpaceColonSpace &lt;&lt; #store &gt;&gt; 'Protocol : ') asText				allBold.	(self builder componentAt: #protocol1) widget model		value: prefix , firstProtocolText.	(self builder componentAt: #protocol2) widget model		value: prefix , secondProtocolText</body></methods><methods><class-id>Store.MethodDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Definition Comparison">compare: text1 with: text2 protocol: text3 with: text4		| instance |	instance := self new.	instance text1 value: text1.	instance text2 value: text2.	instance protocol1 value: text3.	instance protocol2 value: text4.	instance openInterface: #briefSpec</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>actions</category><body package="Store-UI">fileClose	self closeRequest</body><body package="Store-UI">fileImport	self class importRepositoriesFromFile</body><body package="Store-UI">fileSave	self class saveRepositoriesToFile</body><body package="Store-UI">helpAbout	AboutVisualWorksDialog open</body><body package="Store-UI">repositoryMoreRecentlyPublishedItems	DbRegistry doIfOnlineImage: 		[[InputState default ctrlDown			ifTrue: [Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItemsWithFilter]			ifFalse: [Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItemsUnfiltered]] 				withStoreFeedbackOn: self mainWindow]</body><body package="Store-UI">repositoryNew	RepositoryManager addProfileFromUser ifNotNil: 		[:newProfile | self repositoryListHolder selection: newProfile]</body><body package="Store-UI">repositoryProperties	self repositoryListHolder selectionDo:		[:selection |		RepositoryPropertiesDialog openOn: selection.		self class updateRepository: selection]</body><body package="Store-UI">repositoryPublishedItems	DbRegistry doIfOnlineImage: 		[InputState default ctrlDown			ifTrue: [Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesWithFilter]			ifFalse: [Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesUnfiltered]]</body><body package="Store-UI">repositoryRemove	self repositoryListHolder selectionDo:		[:selection |		(Dialog confirm: #repmanRemoveRepositoryQuestion &lt;&lt; #labels &gt;&gt; 'Remove the selected repository?') 			ifTrue: [self class removeRepository: selection]]</body><body package="Store-UI">repositoryToggleConnection	Cursor wait showWhile:		[self repositoryListHolder selectionDo:			[:profile |			profile isConnected				ifTrue: [DbRegistry disconnect]				ifFalse: [DbRegistry connectTo: profile]]]</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	DbRegistry connectedProfileHolder		onChangeSend: #connectedProfileChanged		to: self</body><body package="Store-UI">on: aProfileCollection	self setRepositoryList: aProfileCollection</body><body package="Store-UI">postBuildWith: aBuilder	| descriptors |	descriptors := (self widgetAt: #repositoryDataset) columnDescriptors.	descriptors first rendererSpec: self statusColumnSpec.</body><body package="Store-UI">release	super release.	DbRegistry connectedProfileHolder		retractInterestsFor: self</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>notifications</category><body package="Store-UI">connectedProfileChanged	self refreshRepositoryView</body><body package="Store-UI">noticeOfWindowClose: aWindow	self release.	^super noticeOfWindowClose: aWindow</body><body package="Store-UI">repositoryListDoubleClicked	self repositoryToggleConnection</body><body package="Store-UI">repositorySelected	self updateToolbar</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>aspects</category><body package="Store-UI">repositoryListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^repositoryListHolder isNil		ifTrue:			[repositoryListHolder :=  SelectionInList new]		ifFalse:			[repositoryListHolder]</body><body package="Store-UI">selectedRepositoryHolder	^self repositoryListHolder selectionHolder</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>menus</category><body package="Store-UI">menuBar	| menu |	menu := self class menuBar.	menu		augmentFrom: self class		to: RepositoryManager		menuName: #menuBar		for: self.	(menu atNameKey: #repositoryToggleConnection) 		rawLabel: [self repositoryToggleConnectionItemLabel].	^menu</body><body package="Store-UI">repositoryListMenu	| menu |	menu := self class repositoryListMenu.	menu 		augmentFrom: self class		to: RepositoryManager		menuName: #listMenu		for: self.	(menu atNameKey: #repositoryToggleConnection) 		rawLabel: [self repositoryToggleConnectionItemLabel].	^menu</body><body package="Store-UI">repositoryToggleConnectionItemLabel	^self repositoryListHolder selection		ifNil: [#repmanConnectItem &lt;&lt; #labels &gt;&gt; '&amp;Connect']		ifNotNil: [:profile |			profile isConnected 				ifTrue: [#repmanDisconnectItem &lt;&lt; #labels &gt;&gt; '&amp;Disconnect'] 				ifFalse: [#repmanConnectItem &lt;&lt; #labels &gt;&gt; '&amp;Connect']]</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>private</category><body package="Store-UI">connectedRepositoryIcon	^connectedIcon ifNil: 		[connectedIcon := ToolbarIconLibrary visualFor: #store]</body><body package="Store-UI">refreshRepositoryView	(self widgetAt: #repositoryDataset) invalidate</body><body package="Store-UI">setRepositoryList: aList	self repositoryListHolder list: Repositories</body><body package="Store-UI">statusColumnSpec	^ArbitraryViewSpec new		source: #statusColumnVisual:;		flags: 0</body><body package="Store-UI">statusColumnVisual: isConnected 	^isConnected 		ifTrue: [self connectedRepositoryIcon]		ifFalse: [VisualPart new]</body><body package="Store-UI">updateToolbar	(self widgetAt: #toolbarMenu) updateToolBar</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>testing</category><body package="Store-UI">isRepositorySelected	^self repositoryListHolder selectionIndex ~= 0</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>accessing</category><body package="Store-UI">addRepository: aProfile	Repositories 		add: aProfile;		sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI">removeRepository: aProfile	Repositories remove: aProfile</body><body package="Store-UI">repositories	^Repositories</body><body package="Store-UI">sortRepositoryList	Repositories sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI">updateRepository: aProfile	| index |	index := Repositories indexOf: aProfile.	index = 0 ifFalse: [Repositories changed: #at: with: index].	DbRegistry connectedProfileHolder value = aProfile		ifTrue: [DbRegistry connectedProfileHolder changed: #value]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>private</category><body package="Store-UI">addRepositories: aCollection	Repositories 		removeAllSuchThat: 			[:existingProfile | 			aCollection anySatisfy: [:newProfile| newProfile = existingProfile]];		addAll: aCollection;		sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI">replaceRepositoriesWith: aCollection	Repositories 		removeAllSuchThat: [:anything | true];		addAll: aCollection;		sortWith: [:a :b | a name &lt; b name]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>instance creation</category><body package="Store-UI">new	^super new on: self repositories</body><body package="Store-UI">open	"Override to use the currently-open manager, if one exists."	^self raiseSingleInstance ifNil: [super open]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>utilities</category><body package="Store-UI">addProfileFromUser	| newProfile |	newProfile := Store.ConnectionProfile new.	newProfile name: (#Repository1p &lt;&lt; #store &gt;&gt; 'Repository &lt;1p&gt;' expandMacrosWith: Repositories size + 1).	^(RepositoryPropertiesDialog openOn: newProfile) 		ifTrue: 			[self addRepository: newProfile.			newProfile]		ifFalse: [nil]</body><body package="Store-UI">importRepositoriesFromFile	| dialog filename |	dialog := OpenFileDialog new.	dialog		windowTitle: #importRepositoriesFilesNamed1C					&gt;&gt; 'Import repositories file named:' &lt;&lt; #dialogs;		acceptButtonLabel: #import &gt;&gt; 'Import' &lt;&lt; #dialogs;		addFileFilter: 'XML file (*.xml)' pattern: '*.xml';		defaultFilename: 'repositories.xml';		fileCondition: #mustBeOld.	filename := dialog select ifNil: [^self].	self importRepositoriesFromFile: filename</body><body package="Store-UI">importRepositoriesFromFile: filename	| stream |	stream := (filename asFilename withEncoding: #UTF_8) readStream.	self importRepositoriesFromStream: stream</body><body package="Store-UI">importRepositoriesFromStream: aStream	"Read the repositories from aStream using the Settings framework.  Try to be	 backward compatible with older versions of repository files that might have 	 been created in 7.5 or earlier releases.  The receiver will close aStream."		| reader |	reader := SettingReader on: VisualWorksSettings current.	[[reader readFrom: aStream] ensure: [aStream close].	reader snapshots do: [:collection| StoreRepositoryListSetting new restoreFrom: collection]]		on: InvalidStoredSettingDataError		do:			[:ex | 			aStream reset.			[self importRepositoriesFromXmlOn: aStream] ensure: [aStream close]]</body><body package="Store-UI">saveRepositoriesToFile	| filenameString |	filenameString := Dialog				requestFileName: #SaveRepositoriesToFileNamed &lt;&lt; #store						&gt;&gt; 'Save repositories to file named:'				default: 'repositories.xml'.	filenameString isEmpty ifTrue: [^self].	self saveRepositoriesToFile: filenameString</body><body package="Store-UI">saveRepositoriesToFile: filenameString	| stream |	stream := (filenameString asFilename withEncoding: #UTF_8) writeStream.	self saveRepositoriesToStream: stream</body><body package="Store-UI">saveRepositoriesToStream: aStream	"Write the Repositories to aStream.  Ensure that the format of the file is 	 compatible with the Settings tool.  The receiver will close the stream."	| writer |	writer := SettingsWriter		on: VisualWorksSettings current		settings: VisualWorksSettings storeRepositoriesPage settings.	[writer writeTo: aStream] ensure: [aStream close]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>deprecated</category><body package="Store-UI">importRepositoriesFromXmlOn: aStream	"This method is deprecated and will be removed in a future release."	| loadedRepositories |	loadedRepositories := self repositoriesFromXmlOn: aStream.	self addRepositories: loadedRepositories</body><body package="Store-UI">repositoriesFromXmlOn: aStream 	"This method is deprecated and will be removed in a future release."	| parser document loadedRepositories |	parser := XMLParser new.	parser validate: false.	document := parser parse: aStream.	document root tag type = 'store-repositories' ifFalse: 		[self error: 'invalid file format'].	loadedRepositories := document root realElements collect: 		[:each | ConnectionProfile fromXmlElement: each].	^loadedRepositories</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>persistence</category><body package="Store-UI">addStateXmlElementsTo: anElement	profiles do: 		[:each |		anElement addNode: each asXmlNode]</body><body package="Store-UI">restoreFrom: aSettingSnapshot	| newProfiles |	newProfiles := OrderedCollection new.	aSettingSnapshot stateNodes do:		[:each | | profile |		profile := ConnectionProfile fromXmlElement: each.		newProfiles add: profile].	profiles := newProfiles.	self installProfiles</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>actions</category><body package="Store-UI">installProfiles	RepositoryManager replaceRepositoriesWith: profiles</body><body package="Store-UI">profiles	^profiles</body><body package="Store-UI">resetProfiles	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>accessing</category><body package="Store-Difference Management">differenceName	^self selectorListName</body><body package="Store-Difference Management">firstTextFragments	^self mainDefinition asText wordAndWhitespaceFragments</body><body package="Store-Difference Management">mainDefinition	^mainObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management">mainPackage: aPackage comment: aString	"Make sure to have nil or a plain String. Comment obtained from a real class is Text."	| stringOrNil |	stringOrNil := (aString isNil or: [aString isEmpty])				ifFalse: [aString asString].	self mainPackage: aPackage object: stringOrNil</body><body package="Store-Difference Management">mainProtocol	^''</body><body package="Store-Difference Management">otherDefinition	^otherObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management">otherPackage: aPackage comment: aString	"Make sure to have nil or a plain String. Comment obtained from a real class is Text."	| stringOrNil |	stringOrNil := (aString isNil or: [aString isEmpty])				ifFalse: [aString asString].	self otherPackage: aPackage object: stringOrNil</body><body package="Store-Difference Management">otherProtocol	^''</body><body package="Store-Difference Management">resolutionClass	^ClassCommentChangeResolver</body><body package="Store-Difference Management">secondTextFragments	^self otherDefinition asText wordAndWhitespaceFragments</body><body package="Store-Difference Management">selectorListIcon	^GeneralIcons gear</body><body package="Store-Difference Management">selectorListName	^(#BracketClassCommentBracket &lt;&lt; #store &gt;&gt; '[Class Comment]') asString</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>loading</category><body package="Store-Difference Management">loadMainDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageClass comment: self mainObject</body><body package="Store-Difference Management">loadOtherDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageClass comment: self otherObject</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream comment: commentObject value: mainObject</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream comment: commentObject value: otherObject</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>testing</category><body package="Store-Difference Management">isMeta	"Comment is always regarded a property of a class, not a metaclass.	A concrete use case is in ComparePackages where we don't want to see comment diffs in metaclass view."	^false</body><body package="Store-Difference Management">isShownInMethodList	^true</body><body package="Store-Difference Management">isStandin	^true</body></methods><methods><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">enabledExceptForShared: aNavigator	('Implementors of*' match:aNavigator environment label) ifTrue: [^false].	^(aNavigator definitions allSatisfy: [:each | each isKindOf: RBInitializerDefinition]) not</body></methods><methods><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">selectors	selectors isNil 		ifTrue: 			[selectors := StoreNameSpaceItemTabNavigatorPart new.			navigator notNil ifTrue: [selectors navigator: navigator]].	(self componentNamed: #selectors) isNil 		ifTrue: [self componentNamed: #selectors put: selectors].	^selectors</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>actions</category><body package="Store-UI">applyChanges	session inTransactionDo:		[self targetedPundles list do:			[:each |			each currentBlessingLevel = -54 ifFalse: [self setBlessingForRemoval: each]].		previouslyMarkedPundles do:			[:each |			(self targetedPundles list includes: each) ifFalse: [self resetBlessingFor: each]]].	previouslyMarkedPundles := self targetedPundles list asOrderedCollection.	self enableApply</body><body package="Store-UI">browseBundle	(StoreRefactoringBrowser		openOnEnvironment: (StoreForGlorpBrowserEnvironment on: self bundleVersions selections first)		state: StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-UI">browsePackage	(StoreRefactoringBrowser		openOnEnvironment: (StoreForGlorpBrowserEnvironment on: self packageVersions selections first)		state: StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-UI">bundleSelectionChanged	bundles selectionIndex isZero ifTrue: [^self bundleVersions list: #()].	builder window sensor invalidationSuppressWhile: [bundleVersions list: self filteredBundleVersions].	self setupBundleListPane.</body><body package="Store-UI">cancelChanges	self targetedPundles list copy do:		[:each |		each blessingLevelNumber = -54 ifFalse: [self targetedPundles list remove: each]].	self enableApply</body><body package="Store-UI">clearFilter	| bundlesTarget packagesTarget |	bundlesTarget := self bundles selection.	packagesTarget := self packages selection.	oldFilter := filter.	filter := DeletionToolFilter new.	self setPundleNames.	(self packages list includes: packagesTarget)		ifTrue: [self packages selection: packagesTarget].	(self bundles list includes: bundlesTarget)		ifTrue: [self bundles selection: bundlesTarget].</body><body package="Store-UI">closeWindow	^self closeRequest</body><body package="Store-UI">editFilter	| dialog |	dialog := DeletionToolFilterTool new.	oldFilter ifNotNil: [filter := oldFilter].	dialog filter: filter.	dialog open.	dialog accept value 		ifTrue: [filter := dialog filter]		ifFalse: [filter := DeletionToolFilter new].	self applyFilter</body><body package="Store-UI">enableApply	| enablement |	self setupStartButton.	enablement := (self targetedPundles list allSatisfy: [:each | each currentBlessingLevel = -54]) not.	enablement := enablement or: [(targetedPundles list isSameSequenceAs: previouslyMarkedPundles) not].	self setupTargetedPundlesPane.	(self widgetAt: #ApplyChanges) isEnabled: enablement.	(self widgetAt: #CancelChanges) isEnabled: enablement.	(self widgetAt: #TargetedPundles) invalidate.	(self widgetAt: #BundleVersions) ifNotNil: 		[:value | 		self setupBundleListPane.		value invalidate].	(self widgetAt: #PackageVersions) ifNotNil: 		[:value | 		self setupPackageListPane.		value invalidate].</body><body package="Store-UI">installBundlePage	(self widgetAt: #PundleChooser)		client: self		spec: #bundlesPage		builder: (builder newSubBuilder).	(self widgetAt: #PundleChooser) invalidate</body><body package="Store-UI">installPackagePage	(self widgetAt: #PundleChooser)		client: self		spec: #packagesPage		builder: (builder newSubBuilder)</body><body package="Store-UI">packageSelectionChanged	packages selectionIndex isZero ifTrue: [^self packageVersions list: #()].	builder window sensor invalidationSuppressWhile: [packageVersions list: self filteredPackageVersions].	self setupPackageListPane.</body><body package="Store-UI">pageChanged	| index |	index := self pundleTabs selectionIndex.	index = 1		ifTrue: [self installBundlePage]		ifFalse: [self installPackagePage].</body><body package="Store-UI">setPundleNames		self packages list: (cachedNames at: #packages).	self bundles list: (cachedNames at: #bundles)</body><body package="Store-UI">setupStartButton	(self widgetAt: #StartGarbageCollector) isEnabled: (self targetedPundles list anySatisfy: [:each | each currentBlessingLevel = -54]).</body><body package="Store-UI">startGarbageCollector	#{Store.GarbageCollector}		ifDefinedDo:			[:class |			Store.DbRegistry				doIfImageAdministrator:					[[class collectGarbage] fork.					self closeWindow]				label: (#runGarbageCollection &lt;&lt; #store &gt;&gt; 'run garbage collection') asString]		elseDo:			[Dialog warn:				(#Parcel1sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Parcel &lt;1s&gt; is not loaded'					expandMacrosWith: 'Store-Garbage Collector')].</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>aspects</category><body package="Store-UI">bundleVersions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundleVersions isNil		ifTrue:			[bundleVersions := MultiSelectionInList new]		ifFalse:			[bundleVersions]</body><body package="Store-UI">bundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundles isNil		ifTrue:			[bundles := SelectionInList new]		ifFalse:			[bundles]</body><body package="Store-UI">packageVersions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageVersions isNil		ifTrue:			[packageVersions := MultiSelectionInList new]		ifFalse:			[packageVersions]</body><body package="Store-UI">packages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packages isNil		ifTrue:			[packages := SelectionInList new]		ifFalse:			[packages]</body><body package="Store-UI">pundleTabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleTabs isNil		ifTrue:			[pundleTabs := SelectionInList new]		ifFalse:			[pundleTabs]</body><body package="Store-UI">targetedPundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetedPundles isNil		ifTrue:			[targetedPundles := MultiSelectionInList new]		ifFalse:			[targetedPundles]</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>menu-actions</category><body package="Store-UI">retractAllBundleVersions	self bundleVersions list do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI">retractAllPackageVersions	self packageVersions list do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI">retractAllPundleVersions	self targetedPundles list: OrderedCollection new.	self enableApply</body><body package="Store-UI">retractThisBundleVersion	self bundleVersions selections do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI">retractThisPackageVersion	self packageVersions selections do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI">retractThisPundleVersion	self targetedPundles selections do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI">selectAllBundleVersions	self bundleVersions list do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]].	self enableApply</body><body package="Store-UI">selectAllPackageVersions	self packageVersions list do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]].	self enableApply</body><body package="Store-UI">selectBundleVersionForRemoval	builder window sensor invalidationSuppressWhile:		[self bundleVersions selections do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]]].	self enableApply</body><body package="Store-UI">selectPackageVersionForRemoval	builder window sensor invalidationSuppressWhile:		[self packageVersions selections do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]]].	self enableApply</body><body package="Store-UI">viewContainedItems	[DefinitionForListTool forBundleContents: self bundleVersions selections first] withStoreFeedbackOn: self mainWindow.</body><body package="Store-UI">viewEnclosingBundles	| bundle enclosingBundles versionAspect |	versionAspect := self pundleTabs selectionIndex = 1		ifTrue: [self bundleVersions]		ifFalse: [self packageVersions].	bundle := versionAspect selections first.	(enclosingBundles := bundle enclosingComponents) isEmpty		ifTrue: [^Dialog warn: #NoEnclosingBundles &lt;&lt; #store &gt;&gt; 'No enclosing bundles.'].	DefinitionForListTool forPackages: enclosingBundles</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>private</category><body package="Store-UI">applyFilter	| bundlesTarget packagesTarget |	bundlesTarget := self bundles selection.	packagesTarget := self packages selection.	self setPundleNames.	filter pundleName ifNotNil:		[self bundles list: (self bundles list asOrderedCollection removeAllSuchThat: [:each | (filter pundleName match: each)]).		self packages list: (self packages list asOrderedCollection removeAllSuchThat: [:each | (filter pundleName match: each)])].	(self packages list includes: packagesTarget)		ifTrue: [self packages selection: packagesTarget].	(self bundles list includes: bundlesTarget)		ifTrue: [self bundles selection: bundlesTarget].</body><body package="Store-UI">compositePundleVersionUsing: aPundle nameSize: longestName versionSize: longestVersion blessingSize: longestBlessing in: aSequenceView	| iconPart currentStart nameLabel versionLabel blessingLabel timestampLabel mainThing emphasis icon |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	icon := aPundle blessingLevelNumber = -54		ifTrue: [VisualStack with: aPundle toolListIcon with: (ToolbarIconLibrary visualFor: #debugTerminate)]		ifFalse: 			[(self targetedPundles list includes: aPundle)				ifTrue: [VisualStack with: aPundle toolListIcon with: (ToolbarIconLibrary visualFor: #delete)]				ifFalse: [aPundle toolListIcon]].	iconPart icon: icon.	currentStart := 25.	nameLabel := Label with: aPundle name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 12.	emphasis := Array with: #bold with: #color -&gt; ColorValue darkGreen.	versionLabel := Label with: aPundle versionString asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestVersion + 12.	blessingLabel := Label with: (aPundle blessingLevelString asText emphasizeAllWith: emphasis) attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestBlessing + 12.	timestampLabel := Label with: aPundle timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: versionLabel;		add: blessingLabel;		add: timestampLabel;		yourself.	^mainThing</body><body package="Store-UI">filteredBundleVersions	| allBundles |	allBundles := (StoreBundle allVersionsWithName: bundles selection in: session) asOrderedCollection.	filter versionLike ifNotNil:		[allBundles := allBundles select: [:each | filter versionLike match: each version, ',' , each username]].	filter beforeDate ifNotNil:		[allBundles := allBundles select: [:each | each timestamp asDate &lt;= filter beforeDate]].	filter afterDate ifNotNil:		[allBundles := allBundles select: [:each | each timestamp asDate &gt;= filter afterDate]].	filter blessingGreater ifNotNil:		[allBundles := allBundles select: [:each | each blessingLevelNumber ifNotNil: [:value | value &gt;= filter blessingGreater] ifNil: [true]]].	filter blessingLess ifNotNil:		[allBundles := allBundles select: [:each | each blessingLevelNumber ifNotNil: [:value | value &lt;= filter blessingLess] ifNil: [true]]].	^allBundles</body><body package="Store-UI">filteredPackageVersions	| allPackages |	allPackages := (StorePackage allVersionsWithName: packages selection in: session) asOrderedCollection.	filter versionLike ifNotNil:		[allPackages := allPackages select: [:each | filter versionLike match: each version, ',' , each username]].	filter beforeDate ifNotNil:		[allPackages := allPackages select: [:each | each timestamp asDate &lt;= filter beforeDate]].	filter afterDate ifNotNil:		[allPackages := allPackages select: [:each | each timestamp asDate &gt;= filter afterDate]].	filter blessingGreater ifNotNil:		[allPackages := allPackages select: [:each | each blessingLevelNumber ifNotNil: [:value | value &gt;= filter blessingGreater] ifNil: [true]]].	filter blessingLess ifNotNil:		[allPackages := allPackages select: [:each | each blessingLevelNumber ifNotNil: [:value | value &lt;= filter blessingLess] ifNil: [true]]].	^allPackages</body><body package="Store-UI">resetBlessingFor: aStorePundle	| allBlessings newBlessings |	allBlessings := aStorePundle blessings.	newBlessings := allBlessings allButFirst: 1.	session accessor permitEverythingDuring:		[session inUnitOfWorkDo: 			[session register: aStorePundle.			session accessor permitEverything.			session delete: allBlessings first.			aStorePundle blessings: newBlessings.			aStorePundle currentBlessingLevel: newBlessings first blessingLevel]].</body><body package="Store-UI">setBlessingForRemoval: aStorePundle	| specification |	specification := PublishSpecification dbPundle: aStorePundle.	specification publish: true.	specification blessing: -54.	specification publishBlessing.	aStorePundle currentBlessingLevel: -54.</body><body package="Store-UI">setUpPundleList: aSymbol in: aBuilder	| widget icon descent |	widget := (aBuilder componentAt: aSymbol) widget.	icon := aSymbol == #BundlesList				ifTrue: [StoreBundle toolListIcon]				ifFalse: [StorePackage toolListIcon].	descent := widget textStyle descent.	widget visualBlock: 			[:view :index |			| iconPart |			iconPart := LabelAndIcon with: (view sequence at: index) offset: 2 @ descent negated.			iconPart icon: icon.			BoundedWrapper on: iconPart].	widget selectedVisualBlock: 			[:view :index |			| iconPart wrapper |			iconPart := LabelAndIcon with: (view sequence at: index) offset: 2 @ descent negated.			iconPart icon: icon.			wrapper := ReversingWrapper on: iconPart.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body><body package="Store-UI">setupBundleListPane	| widget items longestName longestVersion longestBlessing |	widget := (self builder componentAt: #BundleVersions) widget.	items := self bundleVersions list.	items size isZero ifTrue: [^widget invalidate].	longestName := longestVersion := longestBlessing := 0.	longestName := (Label with: items first name asText allBold attributes: widget textStyle) width.	items		do:			[:each | 			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestBlessing := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: longestBlessing].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body><body package="Store-UI">setupPackageListPane	| widget items longestName longestVersion longestBlessing |	widget := (self builder componentAt: #PackageVersions) widget.	items := self packageVersions list.	items size isZero ifTrue: [^widget invalidate].	longestName := longestVersion := longestBlessing := 0.	longestName := (Label with: items first name asText allBold attributes: widget textStyle) width.	items		do:			[:each | 			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestBlessing := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: longestBlessing].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body><body package="Store-UI">setupTargetedPundlesPane	| widget items longestName longestVersion longestBlessing |	widget := (self builder componentAt: #TargetedPundles) widget.	items := self targetedPundles list.	items size isZero ifTrue: [^widget invalidate].	longestName := longestVersion := longestBlessing := 0.	items		do:			[:each | 			longestName := (Label with: each name asText allBold attributes: widget textStyle) width max: longestName.			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestBlessing := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: longestBlessing].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body><body package="Store-UI">suppressTooltip	"Suppress hover overlay by installing an empty widget tooltip.	 List items are unable to provide viable overlay content."	^[nil]</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>interface opening</category><body package="Store-UI">postBuildWith: aBuilder	self pundleTabs selectionIndexHolder onChangeSend: #pageChanged to: self.	self bundles selectionIndexHolder onChangeSend: #bundleSelectionChanged		to: self.	self packages selectionIndexHolder onChangeSend: #packageSelectionChanged		to: self.	aBuilder = builder		ifTrue: 			[cachedNames at: #packages				put: (StorePackage allNamesIn: session) asSortedCollection						asOrderedCollection.			cachedNames at: #bundles				put: (StoreBundle allNamesIn: session) asSortedCollection						asOrderedCollection.			self setPundleNames.			self refillTargedPundles].	aBuilder ~= builder		ifTrue: 			[(aBuilder componentAt: #BundleVersions)				ifNotNil: 					[:value |					builder componentAt: #BundleVersions put: value.					builder componentAt: #BundlesList put: value.					self setUpPundleList: #BundlesList in: aBuilder].			(aBuilder componentAt: #PackageVersions)				ifNotNil: 					[:value |					builder componentAt: #PackageVersions put: value.					builder componentAt: #PackagesList put: value.					self setUpPundleList: #PackagesList in: aBuilder]]</body><body package="Store-UI">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self pundleTabs selectionIndexHolder value: 1.	self setupTargetedPundlesPane.	self setupStartButton</body><body package="Store-UI">refillTargedPundles		previouslyMarkedPundles addAll: (StoreBundle allVersionsWithBlessingLevel: -54 in: session).	previouslyMarkedPundles addAll: (StorePackage allVersionsWithBlessingLevel: -54 in: session).	self targetedPundles list removeAll.	self targetedPundles list addAll: previouslyMarkedPundles</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>menu-enablement</category><body package="Store-UI">atLeastOneBundleVersionIsSelected	^self bundleVersions selectionIndexes size &gt; 0</body><body package="Store-UI">atLeastOnePackageVersionIsSelected	^self packageVersions selectionIndexes size &gt; 0</body><body package="Store-UI">atLeastOnePundleVersionIsSelected	^self targetedPundles selectionIndexes size &gt; 0</body><body package="Store-UI">bundleIsSelected	^self bundles selectionIndex ~= 0</body><body package="Store-UI">oneBundleVersionIsSelected	^self bundleVersions selectionIndexes size = 1</body><body package="Store-UI">onePackageVersionIsSelected	^self packageVersions selectionIndexes size = 1</body><body package="Store-UI">packageIsSelected	^self packages selectionIndex ~= 0</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>initialize-release</category><body package="Store-UI">initialize	session := StoreLoginFactory currentStoreSession.	previouslyMarkedPundles := OrderedCollection new.	filter := DeletionToolFilter new.	cachedNames := Dictionary new.</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">isMove	^movePair notNil</body><body package="Store-Merge Management">isPotentialMove	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	| shared owningPackage |	proposed ifNil: [^true].	proposed isRemovalResolution ifFalse: [^true].	shared := proposed value value.	shared correspondingImageBinding ifNil: [^false].	(owningPackage := Registry containingPackageForDataKey: shared correspondingImageBinding key symbol: shared owner absoluteSymbol) ifNil: [^false].	^((owningPackage name = proposed package name) or: 		[Override isOverriddenStatic: shared correspondingImageBinding key in: shared owner in: proposed package storeModel])</body><body package="Store-Merge Management">isSharedResolver	^true</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	| existingPackage |	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isNoOpResolution]]]) 			ifTrue: [^true].	self isMove ifTrue: [^self applyMove].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isUserInputResolution ifTrue: [^self applyUserInput].	(existingPackage := self existingDefinitionPackage) isNil ifTrue: [^self applyChange].	^existingPackage = proposed package storeModel		ifTrue: [self applyChange]		ifFalse: [self applyOverride].</body><body package="Store-Merge Management">applyAsRemove	| overrides changeManager targetOverride reinitialize bindingReference |	reinitialize := true.	refactoring := (overrides := self existingOverrides) isEmpty		ifTrue: 			[reinitialize := false.			RemoveSharedVariableChange objectName: self longName]		ifFalse: 			[(targetOverride := overrides detect: [:each | each sources includes: proposed package storeModel] ifNone: [nil]) notNil				ifTrue: [RemoveOverrideChange for: targetOverride]				ifFalse: [RestoreOverrideChange for: overrides last]].	changeManager := RefactoryChangeManager instance.	^[[changeManager performChange: refactoring.	undo := changeManager undoChange.	reinitialize ifTrue:		[bindingReference := refactoring bindingReference.		(Undeclared includesKey: bindingReference name) ifTrue: [^false].		self initializeShared: bindingReference].	true]		on: RedefinitionNotification		do: [:exception | exception currentPackage = proposed package storeModel ifTrue: [exception resume] ifFalse: [exception return: false]]]			on: Error			do: 				[:exception | 				exception class = ReInitializeSharedVariableNotification ifTrue: [exception resume: exception outer].				Transcript show: (#nApplyingRemovalSharedFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Shared Variable &lt;2s&gt; Failed: &lt;1s&gt;' 					expandMacrosWith: exception messageText					with: self mergeDisplayName).				exception return: false].</body><body package="Store-Merge Management">applyChange	| changeManager bindingReference |	^[refactoring := AddSharedVariableChange definition: proposed value definitionString.	refactoring package: proposed package storeModel.	(Undeclared includesKey: refactoring bindingReference name)		ifTrue: [Undeclared removeKey: refactoring bindingReference name ifAbsent: [nil]].	changeManager := RefactoryChangeManager instance.	changeManager performChange: refactoring.	undo := changeManager undoChange.	bindingReference := refactoring bindingReference.	(Undeclared includesKey: bindingReference name) ifTrue: [^false].	self initializeShared: bindingReference.	true]		on: Error		do: 			[:exception | 			exception class = ReInitializeSharedVariableNotification ifTrue: [exception resume: exception outer].			Transcript show: (#nApplyingChangeSharedFailed1s &lt;&lt; #store 					&gt;&gt; '&lt;n&gt;Applying Change of Shared Variable &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self mergeDisplayName).			exception return: false].</body><body package="Store-Merge Management">applyMove	| targetResolver changeManager |	applied ifTrue: [^true].	targetResolver := proposed isRemovalResolution		ifTrue: [movePair proposed]		ifFalse: [proposed].	refactoring := MoveSharedVariableToPackageChange		sharedVariableNamed: self longName		package: targetResolver package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	self markApplied.	movePair markApplied.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingSharedMoveFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying SharedVariable Move Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">applyOverride	| changeManager sharedChange bindingReference |	sharedChange := AddSharedVariableChange definition: proposed value definitionString.	bindingReference := sharedChange bindingReference.	refactoring := CompositeRefactoryChange named: 'Merge Override Shared'.	refactoring addChange: (MoveSharedVariableToPackageChange 		sharedVariableNamed: self longName		package: proposed package storeModel).	refactoring addChange: (AddOverrideChange for: (Override forDataKey: bindingReference name in: bindingReference environment)).	refactoring addChange: sharedChange.	refactoring changes last package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	bindingReference := refactoring changes last bindingReference.	(Undeclared includesKey: bindingReference name) ifTrue: [^false].	self initializeShared: bindingReference.	true]		on: Error		do: 			[:exception |			exception class = ReInitializeSharedVariableNotification ifTrue: [exception resume: exception outer].			Transcript show: (#nApplyingOverrideSharedFailed1s &lt;&lt; #store 					&gt;&gt; '&lt;n&gt;Applying Override of Shared Variable &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self mergeDisplayName).			exception return: false]</body><body package="Store-Merge Management">applyUserInput	| changeManager bindingReference |	refactoring := AddSharedVariableChange definition: proposed text.	refactoring package: proposed package storeModel.	(Undeclared includesKey: refactoring bindingReference name)		ifTrue: [Undeclared removeKey: refactoring bindingReference name ifAbsent: [nil]].	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	bindingReference := refactoring bindingReference.	(Undeclared includesKey: bindingReference name) ifTrue: [^false].	self initializeShared: bindingReference.		true]		on: Error		do: 			[:exception | 			exception class = ReInitializeSharedVariableNotification ifTrue: [exception resume: exception outer].			Transcript show: (#nApplyingChangeSharedFailed1s &lt;&lt; #store					&gt;&gt; '&lt;n&gt;Applying Change of Shared Variable &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self mergeDisplayName).			exception return: false].</body><body package="Store-Merge Management">askToReinitializeSharedVariable: aVariableBinding		^ReInitializeSharedVariableNotification raiseRequestWith: aVariableBinding</body><body package="Store-Merge Management">doExtraUndoWork	| bindingReference |	bindingReference := (refactoring changeObject isNil and: [refactoring changes notEmpty])		ifTrue: [refactoring changes last bindingReference]		ifFalse: [refactoring bindingReference].	bindingReference binding ifNotNil: 		[:value | value reinitializeValue]</body><body package="Store-Merge Management">existingDefinitionPackage	^Store.Registry containingPackageForDataKey: self mergeDisplayName asSymbol symbol: self longOwnerName asSymbol</body><body package="Store-Merge Management">existingOverrides	^(Override overridesForDataKey: self mergeDisplayName asSymbol in: (self longOwnerName asStrictReference valueOrDo: [^#()])) ifNil: [^#()]</body><body package="Store-Merge Management">hasOverrideAndShouldApply		self existingDefinitionPackage ifNotNil:		[:value | 		value name = proposed package name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed package name) ifFalse: 				[Transcript show: (#nDidNotApplyOverrideSharedVariable1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of Shared Variable &lt;1s&gt; in &lt;2s&gt;' 					expandMacrosWith: self longName					with: proposed package name).				^false]]].	^true</body><body package="Store-Merge Management">initializeShared: aSharedBindingReference	aSharedBindingReference binding ifNotNil: 		[:value | 		(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]</body><body package="Store-Merge Management">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingShared1sn2sOveride3snn &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;Shared Variable "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">browseVersions	| alternative list session |	alternative := self standardResolutionAlternative.	alternative		ifNil: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: alternative value name)].	session := alternative package session.	(Gathering for: self longName) started.	list := StoreSharedVariableInPackage				allVersionsWithName: alternative value name				inOwner: alternative value environmentName				in: session.	(Gathering for: self longName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: alternative value name)].	DefinitionForListTool forSharedVariables: list</body><body package="Store-Merge Management">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[movePair notNil 	ifTrue: 			[^applied 				ifTrue: [self movedToPackageString]				ifFalse: [self moveToPackageString]].		^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value ifNotNil: 		[:value | 		value isString			ifTrue: [value]			ifFalse: [	value definitionString]]</body><body package="Store-Merge Management">listIcon	^VisualStack with: BehaviorIcons Object with: BehaviorIcons SharedVariableOverlay</body><body package="Store-Merge Management">longName	| storeObject |	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value absoluteName</body><body package="Store-Merge Management">longOwnerName	| storeObject |	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value environmentName</body><body package="Store-Merge Management">longTreeName	| string |	string := self longName, self applyableString.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">mergeDisplayName	| storeObject |	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value name</body><body package="Store-Merge Management">moveFromPackageString	^self moveFromPackage: movePair proposed package name</body><body package="Store-Merge Management">moveToPackageString	^self moveToPackage: movePair proposed package name</body><body package="Store-Merge Management">movedFromPackageString	^self movedFromPackage: movePair proposed package name</body><body package="Store-Merge Management">movedToPackageString	^self movedToPackage: movePair proposed package name</body><body package="Store-Merge Management">shortListName	| string |	string := self ownerName, ' [Shared] ' , self shortTreeName.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management">shortTreeName	| string |	string := self mergeDisplayName, self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">validateParse: aNodeHolder	"Answer false if there is a problem, true otherwise"		| selector methodCollector filter receiver alternative oldNode mainStatementNode oldStatementNode name value |	mainStatementNode := aNodeHolder node block body statements first.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	oldNode := self parseDefinition: alternative value definition in: self owningEnvironment.	oldStatementNode := oldNode node block body statements first.	receiver := mainStatementNode receiver name.	oldStatementNode receiver name = receiver ifFalse:		[Dialog warn: (#Class1BooleanNameSpaceMustNotChange &lt;&lt; #store &gt;&gt; '&lt;1?Class:NameSpace&gt; must not change' expandMacrosWith: alternative value isClassVariable).		^false].	name := (mainStatementNode arguments first) value asString.	(oldStatementNode arguments first) value asString = name ifFalse:		[Dialog warn: #SharedVariableNameMustNotChange &lt;&lt; #store &gt;&gt; 'Shared variable name must not change'.		^false].	selector := mainStatementNode selector.	methodCollector := MethodCollector new.	filter := methodCollector implementorsOf: selector.	(methodCollector select: filter) isEmpty ifTrue:		[Dialog warn: #BadDefinitionMessage &lt;&lt; #store &gt;&gt; 'Bad Definition Message'.		^false].	oldStatementNode selector = selector ifFalse:		[Dialog warn: #DefinitionMessageMustNotChange &lt;&lt; #store &gt;&gt; 'Definition message must not change'.		^false].	((mainStatementNode arguments at: 2) value isKindOf: Boolean) ifFalse:		[Dialog warn: #ParameterForPrivateMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #private: must be a Boolean'.		^false].	((mainStatementNode arguments at: 3) value isKindOf: Boolean) ifFalse:		[Dialog warn: #ParameterForConstantMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #constant: must be a Boolean'.		^false].	((mainStatementNode arguments at: 4) value isString) ifFalse:		[Dialog warn: #ParameterForCategoryMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #category: must be a String'.		^false].	((value := (mainStatementNode arguments at: 5) value) isString and: [value isSymbol not]) ifFalse:		[Dialog warn: #ParameterForInitializerMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #initializer: must be a String'.		^false].	^true</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management">movePair	^movePair</body><body package="Store-Merge Management">movePair: aSharedChangeResolver	movePair := aSharedChangeResolver</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>testing</category><body package="Store-Change Management">existsInImage	^tag existsInImage</body><body package="Store-Change Management">isForOverriddenMethod	^ false</body><body package="Store-Change Management">isMoveModification		^false</body><body package="Store-Change Management">isPackageLoaded	^package getImagePundle basicallySameVersionAsPublished: package</body><body package="Store-Change Management">isPublishedModification		^false</body><body package="Store-Change Management">isTextModification		^false</body><body package="Store-Change Management">notOriginallyInImage	^self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>comparing</category><body package="Store-Change Management">= aMod 	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>accessing</category><body package="Store-Change Management">description	self subclassResponsibility</body><body package="Store-Change Management">existsInPackage	self subclassResponsibility</body><body package="Store-Change Management">package	^package</body><body package="Store-Change Management">package: aPackage	package := aPackage.	tag == nil		ifFalse: [ tag package: aPackage ].</body><body package="Store-Change Management">packageName	^package isNil		ifTrue: ['']		ifFalse: [package name]</body><body package="Store-Change Management">record	"Added by Philippe F. Monnet of Andersen Consulting	Added for compatibity with TT_Modification. 	This is called by: TT_MergeData &gt; resolutionRecordForTag: aTag packageNamed: aName"		^nil</body><body package="Store-Change Management">source	"Answer the source code or nil if not there."	self subclassResponsibility</body><body package="Store-Change Management">tag	^tag</body><body package="Store-Change Management">tag: aTag	tag := aTag</body><body package="Store-Change Management">timeStampString	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>printing</category><body package="Store-Change Management">printOn: aStream	"Print tag first and then package."	aStream nextPut: $&lt;.	tag printOn: aStream.	aStream nextPut: $@.	self package printOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>actions</category><body package="Store-Change Management">apply	"Apply a modification to the image. 	Answer true if the application is successful."	self subclassResponsibility</body><body package="Store-Change Management">moveFromPackage: oldPkg to: newPkg 	"Ask if this modification should be moved to the package it was loaded from."	(oldPkg isNil or: 		[Dialog confirm: ((#DoYouWishToMove1LoadedFrom3s &lt;&lt; #store &gt;&gt; 'Do you wish to move &lt;1p&gt;&lt;n&gt;from its current package [&lt;2s&gt;] &lt;n&gt;to the package it was loaded from [&lt;3s&gt;] ?') 						expandMacrosWith: tag						with: oldPkg name						with: newPkg name)				initialAnswer: true]) 		ifTrue: [tag moveToPackage: newPkg]</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersionIfExists	"Open a browser on the system version of this override if possible.	 Answer if it was possible."	^tag browseSystemVersionIfExists</body><body package="Store-Change Management">className	^tag className</body><body package="Store-Change Management">cleanSourceFrom: aString	"Return a version of aString which has a cr line-end convention imposed upon it."	^Kernel.Change new cleanSourceFrom: aString</body><body package="Store-Change Management">componentString	^(#x1s2sComponentString &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: &lt;2s&gt;')		expandMacrosWith: package classDescription with: package name.</body><body package="Store-Change Management">fileOutOn: aStream	"Fileout the change onto aStream."	tag fileOutOn: aStream from: self record in: package</body><body package="Store-Change Management">hasVersionInSystem	^self existsInImage</body><body package="Store-Change Management">isClassRelated	^tag isForClass</body><body package="Store-Change Management">isCommentChange	^tag isCommentChange</body><body package="Store-Change Management">isMethodRelated	^tag isForMethod</body><body package="Store-Change Management">name	"Answer a name for the list."	^tag name</body><body package="Store-Change Management">nonMetaClassName	^tag nonMetaClassName</body><body package="Store-Change Management">protocol	^[ tag protocol ] on: MessageNotUnderstood do:		[ :ex | ex return: nil ].</body><body package="Store-Change Management">sameAsSystem	self subclassResponsibility</body><body package="Store-Change Management">sameAsSystem: list	^self sameAsSystem</body><body package="Store-Change Management">selector	^tag isForMethod		ifTrue: [ tag selector ]</body><body package="Store-Change Management">text	"Asnwer the text to display in a text window."	^tag sourceTextForImage</body><body package="Store-Change Management">type	"Answer a symbol representing the sub-type of this kind of modification." 	^tag type</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison">addedPropertyRow: aPropertyBlueprint	^(SinglePropertyView new)		property: aPropertyBlueprint;		isAddition: true;		populate</body><body package="Store-Code Comparison">changedPropertyRowFrom: anOriginalPropertyBlueprint to: aChangedPropertyBlueprint	^PropertyComparisonView new leftProperty: anOriginalPropertyBlueprint		rightProperty: aChangedPropertyBlueprint</body><body package="Store-Code Comparison">computeDetailRows	^self propertyRows</body><body package="Store-Code Comparison">populateHeader	| headerRow label |	super populateHeader.	self codeComponentName ifNil: [^self].	headerRow := self header.	label := Label with: self codeComponentName asText allBold.	headerRow		add: (self isBundle					ifTrue: [ComparisonIcons bundleProperties]					ifFalse: [ComparisonIcons packageProperties]);		add: label</body><body package="Store-Code Comparison">propertyRows	| rows |	rows := OrderedCollection new.	self		enumerateOrderedPropertyAdditions: [:addedProperty | rows add: (self addedPropertyRow: addedProperty)]		removals: [:removedProperty | rows add: (self removedPropertyRow: removedProperty)]		changes: [:removedProperty :addedProperty | rows add: (self changedPropertyRowFrom: removedProperty to: addedProperty)].	^rows</body><body package="Store-Code Comparison">removedPropertyRow: aPropertyBlueprint	^(SinglePropertyView new)		property: aPropertyBlueprint;		isAddition: false;		populate</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>private</category><body package="Store-Code Comparison">enumerateOrderedPropertyAdditions: additionBlock removals: removalBlock changes: changeBlock	| additionStack removalStack |	additionStack := OrderedCollection withAll: rightProperties.	removalStack := OrderedCollection withAll: leftProperties.	[additionStack isEmpty and: [removalStack isEmpty]] whileFalse: 			[additionStack isEmpty				ifTrue: [removalBlock value: removalStack removeFirst]				ifFalse: 					[removalStack isEmpty						ifTrue: [additionBlock value: additionStack removeFirst]						ifFalse: 							[(additionStack first key = removalStack first key)								ifTrue: [changeBlock value: removalStack removeFirst value: additionStack removeFirst]								ifFalse: 									[additionStack first &lt;= removalStack first										ifTrue: [additionBlock value: additionStack removeFirst]										ifFalse: [removalBlock value: removalStack removeFirst]]]]]</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison">codeComponentName	^leftProperties isEmpty		ifTrue: 			[rightProperties isEmpty				ifTrue: [nil]				ifFalse: [rightProperties any codeComponentName]]		ifFalse: [leftProperties any codeComponentName]</body><body package="Store-Code Comparison">isBundle	^leftProperties isEmpty		ifTrue: 			[rightProperties isEmpty				ifTrue: [nil]				ifFalse: [rightProperties any isBundle]]		ifFalse: [leftProperties any isBundle]</body><body package="Store-Code Comparison">leftProperties: aSequenceOfPropertyBlueprints	leftProperties := aSequenceOfPropertyBlueprints.	self populate</body><body package="Store-Code Comparison">rightProperties: aSequenceOfPropetyBlueprints	rightProperties := aSequenceOfPropetyBlueprints.	self populate</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">initialize	super initialize.	rightProperties := leftProperties := Array new</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>displaying</category><body package="Store-Code Comparison">drawDetailsBackroundOn: aGC	"not for me"</body><body package="Store-Code Comparison">drawDetailsBorderOn: aGC	"not for me"</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	| sampleProperty |	sampleProperty := leftProperties isEmpty				ifTrue: 					[rightProperties isEmpty ifTrue: [^nil] ifFalse: [rightProperties any]]				ifFalse: [leftProperties any].	^Array		with: #codeComponentProperties		with: sampleProperty codeComponentName		with: sampleProperty isBundle</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^false</body><body package="Store-Merge Management">isCommentResolver	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	| class |	proposed ifNil: [^true].	proposed isRemovalResolution ifFalse: [^true].	class :=  self longOwnerName asQualifiedReference valueOrDo: [^false].	^(((Registry containingPackageForClass: class) name = proposed package name) or: 		[Override isOverriddenClassOrNameSpace: class in: proposed package storeModel])</body><body package="Store-Merge Management">sameDefinitionAs: aString	| reference |	(reference := self ownerName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value comment = aString</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isNoOpResolution]]]) 			ifTrue: [^true].	^proposed isRemovalResolution 		ifTrue: [self applyAsRemove]		ifFalse: [self applyChange]</body><body package="Store-Merge Management">applyAsRemove	| class changeManager |	class :=  self longOwnerName asQualifiedReference valueOrDo: [^true].	refactoring := CommentChange		object: class		comment: ''.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingRemovalCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: false]</body><body package="Store-Merge Management">applyChange	| class changeManager |	class :=  self longOwnerName asQualifiedReference valueOrDo: [^true].	^[refactoring := CommentChange		object: class		comment: proposed value asString.	changeManager := RefactoryChangeManager instance.	changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: false]</body><body package="Store-Merge Management">existingDefinitionPackage		^nil</body><body package="Store-Merge Management">existingOverrides	^#()</body><body package="Store-Merge Management">hasOverrideAndShouldApply		^true</body><body package="Store-Merge Management">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	^true</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">parseText: aString		^aString notNil</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">definitionTextFor: anAlternative	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">mergeDisplayName		^(#BracketClassCommentBracket &lt;&lt; #store &gt;&gt; '[Class Comment]') asString</body><body package="Store-Merge Management">shortListName	| string |	string := self ownerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.AlreadyConnected</class-id> <category>private - actions</category><body package="Store-Repository Access">defaultAction	^Dialog confirm: 		((#AlreadyConnected1snReconnect &lt;&lt; #store &gt;&gt; 'Already Connected to &lt;1s&gt;&lt;n&gt;Reconnect?') expandMacrosWith: parameter)</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>interface opening</category><body package="Store-UI">preBuildWith: aBuilder 	"Get the blessing names."	aBuilder aspectAt: #blessingLevelMenu put: (Policies blessingPolicy blessingLevelsMenuForPundle: self pundle)</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>aspects</category><body package="Store-UI">addComment: aString	self text value: self defaultComment, self text value.	(aString isNil or: [aString isEmpty]) ifTrue: [^self].	self text value: aString, '', self text value.</body><body package="Store-UI">blessingLevel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLevel isNil		ifTrue:			[blessingLevel := 0 asValue]		ifFalse:			[blessingLevel]</body><body package="Store-UI">defaultComment	^(#VersionCreatedBy1sOn2pAt3pN &lt;&lt; #store &gt;&gt; 'Version created by: &lt;1s&gt; on: &lt;2p&gt; at: &lt;3p&gt;&lt;n&gt;') 		expandMacrosWith: self userName		with: Date today		with: Time now</body><body package="Store-UI">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	text := '' asValue.</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>accessing</category><body package="Store-UI">pundle	^pundle</body><body package="Store-UI">pundle: aPundle	pundle := aPundle</body><body package="Store-UI">userName	^userName isNil 		ifTrue: [(#Unknown &lt;&lt; #store &gt;&gt; 'Unknown') asString]		ifFalse: [userName]</body><body package="Store-UI">userName: aString		userName := aString</body></methods><methods><class-id>Store.CommentPrompt class</class-id> <category>instance creation</category><body package="Store-UI">forPundle: aPundle	^self new pundle: aPundle</body></methods><methods><class-id>Store.InstallUserManagementPolicies</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	^Dialog confirm: #InstallManagementPolicies &lt;&lt; #store &gt;&gt; 'Install management policies?'</body></methods><methods><class-id>Store.InstallUserManagementPolicies</class-id> <category>constants</category><body package="Store-Base">defaultResumeValue	^true</body><body package="Store-Base">defaultReturnValue	^true</body></methods><methods><class-id>Store.InstallUserManagementPolicies class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.RepositoryFilterDialog</class-id> <category>aspects</category><body package="Store-UI">blessingMenu	^Policies blessingPolicy blessingLevelsMenu</body><body package="Store-UI">greaterThanBlessing	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^greaterThanBlessing isNil		ifTrue:			[greaterThanBlessing := nil asValue]		ifFalse:			[greaterThanBlessing]</body><body package="Store-UI">lessThanBlessing	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lessThanBlessing isNil		ifTrue:			[lessThanBlessing := nil asValue]		ifFalse:			[lessThanBlessing]</body><body package="Store-UI">newerThanDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^newerThanDate isNil		ifTrue: [newerThanDate := self defaultNewerThanDate asValue]		ifFalse: [newerThanDate]</body><body package="Store-UI">olderThanDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^olderThanDate isNil		ifTrue: [olderThanDate := self defaultOlderThanDate asValue]		ifFalse: [olderThanDate]</body><body package="Store-UI">showBundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showBundles isNil		ifTrue:			[showBundles := false asValue]		ifFalse:			[showBundles]</body><body package="Store-UI">showPackages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showPackages isNil		ifTrue:			[showPackages := false asValue]		ifFalse:			[showPackages]</body><body package="Store-UI">useGreaterThanBlessing	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^useGreaterThanBlessing isNil		ifTrue:			[useGreaterThanBlessing := false asValue]		ifFalse:			[useGreaterThanBlessing]</body><body package="Store-UI">useLessThanBlessing	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^useLessThanBlessing isNil		ifTrue:			[useLessThanBlessing := false asValue]		ifFalse:			[useLessThanBlessing]</body><body package="Store-UI">useNewerThanDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^useNewerThanDate isNil		ifTrue:			[useNewerThanDate := false asValue]		ifFalse:			[useNewerThanDate]</body><body package="Store-UI">useOlderThanDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^useOlderThanDate isNil		ifTrue:			[useOlderThanDate := false asValue]		ifFalse:			[useOlderThanDate]</body></methods><methods><class-id>Store.RepositoryFilterDialog</class-id> <category>accessing</category><body package="Store-UI">pundleFilter	^pundleFilter ifNil: [pundleFilter := PundleFilter lastAppliedFilter]</body><body package="Store-UI">pundleFilter: aPundleFilter	pundleFilter := aPundleFilter</body></methods><methods><class-id>Store.RepositoryFilterDialog</class-id> <category>private</category><body package="Store-UI">closeAccept	self updateToolFilters.	super closeAccept</body><body package="Store-UI">defaultNewerThanDate	^Core.Date today subtractDays: 7</body><body package="Store-UI">defaultOlderThanDate	^Core.Date today</body><body package="Store-UI">setUpGreaterThanBlessing	self pundleFilter lessThanBlessing ifNotNil: 		[:value |		self useLessThanBlessing value: true.		self lessThanBlessingMenu isEnabled: true.		self lessThanBlessing value: value]</body><body package="Store-UI">setUpLessThanBlessing	self pundleFilter greaterThanBlessing ifNotNil: 		[:value |		self useGreaterThanBlessing value: true.		self greaterThanBlessingMenu isEnabled: true.		self greaterThanBlessing value: value]</body><body package="Store-UI">setUpNewerThanDate	self pundleFilter newerThanDate ifNotNil: 		[:value |		self useNewerThanDate value: true.		self newerThanInputField isEnabled: true.		self newerThanDate value: value]</body><body package="Store-UI">setUpOlderThanDate	self pundleFilter olderThanDate ifNotNil: 		[:value |		self useOlderThanDate value: true.		self olderThanInputField isEnabled: true.		self olderThanDate value: value]</body><body package="Store-UI">updateToolFilters	self pundleFilter showPackages: self showPackages value.	self pundleFilter showBundles: self showBundles value.	self useGreaterThanBlessing value		ifTrue: [self pundleFilter greaterThanBlessing: self greaterThanBlessing value]		ifFalse: [self pundleFilter greaterThanBlessing: nil].	self useLessThanBlessing value		ifTrue: [self pundleFilter lessThanBlessing: self lessThanBlessing value]		ifFalse: [self pundleFilter lessThanBlessing: nil].	self useNewerThanDate value		ifTrue: [self pundleFilter newerThanDate: self newerThanDate value]		ifFalse: [self pundleFilter newerThanDate: nil].	self useOlderThanDate value		ifTrue: [self pundleFilter olderThanDate: self olderThanDate value]		ifFalse: [self pundleFilter olderThanDate: nil].	PundleFilter lastAppliedFilter: self pundleFilter</body></methods><methods><class-id>Store.RepositoryFilterDialog</class-id> <category>widget access</category><body package="Store-UI">greaterThanBlessingCheckBox	^self widgetAt: #GreaterThanComponents</body><body package="Store-UI">greaterThanBlessingMenu	^self widgetAt: #ComponentGreaterBlessing</body><body package="Store-UI">lessThanBlessingCheckBox	^self widgetAt: #LessThanComponents</body><body package="Store-UI">lessThanBlessingMenu	^self widgetAt: #ComponentLessBlessing</body><body package="Store-UI">newerThanCheckBox	^self widgetAt: #NewerThanCheckBox</body><body package="Store-UI">newerThanInputField	^self widgetAt: #NewerThanDate</body><body package="Store-UI">olderThanCheckBox	^self widgetAt: #OlderThanCheckBox</body><body package="Store-UI">olderThanInputField	^self widgetAt: #OlderThanDate</body></methods><methods><class-id>Store.RepositoryFilterDialog</class-id> <category>actions</category><body package="Store-UI">keepShowBundlesValuesGood	(self showPackages value not and: [self showBundles value not])		ifTrue: [self showPackages value: true].</body><body package="Store-UI">keepShowPackagesValuesGood	(self showPackages value not and: [self showBundles value not])		ifTrue: [self showBundles value: true].</body><body package="Store-UI">resetToDefaults	self showPackages value: self pundleFilter defaultShowPackages.	self showBundles value: self pundleFilter defaultShowBundles.	self useGreaterThanBlessing value: false.	self useLessThanBlessing value: false.	self useOlderThanDate value: false.	self useNewerThanDate value: false.</body><body package="Store-UI">updateGreaterThanBlessingUI	self greaterThanBlessingMenu isEnabled: (self useGreaterThanBlessing value).	self useGreaterThanBlessing value ifFalse: [self greaterThanBlessing value: nil]</body><body package="Store-UI">updateLessThanBlessingUI	self lessThanBlessingMenu isEnabled: (self useLessThanBlessing value).	self useLessThanBlessing value ifFalse: [self lessThanBlessing value: nil]</body><body package="Store-UI">updateNewerThanDateUI	self newerThanInputField isEnabled: (self useNewerThanDate value).	self useNewerThanDate value ifFalse: [self newerThanDate value: self defaultNewerThanDate]</body><body package="Store-UI">updateOlderThanDateUI	self olderThanInputField isEnabled: (self useOlderThanDate value).	self useOlderThanDate value ifFalse: [self olderThanDate value: self defaultOlderThanDate]</body></methods><methods><class-id>Store.RepositoryFilterDialog</class-id> <category>interface opening</category><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self showPackages value: self pundleFilter showPackages.	self showBundles value: self pundleFilter showBundles.	self showPackages onChangeSend: #keepShowPackagesValuesGood to: self.	self showBundles onChangeSend: #keepShowBundlesValuesGood to: self.</body><body package="Store-UI">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self setUpGreaterThanBlessing.	self setUpLessThanBlessing.	self setUpNewerThanDate.	self setUpOlderThanDate.	self updateLessThanBlessingUI.	self updateGreaterThanBlessingUI.	self updateNewerThanDateUI.	self updateOlderThanDateUI.	self useLessThanBlessing onChangeSend: #updateLessThanBlessingUI to: self.	self useGreaterThanBlessing onChangeSend: #updateGreaterThanBlessingUI to: self.	self useNewerThanDate onChangeSend: #updateNewerThanDateUI to: self.	self useOlderThanDate onChangeSend: #updateOlderThanDateUI to: self.</body></methods><methods><class-id>Store.RepositoryFilterDialog class</class-id> <category>interface specs</category><body package="Store-UI">openUsing: aPundleFilter	| instance |	instance := self new.	instance pundleFilter: aPundleFilter.	^instance open</body></methods><methods><class-id>Glorp.UI.StoreWorkbook</class-id> <category>actions</category><body package="StoreForGlorpVWUI">privateLogin	"By this point in initial set up, we usually have already logged in to check the Store version, setting the platform encoding from the accessor in the process, and we need not login again.  If we logged out and are now logging in again (probably because we are opening an image that was saved with a Workbook), reapply the encoding from the platform if the (re)login attempt succeeds as the new connection will have lost it."	session isLoggedIn ifTrue: [^self].	super privateLogin.	session isLoggedIn ifTrue:	"Later, set encoding in all cases, not just postgres."		[(session accessor platform isPostgreSQLPlatform) ifTrue:			[session accessor encoding: session accessor platform characterEncoding]].</body></methods><methods><class-id>Glorp.UI.StoreWorkbook</class-id> <category>private</category><body package="StoreForGlorpVWUI">preBuildWith: aBuilder	super preBuildWith: aBuilder.	self replaceAllTextPagesWith: self class examplesPage.</body></methods><methods><class-id>Glorp.UI.StoreWorkbook</class-id> <category>initialize-release</category><body package="StoreForGlorpVWUI">onProfile: aConnectionProfile	"This calls standard Store login and sets the session local var to the session used."	super session: (Store.Glorp.StoreLoginFactory sessionForStoreLogin: aConnectionProfile).</body></methods><methods><class-id>Glorp.UI.StoreWorkbook class</class-id> <category>examples</category><body package="StoreForGlorpVWUI">exampleHeader	^'"This page contains some useful examples of Store expressions you can use or modify"'.</body><body package="StoreForGlorpVWUI">examplesOneByOne	"Return a list of alternating comments and examples for the workspace. Do this so we can automatically emphasize the text to make them stand out."^#( '"Find all bundle versions published within the last 30 days whose name starts with G (either upper or lower case) and which were published by someone whose username starts with lowercase a"''(session read: StoreBundle where: [:each |	((each name asUppercase like: ''G%'') AND: [each username like: ''a%'']) AND: [each timestamp &gt; (Date today subtractDays: 30)]])	groupedBy: #name.''"Find all packages in the system." ''session read: StoreVersionlessPackage.''"Find all packages for which any version has a blessing level of ''Internal Release'' or higher"''session read: StoreVersionlessPackage where: [:each |	each versions anySatisfy: [:eachVersion |		eachVersion currentBlessingLevel &gt; Store.Access defaultBlessingPolicy internalReleaseBlessing]].''"Find all the packages that define the method #yourself. Note this can be slow on a large database." ''(session read: StorePackage where: [:each |	each methods anySatisfy: [:eachMethod | 		eachMethod definition name = ''yourself'']])			groupedBy: #name.''"Find all the packages that define the class Object. Note this can be slow on a large database." ''(session read: StorePackage where: [:each |	each classDefinitions anySatisfy: [:eachClass | 		eachClass definition name = ''Object'']])			groupedBy: #name.''"Find all the packages that define less than 5 classes"''(session read: StorePackage where: [:each |	each classDefinitions sqlCount &lt; 5])		groupedBy: #name.''"Find if/where a particular package was renamed"''(renamed := session read: StorePackage where: [:each |	each name = ''X'' &amp; (each trace name ~= ''X'')])		groupedBy: #name.''"Find the latest version of all bundles in the system. Restrict to those where the latest version is published by user aknight. Also does this by creating a separate query object and executing it, rather than using the session convenience protocol."''| query |query := Query read: StoreBundle where: [:each |	| q |	q := Query read: StoreBundle where: [:eachBundle |		eachBundle name = each name].	q retrieve: [:x | x primaryKey max].	each username = ''aknight''  &amp; (each primaryKey = q)].query orderBy: [:each | each timestamp descending].session execute: query.''"Empty out all of our caches"''session reset.''"The expressions above are safe, because they only read from the database. Those below this point can modify the database. This is ***DANGEROUS!!!***. Inserting something incorrect can add invalid packages or other structures to your database. Deleting or updating can cause you to lose data. By default, the ability to update or delete is disabled in the Store workbook, to prevent accidental damage to the database. Any attempt to do that will cause an ''Illegal Command'' error or will fail validation in the StoreDescriptorSystem, which checks for updates and deletes, which are not normally valid Store operations. In order to allow the session to delete or update rows, evaluate the following expression."''session accessor permitEverything.''"Stop the session from deleting or updating rows. This restore the default setting in the Store workbook, to prevent accidental damage to the database"''session accessor insertOnly.''"Delete version 1.0 of the package named Foo. Note that this just deletes the package record, it won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the package disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	| query |	query := Query 		readOneOf: StorePackage 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	thePackage := session execute: query.	thePackage isNil 		ifTrue: [self error: ''No such package''] 		ifFalse: [thePackage delete].	(session execute: query) isNil ifFalse: [self error: ''Package was not deleted''].''"Delete version 1.0 of the bundle named Foo. Note that this is recursive - it will delete the bundle record, and the packages/sub-bundles that it contains, if they aren''t used as part of any other bundles. But it only deletes the bundle/package record. It won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the bundle disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	| query |	query := Query 		readOneOf: StoreBundle 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	theBundle := session execute: query.	theBundle isNil 		ifTrue: [self error: ''No such bundle'']		ifFalse: [theBundle delete].	(session execute: query) isNil ifFalse: [self error: ''Bundle was not deleted''].''"Change the name of the package Foo (all versions) to Bar. Again, you might want to think twice before doing this to a real live database with important source code in it. Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level."''	oldName := ''Foo''.	newName := ''Bar''.	versions := session read: StorePackage where: [:each | each name = oldName].	versions isEmpty ifTrue: [self error: ''No such package''].	session modify: versions in: [		versions do: [:each | each name: newName]].	newVersions := session read: StorePackage where: [:each | each name = oldName].	newVersions isEmpty ifFalse: [self error: ''Package was not properly renamed''].	newVersions := session read: StorePackage where: [:each | each name = newName].	newVersions isEmpty ifTrue: [self error: ''Package was not properly renamed''].''"Create the indexes that StoreGlorp defines into the database. Useful if you want to set up some indexes into a default Store setup database. Requires permissions, and will probably have problems if some of them already exist."''session system allTables do: [:each |			session accessor createTableIndexes: each ifError: [self halt]]. ').</body><body package="StoreForGlorpVWUI">workbookLabel	^'Store Examples'.</body></methods><methods><class-id>Glorp.UI.StoreWorkbook class</class-id> <category>instance creation</category><body package="StoreForGlorpVWUI">openRequestingDatabase	| profile logins |	logins := Store.RepositoryManager repositories.	profile := SimpleDialog new		choose: 'Select repository'		fromList: (logins collect: [:l | l name])		values: logins		buttons: (Array with: #OpenWorkbookOnNewProfile &lt;&lt; #store							&gt;&gt; 'Open Workbook on New Profile...')		values: #(#openWorkbookOnNewProfile)		lines: logins size		cancel: [^nil].	profile == #openWorkbookOnNewProfile ifTrue:		[| dialog | dialog := Store.ConnectionDialog new.		dialog currentProfile: dialog createNewProfile.	"do not reset the 'Connect to Repository...' default"		profile := dialog open			ifTrue: [dialog currentProfile]			ifFalse: [^nil]].	^(self new onProfile: profile) open</body></methods><methods><class-id>Store.PublishPundlesDialog</class-id> <category>actions</category><body package="Store-UI">accept	"Publish a pundle.  	It's possible there have been changes to the bundle since we opened the dialog, 	so tell the user to retry and close the UI without publishing, because otherwise the 	pundles will/can get nil blessing levels and versions."	self validatePublishStateIsConsistent ifFalse: [^self].	(self specList allSatisfy: [:each | each publish not or: [self canPublish: each]])		ifFalse: [^self].	self fillEmptyComments.	Announcements announce: (StorePrePublish for: self specifications: self specList).	StoreProgressOverlay 		subsume: builder window		while: 			[self specList publishPundlesIn: session.			callBackBlock ifNotNil: [callBackBlock value: items list]].	Announcements announce: (StorePostPublish for: self specifications: self specList).	self updatePackageListsAndClose</body></methods><methods><class-id>Store.PublishPundlesDialog</class-id> <category>interface opening</category><body package="Store-UI">localPostOpenWith: aBuilder	[ | specs |	(Gathering for: (pundles first)) started.	self mainWindow label: self class windowLabel.	specs := self class publishSpecsFrom: self culledPundles in: self glorpSession.	specs do: [:each | (pundles includes: each pundleModel) ifTrue: [each publish: true; modified: true]].	self items list: specs.	Announcements announce: (StorePublishDialogOpening for: self).	self items selectionIndexHolder onChangeSend: #newItemSelection to: self.	self setVisualBlocks.	self items selectionIndex: 1.	(Gathering for: (pundles first)) finished] withStoreFeedbackOn: self mainWindow</body><body package="Store-UI">openOnPundles: aCollectionOfPundleModel session: aGlorpSession	session := aGlorpSession.	pundles := aCollectionOfPundleModel.	self open</body></methods><methods><class-id>Store.PublishPundlesDialog</class-id> <category>private-publishing</category><body package="Store-UI">fillEmptyComments	"Look at the spec list and determine any publish spec which have empty comments. When found, copy our global comment"	self blessingComment value notEmpty 		ifTrue: [self specList fillEmptyCommentsWith: self blessingComment value].</body></methods><methods><class-id>Store.PublishPundlesDialog</class-id> <category>private</category><body package="Store-UI">culledPundles	| packages bundles |	packages := pundles select: #isPackage.	bundles := pundles select: #isBundle.	packages copy do:		[:eachPackage |		(bundles detect: [:eachBundle | eachPackage enclosingComponents includes: eachBundle] ifNone: [nil])			ifNotNil: [packages remove: eachPackage]].	bundles copy do:		[:each |		(bundles detect: [:eachBundle | each enclosingComponents includes: eachBundle] ifNone: [nil])			ifNotNil: [bundles remove: each]].	packages copy do:		[:each |		| count |		(count := packages occurrencesOf: each) &gt; 1 ifTrue: [count - 1 timesRepeat: [packages remove: each ifAbsent: [nil]]]].	bundles copy do:		[:each |		| count |		(count := bundles occurrencesOf: each) &gt; 1 ifTrue: [count - 1 timesRepeat: [bundles remove: each ifAbsent: [nil]]]].	^bundles, packages</body></methods><methods><class-id>Store.PublishPundlesDialog class</class-id> <category>private</category><body package="Store-UI">askIfUserWantsToPublishSiblingFor: storePundle	^StoreNewVersionWarning		raiseSignal: (#AtLeastOneNew1Bool2sn &lt;&lt; #store				&gt;&gt; 'There is at least one newer version of &lt;1?Bundle:Package&gt; &lt;2s&gt; in the repository.&lt;n&gt;Continue to Publish?'					expandMacrosWith: storePundle isBundle					with: storePundle shortItemString)</body><body package="Store-UI">publishSpecsFrom: aCollectionOfPundleModel	^PublishSpecificationList fromPundles: aCollectionOfPundleModel</body><body package="Store-UI">publishSpecsFrom: aCollectionOfPundleModel in: aSession	^PublishSpecificationList fromPundles: aCollectionOfPundleModel in: aSession</body><body package="Store-UI">reconcileOrCancelMessageFor: aPundle	^#x1sIsNotLinkedProceedByReconciling 		&lt;&lt; #store		&gt;&gt; '&lt;1s&gt; is not linked to an existing version with the same name in the current database.&lt;n&gt; Proceed by reconciling?'			expandMacrosWith: aPundle name</body><body package="Store-UI">validateSourcesIn: aCollectionOfPundleModel in: aSession	| allItems |	allItems := aCollectionOfPundleModel 		inject: Set new		into: 			[:sum :each |			sum addAll: each withAllContainedItems.			sum].	(allItems anySatisfy: [:each | each getImagePundle ~~ each])		ifTrue: [^false].	StoreObject warnIfNewerVersionPublished ifTrue:		[aCollectionOfPundleModel do: 			[:each |			| storePundle versions |			storePundle := each asStorePundleIn: aSession.			storePundle ifNotNil: 				[versions := storePundle class newerVersionsOf: storePundle in: aSession.				versions notEmpty ifTrue: 					[(self askIfUserWantsToPublishSiblingFor: storePundle) ifFalse: [^false]]]]].	allItems do: 		[:each |		(each canBePublishedToCurrentDatabaseIn: aSession) ifFalse: 			[(Dialog confirm: (self reconcileOrCancelMessageFor: each))				ifFalse: [^false]				ifTrue: [(each reconcileWithDbIn: aSession) ifNil: [^false]]]].	^true</body></methods><methods><class-id>Store.PublishPundlesDialog class</class-id> <category>constants</category><body package="Store-UI">windowLabel		^#PublishingOn1sFor2s &lt;&lt; #labels &gt;&gt; 'Publishing on: &lt;1s&gt; for: &lt;2s&gt;'		expandMacrosWith: self connectionLabel		with: DbRegistry connectedProfile userName</body></methods><methods><class-id>Store.PublishPundlesDialog class</class-id> <category>interface opening</category><body package="Store-UI">publishPundles: aCollectionOfPundleModel	^self publishPundles: aCollectionOfPundleModel ifSuccessfulDo: nil</body><body package="Store-UI">publishPundles: aCollectionOfPundleModel ifSuccessfulDo: aBlockOrNil	"Return the dialog, or nil if we did not open one."	| session instance |	session := StoreLoginFactory currentStoreSession.	(self validateSourcesIn: aCollectionOfPundleModel in: session) ifFalse: [^nil].	instance := self new.	instance callBackBlock: aBlockOrNil.	instance openOnPundles: aCollectionOfPundleModel session: session.	^instance</body></methods><methods><class-id>Store.PublishPundlesDialog class</class-id> <category>class initialization</category><body package="Store-UI">initialize	"self initialize "	| complexList |	complexList := 		OrderedCollection new			add: 'Blessing' -&gt; #(#mainSpec #mainHelp);			add: 'Version Names' -&gt; #(#versionSpec #versionHelp);			add: 'Items to Publish' -&gt; #(#publishSpec #publishHelp);			asArray.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new: 1.</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	| focus |	pundle isNil ifFalse: 		[aBuilder window label: ((#VersionsOf1s &lt;&lt; #store &gt;&gt; 'Versions of &lt;1s&gt;') expandMacrosWith: pundle name)].	focus := self graphView focus value asArray.	focus size = 1 ifTrue: [self graphView select: focus first]</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>accessing</category><body package="Store-UI-Graphs">perspective	^#tt_derives</body><body package="Store-UI-Graphs">pundle	^pundle</body><body package="Store-UI-Graphs">pundle: aPundle	pundle := aPundle</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>initialize-release</category><body package="Store-UI-Graphs">loadInitialVersions	| punSet cache focus |	punSet := Set new.	(pundle isLoaded or: [pundle primaryKey notNil]) 		ifTrue: [punSet add: pundle]		ifFalse: 			[| list |			list := pundle allVersionsWithName: pundle name.			list isEmpty 				ifTrue: 					[Dialog warn: ((#ThereAreNoPublishedVersionsOf1s &lt;&lt; #store &gt;&gt; 'There are no published versions of &lt;1s&gt;.') 								expandMacrosWith: self pundle name).					^false].			punSet add: list last.			list 				do: [:each | (each dbTrace = 0 or: [each dbTrace isNil]) ifTrue: [punSet add: each]]].	cache := Dictionary new.	focus := punSet collect: [:pun | ElementProxy element: pun cache: cache].	self graphView focus: focus.	^true</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>actions</category><body package="Store-UI-Graphs">listBundleContents	[Store.Glorp.DefinitionForListTool forBundleContents: pundle] withStoreFeedbackOn: self mainWindow.</body><body package="Store-UI-Graphs">reloadVersions		| imagePundle |	(pundle isLoaded and: [pundle isImageModel]) ifTrue:		[imagePundle := pundle isBundle 			ifTrue: [Registry bundleNamed: pundle name] 			ifFalse: [Registry packageNamed: pundle name].		imagePundle isNil ifTrue:			[(imagePundle := imagePundle newestVersionWithName: pundle name) ifNil:				[^Dialog warn: (#_1sDoesNotExist &lt;&lt; #store &gt;&gt; '&lt;1s&gt; does not exist' expandMacrosWith: pundle name)]].		self pundle: imagePundle].	self loadInitialVersions</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>instance creation</category><body package="Store-UI-Graphs">browseVersionsOfPundle: aPundle 	DbRegistry doIfOnlineImage: 		[| preferredPresentation |		preferredPresentation := StoreSettings preferenceFor: #versionManagerView.		Cursor wait showWhile: 			[| graph |			graph := self new.			graph pundle: aPundle.			graph loadInitialVersions ifFalse: [^self].			preferredPresentation = #indentedPresentation ifTrue: [graph beIndentedList].			self openOn: graph]]</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs">initializePerspectives	"TT_VersionGraph initializePerspectives"	^(List new) add: ((Array new: 9)			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: #(						#(#F1 #V1 'tt_derives' true false false false false) 						#(#V2 #F1 'tt_derives' true false false false false) 						#(#V1 #V1 'tt_derives' false false true false false)					);			at: 4 put: #arrLabelHints:;			at: 5 put: #(#blessing);			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_derives';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue blue;					at: 5 put: 1; yourself); yourself);			at: 8 put: #name:;			at: 9 put: #tt_derives; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs">initializeRelationships	"self initializeRelationships"	^(List new) add: #(#LDMFirstOrderRel #name: 'tt_derives' #description: 'derives' #reverse: nil #token: #tt_derivesRel) decodeAsLiteralArray; add: #(#LDMFirstOrderRel #name: 'tt_derivesR' #description: 'derivesR' #reverse: nil #token: #tt_derivesRRel) decodeAsLiteralArray; yourself</body></methods><methods><class-id>ShadowCompiler</class-id> <category>compilation</category><body package="Atomic Compiling and Loading">evaluate: aString with: aCompiler	"Compile and execute a definition string into Shadow space. Answer the result.	On failure, answer the exception."		^self evaluate: aString with: aCompiler using: self</body><body package="Atomic Compiling and Loading">evaluate: aString with: aCompiler using: aCompilationManager	"Compile and execute a definition string into Shadow space. 	Suppress the general warning about variable naming conventions.	Answer the result. On failure, answer the exception."		^[| aMethod  |	aMethod := self compileDefinitionString: aString with: aCompiler.	[[[self invokeMethod: aMethod]		on: VariableConfirmation 		do: [:exception | exception resume: false]]			on: SharedNeedsShadowRoot			do: [:notification | notification resume: aCompilationManager]]				on: ClassConstructionError				do: [:exception | exception resume]]					on: Error					do: [:exception | exception return: exception]</body></methods><methods><class-id>ShadowCompiler</class-id> <category>utility</category><body package="Atomic Compiling and Loading">findInShadow: aReference	"Locate aReference off of shadow root. Answer nil if not found."	"Cavaet: works for namespaces and classes, but not shareds whose value can be nil."	| path current |	path := aReference path.	current := path first == #Root		ifTrue: [ shadowRoot ]		ifFalse: [ path first == #Smalltalk					ifTrue: [ shadowRoot at: #Smalltalk ]					ifFalse: 						[ current := ( shadowRoot at: #Smalltalk ) localBindingFor: path first.						current == nil ifTrue: [ ^nil ].						current value.						]				].	2 to: path size do:		[ :i | 		( current := current localBindingFor: ( path at: i ) ) == nil			ifTrue: [ ^nil ].		current := current value.		].	^current</body></methods><methods><class-id>ShadowCompiler</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">shadowAt: aPath	^(self shadowRoot		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body><body package="Atomic Compiling and Loading">shadowRoot	^shadowRoot</body><body package="Atomic Compiling and Loading">shadowRoot: anObject	shadowRoot := anObject</body></methods><methods><class-id>ShadowCompiler</class-id> <category>private</category><body package="Atomic Compiling and Loading">addShadowNamespaceToEnvironment: aShadowEnvironment	| namespace builder newNamespace binding |	(namespace := self findInShadow: aShadowEnvironment environment unambiguousName asStrictReference)		ifNil: [self addShadowNamespaceToEnvironment: aShadowEnvironment environment].	builder := ShadowNameSpaceBuilder new.	newNamespace := builder createShadowOf: aShadowEnvironment.	newNamespace environment: namespace. 	binding := (namespace createKey: aShadowEnvironment name value: newNamespace).	(namespace includesKey: binding key)		ifFalse: [	namespace addBinding: binding].</body><body package="Atomic Compiling and Loading">addShadowedClassToEnvironment: aShadowedClass	| namespace binding |	(self findInShadow: aShadowedClass environment unambiguousName asStrictReference) ifNil:		[self addShadowNamespaceToEnvironment: aShadowedClass environment].	namespace := self findInShadow: aShadowedClass environment unambiguousName asStrictReference. 	binding := (namespace createKey: aShadowedClass name value: aShadowedClass).	binding environment: namespace.	(namespace includesKey: binding key)		ifFalse: [	namespace addBinding: binding].</body><body package="Atomic Compiling and Loading">compileDefinitionString: aString with: aCompiler 	"Compiles a definition string (NameSpace, Class or Shared) in the context of the shadowed space.	Answers the method"	| method |	method := aCompiler 				compile: aString				in: nil				allowReceiver: true				class: nil class				environment: self shadowRoot				noPattern: true				notifying: SilentCompilerErrorHandler new				ifFail: [nil].	method == nil ifTrue: [self error: #badDefinition &lt;&lt; #store &gt;&gt; 'bad definition'].	^method</body><body package="Atomic Compiling and Loading">createShadowClassFor: existingClass	"Create a shadow class for existingClass and return what was created.  One would	 use this for creating a shadowed class to put extension methods/shareds on."		| string insertPoint shadowDefinition newShadowCompiler shadowedClass |	existingClass residesInStandardEnvironment ifFalse: 		[^existingClass].	(shadowedClass := self findInShadow: existingClass unambiguousName asStrictReference) ifNotNil: 		[^shadowedClass].	string := existingClass definition.	insertPoint := string indexOfSubCollection: 'defineClass:' startingAt: 1 		ifAbsent: [string indexOfSubCollection: 'defineNameSpace:' startingAt: 1].	shadowDefinition := string copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.	newShadowCompiler := self class root: self shadowRoot.	shadowedClass := newShadowCompiler evaluate: shadowDefinition with: Compiler new.	shadowedClass isSignalledException ifTrue:		[shadowedClass := newShadowCompiler evaluate: string with: Compiler new].	shadowedClass reallyFullyQualifiedReference bindingOrNil ifNotNil: [:value | value setReservedFlag: true].	^shadowedClass</body><body package="Atomic Compiling and Loading">createShadowClassOrNameSpaceFor: existingClass	"Create a shadow class for existingClass and return what was created.  One would	 use this for creating a shadowed class to put extension methods/shareds on."		| string insertPoint shadowDefinition newShadowCompiler shadowedClass |	existingClass residesInStandardEnvironment ifFalse: 		[^existingClass].	(shadowedClass := self findInShadow: existingClass unambiguousName asStrictReference) ifNotNil: 		[^shadowedClass].	string := existingClass definition.	insertPoint := string indexOfSubCollection: 'defineClass:' startingAt: 1 		ifAbsent: [string indexOfSubCollection: 'defineNameSpace:' startingAt: 1].	shadowDefinition := string copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.	newShadowCompiler := self class root: self shadowRoot.	shadowedClass := (newShadowCompiler evaluate: shadowDefinition with: Compiler new) environment.	shadowedClass ifNil: 		[shadowedClass := newShadowCompiler evaluate: string with: Compiler new].	shadowedClass reallyFullyQualifiedReference bindingOrNil ifNotNil: [:value | value setReservedFlag: true].	^shadowedClass</body><body package="Atomic Compiling and Loading">invokeMethod: aMethod	"Executes aMethod in the context of shadowed space, allowing it to resolve variables in Shadow-land	and only if not found, in the system."		^Processor activeProcess scopeEnvironmentWhile:		[:newProcessEnvironment | 		| handler |		handler := ShadowNameSpaceHandler new.		handler shadowRoot: self shadowRoot.		newProcessEnvironment bindingHandler: handler.		nil performMethod: aMethod]</body></methods><methods><class-id>ShadowCompiler class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">root: aRootNameSpace	"Answer an instance that uses aRootNameSpace as it's compilation environment."		^(self new)		shadowRoot: aRootNameSpace;		yourself</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>aspects</category><body package="Store-Merge Management">mergeList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mergeList isNil		ifTrue:			[mergeList := MultiSelectionInList new]		ifFalse:			[mergeList]</body><body package="Store-Merge Management">pundleList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleList isNil		ifTrue:			[pundleList := SelectionInTree new]		ifFalse:			[pundleList]</body><body package="Store-Merge Management">pundleVersions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleVersions isNil		ifTrue:			[pundleVersions := MultiSelectionInList new]		ifFalse:			[pundleVersions]</body><body package="Store-Merge Management">pundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleList isNil		ifTrue:			[pundleList := SelectionInTree new]		ifFalse:			[pundleList]</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>interface opening</category><body package="Store-Merge Management">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #VersionList) displayStringSelector: #mergeDisplayString.</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>private</category><body package="Store-Merge Management">buttonEnablement	(builder componentAt: #AcceptButton) widget isEnabled: mergeList list notEmpty</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>actions</category><body package="Store-Merge Management">accept	| items |	items := mergeList list asArray.	self closeRequest.	[(Delay forMilliseconds: 250) wait.	[mergeTool mergeSelectedPundleVersions: items] uiEventFor: mergeTool builder window.] fork.</body><body package="Store-Merge Management">add	| mergeSet |	mergeSet := mergeList list asSet.	mergeSet addAll: pundleVersions selections.	mergeList list: (SortedCollection withAll: mergeSet sortBlock: [:a :b | a displayString &gt;= b displayString]) asList.	self buttonEnablement.</body><body package="Store-Merge Management">remove	mergeList list removeAll: mergeList selections.	self buttonEnablement.</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>accessing</category><body package="Store-Merge Management">mergeTool: anObject	mergeTool := anObject</body><body package="Store-Merge Management">storeRegistry	^#{Store.Registry} valueOrDo: [nil]</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	super initialize.	self pundleList list: (TreeModel 		on: (Refactory.Browser.PackageListRoot onEnvironment: Refactory.Browser.BrowserEnvironment new)		displayRoot: false		childrenWith: [:each | each children]).	self pundleList selectionIndexHolder onChangeSend: #pundleSelected to: self.</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>selecting</category><body package="Store-Merge Management">pundleSelected		| pundleModel list |	Store.DbRegistry isOnline ifFalse: [^self].	pundleModel := self pundleList selection ifNotNil: #codeComponent.	list := pundleModel isNil		ifTrue: [List new]		ifFalse: [(pundleModel storeVersionsIn: mergeTool databaseSession) asList].	self pundleVersions list: list</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector class</class-id> <category>instance creation</category><body package="Store-Merge Management">openOn: aMergeTool	| me |	me := self new.	me mergeTool: aMergeTool.	me open.</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>testing</category><body package="Store-Change Management">belongsToClass	^true</body><body package="Store-Change Management">existsInImage	^self actualClass notNil</body><body package="Store-Change Management">isClassCommentTag	^true</body><body package="Store-Change Management">isInClass	^true</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: aRecord 	"Load the new class comment from a definition contained in 	aRecord. 	Return true is the operation is successful."	| cl |	cl := aRecord myClass.	^cl isNil 		ifTrue: 			[self error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') expandMacrosWith: aRecord className).			false]		ifFalse: 			[aRecord loadCommentFor: cl.			true]</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>accessing</category><body package="Store-Change Management">containingPackage	"Answer a packge that contians the defintion described by me."	"(ClassCommentTag newClassName: 'MethodTag class') containingPackage"	^Registry containingPackageForClassNamed: self className</body><body package="Store-Change Management">description	^'class comment'</body><body package="Store-Change Management">isMeta	^false</body><body package="Store-Change Management">name	^self className, ' comment'</body><body package="Store-Change Management">sourceTextForImage	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl comment]</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| actualClass |	actualClass := self actualClass.	actualClass isNil 		ifTrue: 			[Dialog 				warn: ((#TheClass1sMustExistAndApplyResolved &lt;&lt; #store &gt;&gt; 'The class "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept an edited comment.&lt;n&gt;Resolve conflicts in the class definition, if any,&lt;n&gt;and "Apply Resolved".') 						expandMacrosWith: self classSymbol asString).			^false].	actualClass comment: someText.	^true</body><body package="Store-Change Management">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	actual notNil		ifTrue: [XChangeSet current				moveClassDefinition: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	(self actualClass isNil and: [tolerantBoolean not]) ifTrue: [		^self 			error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') 			expandMacrosWith: self className)].	self actualClass comment: nil.</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseClass: self actualClass.</body><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self actualClass ) == nil		ifFalse: [ obj fileOutCommentOn: aStream ]</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutCommentOn: aStream.</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"don't bother to remove the comment"</body><body package="Store-Change Management">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'class comment'</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>converting</category><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForClassTag: self.</body></methods><methods><class-id>Store.ClassCommentTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^2</body></methods><methods><class-id>Store.Glorp.StoreDatabaseTable</class-id> <category>accessing</category><body package="Store-Database Model">propertyAt: aSymbol	^properties at: aSymbol ifAbsent: [nil]</body><body package="Store-Database Model">propertyAt: aSymbol put: anObject	anObject isNil ifTrue: [^properties removeKey: aSymbol ifAbsent: [nil]].	properties at: aSymbol put: anObject</body></methods><methods><class-id>Store.Glorp.StoreDatabaseTable</class-id> <category>initialize</category><body package="Store-Database Model">initialize	super initialize.	properties := IdentityDictionary new</body></methods><methods><class-id>Store.StoreLoggingTool</class-id> <category>views</category><body package="Store-Base">collector	| textCollectorView |	textCollectorView := TextCollectorView model: self textCollector.	textCollectorView editText: self textCollector value.	textCollectorView controller: TextEditorController new.	^textCollectorView</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>accessing</category><body package="Store-Base">definitionRecord	^parameter</body><body package="Store-Base">definitionRecord: aDbRecord	parameter := aDbRecord</body><body package="Store-Base">fullDisplayStringWithUnloadableReason	"Display package, Store object and reason for being unloadable"	| aStoreObject stream |	aStoreObject := self definitionRecord.	stream := (String new: 256) writeStream.	aStoreObject isStoreDefinitionInPackage		ifTrue: ["let the object print the package tag"]		ifFalse: [self package ifNotNil: [:pkg | stream nextPutAll: ('[&lt;1s&gt;] ' expandMacrosWith: pkg name)]].	^stream		nextPutAll: aStoreObject fullDisplayString;		nextPutAll: (' (&lt;1s&gt;)' expandMacrosWith: self problemString);		contents</body><body package="Store-Base">originalError	^originalError</body><body package="Store-Base">originalError: anError	originalError := anError</body><body package="Store-Base">package 	^package</body><body package="Store-Base">package: aPackage	package := aPackage</body><body package="Store-Base">problemString	"Answer #messageText if specified, otherwise answer #messageText of #originalError."	| txt anError |	(txt := self messageText) notEmpty ifTrue: [^txt].	(anError := self originalError) isNil ifTrue: [^txt].	(anError isKindOf: UnhandledException)		ifTrue: [anError := self originalError unhandledException].	^anError description</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	"If the exception is not handled, then assume a simple user session and show a warning dialog.	Answer nil."	^Dialog warn: self definitionRecord defaultUnloadableMessage</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>actions</category><body package="Store-Base">fileoutOutOn: aSourceCodeStream	self definitionRecord fileOutOn: aSourceCodeStream.</body><body package="Store-Base">loadRecord	self definitionRecord loadSrcInto: package</body><body package="Store-Base">removeRecord	"Mark this record as removed - so it shows up in the package's changeset."	package == nil		ifFalse: [ self definitionRecord removeFromPackage: package ]</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>printing</category><body package="Store-Base">displayString	| stream |	stream := WriteStream on: String new.	stream nextPutAll: self definitionRecord fullDisplayString.	originalError ifNotNil:		[stream 			space			nextPut: $(;			nextPutAll: originalError class name;			space;			nextPutAll: originalError messageText;			nextPut: $)].	^stream contents</body><body package="Store-Base">printOn: aStream 	aStream nextPutAll: (#UnloadableError1p &lt;&lt; #store &gt;&gt; 'Unloadable Error: &lt;1p&gt;' expandMacrosWith: self definitionRecord)</body></methods><methods><class-id>Store.UnloadableDefinitionError class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.UnloadableDefinitionError class</class-id> <category>instance creation</category><body package="Store-Base">for: aStoreDbRecord inPackage: aPackage error: exceptionOrString 	"Create a new instance, populated with the given parameters.	Assume that the sender context is the one that will raise the exception, 	and the sender of that is the one that detects the unloadable problem."	| raisingContext sufferingContext unloadableError errorMessage |	raisingContext := thisContext sender.	sufferingContext := raisingContext sender.	(unloadableError := self new)		searchFrom: sufferingContext;		originator: sufferingContext homeReceiver;		definitionRecord: aStoreDbRecord;		package: (aPackage isNil ifTrue: ["no #forcePackage:while: in progress"] ifFalse: [aPackage storeModel]).	errorMessage := exceptionOrString isSignalledException		ifTrue: 			[unloadableError originalError: exceptionOrString.			exceptionOrString messageText]		ifFalse: [exceptionOrString isNil ifTrue: [aStoreDbRecord defaultUnloadableMessage] ifFalse: [exceptionOrString]].	errorMessage notNil ifTrue: [unloadableError messageText: errorMessage].	^unloadableError</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>actions</category><body package="StoreForGlorpBrowserUI">browseLocalSelectors	| node results |	node := self findNode.	(node isNil or: [node isMessage not])		ifFalse: 			[results := self environment implementorsOf: node selector.			results notEmpty				ifTrue: [results openEditor]				ifFalse: 					[Dialog						warn: (#NoLocalImplementorsOf1pFound &lt;&lt; #store								&gt;&gt; 'No local implementors of &lt;1p&gt; found' expandMacrosWith: node selector)]]</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>updating</category><body package="StoreForGlorpBrowserUI">update: anAspectSymbol with: aParameter from: aSender	"I don't do this, at least not for now"</body><body package="StoreForGlorpBrowserUI">updateContents	| compiledMethod source text |	modified := false.	self updateTextWidget.	(self selectors size &gt; 1 or: [self selectedClass isNil])		ifTrue: [^self text: ''].	self selector isNil		ifTrue: [^self text: ''].	compiledMethod := self methodClass compiledMethodAt: self selector				ifAbsent: [self warn: #MethodHasBeenRemoved &lt;&lt; #pdp &gt;&gt; 'Method has been removed'.					^self text: ''].	source := self methodClass sourceCodeForMethod: compiledMethod				at: self selector.	text := self formatSource: source for: compiledMethod.	self text: text.	self updateSelection</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>private-environments</category><body package="StoreForGlorpBrowserUI">protocolEnvironment	^StoreProtocolEnvironment 		onEnvironment: self wrappedEnvironment		class: self selectedClass		protocols: self protocols</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>private</category><body package="Store-UI">connectTo: aProfile	Cursor wait showWhile: [ DbRegistry connectTo: aProfile ]</body><body package="Store-UI">connectToNew	self disconnect.	DbRegistry restoreConnection</body><body package="Store-UI">currentRepositoryLabel	"Hack to enable loading."	DbRegistry ifNotNil: [ :registry | registry connectedProfile ifNotNil: [ :profile | ^self labelForProfile: profile ] ].	^#repmanNotConnected &lt;&lt; #labels &gt;&gt; 'Not connected'</body><body package="Store-UI">disconnect	Cursor wait showWhile: [ DbRegistry disconnect ]</body><body package="Store-UI">installLabelController	| controller |	controller := ControllerWithSelectMenu new.	controller selectMenuHolder: [ self repositoryListMenu ]; performer: self.	(self widgetAt: #label) controller: controller.	controller := ControllerWithSelectMenu new.	controller selectMenuHolder: [ self repositoryListMenu ]; performer: self.	(self widgetAt: #menuButtonImage) controller: controller</body><body package="Store-UI">intrinsicHeight	^self intrinsicHeightConstraint value</body><body package="Store-UI">intrinsicHeightConstraint	^intrinsicHeightConstraint ifNil: [		intrinsicHeightConstraint := Constraint			owner: self			name: #intrinsicHeight			rule: [(self widgetAt: #label) intrinsicHeight max: (self widgetAt: #menuButtonImage) intrinsicHeight]]</body><body package="Store-UI">intrinsicWidth	^self intrinsicWidthConstraint value</body><body package="Store-UI">intrinsicWidthConstraint	^intrinsicWidthConstraint ifNil: [		intrinsicWidthConstraint := Constraint			owner: self			name: #intrinsicWidth			rule: [(self widgetAt: #label) intrinsicWidth + (self widgetAt: #menuButtonImage) intrinsicWidth]]</body><body package="Store-UI">isConnected	^DbRegistry connectedProfileHolder value notNil</body><body package="Store-UI">isConnectedProfileRegistered	^RepositoryManager repositories includes: DbRegistry connectedProfile</body><body package="Store-UI">labelForProfile: connectedProfile 	connectedProfile name ifNotNil: [ :label | label notEmpty ifTrue: [ ^label ] ].	connectedProfile environment ifNotNil: [ :label | label notEmpty ifTrue: [ ^label ] ].	^(#aRepository &lt;&lt; #labels &gt;&gt; 'a Repository') asString</body><body package="Store-UI">updateRepositoryLabel	(self widgetAt: #label) ifNotNil: [:widget |		"The spaces at the end are a bit of a UI hack to separate the label from the action icon"		widget label: (Label with: 'Store: ' asText allBold , self currentRepositoryLabel , '  ').		self intrinsicWidthConstraint resetValue]</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>actions</category><body package="Store-UI">openRepositoryManager	RepositoryManager open</body><body package="Store-UI">repositoryExport	RepositoryManager saveRepositoriesToFile</body><body package="Store-UI">repositoryImport	RepositoryManager importRepositoriesFromFile</body><body package="Store-UI">repositoryMoreRecentlyPublishedItems	DbRegistry doIfOnlineImage: [		[			Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItemsUnfiltered		] withStoreFeedbackOn: self mainWindow	]</body><body package="Store-UI">repositoryMoreRecentlyPublishedItemsWithFilter	DbRegistry doIfOnlineImage: [		[			Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItemsWithFilter		] withStoreFeedbackOn: self mainWindow	]</body><body package="Store-UI">repositoryNew	RepositoryManager addProfileFromUser</body><body package="Store-UI">repositoryProperties	DbRegistry connectedProfileHolder value ifNotNil: [ :selection |		RepositoryPropertiesDialog openOn: selection.		RepositoryManager updateRepository: selection	]</body><body package="Store-UI">repositoryPublishedItems	DbRegistry doIfOnlineImage: [		Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesUnfiltered	]</body><body package="Store-UI">repositoryPublishedItemsWithFilter	DbRegistry doIfOnlineImage: [		Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesWithFilter	]</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>menu building</category><body package="Store-UI">createConnectOrDisconnectItemFor: aProfile 	| item |	item := MenuItem labeled: (self labelForProfile: aProfile).	item value: (		aProfile isConnected 			ifTrue: [ [ :controller | self disconnect ] ]			ifFalse: [ [ :controller | self connectTo: aProfile ] ]	).	aProfile isConnected ifTrue: [ item beOn ].	^item</body><body package="Store-UI">createConnectToNewItem	^(MenuItem labeled: #repmanConnectToNew &lt;&lt; #labels &gt;&gt; 'Connect to...')		value: [ :controller | self connectToNew ];		yourself</body><body package="Store-UI">disablePropertiesIn: aMenu	(aMenu atNameKey: #repositoryProperties) disable</body><body package="Store-UI">disableRepositoryItemsIn: aMenu	#(		repositoryPublishedItems repositoryPublishedItemsWithFilter		repositoryMoreRecentlyPublishedItems repositoryMoreRecentlyPublishedItemsWithFilter		repositoryProperties	) do: [:each |		(aMenu atNameKey: each) disable	]</body><body package="Store-UI">menuButtonImage	^UI.Skins.SkinRegistry current assetComponentForActionMenu</body><body package="Store-UI">repositoryListMenu	| menu repositories currentlyConnected |	menu := Menu new.	repositories := RepositoryManager repositories asSortedCollection: [ :a :b | (a name ifNil: [ '' ]) &lt; (b name ifNil: [ '' ]) ].	currentlyConnected := DbRegistry connectedProfile.	currentlyConnected ifNotNil: [		(repositories includes: currentlyConnected)			ifFalse: [ menu addItem: (self createConnectOrDisconnectItemFor: currentlyConnected); addLine ]	].	repositories do: [ :each | menu addItem: (self createConnectOrDisconnectItemFor: each) ].	repositories isEmpty ifFalse: [menu addLine].	menu addItem: self createConnectToNewItem.	self repositoryMenu allMenuItemGroups do: [ :group | menu addItemGroup: group ].	^menu</body><body package="Store-UI">repositoryMenu	| menu |	menu := self class repositoryMenu.	self isConnected 		ifFalse: [ self disableRepositoryItemsIn: menu ]		ifTrue: [ self isConnectedProfileRegistered ifFalse: [ self disablePropertiesIn: menu ] ].	^menu</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	"Hack to enable loading."	DbRegistry ifNotNil: [ DbRegistry connectedProfileHolder onChangeSend: #connectedProfileChanged to: self ]</body><body package="Store-UI">postBuildWith: aBuilder 	self installLabelController.	self updateRepositoryLabel.</body><body package="Store-UI">release	super release.	(DbRegistry notNil and: [DbRegistry connectedProfileHolder notNil])		ifTrue: [DbRegistry connectedProfileHolder retractInterestsFor: self ]</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>notifications</category><body package="Store-UI">connectedProfileChanged	self updateRepositoryLabel</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>fileIn/Out</category><body package="Store-UI">prerequisitesForLoading	^(super prerequisitesForLoading)		add: DBAccess;		yourself</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>class initialization</category><body package="Store-UI">initialize	"Hack to enable loading into a fresh image."		VisualLauncher allInstances do: [ :each | each updateStatusBar ]</body></methods><methods><class-id>Store.Glorp.StoreCodeModel</class-id> <category>navigator accessing</category><body package="StoreForGlorpBrowserUI">binding	^self state ifNotNil: #binding</body><body package="StoreForGlorpBrowserUI">navigatorStateClass	^StoreForGlorpNavigatorState</body><body package="StoreForGlorpBrowserUI">selector	"A selector from StoreForGlorpNavigatorState is always a String"	^self state ifNotNil: [:object | object selector ifNotNil: [:value | value asSymbol]]</body></methods><methods><class-id>Store.Glorp.StoreCodeModel</class-id> <category>aspects</category><body package="StoreForGlorpBrowserUI">mainView	^self newTabbedTools</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>actions</category><body package="Store-UI">askToReinitializeSharedVariable: aVariableBinding		^ReInitializeSharedVariableNotification raiseRequestWith: aVariableBinding</body><body package="Store-UI">compareSelectionWith	| shared target |	shared := self itemsInList selections first.	target := shared class selectStoreVersionOf: shared name in: shared package session.	target ifNotNil: [TextDifferenceBrowser compare: shared definitionString with: target definitionString]</body><body package="Store-UI">compareVersions	| class target |	class := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	TextDifferenceBrowser compare: class definitionString with: target definitionString</body><body package="Store-UI">containingPackages	| shared packages |	shared := self itemsInList selections first.	[(Gathering for: shared name) started.	packages := StoreSharedVariableInPackage allPackagesContaining: shared.	(Gathering for: shared name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: shared longNameFromSmalltalk</body><body package="Store-UI">fileOut	| shared fileName fileManager |	shared := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (shared longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: shared package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			shared fileOutOn: fileManager]				ensure: [fileManager close].			(FilingOut for: shared package) finished].</body><body package="Store-UI">loadShared	| package shared |	shared := self itemsInList selections first.	package := shared package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: 					[shared loadSource.					shared definition correspondingImageBinding ifNotNil: 						[:value | 						(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]].			(Loading for: package) finished].</body><body package="Store-UI">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText emphasis: #bold.				updateText nextPutAll: each longName.				updateText emphasis: #none.				updateText cr.				updateText nextPutAll: each definition definitionString.				updateText cr.				updateText cr.				updateText emphasis: (Array with: #color-&gt; ColorValue navy).				updateText nextPutAll: each definition comment.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>menu</category><body package="Store-UI">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection definition owner notNil]</body><body package="Store-UI">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>interface opening</category><body package="Store-UI">compositeViewUsing: aShared nameSize: longestName longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView	| iconPart currentStart nameLabel timestampLabel mainThing usernameLabel packageNameLabel |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aShared toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aShared longNameFromSmalltalk asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	timestampLabel := Label with: aShared definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aShared definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: aShared package name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestTimestamp := longestUsername :=  0.	items do:		[:each | 		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestName := (Label with: each longNameFromSmalltalk asText allBold attributes: widget textStyle) width max: longestName].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].		widget tooltip: nil</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>accessing</category><body package="Store-UI">listTitle		self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title</body><body package="Store-UI">title		^title ifNil: [#VersionsOfShared1s &lt;&lt; #store &gt;&gt; 'Versions of shared &lt;1s&gt;' expandMacrosWith: self itemsInList list first name]</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">leftSharedVariable: aSharedVariableBlueprint rightSharedVariable: bSharedVariableBlueprint	leftBlueprint := aSharedVariableBlueprint.	rightBlueprint := bSharedVariableBlueprint.	self populate</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison">categoryComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons moveCategory;		add: (self italicizedText: 'Category');		add: 'changed from';		add: leftBlueprint category asText allBold;		add: 'to';		add: rightBlueprint category asText allBold;		yourself</body><body package="Store-Code Comparison">categorySingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons moveCategory);		add: (self italicizedText: 'Category');		add: self singularBlueprint category asText allBold;		yourself</body><body package="Store-Code Comparison">initializerComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modify		name: 'Initializer'		leftText: leftBlueprint initializer		rightText: rightBlueprint initializer</body><body package="Store-Code Comparison">initializerSingularRow	^self singularBlueprint initializer size isZero		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self isAddition						ifTrue: [ComparisonIcons add]						ifFalse: [ComparisonIcons remove])				name: 'Initializer'				text: self singularBlueprint initializer]</body><body package="Store-Code Comparison">isConstantComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifyIsConstant;		add: (self italicizedText: 'Constant');		add: 'changed from';		add: leftBlueprint isConstant toolListIcon;		add: 'to';		add: rightBlueprint isConstant toolListIcon;		yourself</body><body package="Store-Code Comparison">isConstantSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons modifyIsConstant);		add: (self italicizedText: 'Constant');		add: self singularBlueprint isConstant toolListIcon;		yourself</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison">defaultIcon	^BehaviorIcons SharedVariableOverlay</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison">bindingTest	^#isForGeneral</body><body package="Store-Code Comparison">objectHeaderName	| parts |	parts := self objectReference path last: 2.	^parts first , '.' , parts last</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison">versionListPaneClass	^Store.Glorp.SharedVariableListPane</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>testing</category><body package="Store-Database Model">definesClass: aStoreClass	^self containedItems anySatisfy: 		[:each | each definesClass: aStoreClass]</body><body package="Store-Database Model">definesObject: aStoreNameSpace	^self containedItems anySatisfy: 		[:each | each definesObject: aStoreNameSpace]</body><body package="Store-Database Model">definesSelector: aSymbol forClass: aClass		^self		includesSelector: aSymbol		className: aClass absoluteName asClassNameOnly		meta: aClass isMeta</body><body package="StoreForGlorpVWUI">describesBundleNamed: aString	"Copied from Store.BundleDescription"	"Answer true if the description refers to a bundle named aString"	^self name = aString</body><body package="StoreForGlorpVWUI">describesSameAs:  aComponentDescr	"Copied from Store.BundleDescription"	"Answer true if aComponentDescr refers to	a bundle named the same as my bundle"	^aComponentDescr isBundle		and: [ self describesBundleNamed: aComponentDescr name ].</body><body package="Store-Database Model">hasRelatedParcel	^false</body><body package="Store-Database Model">hasRelatedParcelIn: aSession	^false</body><body package="StoreForGlorpVWUI">hasValidLoadOrder	^true</body><body package="Store-Database Model">includesSelector: aSelector className: aClassName meta: isMeta	^self containedItems anySatisfy: [:each |		each includesSelector: aSelector className: aClassName meta: isMeta].</body><body package="Store-Database Model">isBundle	^true.</body><body package="Store-Database Model">isPublishedBinary	^false</body><body package="Store-Database Model">isValid	self bundles do: [:each | each isValid ifFalse: [^false]].	self packages do: [:each | each isValid ifFalse: [^false]].	^true.</body><body package="Store-Database Model">isValidAsNew	"Return true if we are valid as a newly created pundle. This is the same as normal validation, but short-circuits if we already have a primary key, meaning that we're not actually new. So validating e.g. a new bundle, but which contains references to old packages, won't need to revalidate the packages. This assumes that they have already been validated"	self bundles do: [:each | each isValidAsNew ifFalse: [^false]].	self packages do: [:each | each isValidAsNew ifFalse: [^false]].	^true.</body><body package="StoreForGlorpVWUI">needsLoadOrderWarning	^false</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>accessing</category><body package="Store-Database Model">addFile: aFileModel	| file |	file := StoreFile fromFileRecord: aFileModel.	file updateUserAndTimestampFrom: self.	^self files add: file</body><body package="Store-Database Model">allContainedItems	| all |	all := OrderedCollection new.	self containedItems do: [:each |		all add: each.		all addAll: each allContainedItems].	^all.</body><body package="Store-Database Model">allItems	^self allContainedItems</body><body package="Store-Database Model">basicComment	^comment</body><body package="Store-Database Model">bundles	^bundles.</body><body package="Store-Code Comparison">classBlueprints	^Array new</body><body package="Store-Database Model">containedItems	| items |	items := self pundles.	^items keys asSortedCollection asOrderedCollection collect: [:index | items at: index].</body><body package="StoreForGlorpVWUI">dbContent	"So that Bundle can initialize itself from us"	^(((bundles associations asArray, packages associations asArray) asSortedCollection: [:x :y | x key &lt; y key]) 		collect: [:each | each value]) asList.</body><body package="Store-Database Model">definedClasses	^self containedItems inject: #() into: [:sum :each |		sum, each definedClasses asArray].</body><body package="StoreForGlorpVWUI">descriptionClass	^Store.BundleDescription</body><body package="StoreForGlorpVWUI">enclosingBundlesFor: aStorePundle	| target |	target := self containedItems 		detect: [:each | each name = aStorePundle name]		ifNone: [nil].	target ifNotNil: [^Array with: self].	self bundles do:		[:each |		(each enclosingBundlesFor: aStorePundle) ifNotNil: [:value | ^value]].	^nil</body><body package="Store-Database Model">fileDescriptions	^self files.</body><body package="Store-Database Model">files	files isNil ifTrue: [files := #()].	^files.</body><body package="Store-Database Model">files: aCollection	files := aCollection.</body><body package="Store-Database Model">itemCount	^(bundles inject: 0 into: [:sum :each | sum + each itemCount])		+  (packages inject: 0 into: [:sum :each | sum + each itemCount]).</body><body package="Store-Code Comparison">methodBlueprints	^Array new</body><body package="Store-Database Model">methods	^self containedItems inject: (OrderedCollection new: 500) into: [:sum :each |		sum addAll: (each methods yourSelf collect: [:eachMethod | eachMethod yourSelf]). sum].</body><body package="Store-Database Model">nameSpaces	^self containedItems inject: #() into: [:sum :each |		sum, each nameSpaces].</body><body package="Store-Code Comparison">namespaceBlueprints	^Array new</body><body package="Store-Database Model">packages	^packages.</body><body package="Store-Difference Management">pseudoPundleClass	^Store.PseudoBundle</body><body package="Store-Database Model">pundles	| pundles |	pundles := Dictionary new.	bundles keysAndValuesDo: [:eachKey :eachValue | pundles at: eachKey put: eachValue].	packages keysAndValuesDo: [:eachKey :eachValue | pundles at: eachKey put: eachValue].	^pundles</body><body package="Store-Code Comparison">sharedVariableBlueprints	^Array new</body><body package="Store-Database Model">sharedVariables	^self containedItems inject: #() into: [:sum :each |		sum, each sharedVariables].</body><body package="Store-Database Model">structure	"Answer an array that reflects the receiver's contents in the form:		#( #( #package name ) #( #bundle name ) .... )"	| answer |	answer := OrderedCollection new.	self componentsInOrderDo: [:eachPundle | 		eachPundle isPackage			ifTrue: [answer add: (Array with: #package with: eachPundle name)]			ifFalse: [answer add: (Array with: #bundle with: eachPundle name)]].	^answer asArray.</body><body package="Store-Database Model">withAllItems	^super withAllItems, self allContainedItems</body><body package="Store-Database Model">withContainedItems	^self containedItems addFirst: self; yourself</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>reconciling</category><body package="Store-Database Model">matchesRecursivelyWith: aStorePundle	"Return true if all of our contents match"	(self ifMatchesWith: aStorePundle do: [^true] else: [^false]).	self bundles size = aStorePundle bundles size ifFalse: [^false].	self packages size = aStorePundle packages size ifFalse: [^false].	self bundles asSortedCollection with: aStorePundle bundles asSortedCollection do: [:ours :theirs |		(ours matchesRecursivelyWith: theirs) ifFalse: [^false]].	self packages asSortedCollection with: aStorePundle packages asSortedCollection do: [:ours :theirs |		(ours matchesRecursivelyWith: theirs) ifFalse: [^false]].	^true.</body><body package="Store-Database Model">matchesWith: aStorePundle	"Return true if all of our contents match"	(self ifMatchesWith: aStorePundle do: [^true] else: [^false]).	self bundles asSortedCollection = aStorePundle bundles asSortedCollection ifFalse: [^false].	self packages asSortedCollection = aStorePundle packages asSortedCollection ifFalse: [^false].	^true.</body><body package="Store-Database Model">reconcile	"When we share source with our previous version, use it instead of our own"	super reconcile.	self reconcileBundles.	self reconcilePackages.	self reconcileFiles.</body><body package="Store-Database Model">reconcileBundle: aStoreBundle	^self previous bundles detect: [:each |		aStoreBundle reconcilesWith: each] ifNone: [aStoreBundle].</body><body package="Store-Database Model">reconcileBundles	| newBundles |	newBundles := Dictionary new.	bundles		keysAndValuesDo:			[:eachKey :eachValue | newBundles at: eachKey put: (self reconcileBundle: eachValue)].	bundles := newBundles.	bundles do: [:each | 		each username isNil ifTrue: [each username: username].		each timestamp isNil ifTrue: [each timestamp: timestamp]].</body><body package="Store-Database Model">reconcileFile: aStoreFile	^self previous files detect: [:each |		aStoreFile reconcilesWith: each] ifNone: [aStoreFile].</body><body package="Store-Database Model">reconcileFiles	files := self files collect: [:each | self reconcileFile: each].	files do: [:each | 		each username isNil ifTrue: [each username: username].		each timestamp isNil ifTrue: 			[each timestamp: timestamp.			each privateSetPrimaryKey: nil]].</body><body package="Store-Database Model">reconcilePackage: aStorePackage	^self previous packages detect: [:each |		aStorePackage reconcilesWith: each] ifNone: [aStorePackage].</body><body package="Store-Database Model">reconcilePackages	| newPackages |	newPackages := Dictionary new.	packages keysAndValuesDo: [:eachKey :eachValue |		newPackages at: eachKey put: (self reconcilePackage: eachValue)].	packages := newPackages.	packages do: [:each | 		each username isNil ifTrue: [each username: username].		each timestamp isNil ifTrue: [each timestamp: timestamp]].</body><body package="Store-Database Model">uninstantiateSubcomponentProxies	"This conserves memory when doing a large iteration by allowing subcomponents to be garbage collected."	self bundles isGlorpProxy ifTrue: [self bundles uninstantiate].	self packages isGlorpProxy ifTrue: [self packages uninstantiate].</body><body package="Store-Database Model">unreconcile	super unreconcile.	self files do: [:each | each unreconcile].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize	super initialize.	bundles := Dictionary new.	packages := Dictionary new.		files := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>deleting</category><body package="Store-Database Model">delete	"Delete this bundle from the database, and delete all of this packages and sub-bundles associated with it "	| components |	components := self pundles.	self session delete: self.	components do: [:each |		| containing |		containing := session count: StoreBundle where: [:eachContainer |			(each isBundle ifTrue: [eachContainer bundles] ifFalse: [eachContainer packages])				anySatisfy: [:eachSubComponent | eachSubComponent value = each]].		containing = 0 ifTrue: [each delete]]</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>enumerating</category><body package="Store-Database Model">allComponentsDo: aBlock	packages do: aBlock.	bundles do: [:each | 		"ugh. Tolerate malformed bundles from very old Store versions."		each isNil ifFalse: [each allComponentsDo: aBlock]].	aBlock value: self.</body><body package="Store-Database Model">componentsDetect: aBlock ifNone: missingBlock	| valueInSubBundle |	bundles do: [:eachBundle |		(aBlock value: eachBundle) ifTrue: [^eachBundle].		valueInSubBundle := eachBundle componentsDetect: aBlock ifNone: [nil].		valueInSubBundle isNil ifFalse: [^valueInSubBundle]].	packages do: [:eachPackage |		(aBlock value: eachPackage) ifTrue: [^eachPackage]].	^missingBlock value.</body><body package="Store-Database Model">componentsDo: aBlock	bundles do: aBlock.	packages do: aBlock.</body><body package="Store-Database Model">componentsInOrderDo: aBlock	| keys |	keys := OrderedCollection new addAll: bundles keys; addAll: packages keys; yourself.	keys asSortedCollection do: [:eachKey |		aBlock value: (bundles at: eachKey ifAbsent: [packages at: eachKey])].</body><body package="Store-Database Model">newComponentsDo: aBlock 	"Loop over all our sub-components, but only those which are instantiated and new - that is, have no primary key"	(bundles isGlorpProxy not or: [bundles isInstantiated]) 		ifTrue: 			[bundles do: 					[:each | 					((each isGlorpProxy not or: [each isInstantiated]) 						and: [each primaryKey isNil]) ifTrue: [aBlock value: each]]].	(packages isGlorpProxy not or: [packages isInstantiated]) 		ifTrue: 			[packages do: 					[:each | 					((each isGlorpProxy not or: [each isInstantiated]) 						and: [each primaryKey isNil]) ifTrue: [aBlock value: each]]].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>store faking</category><body package="Store-Publishing Support">asPundleWithComponentDescriptions	"Return a copy of ourselves that has actual store component descriptions instead of our entities. Used in e.g. initializeFromDB: to let Store put things back the way it thinks things ought to be, and not old onto any of our entities. This copy really won't work at all for most purposes. The bundles and packages aren't even going to be dictionaries"	| copy |	copy := self copy.	copy privateSetBundles: #().	copy privateSetPackages: (self pundles collect: [:each | each asComponentDescriptionForReal]).	copy privateSetFiles: (self files collect: [:each | each asComponentDescriptionForReal]).	^copy.</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>fixups</category><body package="Store-Database Model">removeDuplicates	"Don't bother removing duplicates if we've already got a primary key. That is, we're already in the database"	self primaryKey isNil ifFalse: [^self].	self bundles do: [:each | each removeDuplicates].	self packages do: [:each | each removeDuplicates].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>private</category><body package="StoreForGlorpVWUI">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^aTag isComponentTag		ifTrue: [ aTag recordForPackage: self ].</body><body package="Store-Database Model">privateSetBundles: aDictionary	bundles := aDictionary.</body><body package="Store-Database Model">privateSetFiles: aCollection	files := aCollection.</body><body package="Store-Database Model">privateSetPackages: aDictionary	packages := aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>loading</category><body package="StoreForGlorpVWUI">dbLoadWithin: aBundle	"We are being told to load within the context of a Store.Bundle. Turn ourselves into an appropriate Store entity and do what it would do in these circumstances"	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource).	self loadSource</body><body package="Store-Database Model">directCompileAndLoad	| bundleModel |	(Loading for: self) started.	Parcel withFileCachesDo: 		[(self preCompileWith: nil) ifFalse: 			[(Loading for: self) finished.			^nil].		(self getImagePundle isNil) ifTrue: 			[self runPreRead ifFalse: 				[(Loading for: self) finished.				^nil]].		bundleModel := self createImagePundle.		self storeModel: bundleModel.		self componentsInOrderDo: 			[:each | each directCompileAndLoad].		self postLoad: bundleModel.		self resetStoreModel.		bundleModel cleanse: false.		self applyPundleVersionsToTheImage: true.		bundleModel markNotModified].	(Loading for: self) finished.	^bundleModel</body><body package="Store-Database Model">downloadFiles		| allFiles |	allFiles := self files copy.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	(DownloadingFiles for: self) started.	Store.Policies filePolicy downloadFiles: allFiles.	(DownloadingFiles for: self) finished</body><body package="Store-Database Model">downloadFilesUsing: aBundleCompilationResult		| allFiles |	allFiles := self files copy.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	Store.Policies filePolicy downloadFiles: allFiles using: aBundleCompilationResult</body><body package="Store-Database Model">postLoad: aPundleModel	super postLoad: aPundleModel.	self downloadFiles.</body><body package="Store-Database Model">postLoad: aPundleModel using: aBundleCompilationResult 	super postLoad: aPundleModel.	self downloadFilesUsing: aBundleCompilationResult.	aPundleModel cleanUpOverrides.	aPundleModel markNotModified</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>constants</category><body package="Store-Database Model">componentType	^#bundle</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	| newBundles newPackages |	super postCopyIn: aDictionary.	newBundles := Dictionary new: bundles size.	bundles keysAndValuesDo:  [:eachKey :eachValue | newBundles at: eachKey put: (eachValue glorpCopyIn: aDictionary)].	newPackages := Dictionary new: packages size.	"Note that we don't copy the packages. This is to stop us from prematurely instantiating and copying package versions from the database that we don't need to touch.  When replicating, we will figure out if we want to use a corresponding version from the database - see ReplicatingPundleWriter&gt;&gt;pundleVersionToUseFor:withPreviousParentVersion: in StoreForGlorpReplication."	packages keysAndValuesDo:  [:eachKey :eachValue | newPackages at: eachKey put: eachValue].	bundles := newBundles.	packages := newPackages.	files := files collect: [:each | each glorpCopyIn: aDictionary].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>printing</category><body package="Store-Database Model">describeContents	| stream |	stream := WriteStream on: String new.	self describeContentsOn: stream level: 0.	^stream contents</body><body package="StoreForGlorpVWUI">describeContentsOn: aStream level: anInteger		self containedItems do:		[:each | 		anInteger timesRepeat: [aStream tab].		aStream			nextPutAll: (each stringKey: #());			cr.		each isBundle ifTrue: [each describeContentsOn: aStream level: anInteger + 1]]</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>full classes</category><body package="Store-Database Model">fullClasses	"We can't just gather up my sub component items, because there may be (multiple) extension methods	So what we do, is we we create our own dictionary and fill or combine as needed, careful to copy	things since each sub package keeps its own dictionary of items we don't want to munge"	^fullClasses ifNil: [fullClasses := self generateFullClasses].</body><body package="Store-Database Model">fullClassesDetect: aBlock ifFound: foundBlock	self fullClasses detect: aBlock ifFound: foundBlock</body><body package="Store-Database Model">generateFullClasses	"We can't just gather up my sub component items, because there may be (multiple) extension methods	So what we do, is we we create our own dictionary and fill or combine as needed, careful to copy	things since each sub package keeps its own dictionary of items we don't want to munge"	| gatheredClasses |	gatheredClasses := Dictionary new.	self containedItems do: 		[:each |		each fullClasses keysAndValuesDo: 			[:key :value |			| currentClass |			currentClass := gatheredClasses at: key ifAbsent: [nil].			currentClass isNil				ifTrue: [gatheredClasses at: key put: value copy]				ifFalse: [currentClass addAllFrom: value]]].	^gatheredClasses</body><body package="Store-Database Model">nameSpacesDetect: aBlock ifFound: foundBlock	self containedItems do: [:each | each nameSpacesDetect: aBlock ifFound: foundBlock]</body><body package="Store-Database Model">resetFullClasses	self containedItems do: [:each | each resetFullClasses].</body><body package="Store-Database Model">sharedVariablesDetect: aBlock ifFound: foundBlock	self containedItems do: [:each | each sharedVariablesDetect: aBlock ifFound: foundBlock]</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>compatibility</category><body package="Store-Database Model">definesName: aSymbol in: aNameSpace	"Bundles don't define stuff as such"	^false</body><body package="Store-Database Model">descriptionsAndLevels	"Answer a list of pairs. The first element contains a descriptions the second the 	level on which the description was found. This should be in the order that the components occur within the bundle."	| descriptionsAndLevels items |	items := self pundles.	descriptionsAndLevels := OrderedCollection new.	items keys asSortedCollection do: [:index | | pundle |		pundle := items at: index. 		descriptionsAndLevels add: (Array with: pundle with: 1).		pundle isBundle 			ifTrue: [								descriptionsAndLevels addAll: (pundle descriptionsAndLevels 					collect: [:eachArray | Array with: eachArray first with: eachArray last + 1])]].	^descriptionsAndLevels.</body><body package="StoreForGlorpVWUI">fileContent	"So that Bundle can initialize itself from us"	^self files.</body><body package="StoreForGlorpVWUI">leafItems	| items |	items := OrderedCollection new.	self allComponentsDo: [:each |		each isPackage ifTrue: [items add: each]].	^items.</body><body package="StoreForGlorpVWUI">setName</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>private-file out</category><body package="StoreForGlorpVWUI">fileOutOn: aFileManager	"File out the bundle on aFileManager"	self		fileOutOn: aFileManager		withoutRepeatingAnyOf: Set new</body><body package="StoreForGlorpVWUI">fileOutOn: aSourceCodeStream withoutRepeatingAnyOf: aSet	"File out bundle on aFileManager"		(aSet includes: self) ifTrue: [^self].	aSourceCodeStream createdComponent: self.	aSourceCodeStream cr.	aSourceCodeStream addComment: (#Bundle1s &lt;&lt; #packages &gt;&gt; 'Bundle &lt;1s&gt;' expandMacrosWith: self itemString).	(UI.UISettings preferenceFor: #fileoutOption) == #never ifFalse: [self fileOutPropertiesOn: aSourceCodeStream].	self containedItems do:		[:each | 		each fileOutOn: aSourceCodeStream withoutRepeatingAnyOf: aSet.		aSet add: each].	aSourceCodeStream bundleStructure: self</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>comparing</category><body package="Store-Database Model">computeDifferencesBetween: aBundle into: aComparitor	"A bundle does not compare itself for class/namespace/shared/methods differences"	^self</body><body package="StoreForGlorpVWUI">computeDiffsBetween: aBundle into: aComparitor	| other |	other := (aBundle class = self class or: [aBundle pseudoPackage])		ifTrue: [aBundle] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aBundle primaryKey]].	^other computeDiffsBetweenDBBundle: self into: aComparitor</body><body package="StoreForGlorpVWUI">computeDiffsBetweenDBBundle: aDBBundle into: aComparitor	"Store  differences between receiver and a aDBPackage into an instance of 	PackageDifferences. Store receiver's definitions as number2 since this method	is called with arguments reversed. "	| myPackages his other otherBundle |	otherBundle := aDBBundle class = self class 		ifTrue: [aDBBundle] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aDBBundle primaryKey]].			myPackages := self leafItems.	his := otherBundle leafItems.	myPackages do: [:each |		other := his detect: [:eachOtherPackage | eachOtherPackage name = each name] ifNone: [nil].		each computeDiffsBetweenDBPackage: other into: aComparitor.		other ifNotNil: [his remove: other]].	his do: [:each |		each computeDiffsBetweenDBPackage: nil into: aComparitor].</body><body package="Store-Database Model">containedBundleDifferencesWith: anotherStoreBundle	| keys query1 query2  union |	keys := Array with: self primaryKey with: anotherStoreBundle primaryKey.	query1 := Query read: StoreBundleInBundle  		where: [:each |   |subQuery |      			subQuery := Query read: StoreBundleInBundle where: [:foo |       				foo bundleRef = keys last].   			subQuery retrieve: [:x | x subbundleRef].       			(each bundleRef = keys first)           			&amp; ((each subbundleRef) notIn: subQuery)].	query1 alsoFetch: [:each| each containingBundle].	query1 alsoFetch: [:each| each subbundle].	query2 := Query read: StoreBundleInBundle  		where: [:each |   |subQuery |      			subQuery := Query read: StoreBundleInBundle where: [:foo |       				foo bundleRef = keys first].   			subQuery retrieve: [:x | x subbundleRef].       			(each bundleRef = keys last)           			&amp; ((each subbundleRef) notIn: subQuery)].	query2 alsoFetch: [:each| each containingBundle].	query2 alsoFetch: [:each| each subbundle].	union := query1 unionAll: query2.	union requiresDistinct: false.	^session execute: union.</body><body package="Store-Publishing Support">descriptionAndLevels: aCollection level: anInteger		self containedItems do:		[:each | 		aCollection add: (Array with: each with: anInteger).		each isBundle ifTrue: [each descriptionAndLevels: aCollection level: anInteger + 1]].	^aCollection</body><body package="Store-Publishing Support">uniqueItemsAndLevels	"Answer a colleciton of description level pairs"	| collection |	collection := OrderedCollection new.	self descriptionAndLevels: collection level: 1.	^collection</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>utilities</category><body package="Store-Database Model">allVersionPrimaryKeysWithFile: aStoreFile	^self class allVersionPrimaryKeysWithFile: aStoreFile in: session</body><body package="Store-Database Model">sharesFile: aStoreFile	"Answer back a Boolean if another Bundle shares the passed in StoreFile"	^self class sharesFile: aStoreFile in: session</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">defaultCompileManagerClass	^ShadowBundleCompileManager</body><body package="Glorp Atomic Compiling">newDefaultCompileManagerWith: aCompilationManager	^self defaultCompileManagerClass newForPundle: self with: aCompilationManager</body><body package="Glorp Atomic Compiling">preCompileWith: aCompilationManager	"Before we compile the bundle, check all of its contained items to ensure that its 	 prerequisities are met.  If they are, then run any pre-read actions.  Return false	 if any of the pre-read actions fail, of if prerequisites are not satisified.  This has a 	 side-effect of loading only those properties that are needed for loading."	| allItems |	allItems := self withAllUniqueItems.	^allItems allSatisfy: [:each | each checkPrerequisitesWithin: self with: aCompilationManager]</body><body package="Glorp Atomic Compiling">pundleInstallClass	^BundleInstall</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>converting</category><body package="Store-Publishing Support">minimizeFootprintInImage	super minimizeFootprintInImage.	self privateUninstantiate</body><body package="StoreForGlorpVWUI">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"	^aTag copy		package: self; 		yourself</body><body package="StoreForGlorpVWUI">recordForTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there."		aTag isComponentTag ifTrue: [^aTag recordForPackage: self].	self leafItems do:		[:each | 		| tagOrStoreObjectInPackage |		(tagOrStoreObjectInPackage := each recordForTag: aTag) ifNotNil: [^tagOrStoreObjectInPackage]].	^nil</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>constants</category><body package="StoreForGlorpVWUI">imageClass	^Store.BundleModel</body><body package="Store-Database Model">propertyTypeCode	^0.</body><body package="Store-Database Model">typeStringForBlessing	^'B'</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>testing</category><body package="Store-Database Model">isBundle	^true.</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>accessing</category><body package="Store-Database Model">enclosingComponentsFor: aStorePundle in: aSession	| queryBlock query |	queryBlock := aStorePundle isBundle		ifTrue: [ [:each | each bundles anySatisfy: [:eachPundle | eachPundle = aStorePundle]]]		ifFalse: [ [:each | each packages anySatisfy: [:eachPundle | eachPundle = aStorePundle]]].	query := Query read: self where: queryBlock.	query orderBy: [:each| each timestamp descending].	^aSession execute: query</body><body package="StoreForGlorpVWUI">toolListIcon	^BehaviorIcons BundleDisconnected</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>query utility</category><body package="Store-Database Model">allVersionPrimaryKeysWithFile: aStoreFile in: aSession	"Answer back all versions of this Bundle that share the passed in File"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each | each files includes: aStoreFile].	query retrieve: [:each | each primaryKey distinct].	^(session execute: query)</body><body package="Store-Database Model">sharesFile: aStoreFile in: aSession	"Answer back all versions of this Bundle that share the passed in File"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query count: self where: [:each | each files includes: aStoreFile].	^(session execute: query) ~= 1</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>comparing</category><body package="Store-Database Model">containedBundleDifferencesBetween: bundleColl1 and: bundleColl2 in: session	| keys1 keys2 query1 query2 union |	keys1 := bundleColl1 collect: [:each| each primaryKey].	keys2 := bundleColl2 collect: [:each| each primaryKey].	query1 := Query read: StoreBundleInBundle  		where: [:each |   |subQuery |      			subQuery := Query read: StoreBundleInBundle where: [:foo |       				foo bundleRef in: keys2].   			subQuery retrieve: [:x | x subbundleRef].       			(each bundleRef in: keys1)           			&amp; ((each subbundleRef) notIn: subQuery)].	query1 alsoFetch: [:each| each containingBundle].	query1 alsoFetch: [:each| each subbundle].	"query1 orderBy: [:ea| ea containingBundle name]."	"query1 orderBy: [:ea| ea sequence]."	query2 := Query read: StoreBundleInBundle  		where: [:each |   |subQuery |      			subQuery := Query read: StoreBundleInBundle where: [:foo |       				foo bundleRef in: keys1].   			subQuery retrieve: [:x | x subbundleRef].       			(each bundleRef in: keys2)           			&amp; ((each subbundleRef) notIn: subQuery)].	query2 alsoFetch: [:each| each containingBundle].	query2 alsoFetch: [:each| each subbundle].	"query2 orderBy: [:ea| ea containingBundle name]."	"query2 orderBy: [:ea| ea sequence]."	union := query1 unionAll: query2.	union requiresDistinct: false.	^session execute: union.</body><body package="Store-Database Model">containedPackageDifferencesBetween: bundleColl1 and: bundleColl2 in: session	| keys1 keys2 query1 query2 union |	keys1 := bundleColl1 collect: [:each| each primaryKey].	keys2 := bundleColl2 collect: [:each| each primaryKey].	query1 := Query read: StorePackageInBundle  		where: [:each |   |subQuery |      			subQuery := Query read: StorePackageInBundle where: [:foo |       				foo bundleRef in: keys2].   			subQuery retrieve: [:x | x packageRef].       			(each bundleRef in: keys1)           			&amp; ((each packageRef) notIn: subQuery)].	query1 alsoFetch: [:each| each containingBundle].	query1 alsoFetch: [:each| each package].	query2 := Query read: StorePackageInBundle  		where: [:each |   |subQuery |      			subQuery := Query read: StorePackageInBundle where: [:foo |       				foo bundleRef in: keys1].   			subQuery retrieve: [:x | x packageRef].       			(each bundleRef in: keys2)           			&amp; ((each packageRef) notIn: subQuery)].	query2 alsoFetch: [:each| each containingBundle].	query2 alsoFetch: [:each| each package].	union := query1 unionAll: query2.	union requiresDistinct: false.	^session execute: union.</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>comparing</category><body package="StoreForGlorpVWUI">asStoreComparisonObjectIn: aSession	^self</body><body package="StoreForGlorpVWUI">computeDifferencesBetween: aPackage into: aComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[aComparitor reverse.	aPackage computeDifferencesBetween: self into: aComparitor]		ensure: [aComparitor reverse].	^aComparitor</body><body package="Store-Component Support">computeDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."	^self computeStoreDiffsBetweenDBPackage: aStorePackage into: aPackageComparitor</body><body package="Store-Component Support">computeDiffsBetween: aPackage into: diffHolder	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[diffHolder reverse.	aPackage computeDiffsBetween: self into: diffHolder]		ensure: [diffHolder reverse].	^diffHolder</body><body package="Store-Component Support">computeDiffsBetweenDBBundle: aStoreBundle into: aComparitor	"I do nothing for a Bundle"</body><body package="Store-Component Support">computeDiffsBetweenDBPackage: aDBPackage into: diffHolder	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."	diffHolder isPackageComparitor ifTrue:		[^self computeStoreDiffsBetweenDBPackage: aDBPackage into: diffHolder].	diffHolder methodsSide: 2 put: OrderedCollection new.	diffHolder methodsSide: 1 put: aDBPackage methods.	diffHolder dataSide: 2 put: OrderedCollection new.	diffHolder dataSide: 1 put: aDBPackage data.	diffHolder classesSide: 2 put: OrderedCollection new.	diffHolder classesSide: 1 put: aDBPackage classes.	diffHolder metaSide: 2 put: OrderedCollection new.	diffHolder metaSide: 1 put: OrderedCollection new. "aDBPackage metaclasses."	diffHolder nameSpacesSide: 2 put: OrderedCollection new.	diffHolder nameSpacesSide: 1 put: aDBPackage nameSpaces.	^diffHolder</body><body package="Store-Difference Management">computePropertyDifferencesBetween: aStorePundle into: aPackageComparitor	^self computePropertyDiffsBetweenDBPundle: aStorePundle into: aPackageComparitor</body><body package="Store-Difference Management">computePropertyDiffsBetweenDBPundle: aStorePackage into: aPackageComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		aPackageComparitor mainPackageProperties: OrderedCollection new.	aPackageComparitor otherPackageProperties: aStorePackage properties associations.	aStorePackage isBundle ifTrue:		[aPackageComparitor otherPackageProperties add: #structure -&gt; aStorePackage structure].	^aPackageComparitor</body><body package="Store-Component Support">computeStoreDiffsBetweenDBPackage: aStorePackage into: aPackageComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."	aPackageComparitor otherPackageMethods: (OrderedCollection new).	aPackageComparitor mainPackageMethods: (aStorePackage methods collect: [:each | each definition]).	aPackageComparitor otherPackageShareds: (OrderedCollection new).	aPackageComparitor mainPackageShareds: (aStorePackage sharedVariables collect: [:each | each definition]).	aPackageComparitor otherPackageNamespaces: (OrderedCollection new).	aPackageComparitor mainPackageNamespaces: (aStorePackage nameSpaces collect: [:each | each definition]).	aPackageComparitor otherPackageClasses: (OrderedCollection new).	aPackageComparitor mainPackageClasses: (aStorePackage classes collect: [:each | each definition]).	^aPackageComparitor</body><body package="Store-Component Support">sameAs: aPackage	^false</body><body package="Store-Component Support">sameVersionAs: aPackage	^false.</body><body package="Store-Component Support">sameVersionAsLoadedPundle: aPundle	^false</body><body package="Store-Component Support">sameVersionAsPublished: aPundle	^false</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>accessing</category><body package="Store-Component Support">allClasses	^#()</body><body package="Store-Component Support">allDatabases	^#()</body><body package="Store-Component Support">allNameSpaces	^#()</body><body package="Store-Component Support">classesAndNameSpacesFromChanges: changeSet meta: isMeta	^self classesNamed: 		( changeSet keys collect: [ :key | key asString ] )</body><body package="Store-Component Support">classesDefinedInPackage	^#()</body><body package="Store-Component Support">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassRecord"	"sorts a list of nils..."	^(aSetOfNames collect: [:aName| self classInPackageNamed: aName])			asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-Component Support">classesNamed: aSetOfNames meta: aBoolean	"Convert aSetOfnames into a collection of ClassRecords"	^( aSetOfNames collect: 		[ :aName | self classInPackageNamed: aName meta: aBoolean ]	) asSortedCollection: [ :x :y | x name &lt; y name ]</body><body package="Store-Component Support">classesWithSource	"For image model, same as defined classes."	^self classesDefinedInPackage.</body><body package="Store-Component Support">classInPackageNamed: cName 	"See if the class is new and answer nil or the class descriptor."	^nil</body><body package="Store-Component Support">classInPackageNamed: cName meta: isMeta	"See if the class is new and answer nil or the class descriptor."	^nil</body><body package="Store-Component Support">data	^#()</body><body package="Store-Component Support">dataWithSource	"For the image model this is the same as data."	^self data.</body><body package="Store-Component Support">datum: dataKey forNamed: aFullName	^nil</body><body package="Store-Component Support">datum: dataKey forOwnerNamed: cName 	^nil</body><body package="Store-Component Support">dbTrace	^nil</body><body package="Store-Component Support">hasTrace 	^false</body><body package="Store-Component Support">isLoaded 	^true</body><body package="Store-Component Support">itemCount	"Answer a count of work to be done. Not much."	^realPackage == nil		ifTrue: [ 1 ]		ifFalse: [ realPackage itemCount ]</body><body package="StoreForGlorpVWUI">itemString	^self name</body><body package="Store-Component Support">method: aSelector forClassNamed: cName meta: isMeta 	^nil</body><body package="Store-Component Support">methods	^#()</body><body package="Store-Component Support">methodsForClassNamed: cName	^#()</body><body package="Store-Component Support">methodsWithSource	"For image model same as methods since sources are already loaded."	^self methods.</body><body package="Store-Component Support">name	^realPackage isNil		ifTrue: [(#BracketNoMatchingPackage &lt;&lt; #store &gt;&gt; '[No Matching Package]') asString]		ifFalse: [realPackage name]</body><body package="Store-Component Support">nameSpaceInPackageNamed: aName 	^nil</body><body package="Store-Component Support">nameSpacesDefinedInPackage	^#()</body><body package="Store-Component Support">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassRecord"	"sorts a list of nils...."	^(aSetOfNames collect: [:aName| self classInPackageNamed: aName])			asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-Component Support">nameSpacesWithSource	"For image model same as defined NameSpace."	^self nameSpacesDefinedInPackage.</body><body package="Store-Component Support">primaryKey	^nil</body><body package="Store-Component Support">properties	^IdentityDictionary new.</body><body package="Store-Component Support">propertiesForFileOut	^IdentityDictionary new.</body><body package="Store-Component Support">propertiesForSave	^IdentityDictionary new.</body><body package="Store-Difference Management">propertiesWithoutVolatileKeys	^IdentityDictionary new.</body><body package="Store-Component Support">pseudoPackage	"Answer true since I'm a fake."	^true</body><body package="Store-Component Support">pundleChangesClass	^PackageChanges</body><body package="StoreForGlorpVWUI">session	"This for being compatable with StorePundle objects"	^nil</body><body package="Store-Component Support">shortItemString	^self name</body><body package="StoreForGlorpVWUI">structure	^#()</body><body package="StoreForGlorpVWUI">toolListIcon	^VisualStack with: Store.Glorp.StorePackage toolListIcon with: GeneralIcons deprecationWarning</body><body package="Store-Component Support">version	^'--'</body><body package="Store-Component Support">versionString	^''</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>testing</category><body package="Store-Component Support">includesClassNamed: aName 	^false</body><body package="Store-Component Support">includesDataKey: dataKey ownerName: aName	^false</body><body package="Store-Component Support">includesDatum: datum	^false</body><body package="Store-Component Support">includesMethod: method	^false</body><body package="Store-Component Support">includesNameSpaceNamed: aName 	^false</body><body package="Store-Component Support">isBundle	^realPackage isBundle</body><body package="StoreForGlorpVWUI">isImageModel	^false</body><body package="Store-Component Support">isPackage	^realPackage isPackage</body><body package="StoreForGlorpVWUI">isVersionLoaded	^false</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>private-accessing</category><body package="Store-Component Support">realPackage: aPackage	realPackage := aPackage</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>printing</category><body package="Store-Component Support">fileOutProperties: props on: aFileManager	^self.</body><body package="Store-Component Support">textForItem	^'*****'</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>compatibility</category><body package="Store-Component Support">cleanse: ignored	"Just so I can participate in a REAL Package world cleanly"</body></methods><methods><class-id>Store.PseudoPackage class</class-id> <category>instance-creation</category><body package="Store-Component Support">fromPackage: aPackage		^self new realPackage: aPackage</body></methods><methods><class-id>Store.Glorp.ClassVersionsNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">packageClassesAndNameSpacesFor: packageCollection 	| objects |	packageCollection isEmpty ifTrue: [^nil].	objects := OrderedCollection new.	packageCollection do: 			[:each | 			objects				addAll: (self convertToFullNames: each allClasses asSortedCollection);				addAll: (self convertToFullNames: each allNameSpaces asSortedCollection)].	^objects</body><body package="StoreForGlorpBrowserUI">sortList: aCollection 	^aCollection asList</body></methods><methods><class-id>Store.FileOutClassDoesntExistError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	Dialog warn: (#Class1sNoLongerExists &lt;&lt; #store &gt;&gt; 'Class &lt;1s&gt; no longer exists' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.FileOutClassDoesntExistError class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">failedInitializations	^failedInitializations</body><body package="Atomic Compiling and Loading">failedInitializations: aCollection	failedInitializations := aCollection</body><body package="Atomic Compiling and Loading">installedEarly: aBoolean	installedEarly := aBoolean</body><body package="Atomic Compiling and Loading">pundle	^pundle</body><body package="Atomic Compiling and Loading">pundle: anObject	pundle := anObject</body><body package="Atomic Compiling and Loading">results	^results</body><body package="Atomic Compiling and Loading">results: anObject	results := anObject</body><body package="Atomic Compiling and Loading">resultsFromParent	^nil</body><body package="Atomic Compiling and Loading">root	^root</body><body package="Atomic Compiling and Loading">root: anObject	root := anObject</body><body package="Atomic Compiling and Loading">shadowAt: aPath	^(self root		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body><body package="Atomic Compiling and Loading">shadowCompiler	^shadowCompiler</body><body package="Atomic Compiling and Loading">shadowCompiler: anObject	shadowCompiler := anObject</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isAtomicallyLoadable	^results allSatisfy: [:each | each isAtomicallyLoadable]</body><body package="Atomic Compiling and Loading">isCompilationResult	^true</body><body package="Atomic Compiling and Loading">isFullyLoaded	^results allSatisfy: [:each | each isFullyLoaded].</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>action</category><body package="Atomic Compiling and Loading">addResult: aCodeReaderOrBundleOrPackageCompilationResult	results ifNil: [results := OrderedCollection new].	results add: aCodeReaderOrBundleOrPackageCompilationResult</body><body package="Atomic Compiling and Loading">applyLoadingPolicyAfterLoadError	"Loading errors have occurred. Check out setting AbstractPundleLoader.LoadFailedOption 	and determine how to deal with them.	- #loadButNotify = Complete the load but open a tool to manage errors	- #load = Ignore errors and load what can be loaded	- #displayDialog = Open a dialog to ask what to do		a positive answer must have been given in #proceedToLoad, otherwise we would not arrive here	- #fail = Load only if there are no errors		we cannot arrive here with this option (see senders of #proceedToLoad)"	AbstractPundleLoader loadFailOption = #load ifTrue: [^self].	ViewUnloadableDefinitionsNotification openOnExceptions: self unloadableDefinitionsForBrowsing</body><body package="Atomic Compiling and Loading">atomicCompileAndInstallWith: aCompilationManager	| pundleCompilerManger |	pundleCompilerManger := pundle newDefaultCompileManagerWith: aCompilationManager.	pundleCompilerManger atomicCompileWith: aCompilationManager.	(installedEarly or: [self isAtomicallyLoadable or: [self proceedToLoad]])		ifFalse: 			[LoadCanceled raiseWith: self pundle.			^nil].	(Relinking for: pundle) started.	SystemUtils modifySystem: [self install].	self isFullyLoaded ifFalse: [self retryUnloadables].	self retryFailedInitializations.	self pundle storeModel.	(Relinking for: pundle) finished.	Registry cleanseModels</body><body package="Atomic Compiling and Loading">cleanOverridesAndUnloadedParcels	"Why two sends of #cleanseLists? It is a bug that it needs two passes to make sure all empty overrides are cleared out"	results ifNil: [^self].	results do: [:each | each isCodeReader ifTrue: [each isLoaded ifFalse: [Parcel parcelList remove: (Parcel parcelNamed: each parcelName) ifAbsent: [nil]]]].	Override cleanseLists.	Override cleanseLists</body><body package="Atomic Compiling and Loading">compileAndInstall	(Loading for: pundle) started.	^[self atomicCompileAndInstallWith: self]		ensure: 			[(Loading for: pundle) finished.			self cleanOverridesAndUnloadedParcels]</body><body package="Atomic Compiling and Loading">install	(results allSatisfy: [:each | each isAtomicallyLoadable]) ifFalse: [self notYetImplemented].	results do: [:each | 		[each installed ifFalse: [each install]]			on: LoadingActionError			do: 				[:exception | 				failedInitializations add: exception package.				exception resume: true]].	results do: [:each | each finishInstall].</body><body package="Atomic Compiling and Loading">installEarlyAndReInitialize		SystemUtils modifySystem: [self installWithoutBundlePostLoad].	results do: [:each | each isCodeReader ifFalse: [each markContentsInstalled]].	self retryFailedInitializations.	installedEarly := true.</body><body package="Atomic Compiling and Loading">installEarlyIfNeeded		(self results last basicClasses		allSatisfy: [:eachClass | (eachClass includesBehavior: Scanner) not])		ifTrue: [^self].	self installEarlyAndReInitialize.	self reinitializeShadowRoot.</body><body package="Atomic Compiling and Loading">installEarlyWith: aCompilationManagerOrResult	| parentResults |	self installEarlyAndReInitialize.	(parentResults := aCompilationManagerOrResult resultsFromParent) notNil		ifTrue: 			[parentResults do:				[:each |				each installWithoutPostLoad ifNil: [AtomicLoadingError raiseWith: self pundle].				each markContentsInstalled]]		ifFalse: [aCompilationManagerOrResult markContentsInstalled].	self reinitializeShadowRoot</body><body package="Atomic Compiling and Loading">installWithoutBundlePostLoad	(results allSatisfy: [:each | each isAtomicallyLoadable]) ifFalse: [self notYetImplemented].	results do: [:each | each installedWithoutBundlePostLoad ifFalse: [each installWithoutBundlePostLoad]].</body><body package="Atomic Compiling and Loading">markContentsInstalled	"I do nothing"</body><body package="Atomic Compiling and Loading">markContentsInstalled: aBoolean	"I do nothing"</body><body package="Atomic Compiling and Loading">mergeDeeplyFrom: aShadowEnvironment		aShadowEnvironment keys do: 		[:each | 		(root at: each ifAbsent: [nil]) isNil 			ifTrue: [root at: each put: (aShadowEnvironment at: each)] 			ifFalse:[(root at: each) mergeDeeplyFrom: (aShadowEnvironment at: each)]]</body><body package="Atomic Compiling and Loading">proceedToLoad	"A loading error has occurred. Check out setting AbstractPundleLoader.LoadFailedOption whether to continue loading.	- #loadButNotify = Complete the load but open a tool to manage errors	- #load = Ignore errors and load what can be loaded	- #displayDialog = Open a dialog to ask what to do	- #fail = Load only if there are no errors"	| option |	(option := AtomicLoader loadFailOption) = #fail ifTrue: [^false].	^option = #displayDialog		ifTrue: [Dialog confirm: (#LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?')]		ifFalse: [true]</body><body package="Atomic Compiling and Loading">reinitializeShadowRoot		root := ShadowNameSpaceBuilder new createShadowRoot.	shadowCompiler shadowRoot: root.</body><body package="Atomic Compiling and Loading">retryFailedInitializations	| stillFailed |	stillFailed := OrderedCollection new.	failedInitializations do:		[:each |		[each runPostLoad]			on: Error			do: [:exception | stillFailed add: each]].	failedInitializations := failedInitializations select: [:each | stillFailed includes: each]</body><body package="Atomic Compiling and Loading">retryUnloadables		(self results reject: [:each | each isCodeReader]) do:		[:each | 		self retryUnloadablesFor: each]</body><body package="Atomic Compiling and Loading">retryUnloadablesFor: aCompilationResult	"A bit of recursion... If the result is for bundle, we recurse in until they are for individual packages"	aCompilationResult isForBundle ifTrue: [^aCompilationResult results do: [:each | self retryUnloadablesFor: each]].	aCompilationResult unloadableDefinitions copy do:		[:each | 		| packageModel |		packageModel := each parameter package			ifNil: [aCompilationResult package storeModel]			ifNotNil: [:value | value storeModel].		([each parameter loadSourceInto: packageModel]			on: Error			do: [:exception | exception return]) ifNotNil:				[:value | 				(each parameter isForMethod and: [each parameter isMeta and: [each parameter selector = #initialize]])					ifTrue: [each parameter correspondingImageClass instanceBehavior postLoad: packageModel].				aCompilationResult unloadableDefinitions remove: each]].	aCompilationResult unloadableDefinitions isEmpty ifTrue: [aCompilationResult pundle storeModel markNotModified]</body><body package="Atomic Compiling and Loading">unloadableDefinitionsForBrowsing	"Answer a collection of Unloadable with the package set."	^results inject: OrderedCollection new into: 		[ :collection :res | 		collection addAll: (res unloadableDefinitionsForBrowsing); yourself			].</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>overrides</category><body package="Atomic Compiling and Loading">setOverriddenForClass: anOverridenClass	| workingResults targetResult fullResults |	workingResults := self results reject: [:each | each isCodeReader].	fullResults := OrderedCollection new.	workingResults do: [:each | fullResults addAll: each leafItems].	targetResult := fullResults detect: 		[:each | each hasShadowClassMatching: anOverridenClass actual]		ifNone: [^self].	targetResult overridden add: anOverridenClass.</body><body package="Atomic Compiling and Loading">setOverriddenForMethod: anOverridenMethod 	| workingResults targetResult fullResults |	workingResults := self results reject: [:each | each isCodeReader].	fullResults := OrderedCollection new.	workingResults do: [:each | fullResults addAll: each leafItems].	targetResult := fullResults detect: 		[:each | each hasShadowMethodMatching: anOverridenMethod method]		ifNone: [^self].	targetResult overridden add: anOverridenMethod.</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize	self results: OrderedCollection new;		failedInitializations: OrderedCollection new;		installedEarly: false;		shadowCompiler: ShadowCompiler new;		reinitializeShadowRoot</body></methods><methods><class-id>Store.AtomicCompilationManager class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new	^super new initialize</body><body package="Atomic Compiling and Loading">newForPundle: aPackageOrBundle	^self new		pundle: aPackageOrBundle</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>accessing</category><body package="Store-Code Comparison">addedBundleProperties	^addedBundleProperties</body><body package="Store-Code Comparison">addedBundleProperties: anObject	addedBundleProperties := anObject</body><body package="Store-Code Comparison">addedClasses	^addedClasses</body><body package="Store-Code Comparison">addedClasses: anObject	addedClasses := anObject</body><body package="Store-Code Comparison">addedMethods	^addedMethods</body><body package="Store-Code Comparison">addedMethods: anObject	addedMethods := anObject</body><body package="Store-Code Comparison">addedNamespaces	^addedNamespaces</body><body package="Store-Code Comparison">addedNamespaces: anObject	addedNamespaces := anObject</body><body package="Store-Code Comparison">addedPackageProperties	^addedPackageProperties</body><body package="Store-Code Comparison">addedPackageProperties: anObject	addedPackageProperties := anObject</body><body package="Store-Code Comparison">addedSharedVariables	^addedSharedVariables</body><body package="Store-Code Comparison">addedSharedVariables: anObject	addedSharedVariables := anObject</body><body package="Store-Code Comparison">allClassReferences	^(Set withAll: removedClasses keys)		addAll: addedClasses keys;		addAll: addedMethods keys;		addAll: removedMethods keys;		yourself</body><body package="Store-Code Comparison">allNamespaceReferences	^(Set withAll: removedNamespaces keys)		addAll: addedNamespaces keys;		yourself</body><body package="Store-Code Comparison">allPropertyBundleNames	^(Set withAll: addedBundleProperties keys)		addAll: removedBundleProperties keys;		yourself</body><body package="Store-Code Comparison">allPropertyPackageNames	^(Set withAll: removedPackageProperties keys)		addAll: addedPackageProperties keys;		yourself</body><body package="Store-Code Comparison">allSharedVariableReferences	^(Set withAll: removedSharedVariables keys)		addAll: addedSharedVariables keys;		yourself</body><body package="Store-Code Comparison">leftCodeComponents	^leftCodeComponents</body><body package="Store-Code Comparison">leftCodeComponents: anObject	leftCodeComponents := anObject</body><body package="Store-Code Comparison">removedBundleProperties	^removedBundleProperties</body><body package="Store-Code Comparison">removedBundleProperties: anObject	removedBundleProperties := anObject</body><body package="Store-Code Comparison">removedClasses	^removedClasses</body><body package="Store-Code Comparison">removedClasses: anObject	removedClasses := anObject</body><body package="Store-Code Comparison">removedMethods	^removedMethods</body><body package="Store-Code Comparison">removedMethods: anObject	removedMethods := anObject</body><body package="Store-Code Comparison">removedNamespaces	^removedNamespaces</body><body package="Store-Code Comparison">removedNamespaces: anObject	removedNamespaces := anObject</body><body package="Store-Code Comparison">removedPackageProperties	^removedPackageProperties</body><body package="Store-Code Comparison">removedPackageProperties: anObject	removedPackageProperties := anObject</body><body package="Store-Code Comparison">removedSharedVariables	^removedSharedVariables</body><body package="Store-Code Comparison">removedSharedVariables: anObject	removedSharedVariables := anObject</body><body package="Store-Code Comparison">rightCodeComponents	^rightCodeComponents</body><body package="Store-Code Comparison">rightCodeComponents: anObject	rightCodeComponents := anObject</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>private</category><body package="Store-Code Comparison">allSortedCodeComponents: aSequenceOfCodeComponents	"Given aSequenceOfCodeComponents, return a sequence which includes thos elements, plus any contained packages and bundles in the originals. Return the results in a deterministic sort order."	| coerced expanded flattened withoutDuplicates sorted session |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	coerced := aSequenceOfCodeComponents				collect: [:each | each asStoreComparisonObjectIn: session].	expanded := coerced collect: #withAllContainedItems.	flattened := self flatten: expanded.	withoutDuplicates := Set withAll: flattened.	sorted := withoutDuplicates				sorted: [:a :b | a name = b name ifTrue: [a isBundle] ifFalse: [a name &lt;= b name]].	^sorted</body><body package="Store-Code Comparison">flatten: aSequenceOfSequences	"Given an Collection of nested collections, reduce it to one single linear sequence."	^aSequenceOfSequences inject: Array new into: [:accum :each | accum , each]</body><body package="Store-Code Comparison">select: aDictionary matchesFrom: aCodeComponentCollection	"Given aDictionary whose values are Blueprint objects, return a copy of the Dictionary which contains only Blueprints that are referenced by one of the members of aCodeComponentCollection."	^aDictionary select: 			[:eachBlueprint |			aCodeComponentCollection				anySatisfy: [:eachCodeComponent | eachBlueprint belongsToCodeComponent: eachCodeComponent]]</body><body package="Store-Code Comparison">select: aDictionary sequenceMatchesFrom: aCodeComponentCollection	"Given aDictionary whose values are Arrays of Blueprint objects, return a copy of the Dictionary which contains only Blueprints that are referenced by one of the members of aCodeComponentCollection."	^(aDictionary collect: 			[:eachBlueprintSequence |			eachBlueprintSequence select: 					[:eachBlueprint |					aCodeComponentCollection						anySatisfy: [:eachCodeComponent | eachBlueprint belongsToCodeComponent: eachCodeComponent]]])		reject: #isEmpty</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>initialize-release</category><body package="Store-Code Comparison">cleanseUnchangedComponents	"Remove any of members of leftCodeComponents or rightCodeComponents, for which we have no blueprints referencing them."	| toRemove filterBlock |	toRemove := leftCodeComponents , rightCodeComponents.	filterBlock :=			[:blueprint |			toRemove isEmpty				ifFalse: 					[| matches |					matches := toRemove								select: [:each | blueprint belongsToCodeComponent: each].					toRemove := toRemove reject: [:each | matches includes: each]]].	removedMethods		do: [:eachSequenceOfMethods | eachSequenceOfMethods do: filterBlock].	removedClasses do: filterBlock.	removedNamespaces do: filterBlock.	removedSharedVariables do: filterBlock.	removedPackageProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	removedBundleProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	addedMethods		do: [:eachSequenceOfMethods | eachSequenceOfMethods do: filterBlock].	addedClasses do: filterBlock.	addedNamespaces do: filterBlock.	addedSharedVariables do: filterBlock.	addedPackageProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	addedBundleProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	rightCodeComponents := rightCodeComponents				reject: [:each | toRemove includes: each].	leftCodeComponents := leftCodeComponents				reject: [:each | toRemove includes: each]</body><body package="Store-Code Comparison">cleanseUnmatchedChanges	"Remove all blueprints that don't reference one of the code components found in my leftCodeComponents or rightCodeComponents."	removedSharedVariables := self select: removedSharedVariables				matchesFrom: leftCodeComponents.	addedSharedVariables := self select: addedSharedVariables				matchesFrom: rightCodeComponents.	removedNamespaces := self select: removedNamespaces				matchesFrom: leftCodeComponents.	addedNamespaces := self select: addedNamespaces				matchesFrom: rightCodeComponents.	removedClasses := self select: removedClasses				matchesFrom: leftCodeComponents.	addedClasses := self select: addedClasses matchesFrom: rightCodeComponents.	removedMethods := self select: removedMethods				sequenceMatchesFrom: leftCodeComponents.	addedMethods := self select: addedMethods				sequenceMatchesFrom: rightCodeComponents.	removedPackageProperties := self select: removedPackageProperties				sequenceMatchesFrom: leftCodeComponents.	addedPackageProperties := self select: addedPackageProperties				sequenceMatchesFrom: rightCodeComponents.	removedBundleProperties := self select: removedBundleProperties				sequenceMatchesFrom: leftCodeComponents.	addedBundleProperties := self select: addedBundleProperties				sequenceMatchesFrom: rightCodeComponents</body><body package="Store-Code Comparison">compute	| leftMethods leftProperties rightMethods rightProperties leftSharedVariables rightSharedVariables sharedVariableDiffs namespaceDiffs classDiffs methodDiffs leftClasses leftNamespaces rightClasses rightNamespaces propertyDiffs |	leftMethods := OrderedCollection new.	leftClasses := OrderedCollection new.	leftNamespaces := OrderedCollection new.	leftSharedVariables := OrderedCollection new.	leftProperties := OrderedCollection new.	rightMethods := OrderedCollection new.	rightClasses := OrderedCollection new.	rightNamespaces := OrderedCollection new.	rightSharedVariables := OrderedCollection new.	rightProperties := OrderedCollection new.	leftCodeComponents do: 			[:each |			Store.Reading for: each				while: 					[leftMethods addAll: each methodBlueprints.					leftClasses addAll: each classBlueprints.					leftNamespaces addAll: each namespaceBlueprints.					leftSharedVariables addAll: each sharedVariableBlueprints.					leftProperties addAll: each propertyBlueprints]].	rightCodeComponents do: 			[:each |			Store.Reading for: each				while: 					[rightMethods addAll: each methodBlueprints.					rightClasses addAll: each classBlueprints.					rightNamespaces addAll: each namespaceBlueprints.					rightSharedVariables addAll: each sharedVariableBlueprints.					rightProperties addAll: each propertyBlueprints]].	leftMethods := leftMethods asArray sort.	leftClasses := leftClasses asArray sort.	leftNamespaces := leftNamespaces asArray sort.	leftSharedVariables := leftSharedVariables asArray sort.	leftProperties := leftProperties asArray sort.	rightMethods := rightMethods asArray sort.	rightClasses := rightClasses asArray sort.	rightNamespaces := rightNamespaces asArray sort.	rightSharedVariables := rightSharedVariables asArray sort.	rightProperties := rightProperties asArray sort.	sharedVariableDiffs := leftSharedVariables				differences: rightSharedVariables.	removedSharedVariables := ((self				flatten: (sharedVariableDiffs select: #isDelete)) groupedBy: #reference)				collect: #any.	addedSharedVariables := ((self				flatten: (sharedVariableDiffs select: #isInsert)) groupedBy: #reference)				collect: #any.	namespaceDiffs := leftNamespaces differences: rightNamespaces.	removedNamespaces := ((self flatten: (namespaceDiffs select: #isDelete))				groupedBy: #reference) collect: #any.	addedNamespaces := ((self flatten: (namespaceDiffs select: #isInsert))				groupedBy: #reference) collect: #any.	classDiffs := leftClasses differences: rightClasses.	removedClasses := ((self flatten: (classDiffs select: #isDelete))				groupedBy: #reference) collect: #any.	addedClasses := ((self flatten: (classDiffs select: #isInsert))				groupedBy: #reference) collect: #any.	methodDiffs := leftMethods differences: rightMethods.	removedMethods := (self flatten: (methodDiffs select: #isDelete))				groupedBy: #classReference.	addedMethods := (self flatten: (methodDiffs select: #isInsert))				groupedBy: #classReference.	propertyDiffs := (leftProperties select: #isPackage)				differences: (rightProperties select: #isPackage).	removedPackageProperties := (self				flatten: (propertyDiffs select: #isDelete)) groupedBy: #codeComponentName.	addedPackageProperties := (self flatten: (propertyDiffs select: #isInsert))				groupedBy: #codeComponentName.	propertyDiffs := (leftProperties select: #isBundle)				differences: (rightProperties select: #isBundle).	removedBundleProperties := (self				flatten: (propertyDiffs select: #isDelete)) groupedBy: #codeComponentName.	addedBundleProperties := (self flatten: (propertyDiffs select: #isInsert))				groupedBy: #codeComponentName.	self cleanseUnchangedComponents</body><body package="Store-Code Comparison">leftCodeComponents: aCodeComponentsCollection rightCodeComponents: bPackageSequence	"For a given set of from and to arguments, first expand them to include any contained bundles or packages, then filter out all that don't actually change between the two (e.g. when we find that Package XYZ is the exact same version as the counterpart package in the other list."	| componentDiffs |	leftCodeComponents := self				allSortedCodeComponents: aCodeComponentsCollection.	rightCodeComponents := self allSortedCodeComponents: bPackageSequence.	componentDiffs := (SequenceableCollectionDifferences new)				comparisonFunction: [:a :b | a sameVersionAs: b];				differencesFrom: leftCodeComponents to: rightCodeComponents.	leftCodeComponents := self flatten: (componentDiffs select: #isDelete).	rightCodeComponents := self flatten: (componentDiffs select: #isInsert)</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>converting</category><body package="Store-Code Comparison">invert	"swap the left/right and added/remove values."	| temp |	temp := leftCodeComponents.	leftCodeComponents := rightCodeComponents.	rightCodeComponents := temp.	temp := addedMethods.	addedMethods := removedMethods.	removedMethods := temp.	temp := addedClasses.	addedClasses := removedClasses.	removedClasses := temp.	temp := addedNamespaces.	addedNamespaces := removedNamespaces.	removedNamespaces := temp.	temp := addedSharedVariables.	addedSharedVariables := removedSharedVariables.	removedSharedVariables := temp.	temp := addedPackageProperties.	addedPackageProperties := removedPackageProperties.	removedPackageProperties := temp.	temp := addedBundleProperties.	addedBundleProperties := removedBundleProperties.	removedBundleProperties := temp</body><body package="Store-Code Comparison">withoutComponents: aCollectionOfCodeComponents	"Return a reduced copy, of me with all members of aCollectionOfCodeComponents and any blueprints that reference them, removed."	| reduced |	reduced := self copy.	reduced leftCodeComponents: (leftCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	reduced rightCodeComponents: (rightCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	^reduced cleanseUnmatchedChanges</body></methods><methods><class-id>Store.Glorp.StoreDatabaseIdentifier</class-id> <category>accessing</category><body package="Store-Database Model">name	^name</body><body package="Store-Database Model">name: aString	name := aString</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>accessing</category><body package="Store-Change Management">description	^property</body><body package="Store-Change Management">name	^'&lt;1s&gt; propertyAt: &lt;2s&gt;' 		expandMacrosWith: symbol		with: self property printString</body><body package="Store-Change Management">property	"Answer the property symbol represented by this tag"	^property</body><body package="Store-Change Management">property: aSymbol	"Set the property symbol represented by this tag"	property := aSymbol</body><body package="Store-Change Management">sourceTextForImage	^self sourceTextForImage: self containingPackage</body><body package="Store-Change Management">sourceTextForImage: aPackage	| value |	aPackage == nil		ifTrue: [ ^nil  ].	value := aPackage propertyAt: self property.	value == nil		ifTrue: [ ^nil ].	^( self convertValue: value ) asText</body><body package="Store-Change Management">symbolKey	^property</body><body package="Store-Change Management">text	^self convertValue: ( package propertyAt: self property ifAbsent: [ '' ] ).</body><body package="Store-Change Management">textRepresentationForTag: aTag 	| value |	value := package propertyAt: aTag property ifAbsent: nil. 	^self convertValue: value.</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>testing</category><body package="Store-Change Management">existsInImage	| pkg |	^( pkg := self containingPackage ) ~~ nil 		and: [ ( pkg propertyAt: self property ifAbsent: nil ) ~~ nil ]</body><body package="Store-Change Management">is: dbPackage meaningfulChangeOf: imgPackage 	^imgPackage == nil | (dbPackage == nil) or: 			[(imgPackage propertyAt: self property ifAbsent: nil) 				~= (dbPackage propertyAt: self property ifAbsent: nil)]</body><body package="Store-Change Management">isPropertyTag	^true</body><body package="Store-Change Management">sameAsImage	^(package propertyAt: property ifAbsent: [^false]) = (self containingPackage propertyAt: property ifAbsent: [^false])</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: dbPackage into: imgPackage	"Load the change. Answer true is the operation is successful."	| dbp value |	"special case because of merge tool/changelist incompat"	"for changelist properties, the tag is needed to correctly filein"	dbp := dbPackage class == self class 			ifTrue: [ dbp := dbPackage package ]		ifFalse: [ dbPackage ].	dbp isLoaded		ifTrue: [ ^true ].		"already the in image version"	value :=  dbp propertyAt: self property ifAbsent: nil. 	[ imgPackage perform: ( self property, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | imgPackage propertyAt: self property put: value. e return ].	^true.</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	aPackage propertyAt: property put: nil</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| pkg |	^( pkg := self containingPackage ) == nil		ifTrue: [ false ]		ifFalse: [ pkg propertyAt: self property put: someText. true ].</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>converting</category><body package="Store-Change Management">convertValue: value	^value isString		ifTrue: [ value ]		ifFalse: 			[ ( value isKindOf: BlockClosure )				ifTrue: [ CodeComponent stringFromAction: value ] 				ifFalse: [ value printString ]			].</body><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch. Answer nil if it's someone elses property"	^( ( package isNil ) or: [ package comparesTo: aPackage ] )		ifTrue: [ aPackage recordForPropertyTag: self ]</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersion	( package propertyAt: property ifAbsent: nil ) inspect.</body><body package="Store-Change Management">definition	^self text</body><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	package == nil		ifFalse: 			[ aStream				component: package componentType				named: package name				property: property				value: ( package propertyAt: property ifAbsent: nil )			].</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aStream		component: aRecord componentType		named: aRecord name		property: property		value: ( aRecord propertyAt: property ifAbsent: nil )</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	package == nil		ifFalse: 			[ aStream				component: package componentType				named: package name				property: property				value: ( package propertyAt: property ifAbsent: nil )			].</body><body package="Store-Change Management">loadSrcIntoPackage: aPackage confirm: aBoolean	"Load the receiver by setting the property value."	| value |	aBoolean 		ifTrue: 			[ ( Dialog confirm: ( (#ResetProperty1s &lt;&lt; #store &gt;&gt; 'Reset property &lt;1s&gt;?') expandMacrosWith: property ) )				ifFalse: [ ^self ].			].	value :=   package propertyAt: property ifAbsent: nil.	[ aPackage perform: ( property, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | aPackage propertyAt: property put: value. e return ].</body></methods><methods><class-id>Store.PropertyTag class</class-id> <category>instance creation</category><body package="Store-Change Management">package: aPackage property: aSymbol	"Answer a tag that represents a change  in a property."	"Note - needs the package to be complete."	^self new		package: aPackage;		property: aSymbol;		yourself.</body></methods><methods><class-id>Store.PropertyTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^10</body></methods><methods><class-id>Store.Glorp.ClassSelectorKeyDictionary</class-id> <category>accessing</category><body package="Store-Database Model">atClass: aClass andSelector: aSelector	| key |	key := ClassSelectorLookupKey forClass: aClass andSelector: aSelector.	^self at: key</body><body package="Store-Database Model">atClass: aClass andSelector: aSelector ifAbsent: aBlock	| key |	key := ClassSelectorLookupKey forClass: aClass andSelector: aSelector.	^self at: key ifAbsent: aBlock</body><body package="Store-Database Model">atClass: aClass andSelector: aSelector put: anObject	| key |	key := ClassSelectorLookupKey forClass: aClass andSelector: aSelector.	^self at: key put: anObject</body></methods><methods><class-id>Store.Glorp.ClassSelectorKeyDictionary</class-id> <category>private</category><body package="Store-Database Model">initialIndexFor: aHashValue boundedBy: length	^aHashValue \\ length + 1</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>testing</category><body package="Store-Difference Management">isMeta	^otherObject 		ifNil: [mainObject isMeta]		ifNotNil: [otherObject isMeta]</body><body package="Store-Difference Management">isShownInMethodList	^true</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>accessing</category><body package="Store-Difference Management">classListName	^otherObject 		ifNil: [mainObject longNameFromSmalltalk]		ifNotNil: [otherObject longNameFromSmalltalk]</body><body package="Store-Difference Management">differenceName	^otherObject 		ifNil: [mainObject signature]		ifNotNil: [otherObject signature]</body><body package="Store-Difference Management">mainClassStoreObject	^mainObject</body><body package="Store-Difference Management">mainDefinition		^(mainObject isNil 		ifTrue: [self notDefinedInThisPackage] 		ifFalse: [mainObject]) asText</body><body package="Store-Difference Management">mainPackage: aPackage method: aStoreMethod	self mainPackage: aPackage object: aStoreMethod</body><body package="Store-Difference Management">mainProtocol	^(mainObject isNil		ifTrue: ['']		ifFalse: [mainObject protocol]) asText</body><body package="Store-Difference Management">otherClassStoreObject	^otherObject</body><body package="Store-Difference Management">otherDefinition	^(otherObject isNil		ifTrue: [self notDefinedInThisPackage]		ifFalse: [otherObject]) asText</body><body package="Store-Difference Management">otherPackage: aPackage method: aStoreMethod	self otherPackage: aPackage object: aStoreMethod</body><body package="Store-Difference Management">otherProtocol	^(otherObject isNil		ifTrue: ['']		ifFalse: [otherObject protocol]) asText</body><body package="Store-Difference Management">resolutionClass	^MethodChangeResolver</body><body package="Store-Difference Management">selector	^otherObject isNil		ifTrue: [mainObject selector]		ifFalse: [otherObject selector]</body><body package="Store-Difference Management">selectorListIcon	^CompiledMethod toolListIcon</body><body package="Store-Difference Management">selectorListName	^self selector asString</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>loading</category><body package="Store-Difference Management">loadMainDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: mainPackage storeModel		while: [mainObject loadSource].</body><body package="Store-Difference Management">loadOtherDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: [otherObject loadSource].</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	mainObject fileOutSourceOn: aStream</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	otherObject fileOutSourceOn: aStream</body></methods><methods><class-id>Store.PseudoMethodDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage method: aStoreMethod	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: aStoreMethod;		yourself</body><body package="Store-Difference Management">otherPackage: aPackage method: aStoreMethod	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: aStoreMethod;		yourself</body></methods><methods><class-id>Store.Glorp.StoreRBInitializerDefinition</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">fullName	^nameSpace fullName</body><body package="StoreForGlorpBrowserUI">implementingClass	^nameSpace isForClassOrExtension ifTrue: [nameSpace]</body><body package="StoreForGlorpBrowserUI">protocol	| result |	result := self classOrNameSpace package sharedVariables		detect: [:each | each name = self variableName asString]		ifNone: [^nil].	^result protocol</body></methods><methods><class-id>Store.PseudoBundle</class-id> <category>accessing</category><body package="Store-Component Support">name	^realPackage isNil		ifTrue: [(#BracketNoMatchingBundle &lt;&lt; #store &gt;&gt; '[No Matching Bundle]') asString]		ifFalse: [realPackage name]</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject</class-id> <category>private - accessing</category><body package="Store-Database Model">signatureObject: aSignatureObject	signatureObject := aSignatureObject</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject</class-id> <category>comparing</category><body package="Store-Database Model">= anObject	^self signatureObject equalsSignatureIn: anObject signatureObject</body><body package="Store-Database Model">hash	^self signatureObject signatureHash</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject</class-id> <category>accessing</category><body package="Store-Database Model">signatureObject	^signatureObject</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject class</class-id> <category>instance creation</category><body package="Store-Database Model">for: aSignatureObject	^self new		signatureObject: aSignatureObject;		yourself</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>interface opening</category><body package="Store-UI">listBlock: aBlock windowTitleBlock: aTitleBlock newFilter: aBoolean	listPart := self listPartClass new.	listPart tool: self.	titleBlock := aTitleBlock.	listPart title: (aTitleBlock value: self class connectionName).	listBlock := aBlock.	pundleFilter := aBoolean				ifTrue: [PundleFilter new]				ifFalse: [PundleFilter lastAppliedFilter].	self setupSearcher</body><body package="Store-UI">listPartClass	^self class listPartClass</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #selectionTool)		client: searchModule		spec: searchModule preferredWindowSpec		builder: aBuilder newSubBuilder</body><body package="Store-UI">postOpenWith: aBuilder		super postOpenWith: aBuilder.	self refreshList.	DbRegistry when: StoreDisconnect send: #storeDisconnect to: self.	DbRegistry when: StoreConnect send: #storeConnect to: self</body><body package="Store-UI">pundlesMatching: aString	| pattern |	pattern := aString trimBlanks, '*'.	^self cachedPundles select: [:some | pattern match: some name]</body><body package="Store-UI">setupSearcher	searchModule := IncrementalSearchModule 		forSelectionWithSearch: [:pattern | self pundlesMatching: pattern].	searchModule		useEagerSelection: false;		pasteSelected: false;		objectToStringBlock: [:package | package name];		showLabels: false;		useMultiSelection: true;		iconSelector: #toolListIcon;		displayStringBlock: [:item | item storeModel ifNil: [item name] ifNotNil: [item name asText allBold]];		menuHolder: [(self mainMenu value atNameKey: #Packages) submenu] performer: self.	searchModule selectionIndexHolder onChangeSend: #pundleSelectionChanged to: self</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>accessing</category><body package="Store-UI">cachedPundles	"Pundles last read from the database are cached to avoid re-querying when	filtering. The cache is filled by reloadVersions."	^cachedPundles isNil		ifTrue: [Array new]		ifFalse: [cachedPundles]</body><body package="Store-UI">listBlock	^listBlock</body><body package="Store-UI">pundleFilter	^pundleFilter ifNil: [pundleFilter := PundleFilter new]</body><body package="Store-UI">pundleFilter: aPundleFilter	pundleFilter := aPundleFilter</body><body package="Store-UI">searchModule	^searchModule</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>updating</category><body package="Store-UI">pundleSelectionChanged	listPart resetWith: searchModule selections withFeedbackOn: self mainWindow.</body><body package="Store-UI">refreshList		| gatheringString |	[gatheringString := (#AllBundlesAndPackages &lt;&lt; #store &gt;&gt; 'All Bundles And Packages') asString.	(Gathering for: gatheringString) started.	searchModule list: (cachedPundles := listBlock value: self pundleFilter).	(Gathering for: gatheringString) finished] withStoreFeedbackOn: self mainWindow.	(((self builder aspectAt: #searchModule) builder aspectAt: #entryModule) builder componentAt: #entryField) takeKeyboardFocus.</body><body package="Store-UI">refreshListAndSelections		| selections |	selections := searchModule selections.	self refreshList.	self searchModule selections: selections</body><body package="Store-UI">resetImageVersions	listPart resetImageVersions</body><body package="Store-UI">storeConnect	listPart title: (titleBlock value: self class connectionName).	self mainWindow label: self listTitle.	self refreshList.</body><body package="Store-UI">storeDisconnect	listPart title: (#Disconnected &lt;&lt; #store &gt;&gt; 'Disconnected') asString.	self mainWindow label: self listTitle.	searchModule selections: OrderedCollection new.	self updateVersionsList.	cachedPundles := #().	searchModule list: cachedPundles.</body><body package="Store-UI">updateVersionsList	self pundleSelectionChanged</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>interface closing</category><body package="Store-UI">noticeOfWindowClose: aWindow	DbRegistry unsubscribe: self.	super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>aspects</category><body package="Store-UI">mainMenu	"The listPart must have a mainMenu which adds its action menu"	^[| menu item |	menu := self class mainMenu.	item := menu atNameKey: #Comment.	item submenu: self class textMenu.	item := menu atNameKey: #Packages.	item submenu: self class packagesMenu.	item := MenuItem labeled: #_Versions &lt;&lt; #store &gt;&gt; '&amp;Versions'.	item submenu: [listPart listMenu value].	menu addItem: item atPosition: 10.015.	menu		augmentFrom: self class		to: self class		menuName: #Packages		for: self.	menu]</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>menus</category><body package="Store-UI">showBundlesIndicator	^self pundleFilter showBundles</body><body package="Store-UI">showPackagesIndicator	^self pundleFilter showPackages</body><body package="Store-UI">toggleShowBundles	self pundleFilter showBundles: self showBundlesIndicator not</body><body package="Store-UI">toggleShowPackages	self pundleFilter showPackages: self showPackagesIndicator not</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>opening</category><body package="Store-UI">openOnAllLoadedPundlesUnfiltered	self openOnAllLoadedPundlesUsingNewFilter: true</body><body package="Store-UI">openOnAllLoadedPundlesUsingNewFilter: aBoolean	| listBlock |	listBlock := self allLoadedPundlesBlock.	self		openOnBlock: listBlock		windowTitleBlock: [:ignore | (#LoadedItems &lt;&lt; #store &gt;&gt; 'Loaded Items') asString]		newFilter: aBoolean</body><body package="Store-UI">openOnAllLoadedPundlesWithFilter	self openOnAllLoadedPundlesUsingNewFilter: (RepositoryFilterDialog new open) not.</body><body package="Store-UI">openOnAllPublishedPundlesUnfiltered	self openOnAllPublishedPundlesUsingNewFilter: true</body><body package="Store-UI">openOnAllPublishedPundlesUsingNewFilter: aBoolean	| listBlock |	listBlock := self allPublishedPundlesBlock.	self		openOnBlock: listBlock		windowTitleBlock: 			[:connectionName |			#PublishedItems1s &lt;&lt; #store &gt;&gt; 'Published Items &lt;1?:on&gt; &lt;2s&gt;'				expandMacrosWith: connectionName isEmpty				with: connectionName]		newFilter: aBoolean</body><body package="Store-UI">openOnAllPublishedPundlesWithFilter	self openOnAllPublishedPundlesUsingNewFilter: (RepositoryFilterDialog new open) not.</body><body package="Store-UI">openOnBlock: aBlock windowTitleBlock: titleBlock newFilter: aBoolean	self openOn: (self new listBlock: aBlock windowTitleBlock: titleBlock newFilter: aBoolean)</body><body package="Store-UI">openRecentPublishedItemsUnfiltered	self openRecentPublishedItemsUsingNewFilter: true</body><body package="Store-UI">openRecentPublishedItemsUsingNewFilter: aBoolean	| listBlock |	(Gathering for: (#MostRecentPublishedItems &lt;&lt; #store &gt;&gt; 'Most Recent Published Items') asString) started.	listBlock := self recentPublishedItemsBlock.	(Gathering for: (#MostRecentPublishedItems &lt;&lt; #store &gt;&gt; 'Most Recent Published Items') asString) finished.	self		openOnBlock: listBlock		windowTitleBlock: 			[:connectionName |			#MoreRecentlyPublishedItems1s &lt;&lt; #store				&gt;&gt; 'More Recently Published Items &lt;1?:on&gt; &lt;2s&gt;'					expandMacrosWith: connectionName isEmpty					with: connectionName]		newFilter: aBoolean</body><body package="Store-UI">openRecentPublishedItemsWithFilter	self openRecentPublishedItemsUsingNewFilter: (RepositoryFilterDialog new open) not.</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>private</category><body package="Store-UI">connectionName	^DbRegistry connectedProfile 		ifNil: ['']		ifNotNil: [:profile | profile name ifNil: [DbRegistry databaseIdentifier]]</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>filter blocks</category><body package="Store-UI">allLoadedPundlesBlock	^[:pundleFilter |	| list |	list := List new.	pundleFilter showBundles ifTrue:		[list addAll: (Registry allBundlesSorted)].	pundleFilter showPackages ifTrue:		[list addAll: (Registry allPackagesSorted)].	list]</body><body package="Store-UI">allPublishedPundlesBlock	^	[:pundleFilter |	| list connection |	connection := StoreLoginFactory currentStoreSession.	list := List new.	pundleFilter showBundles ifTrue: [list addAll: (self storeBundlesIn: connection using: pundleFilter)].	pundleFilter showPackages ifTrue: [list addAll: (self storePackagesIn: connection using: pundleFilter)].	list]</body><body package="Store-UI">recentPublishedItemsBlock	^ 	[:pundleFilter |	| session list |	session := StoreLoginFactory currentStoreSession.	list := List new.	pundleFilter showBundles ifTrue:		[list addAll: ((Registry allBundlesWithNewerInDBIn: session) asSortedCollection: [:a :b | a name &lt; b name])].	pundleFilter showPackages ifTrue:		[list addAll: ((Registry allPackagesWithNewerInDBIn: session) asSortedCollection: [:a :b | a name &lt; b name])].	list]</body><body package="Store-UI">storeBundlesIn: connection using: aPundleFilter	^(StoreBundle 		allNamesSortedIn: connection 		usingPundleFilter: aPundleFilter) asOrderedCollection			collect: [:each | StoreBundle newNamed: each]</body><body package="Store-UI">storePackagesIn: connection using: aPundleFilter	^(StorePackage 		allNamesSortedIn: connection 		usingPundleFilter: aPundleFilter) asOrderedCollection			collect: [:each | StorePackage newNamed: each]</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>accessing</category><body package="Store-UI">defaultListPartClass	^PundleVersionPane</body><body package="Store-UI">listPartClass	(listPartClass isNil or: [listPartClass isObsolete])		ifTrue: [listPartClass := self defaultListPartClass].	^listPartClass</body><body package="Store-UI">listPartClass: aClass	listPartClass := aClass</body></methods><methods><class-id>Store.Reading</class-id> <category>accessing</category><body package="Store-Code Comparison">actionText	^(#Reading &lt;&lt; #store &gt;&gt; 'Reading') asString</body></methods><methods><class-id>Store.Reading class</class-id> <category>utility</category><body package="Store-Code Comparison">for: aCodeComponent while: aBlock	(self for: aCodeComponent) started.	^aBlock ensure: [(self for: aCodeComponent) finished]</body></methods><methods><class-id>Store.TextModification</class-id> <category>testing</category><body package="Store-Change Management">isTextModification		^true</body><body package="Store-Change Management">notOriginallyInImage	^false</body></methods><methods><class-id>Store.TextModification</class-id> <category>comparing</category><body package="Store-Change Management">= aMod 	^aMod notNil and: [aMod isTextModification and: [aMod isMoveModification not and: [aMod text = self text and: [aMod packageName = self packageName and: [aMod tag = self tag]]]]]</body></methods><methods><class-id>Store.TextModification</class-id> <category>accessing</category><body package="Store-Change Management">description	^((#x1sSpace &lt;&lt; #store &gt;&gt; '&lt;1s&gt; ') expandMacrosWith: self packageName)</body><body package="Store-Change Management">existsInPackage	^text notNil</body><body package="Store-Change Management">record	^nil</body><body package="Store-Change Management">source	^text</body><body package="Store-Change Management">text: sourceCode	text := sourceCode</body><body package="Store-Change Management">timeStampString	^''</body></methods><methods><class-id>Store.TextModification</class-id> <category>actions</category><body package="Store-Change Management">apply	"Apply a modification to the image."	"| imPkg | 	imPkg := TT_Registry packageNamed: packageName.	imPkg isNil ifTrue: [self error: 'Package ' , packageName , ' not found.'].	tag existsInImage		ifTrue: 			[| oldPkg |			oldPkg := tag containingPackage.			oldPkg isNil ifTrue: [self error: 'No containing package for: ' , tag printString].			oldPkg = imPkg ifFalse: [self halt]]."	self notify: tag printString</body></methods><methods><class-id>Store.TextModification</class-id> <category>change list support</category><body package="Store-Change Management">category	^tag isForMethod		ifTrue: [ tag category ]</body><body package="Store-Change Management">sameAsSystem	"No record, so this is the system."	^true</body><body package="Store-Change Management">systemCategory	^tag isForMethod		ifTrue: [ tag systemCategory ]</body><body package="Store-Change Management">text	"Asnwer the text to display in a text window."	^text</body></methods><methods><class-id>Store.TextModification class</class-id> <category>instance creation</category><body package="Store-Change Management">tag: aTag package: aPackage text: sourceCode	^self new tag: aTag; package: aPackage; text: sourceCode</body></methods><methods><class-id>Store.Glorp.Store74DescriptorSystem</class-id> <category>descriptors</category><body package="Store-Database Model">descriptorForStoreLoadRecord: aDescriptor	| table |	table := self tableNamed: 'TW_LoadRecord'.	aDescriptor table: table.	aDescriptor directMapping from: #username to: 'username'.	aDescriptor directMapping from: #pundleName to: 'pundleName'.	aDescriptor directMapping from: #type to: 'pundleType'.	aDescriptor directMapping from: #version to: 'pundleVersion'.	self addTimestampTo: aDescriptor fromTable: aDescriptor table.</body><body package="Store-Database Model">descriptorForStoreMethod: aDescriptor	| |	super descriptorForStoreMethod: aDescriptor.	self hasMethodComments ifTrue: [		(aDescriptor newMapping: OneToOneMapping)			attributeName: #comment;			useLinkTable;			useFilteredRead].</body></methods><methods><class-id>Store.Glorp.Store74DescriptorSystem</class-id> <category>tables</category><body package="Store-Database Model">allTableNames	^super allTableNames , #('TW_MethodDocs' 'TW_LoadRecord').</body><body package="Store-Database Model">tableForTW_LOADRECORD: aTable 	aTable createFieldNamed: 'username' type: (platform varchar: 255).	aTable createFieldNamed: 'pundleName' type: (platform varchar: 255).	aTable createFieldNamed: 'pundleType' type: (platform varchar: 1).	aTable createFieldNamed: 'pundleVersion' type: (platform varchar: 255).	aTable createFieldNamed: self timestampFieldName type: platform integer.	aTable propertyAt: #tableSpaceName put: StoreObject tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreObject tableSpaceName , '.' , session schema].</body><body package="Store-Database Model">tableForTW_METHODDOCS: aTable 	| methodRef documentRef foreignKey |	methodRef := aTable createFieldNamed: 'methodRef' type: platform int4.	methodRef bePrimaryKey.	documentRef := aTable createFieldNamed: 'documentRef' type: platform int4.	documentRef bePrimaryKey.	"This foreignKey is always in the same table space as the target, so we always create it"	aTable addForeignKeyFrom: methodRef		to: ((self tableNamed: 'TW_Method') fieldNamed: 'primaryKey').	foreignKey := aTable addForeignKeyFrom: documentRef		to: ((self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey').	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	aTable propertyAt: #tableSpaceName put: StoreObject tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreObject tableSpaceName , '.' , session schema].</body></methods><methods><class-id>Store.Glorp.Store74DescriptorSystem</class-id> <category>classes</category><body package="Store-Database Model">classModelForStoreLoadRecord: aClassModel	aClassModel newAttributeNamed: #username.	aClassModel newAttributeNamed: #pundleName.	aClassModel newAttributeNamed: #pundleType.	aClassModel newAttributeNamed: #version.	aClassModel newAttributeNamed: #timestamp type: Dialect timestampClass.</body><body package="Store-Database Model">classModelForStoreMethod: aClassModel	super classModelForStoreMethod: aClassModel.	aClassModel newAttributeNamed: #comment type: StoreBinaryBlob.</body><body package="Store-Database Model">constructAllClasses	^(super constructAllClasses)		add: StoreLoadRecord;		yourself</body></methods><methods><class-id>Store.Glorp.Store74DescriptorSystem</class-id> <category>initialization</category><body package="Store-Database Model">initialize	super initialize.	self initializeDescriptors</body><body package="Store-Database Model">initializeDescriptors	"Descriptors is a dictionary containing all of the descriptors needed when creating 	objects from database rows. If lookups require a lot of probing because of duplicate hash 	values, it can have an effect on Store performance. The current value was chosen because it	resulted in no slot collisions at all. For future Store descriptorSystem classes, work may be 	necessary on the hashes used and/or creation of a class that guarantees a size with no collisions 	based on known contents"	descriptors := Dictionary new: 61</body></methods><methods><class-id>Store.ReplaceModifiedPackageNotice</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		^(Dialog		choose:			(#ImagePackage1sWasTWithANewVersion &lt;&lt; #store &gt;&gt; 'Image package &lt;1s&gt; was modified.&lt;n&gt;Replace it with a new version?' expandMacrosWith: messageText)		labels: (Array with: (#Replace &lt;&lt; #store &gt;&gt; 'Replace') asString with: (#Cancel &lt;&lt; #store &gt;&gt; 'Cancel') asString)		values: #(#replace #cancel)		default: #replace) = #replace</body></methods><methods><class-id>Store.ReplaceModifiedPackageNotice class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentInspectPropertiesTool</class-id> <category>initialize-release</category><body package="StoreForGlorpBrowserUI">initialize	"We specifically do NOT call super initialize."	inspector := Tools.Trippy.InspectorHolder		with: (StoreCodeComponentPropertyInspector on: nil).	^self</body></methods><methods><class-id>Store.RequestUniqueDatabaseIdentifierString</class-id> <category>constants</category><body package="Store-Base">defaultResumeValue	^'store_database'</body><body package="Store-Base">defaultReturnValue	^'store_database'</body></methods><methods><class-id>Store.RequestUniqueDatabaseIdentifierString</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	| identifier |	[(identifier := Dialog		request: #EnterAUniqueNameForThisStoreRepository &lt;&lt; #store &gt;&gt; 'Enter a unique name for this Store repository:'		initialAnswer: '') notEmpty] whileFalse.	^identifier</body></methods><methods><class-id>Store.RequestUniqueDatabaseIdentifierString class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StandardResolution</class-id> <category>accessing</category><body package="Store-Merge Management">resolver	^resolver</body><body package="Store-Merge Management">resolver: aResolver	resolver := aResolver</body><body package="Store-Merge Management">value	^resolver</body></methods><methods><class-id>Store.Glorp.StandardResolution</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^true</body><body package="Store-Merge Management">isStandardResolution	^true</body><body package="Store-Merge Management">sameAsImageUsing: aChangeResolver	resolver isImageObject not ifTrue: [^resolver sameAsImage].	^aChangeResolver sameDefinitionAs: resolver</body></methods><methods><class-id>Store.Glorp.StandardResolution</class-id> <category>comparing</category><body package="Store-Merge Management">= aResolution	^self class = aResolution class and:		[self package = aResolution package and:		[self value = aResolution value]]</body></methods><methods><class-id>Store.Glorp.StandardResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management">package: aPackage resolver: aResolver	| instance |	instance := self new.	instance package: aPackage.	instance resolver: aResolver.	^instance</body></methods><methods><class-id>Store.Glorp.AbsentResolution</class-id> <category>testing</category><body package="Store-Merge Management">isAbsentResolution	^true</body><body package="Store-Merge Management">isDoNothingResolution	^true</body><body package="Store-Merge Management">proposed	^true</body><body package="Store-Merge Management">value	^MergeTool doNotApplyChangeString</body></methods><methods><class-id>Store.Glorp.AbsentResolution</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	applied := false</body></methods><methods><class-id>Store.Glorp.AbsentResolution</class-id> <category>accessing</category><body package="Store-Merge Management">key 	^nil</body><body package="Store-Merge Management">package 	^nil</body></methods><methods><class-id>Store.Glorp.UserInputResolution</class-id> <category>accessing</category><body package="Store-Merge Management">original	^self package</body><body package="Store-Merge Management">protocol	^protocol</body><body package="Store-Merge Management">protocol: anObject	protocol := anObject</body><body package="Store-Merge Management">protocolName	^(protocol isNil or: [protocol isEmpty])		ifTrue: [ClassOrganizer defaultProtocol]		ifFalse: [protocol]</body><body package="Store-Merge Management">text	^text</body><body package="Store-Merge Management">text: aString	text := aString</body><body package="Store-Merge Management">value	^text</body></methods><methods><class-id>Store.Glorp.UserInputResolution</class-id> <category>testing</category><body package="Store-Merge Management">isUserInputResolution	^true</body></methods><methods><class-id>Store.Glorp.UserInputResolution</class-id> <category>comparing</category><body package="Store-Merge Management">= anObject	^self class = anObject class and: 		[text = anObject text and:		[protocol = anObject protocol and:		[package = anObject package]]]</body></methods><methods><class-id>Store.Glorp.UserInputResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management">forPackage: aPundleModel text: aString	| instance |	instance := self new.	instance package: aPundleModel.	instance text: aString.	^instance</body><body package="Store-Merge Management">forPackage: aPundleModel text: aString protocol: aProtocolString	| instance |	instance := self new.	instance package: aPundleModel.	instance text: aString.	instance protocol: aProtocolString.	^instance</body></methods><methods><class-id>Store.RequestInstallDatabaseTables</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	^Dialog confirm: (#StoreDatabaseTablesNotInDatabaseCreate &lt;&lt; #store &gt;&gt; 'The Store database tables do not appear to be in the current database&lt;n&gt;Install Store database tables?') expandMacros</body></methods><methods><class-id>Store.RequestInstallDatabaseTables</class-id> <category>constants</category><body package="Store-Base">defaultResumeValue	^true</body><body package="Store-Base">defaultReturnValue	^true</body></methods><methods><class-id>Store.RequestInstallDatabaseTables class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison">leftMethod: aLeftMethodBlueprint rightMethod: aRightMethodBlueprint	leftMethod := aLeftMethodBlueprint.	rightMethod := aRightMethodBlueprint.	self populate</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>row population</category><body package="Store-Code Comparison">computeDetailRows	| rows |	rows := OrderedCollection new.	leftMethod packageName = rightMethod packageName		ifFalse: 			[rows add: ((self newRow)						add: ComparisonIcons movePackage;						add: (self italicizedText: 'Package');						add: 'changed from';						add: leftMethod packageName asText allBold;						add: 'to';						add: rightMethod packageName asText allBold;						yourself)].	leftMethod category = rightMethod category		ifFalse: 			[rows add: ((self newRow)						add: ComparisonIcons moveCategory;						add: (self italicizedText: 'Category');						add: 'changed from';						add: leftMethod category asText allBold;						add: 'to';						add: rightMethod category asText allBold;						yourself)].	leftMethod source = rightMethod source		ifFalse: 			[rows				add: (SideBySideTextComparisonView new leftText: leftMethod sourceText						rightText: rightMethod sourceText)].	^rows</body><body package="Store-Code Comparison">populateHeader	| header icons |	super populateHeader.	header := self header.	icons := Panel new beRow: 0.5.	leftMethod source = rightMethod source		ifFalse: [icons add: ComparisonIcons modify].	leftMethod category = rightMethod category		ifFalse: [icons add: ComparisonIcons moveCategory].	leftMethod packageName = rightMethod packageName		ifFalse: [icons add: ComparisonIcons movePackage].	header add: icons.	header add: (Label with: leftMethod selectorDisplayText).	header add: self moreInfoTooltipHandle</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison">openMethodVersions	| selections |	selections := Set new.	self leftStoreMethod		ifNotNil: [:storeMethodInPackage | selections add: storeMethodInPackage definition].	self rightStoreMethod		ifNotNil: [:storeMethodInPackage | selections add: storeMethodInPackage definition].	self openMethodVersions: selections</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>testing</category><body package="Store-Code Comparison">canRevertFrom: anImageMethodDefinition to: aStoreMethodInPackage	aStoreMethodInPackage		ifNotNil: 			[:storeMethodInPackage |			anImageMethodDefinition				ifNotNil: 					[:imageMethodDefinition |					storeMethodInPackage package primaryKey = (imageMethodDefinition package								dbTraceFor: storeMethodInPackage package dbIdentifier)						ifTrue: [^true]]].	^false</body><body package="Store-Code Comparison">hasMenu	^true</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>private</category><body package="Store-Code Comparison">leftImageMethod	^self imageMethodDefinitionFrom: leftMethod</body><body package="Store-Code Comparison">leftStoreMethod	^leftMethod originalStoreObject</body><body package="Store-Code Comparison">rightImageMethod	^self imageMethodDefinitionFrom: rightMethod</body><body package="Store-Code Comparison">rightStoreMethod	^rightMethod originalStoreObject</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison">categoryInfoTooltipText	| output |	output := TextStream on: String new.	output		nextPutAll: (leftMethod category = rightMethod category				ifTrue: [#MethodCategoryC &gt;&gt; 'Category:' &lt;&lt; #IDE]				ifFalse: [#MethodCategoriesC &gt;&gt; 'Categories:' &lt;&lt; #IDE]) asString.	output space.	output		emphasis: #bold;		nextPutAll: leftMethod category;		emphasis: nil.	rightMethod category = leftMethod category		ifFalse: 			[output				nextPut: $/;				emphasis: #bold;				nextPutAll: rightMethod category;				emphasis: nil].	^output contents</body><body package="Store-Code Comparison">packageInfoTooltipText	| output |	output := TextStream on: String new.	output		nextPutAll: (leftMethod packageName = rightMethod packageName				ifTrue: [#DefinitionPackageC &gt;&gt; 'Package:' &lt;&lt; #IDE]				ifFalse: [#DefinitionPackagesC &gt;&gt; 'Packages:' &lt;&lt; #IDE]) asString.	output space.	output		emphasis: #bold;		nextPutAll: leftMethod packageName;		emphasis: nil.	rightMethod packageName = leftMethod packageName		ifFalse: 			[output				nextPut: $/;				emphasis: #bold;				nextPutAll: rightMethod packageName;				emphasis: nil].	^output contents</body><body package="Store-Code Comparison">tooltipTextChunks	^Array with: self categoryInfoTooltipText with: self packageInfoTooltipText</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^Array		with: #compareMethods		with: leftMethod selector		with: leftMethod isInstanceBehavior</body></methods><methods><class-id>Store.StorePublishingError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog warn:		(#AnErrorOccuredPublishingn1snNoChanges &lt;&lt; #store &gt;&gt;			'An error occured when writing to the database.&lt;n&gt;&lt;1s&gt;&lt;n&gt;No changes to the database have been commited' 				expandMacrosWith: self messageText).	^nil</body></methods><methods><class-id>Store.Loading</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">actionText	^(#Loading &lt;&lt; #store &gt;&gt; 'Loading') asString</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">isClassDefinitionResolver	^true</body><body package="Store-Merge Management">isDefintionResolver	^true</body><body package="Store-Merge Management">isMove	^movePair notNil</body><body package="Store-Merge Management">isPotentialMove	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	| reference |	proposed ifNil: [^true].	proposed isRemovalResolution ifFalse: [^true].	(reference := (self environmentString asString, '.' , self definitionName) asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^(((Registry containingPackageForClass: reference value) name = proposed package name) or: 		[Override isOverriddenClassOrNameSpace: reference value in: proposed package storeModel])</body><body package="Store-Merge Management">sameDefinitionAs: aString	| reference |	(reference := self ownerName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value definitionString = aString</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	| existingPackage |	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isNoOpResolution]]]) 			ifTrue: [^true].	self isMove ifTrue: [^self applyMove].	self hasOverrideAndShouldApply ifFalse: [^false].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	(existingPackage := self existingDefinitionPackage) isNil ifTrue: [^self applyChange].	^existingPackage = proposed package storeModel		ifTrue: [self applyChange]		ifFalse: [self applyOverride].</body><body package="Store-Merge Management">applyAsRemove	| class overrides changeManager targetOverride |	class := self longOwnerName asQualifiedReference value.	refactoring := (overrides := self existingOverrides) isEmpty		ifTrue: [RemoveClassChange remove: class]		ifFalse: 			[(targetOverride := overrides detect: [:each | each sources includes: proposed package storeModel] ifNone: [nil]) notNil				ifTrue: [RemoveOverrideChange for: targetOverride]				ifFalse: [RestoreOverrideChange for: overrides last]].	changeManager := RefactoryChangeManager instance.	^[[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: RedefinitionNotification		do: [:exception | exception currentPackage = proposed package storeModel ifTrue: [exception resume] ifFalse: [exception return: false]]]			on: Error			do: 				[:exception | 				Transcript show: (#nApplyingClassRemovalFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Class &lt;2s&gt; Failed: &lt;1s&gt;' 					expandMacrosWith: exception messageText					with: self definitionName).				exception return: false].</body><body package="Store-Merge Management">applyChange	| changeManager |	^[refactoring := AddClassChange definition: proposed value.	refactoring package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	changeManager performChange: refactoring.	undo := changeManager undoChange.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingClassChangeFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying Class Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">applyMove	| targetResolver changeManager |	applied ifTrue: [^true].	targetResolver := proposed isRemovalResolution		ifTrue: [movePair proposed]		ifFalse: [proposed].	refactoring := MoveClassDefinitionToPackageChange		class: self longOwnerName asStrictReference value		package: targetResolver package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	self markApplied.	movePair markApplied.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingClassMoveFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying Class Move Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">applyOverride	| changeManager class |	class := self longOwnerName asQualifiedReference value.	refactoring := CompositeRefactoryChange named: 'Merge Override Class'.	refactoring addChange: (MoveClassDefinitionToPackageChange 		class: class		package: proposed package storeModel).	refactoring addChange: (AddOverrideChange for: (Override forClass: class)).	refactoring addChange: (AddClassChange definition: proposed value).	refactoring changes last package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingClassOverrideFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying Class Override Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">definitionName	| methodNodeHolder target |	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	target isAbsentResolution ifTrue: [^''].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first arguments first value asString</body><body package="Store-Merge Management">environmentString	| methodNodeHolder target |	proposed isAbsentResolution ifTrue: [^'Root'].	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^'Root'].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first receiver name asString</body><body package="Store-Merge Management">existingDefinitionPackage		^Store.Registry containingPackageForClassNamed: self longOwnerName</body><body package="Store-Merge Management">existingOverrides	^(Override overridesForClassOrNameSpace: (self longOwnerName asStrictReference valueOrDo: [^#()])) ifNil: [^#()]</body><body package="Store-Merge Management">hasOverrideAndShouldApply		self existingDefinitionPackage ifNotNil:		[:value | 		value name = proposed package name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed package name) ifFalse: 				[Transcript show: (#nDidNotApplyOverrideClass1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of Class &lt;1s&gt; in &lt;2s&gt;' 					expandMacrosWith: self longOwnerName					with: proposed package name).				^false]]].	^true</body><body package="Store-Merge Management">ownerNameForLoadOrdering	| methodNodeHolder target |	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	target isAbsentResolution ifTrue: [^''].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^(methodNodeHolder node block body statements first arguments at: 2) value asString</body><body package="Store-Merge Management">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingChange1sIn2nsOveride3snn &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;Class "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longOwnerName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">raiseNoticeFor: aCompilerError	aCompilerError type = #undeclared ifTrue: 		[Dialog warn: (#UnknownVariableSpaceColonSpace1s &lt;&lt; #dialogs &gt;&gt; 'Unknown Variable : &lt;1s&gt;' expandMacrosWith: aCompilerError parameter key).		^nil].	^super raiseNoticeFor: aCompilerError</body><body package="Store-Merge Management">validateParse: aNodeHolder	"We make sure of the following:		1) The superclass hasn't changed		2) The ClassName hasn't changed		3) Someone defines the define method	Answer false if there is a problem, true otherwise"				| selector methodCollector filter receiver alternative oldNode superclass mainStatementNode oldStatementNode value |	mainStatementNode := aNodeHolder node block body statements first.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	oldNode := self parseDefinition: alternative value in: self owningEnvironment.	oldStatementNode := oldNode node block body statements first.	receiver := mainStatementNode receiver name.	oldStatementNode receiver name = receiver ifFalse:		[Dialog warn: #NamespaceMustNotChange &lt;&lt; #store &gt;&gt; 'NameSpace must not change'.		^false].	selector := mainStatementNode selector.	methodCollector := MethodCollector new.	filter := methodCollector implementorsOf: selector.	(methodCollector select: filter) isEmpty ifTrue:		[Dialog warn: #BadDefinitionMessage &lt;&lt; #store &gt;&gt; 'Bad Definition Message'.		^false].	oldStatementNode selector = selector ifFalse:		[Dialog warn: #DefinitionMessageMustNotChange &lt;&lt; #store &gt;&gt; 'Definition message must not change'.		^false].	('defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:*' match: selector asString) ifTrue: 		[((mainStatementNode arguments at: 3) value isSymbol) ifFalse:			[Dialog warn: #ParameterForIndexedTypeMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #indexedType: must be a Symbol'.			^false].		superclass := (mainStatementNode arguments at: 2) value asString.		(oldStatementNode arguments at: 2) value asString = superclass ifFalse:			[Dialog warn: #SuperclassMustNotChange &lt;&lt; #store &gt;&gt; 'Superclass must not change'.			^false].		((mainStatementNode arguments at: 4) value isKindOf: Boolean) ifFalse:			[Dialog warn: #ParameterForPrivateMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #private: must be a Boolean'.			^false].		((value := (mainStatementNode arguments at: 7) value) isString and: [value isSymbol not]) ifFalse:			[Dialog warn: #ParameterForImportsMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #imports: must be a String'.			^false].		((value := (mainStatementNode arguments at: 8) value) isString and: [value isSymbol not]) ifFalse:			[Dialog warn: #ParameterForCategoryMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #category: must be a String'.			^false]].	^true</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">browseVersions	| list session |	(Gathering for: self definitionName) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value package session].	list := Store.Glorp.StoreClassDefinitionInPackage				allVersionsWithName: self definitionName				inOwner: self longOwnerName				in: session.	(Gathering for: self definitionName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self definitionName)].	Store.Glorp.DefinitionForListTool forClasses: list</body><body package="Store-Merge Management">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[movePair notNil ifTrue: 			[^applied 				ifTrue: [self movedToPackageString]				ifFalse: [self moveToPackageString]].		^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">mergeDisplayName		^(#BracketClassDefinition &lt;&lt; #store &gt;&gt; '[Class Definition]') asString</body><body package="Store-Merge Management">moveFromPackageString	^self moveFromPackage: movePair proposed package name</body><body package="Store-Merge Management">moveToPackageString	^self moveToPackage: movePair proposed package name</body><body package="Store-Merge Management">movedFromPackageString	^self movedFromPackage: movePair proposed package name</body><body package="Store-Merge Management">movedToPackageString	^self movedToPackage: movePair proposed package name</body><body package="Store-Merge Management">shortListName	| string |	string := self ownerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management">movePair	^movePair</body><body package="Store-Merge Management">movePair: aClassChangeResolver	movePair := aClassChangeResolver</body></methods><methods><class-id>Store.SkipPrerequisite</class-id> <category>printing</category><body package="Atomic Compiling and Loading">defaultMessageText	^(#APrerequisiteNotLoaded &lt;&lt; #store		&gt;&gt; 'A Prerequisite has been not loaded') asString</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>comparing</category><body package="Store-User Management">&lt; aBlessing	^level &lt; aBlessing level</body><body package="Store-User Management">&lt;= aBlessing	^level &lt;= aBlessing level</body><body package="Store-User Management">= aBlessing	^self class = aBlessing class		and: [self level = aBlessing level]</body><body package="Store-User Management">hash	^level hash</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>types</category><body package="Store-User Management">beAdminOnly	type := #admin</body><body package="Store-User Management">beNormal	"Remove any type restrictions."	type := nil</body><body package="Store-User Management">beOwnerOnly	type := #owner</body><body package="Store-User Management">beQaOnly	type := #qa</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>testing</category><body package="Store-User Management">isAdminOnly	^type == #admin</body><body package="Store-User Management">isOwnerOnly	^type == #owner</body><body package="Store-User Management">isQaOnly	^type == #qa</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>printing</category><body package="Store-User Management">printOn: aStream	aStream nextPutAll: name.	type == nil		ifFalse: [ aStream nextPut: $-; nextPutAll: type ].	aStream 		nextPut: $(;		nextPutAll: level printString;		nextPut: $).</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>accessing</category><body package="Store-User Management">level	^level</body><body package="Store-User Management">level: anInteger	level := anInteger</body><body package="Store-User Management">name	^name</body><body package="Store-User Management">name: aString	name := aString</body></methods><methods><class-id>Store.BlessingLevel class</class-id> <category>instance creation</category><body package="Store-User Management">name: aString level: anInteger	^self new		name: aString;		level: anInteger;		yourself.</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs">postOpenWith: aBuilder 	self updateUserGroupList.	self updateBundleList.	self setButtons.	self updateText.	self mainWindow label: #BundleUserGroupPrivliges &lt;&lt; #store &gt;&gt; 'Bundle - User / Group Privileges'.	(self widgetAt: #pundleLabel) labelString: (#BundleC &lt;&lt; #store &gt;&gt; 'Bundle:') asString</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>private</category><body package="Store-UI-Graphs">updateBundleList		| bundlesOfAllKinds |	bundlesOfAllKinds := Store.Registry allBundles.	StoreBundle allNames do: 		[:each | 		(bundlesOfAllKinds contains: [:eachBundle | eachBundle name = each]) ifFalse: 			[bundlesOfAllKinds add: (StoreBundle newNamed: each)]].	self packageList list: (bundlesOfAllKinds asSortedCollection: [:a :b | a name &lt; b name]) asOrderedCollection</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>actions</category><body package="Store-UI-Graphs">grant: aSymbol		| owner workingBundle |	owner := userGroupList selection.	packageList selections do:		[:eachBundle | 		workingBundle := StoreBundle newestVersionWithName: eachBundle name.		workingBundle withAllItems asSet do: [:eachPundle | self privilegeManager grant: aSymbol to: owner for: eachPundle]].	self updateText.	self setButtons</body><body package="Store-UI-Graphs">revokeRights		| owner workingBundle |	owner := userGroupList selection.	packageList selections do: 		[:each | 		workingBundle := StoreBundle newestVersionWithName: each name.		workingBundle withAllItems asSet do: [:eachItem | self privilegeManager revokeAllFor: owner for: eachItem]].	self updateText.	self setButtons</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>accessing</category><body package="Store-Database Model">asDBComponent	^self</body><body package="Store-Database Model">basicContents	^contents.</body><body package="Store-Database Model">basicContents: aStoreBlob	contents := aStoreBlob.</body><body package="Store-Database Model">basicFilename	^filename</body><body package="Store-Database Model">basicFilename: aByteArray	filename := aByteArray.</body><body package="Store-Database Model">basicSource	^self basicContents.</body><body package="Store-Database Model">bossDecode: aByteArray		| stream bos result |	Dialect isVisualWorks ifFalse: [self error: 'Requires BOSS'].	aByteArray ifNil: [^nil].	stream := ReadStream on: aByteArray asByteArray.	bos := (Dialect smalltalkAt: #BinaryObjectStorage) onOld: stream.	result := bos next.	bos close.	^result</body><body package="Store-Database Model">bossEncode: anObject		| stream bos |	Dialect isVisualWorks ifFalse: [self error: 'Requires BOSS'].	stream := WriteStream on: ByteArray new.	bos := (Dialect smalltalkAt: #BinaryObjectStorage) onNew: stream.	bos nextPut: anObject.	bos close.	^stream contents</body><body package="Store-Database Model">bundle: aBundleModel	"For compatibility. I think we can just ignore it"	^self.</body><body package="Store-Database Model">contents	^contents binaryData.</body><body package="Store-Database Model">contents: aByteArray	contents := StoreBinaryBlob forByteArray: aByteArray.</body><body package="Store-Database Model">fileSize	^fileSize</body><body package="Store-Database Model">fileSize: anObject	fileSize := anObject</body><body package="Store-Database Model">filename	^Dialect isVisualWorks		ifTrue: [decodedFilename ifNil: [decodedFilename := (Dialect smalltalkAt: #LogicalFilename) fromComponents: (self bossDecode: filename)]]		ifFalse: [self error: 'VisualWorks specific code'].</body><body package="Store-Database Model">filename: aFilename	filename := self bossEncode: ((decodedFilename := aFilename asLogicalFileSpecification) componentStrings).</body><body package="StoreForGlorpVWUI">md5Value	^self basicContents binaryData md5Value</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	contents := contents glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>reconciling</category><body package="Store-Database Model">reconcilesWith: aStoreFile	self fileSize = aStoreFile fileSize ifFalse: [^false].	self filename = aStoreFile filename ifFalse: [^false].	self contents = aStoreFile contents ifFalse: [^false].	^true.</body><body package="Store-Database Model">unreconcile	super unreconcile.	contents unreconcile.</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI">asComponentDescription		| fileModel |	fileModel := Store.FileModel new.	fileModel dbTrace: primaryKey.	primaryKey notNil ifTrue: [fileModel portableFilename: self filename].	^fileModel</body><body package="Store-Database Model">asComponentDescriptionForReal	"Return a representation of ourselves as a store component description, used to update the image after a publish."	| baby |	baby := Store.FileModel new.	baby dbTrace: primaryKey.	primaryKey notNil		ifTrue: [ baby portableFilename: self filename ].	^baby</body><body package="Store-Database Model">download	"Download the file. Answer whether we did so successfully."	^self downloadTo: self filename</body><body package="Store-Database Model">downloadTo: aFilename	"Download the file. Answer whether we did so successfully."		| fileContents validFIlename stream |	(fileContents := self contents) ifNil:		[Dialog warn: (#IsEmpty &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is empty' expandMacrosWith: self filename).		^false].	(validFIlename := self validateFilenameForDownload: aFilename) ifNil: 		[^false].	stream := validFIlename writeStream binary.	[stream nextPutAll: fileContents] ensure: [stream close].	^true</body><body package="Store-Database Model">fileID	^contents primaryKey</body><body package="Store-Database Model">fileRef	^self primaryKey</body><body package="Store-Database Model">portableFilename	^self filename</body><body package="Store-Database Model">validateFilenameForDownload: aFilename	"Validate that a file can be written. Answer the filename to be used."		| targetFilename |	targetFilename := aFilename.	[targetFilename canBeWritten]		whileFalse:			[targetFilename := (Dialog				request: #PleaseEnterAValidFAmeForThisPlatform &lt;&lt; #store &gt;&gt; 'Please enter a valid filename for this platform'				initialAnswer: targetFilename asString				onCancel: [^nil]) asFilename].	^targetFilename</body></methods><methods><class-id>Store.Glorp.StoreFile class</class-id> <category>instance creation</category><body package="Store-Database Model">allFromBundleID: anInteger	^(StoreBundle withPrimaryKey: anInteger) 		ifNil: [#()]		ifNotNil: [:value | value files]</body><body package="Store-Database Model">fromFileRecord: aFileModel	"We can't rely on FileRecord actually existing in this image, so convert it from this end and assume we know the right instance variables"	| result |	result := self new.	result privateSetPrimaryKey: aFileModel primaryKey.	result name: aFileModel name.	result filename: aFileModel name.	result filename exists ifTrue: [		| stream bits |		[			stream := result filename readStream.		stream binary.		bits := stream upToEnd.		result contents: bits.		result fileSize: bits size]			ensure: [stream close]].	^result</body><body package="Store-Database Model">named: aString bits: bits	^self new name: aString; filename: aString; contents: bits; fileSize: bits size.</body></methods><methods><class-id>Store.ElementView</class-id> <category>private</category><body package="Store-UI-Graphs">doLayout	| pt |	pt := 0.	self hasIn == 0		ifTrue: [pt := pt + 9 + 2]		ifFalse: 			[| inBut inLf inWid |			inBut := self inButton.			inWid := inBut preferredWidth + 2.			inLf := LayoutFrame new.			inLf				bottomFraction: 1;				topOffset: 1;				leftOffset: pt;				rightOffset: pt + inWid.			self add: inBut in: inLf.			pt := pt + inWid].	label := self elLabelFor: element at: pt @ 0.	label := self findTopmostWrapperFor: label.	pt := label bounds corner x.	firstPovIconX := pt + 2.	self hasOut == 0		ifFalse: 			[| outBut outLf outWid |			outBut := self outButton.			outWid := outBut preferredWidth.			outLf := LayoutFrame new.			outLf				bottomFraction: 1;				topOffset: 1;				leftOffset: [self outButtonXPosition];				rightOffset: [self outButtonXPosition + outWid].			self add: outBut in: outLf]</body></methods><methods><class-id>Store.ElementView</class-id> <category>initialize-release</category><body package="Store-UI-Graphs">inButton	"creates the button for opening and closing the incoming 	relationships. cyev is self"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasIn == true]		putBlock: self inButtonPutBlock		updateBlock: [:m :a :p | false].	v := Lens.LDMArrowView model: pa fullImage: FullInArrow emptyImage: EmptyInArrow.	v controller beToggle.	v label: ''.	^v</body><body package="Store-UI-Graphs">outButton	"same as inButton but for outgoing relationships"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasOut == true]		putBlock: self outButtonPutBlock		updateBlock: [:m :a :p | false].	v := Lens.LDMArrowView model: pa fullImage: FullOutArrow emptyImage: EmptyOutArrow.	v controller beToggle.	v label: ''.	^v</body></methods><methods><class-id>Store.ElementView class</class-id> <category>class initialization</category><body package="Store-UI-Graphs">initialize	"self initialize"	EmptyInArrow := self emptyInImage.	EmptyOutArrow := self emptyOutImage.	FullInArrow := self fullInImage.	FullOutArrow := self fullOutImage.</body></methods><methods><class-id>Store.LoadOrSaveEvaluationError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog warn: (#_1sErrorEvaluating2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: Error evaluating &lt;2s&gt;'		expandMacrosWith: messageText first 		with: messageText last)</body></methods><methods><class-id>Store.Glorp.StoreLoginFactory class</class-id> <category>instance creation</category><body package="Store-Database Model">convertStoreLogin: aStoreConnectionProfile	"Convert a regular store connection login into a Glorp Login object."	aStoreConnectionProfile isNil ifTrue: [^nil].	^StoreLogin newFromConnectionProfile: aStoreConnectionProfile</body><body package="Store-Database Model">currentStoreSession	"Return a glorp session connected to the current store database and using its connection.  #doIfOnlineImage returns self, not nil, if we are not connected and fail to become so (which is the wrong choice as it returns the block's value, not self, if we are connected or become so).  We code this to ensure we return nil if we cannot ensure being online."	| session |	Store.DbRegistry doIfOnlineImage:		[session := self currentStoreSessionFromProfile: Store.DbRegistry connectedProfile].	^session ifNil: [Store.DbRegistry currentlyNotConnectedSignal raiseSignal]</body><body package="Store-Database Model">currentStoreSessionForPublishing	"Return a (new) GlorpSession connected to the current store database, using the same connection but a new system optimised for faster publishing (and slower reading) by not fetching source code of unmodified packages."	| newSession nonSourceFetchingQuery methodMapping |	newSession := self currentStoreSession.	methodMapping := (newSession system descriptorFor: StorePackage)		mappingForAttributeNamed: #methods.	nonSourceFetchingQuery := methodMapping buildQuery.	nonSourceFetchingQuery		collectionType: OrderedCollection;	"quick-fix Glorp bug (since mid-2005, revealed by this): query accepts GlorpVirtualCollection as collection type, then DNUs"		tracing: nonSourceFetchingQuery defaultTracing;		alsoFetch: [:each | each definition].	methodMapping privateAndBasicSetQuery: nonSourceFetchingQuery.	^newSession</body><body package="Store-Database Model">currentStoreSessionFromProfile: aConnectionProfile	"Return a glorp session connected to the store database of the supplied profile."	| login |	login := self convertStoreLogin: aConnectionProfile.	login isNil ifTrue: [^nil].	^Store.DbRegistry createSessionForLogin: login</body><body package="Store-Database Model">sessionForStoreLogin: aStoreConnectionProfile	"Return a glorp session connected to the indicated Store database and configured for Store."	| aLogin |	aLogin := self convertStoreLogin: aStoreConnectionProfile.	^Store.DbRegistry createSessionForLogin: aLogin</body></methods><methods><class-id>Store.Merging</class-id> <category>accessing</category><body package="Store-Merge Management">actionText	^(#Merging &lt;&lt; #store &gt;&gt; 'Merging') asString</body><body package="Store-Merge Management">componentName	^self codeComponent 		ifNotNil: [:value | value isString ifTrue: [value] ifFalse: [value shortItemString]]		ifNil: [self actionText]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus</category><body package="Store-Difference Management">classesMenu	^(self mainMenu atNameKey: #AmpClass) submenu</body><body package="Store-Difference Management">definitionMenu	definitionMenu ifNotNil: [^definitionMenu].	definitionMenu := Menu				labelList: (Array with: (Array								with: #DoIt &lt;&lt; #dialogs &gt;&gt; 'Do it'								with: #PrintIt &lt;&lt; #dialogs &gt;&gt; 'Print it'								with: #InspectIt &lt;&lt; #dialogs &gt;&gt; 'Inspect it'								with: #DebugIt &lt;&lt; #dialogs &gt;&gt; 'Debug it')						with: (Array with: #Explain &lt;&lt; #menus &gt;&gt; 'Explain'))							, TextEditorController editGroupLabels				values: #(#doIt #printIt #inspectIt #debugIt #explain)						, TextEditorController editGroupSelectors.	TextEditorController decorateTextItemsIn: definitionMenu.	TextEditorController decorateEvaluationItemsIn: definitionMenu.	^definitionMenu</body><body package="Store-Difference Management">mainMenu	| menu |	menu := self class mainMenu.	menu		augmentFrom: self class		to: self class		menuName: #mainMenu		for: self.	^menu</body><body package="Store-Difference Management">methodsMenu	^(self mainMenu atNameKey: #AmpDefinition) submenu</body><body package="Store-Difference Management">noMenu	^Menu new</body><body package="Store-Difference Management">packageMenu	^(self mainMenu atNameKey: #AmpPackage) submenu</body><body package="Store-Difference Management">textController	^(self widgetAt: #FromDefinition) controller</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>private interface configuration</category><body package="Store-Difference Management">bothObjectEmphasisSelected: aBoolean		^#bold</body><body package="Store-Difference Management">bothObjectsIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean		(aClassNamespaceOrPropertiesDifference isMainDefinedInPackage or: [aClassNamespaceOrPropertiesDifference isOtherDefinedInPackage])		ifFalse: [^#none].	^#bold</body><body package="Store-Difference Management">classAndPseudoLabelUsing: aClassNamespaceOrPropertiesDifference in: aSelectionInList selected: aBoolean	| mainString iconPart |	mainString := aClassNamespaceOrPropertiesDifference classListName asText.	aClassNamespaceOrPropertiesDifference hasBothDefinitions		ifTrue: [mainString emphasizeAllWith: (self bothObjectsIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean)]		ifFalse: 			[aClassNamespaceOrPropertiesDifference hasOnlyMainDefinition				ifTrue: [mainString emphasizeAllWith: (self mainObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean)]				ifFalse: [mainString emphasizeAllWith: (self otherObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean)]].	iconPart := LabelAndIcon 		with: mainString		attributes: aSelectionInList textStyle.	iconPart icon: aClassNamespaceOrPropertiesDifference classListIcon.	iconPart offset: 2 @ 0.	^iconPart</body><body package="Store-Difference Management">compositeViewUsing: aPackageComparitor startingAt: anInteger in: aSequenceView selected: aBoolean	| mainPackageLabel otherPackageLabel currentStart mainString differLabel mainThing iconPart otherString secondIconPart |	mainString := aPackageComparitor mainVersionNameString.	otherString := aPackageComparitor otherVersionNameString.	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aPackageComparitor mainPackage toolListIcon.	currentStart := iconPart width + 2.	mainPackageLabel := Label				with: (mainString asText						emphasizeAllWith: (self mainObjectEmphasisSelected: aBoolean))				attributes: aSequenceView textStyle				offset: currentStart @ 0.	currentStart := currentStart + anInteger.	differLabel := Label				with: ' ==&gt; ' asText				attributes: aSequenceView textStyle				offset: currentStart @ 0.	currentStart := differLabel width + 2.	secondIconPart := LabelAndIcon with: '' offset: currentStart @ 0.	secondIconPart icon: aPackageComparitor otherPackage toolListIcon.	currentStart := secondIconPart width + 2.	otherPackageLabel := Label				with: (otherString asText						emphasizeAllWith: (self otherObjectEmphasisSelected: aBoolean))				attributes: aSequenceView textStyle				offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: mainPackageLabel;		add: differLabel;		add: secondIconPart;		add: otherPackageLabel;		yourself.	^mainThing</body><body package="Store-Difference Management">mainObjectEmphasisSelected: aBoolean	^aBoolean 		ifTrue: [#bold]		ifFalse: [(Array with: #bold with: #color -&gt; ColorValue blue)]</body><body package="Store-Difference Management">mainObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean	| emphasis |	emphasis := aClassNamespaceOrPropertiesDifference isMainDefinedInPackage 		ifTrue: [#bold]		ifFalse: 			[ | targetObject|			targetObject := aClassNamespaceOrPropertiesDifference mainClassStoreObject.			targetObject isNil				ifTrue: [#none]				ifFalse:					[(targetObject isForClassOrExtension 						ifTrue: [targetObject isImageObject ifTrue: [targetObject] ifFalse: [targetObject correspondingImageClass]]						ifFalse: [(targetObject isForSharedVariable ifTrue: [targetObject correspondingImageBinding] ifFalse: [targetObject correspondingImageNamespace])])							ifNil: [#italic]							ifNotNil: [#none]]].	^aBoolean 		ifTrue: [emphasis]		ifFalse: [(Array with: emphasis with: #color -&gt; ColorValue blue)]</body><body package="Store-Difference Management">methodOrPropertiesLabelUsing: aMethodOrSharedOrPropertyDifference in: aSelectionInList selected: aBoolean	| mainString iconPart |	mainString := aMethodOrSharedOrPropertyDifference selectorListName asText.	aMethodOrSharedOrPropertyDifference hasBothDefinitions		ifTrue: [mainString emphasizeAllWith: (self bothObjectEmphasisSelected: aBoolean)]		ifFalse: 			[aMethodOrSharedOrPropertyDifference hasOnlyMainDefinition				ifTrue: [mainString emphasizeAllWith: (self mainObjectEmphasisSelected: aBoolean)]				ifFalse: [mainString emphasizeAllWith: (self otherObjectEmphasisSelected: aBoolean)]].	iconPart := LabelAndIcon 		with: mainString		attributes: aSelectionInList textStyle.	iconPart icon: aMethodOrSharedOrPropertyDifference selectorListIcon.	iconPart offset: 2 @ 0.	^iconPart</body><body package="Store-Difference Management">otherObjectEmphasisSelected: aBoolean		^aBoolean 		ifTrue: [#bold]		ifFalse: [(Array with: #bold with: #color -&gt; ColorValue purple)]</body><body package="Store-Difference Management">otherObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean	| emphasis |	emphasis := aClassNamespaceOrPropertiesDifference isOtherDefinedInPackage 		ifTrue: [#bold]		ifFalse: 			[ | targetObject|			targetObject := aClassNamespaceOrPropertiesDifference otherClassStoreObject.			targetObject isNil				ifTrue: [#none]				ifFalse:					[(targetObject isForClassOrExtension 						ifTrue: [targetObject isImageObject ifTrue: [targetObject] ifFalse: [targetObject correspondingImageClass]]						ifFalse: [targetObject isForSharedVariable ifTrue: [targetObject correspondingImageBinding] ifFalse: [targetObject correspondingImageNamespace]])							ifNil: [#italic]							ifNotNil: [#none]]].	^aBoolean 		ifTrue: [emphasis]		ifFalse: [(Array with: emphasis with: #color -&gt; ColorValue purple)]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>aspects</category><body package="Store-Difference Management">classesAndProperties	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classesAndProperties isNil		ifTrue:			[classesAndProperties := SelectionInList new]		ifFalse:			[classesAndProperties]</body><body package="Store-Difference Management">comparedPackages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^comparedPackages isNil		ifTrue:			[comparedPackages := SelectionInList new]		ifFalse:			[comparedPackages]</body><body package="Store-Difference Management">fromDefinition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fromDefinition isNil		ifTrue:			[fromDefinition := String new asValue]		ifFalse:			[fromDefinition]</body><body package="Store-Difference Management">fromProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fromProtocol isNil		ifTrue:			[fromProtocol := Text new asValue]		ifFalse:			[fromProtocol]</body><body package="Store-Difference Management">methodsOrProperties	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^methodsOrProperties isNil		ifTrue:			[methodsOrProperties := MultiSelectionInList new]		ifFalse:			[methodsOrProperties]</body><body package="Store-Difference Management">selectionType	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectionType isNil		ifTrue:			[selectionType := nil asValue]		ifFalse:			[selectionType]</body><body package="Store-Difference Management">toDefinition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^toDefinition isNil		ifTrue:			[toDefinition := String new asValue]		ifFalse:			[toDefinition]</body><body package="Store-Difference Management">toProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^toProtocol isNil		ifTrue:			[toProtocol := Text new asValue]		ifFalse:			[toProtocol]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - dynamic</category><body package="Store-Difference Management">mainPackageVersionName	self comparedPackages selection ifNil: [^''].	^self comparedPackages selection mainPackage versionString.</body><body package="Store-Difference Management">otherPackageVersionName	self comparedPackages selection ifNil: [^''].	^self comparedPackages selection otherPackage versionString.</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>private</category><body package="Store-Difference Management">allClasses	| definedClasses |	definedClasses := Dictionary new.	comparedDifferences do:		[:each |		each mainPackageClasses, each otherPackageClasses do:			[:eachClass |			definedClasses at: eachClass name ifAbsentPut: [each -&gt; eachClass]]].	^definedClasses</body><body package="Store-Difference Management">browseImagePackage: aPackage		Refactory.Browser.RefactoringBrowser openOnEnvironment: (Refactory.Browser.PundleEnvironment new pundles: (List with: aPackage))</body><body package="Store-Difference Management">browseStorePackage: aPackage	(Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: (Store.Glorp.StoreForGlorpBrowserEnvironment on: aPackage)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-Difference Management">fileNameForDefinitionsUsing: targetString		| fileName |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (targetString , '-definitions' replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	^fileName</body><body package="Store-Difference Management">fileOutClassNamespaceOrShared: aStoreObject definedIn: aStorePackage		| fileName sourceCodeStream |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: ((aStoreObject longNameFromSmalltalk) replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: aStoreObject) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | aStorePackage name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aStorePackage name].			[sourceCodeStream timeStamp.			aStoreObject fileOutOn: sourceCodeStream] 				ensure: [sourceCodeStream close].			(FilingOut for: aStoreObject) finished].</body><body package="Store-Difference Management">fileOutPackage: aPackage		| fileName fileManager |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: aPackage name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: aPackage) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager sourceFormatter attributeFor: #package compute: [:ignore | aPackage name].			fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aPackage name].			aPackage fileOutOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: aPackage) finished].</body><body package="Store-Difference Management">fileOutSharedsFrom: aNamespaceString definedIn: aStorePackage		| fileName sourceCodeStream |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (('Root.Smalltalk.', aNamespaceString) replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: aNamespaceString) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | aStorePackage name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aStorePackage name].			[sourceCodeStream timeStamp.			(aStorePackage sharedVariablesForNamespaceNamed: 'Root.Smalltalk.', aNamespaceString) do:				[:each | each fileOutOn: sourceCodeStream]] 				ensure: [sourceCodeStream close].			(FilingOut for: aNamespaceString) finished].</body><body package="Store-Difference Management">findClassIn: aDictionary matching: aString	| results pattern |	aString isEmpty ifTrue: [^Array new].	results := IdentitySet new: 100.	pattern := aString last = $*		ifTrue:			[results add: #*.			aString]		ifFalse: [aString , '*'].	aDictionary do:		[:each |		(pattern match: each value name) ifTrue:			[results add: each value name.			results size &gt; 500 ifTrue: [^results sorted]]].	^results sorted</body><body package="Store-Difference Management">loadClass: aStoreObject fromPackage: aPackage removing: aCollection		StoreProgressOverlay		subsume: builder window		while:			[(Loading for: aPackage) started.			Store.Policies packagePolicy 				forcePackage: aPackage storeModel				while: 					[aStoreObject loadSource.					self removeObjects: aCollection fromPackage: aPackage].			(Loading for: aPackage) finished].</body><body package="Store-Difference Management">mainClassNameFrom: selection		| targetString |	targetString := selection isNamespace		ifTrue: [selection mainNamespace asString]		ifFalse: [selection isClass ifTrue: [selection mainClassLongName] ifFalse: [selection mainPackage name]].	^targetString</body><body package="Store-Difference Management">openBrowserOnClasses: aCollection definedIn: aStorePackageOrImageModel		aStorePackageOrImageModel isImageModel ifTrue: 		[^RefactoringBrowser openOnEnvironment: (BrowserEnvironment new forClasses: aCollection)].	Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: ((StoreForGlorpBrowserEnvironment on: aStorePackageOrImageModel) forClasses: aCollection)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false</body><body package="Store-Difference Management">otherClassNameFrom: selection		| targetString |	targetString := selection isNamespace		ifTrue: [selection otherNamespace asString]		ifFalse: [selection isClass ifTrue: [selection otherClassLongName] ifFalse: [selection otherPackage name]].	^targetString</body><body package="Store-Difference Management">packagesContaining: target in: package		| packages storeObject |	storeObject := target isImageObject		ifTrue: [(package asStorePundleIn: storeSession) objectNamed: target longName]		ifFalse: [target].	StoreProgressOverlay		subsume: builder window		while:			[(Gathering for: storeObject) started.			packages := storeObject isForNameSpace 				ifTrue: [StoreNamespaceInPackage allPackagesContaining: storeObject in: storeSession]				ifFalse: [StoreClassDefinitionInPackage allPackagesContaining: storeObject in: storeSession].			(Gathering for: storeObject) finished].	DefinitionForListTool forPackages: packages</body><body package="Store-Difference Management">redrawTextPanes	(self widgetAt: #FromDefinition) invalidateNow.	(self widgetAt: #ToDefinition) invalidateNow.</body><body package="Store-Difference Management">removeObjects: aCollection fromPackage: aPackage	StoreProgressOverlay		subsume: builder window		while: 			[(Loading for: aPackage) started.			aCollection do: [:each | each removeFromImage].			(Loading for: aPackage) finished].</body><body package="Store-Difference Management">setRawDifferences: aCollection	rawDifferences := aCollection</body><body package="Store-Difference Management">storeSession: aSession	storeSession := aSession</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - actions - Package</category><body package="Store-Difference Management">browseMainPackage	| package |	package := self comparedPackages selection mainPackage.	package isImageModel		ifTrue: [self browseImagePackage: package]		ifFalse: [self browseStorePackage: package]</body><body package="Store-Difference Management">browseOtherPackage	| package |	package := comparedPackages selection otherPackage.	package isImageModel		ifTrue: [self browseImagePackage: package]		ifFalse: [self browseStorePackage: package]</body><body package="Store-Difference Management">browseVersions	| selection targetPackage |	selection := comparedPackages selection.	(targetPackage := selection mainPackage) pseudoPackage ifTrue: 		[targetPackage := selection otherPackage].	DefinitionForListTool forPackages: targetPackage allStoreVersions</body><body package="Store-Difference Management">compareMainPackage	| target fromPackage session |	fromPackage := self comparedPackages selection mainPackage.	session := fromPackage session.	target := StorePackage selectStoreVersionOf: fromPackage name in: session.	target ifNil: [^self].	self collectDifferencesFrom: (Array with: (Array with: fromPackage with: target)).	self comparedPackages selectionIndex: (self comparedPackages list size)</body><body package="Store-Difference Management">compareOtherPackage		| target fromPackage session |	fromPackage := self comparedPackages selection otherPackage.	session := fromPackage session.	target := StorePackage selectStoreVersionOf: fromPackage name in: session.	target ifNil: [^self].	self collectDifferencesFrom: (Array with: (Array with: fromPackage with: target)).	self comparedPackages selectionIndex: self comparedPackages list size</body><body package="Store-Difference Management">fileOutMainPackage		| package |	package := comparedPackages selection mainPackage.	self fileOutPackage: package</body><body package="Store-Difference Management">fileOutMainToOtherPackageDifference		| packageComparitor fileName package fileManager |	packageComparitor := comparedPackages selection.	package := packageComparitor mainPackage.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: package name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager sourceFormatter attributeFor: #package compute: [:ignore | package name].			fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			packageComparitor fileOutMainToOtherDifferencesOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management">fileOutOtherPackage		| package |	package := comparedPackages selection otherPackage.	self fileOutPackage: package</body><body package="Store-Difference Management">fileOutOtherToMainPackageDifference		| packageComparitor fileName package fileManager |	packageComparitor := comparedPackages selection.	package := packageComparitor mainPackage.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: package name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager sourceFormatter attributeFor: #package compute: [:ignore | package name].			fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			packageComparitor fileOutOtherToMainDifferencesOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management">findClass	| dialog searchString searcher allClasses comparitor targetClass targetPseudo |	allClasses := self allClasses.	searcher := (IncrementalSearchModule new)		firstLabel: #FindClass &lt;&lt; #dialogs &gt;&gt; 'Find Class';		secondLabel: #ClassesC &lt;&lt; #labels &gt;&gt; 'Classes:';		searchBlock: [:string | self findClassIn: allClasses matching: string];		objectToStringBlock: [:object | object];		useEagerSelection: true;		pasteSelected: false.	dialog := (IncrementalSearchDialog new)		module: searcher;		requireSelection: true.	searchString := dialog select.	(searchString isNil or: [searchString isEmpty]) 		ifTrue: [^self].	comparitor := (allClasses at: searchString) key.	self comparedPackages selection: comparitor.	targetClass :=  (allClasses at: searchString) value.	targetPseudo := self classesAndProperties list		detect: [:each | each classListName = targetClass longName]		ifNone: [^self].	self classesAndProperties selection: targetPseudo</body><body package="Store-Difference Management">graphMainVersion	| pundle |	pundle := comparedPackages selection mainPackage.	pundle isImageModel ifFalse: [pundle := pundle class cachedItemFor: pundle].	VersionGraph browseVersionsOfPundle: pundle.</body><body package="Store-Difference Management">graphOtherVersion	| pundle |	pundle := comparedPackages selection otherPackage.	pundle isImageModel ifFalse: [pundle := pundle class cachedItemFor: pundle].	VersionGraph browseVersionsOfPundle: pundle.</body><body package="Store-Difference Management">loadMainPackage	comparedPackages selection mainPackage loadSource</body><body package="Store-Difference Management">loadOtherPackage	comparedPackages selection otherPackage loadSource</body><body package="Store-Difference Management">mergeMainIntoImage	| package target |	package := comparedPackages selection mainPackage.	target := package isBundle		ifTrue: [StoreBundle pundleWithName: package name version: package version in: package session]		ifFalse: [StorePackage pundleWithName: package name version: package version in: package session].	Store.Glorp.MergeTool alwaysOpenMergeTool		ifTrue: [Store.Glorp.MergeTool openOnPundle: target]		ifFalse: [[Store.Glorp.ResolutionManager doMergeOnPundle: target] withStoreFeedbackOn: self mainWindow]</body><body package="Store-Difference Management">mergeOtherIntoImage	| package target |	package := comparedPackages selection otherPackage.	target := package isBundle		ifTrue: [StoreBundle pundleWithName: package name version: package version in: package session]		ifFalse: [StorePackage pundleWithName: package name version: package version in: package session].	Store.Glorp.MergeTool alwaysOpenMergeTool		ifTrue: [Store.Glorp.MergeTool openOnPundle: target]		ifFalse: [[Store.Glorp.ResolutionManager doMergeOnPundle: target] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - actions - Class</category><body package="Store-Difference Management">browseClassVersions	| selection |	selection := self classesAndProperties selection.	[selection isNamespace		ifTrue: [DefinitionForListTool forNameSpaces: (selection mainClassStoreObject ifNil: [selection otherClassStoreObject]) allStoreVersions]		ifFalse: [	DefinitionForListTool forClasses: (selection mainClassStoreObject ifNil: [selection otherClassStoreObject]) allStoreVersions]] withStoreFeedbackOn: self mainWindow</body><body package="Store-Difference Management">browseMainClass		| package target objects |	package := self comparedPackages selection mainPackage.	target := package objectNamed: self classesAndProperties selection mainClassLongName.	objects := OrderedCollection with: target.	target isImageObject 		ifTrue: [target isForClass ifTrue: [objects add: target class]]		ifFalse: [target isClass ifTrue: [objects add: target storeMetaClass]].	self openBrowserOnClasses: objects definedIn: package</body><body package="Store-Difference Management">browseOtherClass		| package target objects |	package := self comparedPackages selection otherPackage.	target := package objectNamed: self classesAndProperties selection otherClassLongName.	objects := OrderedCollection with: target.	target isClass ifTrue: [objects add: target storeMetaClass].	self openBrowserOnClasses: objects definedIn: package</body><body package="Store-Difference Management">fileOutMainClass		| selection targetString storeObject package |	selection := self classesAndProperties selection.	targetString := self mainClassNameFrom: selection.	storeObject := (package := self comparedPackages selection mainPackage) objectNamed: targetString.	storeObject ifNil: [^self fileOutSharedsFrom: targetString definedIn: package].	self fileOutClassNamespaceOrShared: storeObject definedIn: package</body><body package="Store-Difference Management">fileOutOtherClass		| selection targetString storeObject package |	selection := self classesAndProperties selection.	targetString := self otherClassNameFrom: selection.	storeObject := (package := self comparedPackages selection otherPackage) objectNamed: targetString.	storeObject ifNil: [^self fileOutSharedsFrom: targetString definedIn: package].	self fileOutClassNamespaceOrShared: storeObject definedIn: package</body><body package="Store-Difference Management">loadMainClass	| selection targetString storeObject package removeObjects |	selection := self classesAndProperties selection.	targetString := selection isNamespace		ifTrue: [selection mainNamespace asString]		ifFalse: 			[selection isClass				ifTrue: [selection mainClassLongName]				ifFalse: [selection mainObject]].	storeObject := (package := (self comparedPackages selection mainPackage asStorePundleIn: storeSession)) objectNamed: targetString.	removeObjects := (selection methodDifferences select: [:each | each mainPackage isNil]) collect: [:each | each otherObject].	removeObjects addAll: ((selection sharedDifferences select: [:each | each mainPackage isNil]) collect: [:each | each otherObject]).	self loadClass: storeObject fromPackage: package removing: removeObjects</body><body package="Store-Difference Management">loadOtherClass		| selection targetString storeObject package removeObjects |	selection := self classesAndProperties selection.	targetString := selection isNamespace		ifTrue: [selection otherNamespace asString]		ifFalse: 			[selection isClass 				ifTrue: [selection otherClassLongName] 				ifFalse: [selection otherObject]].	storeObject := (package := (self comparedPackages selection otherPackage asStorePundleIn: storeSession)) objectNamed: targetString.	removeObjects := (selection methodDifferences select: [:each | each otherPackage isNil]) collect: [:each | each mainObject].	removeObjects addAll: ((selection sharedDifferences select: [:each | each otherPackage isNil]) collect: [:each | each mainObject]).	self loadClass: storeObject fromPackage: package removing: removeObjects</body><body package="Store-Difference Management">packagesContainingMainObject		| package target |	package := self comparedPackages selection mainPackage.	target := package objectNamed: self classesAndProperties selection mainClassLongName.	self packagesContaining: target in: package</body><body package="Store-Difference Management">packagesContainingOtherObject		| package target |	package := self comparedPackages selection otherPackage.	target := package objectNamed: self classesAndProperties selection otherClassLongName.	self packagesContaining: target in: package</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - enablement</category><body package="Store-Difference Management">canActOnMainClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection mainClassStoreObject notNil</body><body package="Store-Difference Management">canActOnOtherClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection otherClassStoreObject notNil</body><body package="Store-Difference Management">canFileOutMainClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection hasMainDifferences</body><body package="Store-Difference Management">canFileOutMainDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasMainDifferences].</body><body package="Store-Difference Management">canFileOutOtherClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection hasOtherDifferences</body><body package="Store-Difference Management">canFileOutOtherDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasOtherDifferences].</body><body package="Store-Difference Management">canLoadMainDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasMainDifferences].</body><body package="Store-Difference Management">canLoadMainPackage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^(selection mainPackage pseudoPackage or: [selection mainPackage isImageModel]) not</body><body package="Store-Difference Management">canLoadOtherDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasOtherDifferences].</body><body package="Store-Difference Management">canLoadOtherPackage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^selection otherPackage pseudoPackage not</body><body package="Store-Difference Management">classObjectIsSelected	| selection |	selection := self classesAndProperties selection.	^self classesAndProperties selectionIndex &gt; 0 and: [selection isStandin not]</body><body package="Store-Difference Management">classObjectIsSelectedAndBrowsable	| selection |	selection := self classesAndProperties selection.	^self classObjectIsSelected and: [selection isNamespaceExtension not and: [selection isClassExtension not]]</body><body package="Store-Difference Management">instanceClassOrShared: aMenuItem	self selectionType value = #instance ifTrue: [^aMenuItem nameKey = #AmpInstanceMethods].	self selectionType value = #class ifTrue: [^aMenuItem nameKey = #AmpClassMethods].	self selectionType value = #shared ifTrue: [^aMenuItem nameKey = #AmpSharedVariables].	^false</body><body package="Store-Difference Management">mainClassIsNotExtension	| package target |	package := self comparedPackages selection mainPackage.	target := package definedObjectNamed: self classesAndProperties selection mainClassLongName.	^target notNil and: [target isExtension not]</body><body package="Store-Difference Management">mainPackageIsPseudo	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^selection mainPackage pseudoPackage</body><body package="Store-Difference Management">namespaceNotSelected	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection isNamespace not</body><body package="Store-Difference Management">otherClassIsNotExtension	| package target |	package := self comparedPackages selection otherPackage.	target := package definedObjectNamed: self classesAndProperties selection otherClassLongName.	^target notNil and: [target isExtension not]</body><body package="Store-Difference Management">otherPackageIsPseudo	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^selection otherPackage pseudoPackage</body><body package="Store-Difference Management">packageIsInImage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^(Registry packageNamed: (selection mainPackage ifNil: [selection otherPackage]) name) notNil</body><body package="Store-Difference Management">packageIsInImageButNotActualImage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	(selection mainPackage notNil and: [selection mainPackage = (Registry packageNamed: selection mainPackage name)])		ifTrue: [^false].	^(Registry packageNamed: (selection mainPackage ifNil: [selection otherPackage]) name) notNil</body><body package="Store-Difference Management">singleMainDefinitionObjectSelectedAndBrowseableForVersion	| selections |	selections := self methodsOrProperties selections.	^selections size = 1 and: [selections first isExtensionInMain not and: [selections first isPropertyDifference not]]</body><body package="Store-Difference Management">singleMethodObjectSelectedAndBrowseable	| selections |	selections := self methodsOrProperties selections.	^selections size = 1 and: [selections first isStandin not]</body><body package="Store-Difference Management">singleOtherDefinitionObjectSelectedAndBrowseableForVersion	| selections |	selections := self methodsOrProperties selections.	^selections size = 1 and: [selections first isExtensionInOther not and: [selections first isPropertyDifference not]]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - actions - Definitions</category><body package="Store-Difference Management">browseDefinitionVersions	| selection methodOrShared |	selection := self methodsOrProperties selections first.	methodOrShared := selection mainClassStoreObject ifNil: [selection otherClassStoreObject].	methodOrShared isForSharedVariable		ifTrue: [DefinitionForListTool forSharedVariables: methodOrShared allStoreVersions]		ifFalse: [DefinitionForListTool forMethods: methodOrShared allStoreVersions]</body><body package="Store-Difference Management">fileOutMainDefinitions		| selections targets targetString fileName package sourceCodeStream storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasMainDifferences].	targets isEmpty ifTrue: [^self].	targetString := self mainClassNameFrom: self classesAndProperties selection.	(fileName := self fileNameForDefinitionsUsing: targetString) ifNil: [^self].	package :=  self comparedPackages selection mainPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | package name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			[sourceCodeStream timeStamp.			targets do: [:each | each fileOutMainOn: sourceCodeStream from: storeObject]] 				ensure: [sourceCodeStream close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management">fileOutOtherDefinitions		| selections targets targetString fileName package sourceCodeStream storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasOtherDifferences].	targets isEmpty ifTrue: [^self].	targetString := self otherClassNameFrom: self classesAndProperties selection.	(fileName := self fileNameForDefinitionsUsing: targetString) ifNil: [^self].	package :=  self comparedPackages selection otherPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | package name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			[sourceCodeStream timeStamp.			targets do: [:each | each fileOutOtherOn: sourceCodeStream from: storeObject]] 				ensure: [sourceCodeStream close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management">loadMainDefinitions	| selections targets targetString package storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasMainDifferences].	targets isEmpty ifTrue: [^self].	targetString := self mainClassNameFrom: self classesAndProperties selection.	package :=  self comparedPackages selection mainPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(Loading for: package) started.			targets do: [:each | each loadMainDefinitionFrom: storeObject].			(Loading for: package) finished].</body><body package="Store-Difference Management">loadOtherDefinitions	| selections targets targetString package storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasOtherDifferences].	targets isEmpty ifTrue: [^self].	targetString := self otherClassNameFrom: self classesAndProperties selection.	package :=  self comparedPackages selection otherPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(Loading for: package) started.			targets do: [:each | each loadOtherDefinitionFrom: storeObject].			(Loading for: package) finished].</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>actions</category><body package="Store-Difference Management">classSelectionChanged		| targetPsuedoDifference sourceList |	(targetPsuedoDifference := self classesAndProperties selection) isNil		ifTrue: [self methodsOrProperties list: #()] 	"Eventually, here is where we put Propertyies?"		ifFalse:			[sourceList := targetPsuedoDifference changedMethodsSharedAndProperties.			self selectionType value == #instance 				ifTrue: [self methodsOrProperties list: (sourceList select: [:each | each isShownInMethodList and: [each isNotMeta]])].			self selectionType value == #class 				ifTrue: [self methodsOrProperties list: (sourceList select: [:each | each isShownInMethodList and: [each isMeta]])].			self selectionType value == #shared 				ifTrue: [self methodsOrProperties list: (sourceList select: [:each | each isForSharedVariable])].			self setSelectionTypeEmphasisFrom: sourceList.			self methodsOrProperties list isEmpty ifFalse: [self methodsOrProperties selectionIndexes: (Set with: 1)]]</body><body package="Store-Difference Management">collectDifferencesFrom: aCollection	comparedDifferences ifNil: [comparedDifferences := OrderedCollection new: aCollection size].	StoreProgressOverlay		subsume: builder window		while: 			[aCollection do:				[:each |				(Comparing for: (each first ifNil: [PseudoPackage new])) started.				comparedDifferences add: (PackageComparitor 					differencesWithPropertiesBetween: (each first ifNil: [each last pseudoPundleClass new]) 					and: (each last ifNil: [each first pseudoPundleClass new])).				(Comparing for: (each first ifNil: [PseudoPackage new])) finished]].	 self comparedPackages list: comparedDifferences</body><body package="Store-Difference Management">methodSelectionChanged		| pseudoDifferences |	pseudoDifferences := self methodsOrProperties selections.	pseudoDifferences size = 1		ifFalse:			[ | definitionString |			definitionString := pseudoDifferences size &gt; 1 				ifTrue: [(#MutlipleDefinitionsSelected &lt;&lt; #store &gt;&gt; 'Multiple Definitions Selected') asString] 				ifFalse: [String new].			self fromDefinition value: definitionString.			self toDefinition value: definitionString.			self fromProtocol value: String new.			self toProtocol value: String new]		ifTrue: [self emphasizeCodeUsing: pseudoDifferences first]</body><body package="Store-Difference Management">packageSelectionChanged	| targetComparitor |	self comparedPackages list size isZero ifTrue: [^self].	(targetComparitor := self comparedPackages selection) isNil		ifTrue: [classesAndProperties list: #()]		ifFalse: [classesAndProperties list: targetComparitor changedClassesNamespacesAndProperties].	self clearSelectionTypeEmpahsis</body><body package="Store-Difference Management">setClassSelectionType	self selectionType value: #class</body><body package="Store-Difference Management">setInstanceSelectionType	self selectionType value: #instance</body><body package="Store-Difference Management">setSharedSelectionType	self selectionType value: #shared</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>interface opening</category><body package="Store-Difference Management">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(builder window)		application: self;		sendWindowEvents: #(#newGraphicsDevice #reopen).	self setUpPackageViewWith: aBuilder.	self setUpClassesAndPseudoViewWith: aBuilder.	self setUpMethodsOrPropertiesViewWith: aBuilder.	self comparedPackages selectionIndexHolder		onChangeSend: #packageSelectionChanged		to: self.	self classesAndProperties selectionIndexHolder		onChangeSend: #classSelectionChanged		to: self.	self methodsOrProperties selectionIndexHolder		onChangeSend: #methodSelectionChanged		to: self.	self selectionType value: #instance.	self selectionType onChangeSend: #classSelectionChanged to: self</body><body package="Store-Difference Management">postOpenWith: aBuilder		self collectDifferencesFrom: rawDifferences.	self comparedPackages selectionIndex: 1</body><body package="Store-Difference Management">setUpClassesAndPseudoViewWith: aBuilder		| widget |	widget := (aBuilder componentAt: #ClassesAndPseudo) widget.	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self classAndPseudoLabelUsing: (view sequence at: index) in: view selected: false.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self classAndPseudoLabelUsing: (view sequence at: index) in: view selected: true.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body><body package="Store-Difference Management">setUpMethodsOrPropertiesViewWith: aBuilder		| widget |	widget := (aBuilder componentAt: #MethodsOrProperties) widget.	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self methodOrPropertiesLabelUsing: (view sequence at: index) in: view selected: false.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self methodOrPropertiesLabelUsing: (view sequence at: index) in: view selected: true.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body><body package="Store-Difference Management">setUpPackageViewWith: aBuilder		| widget firstMax |	widget := (aBuilder componentAt: #Packages) widget.	widget tooltip: nil.	firstMax := 0.	rawDifferences do: 		[:each | 		| labelString |		labelString := each first 			ifNil: [#BracketNoMatchingPackage &lt;&lt; #store &gt;&gt; '[No Matching Package]']			ifNotNil: [each first name , each first versionString].		firstMax := (Label with: labelString asText allBold attributes: widget textStyle) width max: firstMax].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self compositeViewUsing: (view sequence at: index) startingAt: firstMax in: view selected: false.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self compositeViewUsing: (view sequence at: index) startingAt: firstMax in: view selected: true.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>emphasis</category><body package="Store-Difference Management">clearSelectionTypeEmpahsis		| text widget |	text := (widget := self widgetAt: #InstanceSelection) label text.	widget label text: text string asText.	text := (widget := self widgetAt: #ClassSelection) label text.	widget label text: text string asText.	text := (widget := self widgetAt: #SharedSelection) label text.	widget label text: text string asText.	self mainWindow display.</body><body package="Store-Difference Management">emphasizeCodeUsing: anIndividualDifference	| secondProtocol prefix firstProtocol firstFragments secondFragments |	firstFragments := anIndividualDifference firstTextFragments.	secondFragments := anIndividualDifference secondTextFragments.	(firstFragments differences: secondFragments)		do: #applyAnyDifferenceTextEmphases.	self fromDefinition value: (firstFragments isEmpty				ifTrue: [Text new]				ifFalse: [firstFragments first sequence]).	self toDefinition value: (secondFragments isEmpty				ifTrue: [Text new]				ifFalse: [secondFragments first sequence]).	prefix := (#ProtocolSpaceColonSpace &lt;&lt; #store &gt;&gt; 'Protocol : ') asText				allBold.	firstProtocol := anIndividualDifference mainProtocol asText.	secondProtocol := anIndividualDifference otherProtocol asText.	firstProtocol = secondProtocol		ifFalse: 			[firstProtocol := firstProtocol						emphasizeAllWith: TextFragment emphasisForChange.			secondProtocol := secondProtocol						emphasizeAllWith: TextFragment emphasisForChange].	firstProtocol notEmpty ifTrue: [firstProtocol := prefix , firstProtocol].	secondProtocol notEmpty		ifTrue: [secondProtocol := prefix , secondProtocol].	self fromProtocol value: firstProtocol.	self toProtocol value: secondProtocol</body><body package="Store-Difference Management">setSelectionTypeEmphasisFrom: sourceList		| text widget |	text := (widget := self widgetAt: #InstanceSelection) label text.	widget label text: ((sourceList anySatisfy: [:each | each isShownInMethodList and: [each isMeta not and: [each isStandin not]]])		ifTrue: [text allBold]		ifFalse: [text string asText]).	text := (widget := self widgetAt: #ClassSelection) label text.	widget label text: ((sourceList anySatisfy: [:each | each isShownInMethodList and: [each isMeta and: [each isStandin not]]])		ifTrue: [text allBold]		ifFalse: [text string asText]).	text := (widget := self widgetAt: #SharedSelection) label text.	widget label text: ((sourceList anySatisfy: [:each | each isForSharedVariable])		ifTrue: [text allBold]		ifFalse: [text string asText]).	self mainWindow display.</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>events</category><body package="Store-Difference Management">windowEvent: anEvent from: aWindow 	super windowEvent: anEvent from: aWindow.	(#(#newGraphicsDevice #reopen) includes: anEvent key) 		ifTrue: [self closeAndUnschedule]</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>interface opening</category><body package="Store-Difference Management">compareFrom: aCodeComponent to: bCodeComponent	^self compareFromAll: (Array with: aCodeComponent)		toAll: (Array with: bCodeComponent)</body><body package="Store-Difference Management">compareFromAll: aSequenceOfCodeComponents toAll: bSequenceOfCodeComponents	| packagePairs session |	(UseNewCompareTool ~~ false and: [InputState default shiftDown not])		ifTrue: 			[PackageComparisonTool compareFromAll: aSequenceOfCodeComponents				toAll: bSequenceOfCodeComponents.			^self].	packagePairs := OrderedCollection new.	session := Store.Glorp.StoreLoginFactory currentStoreSession.	aSequenceOfCodeComponents with: bSequenceOfCodeComponents		do: 			[:first :second |			first isPackage				ifTrue: 					[packagePairs add: (Array with: (first asStoreComparisonObjectIn: session)								with: (second asStoreComparisonObjectIn: session))]				ifFalse: 					[(first isImageObject or: [second isImageObject])						ifTrue: [(self							gatherVersionsFor: (first asStoreComparisonObjectIn: session)							and: (second asStoreComparisonObjectIn: session)							in: session) do: [:pair | packagePairs add: pair]]						ifFalse: [(self							gatherDifferentVersionsFor: (first asStoreComparisonObjectIn: session)							and: (second asStoreComparisonObjectIn: session)							in: session) do: [:pair | packagePairs add: pair]]]].	packagePairs isEmpty		ifTrue: 			[^Dialog				warn: (#NoDifferences1s &lt;&lt; #store						&gt;&gt; 'The Following Items Have No Differences:&lt;n&gt;&lt;1s&gt;'							expandMacrosWith: (self									noDifferenceTabbedNamesUsing: aSequenceOfCodeComponents))].	^self openOn: packagePairs using: session.</body><body package="Store-Difference Management">openOn: aCollection using: aSession	| instance |	instance := self new.	instance setRawDifferences: aCollection.	instance storeSession: aSession.	^self openOn: instance</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>old browser compatibility</category><body package="Store-Difference Management">compareClass: aClass toClass: anotherClass	Store.TextDifferenceBrowser compare: aClass definition with: anotherClass definition</body><body package="Store-Difference Management">compareMethod: aMethod toMethod: anotherMethod	Store.MethodDifferenceBrowser		compare: aMethod definitionString		with: anotherMethod definitionString		protocol: aMethod protocol		with: anotherMethod protocol</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>resources</category><body package="Store-Difference Management">mainMenu	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #store ) 				#nameKey: #AmpView 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InstanceMethods 								#defaultString: '&amp;Instances Methods' 								#catalogID: #store ) 							#nameKey: #AmpInstanceMethods 							#value: #setInstanceSelectionType 							#indication: true 							#indicationSelector: 							#instanceClassOrShared: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ClassMethods 								#defaultString: '&amp;Class Methods' 								#catalogID: #store ) 							#nameKey: #AmpClassMethods 							#value: #setClassSelectionType 							#indication: true 							#indicationSelector: 							#instanceClassOrShared: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SharedVariables 								#defaultString: '&amp;Shared Variables' 								#catalogID: #store ) 							#nameKey: #AmpSharedVariables 							#value: #setSharedSelectionType 							#indication: true 							#indicationSelector: 							#instanceClassOrShared: ) ) #(3  ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AmpPackage 					#defaultString: '&amp;Package' 					#catalogID: #store ) 				#nameKey: #AmpPackage 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOut 								#defaultString: '&amp;File Out' 								#catalogID: #store ) 							#nameKey: #AmpFileOut 							#submenu: #(#{UI.Menu} #() #(0 0) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Versions 								#defaultString: '&amp;Versions' 								#catalogID: #store ) 							#nameKey: #AmpVersions 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #_List 											#defaultString: '&amp;List' 											#catalogID: #store ) 										#nameKey: #AmpList 										#value: #browseVersions ) ) #(1 0 0 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Find_ClassDots 								#defaultString: 'Find &amp;Class...' 								#catalogID: #store ) 							#nameKey: #FindAmpClassDots 							#value: #findClass) ) #(0 2 0 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Class 					#defaultString: '&amp;Class' 					#catalogID: #store ) 				#nameKey: #AmpClass 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseClassAmpVersions 								#defaultString: 'Browse Class &amp;Versions' 								#catalogID: #store ) 							#nameKey: #BrowseClassAmpVersions							#enablementSelector: #classObjectIsSelectedAndBrowsable							#value: #browseClassVersions ) 							) #(1 0 0 0 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Definition 					#defaultString: '&amp;Definition' 					#catalogID: #store ) 				#nameKey: #AmpDefinition 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseDefinition_Versions 								#defaultString: 'Browse Definition &amp;Versions' 								#catalogID: #store ) 							#nameKey: #BrowseDefinitionAmpVersions 							#enablementSelector: #singleMethodObjectSelectedAndBrowseable							#value: #browseDefinitionVersions ) 						) #(1 0 0 0 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #AmpHelp 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Topics 								#defaultString: '&amp;Topics' 								#catalogID: #store ) 							#nameKey: #AmpTopics ) ) #(1 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>deprecated</category><body package="Store-Difference Management">comparePackage: aStorePackage toPackage: aStorePackageOrPackageModel	"Deprecated. Use compareFrom:to: with the appropriate left-&gt;right semantics instead."	self deprecated: #(#after '7.7' #use #compareFrom:to: #callSite)				, (Array with: thisContext sender home method definition displayString).	self compareFromAll: (Array with: aStorePackage)		toAll: (Array with: aStorePackageOrPackageModel)</body><body package="Store-Difference Management">comparePackages: aCollectionOfPackages to: anotherCollectionOfPackages	"Deprecated. Use compareFromAll:toAll: with the appropriate left-&gt;right semantics instead."	self deprecated: #(#after '7.7' #use #compareFromAll:toAll: #callSite)				, (Array with: thisContext sender home method definition displayString).	self compareFromAll: aCollectionOfPackages		toAll: anotherCollectionOfPackages</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>private</category><body package="Store-Difference Management">allContainedBundleDifferencesBetween: leftBundle and: rightBundle in: session	|   results leftBundles rightBundles leftContainingBundles rightContainingBundles |	leftBundles := OrderedCollection with: leftBundle.	rightBundles := OrderedCollection with: rightBundle.	results := leftBundle containedBundleDifferencesWith: rightBundle.	leftContainingBundles := OrderedCollection with: leftBundle.	rightContainingBundles := OrderedCollection with: rightBundle.	[results isEmpty]		whileFalse: [ | bundles1 bundles2 |			bundles1 := (results select: [:ea| leftContainingBundles includes: ea containingBundle]).			leftBundles addAll: bundles1.			bundles1 := bundles1 collect: #subbundle.			bundles2 := (results select: [:ea| rightContainingBundles includes: ea containingBundle]).			rightBundles addAll: bundles2.			bundles2 := bundles2 collect: #subbundle.			results := StoreBundle containedBundleDifferencesBetween: bundles1 and: bundles2 in: session.			leftContainingBundles := bundles1.			rightContainingBundles := bundles2].	^Array with: leftBundles with: rightBundles.</body><body package="Store-Difference Management">createFullyPopulatedPundlePairFrom: currentPundlePair	| left right |	(currentPundlePair first isNil and: [currentPundlePair last isNil])		ifTrue: [self error].	left := currentPundlePair first notNil		ifTrue: [currentPundlePair first class = StoreBundle			ifTrue: [currentPundlePair first]			ifFalse: [currentPundlePair first containedPundle]]		ifFalse: [nil].	right := currentPundlePair last notNil		ifTrue: [currentPundlePair last class = StoreBundle			ifTrue: [currentPundlePair last]			ifFalse: [currentPundlePair last containedPundle]]		ifFalse: [nil].	left isNil		ifTrue: [left := right pseudoPundleClass new].	right isNil		ifTrue: [right := left pseudoPundleClass new].	^Array with: left with: right.</body><body package="Store-Difference Management">gatherDifferentVersionsFor: aBundle and: anotherBundle in: aSession	|  leftAndRight results  leftContainingBundles rightContainingBundles leftPackages rightPackages bundleCompareDict pundlePairs currentBundlePair leftBundles  rightBundles packageCompareDict   |	leftAndRight := self allContainedBundleDifferencesBetween: aBundle and: anotherBundle in: aSession.	" collect pairs of bundles "	leftBundles := leftAndRight first.	rightBundles := leftAndRight last.	bundleCompareDict := Dictionary new.	leftBundles do: [:ea|		ea class == StoreBundle			ifTrue: [ bundleCompareDict at: #root put: (Array with: ea with: nil)]			ifFalse: [ | containedColl |				containedColl := bundleCompareDict at: ea containingBundle name ifAbsentPut: [OrderedCollection new].				containedColl addLast: (Array with: ea with: nil)]].	rightBundles do: [:ea|		ea class == StoreBundle			ifTrue: [ | rootArray |				rootArray := bundleCompareDict at: #root.				(rootArray first notNil and: [rootArray first name = ea name])					ifTrue: [rootArray at: 2 put: ea]]			ifFalse: [ | containedColl array |				containedColl := bundleCompareDict at: ea containingBundle name ifAbsentPut: [OrderedCollection new].				array := containedColl detect: [:eaArray| eaArray first subbundle name = ea subbundle name] 								ifNone: [containedColl addLast: (Array new: 2)].				array at: 2 put: ea]].		leftContainingBundles := (leftBundles collect: [:ea| ea class == StoreBundle ifTrue: [ea] ifFalse: [ea subbundle]]).	rightContainingBundles :=  (rightBundles collect: [:ea| ea class == StoreBundle ifTrue: [ea] ifFalse: [ea subbundle]]).	results := StoreBundle containedPackageDifferencesBetween: leftContainingBundles  and: rightContainingBundles in: aSession.	leftPackages := results select: [:ea| leftContainingBundles includes: ea containingBundle].	rightPackages := results select: [:ea | rightContainingBundles includes: ea containingBundle].	packageCompareDict := Dictionary new.	leftPackages do: [:ea| | containedColl |		containedColl := packageCompareDict at: ea containingBundle name ifAbsentPut: [OrderedCollection new].		containedColl addLast: (Array with: ea with: nil)].	rightPackages do: [:ea | | containedColl array |		containedColl := packageCompareDict at: ea containingBundle name ifAbsentPut: [OrderedCollection new].		array := containedColl detect: [:eaArray| eaArray first notNil and: [eaArray first package name = ea package name]] ifNone: [containedColl addLast: (Array new: 2)].		array at: 2 put: ea].	pundlePairs := OrderedCollection new.	currentBundlePair := bundleCompareDict at: #root.	self orderChangedItemsIn: currentBundlePair withBundles: bundleCompareDict andPackages: packageCompareDict into: pundlePairs.	^pundlePairs</body><body package="Store-Difference Management">gatherVersionsFor: aBundle and: anotherBundle in: aSession	| gatheredPundles versionMatchedPundles mainLeafItems otherLeafItems session |	mainLeafItems := (aBundle asStoreComparisonObjectIn: aSession) withAllItems.	otherLeafItems := (anotherBundle asStoreComparisonObjectIn: aSession) withAllItems.	gatheredPundles := Dictionary new.	versionMatchedPundles := OrderedCollection new.	session := aSession.	otherLeafItems do: [:each | gatheredPundles at: (each name, each typeStringForBlessing) put: (each asStoreComparisonObjectIn: session)].	mainLeafItems do:		[:each | 		| other |		(Gathering for: (each asStoreComparisonObjectIn: session)) started.		other := gatheredPundles			at: each name, each typeStringForBlessing			ifAbsent:				[versionMatchedPundles add: (Array with: (each asStoreComparisonObjectIn: session) with: nil).				nil].		other notNil ifTrue:			[(other sameVersionAs: (each asStoreComparisonObjectIn: session)) ifFalse: 				[versionMatchedPundles add: (Array 					with: (each asStoreComparisonObjectIn: session) 					with: (other asStoreComparisonObjectIn: session))].			gatheredPundles at: each name, each typeStringForBlessing put: nil].		(Gathering for: (each asStoreComparisonObjectIn: session)) finished].	gatheredPundles do: 		[:each | 		each notNil ifTrue: [versionMatchedPundles add: (Array with: nil with: (each asStoreComparisonObjectIn: session))]].	^versionMatchedPundles</body><body package="Store-Difference Management">noDifferenceTabbedNamesUsing: aCollectionOfPundles	| stream counter |	stream := WriteStream on: String new.	counter := 1.	aCollectionOfPundles do:		[:each | 		counter = 1 ifTrue: [stream tab].		stream nextPutAll: each name.		counter = 7 			ifTrue: [stream cr]			ifFalse: [each = aCollectionOfPundles last ifFalse: [stream nextPutAll: ', ']].		counter := counter \\ 7 + 1].	^stream contents</body><body package="Store-Difference Management">orderChangedItemsIn: currentBundlePair withBundles: bundleCompareDict andPackages: packageCompareDict into: pundlePairCollection	| bundle bundlePair bundleName inBundlePairs |	bundle := currentBundlePair first ifNotNil: [:first | first]  ifNil: [currentBundlePair last].	bundleName := bundle class == StoreBundle		ifTrue: [bundle name]		ifFalse: [bundle containedPundle name]. 	bundlePair := self createFullyPopulatedPundlePairFrom: currentBundlePair.	pundlePairCollection add: bundlePair.	inBundlePairs := OrderedCollection new		addAll: (bundleCompareDict at: bundleName ifAbsent: [#()]);		addAll: (packageCompareDict at: bundleName ifAbsent: [#()]);		yourself.	inBundlePairs := inBundlePairs asSortedCollection: [:a :b | 		(a first ifNotNil: [:first | first sequence] ifNil: [a last sequence]) &lt; (b first ifNotNil: [:first | first sequence] ifNil: [b last sequence])].	inBundlePairs do: [:eachPair | | pundleClass |		pundleClass := eachPair first ifNotNil: [:first | first class] ifNil: [eachPair last class].		pundleClass == StoreBundleInBundle			ifTrue: [self orderChangedItemsIn: eachPair withBundles: bundleCompareDict andPackages: packageCompareDict into: pundlePairCollection]			ifFalse: [ | packagePair |				packagePair := self createFullyPopulatedPundlePairFrom: eachPair.				pundlePairCollection add: packagePair]].</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>accessing</category><body package="Store-Difference Management">useNewCompareTool	^UseNewCompareTool</body><body package="Store-Difference Management">useNewCompareTool: aBoolean	UseNewCompareTool := aBoolean.</body></methods><methods><class-id>Store.PundleVersionAlreadyExistsError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	^Dialog		request: (#Version1sOf2sANotherVersionString &lt;&lt; #store &gt;&gt; 'Version &lt;1s&gt; of &lt;2s&gt; already exists.&lt;n&gt;Enter another version string'						expandMacrosWith: parameter version						with: parameter name)		initialAnswer: (Policies versionPolicy						nextVersion: parameter version						forPundle: parameter)</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>private</category><body package="Store-UI-Unloadables Support">fileOut: definitions onFilename: filename 	| output |	output := SourceCodeStream write: filename.	[definitions do: 		[:definition | 		definition fileOutDefinitionOn: output]] 			ensure: [output close]</body><body package="Store-UI-Unloadables Support">handleAcceptAndLoadFor: anEvent in: aController	| keyValue |	(self oneSelected and: [anEvent hasCtrl and: [(keyValue := anEvent alternativeKeyValue) notNil and: [keyValue asLowercase = $s]]])		ifTrue:			[aController view keyboardProcessor requestGlobalAccept.			self acceptAndLoad.			^nil].	^anEvent</body><body package="Store-UI-Unloadables Support">promptForFilenameThenFileOut: list	|filename|	filename := Dialog requestNewFileName: #FileOutOnC &lt;&lt; #store &gt;&gt;'File out on:' default: 'unloadable.st'.	filename isEmpty ifTrue: [^nil].	self fileOut: list onFilename: filename</body><body package="Store-UI-Unloadables Support">selectedDefinitions	^self selectionModule selections</body><body package="Store-UI-Unloadables Support">selectedDefinitionsDo: aBlock	^self selectionModule selectionDo: aBlock</body><body package="Store-UI-Unloadables Support">setTextFrom: selections 	self text value: (selections isEmpty 				ifTrue: [String new]				ifFalse: 					[selections size = 1 						ifTrue: [selections first definition asText]						ifFalse: [(#MultipleDefinitionsSelected &lt;&lt; #store &gt;&gt; 'Multiple definitions are selected') asText allBold]])</body><body package="Store-UI-Unloadables Support">windowLabel	^(#JustUnloadableDefinitions &lt;&lt; #store &gt;&gt; 'Unloadable Definitions') asString.</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>menu actions</category><body package="Store-UI-Unloadables Support">acceptAndLoad	| newSource |	newSource := self text value string.	self selectedDefinitionsDo: 		[:definition | definition loadNewSource: newSource].	self definitionSelected.	self selectionModule listWidget invalidate</body><body package="Store-UI-Unloadables Support">briefHelp	|help|	help := SimpleHelp helpString: self class briefHelpString.	SimpleHelp openOn: help</body><body package="Store-UI-Unloadables Support">fileOut	self promptForFilenameThenFileOut: self selectedDefinitions</body><body package="Store-UI-Unloadables Support">fileOutAll	self promptForFilenameThenFileOut: selectionModule list</body><body package="Store-UI-Unloadables Support">loadAll	| errors |	errors := false.	selectionModule listDo: 		[:definition | 		[definition loadSrcInto: definition package storeModel]			on: UnloadableDefinitionError			do: 				[:exception |				errors := true.				exception resume]].	self selectionModule listWidget invalidate.	errors ifTrue: [Dialog warn: #SomeOrAllItemsDidNotLoad &lt;&lt; #store &gt;&gt; 'Some or all items did not load successfully']</body><body package="Store-UI-Unloadables Support">loadDefinition	self selectedDefinitionsDo: 		[:definition | 		definition loadSrcInto: definition package storeModel].	self selectionModule listWidget invalidate.</body><body package="Store-UI-Unloadables Support">removeFromPackage	self selectedDefinitionsDo: 		[:definition | definition removeFromPackage: definition package storeModel]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>interface opening</category><body package="Store-UI-Unloadables Support">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(aBuilder menuAt: #menuBar) ifNotNil: 		[:menu | (menu atNameKey: #definition) submenu: self class definitionMenu].</body><body package="Store-UI-Unloadables Support">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self mainWindow label: self windowLabel.	(self widgetAt: #selectionModule)		client: selectionModule		spec: selectionModule preferredWindowSpec		builder: aBuilder newSubBuilder.	selectionModule selectionHolder 		onChangeSend: #definitionSelected to: self.	self mainWindow keyboardProcessor keyboardHook: [:event :controller | self handleAcceptAndLoadFor: event in: controller].	self widget: #viewers when: #tabChanged send: #viewerChanged to: self.	self viewerChanged</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>testing</category><body package="Store-UI-Unloadables Support">anyNotLoadedSelected	| selections |	^(selections := self selectedDefinitions) notEmpty and: [selections anySatisfy: #notLoaded]</body><body package="Store-UI-Unloadables Support">anySelected	^self selectedDefinitions notEmpty</body><body package="Store-UI-Unloadables Support">oneSelected	^self selectedDefinitions size = 1 and: [self selectedDefinitions first notLoaded]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>initialize-release</category><body package="Store-UI-Unloadables Support">definitions: unloadableDefinitions	self selectionModule list: unloadableDefinitions.</body><body package="Store-UI-Unloadables Support">initialize	super initialize.	selectionModule := ListSelectionModule new.	selectionModule useMultiSelection: true.	selectionModule iconBlock: #icon.	selectionModule menuHolder: [self class definitionMenu] performer: self.	selectionModule displayStringBlock: 		[:object | 		object loaded			ifTrue: [object fullDisplayString asText emphasizeAllWith: (#color -&gt;ColorValue gray)]			ifFalse: [object fullDisplayStringWithUnloadableReason asText]].	self viewerListHolder 		list: (Array 			with: (#Source &lt;&lt; #store &gt;&gt; 'Source') asString			with: (#Versions &lt;&lt; #store &gt;&gt; 'Versions') asString).	self viewerListHolder selectionIndex: 1</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>notifications</category><body package="Store-UI-Unloadables Support">definitionSelected	| selections |	selections := self selectedDefinitions.	self viewerChanged.	Cursor database showWhile: [self setTextFrom: selections]</body><body package="Store-UI-Unloadables Support">viewerChanged	| viewer |	viewer := self widgetAt: #viewers.	self viewerListHolder selectionIndex = 1 		ifTrue: [viewer client: self spec: #definitionSpec]		ifFalse: 			[| versionsViewer definitions |			versionsViewer := RecordVersionsViewer new.			definitions := self selectedDefinitions.			viewer client: versionsViewer spec: #verticalWindowSpec.			definitions notEmpty ifTrue: [versionsViewer versions: definitions first versions]]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>accessing</category><body package="Store-UI-Unloadables Support">selectionModule	^selectionModule</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>aspects</category><body package="Store-UI-Unloadables Support">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body><body package="Store-UI-Unloadables Support">viewerListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^viewerListHolder isNil		ifTrue:			[viewerListHolder := SelectionInList new]		ifFalse:			[viewerListHolder]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Unloadables Support">windowSpec	^self perform: self specPreference</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>accessing</category><body package="Store-UI-Unloadables Support">briefHelpString^#UnloadableDefinitionsHelpString &lt;&lt;#store &gt;&gt; 'This is a list of definitions which could not be loaded. Your options are:Load them. If there is a problem with your prerequisites or bundle load ordering, they may be loadable now. Fix the problem and republish.  Alternatively, if the load problem can be fixed without touching this package, you may wish to simply publish the containing bundle, quit your image and reload.Remove them from the package.  Any definitions that cannot be loaded should be removed. This is because Store publishes only deltas. A definition needs to be explicitly removed or it will remain there and the same problems will occur.Fileout. If a Class or NameSpace has been moved to a different NameSpace, your extension methods may not load.  You can file them out, edit the name and file them into your package. Remember to remove these old definitions from the package as explained above.'</body><body package="Store-UI-Unloadables Support">specPreference		^specPreference</body><body package="Store-UI-Unloadables Support">specPreference: aSymbol		specPreference := aSymbol</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>interface opening</category><body package="Store-UI-Unloadables Support">openOnDefinitions: unloadableDefinitions	| viewer |	viewer := self new.	viewer definitions: (unloadableDefinitions collect: [:each | UnloadableDefinition on: each]).	viewer open.	^viewer</body><body package="Store-UI-Unloadables Support">openOnExceptions: exceptions	| viewer |	viewer := self new.	viewer definitions: (exceptions collect: [:each | UnloadableDefinition fromUnloadableError: each]).	viewer open.	^viewer</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>class initialization</category><body package="Store-UI-Unloadables Support">initialize	specPreference := #horizontalWindowSpec</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">classesAndNameSpaces	| objects |	objects := OrderedCollection new.	self objectNames do: 			[:each |			| object |			object := environment classForName: each						ifAbsent: [environment nameSpaceForName: each ifAbsent: [nil]].			object notNil ifTrue: [objects add: object]].	^objects</body><body package="StoreForGlorpBrowserUI">classesAndNameSpaces: aCollection	| any |	any := self any: aCollection.	any notNil		ifTrue: 			[type := any isForClassOrExtension						ifTrue: [any isMeta ifTrue: [#class] ifFalse: [#instance]]						ifFalse: [#sharedVariable]].	objectNameReferences := aCollection collect: 					[:each |					(each isBehavior ifTrue: [each instanceBehavior] ifFalse: [each])						fullRootName asQualifiedReference]</body><body package="StoreForGlorpBrowserUI">environment	^environment</body><body package="StoreForGlorpBrowserUI">environment: aBrowserEnvironment	"It would be more in keeping with the way the RB works to have the state consult a global variable holding the glorp StoreModel loaded in the image.  However, that would not work if you want to browse two versions of the same code at the same time.  For that, we must ask the environment which knows which pundle models you are actually browsing.  Later we will distinguish the two cases and subclass so you can browse in glorp StoreModel organisation any code you have currently loaded from, or published to, Store, and also shadow-browse unloaded store models. Only the latter will need a state that knows its environment."	environment := aBrowserEnvironment.</body><body package="StoreForGlorpBrowserUI">nameSpace	"Just give the name space equivalent that's in memory. We should probably disallow saving from this pane anyway"	^nameSpaceName asQualifiedReference valueOrDo: [Smalltalk].</body><body package="StoreForGlorpBrowserUI">nameSpace: aStringOrNamespace	aStringOrNamespace isString		ifTrue: 			[(aStringOrNamespace copyFrom: 1 to: (4 min: aStringOrNamespace size))				= 'Root'					ifTrue: [nameSpaceName := aStringOrNamespace]					ifFalse: [nameSpaceName := 'Root.Smalltalk.' , aStringOrNamespace]]		ifFalse: [nameSpaceName := aStringOrNamespace fullRootName]</body><body package="StoreForGlorpBrowserUI">nonMetaClasses	| classes |	classes := OrderedCollection new: self objectNames size.	self objectNames do:		[:each || class |		class := environment classForName: each ifAbsent: [nil].		(class notNil and: [class isClass]) ifTrue: [classes add: class]].	^classes</body><body package="StoreForGlorpBrowserUI">objectNames: aCollection 	objectNameReferences := aCollection.</body><body package="StoreForGlorpBrowserUI">pseudoBindingFor: aBinding	^environment at: aBinding asString ifAbsent: [nil].</body><body package="StoreForGlorpBrowserUI">pundles	^(pundles collect: [:each | environment pundleNamed: each first isPackage: each last])		select: [:each | each notNil].</body><body package="StoreForGlorpBrowserUI">selectedBindings	^objectNameReferences collect: [:each | self pseudoBindingFor: each].</body><body package="StoreForGlorpBrowserUI">selectedMethods	^self definitions collect:		[:each |		self environment methodNamed: each selector inClass: each implementingClass]</body><body package="StoreForGlorpBrowserUI">selectedNameSpace	^(objectNameReferences collect: [:each | self pseudoBindingFor: each])		detect: [:each | each isForNameSpace or: [each isForData]]		ifNone: [^nil]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>accessing-class</category><body package="StoreForGlorpBrowserUI">selectedClasses	| classes classOrNameSpace |	classes := OrderedCollection new: objectNameReferences size.	objectNameReferences do: 			[:each |			classOrNameSpace := self pseudoBindingFor: each.			classOrNameSpace isForClassOrExtension				ifTrue: [classes addAll: (environment allClassesAndExtensionsForName: each)]].	^classes</body><body package="StoreForGlorpBrowserUI">selectedGlobals	| globals classOrNameSpace |	globals := OrderedCollection new: objectNameReferences size.	objectNameReferences do:		[:each | 		classOrNameSpace := self pseudoBindingFor: each.		(classOrNameSpace isForClassOrExtension or: [classOrNameSpace isForNameSpace or: [classOrNameSpace isForData]])			ifTrue: [globals add: classOrNameSpace]].	^globals</body><body package="StoreForGlorpBrowserUI">selectedShareds	| shareds shared |	shareds := OrderedCollection new: objectNameReferences size.	objectNameReferences keysAndValuesDo:		[:index :each | 		shared := self binding.		(shared isForClassOrExtension or: [shared isForNameSpace or: [shared isForData]])			ifTrue: [shareds add: shared]].	^shareds</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>accessing-methods</category><body package="StoreForGlorpBrowserUI">binding		| localDefinitions |	localDefinitions := (self type = #sharedVariable and: [definitions isEmpty])		ifTrue: [^nil]		ifFalse: [definitions].	^environment sharedVariable: localDefinitions first variableName for: objectNameReferences first</body><body package="StoreForGlorpBrowserUI">methodDefinitionClass	^StoreMethodDefinition</body><body package="StoreForGlorpBrowserUI">selectors	"The methods in StorePundle hold selectors as String."	| defs class |	defs := self methodDefinitions.	defs isEmpty ifTrue: [^#()].	class := self selectedClass.	^(defs select: [:each | each inheritingClass = class]) 		collect: [:each | each selector asSymbol]</body><body package="StoreForGlorpBrowserUI">selectors: symbolCollection	"	| class |	class := self selectedClass.	class isNil ifTrue: [^self definitions: #()].	self definitions: (symbolCollection collect:		[:each | 		| implementingClass |		implementingClass := class whichClassIncludesSelector: each.		implementingClass isNil ifTrue: [implementingClass := class].		StoreMethodDefinition class: class implementor: implementingClass selector: (each isString ifTrue: [each] ifFalse: [each name])])"	super selectors: symbolCollection</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>printing</category><body package="StoreForGlorpBrowserUI">printOn: aStream		| binding |	binding := self selectedBinding.	binding notNil		ifTrue:			[aStream nextPutAll: binding name.			self isMeta ifTrue: [aStream nextPutAll: ' class'].			self selector notNil				ifTrue:					[aStream						nextPutAll: '&gt;&gt;';						nextPutAll: self selector]				ifFalse:					[self sharedVariableName notNil						ifTrue:							[aStream								nextPut: $.;								nextPutAll: self sharedVariableName]						ifFalse:							[self protocol notNil								ifTrue:									[aStream										nextPut: $&gt;;										nextPutAll: self protocol]]]]		ifFalse:			[self pundles isEmpty				ifTrue: [aStream nextPutAll: '(nothing selected)']				ifFalse: [aStream nextPutAll: self pundle itemString]].</body></methods><methods><class-id>Store.Renaming</class-id> <category>accessing</category><body package="Store-Base">actionText	^(#Renaming &lt;&lt; #store &gt;&gt; 'Renaming') asString</body><body package="Store-Base">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.Renaming class</class-id> <category>instance creation</category><body package="Store-Base">for: aPundleClass from: aString to: anotherString	^self for: (#_1sFrom2sTo3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; from: &lt;2s&gt; to: &lt;3s&gt;'		expandMacrosWith: aPundleClass name		with: aString		with: anotherString)</body></methods><methods><class-id>Store.Glorp.StorePackageInBundle</class-id> <category>accessing</category><body package="Store-Database Model">containedPundle	^package</body><body package="Store-Database Model">containingBundle	^containingBundle</body><body package="Store-Database Model">containingBundle: anObject	containingBundle := anObject</body><body package="Store-Database Model">package	^package</body><body package="Store-Database Model">package: anObject	package := anObject</body><body package="Store-Database Model">sequence	^sequence</body><body package="Store-Database Model">sequence: anObject	sequence := anObject</body></methods><methods><class-id>Store.UserCancelledPublish</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog warn:		(#UserHasChosenToCancelPublishing &lt;&lt; #store &gt;&gt;			'User has chosen to cancel publishing instead of entering a new version string.&lt;n&gt;No changes to the database have been commited') expandMacros.	^nil</body></methods><methods><class-id>Store.Glorp.ClassSelectorLookupKey</class-id> <category>accessing</category><body package="Store-Database Model">classKey	^classKey</body><body package="Store-Database Model">classKey: anObject	classKey := anObject</body><body package="Store-Database Model">selectorKey	^selectorKey</body><body package="Store-Database Model">selectorKey: anObject	selectorKey := anObject</body></methods><methods><class-id>Store.Glorp.ClassSelectorLookupKey</class-id> <category>comparing</category><body package="Store-Database Model">= aClassSelectorKey	^self selectorKey == aClassSelectorKey selectorKey		and: [self classKey = aClassSelectorKey classKey]</body><body package="Store-Database Model">hash	hash notNil ifTrue: [^hash].	hash := self selectorKey stringhash * 2 + 1		bitXor: self classKey hash.	^hash</body></methods><methods><class-id>Store.Glorp.ClassSelectorLookupKey class</class-id> <category>instance creation</category><body package="Store-Database Model">forClass: aClass andSelector: aSelector	^self new		classKey: aClass;		selectorKey: aSelector;		yourself</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id> <category>updating</category><body package="StoreForGlorpBrowserUI">definitionOfBinding: binding 	| namespace definitionString |	binding isForGeneral ifFalse: 		[^(definitionString := binding definitionString) isEmpty 			ifTrue: [(#NotDefinedInThisPackage &lt;&lt; #store &gt;&gt; 'Not defined in this package') asText]			ifFalse: [definitionString asText]].	namespace := Root whoDefinesBinding: binding.	namespace isNil ifTrue: [^''].	^namespace definitionOfStatic: binding</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">canDefineClassesAndNameSpaces	^false</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	self updateGroupList.	self updateUserList.	self updateGraph.	self setButtons.</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>aspects</category><body package="Store-UI-Graphs">groupList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^groupList isNil		ifTrue:			[groupList := SelectionInList new]		ifFalse:			[groupList]</body><body package="Store-UI-Graphs">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>accessing</category><body package="Store-UI-Graphs">perspective	^#tt_containsAdjacent</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>actions</category><body package="Store-UI-Graphs">addToGroup		| user group |	user := userList selection.	group := groupList selection.	(user isNil or: [group isNil]) ifTrue:		[^Dialog warn:			(#SelectGroupAndMemberToAdd &lt;&lt; #store &gt;&gt; 'Select a group and group member (user) that&lt;n&gt;you wish to add before pressing this button') expandMacros].	StoreUserGroup newUserNamed: user inGroupNamed: group.	self updateGraph</body><body package="Store-UI-Graphs">listChange	self updateGraph.	self setButtons.</body><body package="Store-UI-Graphs">newGroup	| group |	[group := Dialog request: #NewGroupName &lt;&lt; #store &gt;&gt; 'New Group Name:'.	group isEmpty ifTrue: [^self].	self groupList list includes: group] whileTrue: 		[Dialog warn: (#Group1sAlreadyExists &lt;&lt; #store &gt;&gt; 'Group &lt;1s&gt; already exists' expandMacrosWith: group)].	StoreUserGroup newGroupNamed: group.	self updateGroupList.	self groupList selection: group.	self updateGraph</body><body package="Store-UI-Graphs">newUser		| group user |	group := groupList selection.	group size = 0 ifTrue: [^Dialog warn: #PleaseSelectAGroup &lt;&lt; #store &gt;&gt; 'Please select a group'].	[user := Dialog request: #NewUserName &lt;&lt; #store &gt;&gt; 'New user name:'.	user isEmpty ifTrue: [^self].	(self userList list includes: user) or: [self groupList list includes: user]] whileTrue: 		[Dialog warn: (#UserORGroup1sAlreadyExists &lt;&lt; #store &gt;&gt; 'User or Group ''&lt;1s&gt;'' already exists' expandMacrosWith: user)].	StoreUserGroup newUserNamed: user inGroupNamed: group.	self updateUserList.	self userList selection: user.	self updateGraph</body><body package="Store-UI-Graphs">removeFromGroup	| user group |	user := userList selection.	group := groupList selection.	(user isNil or: [group isNil]) ifTrue: 		[^Dialog warn: (#SelectGroupAndMemberToRemove &lt;&lt; #store &gt;&gt; 'Select a group and group member (user) that&lt;n&gt;you wish to remove before pressing this button')  expandMacros].	StoreUserGroup removeUserNamed: user inGroupNamed: group.	self updateGraph</body><body package="Store-UI-Graphs">updateGraph	"Our graph here is Group on the left, and arrows to users on the right... only"	| focus cache |	focus := Set new.	cache := Dictionary new.	groupList selection notNil ifTrue: [focus add: (GroupElement element: groupList selection cache: cache)].	self graphView focus: focus.</body><body package="Store-UI-Graphs">updateGroupList	self groupList list: StoreUserGroup allGroupNames</body><body package="Store-UI-Graphs">updateUserList	self userList list: StoreUserGroup allUserNames</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>private</category><body package="Store-UI-Graphs">setButtons	| enable |	enable := ( ( userList selection ~~ nil ) and: [ groupList selection ~~ nil ] ).	( builder componentAt: #addToGroup ) isEnabled: enable.	( builder componentAt: #removeFromGroup )  isEnabled: enable.	( builder componentAt: #newUser ) isEnabled: ( groupList selection ~~ nil ).</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs">initializePerspectives	"self initializePerspectives"	^(List new) add: ((Array new: 9)			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: 	#(#(#V1 #F1 'tt_contains' true true false true true) 						   #(#F1 #V2 'tt_contains' true true false true true) );			at: 4 put: #arrLabelHints:;			at: 5 put: #();			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_contains';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue purple;					at: 5 put: 1; yourself);  yourself);			at: 8 put: #name:;			at: 9 put: #tt_containsAdjacent; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs">initializeRelationships	"self initializeRelationships"	^List new 		add: #( #LDMFirstOrderRel #name: 'tt_contains' #description: 'contains' 				#reverse: nil #token: #tt_containsRel) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_containsR' #description: 'containsR' 				#reverse: nil #token: #tt_containsRRel) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Tools.BindingTextualDetailComparisonView</class-id> <category>row population</category><body package="Store-Code Comparison">computeDetailRows	^Array with: (SideBySideTextComparisonView new leftText: leftText				rightText: rightText)</body><body package="Store-Code Comparison">populateHeader	| header |	super populateHeader.	header := self header.	header add: icon.	header add: (self italicizedText: name)</body></methods><methods><class-id>Tools.BindingTextualDetailComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">icon: aGraphic name: aStringThing leftText: aLeftText rightText: aRightText	icon := aGraphic.	name := aStringThing.	leftText := aLeftText.	rightText := aRightText.	self populate</body></methods><methods><class-id>Tools.BindingTextualDetailComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^Array with: #compareBindingDetail with: name</body></methods><methods><class-id>Store.LoadAnalysisError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	^Dialog		chooseReport: messageText		labels: (Array with: (#OK &lt;&lt; #dialogs &gt;&gt; 'OK'))		values: (Array with: true)		default: true		for: nil</body></methods><methods><class-id>Store.LoadAnalysisError class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>menu</category><body package="Store-UI">publishOrderedSelectionPair	| last selections firstTimestamp lastTimestamp first |	selections := self selectedPundles asArray.	first := selections first.	last := selections last.	firstTimestamp := first isImageModel				ifTrue: [first storeTracePackage ifNotNil: #timestamp]				ifFalse: [first timestamp].	lastTimestamp := last isImageModel				ifTrue: [last storeTracePackage ifNotNil: #timestamp]				ifFalse: [last timestamp].	(firstTimestamp isNil		or: [lastTimestamp notNil and: [lastTimestamp &lt; firstTimestamp]])			ifTrue: [selections := selections reverse].	^selections</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>actions</category><body package="Store-UI">browseSelectedVersion	| package |	package := self selectedPundle.	package := package isImageModel		ifTrue: [			self itemsInList list detect: [:each|				each isImageModel					ifTrue: [false]					ifFalse: [package dbTrace = each primaryKey]] ifNone: [nil]]		ifFalse: [package].	package isNil 		ifTrue: [Dialog warn: 'Loaded version is not in the currently connected Store repository'.			^self].		[(Gathering for: package) started.	package prefetchAllFromDatabase.	(StoreForGlorpBrowserEnvironment on: package) openEditor.	(Gathering for: package) finished]			withStoreFeedbackOn: self mainWindow</body><body package="Store-UI">compareSelectionWith	| pundle target older newer |	pundle := self selectedPundle.	target := pundle class selectStoreVersionOf: pundle name in: pundle session.	target		ifNotNil: 			[older := pundle timestamp &lt; target timestamp						ifTrue: [pundle]						ifFalse: [target].			newer := pundle timestamp &lt; target timestamp						ifTrue: [target]						ifFalse: [pundle].			ComparePackages compareFrom: older to: newer]</body><body package="Store-UI">compareVersions	| selections |	selections := self publishOrderedSelectionPair.	ComparePackages compareFrom: selections first to: selections last</body><body package="Store-UI">compareWithParent	| pundle parent |	pundle := self selectedPundle.	parent := pundle previous.	parent ifNil: [parent := pundle selectStoreVersionIn: pundle session].	parent ifNotNil: 		[self openCompareFrom: pundle  to: parent]</body><body package="Store-UI">containedItems	[DefinitionForListTool forBundleContents: self selectedPundle] withStoreFeedbackOn: tool mainWindow.</body><body package="Store-UI">enclosingBundles	| pundle enclosingBundles |	pundle := self selectedPundle.	(enclosingBundles := pundle enclosingComponents) isEmpty		ifTrue: [^Dialog warn: #NoEnclosingBundles &lt;&lt; #store &gt;&gt; 'No enclosing bundles.'].	DefinitionForListTool forPackages: enclosingBundles</body><body package="Store-UI">fileOutSelectedVersion	| pundle fileName fileManager |	pundle := self selectedPundle.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: pundle name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: pundle) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			pundle fileOutOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: pundle) finished].</body><body package="Store-UI">graphSelectedVersion	| pundle |	pundle := self selectedPundle.	pundle isImageModel ifFalse: [pundle := pundle class cachedItemFor: pundle].	VersionGraph browseVersionsOfPundle: pundle.</body><body package="Store-UI">inspectSelected	^self selectedPundle inspect</body><body package="Store-UI">loadSelectedVersion	self selectedPundle canLoadNewOrReplaceExistingVersion 		ifTrue: [			[self selectedPundle loadSource] 				withStoreFeedbackOn: self mainWindow].</body><body package="Store-UI">mergeIntoImage	| packages targets openMergeTool |	openMergeTool := MergeTool alwaysOpenMergeTool.	packages := self selectedPundles.	targets := packages collect:		[:each |		each isBundle			ifTrue: [StoreBundle pundleWithName: each name version: each version in: each session]			ifFalse: [StorePackage pundleWithName: each name version: each version in: each session]].	openMergeTool		ifTrue: [MergeTool openOnPundles: targets]		ifFalse: [[ResolutionManager doMergeOnPundles: targets] withStoreFeedbackOn: self mainWindow]</body><body package="Store-UI">reconcile	| dbVersion |	dbVersion := self selectedPundle.	[dbVersion getImagePundle reconcileWithDbVersion: dbVersion]		withStoreFeedbackOn: self mainWindow</body><body package="Store-UI">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText emphasis: #bold.				updateText nextPutAll: each name.				updateText space.				updateText nextPutAll: each versionString.				updateText space.				updateText space.				updateText nextPutAll: (Policies blessingPolicy blessingName:each currentBlessingLevel).				updateText cr.				updateText emphasis: #none.				updateText cr.				each blessings do:					[:eachBlessing | eachBlessing blessingLevel = -1 ifFalse: [eachBlessing printWideOn: updateText]].				updateText cr.				updateText emphasis: (Array with: #color-&gt; ColorValue navy).				updateText nextPutAll: each comment.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body><body package="Store-UI">setBlessingLevel	| pundle |	pundle := self selectedPundle.	BlessingDialog setBlessingFor: pundle. 	(self builder componentAt: #SelectionList) widget invalidate.	self selectionsUpdated</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>interface opening</category><body package="Store-UI">compositeViewUsing: aPackage nameSize: longestName versionSize: longestVersion timeSize: longestTimestamp in: aSequenceView		| iconPart currentStart nameLabel versionLabel timestampLabel blessingLabel mainThing |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aPackage toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aPackage name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 12.	versionLabel := Label with: aPackage versionString asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestVersion + 12.	timestampLabel := Label with: aPackage timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	blessingLabel := Label with: aPackage blessingLevelString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: versionLabel;		add: blessingLabel;		yourself.	^mainThing</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder.</body><body package="Store-UI">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestVersion longestTimestamp |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestVersion := longestTimestamp := 0.	items		do:			[:each | 			longestName := (Label with: each name asText allBold attributes: widget textStyle) width max: longestName.			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestTimestamp := (Label with: each timeStampString asText attributes: widget textStyle) width max: longestTimestamp].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				timeSize: longestTimestamp				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				timeSize: longestTimestamp				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget tooltip: nil</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>accessing</category><body package="Store-UI">listTitle		self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title</body><body package="Store-UI">selectedPundle	^self selections first</body><body package="Store-UI">selectedPundles	"This synonym for #selections is provided so that subclasses with wrapped pundles can override it 	and use my menu choices successfully."	^self selections</body><body package="Store-UI">selection	^self itemsInList selections size &gt; 0		ifTrue: [self itemsInList selections first]		ifFalse: [^self error: 'selection is nil']</body><body package="Store-UI">title		| target |	^title ifNil: 		[target := self itemsInList list first.		#VersionsOf2BundleOrPackage1s &lt;&lt; #store &gt;&gt; 'Versions of &lt;2?Bundle:Package&gt; &lt;1s&gt;' expandMacrosWith: target name with: target isBundle]</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>private</category><body package="Store-UI">openCompareFrom: aPundle  to: anotherPundle	| session left right leftTimestamp rightTimestamp |	session := aPundle session ifNil: [anotherPundle session ifNil: [StoreLoginFactory currentStoreSession]].	left := aPundle asStoreComparisonObjectIn: session.	right := anotherPundle asStoreComparisonObjectIn: session.	leftTimestamp := (left isKindOf: PundleModel)				ifTrue: [left storeTracePackage ifNotNil: #timestamp]				ifFalse: [left timestamp].	rightTimestamp := (right isKindOf: PundleModel)				ifTrue: [right storeTracePackage ifNotNil: #timestamp]				ifFalse: [right timestamp].	(leftTimestamp isNil		or: [rightTimestamp notNil and: [rightTimestamp &lt; leftTimestamp]])			ifTrue: 				[| swap |				swap := left.				left := right.				right := swap].	ComparePackages compareFrom: left to: right</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>testing</category><body package="Store-UI">atLeastOneVersionSelectedAndInImage	"Test that there is at least one database version selected, no image versions selected and that a version is loaded in the image"	| selectedPundles |	(self selections size &gt; 0 and: [self selections allSatisfy: [:each | each isImageModel not]])		ifFalse: [^false].	^self selections size &gt; 0 and: 		[selectedPundles := self selectedPundles.		selectedPundles allSatisfy:			[:each |			each correspondingImagePundle notNil]]</body><body package="Store-UI">oneItemAndInImage	^self onlyOneItemSelected and: 		[self selectedPundle correspondingImagePundle notNil]</body><body package="Store-UI">onlyOneItemSelected	^self selections size = 1 and: [self selectedPundle isImageModel not]</body><body package="Store-UI">onlyTwoItemsSelected	^self selections size = 2</body><body package="Store-UI">selectionIsBundle	^self onlyOneItemSelected and: [self selectedPundle isBundle]</body></methods><methods><class-id>Store.NotifyNoMergeChanges</class-id> <category>private - actions</category><body package="Store-Merge Management">defaultAction	Dialog warn:		(#OnlyAlreadyAppliedChangesWereDetected &lt;&lt; #store &gt;&gt;		'Only already applied changes were detected.&lt;n&gt;No new changes are available for this merge session') expandMacros</body></methods><methods><class-id>Store.NullPackageCanNotBeSavedError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	Dialog warn: (#TheNullPackageCannotBeSaved &lt;&lt; #store &gt;&gt; 'The Null package cannot be saved.') asString.	^false</body></methods><methods><class-id>Store.NullPackageCanNotBeSavedError class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.ReconcilingComparitor</class-id> <category>accumulate changes</category><body package="Store-Difference Management">addClassChanges	"Find and note class changes"	| classChange matchingClass |	pundleModel classesWithSource do: 		[:eachClass |		classChange := Change new classSymbol: eachClass absoluteName.		(storePundle includesClassNamed: eachClass absoluteName)			ifFalse: [workingChangeSet doClassChange: classChange add]			ifTrue: 				[matchingClass := storePundle classInPackageNamed: eachClass absoluteName meta: false.				eachClass definition = matchingClass definition ifFalse: 					[workingChangeSet doClassChange: classChange change].				((eachClass comment ifNil: ['']) string equalsAcrossPlatforms: matchingClass comment string) ifFalse: 					[workingChangeSet doClassChange: classChange comment]]].	storePundle classesDefinedInPackage do: 		[:eachClass |		(pundleModel includesClassNamed: eachClass absoluteName) ifFalse: 			[classChange := Change new classSymbol: eachClass absoluteName.			workingChangeSet doClassChange: classChange removeDefinition]]</body><body package="Store-Difference Management">addMethodChanges	"Add method changes to the change sets."	| methodChange matchingMethod |	pundleModel methodsWithSource do: 		[:eachMethod |		methodChange := (Change new)			classSymbol: eachMethod classNameWithMeta;			selector: eachMethod selector.		(storePundle includesMethod: eachMethod)			ifFalse: [workingChangeSet doSubdefChange: methodChange add]			ifTrue: 				[matchingMethod := storePundle					method: eachMethod selector					forClassNamed: eachMethod absoluteClassName					meta: eachMethod isMeta.				(eachMethod sourceMatches: matchingMethod) ifFalse: 					[workingChangeSet doSubdefChange: methodChange change]]].	storePundle methods do: 		[:eachMethod |		((pundleModel includesMethod: eachMethod) or: [pundleModel includesUninstalledMethod: eachMethod]) ifFalse: 			[methodChange := (Change new)				classSymbol: eachMethod classNameWithMeta;				selector: eachMethod selector.			workingChangeSet doSubdefChange: methodChange remove]]</body><body package="Store-Difference Management">addNamespaceChange	"Add def namespace changes to the change sets."	| namespaceChange matchingNamespace |	pundleModel nameSpacesWithSource do: 		[:eachNamespace |		namespaceChange := Change new nameSpaceSymbol: eachNamespace absoluteName.		(matchingNamespace := storePundle nameSpaceInPackageNamed: eachNamespace absoluteName) notNil			ifTrue: 				[eachNamespace definition = matchingNamespace definition ifFalse: 					[workingChangeSet doNameSpaceChange: namespaceChange change].				((eachNamespace comment ifNil: ['']) string equalsAcrossPlatforms: matchingNamespace comment string) ifFalse: 					[workingChangeSet doNameSpaceChange: namespaceChange comment]]			ifFalse: [workingChangeSet doNameSpaceChange: namespaceChange add]].	storePundle nameSpacesDefinedInPackage do: 		[:eachNamespace |		(pundleModel includesNameSpaceNamed: eachNamespace absoluteName) ifFalse: 			[namespaceChange := Change new nameSpaceSymbol: eachNamespace absoluteName.			workingChangeSet doNameSpaceChange: namespaceChange removeDefinition]]</body><body package="Store-Difference Management">addPropertyChanges	"Add property changes to the changesets.	Ensure that we remove any property keys that are volatile or system only.  The list of 	these property keys has changed over time so there is no point tracking them."	| imageProperties databaseProperties |	imageProperties := pundleModel propertiesForFileOut.	databaseProperties := storePundle propertiesForFileOut.	CodeComponent systemOnlyPropertyKeys do: 		[:each |		imageProperties removeKey: each ifAbsent: [nil].		databaseProperties removeKey: each ifAbsent: [nil]].	imageProperties associationsDo: 		[:each |		((databaseProperties includesKey: each key) and: [each value = (databaseProperties at: each key)]) ifFalse: 			[workingChangeSet addPropertyChange: each key]].	databaseProperties keysDo: 		[:each |		(imageProperties includesKey: each) ifFalse: 			[workingChangeSet addPropertyChange: each]]</body><body package="Store-Difference Management">addSharedChanges	"Add shared variable changes to the working change set."	| sharedChange matchingShared |	pundleModel dataWithSource do: 		[:eachShared |		sharedChange := Change new dataKey: eachShared dataKey.		eachShared isInClass			ifTrue: [sharedChange classSymbol: eachShared absoluteOwnerName asSymbol]			ifFalse: [sharedChange nameSpaceSymbol: eachShared absoluteOwnerName asSymbol].		sharedChange dataKey: eachShared dataKey.		(storePundle includesDatum: eachShared)			ifTrue: 				[matchingShared := storePundle datum: eachShared dataKey forOwnerNamed: eachShared absoluteOwnerName.				(eachShared sourceMatches: matchingShared) ifFalse: 					[workingChangeSet doSubdefChange: sharedChange change]]			ifFalse: [workingChangeSet doSubdefChange: sharedChange add]].	storePundle sharedVariables do: 		[:eachShared |		| ownerName |		ownerName := eachShared absoluteOwnerName asSymbol.		(pundleModel includesDatum: eachShared) ifFalse: 			[sharedChange := Change new dataKey: eachShared dataKey.			eachShared isInClass 				ifTrue: [sharedChange classSymbol: ownerName] 				ifFalse: [sharedChange nameSpaceSymbol: ownerName].			workingChangeSet doSubdefChange: sharedChange remove]]</body><body package="Store-Difference Management">addStructureChanges	"Only called for bundles"		pundleModel structure = storePundle structure 		ifFalse: [workingChangeSet addOtherChange: BundleModel structureMark]</body><body package="Store-Difference Management">reconcileBundle	(Reconciling for: storePundle) started.	self addStructureChanges.	self addPropertyChanges.	self reconcileBundleParts.	self updateDatabaseInformationInPundleModel.	(Reconciling for: storePundle) finished</body><body package="Store-Difference Management">reconcileBundleParts	"We must call #initializeForReconcileWith: on the pundelModel to ensure it has a databaseInformation for this reconcile before we call #contentDescriptions on it.  If this is omitted, and the pundelModel does not already have a databaseInformation for the current database, #contentDescriptions will call #anyContentDescriptions which returns copies, not originals, so the setting of their traces and databaseIdentifiers below will be lost.  If there is no matching sub pundle then we nil out the db info in the owning description for it, as a way of marking that the structure has changed."	| databaseItems |	pundleModel initializeForReconcileWith: pundleModel.	databaseItems := storePundle containedItems.	pundleModel contentDescriptions do:		[:eachContentDescription || subPundleModel matchingDatabasePundle |		subPundleModel := eachContentDescription component.		subPundleModel ifNotNil:			[matchingDatabasePundle := databaseItems				detect: 					[:eachPundle | 					subPundleModel isBundle == eachPundle isBundle and: [subPundleModel name = eachPundle name]] 				ifNone: [nil].			matchingDatabasePundle				ifNil: [eachContentDescription id: nil; dbIdentifier: nil]				ifNotNil:					[self reconcileQuietly: subPundleModel against: matchingDatabasePundle.					eachContentDescription id: subPundleModel dbTrace.					eachContentDescription dbIdentifier: storePundle dbIdentifier].		storePundle uninstantiateSubcomponentProxies]].</body><body package="Store-Difference Management">reconcilePackage	"Compare the model and store, and put the change set into the model"	(Reconciling for: storePundle) started.	pundleModel cleanse: false.	self addClassChanges.	self addNamespaceChange.	self addMethodChanges.	self addSharedChanges.	self addPropertyChanges.	self updateDatabaseInformationInPundleModel.	(Reconciling for: storePundle) finished</body></methods><methods><class-id>Store.ReconcilingComparitor</class-id> <category>reconcile</category><body package="Store-Difference Management">reconcile	Registry cleanseModels.	pundleModel isBundle		ifTrue: [self reconcileBundle]		ifFalse: [self reconcilePackage]</body><body package="Store-Difference Management">reconcileQuietly		pundleModel isBundle 		ifTrue: [self reconcileBundle] 		ifFalse: [self reconcilePackage]</body></methods><methods><class-id>Store.ReconcilingComparitor</class-id> <category>private</category><body package="Store-Difference Management">pundleModel: aPundleModel storePundle: aStorePundle	pundleModel := aPundleModel.	storePundle := aStorePundle.	workingChangeSet := XChangeSet new.</body><body package="Store-Difference Management">reconcileQuietly: aPundleModel against: aStorePundle	self class reconcileQuietly: aPundleModel against: aStorePundle</body><body package="Store-Difference Management">updateDatabaseInformationInPundleModel		| databaseInformation |	databaseInformation := pundleModel databaseInformationOrCreate.	databaseInformation setDbTrace: nil.	databaseInformation changeSet: workingChangeSet.	pundleModel setDbTraceAndVersionUsing: storePundle for: databaseInformation dbIdentifier.	pundleModel databaseInformations removeKey: pundleModel noDbSymbol ifAbsent: [nil]</body></methods><methods><class-id>Store.ReconcilingComparitor class</class-id> <category>private</category><body package="Store-Difference Management">reconcileQuietly: aPundleModel against: aStorePundle		| instance session newPundle targetSession |	instance := self new.	targetSession := aStorePundle session.	targetSession isNil		ifTrue: 			[session := Store.Glorp.StoreLoginFactory currentStoreSession.			session system cachePolicy: Glorp.CachePolicy new]		ifFalse: [session := targetSession].	newPundle := session readOneOf: aStorePundle yourSelf class where: [:each | each primaryKey = aStorePundle primaryKey].	instance pundleModel: aPundleModel storePundle: newPundle.	instance reconcileQuietly.	targetSession ifNil: [session reset].</body></methods><methods><class-id>Store.ReconcilingComparitor class</class-id> <category>instance creation</category><body package="Store-Difference Management">reconcile: aPundleModel against: aStorePundle	| instance |	instance := self new.	instance pundleModel: aPundleModel storePundle: aStorePundle.	instance reconcile.</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableProtocolNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">fillInListFor: aNavigatorState		| classes protocols |	classes := aNavigatorState classesAndNameSpaces.	(classes size = 1 and: [aNavigatorState pundles notEmpty])		ifTrue:			[protocols := Set new.			self 				inheritedClassesOf: classes asArray first 				do: [:each | protocols addAll: (self environment sharedVariableProtocolsFor: each)]]		ifFalse: [protocols := #()].	self updateListWith: protocols</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^false</body><body package="Store-Merge Management">isForProperties	^true</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>displaying</category><body package="Store-Merge Management">typeIcon	^GeneralIcons gear</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>resolving</category><body package="Store-Merge Management">removeEmptyResolvers	| keysToRemove |	keysToRemove := OrderedCollection new.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [keysToRemove add: key].		value applied ifTrue: [keysToRemove add: key]].	keysToRemove do: [:eaKey|		resolutions removeKey: eaKey ifAbsent: [nil]]</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>accessing</category><body package="Store-UI-Unloadables Support">selectionModule	^selectionModule</body><body package="Store-UI-Unloadables Support">versions: definitionRecords	self selectionModule list: definitionRecords</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>interface opening</category><body package="Store-UI-Unloadables Support">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #selectionModule)		client: selectionModule		spec: selectionModule preferredWindowSpec		builder: aBuilder newSubBuilder.	selectionModule selectionHolder 		onChangeSend: #selectionChanged to: self</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>initialize-release</category><body package="Store-UI-Unloadables Support">initialize	super initialize.	selectionModule := ListSelectionModule new.	selectionModule displayStringSelector: #versionString</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>private</category><body package="Store-UI-Unloadables Support">selectionModuleSelection	^selectionModule selection 			ifNil: [String new]			ifNotNil: [:selection | selection definition asText]</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>aspects</category><body package="Store-UI-Unloadables Support">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>notifications</category><body package="Store-UI-Unloadables Support">selectionChanged	self text value: self selectionModuleSelection</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Unloadables Support">windowSpec	^self perform: self specPreference</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>class initialization</category><body package="Store-UI-Unloadables Support">initialize	specPreference := #horizontalWindowSpec</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>accessing</category><body package="Store-UI-Unloadables Support">specPreference		^specPreference</body><body package="Store-UI-Unloadables Support">specPreference: aSymbol		specPreference := aSymbol</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>instance creation</category><body package="Store-UI-Unloadables Support">openOnVersionsOf: aRecord	|app|	app := self new.	app versions: aRecord versions.	app open</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertiesTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.OwnerOwnershipPolicy</class-id> <category>accessing</category><body package="Store-Ownership">currentUser	^StoreUserGroup userNamed: self currentUserName</body><body package="Store-Ownership">currentUserHasOwnershipPrivilegesFor: aPundle	"Answer true if the current user has ownership rights over a pundle."		(self ownerOfPundle: aPundle) ifNil: [^true].	^StoreAccessPrivilege user: self currentUser hasPrivilege: #owner to: aPundle</body><body package="Store-Ownership">currentUserHasPublishingPrivilegesFor: aPundle	"Answer true if the current user has publishing rights over a pundle."		^StoreAccessPrivilege user: self currentUser hasPrivilege: #publish to: aPundle</body><body package="Store-Ownership">currentUserIsOwner: aPundle	"Answer true if the current user has ownership rights over a pundle."	^StoreAccessPrivilege user: self currentUser hasPrivilege: #owner to: aPundle.</body><body package="Store-Ownership">ownerOfPundle: aPundle		^(#{StoreAccessPrivilege} valueOrDo: [^super ownerOfPundle: aPundle]) ownerOfPundle: aPundle</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>private</category><body package="Store-UI">checkHealth	timer		ifNotNil: 			[self topComponent				ifNotNil: 					[:window |					window isOpen						ifTrue: 							[| contextSample |							contextSample := observedProcess suspendedContext.							contextSample = lastContext								ifFalse: 									[progressIndex := (progressIndex + 1) \\ self frameRate.									[self invalidateNow] uiEventNowFor: window].							lastContext := contextSample]]]</body><body package="Store-UI">currentProgressIcon	^SpinnerIcons perform: ('spin' , (progressIndex ) printString) asSymbol</body><body package="Store-UI">frameRate	^24</body><body package="Store-UI">isActive	^isActive value</body><body package="Store-UI">startFeedback	observedProcess := Processor activeProcess.	lastContext := nil.	progressIndex := 0.	timer := Timer every: self frameRate reciprocal seconds				do: [self checkHealth]</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>accessing</category><body package="Store-UI">isActive: anObject	isActive := anObject.	self invalidate.	self topComponent ifNotNil: [:window | window displayPendingInvalidation]</body><body package="Store-UI">observedProcess	^observedProcess</body><body package="Store-UI">observedProcess: anObject	observedProcess := anObject</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>displaying</category><body package="Store-UI">displayOn: aGC	self isActive ifFalse: [^self stopFeedback].	timer ifNil: [self startFeedback].	self displayProgressOn: aGC</body><body package="Store-UI">displayProgressOn: aGC	| icon |	icon := self currentProgressIcon.	icon displayOn: aGC at: self bounds center - icon bounds center</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>bounds accessing</category><body package="Store-UI">preferredExtent	^self currentProgressIcon preferredExtent</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>initialize-release</category><body package="Store-UI">initialize	super initialize.	isActive := [false].	progressIndex := 0</body><body package="Store-UI">release	self stopFeedback.	super release</body><body package="Store-UI">stopFeedback	timer ifNotNil: #stop.	timer := observedProcess := lastContext := nil</body></methods><methods><class-id>Store.ProcessHealthView class</class-id> <category>example</category><body package="Store-UI">example	"self example"	| window view |	window := ScheduledWindow new.	view := self new.	window component: view.	window openWithExtent: 25 @ 25.	view isActive: [InputState default shiftDown not]</body></methods><methods><class-id>Store.PseudoClassForSharedDifference</class-id> <category>accessing</category><body package="Store-Merge Management">modifiedMethodsSharedAndProperties	"Answer the truly modified differences."	^self sharedAndMethodDifferences.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>testing</category><body package="Store-Database Model">isClass	^true.</body><body package="Store-Database Model">isForClass	^true</body><body package="Store-Database Model">isForClassOrExtension	^true</body><body package="Store-Database Model">isMeta	^false</body><body package="Store-Database Model">sameAsImage	"Answer true if the receiver is the same as the image version."	| theClass |	theClass := self correspondingImageClass.	theClass isNil ifTrue: [^false].	^self = theClass asStoreClassDefinition.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>reconciling</category><body package="Store-Database Model">reconcilesWith: aStoreClassDefinition	"Return true if we appear to be the same entry, but potentially in a different database"	(super reconcilesWith: aStoreClassDefinition) ifFalse: [^false].	self superclassName = aStoreClassDefinition superclassName ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>accessing</category><body package="Store-Database Model">absoluteClassName	^self longName</body><body package="Store-Database Model">actual	^self correspondingImageClass</body><body package="Store-Database Model">allInstVarNames	"Parse our class definition to extract the instance variable names. For compatibility with code highlighting. Probably VW-specific, both in use of throughAll: and in class definition format"	| stream names |	stream := self definition readStream.	stream throughAll: 'instanceVariableNames: '''.	names := stream upTo: $'.	^(Dialect tokensBasedOn: ' ' in: names) reject: [:each | each isEmpty].</body><body package="StoreForGlorpVWUI">allStoreVersions	^[(Store.Gathering for: self name) started.		StoreClassDefinitionInPackage allVersionsWithName: self name inOwner: self environmentName]		ensure: [(Store.Gathering for: self name) finished]</body><body package="Store-Database Model">correspondingImageClass	"Return the image class that corresponds to our name. Note that they may not have the same information"	^(Dialect smalltalkAt: self longName ifAbsent: [nil])</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineClass:... version of this, not the #defineClass: version,	because the standard version calls link system too soon and also will create change objects too soon.	We support all old style class creation methods also: #subclass:... #variableByteSubclass:... and #variableSubclass:..	if there is something else, we just go with whatever there is"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineClass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'].	insertPoint := definitionString indexOfSubCollection: 'subclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadS'].	insertPoint := definitionString indexOfSubCollection: 'variableByteSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	insertPoint := definitionString indexOfSubCollection: 'variableSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	insertPoint := definitionString indexOfSubCollection: 'indexableSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadI'].	insertPoint := definitionString indexOfSubCollection: 'byteSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadB'].	^definitionString</body><body package="Store-Database Model">superclassName	^superclassName</body><body package="Store-Database Model">superclassName: aString	superclassName := aString.</body><body package="Store-Database Model">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>converting</category><body package="Store-Database Model">asStoreClassDefinition	^self</body><body package="Store-Database Model">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage classDefinitions		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: StoreClassDefinitionInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="StoreForGlorpVWUI">asTag	^Store.ClassTag newClassName: self longName.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>comparing</category><body package="StoreForGlorpVWUI">comparesTo: anObject	^self class == anObject class and: [		self absoluteName = anObject absoluteName].</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>private</category><body package="Store-Database Model">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineClass:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'super' value: (self convertVariableNodeToXML: (data at: 'superclass:')).	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'indexed-type' value: (data at: 'indexedType:') value asString.	self sax: driver tag: 'inst-vars' value: (data at: 'instanceVariableNames:') value.	self sax: driver tag: 'class-inst-vars' value: (data at: 'classInstanceVariableNames:') value.	self sax: driver tag: 'imports' value: (data at: 'imports:') value asString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	(data includesKey: 'attributes:') ifTrue:		[driver startElement: 'attributes' atts: nil.		(data at: 'attributes:') value do: [:attr |			(attr last isKindOf: Array)				ifTrue:					[driver startElement: attr first atts: nil.					attr last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: attr first value: attr last displayString]].		driver endElement].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>fileIn/Out</category><body package="Store-Database Model">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#class</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>IDE-support</category><body package="Store-Database Model">instanceBehavior	^self</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>loading</category><body package="Store-Database Model">definitionArguments	| parse |	parse := Compiler new parse: self definitionString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	^parse arguments collect: [:each | each value]</body><body package="Store-Database Model">definitionMessageUsing: aClass	| messageSend |	messageSend := aClass definitionMessage.	messageSend arguments: self definitionArguments.	^messageSend</body><body package="Store-Database Model">evaluateDefinition: aString	"See super implementor. Add handler for ClassBuilder buildFailureSignal.	Answer the result (a new Class)"	^[super evaluateDefinition: aString]		on: ClassBuilder buildFailureSignal		do: [:exception | exception proceed]</body><body package="Store-Database Model">loadSource	"Compile the class definition. On failure answer nil.	Since we want to report the reason for loading problems, we additionally raise UnloadableDefinitionNotification	with the underlying exception attached, so that interested processes can catch and evaluate it."	| newClass cmt |	newClass := self evaluateDefinition: self definitionString				onError: [:error | ^self notifyUnloadableError: error].	((cmt := self comment) notNil and: [cmt notEmpty])		ifTrue: [newClass comment: cmt]		ifFalse: [newClass comment: nil].	^newClass</body><body package="Store-Database Model">loadSourceDirect	^self loadSourceDirectInPackage: Store.Policies packagePolicy forcedPackage</body><body package="Store-Database Model">loadSourceDirectInPackage: aPackage	| existingClass knownOverrides target |	aPackage ifNil: [^self loadSource].	(existingClass := self correspondingImageClass) ifNil: [^self loadSource].	knownOverrides := Override overridesForClassOrNameSpace: existingClass.	knownOverrides ifNil: [^self loadSource].	target := knownOverrides 		detect: [:eachOverride | eachOverride sources includes: aPackage] 		ifNone: [nil].	^target isNil		ifTrue: [self loadSource]		ifFalse: [target setOverriddenDefinition: (self definitionMessageUsing: existingClass)]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeClass: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedClassObject</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>printing</category><body package="Store-Database Model">displayString	^self longNameFromSmalltalk</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>initialize-release</category><body package="Store-Database Model">initializeFrom: aClassOrOverrideOrDescriptor	self name: ((aClassOrOverrideOrDescriptor isMeta and: [(aClassOrOverrideOrDescriptor name last: 5) ~= 'class'])		ifTrue: [aClassOrOverrideOrDescriptor name, ' class']		ifFalse: [aClassOrOverrideOrDescriptor name asString]).	(aClassOrOverrideOrDescriptor isMeta not 			and: [aClassOrOverrideOrDescriptor comment notNil 			and: [aClassOrOverrideOrDescriptor comment notEmpty]])		ifTrue: [self comment: aClassOrOverrideOrDescriptor comment asString].	self definition: aClassOrOverrideOrDescriptor definition.	self environmentName: aClassOrOverrideOrDescriptor environment absoluteName.	self superclassName: (aClassOrOverrideOrDescriptor superclass isNil							ifTrue: ['nil']							ifFalse: [aClassOrOverrideOrDescriptor superclass absoluteName])</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition class</class-id> <category>instance creation</category><body package="Store-Database Model">allNamesMatching: aString in: aSessionOrNil	"For this, we only answer those that don't have the 'class' suffix (ie 'Class class')"	| results |	results := super allNamesMatching: aString in: aSessionOrNil.	^results reject: [:each | '* class' match: each]</body><body package="Store-Database Model">newFrom: aClassOrOverrideOrDescriptor	^self new initializeFrom: aClassOrOverrideOrDescriptor</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition class</class-id> <category>constants</category><body package="Store-Database Model">inPackageClass	^StoreClassDefinitionInPackage</body></methods><methods><class-id>Store.PseudoNamespaceCommentDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace definition].	aStream comment: commentObject value: mainObject</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace definition].	aStream comment: commentObject value: otherObject</body></methods><methods><class-id>Store.PseudoNamespaceCommentDifference</class-id> <category>accessing</category><body package="Store-Difference Management">resolutionClass	^NamespaceCommentChangeResolver</body><body package="Store-Difference Management">selectorListName	^(#BracketNameSpaceCommentBracket &lt;&lt; #store &gt;&gt; '[NameSpace Comment]') asString</body></methods><methods><class-id>Store.PseudoNamespaceCommentDifference</class-id> <category>loading</category><body package="Store-Difference Management">loadMainDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageNamespace comment: self mainObject</body><body package="Store-Difference Management">loadOtherDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageNamespace comment: self otherObject</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>testing</category><body package="Store-Merge Management">isForNamespace	^true</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>accessing</category><body package="Store-Merge Management">longTreeName	(name includes: $.) ifTrue: 		[^(('Root.*' match: name)			ifTrue: [name]			ifFalse: ['Root.', name]) , self applyableString].	^'Root.Smalltalk.' , name, self applyableString</body><body package="Store-Merge Management">simpleName	| index |	index := name lastIndexOf: $..	^name copyFrom: index + 1 to: name size.</body><body package="Store-Merge Management">typeIcon	^NameSpace toolListIcon</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>resolving</category><body package="Store-Merge Management">removeEmptyResolvers	| keysToRemove |	keysToRemove := OrderedCollection new.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [keysToRemove add: key].		value applied ifTrue: [keysToRemove add: key]].	keysToRemove do: [:eaKey|		resolutions removeKey: eaKey ifAbsent: [nil]].</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>displaying</category><body package="Store-Merge Management">browseVersions	| list session |	(Gathering for: self simpleName) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value package session].	list := Store.Glorp.StoreNamespaceInPackage				allVersionsWithName: self simpleName				in: session.	(Gathering for: self simpleName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: name)].	Store.Glorp.DefinitionForListTool forNameSpaces: list</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>accessing</category><body package="Store-Database Model">absoluteClassName	^self definition absoluteClassName</body><body package="StoreForGlorpVWUI">allStoreVersions	^[(Store.Gathering for: self name) started.		self class allVersionsWithName: self name inOwner: self environmentName in: package session]		ensure: [(Store.Gathering for: self name) finished]</body><body package="Store-Code Comparison">asBlueprint	| definitionParts names myReference blueprint |	blueprint := ClassBlueprint of: self.	definitionParts := blueprint parseDefinition: self definition definition.	myReference := self fullName asQualifiedReference.	blueprint reference: myReference.	(definitionParts at: #superclass:)		ifNotNil: 			[:superclassReference |			blueprint				superclassReference: superclassReference asString asQualifiedReference						makeUnambiguous].	blueprint behaviorType: (definitionParts at: #indexedType:).	names := (definitionParts at: #instanceVariableNames:)				runsFailing: #isSeparator.	blueprint instanceVariables: names.	names := (definitionParts at: #classInstanceVariableNames:)				runsFailing: #isSeparator.	blueprint classInstanceVariables: names.	blueprint isPrivate: (definitionParts at: #private:).	blueprint importsString: (definitionParts at: #imports:).	blueprint		attributes: (definitionParts at: #attributes: ifAbsent: [Array new]).	self comment ifNotNil: [:string | blueprint comment: string].	^blueprint</body><body package="Store-Database Model">comment	^definition comment.</body><body package="Store-Database Model">correspondingImageClass	^self definition correspondingImageClass</body><body package="Store-Database Model">definitionString	^self definition definitionString.</body><body package="Store-Database Model">environmentName	^self definition environmentName.</body><body package="Store-Database Model">environmentNameFromSmalltalk	^self definition environmentNameFromSmalltalk.</body><body package="Store-Database Model">longName	^self definition longName.</body><body package="Store-Database Model">metaclass	^metaclass</body><body package="Store-Database Model">metaclass: aStoreClassDefinition	metaclass := aStoreClassDefinition</body><body package="Store-Database Model">myClass	^self definition correspondingImageClass.</body><body package="Store-Database Model">name	^self definition name.</body><body package="Store-Database Model">superclass	^self superclassName.</body><body package="Store-Database Model">superclassName	^self definition superclassName.</body><body package="Store-Database Model">timestamp	^self definition timestamp.</body><body package="Store-Database Model">versions	| session classDefQuery classes uniqueKeys |	session := StoreLoginFactory currentStoreSession.	classDefQuery := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	classDefQuery alsoFetch: #definition.	classDefQuery alsoFetch: [:eachClass | eachClass definition definition].	classDefQuery orderBy: [:each | each definition timestamp descending].	classes := session execute: classDefQuery.	uniqueKeys := Set new.	^classes inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>loading</category><body package="Store-Database Model">definitionMessageUsing: aClass	^self definition definitionMessageUsing: aClass</body><body package="Store-Database Model">evaluateDefinition: aString	"See super implementor. Add handler for ClassBuilder buildFailureSignal.	Answer the result (a new Class)"	^[super evaluateDefinition: aString]		on: ClassBuilder buildFailureSignal		do: [:exception | exception proceed]</body><body package="Store-Database Model">loadNewSource: aString	^Store.Policies packagePolicy		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[| newClass cmt |			newClass := self evaluateDefinition: aString				onError: [:error | ^self raiseUnloadableError: error description inPackage: self package].			((cmt := self comment) notNil and: [cmt notEmpty])				ifTrue: [newClass comment: cmt].			newClass]</body><body package="Store-Database Model">loadSource	^Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[| newClass cmt |			newClass := self evaluateDefinition: self definitionString 						onError: [:error | ^self notifyUnloadableError: error].			((cmt := self comment) notNil and: [cmt notEmpty]) 				ifTrue: [newClass comment: cmt]				ifFalse: [newClass comment: nil].			newClass]</body><body package="Store-Database Model">loadSourceDirect	^self definition loadSourceDirectInPackage: self package storeModel</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>testing</category><body package="Store-Database Model">isClass	^true.</body><body package="Store-Database Model">isForClass	^true</body><body package="Store-Database Model">isForClassOrExtension	^true</body><body package="Store-Database Model">isMeta	^false.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>compatibility</category><body package="Store-Database Model">allInstVarNames	^self definition allInstVarNames.</body><body package="StoreForGlorpVWUI">object	^self definition correspondingImageClass.</body><body package="StoreForGlorpVWUI">removeFromPackage: aPackageModel	Store.XMainChangeSet current		addRemoveClass: self absoluteClassName		package: aPackageModel</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>comparing</category><body package="Store-Database Model">= aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifTrue:		[^self package yourSelf = aStoreObjectInPackage package yourSelf			and: [self definition reconcilesWith: aStoreObjectInPackage definition]].	aStoreObjectInPackage class == self definition class ifTrue:		[^self primaryKey notNil			ifTrue: [self primaryKey = aStoreObjectInPackage primaryKey]			ifFalse: [self definition reconcilesWith: aStoreObjectInPackage]].	(aStoreObjectInPackage respondsTo: #asStoreClassDefinition) ifFalse: [^false]. 	^self definition = aStoreObjectInPackage asStoreClassDefinition</body><body package="StoreForGlorpVWUI">comparesTo: anObject	^self definition comparesTo: anObject definition.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	metaclass := metaclass glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>filing out</category><body package="Store-Database Model">fileOutDifferencesBetween: aClassInPackage on: aSourceCodeStream	self definitionString = aClassInPackage definitionString ifFalse:		[aSourceCodeStream storeObjectDefinition: self].	self comment = aClassInPackage comment ifFalse:		[aSourceCodeStream comment: self value: self comment]</body><body package="Store-Database Model">fileOutMethodsOn: aSourceFileManager	| methods |	methods := self package methodsForClass: self meta: false.	methods do: [:each | each fileOutSourceOn: aSourceFileManager].	methods := self package methodsForClass: self meta: true.	methods do: [:each | each fileOutSourceOn: aSourceFileManager]</body><body package="Store-Database Model">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#class</body><body package="Store-Database Model">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager.	aSourceFileManager comment: self value: self comment.	self fileOutMethodsOn: aSourceFileManager</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asCommentTag	^Store.ClassCommentTag newClassName: self longName.</body><body package="Store-Database Model">asStoreClassDefinition	^self definition</body><body package="StoreForGlorpVWUI">textRepresentationForTag: aTag	^aTag isClassCommentTag		ifTrue: [self definition comment]		ifFalse: [self definition definition]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeClass: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineClass:... version of this, not the #defineClass: version,	because the standard version calls link system too soon and also will create change objects too soon.	We support all old style class creation methods also: #subclass:... #variableByteSubclass:... and #variableSubclass:..	if there is something else, we just go with whatever there is"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineClass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'].	insertPoint := definitionString indexOfSubCollection: 'subclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadS'].	insertPoint := definitionString indexOfSubCollection: 'variableByteSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	insertPoint := definitionString indexOfSubCollection: 'variableSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	insertPoint := definitionString indexOfSubCollection: 'indexableSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadI'].	insertPoint := definitionString indexOfSubCollection: 'byteSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadB'].	^definitionString</body><body package="Glorp Atomic Compiling">shadowedObjectClass	^ShadowedClassObject</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>printing</category><body package="Store-Database Model">displayString	^self longNameFromSmalltalk</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage class</class-id> <category>instance creation</category><body package="Store-Database Model">newFor: aClass package: aPackage		| classDefinition metaclassDefinition |	classDefinition := aClass asStoreClassDefinition.	classDefinition updateUserAndTimestampFrom: aPackage.	metaclassDefinition := aClass class asStoreClassDefinition.	metaclassDefinition updateUserAndTimestampFrom: aPackage.	^(self new)		definition: classDefinition;		metaclass: metaclassDefinition;		package: aPackage</body><body package="Store-Database Model">newForUninstalled: aClass package: aPackage		| classDefinition metaclassDefinition |	classDefinition := aClass asUninstalledStoreClassDefinition.	classDefinition updateUserAndTimestampFrom: aPackage.	metaclassDefinition := aClass class asUninstalledStoreClassDefinition.	metaclassDefinition updateUserAndTimestampFrom: aPackage.	^(self new)		definition: classDefinition;		metaclass: metaclassDefinition;		package: aPackage</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>actions</category><body package="Atomic Compiling and Loading">add: aResult	results addLast: aResult</body><body package="Atomic Compiling and Loading">finishInstall		results do: [:each | each finishInstall].	hasRunPostLoad ifFalse: 		[bundle postLoad: bundle createImagePundle using: self.		hasRunPostLoad := true].	bundle applyPundleVersionsToTheImage: true.</body><body package="Atomic Compiling and Loading">install		| bundleModel |	bundleModel := self installWithoutPostLoad ifNil: [^self].	bundle applyPundleVersionsToTheImage: true.	hasRunPostLoad		ifTrue: [bundleModel markNotModified]		ifFalse: [bundle postLoad: bundleModel using: self].	hasRunPostLoad := true.</body><body package="Atomic Compiling and Loading">installWithoutBundlePostLoad		| bundleModel |	bundleModel := self installWithoutPostLoad ifNil: [^self].	hasRunPostLoad ifTrue: [bundleModel markNotModified]</body><body package="Atomic Compiling and Loading">installWithoutPostLoad		| bundleModel |	installed ifFalse:		[bundle runPreRead ifFalse: [^nil].		bundle runPreLoad ifFalse: [^nil].		bundleModel := bundle createImagePundle.		bundleModel initializeFromDB: bundle].	results do: [:each | each installed ifFalse: [SystemUtils modifySystem: [each install]]].	^installed 		ifFalse: [bundleModel] 		ifTrue: [bundle createImagePundle]</body><body package="Atomic Compiling and Loading">installed		installed == true 		ifFalse: 			[self installWithoutBundlePostLoad.			installed := true]		ifTrue: 			[results do: [:each | each installed ifFalse: [SystemUtils modifySystem: [each install]]].			hasRunPostLoad ifFalse: 				[bundle postLoad: bundle createImagePundle using: self.				hasRunPostLoad := true]].	^true</body><body package="Atomic Compiling and Loading">installedWithoutBundlePostLoad		installed == true 		ifFalse: 			[self installWithoutBundlePostLoad.			installed := true]		ifTrue: [results do: [:each | each installed ifFalse: [SystemUtils modifySystem: [each install]]]].	^true</body><body package="Atomic Compiling and Loading">markContentsInstalled	results do: [:each | each markContentsInstalled]</body><body package="Atomic Compiling and Loading">markContentsInstalled: aBoolean	results do: [:each | each markContentsInstalled: aBoolean]</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>testing</category><body package="Atomic Compiling and Loading">hasChanges	^results isEmpty not</body><body package="Atomic Compiling and Loading">hasChangesToLoad		^results allSatisfy: [:each | each hasChanges]</body><body package="Atomic Compiling and Loading">hasShadowClassMatching: aClass	^self results anySatisfy: [:each | each hasShadowClassMatching: aClass]</body><body package="Atomic Compiling and Loading">hasShadowMethodMatching: aCompiledMethod	^self results anySatisfy: [:each | each hasShadowMethodMatching: aCompiledMethod]</body><body package="Atomic Compiling and Loading">isAtomicallyLoadable	"Answer false if the bundle contains an override of itself, or if any of our subcomponents are not atomically loadable."	^results allSatisfy: [:each | each isAtomicallyLoadable].</body><body package="Atomic Compiling and Loading">isCodeReader	^false</body><body package="Atomic Compiling and Loading">isCompilationResult	^true</body><body package="Atomic Compiling and Loading">isForBundle	^true</body><body package="Atomic Compiling and Loading">isFullyLoaded	"Answer true if no there are no unloadables"		^self isAtomicallyLoadable and: [((results reject: [:each | each = self]) contains: [:each | each isFullyLoaded not]) not]</body><body package="Atomic Compiling and Loading">needsEarlyInstall	bundle propertyAt: #installBeforeContinuing ifAbsent: [^false].	^true</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">bundle	^bundle</body><body package="Atomic Compiling and Loading">bundle: anObject	bundle := anObject</body><body package="Atomic Compiling and Loading">component	^bundle</body><body package="Atomic Compiling and Loading">leafItems	^self results inject: OrderedCollection new into:		[:sum :each |		sum addAll: each leafItems.		sum]</body><body package="Atomic Compiling and Loading">overrides	"I myself never have any, but my sub results may"		^#()</body><body package="Atomic Compiling and Loading">packageDifferences	^nil</body><body package="Atomic Compiling and Loading">pundle	^self bundle.</body><body package="Atomic Compiling and Loading">results		^results</body><body package="Atomic Compiling and Loading">shadowedObjects	^#()</body><body package="Atomic Compiling and Loading">unloadableDefinitions	^results inject: OrderedCollection new into: 		[ :collection :res | 		collection addAll: (res unloadableDefinitions); yourself			].</body><body package="Atomic Compiling and Loading">unloadableDefinitionsForBrowsing	"Answer a collection of Unloadable with the package set."	^results inject: OrderedCollection new into: 		[ :collection :res | 		collection addAll: (res unloadableDefinitionsForBrowsing); yourself			].</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize		results := OrderedCollection new.	hasRunPostLoad := false.	installed := false.</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $&lt;;		nextPutAll: bundle name;		nextPut: $&gt;.</body></methods><methods><class-id>BundleCompilationResult class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new		^super new initialize</body></methods><methods><class-id>Store.StorePrePublish</class-id> <category>accessing</category><body package="Store-Base">specifications	^specifications</body><body package="Store-Base">specifications: aCollection	specifications := aCollection</body></methods><methods><class-id>Store.StorePrePublish class</class-id> <category>instance creation</category><body package="Store-Base">for: aStorePublishDialog specification: aPublishSpecification	^self for: aStorePublishDialog specifications: (PublishSpecificationList with: aPublishSpecification)</body><body package="Store-Base">for: aStorePublishDialog specifications: aPublishSpecificationList	| instance |	instance := self for: aStorePublishDialog.	instance specifications: aPublishSpecificationList.	^instance</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>browsing</category><body package="StoreForGlorpBrowserUI">browseImplementors	"We need a local search block for the selection dialog."	| dialog searchString searcher |	searcher := (IncrementalSearchModule				forMethodSelectorEntry: #EnterAMethodNameC &lt;&lt; #browser						&gt;&gt; 'Enter a method name:')					searchBlock: [:string | self findLocalMethodSelectorsMatching: string].	dialog := (IncrementalSearchDialog new)				module: searcher;				requireSelection: true.	searchString := dialog select.	(searchString isNil or: [searchString isEmpty]) ifTrue: [^self].	self showWaitCursorWhile: 			[self class openOnEnvironment: (self environment						implementorsMatching: searchString asString)]</body><body package="StoreForGlorpBrowserUI">findLocalMethodSelectorsMatching: aString		| results pattern |	aString isEmpty ifTrue: [^Array new].	results := IdentitySet new: 100.	pattern := aString last = $*		ifTrue:			[results add: #*.			aString]		ifFalse: [aString , '*'].	navigator environment methodDefinitions do:		[:each |		(pattern match: each name) ifTrue:			[results add: each name asSymbol.			results size &gt; 500 ifTrue: [^results sorted]]].	^results sorted</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>interface opening</category><body package="StoreForGlorpBrowserUI">postBuildWith: aBuilder 		super postBuildWith: aBuilder.	Glorp.GlorpError.Announcements when: ObsoleteBrowserContent send: #handleGlorpError: to: self</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>menus</category><body package="StoreForGlorpBrowserUI">menuBar	| menu |	menu := Menu new.	menu		addItem:				((MenuItem labeled: #_Find &lt;&lt; #browser &gt;&gt; '&amp;Find')						nameKey: #Find;						submenu: (self buildTopLevelMenuFrom: #findMenu);						yourself);		addItem:				((MenuItem labeled: #_View &lt;&lt; #browser &gt;&gt; '&amp;View')						nameKey: #View;						submenu: (self buildTopLevelMenuFrom: #viewMenu);						yourself).	navigator ifNotNil: [:nav | nav windowMenuItems		do:			[:each | 			menu				addItem:					((MenuItem labeled: each key)						nameKey: (each key copyWithout: $&amp;) asSymbol;						submenu: each value;						yourself)]].	menu		addItem:				((MenuItem labeled: #Tools &lt;&lt; #browser &gt;&gt; 'Tools')						nameKey: #Tools;						submenu: (self buildTopLevelMenuFrom: #toolsMenu);						yourself);		addItem:				((MenuItem labeled: #Help &lt;&lt; #browser &gt;&gt; 'Help')						nameKey: #Help;						submenu: (self buildTopLevelMenuFrom: #helpMenu);						yourself).	menu		augmentFrom: self class		to: self menuAugmentationRoot		menuName: #menuBar		for: self.	^menu</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">codeModelClass	^StoreCodeModel</body><body package="StoreForGlorpBrowserUI">isStatusBarEnabled	"The Store browser does not have a status bar."		^false</body><body package="StoreForGlorpBrowserUI">terminateBrowser	self release.	self builder ifNotNil: [self closeAndUnschedule]</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">isGlobalSelected	"We always have a local environment confined to the selection from the database."	^false</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI">storeLabelImage	| text |	text := navigator environment repositoryName asText				emphasizeAllWith: (Array						with: #color -&gt; (ColorValue red: 0.29 green: 0.43 blue: 0.76)						with: #bold						with: #large).	^VisualRow		withAll: (Array				with: GeneralIcons repository				with: (PixelSpace width: 5)				with: (Label with: text))					, (Array with: (PixelSpace width: 5) with: GeneralIcons repository)</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>interface closing</category><body package="StoreForGlorpBrowserUI">noticeOfWindowClose: aWindow 	"The ApplicationWindow aWindow is in the process of closing. 	You have been notified."	Glorp.GlorpError.Announcements unsubscribe: self.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>error handling</category><body package="StoreForGlorpBrowserUI">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self navigator environment glorpSession.	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn: (#DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printString)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser class</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">browserEnvironmentClass	^StoreForGlorpBrowserEnvironment</body><body package="StoreForGlorpBrowserUI">cleanUpObsoleteInstances	"Once a repository connection is closed, any open instances are not revivable, even if the repository is connected again."	self allInstances do: [:ea | ea terminateBrowser]</body><body package="StoreForGlorpBrowserUI">navigatorStateClass		^StoreForGlorpNavigatorState</body></methods><methods><class-id>Store.Preloading</class-id> <category>accessing</category><body package="Store-Base">actionText	^(#Preloading &lt;&lt; #store &gt;&gt; 'Preloading') asString</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>testing</category><body package="Store-Merge Management">isApplyable	^classInImage</body><body package="Store-Merge Management">isForClass	^true</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>accessing</category><body package="Store-Merge Management">longTreeName	(name includes: $.) ifTrue: 		[('Root.*' match: name) ifTrue: [^name , self applyableString]].	^'Root.Smalltalk.' , name, self applyableString</body><body package="Store-Merge Management">simpleName	| index |	index := name lastIndexOf: $..	^name copyFrom: index + 1 to: name size.</body><body package="Store-Merge Management">sortedTreeResolutionValues: aSymbol	| result resolution values rejectBlock |	rejectBlock := self rejectBlockFor: aSymbol.	result := OrderedCollection new.	resolution := resolutions detect: [:each | each isDefintionResolver] ifNone: [nil].	resolution ifNotNil: [result add: resolution].	resolution := resolutions detect: [:each | each isCommentResolver] ifNone: [nil].	resolution ifNotNil: [result add: resolution].	result := result reject: rejectBlock.	values := self sortedResolutionsSelectedBy: [:each | (each isMethodResolver and: [each isMeta]) and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | (each isMethodResolver and: [each isMeta not]) and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | each isSharedResolver and: [(rejectBlock value: each) not]].	result addAll: values.	^result</body><body package="Store-Merge Management">typeIcon	classInImage ifFalse: [^GeneralIcons padlock].	^Behavior toolListIcon</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>resolving</category><body package="Store-Merge Management">makeResolutionProposals		self resolutions do: [:each | each makeResolutionProposals].	name asStrictReference bindingOrNil ifNotNil:		[:value | 		resolutions at: name ifAbsent: [classInImage := value isForClass]].	classInImage ifFalse: [resolutions do: [:each | each markUnapplyable]].</body><body package="Store-Merge Management">removeEmptyResolvers	| keysToRemove |	keysToRemove := OrderedCollection new.	resolutions keysAndValuesDo:		[:key :value |		value isProposedRemovalInPackage ifFalse: [keysToRemove add: key].		value alternatives isEmpty ifTrue: [keysToRemove add: key].		value applied ifTrue: [keysToRemove add: key]].	keysToRemove do: [:eaKey|		resolutions removeKey: eaKey ifAbsent: [nil]].</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	super initialize.	classInImage := true.</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>displaying</category><body package="Store-Merge Management">browseVersions	| list session |	(Gathering for: self simpleName) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value package session].	list := Store.Glorp.StoreClassDefinitionInPackage				allVersionsWithName: self simpleName				in: session.	(Gathering for: self simpleName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: name)].	Store.Glorp.DefinitionForListTool forClasses: list</body></methods><methods><class-id>Store.PundleSavedChange</class-id> <category>fileIn/Out</category><body package="Store-Change Management">fileIn	"File-in the receiver - ie. make the change to the system."	"Note- The saving of a Pundle action is same as loading. "	super fileIn</body><body package="Store-Change Management">fileOutOn: aSourceFile	aSourceFile		savePundleNamed: componentName		type: componentType		primaryKey: databaseId		databaseId: primaryKey</body></methods><methods><class-id>Store.PundleSavedChange</class-id> <category>accessing</category><body package="Store-Change Management">actionString	"Answer a string for messages describing the receiver."	^(#SavedTo &lt;&lt; #store &gt;&gt; ' saved to ') asString</body><body package="Store-Change Management">type 	"Answer the sub-type of this kind of change."	^#componentSaved</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private</category><body package="Store-Change Management">formatStructure: structure	"Answers a formatted print string for the bundle structure."		| stream |	stream := (String new: 256) writeStream.	structure do:		[ :array |		stream 			nextPutAll: array first printString; tab; tab;			nextPutAll: array last; cr		].	^stream contents</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: dbPackage into: imgPackage	"Load the change. Answer true is the operation is successful."	dbPackage isLoaded		ifTrue: [ ^true ].		"already the in image version"	imgPackage structure: dbPackage structure.	^true.</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	tolerantBoolean 		ifFalse: 			[Dialog 				warn: (#CannotRemoveBundleStructure &lt;&lt; #store 						&gt;&gt; 'Cannot remove bundle structure') asString]</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>testing</category><body package="Store-Change Management">existsInImage	 ^self containingPackage ~~ nil</body><body package="Store-Change Management">is: dbPackage meaningfulChangeOf: imgPackage 	^imgPackage == nil | (dbPackage == nil) 		or: [imgPackage structure ~= dbPackage structure]</body><body package="Store-Change Management">isStructureTag	^true</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>accessing</category><body package="Store-Change Management">containingPackage	"Answer a packge that contians the defintion described by me, nil if none."	^package == nil		ifFalse: [ Registry bundleNamed: package name]</body><body package="Store-Change Management">description	^self name</body><body package="Store-Change Management">name	^'&lt;1s&gt; structure' 		expandMacrosWith: self packageName</body><body package="Store-Change Management">sourceTextForImage	^self sourceTextForImage: self containingPackage</body><body package="Store-Change Management">sourceTextForImage: aPackage	aPackage == nil		ifTrue: [ ^'' ].	^self formatStructure: aPackage structure.</body><body package="Store-Change Management">symbolKey	^#BundleStructure</body><body package="Store-Change Management">text	package == nil 		ifTrue: [ ^'' ].	^self formatStructure: package structure.</body><body package="Store-Change Management">textRepresentationForTag: aTag 	^self text.</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| pkg |	^( pkg := self containingPackage ) == nil		ifTrue: [ false ]		ifFalse: [ pkg structure: package structure ].</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>converting</category><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch. Answer nil if it's someone elses structure"	^( ( package isNil )  or: [ package comparesTo: aPackage ] )		ifTrue: [ 	aPackage recordForStructureTag: self ]</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersion	BundleSpecEditor openOnBundle: package</body><body package="Store-Change Management">definition	^self text</body><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	package == nil		ifFalse: [ aStream bundleStructure: package ].</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aStream bundleStructure: aRecord</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"nonsense"	^self shouldNotImplement</body><body package="Store-Change Management">loadSrcIntoPackage: aPackage confirm: aBoolean	"Load the receiver by setting its bundle structure."	aBoolean 		ifTrue: 			[ ( Dialog confirm: ( (#Reset1sBundleStructure &lt;&lt; #store &gt;&gt; 'Reset &lt;1s&gt; bundle structure?') expandMacrosWith: aPackage name ) )				ifFalse: [ ^self ].			].	aPackage structure: package structure</body></methods><methods><class-id>Store.BundleStructureTag class</class-id> <category>instance creation</category><body package="Store-Change Management">bundle: aBundle	^self new		package: aBundle;		yourself</body></methods><methods><class-id>Store.BundleStructureTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^11</body></methods><methods><class-id>Store.Glorp.StoreBundleSubBundleRelationship</class-id> <category>accessing</category><body package="Store-Database Model">bundleID		^bundleID</body><body package="Store-Database Model">bundleID: anObject		bundleID := anObject</body><body package="Store-Database Model">expressionID		^expressionID</body><body package="Store-Database Model">expressionID: anObject		expressionID := anObject</body><body package="Store-Database Model">sequence		^sequence</body><body package="Store-Database Model">sequence: anObject		sequence := anObject</body><body package="Store-Database Model">subbundleID		^subbundleID</body><body package="Store-Database Model">subbundleID: anObject		subbundleID := anObject</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">isDefintionResolver	^true</body><body package="Store-Merge Management">isMove	^movePair notNil</body><body package="Store-Merge Management">isNameSpaceDefinitionResolver	^true</body><body package="Store-Merge Management">isPotentialMove	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	| reference |	proposed ifNil: [^true].	proposed isRemovalResolution ifFalse: [^true].	(reference := self definitionName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^(((Registry containingPackageForNameSpace: reference value) name = proposed package name) or: 		[Override isOverriddenClassOrNameSpace: reference value in: proposed package storeModel])</body><body package="Store-Merge Management">sameDefinitionAs: aString	| reference |	(reference := self definitionName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value definitionString = aString</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	| existingPackage |	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isNoOpResolution]]]) 			ifTrue: [^true].	self isMove ifTrue: [^self applyMove].	self hasOverrideAndShouldApply ifFalse: [^false].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	(existingPackage := self existingDefinitionPackage) isNil ifTrue: [^self applyChange].	^existingPackage = proposed package storeModel		ifTrue: [self applyChange]		ifFalse: [self applyOverride].</body><body package="Store-Merge Management">applyAsRemove	| namespace overrides changeManager targetOverride |	namespace := self longOwnerName asQualifiedReference value.	refactoring := (overrides := self existingOverrides) isEmpty		ifTrue: [RemoveNameSpaceChange objectName: namespace absoluteName]		ifFalse: 			[(targetOverride := overrides detect: [:each | each sources includes: proposed package storeModel] ifNone: [nil]) notNil				ifTrue: [RemoveOverrideChange for: targetOverride]				ifFalse: [RestoreOverrideChange for: overrides last]].	changeManager := RefactoryChangeManager instance.	^[[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: RedefinitionNotification		do: [:exception | exception currentPackage = proposed package storeModel ifTrue: [exception resume] ifFalse: [exception return: false]]]			on: Error			do: 				[:exception | 				Transcript show: (#nApplyingRemovalNamespaceFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of NameSpace &lt;2s&gt; Failed: &lt;1s&gt;' 					expandMacrosWith: exception messageText					with: self definitionName).				exception return: false].</body><body package="Store-Merge Management">applyChange	| changeManager |	^[refactoring := AddNameSpaceChange definition: proposed value.	refactoring package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	changeManager performChange: refactoring.	undo := changeManager undoChange.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingNameSpaceChangeFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying NameSpace Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">applyMove	| targetResolver changeManager |	applied ifTrue: [^true].	targetResolver := proposed isRemovalResolution		ifTrue: [movePair proposed]		ifFalse: [proposed].	refactoring := MoveNameSpaceToPackageChange		nameSpace: self longOwnerName asStrictReference value		package: targetResolver package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	self markApplied.	movePair markApplied.	true]			on: Error			do: 				[:exception |				Transcript 					show: (#nApplyingClassMoveFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying Class Move Change Failed &lt;2s&gt; : &lt;1s&gt;'							expandMacrosWith: exception messageText							with: self mergeDisplayName).				exception return: false]</body><body package="Store-Merge Management">applyOverride	| changeManager namespace |	namespace := self longOwnerName asQualifiedReference value.	refactoring := CompositeRefactoryChange named: 'Merge Override Class'.	refactoring addChange: (MoveNameSpaceToPackageChange 		nameSpace: namespace		package: proposed package storeModel).	refactoring addChange: (AddOverrideChange for: (Override forNameSpace: namespace)).	refactoring addChange: (AddNameSpaceChange definition: proposed value).	refactoring changes last package: proposed package storeModel.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do: 			[:exception |			Transcript 				show: (#nApplyingNameSpaceOverrideFailed1s &lt;&lt; #store						&gt;&gt; '&lt;n&gt;Applying NameSpace Override Change Failed &lt;2s&gt; : &lt;1s&gt;'					expandMacrosWith: exception messageText					with: self mergeDisplayName).			exception return: false]</body><body package="Store-Merge Management">existingDefinitionPackage		^Store.Registry containingPackageForNameSpaceSymbol: self longOwnerName asSymbol</body><body package="Store-Merge Management">existingOverrides	^(Override overridesForClassOrNameSpace: (self longOwnerName asStrictReference valueOrDo: [^#()])) ifNil: [^#()]</body><body package="Store-Merge Management">hasOverrideAndShouldApply		self existingDefinitionPackage ifNotNil:		[:value | 		value name = proposed package name ifFalse:			[(self proceedWithPossibleOverrideFrom: value name to: proposed package name) ifFalse:				[Transcript					show:						(#nDidNotApplyOverrideNamespace1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of NameSpace &lt;1s&gt; in &lt;2s&gt;'							expandMacrosWith: self longOwnerName							with: proposed package name).				^false]]].	^true</body><body package="Store-Merge Management">ownerNameForLoadOrdering	^self environmentString</body><body package="Store-Merge Management">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingChangeNS1sn2sOveride3snn &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;NameSpace "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longOwnerName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">raiseNoticeFor: aCompilerError	aCompilerError type = #undeclared ifTrue: 		[Dialog warn: (#UnknownVariableSpaceColonSpace1s &lt;&lt; #dialogs &gt;&gt; 'Unknown Variable : &lt;1s&gt;' expandMacrosWith: aCompilerError parameter key).		^nil].	^super raiseNoticeFor: aCompilerError</body><body package="Store-Merge Management">validateParse: aNodeHolder	"Answer false if there is a problem, true otherwise"		| mainStatementNode selector methodCollector filter alternative oldNode oldStatementNode receiver name |	mainStatementNode := aNodeHolder node block body statements first.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	oldNode := self parseDefinition: alternative value in: self owningEnvironment.	oldStatementNode := oldNode node block body statements first.	receiver := mainStatementNode receiver name.	oldStatementNode receiver name = receiver ifFalse:		[Dialog warn: #NamespaceMustNotChange &lt;&lt; #store &gt;&gt; 'NameSpace must not change'.		^false].	name := (mainStatementNode arguments first) value asString.	(oldStatementNode arguments first) value asString = name ifFalse:		[Dialog warn: #NameOfTheNameSpaceMustNotChange &lt;&lt; #store &gt;&gt; 'Name of the NameSpace must not change'.		^false].	selector := mainStatementNode selector.	methodCollector := MethodCollector new.	filter := methodCollector implementorsOf: selector.	(methodCollector select: filter) isEmpty ifTrue:		[Dialog warn: #BadDefinitionMessage &lt;&lt; #store &gt;&gt; 'Bad Definition Message'.		^false].	oldStatementNode selector = selector ifFalse:		[Dialog warn: #DefinitionMessageMustNotChange &lt;&lt; #store &gt;&gt; 'Definition message must not change'.		^false].	^true</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">browseVersions	| alternative list session |	alternative := self standardResolutionAlternative.	alternative		ifNil: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self definitionName)].	session := alternative package session.	(Gathering for: self definitionName) started.	list := StoreNamespaceInPackage allVersionsWithName: self definitionName				in: session.	(Gathering for: self definitionName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self definitionName)].	DefinitionForListTool forNameSpaces: list</body><body package="Store-Merge Management">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[movePair notNil 	ifTrue: 			[^applied 				ifTrue: [self movedToPackageString]				ifFalse: [self moveToPackageString]].		^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management">listIcon	^NameSpace toolListIcon</body><body package="Store-Merge Management">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">mergeDisplayName		^(#BracketNameSpaceDefinition &lt;&lt; #store &gt;&gt; '[NameSpace Definition]') asString</body><body package="Store-Merge Management">moveFromPackageString	^self moveFromPackage: movePair proposed package name</body><body package="Store-Merge Management">moveToPackageString	^self moveToPackage: movePair proposed package name</body><body package="Store-Merge Management">movedFromPackageString	^self movedFromPackage: movePair proposed package name</body><body package="Store-Merge Management">movedToPackageString	^self movedToPackage: movePair proposed package name</body><body package="Store-Merge Management">shortListName	| string |	string := self ownerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>applying</category><body package="Store-Merge Management">definitionName	| methodNodeHolder target |	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first arguments first value asString</body><body package="Store-Merge Management">environmentString	| methodNodeHolder target |	proposed isAbsentResolution ifTrue: [^'Root'].	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^'Root'].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first receiver name asString</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management">movePair	^movePair</body><body package="Store-Merge Management">movePair: aNamespaceChangeResolver	movePair := aNamespaceChangeResolver</body></methods><methods><class-id>Store.PseudoPropertiesDifference</class-id> <category>testing</category><body package="Store-Difference Management">hasBothDefinitions	^true</body><body package="Store-Difference Management">isBundleStructureOnly	| result |	result := false.	mainObject ifNotNil: [result := mainObject size = 1 and: [mainObject first key = #structure]].	otherObject ifNotNil: [result := result and: [otherPackage pseudoPackage or: [otherObject size = 1 and: [otherObject first key = #structure]]]].	^result</body><body package="Store-Difference Management">isMainDefinedInPackage	^true</body><body package="Store-Difference Management">isOtherDefinedInPackage	^true</body><body package="Store-Difference Management">isStandin	^true</body></methods><methods><class-id>Store.PseudoPropertiesDifference</class-id> <category>accessing</category><body package="Store-Difference Management">changedMethodsSharedAndProperties	| properties |	properties := OrderedCollection new.	mainObject do:		[:each |		| targetProperty |		properties add: (targetProperty := PseudoPropertyDifference mainPackage: mainPackage property: each).		(otherPackage notNil and: [otherObject isEmpty]) ifTrue: [targetProperty otherPackage: otherPackage]].	otherObject do:		[:each |		| targetProperty |		targetProperty := properties 			detect: [:eachProperty | eachProperty selectorListName = each key]			ifNone: [nil].		targetProperty isNil			ifTrue: [properties add: (PseudoPropertyDifference otherPackage: otherPackage property: each)]			ifFalse: [targetProperty otherPackage: otherPackage property: each]].	^properties</body><body package="Store-Difference Management">classListIcon	^GeneralIcons gear</body><body package="Store-Difference Management">classListName	^self class classListName</body><body package="Store-Difference Management">mainPackage: aPackage properties: aCollection	self mainPackage: aPackage object: aCollection</body><body package="Store-Difference Management">modifiedMethodsSharedAndProperties	^self changedMethodsSharedAndProperties</body><body package="Store-Difference Management">otherPackage: aPackage properties: aCollection	self otherPackage: aPackage object: aCollection</body><body package="Store-Difference Management">referencesHolderClass 	^PropertyResolutions</body></methods><methods><class-id>Store.PseudoPropertiesDifference class</class-id> <category>accessing</category><body package="Store-Difference Management">classListName	^(#BracketPropertiesBracket &lt;&lt; #store &gt;&gt; '[Properties]') asString</body></methods><methods><class-id>Store.PseudoPropertiesDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage properties: aCollection	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: aCollection;		yourself</body><body package="Store-Difference Management">otherPackage: aPackage properties: aCollection	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: aCollection;		yourself</body></methods><methods><class-id>Store.BundleHasUnpublisedChangesConfirmation</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		^Dialog		confirm:			(#T1sHasUnpublisheUdedNttttContinue &lt;&lt; #store &gt;&gt;					'&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.BundleHasUnpublisedChangesConfirmation</class-id> <category>constants</category><body package="Store-Base">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="Store-Base">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.BundleHasUnpublisedChangesConfirmation class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Tools.BindingTextualDetailSingularView</class-id> <category>initialize-release</category><body package="Store-Code Comparison">icon: aGraphic name: aStringThing text: aText	icon := aGraphic.	name := aStringThing.	text := aText.	self populate</body></methods><methods><class-id>Tools.BindingTextualDetailSingularView</class-id> <category>row population</category><body package="Store-Code Comparison">computeDetailRows	| view |	view := TextEditorView model: text asText asValue.	view beReadOnly.	^Array with: view</body><body package="Store-Code Comparison">populateHeader	| header |	super populateHeader.	header := self header.	header add: icon.	header add: (self italicizedText: name)</body></methods><methods><class-id>Tools.BindingTextualDetailSingularView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^Array with: #singleBindingDetail with: name</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>accessing</category><body package="Store-Merge Management">addChildren: aCollectionOfVersionNodes		children addAll: aCollectionOfVersionNodes.	aCollectionOfVersionNodes do: [:each | each parent: self]</body><body package="Store-Merge Management">children	^children</body><body package="Store-Merge Management">children: aCollection	children := aCollection</body><body package="Store-Merge Management">isLeaf	^children isEmpty</body><body package="Store-Merge Management">isRoot	^parent isNil</body><body package="Store-Merge Management">leaves	"Assuming that I'm the root of the tree answer all leaves."		| leaves |	children isEmpty ifTrue: [^OrderedSet with: self].	leaves := OrderedSet new.	children do: [:each | leaves addAll: each leaves].	^leaves</body><body package="Store-Merge Management">level	^level</body><body package="Store-Merge Management">maxLevel	"Assuming that I'm the root of the tree 	calculate the biggest level."	| maxLevel |	maxLevel := level.	children do: [:each | maxLevel := maxLevel max: each maxLevel].	^maxLevel</body><body package="Store-Merge Management">nodesAtLevel: anInteger	"Assuming that I'm the root of the tree answer all my children that are at level aLevel."		| result |	level = anInteger ifTrue: [^OrderedSet with: self].	result := OrderedSet new.	children do: [:each | result addAll: (each nodesAtLevel: anInteger)].	^result</body><body package="Store-Merge Management">package	^package</body><body package="Store-Merge Management">package: aStorePundle	package := aStorePundle</body><body package="Store-Merge Management">parent	^parent</body><body package="Store-Merge Management">parent: aVersionNode	parent := aVersionNode</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>initialize release</category><body package="Store-Merge Management">initialize	children := OrderedSet new.</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>private-calculations</category><body package="Store-Merge Management">becomeParentFor: aVersionNode	aVersionNode parent: self.	children add: aVersionNode.</body><body package="Store-Merge Management">buildTowardsRoot: aRootVersionNode initial: aVersionNode	"Move towards the specified root. 	If I'm older then the root then process stops. 	If I'm part of another tree then reparent the root of the other tree off the 'initialNode'.	Answer either root or the node containing package older then the root.	If the common ancestor of me and aRoot cannot be found	raise an exception and then answer nil."		| node parentPundle |	(aRootVersionNode package youngerThan: self package) ifTrue: [^self].	parentPundle := self package tracePackage yourSelf.	node := parentPundle isNil		ifTrue:			["We cannot reach the root, Raise a signal."			NoCommonAncestor raiseRequestWith: (Array with: self package with: aRootVersionNode package).			^nil]		ifFalse: [aRootVersionNode nodeContainingVersion: parentPundle primaryKey].	^node isNil		ifTrue:			[node := self class on: parentPundle.			node becomeParentFor: self.			node buildTowardsRoot: aRootVersionNode initial: aVersionNode]		ifFalse:			[node becomeParentFor: self.			aRootVersionNode]</body><body package="Store-Merge Management">buildTree: aCollectionOfPundleVersions	"Given an initial package version find all integration-ready versions and build a tree which encompasses all 	integration-ready versions. Answer the root of the newly built tree."		| rootNode |	rootNode := self.	aCollectionOfPundleVersions		do:			[:eachVersion | 			(rootNode nodeContainingVersion: eachVersion primaryKey) isNil				ifTrue:					[| childNode parentNode resultNode |					childNode := self class on: eachVersion.					parentNode := rootNode.					[resultNode := childNode buildTowardsRoot: parentNode initial: self.					resultNode = parentNode or: [resultNode isNil]]						whileFalse:							[childNode := parentNode.							parentNode := resultNode].					resultNode notNil ifTrue: [rootNode := resultNode]]].	[rootNode compressPreserving: self] whileFalse.	rootNode setLevel: 0.	^rootNode</body><body package="Store-Merge Management">compressPreserving: aVersionNode	"Remove all the intermediate nodes. Children are moved up to parent.	The result is a tree with each leaf having its own branch starting at the root.	Do not remove aNode."		self isLeaf ifTrue: [^true].	^(self isRoot not and: [self package ~= aVersionNode package])		ifTrue:			[parent remove: self.			parent addChildren: children.			children do: [:eachVersionNode | eachVersionNode compressPreserving: aVersionNode].			false]		ifFalse: [children shallowCopy inject: true into: [:sum :each | sum &amp; (each compressPreserving: aVersionNode)]]</body><body package="Store-Merge Management">remove: aVersionNode	"Remove aNode form my children."		children remove: aVersionNode</body><body package="Store-Merge Management">setLevel: anInteger		level := anInteger.	children do: [:each | each setLevel: anInteger + 1]</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>testing</category><body package="Store-Merge Management">nodeContainingVersion: anInteger	"Starting from the receiver as a tree root, answer a node which contains a package with	the specified key."		| result |	self package primaryKey = anInteger ifTrue: [^self].	self children do: [:each | (result := each nodeContainingVersion: anInteger) notNil ifTrue: [^result]].	^nil</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>printing</category><body package="Store-Merge Management">basicNodePrintOn: aStream		aStream nextPutAll: package version.	children isEmpty ifTrue: [^self].	aStream space.	aStream nextPut: $(.	children do: [:each | each printChildrenOn: aStream first: true] separatedBy: [aStream nextPut: $-].	aStream nextPut: $)</body><body package="Store-Merge Management">printChildrenOn: aStream first: aBoolean		aBoolean ifFalse: [aStream nextPut: $-].	self basicNodePrintOn: aStream</body><body package="Store-Merge Management">printOn: aStream		aStream nextPut: Character space.	parent isNil ifFalse: [self printParentOn: aStream last: true].	self basicNodePrintOn: aStream</body><body package="Store-Merge Management">printParentOn: aStream last: aBoolean		parent isNil ifFalse: [parent printParentOn: aStream last: false].	aBoolean ifTrue: [^self].	aStream nextPutAll: package version.	aStream nextPut: $-</body></methods><methods><class-id>Store.Glorp.VersionNode class</class-id> <category>instance creation</category><body package="Store-Merge Management">on: aPackageVersion 	^(self new) initialize; package: aPackageVersion; yourself</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>interface opening</category><body package="Store-Merge Management">computeTitle	| pundleNames |	pundleNames := resolutionManager packageNames asSortedCollection.	^bundles size = 0		ifTrue: [			pundleNames size = 1				ifTrue: [#MergingPackage1s &lt;&lt; #store &gt;&gt; 'Merging Package &lt;1s&gt;'						expandMacrosWith: pundleNames any]							ifFalse: [#Merging1pPackages &lt;&lt; #store &gt;&gt; 'Merging &lt;1p&gt; Packages'						expandMacrosWith: pundleNames size]]		ifFalse: [#Merging1pBundlesAnd2pPackages &lt;&lt; #store			&gt;&gt; 'Merging &lt;1p&gt; Bundles and &lt;2p&gt; Packages' expandMacrosWith: bundles size			with: pundleNames size]</body><body package="Store-Merge Management">emptyLableAndIcon 	^LabelAndIcon with: ''.</body><body package="Store-Merge Management">labelForPackageAtIndex: anInteger inView: aView 	| label rec |	selectedResolution isNil 		ifTrue: [^self emptyLableAndIcon].	rec := self packageList list at: anInteger.	label := LabelAndIcon 		with: rec labelText		attributes: aView textStyle.	label icon: (rec icon ifNil: [PixelSpace extent: 20]).	^label</body><body package="Store-Merge Management">postBuildWith: aBuilder 	"Replace controller with one with more sanity."	super postBuildWith: aBuilder.	(builder window)		application: self;		sendWindowEvents: #(#newGraphicsDevice #reopen).	(aBuilder componentAt: #ModTabs) widget tabBar component		displayStringSelector: #tabLabel.	self setupPackageListWidget.	self setupTextWidget.	self compareWithHolderChanged.</body><body package="Store-Merge Management">postOpenWith: aBuilder	super postOpenWith: aBuilder.	builder window damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	builder window toolbarVisible: ShowToolbar.	self updateToolbar.	self displayInitialList.</body><body package="Store-Merge Management">reverseLabel: aLabel 	"Build the wrappers needed to reverse the label to show it selected."	| rw |	rw := ReversingWrapper on: aLabel.	rw reverse setValue: true.	^BoundedWrapper on: rw</body><body package="Store-Merge Management">setupPackageListWidget	| listView |	listView := self packageListWidget.	listView selectedVisualBlock: 			[:view :index | 			self reverseLabel: (self labelForPackageAtIndex: index inView: view)].	listView visualBlock: 			[:view :index | 			BoundedWrapper on: (self labelForPackageAtIndex: index inView: view)]</body><body package="Store-Merge Management">setupTextWidget	(builder componentAt: #displayTextID) widget controller autoAccept: false</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>aspects</category><body package="Store-Merge Management">compareWithHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^compareWithHolder isNil		ifTrue:			[compareWithHolder := nil asValue]		ifFalse:			[compareWithHolder]</body><body package="Store-Merge Management">conflictProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^conflictProtocol isNil		ifTrue:			[conflictProtocol := Text new asValue]		ifFalse:			[conflictProtocol]</body><body package="Store-Merge Management">conflictProtocolText		conflictType == #conflictsWithImage ifTrue: [^selectedResolution originalProtocol].	conflictType == #conflictsWithBase ifTrue: [^selectedResolution baseProtocol].	conflictType == #conflictsWithResolution ifTrue: [^selectedResolution proposedProtocol].	^''</body><body package="Store-Merge Management">conflictText	"Answer the text to display in the conflict text pane."	^conflictText</body><body package="Store-Merge Management">displayText	^displayText</body><body package="Store-Merge Management">isShowingCodeDifferences	^differencesType = #showCodeDifferences.</body><body package="Store-Merge Management">isShowingSourceDifferences	^differencesType = #showSourceDifferences.</body><body package="Store-Merge Management">packageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageList isNil		ifTrue:			[packageList := MultiSelectionInList new]		ifFalse:			[packageList]</body><body package="Store-Merge Management">resolutionListTabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^resolutionListTabs isNil		ifTrue:			[resolutionListTabs := SelectionInList new]		ifFalse:			[resolutionListTabs]</body><body package="Store-Merge Management">selectionProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectionProtocol isNil		ifTrue:			[selectionProtocol := Text new asValue]		ifFalse:			[selectionProtocol]</body><body package="Store-Merge Management">setConflictText	| selectionText compareText selectionFragments compareFragments skipCompare |	selectionText := self displayText value.	(selectedResolution == nil or: 			[self packageListIndexes isEmpty				or: [selectedResolution notNil and: [selectedResolution isResolver not]]])		ifTrue: 			[selectionText emphasizeAllWith: #normal.			^conflictText value: Text new].	conflictType == #conflictsWithImage		ifTrue: [compareText := self imageText].	conflictType == #conflictsWithBase ifTrue: [compareText := self baseText].	conflictType == #conflictsWithResolution		ifTrue: [compareText := self resolutionText].	selectionFragments := selectionText smalltalkOrWordAndWhitespaceFragments.	compareFragments := compareText smalltalkOrWordAndWhitespaceFragments.	skipCompare := false.	(skipCompare := self stringsNotForCompare includes: selectionText string) ifTrue:		[selectionText emphasizeAllWith: self ignoreTextEmphasis].	(self stringsNotForCompare includes: compareText string) ifTrue:		[skipCompare := true.		compareText emphasizeAllWith: self ignoreTextEmphasis].	skipCompare		ifFalse:			[(compareFragments differences: selectionFragments)				do: #applyAnyDifferenceTextEmphases].	textMode := #internal.	displayText value: selectionText.	textMode := #external.	conflictText value: compareText</body><body package="Store-Merge Management">showCodeDifferences	differencesType := #showCodeDifferences.	self updateText</body><body package="Store-Merge Management">showSourceDifferences	differencesType := #showSourceDifferences.	self updateText.</body><body package="Store-Merge Management">sourceCompareMenu	| menu |	menu := Menu new.	menu		addItem: ((MenuItem labeled: (#BaseColonSpace &lt;&lt; #store &gt;&gt; 'Base: ') asText							, self baseLabel asText allBold)					value: #conflictsWithBase);		addItem: ((MenuItem					labeled: (#ResolutionColonSpace &lt;&lt; #store &gt;&gt; 'Resolution: ') asText							, self resolutionLabel asText allBold)						value: #conflictsWithResolution);		addItem: ((MenuItem labeled: (#ImageColonSpace &lt;&lt; #store &gt;&gt; 'Image: ') asText							, self imageLabel asText allBold)					value: #conflictsWithImage).	^menu</body><body package="Store-Merge Management">sourceCompareMenuBlock	^[self sourceCompareMenu]</body><body package="Store-Merge Management">toolbarMenuHolder	toolbarMenuHolder isNil ifTrue:		[toolbarMenuHolder := self class toolbarMenu asValue].	^toolbarMenuHolder</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>testing</category><body package="Store-Merge Management">areAllApplied	^resolutionManager successfullyAppliedAll</body><body package="Store-Merge Management">areTextViewsZoomed	^(self builder componentAt: #pkgListID) isVisible not</body><body package="Store-Merge Management">autoSelectResolution	^autoSelectResolution</body><body package="Store-Merge Management">canApplyResolution	^selectedResolution notNil and:		[(self currentResolutionPackageItem notNil and:		[self currentResolutionPackageItem proposed and:		[selectedResolution isApplyable]]) or:		[selectedResolution isResolved]]</body><body package="Store-Merge Management">canBrowseVersions	^selectedResolution notNil and:		[selectedResolution canBrowseVersions]</body><body package="Store-Merge Management">canChooseDoNotResolve	^selectedResolution notNil</body><body package="Store-Merge Management">canCompareWithResolution		^self versionSelected and: [selectedResolution isResolved]</body><body package="Store-Merge Management">canExpandHierarchy	^self resolutionListTabs selection isKindOf: ResolutionsTreePane</body><body package="Store-Merge Management">canResolve	^packageList selectionIndexes size = 1 and:		[selectedResolution notNil and:		[selectedResolution isApplyable]]</body><body package="Store-Merge Management">canUnresolve	^selectedResolution notNil and:		[selectedResolution isApplyable]</body><body package="Store-Merge Management">containsResolvedAndNotApplied	^resolutionManager canApplyAll</body><body package="Store-Merge Management">isShowConflictsWithBase	^conflictType == #conflictsWithBase</body><body package="Store-Merge Management">isShowConflictsWithImage	^conflictType == #conflictsWithImage</body><body package="Store-Merge Management">isShowConflictsWithResolution	^conflictType == #conflictsWithResolution</body><body package="Store-Merge Management">isShowLongNames	^nameStyle == #showLongNames</body><body package="Store-Merge Management">isShowShortNames	^nameStyle == #showShortNames</body><body package="Store-Merge Management">isShowingToolbar	^self builder window toolbarVisible</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - view</category><body package="Store-Merge Management">conflictsWithBase	self toggleConflicts: #conflictsWithBase.</body><body package="Store-Merge Management">conflictsWithImage	self toggleConflicts: #conflictsWithImage.</body><body package="Store-Merge Management">conflictsWithResolution	self toggleConflicts: #conflictsWithResolution.</body><body package="Store-Merge Management">expandHierarchy	currentResolutionsPane expandAll</body><body package="Store-Merge Management">refreshResolutions	builder window sensor invalidationSuppressWhile: 		[self updateResolutions.		currentResolutionsPane doInitialExpansion].	builder window refresh</body><body package="Store-Merge Management">showAll	show := #all.	self refreshResolutions</body><body package="Store-Merge Management">showConflicts	show := #conflicts.	self refreshResolutions</body><body package="Store-Merge Management">showLongNamesAction	nameStyle := #showLongNames.	currentResolutionsPane setShowLongNames.	self updateResolutions.</body><body package="Store-Merge Management">showShortNamesAction	nameStyle := #showShortNames.	currentResolutionsPane setShowShortNames.	self updateResolutions.</body><body package="Store-Merge Management">showUnresolved	show := #unresolved.	self refreshResolutions</body><body package="Store-Merge Management">toggleFullNames	nameStyle := nameStyle = #showLongNames		ifTrue: [#showShortNames]		ifFalse: [#showLongNames].	nameStyle = #showLongNames		ifTrue: [currentResolutionsPane setShowLongNames]		ifFalse: [currentResolutionsPane setShowShortNames].	self updateResolutions.</body><body package="Store-Merge Management">toggleToolbar	| window |	window := self builder window.	window toolbarVisible: window toolbarVisible not</body><body package="Store-Merge Management">toggleZoomTextViews	self areTextViewsZoomed		ifTrue: [self unzoomTextViews]		ifFalse: [self zoomTextViews]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - packages</category><body package="Store-Merge Management">downgradeBlessingOnMerge	^self class downgradeBlessingOnMerge</body><body package="Store-Merge Management">exit	self closeRequest</body><body package="Store-Merge Management">informativeBlessingsOnly	^self class informativeBlessingsOnly</body><body package="Store-Merge Management">publishPackages	self areAllApplied ifFalse: 		[(Dialog confirm: (#PublishePackagesConfirm &lt;&lt; #store &gt;&gt; 'All definitions do not have applied resolutions.&lt;n&gt;Publish anyway?') expandMacros) 			ifFalse: [^self]].	self publishModified.</body><body package="Store-Merge Management">selectPackages	resolutionManager isEmpty ifFalse: [self areResolutionsPublished ifFalse: 		[(Dialog 			confirm: (#SelectPackagesConfirm &lt;&lt; #store &gt;&gt; 'Some of the modification have not been published and will be&lt;n&gt;removed from the Merge Tool if you select a new set of packages.&lt;n&gt;Are you sure that you want to proceed?') expandMacros 			for: builder window)				ifFalse: [^self]]].	PundleVersionSelector openOn: self.</body><body package="Store-Merge Management">showStatus	currentResolutionsPane isResolutionSelected		ifTrue:			[currentResolutionsPane selectionIndex: 0]		ifFalse:			[(builder componentAt: #displayTextID) flash]</body><body package="Store-Merge Management">toggleInformativeBlessingsOnly	^self class informativeBlessingsOnly: self informativeBlessingsOnly not</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - browse</category><body package="Store-Merge Management">browseImplementors		| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect: (methodCollector implementorsOf: selectedResolution selector)</body><body package="Store-Merge Management">browseSenders	| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect:  (methodCollector referencesTo: (selectedResolution selector ifNil: [^self]))</body><body package="Store-Merge Management">browseVersions	selectedResolution notNil		ifTrue: [[selectedResolution browseVersions] withStoreFeedbackOn: self mainWindow]</body><body package="Store-Merge Management">compare	| indexes |	indexes := self packageListIndexes.	Differator 		compare: ((self packageList list at: indexes first) definitionTextFrom: selectedResolution)		and: ((self packageList list at: indexes last) definitionTextFrom: selectedResolution)</body><body package="Store-Merge Management">compareWithBase	Differator 		compare: self selectedPackageText		and: self baseText</body><body package="Store-Merge Management">compareWithImage	Differator 		compare: self selectedPackageText 		and: self imageText</body><body package="Store-Merge Management">compareWithResolution	Differator 		compare: self selectedPackageText		and: self resolutionText</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menus</category><body package="Store-Merge Management">augmentedMenu: aMenu named: aSymbol 	^[aMenu 		augmentFrom: self class		to: Store.Glorp.MergeTool		menuName: aSymbol		for: self] 			on: Error			do: [:ex | aMenu]</body><body package="Store-Merge Management">isShowAll	^show == #all</body><body package="Store-Merge Management">isShowConflicts	^show == #conflicts</body><body package="Store-Merge Management">isShowUnresolved	^show == #unresolved</body><body package="Store-Merge Management">menuBar	| menu |	menu := self class menuBarMenu.	^self augmentedMenu: menu named: #menuBar</body><body package="Store-Merge Management">modificationMenu	^[self augmentedMenu: self class modificationMenu named: #modificationMenu]</body><body package="Store-Merge Management">versionMenu	^[self augmentedMenu: self class versionMenu named: #versionMenu]</body><body package="Store-Merge Management">viewMenu	| items values |	items := OrderedCollection new.	values := OrderedCollection new.	items add: ((MenuItem labeled: (#ShowConflicts &lt;&lt; #store &gt;&gt; 'Show Conflicts')) 		indication: [show == #conflicts]).	values add: #showConflicts.	items add: ((MenuItem labeled: (#ShowUnresolved &lt;&lt; #store &gt;&gt; 'Show Unresolved')) 		indication: [show == #unresolved]).	values add: #showUnresolved.	items add: ((MenuItem labeled: (#ShowAll &lt;&lt; #store &gt;&gt; 'Show All')) 		indication: [show == #all]).	values add: #showAll.	^Menu menuItems: items values: values</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private</category><body package="Store-Merge Management">absentString	^(#SpaceDashAbsentDashSpace &lt;&lt; #store &gt;&gt; ' - absent - ') asString</body><body package="Store-Merge Management">areResolutionsPublished	"Check if all the modifications has been applied and the packages published."	self areAllApplied ifFalse: [^false].	self hasPackagesToPublish ifTrue: [^false].	^true</body><body package="Store-Merge Management">askIfOkToDiscard	^Dialog confirm: (#AslIfOkToDiscard &lt;&lt; #store &gt;&gt; 'The text showing has been altered.&lt;n&gt;Do you wish to discard these changes?') expandMacros</body><body package="Store-Merge Management">baseLabel		^selectedResolution isNil 		ifTrue: [Text new] 		ifFalse: [(selectedResolution baseLabel ifNil: [self absentString]) asText]</body><body package="Store-Merge Management">baseText		^selectedResolution isNil 		ifTrue: [Text new] 		ifFalse: [(selectedResolution baseDefinitionText ifNil: ['']) asText]</body><body package="Store-Merge Management">clearProtocolPanes		self conflictProtocol value: ' '.	self selectionProtocol value: ' '</body><body package="Store-Merge Management">couldPublishPackages	^resolutionManager hasChangesToPublish</body><body package="Store-Merge Management">currentResolutionPackageItem	^packageList selections size = 1 ifTrue: [packageList selections first]</body><body package="Store-Merge Management">displayInitialList	self resolutionListTabs selectionIndex: 1.	builder window sensor invalidationSuppressWhile:		[self resolutionListTabsChanged.		currentResolutionsPane doInitialExpansion.].	builder window refresh.</body><body package="Store-Merge Management">hasPackagesToPublish	^resolutionManager hasChangesToPublish</body><body package="Store-Merge Management">ignoreTextEmphasis	^Array with: #bold with: #color -&gt; ColorValue red</body><body package="Store-Merge Management">imageBundles	"Answer a collection of unique bundles as loaded into the image preserving order orignially encountered."		| targets unique |	targets := ((bundles collect: [:each | Registry bundleNamed: each name]) reject: [:each | each isNil]).	unique := OrderedCollection new.	targets do: [:each | (unique includes: each) ifFalse: [unique add: each]].	^unique</body><body package="Store-Merge Management">imageLabel	^selectedResolution isNil		ifTrue: [Text new]		ifFalse: [(selectedResolution imageLabel ifNil: [self absentString]) asText].</body><body package="Store-Merge Management">imageText	^selectedResolution isNil		ifTrue: [Text new]		ifFalse: 			[((selectedResolution applied and: [selectedResolution proposed isRemovalResolution])				ifTrue: [selectedResolution removeFromImageString]				ifFalse: 					[(selectedResolution originalDefinitionText ifNil: 						[selectedResolution isMove 							ifTrue: 								[selectedResolution applied									ifTrue: [selectedResolution movedFromPackageString]									ifFalse: [selectedResolution moveFromPackageString]]							ifFalse: [self class notInImageString]])]) asText]</body><body package="Store-Merge Management">isResolutionSelected	"Answer true if a mod set has been selected"	^selectedResolution notNil</body><body package="Store-Merge Management">mergeStringForPundle: aPundle	| stream notLoadedVersions trunk treeRecord historyPreambleEndPosition |	notLoadedVersions := OrderedCollection new.	(resolutionManager versionsToMergeAt: aPundle classAndName) do:		[:each |		each isVersionLoaded			ifTrue: [trunk := each]			ifFalse: [notLoadedVersions add: each]].	trunk isNil ifTrue: [NoTrunkToMergeError raise].	stream := WriteStream on: String new.	stream nextPutAll: (#MergedByMergeTool &lt;&lt; #store &gt;&gt; 'Merged by Merge Tool') asString; cr.	stream nextPutAll: (#ImageVersion &lt;&lt; #store &gt;&gt; 'Image version:') asString; cr; tab.	stream nextPutAll: trunk itemString;cr.	stream nextPutAll: (#BranchVersionsIntegrated &lt;&lt; #store &gt;&gt; 'Branch versions integrated:') asString; cr.	notLoadedVersions do: 		[ :each |		each isPackage = aPundle isPackage ifTrue:			[stream 				tab;				nextPutAll: each mergeItemString; cr]].	Policies mergePolicy includeBranchBlessingCommentHistory		ifFalse: [^stream contents].	historyPreambleEndPosition := stream position.	stream cr.	stream nextPutAll: (#BranchHistory &lt;&lt; #store &gt;&gt; 'Branch history:') asString; cr.	treeRecord := resolutionManager trees detect: 		[:each | 		(each at: 1) package name = aPundle name].	notLoadedVersions 		do:			[:each | 			| ancestorVersion |			ancestorVersion := (treeRecord at: 2) package version.			each printPremergeCommentHistoryOn: stream from: ancestorVersion withLeadingCR: false]		separatedBy: [stream cr;cr].	(stream position &gt; (historyPreambleEndPosition + self class maxBranchHistoryTextSize))		ifTrue:  			[stream position: (historyPreambleEndPosition + self class maxBranchHistoryTextSize).			stream nextPutAll: ' ... ' ; cr.			stream nextPutAll: (#MoreDots &lt;&lt; #store &gt;&gt; ' More...') asString; cr].	^stream contents</body><body package="Store-Merge Management">methodSelected	"Answer true if a mod set of a method has been selected"	^selectedResolution notNil and: [selectedResolution isMethodResolver]</body><body package="Store-Merge Management">notifyNoChangesAndReset		self reset.	NotifyNoMergeChanges raise.</body><body package="Store-Merge Management">packageForAccept	^selectedResolution containingPackageModel.</body><body package="Store-Merge Management">packageListIndexes	^packageList selectionIndexes asArray</body><body package="Store-Merge Management">promptIfNecessaryForUnpublishedChanges	^WarnBeforeAbandoningUnpublished not		or:			[Dialog				confirm:				#SomeModsNotYetPublished &lt;&lt; #store &gt;&gt; 'Some of the modifications have not been published.Are you sure that you want to quit the Merge Tool?'				for: self mainWindow]</body><body package="Store-Merge Management">protocolColonLabelString		^(#ProtocolColonSpace &lt;&lt; #store &gt;&gt; 'Protocol: ') asString</body><body package="Store-Merge Management">protocolStringOfSelectedResolutionFrom: aResolutionPackageItem		^selectedResolution protocolStringFrom: aResolutionPackageItem</body><body package="Store-Merge Management">publishModified	"Publish all modified package and other merged packages the user selects that are mentioned 	in the merge data.  Change blessing level from integration-ready to integrated."		| affected |	affected := self pundlesToPublish.	affected isEmpty ifTrue: 		[^Dialog warn: #NoChangesToPublish &lt;&lt; #store &gt;&gt; 'There are no changes to publish.'].	PublishMergeDialog		publishPackages: affected		comments: (affected collect:			[:each | 			[self mergeStringForPundle: each]				on: NoTrunkToMergeError				do: [:exception | ^Dialog warn: #NoChangesToPublish &lt;&lt; #store &gt;&gt; 'There are no changes to publish.']])		defaultBlessing: Policies mergePolicy blessingForMerged		ifSuccessfulDo:			[:pundleSpecificationList | 			Policies integratedBlessingChangePolicy = #change ifTrue: 				[resolutionManager updateIntegrationBlessingsFor: pundleSpecificationList]]</body><body package="Store-Merge Management">pundlesToPublish	^resolutionManager affectedPundles</body><body package="Store-Merge Management">resolutionLabel		^selectedResolution isNil 		ifTrue: [Text new] 		ifFalse: [(selectedResolution resolutionLabel ifNil: [self absentString]) asText]</body><body package="Store-Merge Management">resolutionText	^selectedResolution isNil		ifTrue: [Text new]		ifFalse: [(selectedResolution proposedDefinitionText ifNil: ['']) asText]</body><body package="Store-Merge Management">resolveTo: aResolutionPackageItem	selectedResolution resolution: aResolutionPackageItem.	resolutionManager clearMoves.	resolutionManager detectMoves.	self updateResolutionsWithoutRebuild.	(self builder componentAt: #pkgListID) widget invalidate</body><body package="Store-Merge Management">resolveToText	selectedResolution isNil 		ifTrue: [self packageSelectionChanged]		ifFalse: 			[| packageModel resolution textController parseSucceeded | 			selectedResolution isApplyable ifFalse: [^self packageSelectionChanged].			selectedResolution isResolver ifFalse: [^self packageSelectionChanged].			packageModel := self packageForAccept.			packageModel isNil ifTrue: [^self packageSelectionChanged].			textController := (self builder componentAt: #displayTextID) widget controller.			Policies packagePolicy 				forcePackage: packageModel 				while: [parseSucceeded := selectedResolution parseText: textController text].			parseSucceeded ifFalse: [^self packageSelectionChanged].			self text: textController text copy.			resolution := UserInputResolution				forPackage: packageModel				text: textController text copy.			selectedResolution isMethodResolver ifTrue:				[resolution protocol: (self protocolStringOfSelectedResolutionFrom: self currentResolutionPackageItem)].			selectedResolution addAlternative: resolution.			selectedResolution proposed: resolution.			selectedResolution applied: false.			selectedResolution isMove ifTrue: 				[selectedResolution movePair movePair: nil.				selectedResolution movePair: nil].			self updateResolutionsWithoutRebuild]</body><body package="Store-Merge Management">selectedPackageItem	| packageItem |	packageItem := (self packageList list at: self packageListIndexes first).	self selectedResolution isResolver ifFalse:		[packageItem := packageItem asGeneralResolution].	^packageItem</body><body package="Store-Merge Management">selectedPackageText	| alternative |	alternative := self currentResolutionPackageItem alternative.	alternative isRemovalResolution ifTrue: [^alternative base value].	^alternative value</body><body package="Store-Merge Management">showLongNames	nameStyle := #showLongNames.	currentResolutionsPane showLongNames</body><body package="Store-Merge Management">showShortNames	nameStyle := #showShortNames.	currentResolutionsPane showShortNames</body><body package="Store-Merge Management">sortResolutionsForLoading: aCollectionOfChangeResolvers		^resolutionManager sortResolutionsForLoading: aCollectionOfChangeResolvers</body><body package="Store-Merge Management">statusString	| stream |	resolutionManager isEmpty		ifTrue: [^(#StatusString1 &lt;&lt; #store &gt;&gt; 'No packages selected to merge.') asString].	stream := WriteStream on: String new.	stream nextPutAll: (#VersionsBeingIntegrated &lt;&lt; #store &gt;&gt; 'Versions being integrated: ') asString; cr; cr.	resolutionManager versionsToMerge do:		[:versionCollection |		versionCollection do:			[:eachPackage|			stream nextPutAll: eachPackage mergeItemString; cr]].	^stream contents</body><body package="Store-Merge Management">text: someText	"For our use only"	| oldTextMode |	oldTextMode := textMode.	textMode := #internal.	displayText value: someText asText.	self setConflictText.	textMode := oldTextMode.</body><body package="Store-Merge Management">textChanged 	textMode = #external ifTrue: [self resolveToText]</body><body package="Store-Merge Management">toggleConflicts: aSymbol	"Change the conflicts after aSymbol was selected."	conflictType := aSymbol.	self setConflictText.</body><body package="Store-Merge Management">twoVersionsSelected	"Answer true if there are	exactly two packages selected"	^self packageList selectionIndexes size = 2 and: [self selectedResolution isResolver]</body><body package="Store-Merge Management">updateConflictProtocolFor: aResolutionPackageItem into: stream	| protocolString |	(selectedResolution notNil and: [selectedResolution displaysProtocolStatus and: [self conflictProtocolText notEmpty]])		ifTrue: 			[stream				emphasis: #bold;				nextPutAll: self protocolColonLabelString;				emphasis: #none.			protocolString := (selectedResolution protocolStringFrom: aResolutionPackageItem) ifNil: [''].			self conflictProtocolText asString = protocolString asString				ifFalse: [stream emphasis: TextFragment emphasisForChange].			stream nextPutAll: self conflictProtocolText].	self conflictProtocol value: stream contents</body><body package="Store-Merge Management">updateResolutions	currentResolutionsPane updateResolutions.	self updateToolbar</body><body package="Store-Merge Management">updateResolutionsWithoutRebuild	currentResolutionsPane updateResolutionsWithoutRebuild.	currentResolutionsPane resolutionSelectionChanged.	self updateToolbar</body><body package="Store-Merge Management">updateSelectionProtocol	| indexes item |	indexes := packageList selectionIndexes.	self clearProtocolPanes.	indexes size = 1 ifTrue:		[item := packageList list at: indexes asArray first.		self updateSelectionProtocolFrom: item]</body><body package="Store-Merge Management">updateSelectionProtocolFor: aResolutionPackageItem into: stream	| protocolString |	(selectedResolution notNil and: 			[selectedResolution displaysProtocolStatus and: 					[(protocolString := self								protocolStringOfSelectedResolutionFrom: aResolutionPackageItem) notNil]])		ifTrue: 			[selectedResolution isMethodResolver				ifTrue: 					[stream						emphasis: #bold;						nextPutAll: self protocolColonLabelString;						emphasis: #none].			self conflictProtocolText asString = protocolString asString				ifFalse: [stream emphasis: TextFragment emphasisForChange].			stream nextPutAll: protocolString].	self selectionProtocol value: stream contents</body><body package="Store-Merge Management">updateSelectionProtocolFrom: aResolutionPackageItem		| stream |	stream := TextStream on: String new.	stream space.	self updateSelectionProtocolFor: aResolutionPackageItem into: stream.	stream := TextStream on: String new.	stream space.	self updateConflictProtocolFor: aResolutionPackageItem into: stream</body><body package="Store-Merge Management">validateTextOnExit: aController	^self textHasChanged not or: [self askIfOkToDiscard]</body><body package="Store-Merge Management">versionSelected	"Answer true if there are	exactly one packages selected"	^self packageList selectionIndexes size = 1 and: [self selectedResolution isResolver]</body><body package="Store-Merge Management">warnAboutNotLoadedPackages: aCollectionOfPackages 	| warningStream |	warningStream := (String new: 100) writeStream.	aCollectionOfPackages size = 1		ifTrue: 			[| package |			package := aCollectionOfPackages first.			warningStream nextPut: $"; nextPutAll: package name; nextPut: $".			warningStream nextPutAll: (#WarnNotLoaded1 &lt;&lt; #store &gt;&gt; ' is being merged but is not loaded in the image.  A new&lt;n&gt;empty package named "') expandMacros.			warningStream nextPutAll: package name; nextPut: $".			warningStream nextPutAll: (#WarnNotLoaded2 &lt;&lt; #store &gt;&gt; ' has been created, and the&lt;n&gt;resolutions you apply will be placed in this package.') expandMacros]		ifFalse: 			[warningStream nextPutAll: (#TheFollowingPackages &lt;&lt; #store &gt;&gt; 'The following packages:&lt;n&gt;') expandMacros.			aCollectionOfPackages do: 				[:each | warningStream tab; nextPut: $"; nextPutAll: each name; nextPut: $"; cr].			warningStream nextPutAll: (#WarnNotLoaded3 &lt;&lt; #store &gt;&gt; 'are being merged but are not loaded in the image.  A new empty package&lt;n&gt;has been created for each of these packages, and the resolutions&lt;n&gt;you apply will be placed in these newly created packages.') expandMacros].	warningStream cr.	Dialog warn: warningStream contents</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private-toolbar</category><body package="Store-Merge Management">createGuideItem	"Guide item appears as the first in the toolbar, and with a text label instead of an icon.	It changes adapting to the tool state to show the next 'major step' for the current state."	| menuItem |	menuItem := resolutionManager isEmpty 		ifTrue: [(MenuItem labeled: #SelectPackages &lt;&lt; #store &gt;&gt; 'Select Packages...') value: #selectPackages]		ifFalse: 			[self areAllApplied 				ifTrue: 					[self couldPublishPackages 						ifTrue: [(MenuItem labeled: #PublishPackages &lt;&lt; #store &gt;&gt; 'Publish Packages...') value: #publishPackages]						ifFalse: [(MenuItem labeled: #SelectPackages &lt;&lt; #store &gt;&gt; 'Select Packages...') value: #selectPackages]]				ifFalse: 					[(MenuItem labeled: #ApplyAll &lt;&lt; #store &gt;&gt; 'Apply All')						enablementSelector: #containsResolvedAndNotApplied;						value: #applyResolved]].	menuItem nameKey: #guideButton.	^menuItem</body><body package="Store-Merge Management">createToolbarMenuWithGuideItem: aMenuItem	| menu |	menu := Menu new.	menu addItem: aMenuItem.	menu addLine.	menu addPart: self class toolbarMenu.	^menu</body><body package="Store-Merge Management">replaceLabelOfFirstToolbarItem	"Make the first toolbar button show menu item text rather than the icon as the label."	| toolbarView firstButton firstMenuItem |	toolbarView := self builder componentAt: #toolbarMenuHolder.	firstButton := toolbarView components first widget.	firstMenuItem := self toolbarMenuHolder value menuItemAt: 1.	firstButton setLabel: (Label				with: firstMenuItem label				attributes: toolbarView currentSkin textAttributesForMenubar				offset: 0 @ 3).	toolbarView		changedPreferredGeometry;		bounds: toolbarView bounds;		invalidate</body><body package="Store-Merge Management">setToolbarMenu: aMenu	self toolbarMenuHolder value: aMenu.	self replaceLabelOfFirstToolbarItem</body><body package="Store-Merge Management">updateToolbar	"Rebuild toolbar as needed to show the correct guide button	and also update the enablement of everything to match the tool state.	This method should be called after anything that can	potentially change the state of the tool."	| guideItem toolbar |	guideItem := self createGuideItem.	guideItem value = (self toolbarMenuHolder value menuItemAt: 1) value ifFalse:		[self setToolbarMenu: (self createToolbarMenuWithGuideItem: guideItem)].	toolbar := self builder componentAt: #toolbarMenuHolder.	self toolbarMenuHolder value menuItems do:		[:each | 		| id enablementSelector |		id := each nameKey.		enablementSelector := each enablementSelector.		enablementSelector notNil ifTrue:			[(toolbar componentAt: id) isEnabled: (self perform: enablementSelector)]]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - help</category><body package="Store-Merge Management">openHelpHowToUse	MergeToolHelp openHowToUseHelp</body><body package="Store-Merge Management">openIconHelp	MergeToolHelp openIconHelp</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - resolution</category><body package="Store-Merge Management">applyResolution	"Apply the resolution"		builder window sensor invalidationSuppressWhile:		[| index |		index := currentResolutionsPane selectionIndex.		self applyResolved: selectedResolution proposedResolutions.		currentResolutionsPane selectionIndex: index].	builder window refresh</body><body package="Store-Merge Management">applyResolved	"Load into the image all resolved 	definitions. 	Update the status of modification set when the resolution has been successfuly loaded."	builder window sensor invalidationSuppressWhile:		[self applyAllResolved].	builder window refresh.</body><body package="Store-Merge Management">applySelection	"Apply the selection as a resolution"	builder window sensor invalidationSuppressWhile:		[self chooseAsResolution.		self applyResolution].	builder window refresh.</body><body package="Store-Merge Management">chooseAsResolution	builder window sensor invalidationSuppressWhile:		[self resolveTo: self selectedPackageItem].	builder window refresh.</body><body package="Store-Merge Management">doNotResolve	selectedResolution ifNotNil:		[selectedResolution doNotResolve.		self updateResolutionsWithoutRebuild]</body><body package="Store-Merge Management">unresolve	builder window sensor invalidationSuppressWhile:		[self resolveTo: nil].	builder window refresh.</body><body package="Store-Merge Management">updateAndWarnIfError: errors	| navigatorClass |	errors		ifTrue: 			[Dialog				warn: (#ApplyResolvedNote &lt;&lt; #store						&gt;&gt; 'Some of the resolved definitions have not been applied. &lt;n&gt;See the Transcript for details.')							expandMacros].	self updateResolutionsWithoutRebuild.	navigatorClass := #{Refactory.Browser.BrowserNavigator} valueOrDo: [^self].	navigatorClass updatePackageListsInOpenWindows</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private-text zoom</category><body package="Store-Merge Management">unzoomTextViews	| splitterLayout textLayout |	self areTextViewsZoomed ifTrue:		[splitterLayout := (self builder componentAt: #mainHorizontalSplitter) component layout.		textLayout := (self builder componentAt: #textCanvas) component layout.		textLayout			topFraction: splitterLayout bottomFraction;			topOffset: splitterLayout bottomOffset.		self widgetIDsHiddenWhenZoomed do: [:each | (self builder componentAt: each) beVisible].		self builder window refresh]</body><body package="Store-Merge Management">widgetIDsHiddenWhenZoomed	^#(ModTabs pkgListID VersionLabel mainHorizontalSplitter)</body><body package="Store-Merge Management">zoomTextViews	| textLayout |	self areTextViewsZoomed ifFalse:		[textLayout := (self builder componentAt: #textCanvas) component layout.		textLayout			topFraction: 0;			topOffset: 0.		self widgetIDsHiddenWhenZoomed do: [:each | (self builder componentAt: each) beInvisible].		self builder window refresh]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	super initialize.	stringsNotForCompare := self class stringsNotForCompare.	resolutionManager := ResolutionManager new.	bundles := OrderedCollection new.	displayText := Text new asValue.	conflictText := Text new asValue.	textMode := #external.	show := #all.	autoSelectResolution := AutoSelectResolution.	nameStyle := NameStyle.	differencesType := DifferencesType.	self compareWithHolder value: ConflictsReference.	self compareWithHolder onChangeSend: #compareWithHolderChanged to: self.	self resolutionListTabs list: (List with: (ResolutionsTreePane new mergeTool: self) with: (ResolutionsListPane new mergeTool: self)).	self packageList selectionIndexHolder onChangeSend: #packageSelectionChanged to: self.	self displayText onChangeSend: #textChanged to: self.</body><body package="Store-Merge Management">noticeOfWindowClose: aWindow 	self updateSoftSettings.	^super noticeOfWindowClose: aWindow.</body><body package="Store-Merge Management">reset	resolutionManager := resolutionManager copyEmpty.	resolutionListTabs list do: [:each | each reset].	bundles := OrderedCollection new.	packageList list: List new.	self updateResolutions</body><body package="Store-Merge Management">stringsNotForCompare	^stringsNotForCompare ifNil: [stringsNotForCompare := self class stringsNotForCompare].</body><body package="Store-Merge Management">updateSoftSettings	ConflictsReference := conflictType.	AutoSelectResolution := autoSelectResolution.	NameStyle := nameStyle.	ShowToolbar := builder window toolbarVisible.	DifferencesType := differencesType.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>selecting</category><body package="Store-Merge Management">compareWithHolderChanged	"Selector has toggle behavior but we specifically don't want it."	| selection |	selection := self compareWithHolder value.	selection = conflictType ifFalse:		[self perform: self compareWithHolder value.		self updateSelectionProtocol]</body><body package="Store-Merge Management">packageSelectionChanged	| indexes text item |	indexes := packageList selectionIndexes.	self clearProtocolPanes.	text := (indexes isEmpty				or: [selectedResolution notNil and: [selectedResolution isResolver not]])					ifTrue: 						[selectedResolution isNil							ifTrue: [self statusString]							ifFalse: [selectedResolution explanationText]]					ifFalse: 						[indexes size = 1							ifTrue: 								[item := packageList list at: indexes asArray first.								self updateSelectionProtocolFrom: item.								selectedResolution definitionTextFrom: item]							ifFalse: 								[self class multiplePackagesSelectedString]].	self text: text.	self updateToolbar</body><body package="Store-Merge Management">selectedResolution: aResolutionsOrResolver	| selections idx |	selectedResolution := aResolutionsOrResolver.	packageList list: (selectedResolution isNil ifTrue: [#()] ifFalse: [selectedResolution createModificationDisplayRecords]).	selections := (autoSelectResolution and: [selectedResolution notNil])		ifTrue:			[idx := packageList list findFirst: [:ele | ele proposed].			(selectedResolution isResolved and: [idx &gt; 0])				ifTrue: [Set with: idx]				ifFalse: [Set new]]		ifFalse: [Set new].	packageList selectionIndexes: selections.</body><body package="Store-Merge Management">textHasChanged	"Answer true if the text view contains a definition 	and the definition has been modified. 	We distinguish definition from by the ***."	^(self builder componentAt: #displayTextID) widget controller textHasChanged		and: 			[| str |			str := displayText value asString.			str isEmpty not and: [str size &lt; 3 or: [(str copyFrom: 1 to: 3)						~= '***']]]</body><body package="Store-Merge Management">updateText	self packageSelectionChanged.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>accessing</category><body package="Store-Merge Management">databaseSession	^databaseSession ifNil: 		[databaseSession := Store.Glorp.StoreLoginFactory currentStoreSession].</body><body package="Store-Merge Management">databaseSession: aGlorpDatabaseSession	databaseSession := aGlorpDatabaseSession</body><body package="Store-Merge Management">filteredResolutions	^resolutionManager sortedListResolutionValues: show</body><body package="Store-Merge Management">resolutionManager	^resolutionManager</body><body package="Store-Merge Management">selectedResolution	^selectedResolution</body><body package="Store-Merge Management">show	^show</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - version</category><body package="Store-Merge Management">spawnVersion	| modification |	modification := packageList selections first.	modification isNil ifTrue: [^Dialog warn: (#NoResolutionToSpawn &lt;&lt; #store &gt;&gt; 'No resolution to spawn')].	ComposedTextView		edit: self selectedPackageText asValue		label: ((#x1sIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; in &lt;2s&gt;')			expandMacrosWith: selectedResolution name			with: modification description)		icon: nil		extent: 400 @ 200</body><body package="Store-Merge Management">toggleAutoSelectResolution	autoSelectResolution := autoSelectResolution not.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>widget accessing</category><body package="Store-Merge Management">packageListWidget	^(builder componentAt: #pkgListID ) widget.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>mod tab control</category><body package="Store-Merge Management">resolutionListTabsChanged	| selectedApp |	currentResolutionsPane release.	selectedApp := self resolutionListTabs selection.	selectedApp isNil		ifTrue: [^self].	currentResolutionsPane := selectedApp.	(self widgetAt: #ModTabs)		client: currentResolutionsPane		spec: #windowSpec		builder: builder newSubBuilder.	self perform: nameStyle.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>changing</category><body package="Store-Merge Management">changeRequest		^super changeRequest and: [resolutionManager isEmpty or: [self areResolutionsPublished or: [self promptIfNecessaryForUnpublishedChanges]]]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private-resolving</category><body package="Store-Merge Management">applyAllResolved	"Load into the image the designated definitions. 	Update the status of modification set when the resolution has been successfuly loaded."	| errors |	Cursor wait showWhile:		[errors := resolutionManager applyAllResolved].	self updateAndWarnIfError: errors</body><body package="Store-Merge Management">applyResolved: aCollection	"Load into the image the designated definitions. 	Update the status of modification set when the resolution has been successfuly loaded."	| errors |	Cursor wait showWhile:		[errors := resolutionManager applyResolutions: aCollection].	self updateAndWarnIfError: errors</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>merge support</category><body package="Store-Merge Management">doMergeBy: aBlock 	"Execute 'aBlock' to set the versions to merge.	If there are no errors proceed to do the merge	and update the modification sets.	Otherwise report the error."	| notConnectedPackages |	notConnectedPackages := OrderedCollection new.	Merging new started.	aBlock 		on: NoCommonAncestor		do: 			[:exception | 			notConnectedPackages add: exception parameter.			exception proceed].	(notConnectedPackages isEmpty and: [resolutionManager canMerge not])		ifTrue: [^self reset].	notConnectedPackages isEmpty ifTrue: 		[resolutionManager doMerge ifFalse: [self notifyNoChangesAndReset].		Merging new finished.		^self].	Merging new finished.	notConnectedPackages size &gt; 1 		ifTrue: 			[Transcript				cr;				show: #DoMergeBy &lt;&lt; #store &gt;&gt; 'The following pairs of packages do not have a common ancestor.';				cr.			notConnectedPackages do: 				[:each | 				Transcript					show: (each at: 1) itemString;					show: #And &lt;&lt; #store &gt;&gt; ' and ';					show: (each at: 2) itemString;					cr].			Transcript show: '-------------'.			Dialog 				warn: (#DoMergeByWarning &lt;&lt; #store 						&gt;&gt; 'Multiple cases of the following problem have been detected:&lt;n&gt;a package with two integration ready versions which are not &lt;n&gt;derived from a common ancestor.&lt;n&gt;The merge has been aborted.&lt;n&gt;One of each of the following pairs should have its blessing &lt;n&gt;level set to a value other than integration ready.  These &lt;n&gt;versions may first be merged using the Differences Tool.  &lt;n&gt;After this is done the merge may be retried.&lt;1s&gt;&lt;n&gt;This list is repeated in the transcript.' 					expandMacrosWith: (notConnectedPackages 						inject: ''						into: 							[:sum :each | 							#x1sn2sAnd3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&lt;n&gt;     &lt;2s&gt; and &lt;3s&gt;' 								expandMacrosWith: sum								with: (each at: 1) itemString								with: (each at: 2) itemString]))]		ifFalse: 			[| package |			package := notConnectedPackages first.			Transcript				cr;				show: (#DoMergeByTwoPackages &lt;&lt; #store &gt;&gt; 'The two packages &lt;1s&gt; and &lt;2s&gt; do not have a common ancestor.' 					expandMacrosWith: (package at: 1) itemString					with: (package at: 2) itemString).			Dialog warn: 				(#DoMergeByAborted &lt;&lt; #store &gt;&gt; 'The two packages &lt;1s&gt; and &lt;2s&gt;&lt;n&gt;do not have a common ancestor. The merge has been aborted.&lt;n&gt;These versions may be merged using the Differences Tool.' 				expandMacrosWith: (package at: 1) itemString				with: (package at: 2) itemString)].	self reset</body><body package="Store-Merge Management">finishUpdatingMergeInformation	| title |	title := self computeTitle.	builder window label: title.	self displayInitialList.	self updateToolbar.	self unzoomTextViews</body><body package="Store-Merge Management">mergePundleVersions: aCollectionOfPundleVersions 		self doMergeBy:		[resolutionManager := ResolutionManager onPundles: aCollectionOfPundleVersions.		resolutionManager ifNil: [^self reset].		bundles := resolutionManager bundles]</body><body package="Store-Merge Management">mergeSelectedPundleVersions: aCollectionOfPundles	| targetPundleForSession |	self reset.	targetPundleForSession := aCollectionOfPundles		detect: [:each | each isImageModel not]		ifNone: [nil].	(databaseSession isNil and: [targetPundleForSession notNil])		ifTrue: [self databaseSession: targetPundleForSession session].	StoreProgressOverlay 		subsume: builder window		while:  [self mergePundleVersions: (aCollectionOfPundles collect: [:each | each asStorePundleIn: self databaseSession])].	resolutionManager successfullyCompared not ifTrue: [^self].	self finishUpdatingMergeInformation</body><body package="Store-Merge Management">setupForResolutionManager: aResolutionManager 		resolutionManager := aResolutionManager.	resolutionManager ifNil: [^self reset].	bundles := resolutionManager bundles.	self finishUpdatingMergeInformation</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>support</category><body package="Store-Merge Management">alwaysOpenMergeTool	AlwaysOpenMergeTool isNil ifTrue: [AlwaysOpenMergeTool := false].	^AlwaysOpenMergeTool</body><body package="Store-Merge Management">alwaysOpenMergeTool: aBoolean	AlwaysOpenMergeTool := aBoolean</body><body package="Store-Merge Management">downgradeBlessingOnMerge	DowngradeBlessingOnMerge ifNil: [#{Store.Glorp.MergeTool.DowngradeBlessingOnMerge} initialize].	^DowngradeBlessingOnMerge</body><body package="Store-Merge Management">downgradeBlessingOnMerge: aBoolean	#{Store.Glorp.MergeTool.DowngradeBlessingOnMerge} value: aBoolean</body><body package="Store-Merge Management">iconImportExpressions"These are the helper do-its for importing the icon sources into VisualWorks.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/resolved.gif' 		toClass: ListIconLibrary		selector: #resolved16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/unresolved.gif' 		toClass: ListIconLibrary		selector: #unresolved16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/applied.gif' 		toClass: ListIconLibrary		selector: #applied16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/General/class.gif' 		toClass: ListIconLibrary		selector: #class16x16	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/General/classMethod.gif' 		toClass: ListIconLibrary		selector: #classMethod16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/General/instanceMethod.gif' 		toClass: ListIconLibrary		selector: #instanceMethod16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationAdd.gif' 		toClass: ListIconLibrary		selector: #modificationAdd16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationMove.gif' 		toClass: ListIconLibrary		selector: #modificationMove16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationChange.gif' 		toClass: ListIconLibrary		selector: #modificationChange16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationRemove.gif' 		toClass: ListIconLibrary		selector: #modificationRemove16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarResolve.gif' 		toClass: ToolbarIconLibrary		selector: #modificationResolve20x20.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarUnresolve.gif' 		toClass: ToolbarIconLibrary		selector: #modificationUnresolve20x20.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarApply.gif' 		toClass: ToolbarIconLibrary		selector: #modificationApply20x20.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarApplyAll.gif' 		toClass: ToolbarIconLibrary		selector: #modificationApplyAll20x20."	self commentOnly</body><body package="Store-Merge Management">informativeBlessingsOnly	InformativeBlessingsOnly ifNil: [#{Store.Glorp.MergeTool.InformativeBlessingsOnly} initialize].	^InformativeBlessingsOnly</body><body package="Store-Merge Management">informativeBlessingsOnly: aBoolean	#{Store.Glorp.MergeTool.InformativeBlessingsOnly} value: aBoolean</body><body package="Store-Merge Management">warnBeforeAbandoningUnpublished	^WarnBeforeAbandoningUnpublished</body><body package="Store-Merge Management">warnBeforeAbandoningUnpublished: aBoolean	WarnBeforeAbandoningUnpublished := aBoolean</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>constants</category><body package="Store-Merge Management">absentFromThisPackageString	^(#AbsentFromThisPackage &lt;&lt; #store &gt;&gt; '*** Absent from this package ***') asString</body><body package="Store-Merge Management">doNotApplyChangeString	^(#StarsDoNotApplyChangeStars &lt;&lt; #store &gt;&gt; '*** Do Not Apply Change ***') asString</body><body package="Store-Merge Management">maxBranchHistoryTextSize	^ 4096</body><body package="Store-Merge Management">multiplePackagesSelectedString	^(#MultiplePackagesSeleted &lt;&lt; #store &gt;&gt; '*** Multiple packages selected ***') asString</body><body package="Store-Merge Management">notInImageString	^(#NotInImage &lt;&lt; #store &gt;&gt; '*** Not in image ***') asString</body><body package="Store-Merge Management">removeFromImageString	^(#RemoveFromImage &lt;&lt; #store &gt;&gt; '*** Remove from image ***') asString</body><body package="Store-Merge Management">stringsNotForCompare	| strings |	strings := Array new: 8.	strings at: 1 put: self absentFromThisPackageString.	strings at: 2 put: self doNotApplyChangeString.	strings at: 3 put: self multiplePackagesSelectedString.	strings at: 4 put: self notInImageString.	strings at: 5 put: self removeFromImageString.	strings at: 6 put: self userSuppliedString.	^strings</body><body package="Store-Merge Management">userSuppliedString	^(#SpaceParenUserSuppliedParen &lt;&lt; #store &gt;&gt; ' (User Supplied)') asString</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>interface opening</category><body package="Store-Merge Management">openOnPundle: aPundle	self openOnPundles: (OrderedCollection with: aPundle)</body><body package="Store-Merge Management">openOnPundles: aCollectionOfPundles	| instance session targetPundle |	aCollectionOfPundles isEmpty		ifTrue: [^aCollectionOfPundles emptyCollectionError].	targetPundle := aCollectionOfPundles		detect: [:each | each isImageModel not]		ifNone: [nil].	session := targetPundle isNil		ifTrue: [Store.Glorp.StoreLoginFactory currentStoreSession]		ifFalse: [targetPundle session].	instance := self new.	instance databaseSession: session.	instance open.	Processor yield.	[instance mergeSelectedPundleVersions: (aCollectionOfPundles collect: [:each | each asStorePundleIn: session])]		uiEventFor: instance builder window</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>private - interface opening</category><body package="Store-Merge Management">openOnResolutionManager: aResolutionManager	| instance session |	session := aResolutionManager databaseSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	instance := self new.	instance databaseSession: session.	instance open.	Processor yield.	[instance setupForResolutionManager: aResolutionManager]		uiEventFor: instance builder window</body></methods><methods><class-id>Store.ShadowOrganizer</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">addAllCOtherMethods: anOrderedCollection	^cOtherMethods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllExternalMethods: anOrderedCollection	^externalMethods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading">addCOtherMethod: aShadowMethod	^cOtherMethods add: aShadowMethod</body><body package="Atomic Compiling and Loading">addExternalMethod: aShadowMethod	^externalMethods add: aShadowMethod</body><body package="Atomic Compiling and Loading">cOtherMethods	^cOtherMethods</body><body package="Atomic Compiling and Loading">cOtherMethods: anObject	cOtherMethods := anObject</body><body package="Atomic Compiling and Loading">cTypeMethods	^cTypeMethods</body><body package="Atomic Compiling and Loading">cTypeMethods: anObject	cTypeMethods := anObject</body><body package="Atomic Compiling and Loading">classNamed: aClassLongName ifAbsent: absentBlock	^classLookupDict at: aClassLongName ifAbsent: absentBlock</body><body package="Atomic Compiling and Loading">classes	^classes</body><body package="Atomic Compiling and Loading">classes: anObject	classes := anObject</body><body package="Atomic Compiling and Loading">definedClassMethods	"Methods for classes defined in the current package"	^definedClassMethods</body><body package="Atomic Compiling and Loading">definedClassMethods: aCollection	definedClassMethods := aCollection</body><body package="Atomic Compiling and Loading">extensionMethods	^extensionMethods</body><body package="Atomic Compiling and Loading">extensionMethods: anObject	extensionMethods := anObject</body><body package="Atomic Compiling and Loading">externalMethods	^externalMethods</body><body package="Atomic Compiling and Loading">externalMethods: anObject	externalMethods := anObject</body><body package="Atomic Compiling and Loading">loadingDictionary	^loadingDictionary</body><body package="Atomic Compiling and Loading">namespaces	^namespaces</body><body package="Atomic Compiling and Loading">namespaces: anObject	namespaces := anObject</body><body package="Atomic Compiling and Loading">regularExternalInterfaceMethods	"Return all methods defined on ExternalInterface classes which aren't ExternalMethods. This will include 	regular Smalltalk methods and cTypeMethods which define constants, types and structs."		^(self definedClassMethods, self cTypeMethods, self extensionMethods) select: [:eachMethod|		eachMethod mclass notNil and: [eachMethod mclass instanceBehavior includesBehavior: ExternalInterface]]</body><body package="Atomic Compiling and Loading">sharedVariables	^sharedVariables</body></methods><methods><class-id>Store.ShadowOrganizer</class-id> <category>analysis</category><body package="Atomic Compiling and Loading">addPackageShadowsFrom: aShadowOrganizer	self addAllNamespaces: aShadowOrganizer namespaces.	self addAllClasses: aShadowOrganizer classes.	self addAllSharedVariables: aShadowOrganizer sharedVariables.	self addAllCTypeMethods: aShadowOrganizer cTypeMethods.	self addAllCOtherMethods: aShadowOrganizer cOtherMethods.	self addAllExternalMethods: aShadowOrganizer externalMethods.	self addAllExtensionMethods: aShadowOrganizer extensionMethods.	self addAllDefinedClassMethods: aShadowOrganizer definedClassMethods.</body></methods><methods><class-id>Store.ShadowOrganizer</class-id> <category>accessing - dictionary</category><body package="Atomic Compiling and Loading">at: anObject ifAbsent: aBlock	^self loadingDictionary at: anObject ifAbsent: aBlock</body><body package="Atomic Compiling and Loading">at: anObject ifAbsentPut: aBlock	^self loadingDictionary at: anObject ifAbsentPut: aBlock</body><body package="Atomic Compiling and Loading">at: anObject put: aValue	self loadingDictionary at: anObject put: aValue</body></methods><methods><class-id>Store.ShadowOrganizer</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initialize	loadingDictionary := Dictionary new.	namespaces := OrderedCollection new.	sharedVariables := OrderedCollection new.	classes := OrderedCollection new.	classLookupDict := Dictionary new.	definedClassMethods := OrderedCollection new.	cTypeMethods := OrderedCollection new.	cOtherMethods := OrderedCollection new.	externalMethods := OrderedCollection new.	extensionMethods := OrderedCollection new.</body></methods><methods><class-id>Store.ShadowOrganizer</class-id> <category>adding shadow objects</category><body package="Atomic Compiling and Loading">addCTypeMethod: aShadowMethod	^cTypeMethods add: aShadowMethod</body><body package="Atomic Compiling and Loading">addClass: aShadowClass	classLookupDict at: aShadowClass longName put: aShadowClass.	^classes add: aShadowClass</body><body package="Atomic Compiling and Loading">addDefinedClassMethod: aShadowMethod	"Add a method for a class defined in the current package"	^definedClassMethods add: aShadowMethod</body><body package="Atomic Compiling and Loading">addExtensionMethod: aShadowMethod	^extensionMethods add: aShadowMethod</body><body package="Atomic Compiling and Loading">addNamespace: aShadowNamespace	^namespaces add: aShadowNamespace</body><body package="Atomic Compiling and Loading">addSharedVariable: aShadowSharedVariable	^sharedVariables add: aShadowSharedVariable</body></methods><methods><class-id>Store.ShadowOrganizer</class-id> <category>adding - collections</category><body package="Atomic Compiling and Loading">addAllCTypeMethods: anOrderedCollection	^cTypeMethods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllClasses: anOrderedCollection	anOrderedCollection do: [:eaClass|		self addClass: eaClass].	^anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllDefinedClassMethods: anOrderedCollection	^definedClassMethods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllExtensionMethods: anOrderedCollection	^extensionMethods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllNamespaces: anOrderedCollection	^namespaces addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading">addAllSharedVariables: anOrderedCollection	^sharedVariables addAll: anOrderedCollection</body></methods><methods><class-id>Store.ShadowOrganizer class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Store.Glorp.NoOpResolution</class-id> <category>testing</category><body package="Store-Merge Management">isDoNothingResolution	^true</body><body package="Store-Merge Management">isNoOpResolution	^true</body><body package="Store-Merge Management">proposed	^true</body><body package="Store-Merge Management">value	^MergeTool doNotApplyChangeString</body></methods><methods><class-id>Store.Glorp.NoOpResolution</class-id> <category>accessing</category><body package="Store-Merge Management">key 	^nil</body><body package="Store-Merge Management">package 	^nil</body></methods><methods><class-id>Store.Glorp.NoOpResolution</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize	applied := false</body></methods><methods><class-id>Store.ReInitializeSharedVariableNotification</class-id> <category>private - actions</category><body package="Store-Merge Management">defaultAction	^Dialog confirm: (#ReInitializeSharedVariable &lt;&lt; #store &gt;&gt; '(Re)Initialize Shared Variable : ''&lt;1s&gt;''?' expandMacrosWith: parameter absoluteName)</body></methods><methods><class-id>Store.ReInitializeSharedVariableNotification</class-id> <category>constants</category><body package="Store-Merge Management">defaultResumeValue	^true</body></methods><methods><class-id>Store.ReInitializeSharedVariableNotification class</class-id> <category>testing</category><body package="Store-Merge Management">mayResume	^true</body></methods><methods><class-id>Store.NoCorrespondingImageItemError</class-id> <category>private - actions</category><body package="Store-Merge Management">defaultAction	^Dialog warn: 		(#_1sHasNoImageVersion 			&lt;&lt; #store			&gt;&gt; '&lt;1s&gt; has no image version to merge with. Merge cannot proceed.'					expandMacrosWith: parameter name)</body></methods><methods><class-id>Store.NoCorrespondingImageItemError class</class-id> <category>instance creation</category><body package="Store-Merge Management">onPundle: aStorePundle	| instance |	instance := self new.	instance parameter: aStorePundle.	instance raise</body></methods><methods><class-id>Store.NoCorrespondingImageItemError class</class-id> <category>testing</category><body package="Store-Merge Management">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private-selector</category><body package="StoreForGlorpBrowserUI">fileNameForSelectors		| sel |	sel := self definition isForSharedVariable		ifTrue: [self definition classOrNameSpace name , '-' , self definition variableName]		ifFalse:			[self selectedClass simpleNameWithMeta , '-' , (self selector asSymbol isKeyword				ifTrue:					[(self selector asSymbol keywords						inject: (WriteStream on: (String new: 20))						into:							[:sum :each | 							sum								nextPutAll: (each copyFrom: 1 to: each size - 1);								yourself]) contents]				ifFalse: [self selector])].	^Dialog requestNewFileName: #FileOutAs &lt;&lt; #browser &gt;&gt; 'File out as' default: (self filterFilename: sel , '.st')</body><body package="StoreForGlorpBrowserUI">fileOutMessage	| fileName fileManager method shared |	fileName := self fileNameForSelectors.	fileName isEmpty ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	self definitions do: 		[:each | 		each isForSharedVariable 			ifTrue: 				[shared := self environment sharedVariable: each variableName for: each fullName.				shared fileOutSourceOn: fileManager]			ifFalse: 				[method := self environment methodNamed: each selector inClass: each implementingClass.				method fileOutSourceOn: fileManager]]] 			ensure: [fileManager close]</body><body package="StoreForGlorpBrowserUI">spawnMethod	self showWaitCursorWhile: 			[self openBrowserOnEnvironment: (StoreSelectorEnvironment						onMethods: self definitions						in: environment)]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private-class</category><body package="StoreForGlorpBrowserUI">fileOutGlobal		| theGlobals fileName fileManager |	(theGlobals := self selectedGlobals) isEmpty ifTrue: [^self warn: #NoLocallyDefined &lt;&lt; #store&gt;&gt; 'No locally defined objects selected'].	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (self filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: theGlobals first name)).	fileName isEmpty ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	theGlobals do: [:each | each fileOutSourceOn: fileManager]] 		ensure: [fileManager close]</body><body package="StoreForGlorpBrowserUI">printOutClass	"Print the class."	| stream |	stream := TextStream on: (String new: 1000).	self selectedBindings do: [:each | each printOutOn: stream].	self hardcopyStream: stream</body><body package="StoreForGlorpBrowserUI">spawnClass	self showWaitCursorWhile: 			[| allClasses |			allClasses := OrderedCollection withAll: self nonMetaClasses.			allClasses addAll: (self nonMetaClasses collect: [:each | each storeMetaClass]).			self 				openBrowserOnEnvironment: ((StoreForGlorpBrowserEnvironment on: self pundle) forClasses: allClasses)]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>accessing-pundles</category><body package="StoreForGlorpBrowserUI">findPundle		| dialog thePundle |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: (self sortedPundleList: environment allPundles)		filterBlock: [:entry :pundle | entry , '*' match: pundle name].	dialog		windowLabel: #FindPackageOrBundle &lt;&lt; #browser &gt;&gt; 'Find Package or Bundle';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #PackagesAndBundlesC &lt;&lt; #browser &gt;&gt; 'Packages and Bundles:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #toolListText;		iconSelector: #toolListIcon.	thePundle := dialog select.	thePundle isNil ifTrue: [^self].	self selectPundle: thePundle</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private-category</category><body package="StoreForGlorpBrowserUI">findClass		| dialog theSelection |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: environment allClasses		filterBlock: [:entry :item | entry , '*' match: item name].	dialog		windowLabel: #FindClass &lt;&lt; #dialogs &gt;&gt; 'Find Class';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #ClassesC &lt;&lt; #labels &gt;&gt; 'Classes:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #displayString;		iconSelector: #toolListIcon.	theSelection := dialog select.	theSelection isNil ifTrue: [^self].	self setBinding: theSelection</body><body package="StoreForGlorpBrowserUI">findNameSpace		| dialog theSelection |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: environment allNameSpaces		filterBlock: [:entry :item | entry , '*' match: item name].	dialog		windowLabel: #FindNamespace &lt;&lt; #dialogs &gt;&gt; 'Find Namespace';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #NamespacesC &lt;&lt; #labels &gt;&gt; 'Namespaces:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #displayString;		iconSelector: #toolListIcon.	theSelection := dialog select.	theSelection isNil ifTrue: [^self].	self setBinding: theSelection</body><body package="StoreForGlorpBrowserUI">findSharedVariable		| dialog theSelection |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: environment allShared		filterBlock: [:entry :item | entry , '*' match: item name].	dialog		windowLabel: #FindSharedVariable &lt;&lt; #dialogs &gt;&gt; 'Find Shared Variable';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #SharedVariablesC &lt;&lt; #labels &gt;&gt; 'SharedVariables';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #longNameFromSmalltalk;		iconSelector: #toolListIcon.	theSelection := dialog select.	theSelection isNil ifTrue: [^self].	self setBinding: theSelection</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>menus</category><body package="StoreForGlorpBrowserUI">menuNameFor: aSelector	"Our selectors arrive as strings from glorp;  check this."	| selector |	selector := aSelector asSymbol.	selector isEmpty ifTrue: [^(#emptySymbol &lt;&lt; #browser &gt;&gt; '-empty symbol-')].	selector isInfix ifFalse: [^super menuNameFor: selector].	^selector asString copyReplaceAll: '&amp;' with: '&amp;&amp;'</body><body package="StoreForGlorpBrowserUI">windowMenuItems	"Provide CodeTool menus on the main ToolBar."	| items |	items := OrderedCollection new.	items		add: (#_Class &lt;&lt; #browser &gt;&gt; '&amp;Class') asString					-&gt; (self menuNamed: #classMenu);		add: (#_Method &lt;&lt; #browser &gt;&gt; '&amp;Method') asString					-&gt; (self menuNamed: #selectorMenu).	^items</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private</category><body package="StoreForGlorpBrowserUI">browserClass	^StoreRefactoringBrowser</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>aspects</category><body package="StoreForGlorpBrowserUI">ClassAndMethodTabNavigatorPart	^partsDictionary at: #StoreClassAndMethodTabNavigatorPart		ifAbsentPut: [parts add: (StoreClassAndMethodTabNavigatorPart onNavigator: self)]</body><body package="StoreForGlorpBrowserUI">ClassNavigatorPart	^partsDictionary at: #StoreClassNavigatorPart		ifAbsentPut: [parts add: (StoreClassNavigatorPart onNavigator: self)]</body><body package="StoreForGlorpBrowserUI">CodeComponentTabNavigatorPart	^partsDictionary at: #StoreCodeComponentTabNavigatorPart		ifAbsentPut: [parts add: (StoreCodeComponentTabNavigatorPart onNavigator: self)]</body><body package="StoreForGlorpBrowserUI">NameSpaceItemTabNavigatorPart		^partsDictionary		at: #StoreNameSpaceItemTabNavigatorPart		ifAbsentPut:			[parts add: ((StoreNameSpaceItemTabNavigatorPart onNavigator: self)				showProtocols: true;				yourself)]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">getState	"Shadow browsers need to have their state initialized with the right environment 	(as do loaded ones until we provide a global access to loaded glorp store models).	Some environments are pundle environments, others are not. Only get pundles for those that are:"	| newState newEnvironment |	newState := super getState.	newEnvironment := environment.	environment isPundleEnvironemt ifTrue:		[newEnvironment := self environment copy.		newEnvironment setPundles: self pundles].	newState environment: newEnvironment.	^newState.</body><body package="StoreForGlorpBrowserUI">navigatorStateClass		^StoreForGlorpNavigatorState</body><body package="StoreForGlorpBrowserUI">setBinding: aBinding 	| newState owner |	newState := self getState.	newState clearClassDependentFields.	(aBinding isForNameSpace not and: [aBinding isForClassOrExtension not])		ifTrue: 			[owner := aBinding isInClass				ifTrue: [environment classForName:aBinding absoluteOwnerName asString]				ifFalse: [environment nameSpaceForName: aBinding absoluteOwnerName asString].			newState				objectName: owner fullRootName;				protocols: #();				definition: (StoreRBInitializerDefinition nameSpace: owner key: aBinding name)]		ifFalse: [newState objectName: aBinding fullRootName].	self updateWithState: newState</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>store-shared variables</category><body package="StoreForGlorpBrowserUI">sharedVariableBinding	^self state selectedShareds first</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>actions</category><body package="StoreForGlorpBrowserUI">fileOutMethodProtocol		| fileManager fileName methods |	fileName := Dialog		requestNewFileName: #FileOutAs &lt;&lt; #browser &gt;&gt; 'File out as'		default: (self filterFilename: self selectedClass simpleNameWithMeta , '-' , self protocol , '.st').	fileName isEmpty ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	self protocols do: 		[:each | 		methods := (self environment selectorsFor: each in: self selectedClass) collect: [:eachSelector | self environment methodNamed: eachSelector inClass: self selectedClass].		methods do: [:eachMethod | eachMethod fileOutSourceOn: fileManager]]]			ensure: [fileManager close]</body><body package="StoreForGlorpBrowserUI">inspectClasses	| items |	items := self selectedBindings.	items size &gt; 1	 	ifTrue: [items inspect]		ifFalse: [items first inspect]</body><body package="StoreForGlorpBrowserUI">inspectPundle	| items |	items := self pundles.	items size &gt; 1	 	ifTrue: [items inspect]		ifFalse: [items first inspect]</body><body package="StoreForGlorpBrowserUI">inspectSelected	| items |	items := self definitions.	items := (items allSatisfy: #isForSharedVariable)		ifTrue: [state selectedShareds]		ifFalse: [state selectedMethods].	items size &gt; 1	 	ifTrue: [items inspect]		ifFalse: [items first inspect]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>store-classes</category><body package="StoreForGlorpBrowserUI">storeClass	^state classesAndNameSpaces first</body><body package="StoreForGlorpBrowserUI">storeCompareBindingWithVersion: binding		self dbRegistry doIfOnlineImage:		[| trace |		trace := binding isForSharedVariable			ifTrue: [self storeSharedVariableClass selectVersionNamed: binding name inOwner: binding absoluteOwnerName asString]			ifFalse:				[binding isForClassOrExtension					ifTrue: [self storeClassClass selectVersionNamed: binding name]					ifFalse: [self storeNameSpaceClass selectVersionNamed: binding name]].		trace isNil ifTrue: [^self].		self comparisonBrowserClass compareClass: binding toClass: trace]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>changing</category><body package="StoreForGlorpBrowserUI">changeRequest	"The receiver wants to change; We don't do changes in the Store/Glorp version."	^true</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>store-methods</category><body package="StoreForGlorpBrowserUI">storeMethod	^self state selectedMethods first.</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>browsing</category><body package="StoreForGlorpBrowserUI">browseGlobalImplementors	"In Store Browsers a selector is always a String."	self browseGlobalImplementorsOf: self selector asSymbol</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator class</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">classSpecQuery		^[:navigator | 	navigator environment useSingleClassNavigator		ifTrue:			[| classNames |			classNames := navigator environment classNames asArray.			classNames isEmpty				ifTrue: [nil]				ifFalse:					[| packages |					packages := navigator environment pundles.					navigator						addConstantStateBlock:							[:ns | 							ns pundles: packages.							ns objectName: classNames first].					#classWindowSpec]]		ifFalse: [nil]]</body></methods><methods><class-id>Store.PublishFileSpecification</class-id> <category>accessing</category><body package="Store-Publishing Support">file	^object</body><body package="Store-Publishing Support">file: aFileName	object := aFileName.</body><body package="Store-Publishing Support">name	^object name</body><body package="Store-Publishing Support">parentVersion	^''</body><body package="Store-Publishing Support">publishFile	^self publish</body><body package="Store-Publishing Support">publishFile: aBoolean	self publish: aBoolean</body></methods><methods><class-id>Store.PublishFileSpecification class</class-id> <category>instance creation</category><body package="Store-Publishing Support">new	^self basicNew initialize.</body></methods><methods><class-id>Store.Glorp.StorePundleDisplayRow</class-id> <category>labels</category><body package="Store-UI">blessingLabelText	^self pundle blessingLevelString asText</body><body package="Store-UI">publishedFormatLabelText	^(self parentModel publishedFormatStringFor: self pundle) asText.</body><body package="Store-UI">timestampLabelText	^self pundle timeStampString asText</body></methods><methods><class-id>Store.Glorp.StorePundleDisplayRow</class-id> <category>testing</category><body package="Store-UI">alwaysShow	^false</body><body package="Store-UI">useForWidthCalculations	^true</body></methods><methods><class-id>Store.Glorp.StorePundleDisplayRow</class-id> <category>accessing</category><body package="Store-UI">labelClass	^Label</body><body package="Store-UI">pundle	^pundle</body><body package="Store-UI">pundle: anObject	pundle := anObject</body><body package="Store-UI">selectEmphasis	^self parentModel selectEmphasisFor: self pundle.</body></methods><methods><class-id>Store.Glorp.StorePundleDisplayRow</class-id> <category>displaying</category><body package="Store-UI">displayRowUsingColumnWidths: columnWidthDictionary textStyle: textStyle	| versionLabel longestVersion longestName rowView longestPublishedFormatDescription emphasis currentStart longestBlessing |	emphasis := self selectEmphasis.	rowView := CompositePart new.	currentStart := 2.	longestName := columnWidthDictionary at: #name ifAbsent: [0].	longestName &gt; 0		ifTrue: 			[rowView add: (self labelClass						with: self nameLabelText						attributes: textStyle						offset: currentStart @ 0).			currentStart := currentStart + longestName + 8].	longestVersion := columnWidthDictionary at: #version.	versionLabel := self labelClass				with: (self versionLabelText emphasizeAllWith: emphasis)				attributes: textStyle				offset: 0 @ 0.	rowView		add: ((BoundedWrapper on: versionLabel) setOrigin: currentStart @ 0				extent: longestVersion @ versionLabel preferredHeight).	currentStart := currentStart + longestVersion + 12.	longestBlessing := columnWidthDictionary at: #blessing.	rowView add: (self labelClass				with: self blessingLabelText				attributes: textStyle				offset: currentStart @ 0).	currentStart := currentStart + longestBlessing + 8.	longestPublishedFormatDescription := columnWidthDictionary				at: #publishedFormatDescription.	longestPublishedFormatDescription &gt; 0		ifTrue: 			[rowView add: (self labelClass						with: self publishedFormatLabelText						attributes: textStyle						offset: currentStart @ 0).			currentStart := currentStart + longestPublishedFormatDescription + 8].	rowView add: (self labelClass				with: self timestampLabelText				attributes: textStyle				offset: currentStart @ 0).	^rowView</body><body package="Store-UI">toolTipText	| stream |	stream := TextStream on: String new.	stream		emphasis: (Array with: #bold);		nextPutAll: self nameLabelText;		space; space; 		nextPutAll: self versionLabelText;		space; space; 		nextPutAll: self blessingLabelText;		space; space; 		nextPutAll: self publishedFormatLabelText;		space; space; 		nextPutAll: self timestampLabelText.	^ComposedText withText: stream contents</body></methods><methods><class-id>Store.Glorp.StorePundleDisplayRow class</class-id> <category>instance creation</category><body package="Store-UI">newFor: aPundle parentModel: aPundleVersionPane	^self new		pundle: aPundle;		parentModel: aPundleVersionPane</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>relationships</category><body package="Store-UI-Graphs">elementRelatedBy: relToken 	"Answer a collection of related elements."	Transcript		cr;		show: ((#PackageElementToken1sElement2p &lt;&lt; #store &gt;&gt; 'PackageElement token: &lt;1s&gt; element: &lt;2p&gt;') 					expandMacrosWith: relToken					with: element).	Transcript		cr;		show: (element relatedBy: relToken) printString.	^element relatedBy: relToken</body><body package="Store-UI-Graphs">stringKey: hints 	^element class == StoreUserGroup 		ifTrue: 			[(hints includes: #sort) 				ifFalse: [(#_1sOwns &lt;&lt; #store &gt;&gt; '&lt;1s&gt; owns') expandMacrosWith: element userName]				ifTrue: [element]]		ifFalse: [element stringKey: hints]</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>accessing</category><body package="Store-UI-Graphs">itemString	^element</body></methods><methods><class-id>Store.Glorp.StoreVersionlessBundle</class-id> <category>comparing</category><body package="Store-Database Model">precedence	^1</body></methods><methods><class-id>Store.Glorp.StoreVersionlessBundle</class-id> <category>testing</category><body package="Store-Database Model">isBundle	^true.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessBundle class</class-id> <category>constants</category><body package="Store-Database Model">isBundle	^true.</body><body package="Store-Database Model">pundleClass	^StoreBundle.</body></methods><methods><class-id>Tools.PackageComparisonTool</class-id> <category>initialize-release</category><body package="Store-Code Comparison">addHeaderBand: aComparison	| headerView |	headerView := PackageComparisonHeaderView new.	headerView comparison: aComparison.	self add: headerView</body><body package="Store-Code Comparison">addHelpButton	| clicker |	clicker := ClickableGraphic new.	clicker idleGraphic: GeneralIcons help.	clicker when: Clicked do: [ComparisonUsersManual open].	clicker		tooltip: #OpenComparisonToolHelpReference				&gt;&gt; 'Open Comparison Tool Help Reference' &lt;&lt; #IDE.	self add: clicker</body><body package="Store-Code Comparison">addMainComparisonArea: aComparison	| scrolled particularsPanel |	particularsPanel := ScrolledComparisonShell new.	particularsPanel comparisonSource: aComparison.	scrolled := (BorderDecorator on: particularsPanel)				useVerticalScrollbar;				noBorder.	self add: scrolled</body><body package="Store-Code Comparison">populateWith: aComparison	self addHeaderBand: aComparison.	self addMainComparisonArea: aComparison.	self addHelpButton.	self updateLayoutAlgorithm</body></methods><methods><class-id>Tools.PackageComparisonTool</class-id> <category>accessing</category><body package="Store-Code Comparison">headerBand	^self children first</body><body package="Store-Code Comparison">mainArea	^self children at: 2</body><body package="Store-Code Comparison">openInWindow	| window |	window := ScheduledWindow new useDisplayBuffer.	window label: #ComparingCodeDots &gt;&gt; 'Comparing Code...' &lt;&lt; #IDE.	window component: self.	window openWithExtent: 800 @ Screen default bounds height half.	Screen default sync</body><body package="Store-Code Comparison">swapSides	self headerBand swapSides</body><body package="Store-Code Comparison">updateLayoutAlgorithm	"We don't do this with initializeLayoutAlgorithm, because it would get called by initialize before we've added our 3 main children, so we call this by a different name after we've made sure that's happened."	self layoutAlgorithm: 			[:rect :parts |			| headerBand mainArea helpButton |			headerBand := rect origin						extent: rect width @ (parts first preferredHeight min: rect height half).			mainArea := headerBand bottomLeft corner: rect corner.			helpButton := (rect topRight leftBy: GeneralIcons help width)						extent: GeneralIcons help extent.			Array with: headerBand with: mainArea with: helpButton]</body></methods><methods><class-id>Tools.PackageComparisonTool class</class-id> <category>instance creation</category><body package="Store-Code Comparison">compareFromAll: aCodeComponentCollection toAll: bCodeComponentCollection	| view comparison |	view := self new.	view openInWindow.	comparison := CodeComponentComparison new.	Store.DbRegistry doIfOnlineImage: 			[			[comparison leftCodeComponents: aCodeComponentCollection				rightCodeComponents: bCodeComponentCollection.			comparison compute]					withStoreFeedbackOn: view topComponent].	view populateWith: comparison.	view topComponent refresh.	^view</body></methods><methods><class-id>Store.Glorp.StoreLoadRecord</class-id> <category>accessing</category><body package="Store-Database Model">pundleName	^pundleName</body><body package="Store-Database Model">pundleName: anObject	pundleName := anObject</body><body package="Store-Database Model">timestamp	^timestamp</body><body package="Store-Database Model">timestamp: anObject	timestamp := anObject</body><body package="Store-Database Model">type	^type</body><body package="Store-Database Model">type: anObject	type := anObject</body><body package="Store-Database Model">username	^username</body><body package="Store-Database Model">username: anObject	username := anObject</body><body package="Store-Database Model">version	^version</body><body package="Store-Database Model">version: anObject	version := anObject</body></methods><methods><class-id>Store.Glorp.StoreLoadRecord</class-id> <category>printing</category><body package="Store-Database Model">localTimestamp	^TimeZone default universalToLocal: timestamp</body><body package="Store-Database Model">printOn: aStream	| arguments  |	(pundleName isNil or: [type isNil or: [username isNil or: [timestamp isNil or: [version isNil]]]])		ifTrue: [^super printOn: aStream].	arguments := Array new: 5.	arguments		at: 1 put: self type = 'P';		at: 2 put: self pundleName;		at: 3 put: self username;		at: 4 put: self timeStampString;		at: 5 put: self version.	aStream nextPutAll: (#x1sPackageBundle2s5sLoadedBy &lt;&lt; #store &gt;&gt; '&lt;1?Package:Bundle&gt; (&lt;2s&gt;,&lt;5s&gt;) loaded by: &lt;3s&gt; on: &lt;4s&gt;'		expandMacrosWithArguments: arguments)</body><body package="Store-Database Model">timeStampString	^Locale current 		printAsTime: self localTimestamp		policyNamed: (Locale isCLDR ifTrue: [#medium] ifFalse: [#editing])</body></methods><methods><class-id>Store.Glorp.StoreLoadRecord class</class-id> <category>instance creation</category><body package="Store-Database Model">from: aPundle	| instance |	instance := self new.	instance 		type: aPundle typeStringForBlessing;		username: Store.DbRegistry userName;		pundleName: aPundle name;		version: aPundle version;		timestamp: (Dialect storeTimestampIn: aPundle session).	^instance</body></methods><methods><class-id>Store.Modification</class-id> <category>testing</category><body package="Store-Change Management">belongsToClass	^tag belongsToClass</body><body package="Store-Change Management">isForNameSpace	^tag isForNameSpace</body><body package="Store-Change Management">isForOverriddenMethod		| theMethodDescriptor |	^record notNil 		and: [record isForMethod		and: [(theMethodDescriptor := self record asDescriptor) existsInImage		and: [Override isOverriddenSelector: theMethodDescriptor selector class: theMethodDescriptor classFromClassName in: self package]]]</body><body package="Store-Change Management">isMeaningful	"This was modeled after #apply"	| imPkg |	(tag existsInImage not and: [record isNil]) ifTrue: 		[^false].	(tag existsInImage and: [record isNil &amp; package isNil]) ifTrue: 		[^true	"must be a removal"].	imPkg := package getImagePundle.	imPkg isNil ifTrue: 		["Create a package."		self error: (#Package1sMissingFromImage &lt;&lt; #store&gt;&gt; 'Package named "&lt;1s&gt;" missing from image - should not occur' expandMacrosWith: package name).		imPkg := PackageModel named: package name.		imPkg dbTrace: package primaryKey].	^tag is: record meaningfulChangeOf: imPkg</body><body package="Store-Change Management">isPublishedModification		^true</body><body package="Store-Change Management">isRemoval	^tag existsInImage and: [record isNil]</body><body package="Store-Change Management">notOriginallyInImage	^originallyInImage not</body></methods><methods><class-id>Store.Modification</class-id> <category>comparing</category><body package="Store-Change Management">= aMod 	^self == aMod or:	[( aMod notNil and: [ record notNil ] ) and: 		[ aMod isPublishedModification and: 			[ aMod isMoveModification not and: [ aMod record = self record ] ]		]]</body></methods><methods><class-id>Store.Modification</class-id> <category>accessing</category><body package="Store-Change Management">description	self package isNil ifTrue: [^''].	^((#x1s2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt;')		expandMacrosWith: self packageName		with: self package versionStringAlternate)</body><body package="Store-Change Management">existsInPackage	^record notNil</body><body package="Store-Change Management">key	^package isNil		ifTrue: [nil]		ifFalse: [package primaryKey]</body><body package="Store-Change Management">originallyInImage	^originallyInImage</body><body package="Store-Change Management">record	^record</body><body package="Store-Change Management">record: aRecord	record := aRecord</body><body package="Store-Change Management">source	"Answer the source code or nil if not there."	^record isNil		ifTrue: [nil]		ifFalse: [record textRepresentationForTag: tag ]</body><body package="Store-Change Management">timeStampString	^self package timeStampString</body></methods><methods><class-id>Store.Modification</class-id> <category>actions</category><body package="Store-Change Management">apply	"Apply a modification to the image. 	Answer true if the application is successful."	| imPkg result |	(tag existsInImage not and: [record isNil]) ifTrue: [^true].	(tag existsInImage and: [record isNil &amp; package isNil]) 		ifTrue: 			[tag removeFromSystem.			^true	"must be a removal"].	imPkg := package getImagePundle.	imPkg isNil 		ifTrue: 			["Create a package."			self error: ((#Package1sMissing &lt;&lt; #store &gt;&gt; 'Package &lt;1s&gt; missing from image - should not occur') 						expandMacrosWith: package name).			imPkg := PackageModel named: package name.			imPkg dbTrace: package primaryKey].	result := tag loadIntoPackage: imPkg from: record.	^result</body><body package="Store-Change Management">determineOriginallyInImage	originallyInImage := self isMeaningful not</body></methods><methods><class-id>Store.Modification</class-id> <category>change list support</category><body package="Store-Change Management">category	^record isForMethod		ifTrue: [ record protocolName ]</body><body package="Store-Change Management">name	"Answer a name for the list."	^tag name</body><body package="Store-Change Management">sameAs: aModification 	"No record, so this is the system."	^self packageName = aModification packageName and:		[record isNil			ifTrue: [aModification record isNil and: [tag = aModification tag]]			ifFalse: [aModification record notNil and: [self source = aModification source]]]</body><body package="Store-Change Management">sameAsSystem	^record isNil		ifTrue: [tag existsInImage not]		ifFalse: [record sameAsImage]</body><body package="Store-Change Management">systemCategory	"Return the category of the corresponding change in the system, if any"	^record isForMethod		ifTrue: [ record systemCategory ]</body></methods><methods><class-id>Store.Modification class</class-id> <category>instance creation</category><body package="Store-Change Management">tag: aTag package: aPackage record: aRecord	|baby|	baby := self new.	baby tag: aTag; package: aPackage; record: aRecord.	^baby</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>menu</category><body package="Store-UI">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection package storeModel notNil]</body><body package="Store-UI">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>actions</category><body package="Store-UI">browseSelectedVersion	| package classes class |	package := (class := self itemsInList selections first) package.	classes := OrderedCollection with: class.	StoreRefactoringBrowser		openOnEnvironment: ((StoreForGlorpBrowserEnvironment on: package) forClasses: classes)		state: StoreForGlorpNavigatorState new		hierarchy: false</body><body package="Store-UI">compareSelectionWith	| class target |	class := self itemsInList selections first.	target := class class selectStoreVersionOf: class name in: class package session.	target ifNotNil: [TextDifferenceBrowser compare: class definitionString with: target definitionString]</body><body package="Store-UI">compareVersions	| class target |	class := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	TextDifferenceBrowser compare: class definitionString with: target definitionString</body><body package="Store-UI">containingPackages	| class packages |	class := self itemsInList selections first.	[(Gathering for: class name) started.	packages := StoreClassDefinitionInPackage allPackagesContaining: class.	(Gathering for: class name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: class longNameFromSmalltalk</body><body package="Store-UI">fileOutClass	| class fileName fileManager |	class := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (class longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: class package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager deferInitializations.			class fileOutOn: fileManager.			fileManager finishInitializations]				ensure: [fileManager close].			(FilingOut for: class package) finished].</body><body package="Store-UI">fileOutOnlyClassDefinition	| class fileName fileManager |	class := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (class longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: class package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			class fileOutDefinitionOn: fileManager.			fileManager comment: class value: class comment]				ensure: [fileManager close].			(FilingOut for: class package) finished].</body><body package="Store-UI">loadClass		| package class imageModel methodsToRemove fullClass sharedsToRemove |	class := self itemsInList selections first.	package := class package.	imageModel := package storeModel.	fullClass := package fullClassForClass: class.	methodsToRemove := self methodsInClass: class notIn: imageModel.	sharedsToRemove := self sharedsInClass: class notIn: imageModel.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: 					[fullClass loadSource.					methodsToRemove do: [:each | each implementingClass removeSelector: each selector].					sharedsToRemove do: [:each | each absoluteName asQualifiedReference removeFromSystem]].			(Loading for: package) finished].</body><body package="Store-UI">loadOnlyClassDefinition		| package class |	class := self itemsInList selections first.	package := class package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: [class loadSource].			(Loading for: package) finished].</body><body package="Store-UI">selectionsUpdated		| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0 ifTrue:		[self itemsInList selections do:			[:each | 			updateText emphasis: #bold.			updateText nextPutAll: each longName.			updateText emphasis: #none.			updateText cr.			updateText nextPutAll: each definition definitionString.			updateText cr.			updateText cr.			updateText emphasis: (Array with: #color -&gt; ColorValue navy).			updateText nextPutAll: each definition comment.			updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>interface opening</category><body package="Store-UI">compositeViewUsing: aClass nameSize: longestName longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView	| iconPart currentStart nameLabel timestampLabel mainThing usernameLabel packageNameLabel |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aClass toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aClass longNameFromSmalltalk asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	timestampLabel := Label with: aClass definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aClass definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: aClass package name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestTimestamp := longestUsername := 0.	items do:		[:each | 		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestName := (Label with: each longNameFromSmalltalk asText allBold attributes: widget textStyle) width max: longestName].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget tooltip: nil</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>private</category><body package="Store-UI">methodsInClass: aClassDefinitionInPackage notIn: aPackageModel	| fullClass instanceMethods classMethods removeMethods |	fullClass := aClassDefinitionInPackage package fullClassForClass: aClassDefinitionInPackage.	instanceMethods := aPackageModel methodsForClassNamed: fullClass fullName meta: false.	classMethods := aPackageModel methodsForClassNamed: fullClass fullName meta: true.	removeMethods := OrderedCollection new.	removeMethods addAll: (instanceMethods reject: [:each | fullClass includesSelector: each selector]).	fullClass := fullClass storeMetaClass.	removeMethods addAll: (classMethods reject: [:each | fullClass includesSelector: each selector]).	^removeMethods</body><body package="Store-UI">sharedsInClass: aClassDefinitionInPackage notIn: aPackageModel	| fullClass shareds removeShareds |	fullClass := aClassDefinitionInPackage package fullClassForClass: aClassDefinitionInPackage.	shareds := aPackageModel dataForNamed: fullClass fullName.	removeShareds := OrderedCollection new.	removeShareds addAll: (shareds reject: [:each | fullClass sharedVariables contains:  [:eachShared | eachShared dataKey = each dataKey]]).	^removeShareds</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>accessing</category><body package="Store-UI">listTitle	self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title.</body><body package="Store-UI">title	^title ifNil: [(#VersionsOfClass1s &lt;&lt; #store &gt;&gt; 'Versions of class &lt;1s&gt;' expandMacrosWith: self itemsInList list first name)]</body></methods><methods><class-id>Store.LoadCanceled</class-id> <category>printing</category><body package="Atomic Compiling and Loading">defaultMessageText	^(#LoadingHasBeenCanceled &lt;&lt; #store &gt;&gt; 'Loading has been canceled')		asString</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>actions</category><body package="Store-UI">quitLoading	result := #quitLoading.	self accept value: true.</body><body package="Store-UI">skipPrerequisite	result := #skip.	self accept value: true.</body><body package="Store-UI">tryParcel	result := #tryParcel.	self accept value: true.</body><body package="Store-UI">useSelection	self selections selection ifNil: [^self].	result := self selections selection.	self accept value: true.</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>interface opening</category><body package="Store-UI">displayPundleLabelUsing: aPundle blessingAt: blessingStart timestampAt: timestampStart in: aSequenceView		| nameLabel currentStart blessingLabel timestampLabel mainThing |	currentStart := 1.	nameLabel := Label with: aPundle displayString asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + blessingStart + 8.	blessingLabel := Label with: aPundle blessingLevelString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + timestampStart + 12.	timestampLabel := Label with: aPundle timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: nameLabel;		add: blessingLabel;		add: timestampLabel;		yourself.	^mainThing</body><body package="Store-UI">openFrom: aSpec 	"Open a dialog based on aSpec.  If the windowing system is not active	 then simply accept."	WindowingSystem isActive ifFalse: [^accept value].	self allButOpenFrom: aSpec.	builder openDialog.	^result ifNil: [#quitLoading]</body><body package="Store-UI">postBuildWith: aBuilder		| widget blessingStart timestampStart |	(aBuilder componentAt: #PrereqList) widget displayStringSelector: #itemStringWithBlessing.	selections list first isBundle ifTrue: 		[(aBuilder componentAt: #TryParcel) widget labelString: #TryPackage &lt;&lt; #store &gt;&gt; 'Try Package'.		(aBuilder componentAt: #PromptLabel) widget labelString: #ChooseBundlePrereq &lt;&lt; #store &gt;&gt; 'Choose a Bundle version to fullfill prerequiste:'].	widget := (aBuilder componentAt: #PrereqList) widget.	blessingStart := 0.	timestampStart := 0.	selections list		do:			[:each | 			blessingStart := (Label with: each displayString asText allBold attributes: widget textStyle) width max: blessingStart.			timestampStart := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: timestampStart].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self displayPundleLabelUsing: (view sequence at: index) blessingAt: blessingStart timestampAt: timestampStart in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self displayPundleLabelUsing: (view sequence at: index) blessingAt: blessingStart timestampAt: timestampStart in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget tooltip: nil</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>accessing</category><body package="Store-UI">result	^result</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>aspects</category><body package="Store-UI">selections	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selections isNil		ifTrue:			[selections := SelectionInList new]		ifFalse:			[selections]</body></methods><methods><class-id>Store.PrerequisiteSelector class</class-id> <category>interface opening</category><body package="Store-UI">openWith: aCollectionOfStorePundle	| instance |	instance := self new.	instance selections list: aCollectionOfStorePundle asList.	^instance open</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>private</category><body package="Store-Code Comparison">graphic: aGraphic explanation: aCharacterThing	| paragraph row textWidth rowHeight |	row := Panel new.	row add: aGraphic.	paragraph := ComposedText withText: aCharacterThing asText.	row add: paragraph.	row layoutAlgorithm: 			[:rect :parts |			textWidth := rect width - 15 - aGraphic preferredWidth.			textWidth &gt; 0 ifTrue: [paragraph compositionWidth: textWidth].			rowHeight := aGraphic preferredHeight max: paragraph preferredHeight.			Array				with: ((rect left + 5)						@ (rect top + rowHeight half - aGraphic preferredHeight half)							extent: aGraphic preferredExtent)				with: ((rect left + 10 + aGraphic preferredWidth)						@ (rect top + rowHeight half - paragraph preferredHeight half)							extent: paragraph extent)].	^row</body><body package="Store-Code Comparison">keyboardGraphic: aString	^VisualStack with: ComparisonIcons keyboardKey		with: (Label with: aString asText allBold)</body><body package="Store-Code Comparison">keyboardOne: aString two: bString clickOver: aGraphic	| ws |	(bString isNil and: [aString notNil])		ifTrue: [^self keyboardOne: nil two: aString clickOver: aGraphic].	ws := Array new writeStream.	ws		nextPut: (aString					ifNil: [PixelSpace width: ComparisonIcons keyboardKey width]					ifNotNil: [self keyboardGraphic: aString]);		nextPut: (bString					ifNil: [PixelSpace width: ComparisonIcons keyboardKey width]					ifNotNil: [self keyboardGraphic: bString]);		nextPut: (aGraphic					ifNil: [PixelSpace width: ComparisonIcons mouseClick width]					ifNotNil: [VisualStack with: aGraphic with: ComparisonIcons mouseClick]).	^VisualRow withAll: ws contents</body><body package="Store-Code Comparison">plainParagraph: aStringThing	"Do it just like one with a graphic, so things line up nicely."	^self graphic: (PixelSpace extent: 16) explanation: aStringThing</body><body package="Store-Code Comparison">populationSelectors	^((Pragma allNamed: #paragraph in: self class) collect: #selector) sorted</body><body package="Store-Code Comparison">sectionHeader: aCharacterThing	| paragraph |	paragraph := Panel new.	paragraph beRow: 0.	paragraph		add: (PixelSpace width: 5);		add: (aCharacterThing asText emphasizeAllWith: #(#bold #large)).	^paragraph</body><body package="Store-Code Comparison">subsectionHeader: aCharacterThing	| paragraph |	paragraph := Panel new.	paragraph beRow: 0.	paragraph		add: (PixelSpace width: 26);		add: (aCharacterThing asText emphasizeAllWith: #(#bold)).	^paragraph</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>initialize-release</category><body package="Store-Code Comparison">initialize	super initialize.	self populate</body><body package="Store-Code Comparison">initializeLayoutAlgorithm	self beFullColumn</body><body package="Store-Code Comparison">openInWindow	| window scrolled |	window := ScheduledWindow new.	scrolled := (BorderDecorator on: self)				useVerticalScrollbar;				noBorder.	window component: scrolled.	window		label: #ComparisonToolManual &gt;&gt; 'Comparison Tool Reference' &lt;&lt; #IDE.	window		openWithExtent: (Screen default bounds extent * (0.5 @ 1) - ( 0 @ 30)).	self relayout</body><body package="Store-Code Comparison">populate	self		addAll: (self populationSelectors collect: [:each | self perform: each])</body><body package="Store-Code Comparison">scrollOffsetHolder: aScrollOffsetHolder	aScrollOffsetHolder grid: 1 @ 16</body></methods><methods><class-id>Tools.ComparisonUsersManual class</class-id> <category>instance creation</category><body package="Store-Code Comparison">open	"self open"	self new openInWindow</body></methods><methods><class-id>Store.NoCommonAncestor class</class-id> <category>testing</category><body package="Store-Merge Management">mayResume	^true</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^false</body><body package="Store-Merge Management">displaysProtocolStatus	^true</body><body package="Store-Merge Management">isBundleStructureResolver	^true</body><body package="Store-Merge Management">isForClass	^false</body><body package="Store-Merge Management">isForNamespace	^false</body><body package="Store-Merge Management">isForProperties	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	^true</body><body package="Store-Merge Management">sameDefinitionAs: anArray	"Best we can do"	^true</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>displaying</category><body package="Store-Merge Management">baseProtocol	^''</body><body package="Store-Merge Management">definitionTextFor: anAlternative		| stream |	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	stream := WriteStream on: String new.	anAlternative isNoOpResolution		ifTrue: [stream nextPutAll: anAlternative value]		ifFalse: 			[anAlternative value 				do: 					[:each | 					stream 						nextPutAll: each first;						nextPutAll: ': ';						nextPutAll: each last printString] 					separatedBy: [stream cr]].	^stream contents</body><body package="Store-Merge Management">listIcon	^BehaviorIcons Array</body><body package="Store-Merge Management">mergeDisplayName		^(#BracketBundleStructureBracket &lt;&lt; #store &gt;&gt; '[Bundle Structure]') asString</body><body package="Store-Merge Management">name		^self mergeDisplayName</body><body package="Store-Merge Management">originalProtocol	^''</body><body package="Store-Merge Management">proposedProtocol	^''</body><body package="Store-Merge Management">protocolStringFrom: aResolutionPackageItem	^(#BundleStructureCannotBeEdited &lt;&lt; #store &gt;&gt; 'Bundle Structure cannot be editied') asString</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isRemovalResolution or:		[proposed isNoOpResolution]]]]) 			ifTrue: [^true].	^self applyChange</body><body package="Store-Merge Management">applyChange	| changeManager |	^[refactoring := BundleStructureMergeChange		bundle: proposed package storeModel		structure: proposed resolver.	changeManager := RefactoryChangeManager instance.	changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do: 			[:exception |			Transcript show: (#nApplyingStructureFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Bundle Structure Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: proposed package name).			exception return: false]</body><body package="Store-Merge Management">removeEmptyResolvers	applied ifTrue: [alternatives := OrderedCollection new].</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>user interface</category><body package="Store-Merge Management">toolListIcon	^BehaviorIcons Array</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>private</category><body package="Store-Merge Management">parseText: aString		^false</body></methods><methods><class-id>Store.StoreProgressView</class-id> <category>initialize-release</category><body package="Store-UI">addActionLabel	self add: (Label with: '')</body><body package="Store-UI">addComponentLabel	self add: (Label with: '')</body><body package="Store-UI">addHealthView	| view |	view := ProcessHealthView new.	view isActive: [self isActive].	self add: view</body><body package="Store-UI">initialize	super initialize.	activityStack := OrderedCollection new.	self		addHealthView;		addActionLabel;		addComponentLabel</body><body package="Store-UI">initializeLayoutAlgorithm	"Exploits knowledge that the children when populated are 1) the health process spinner, 2) the code component name, 3) the action."	self layoutAlgorithm: 			[:rect :children |			children size = 3				ifFalse: [#()]				ifTrue: 					[| centerExtent rightExtent leftBox centerBox rightBox |					centerExtent := (children at: 2) preferredExtent.					rightExtent := (children at: 3) preferredExtent.					leftBox := rect topLeft extent: rect height asPoint.					centerBox := (leftBox rightCenter upBy: centerExtent y half)								extent: centerExtent.					rightBox := rect rightCenter - ((rightExtent x + 5) @ rightExtent y half)								extent: rightExtent.					rightBox left - centerBox right &gt;= 5						ifFalse: 							[| mid |							mid := rightBox left midpoint: centerBox right.							rightBox left: mid + 2.							centerBox right: mid - 3].					Array with: leftBox with: centerBox with: rightBox]]</body><body package="Store-UI">release	notifications unsubscribe: self.	super release</body></methods><methods><class-id>Store.StoreProgressView</class-id> <category>private</category><body package="Store-UI">actionLabelPart	^self children at: 3</body><body package="Store-UI">componentLabelPart	^self children at: 2</body><body package="Store-UI">currentActionText	^(self currentActivity ifNil: [''] ifNotNil: #actionText) asText allBold		emphasizeAllWith: #color -&gt; (ColorValue						red: 1 / 3						green: 1 / 3						blue: 2 / 3)</body><body package="Store-UI">currentActivity	^activityStack isEmpty ifTrue: [nil] ifFalse: [activityStack last]</body><body package="Store-UI">currentComponentName	^(self currentActivity ifNil: [''] ifNotNil: #componentName) asText		allBold</body><body package="Store-UI">healthPart	^self children at: 1</body><body package="Store-UI">isActive	^activityStack isEmpty not</body><body package="Store-UI">noteActivity: anActivity	| index |	anActivity isFinished		ifTrue: 			[index := activityStack findFirst: [:each | each isComplement: anActivity].			index isZero ifFalse: [activityStack := activityStack first: index - 1]]		ifFalse: [activityStack add: anActivity].	self updateCurrentLabels.	self invalidateNow</body><body package="Store-UI">updateCurrentLabels	self componentLabelPart graphic: (Label with: self currentComponentName).	self actionLabelPart graphic: (Label with: self currentActionText)</body></methods><methods><class-id>Store.StoreProgressView</class-id> <category>accessing</category><body package="Store-UI">notifications	^notifications</body><body package="Store-UI">notifications: anAnnouncer	notifications unsubscribe: self.	notifications := anAnnouncer.	notifications when: StoreWorkActivity send: #noteActivity: to: self</body></methods><methods><class-id>Store.StoreProgressView class</class-id> <category>instance creation</category><body package="Store-UI">example	"self example"	| window view |	window := ScheduledWindow new.	view := self new.	view notifications: StoreWorkActivity notifications.	window component: view.	window openWithExtent: 500 @ 25</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>private</category><body package="Store-Merge Management">addResolver: eaResolver type: resolverType to: resolverDict	| dict |	dict := eaResolver isProposedForRemoval				ifTrue: [resolverDict at: #remove]				ifFalse: [resolverDict at: #addChg].	^(dict at: resolverType ifAbsentPut: [OrderedCollection new])		add: eaResolver</body><body package="Store-Merge Management">applyUnapplied: aCollection	| errors clone currentChanges |	errors := false.	Refactory.Browser.RefactoryChangeManager undoSize: Refactory.Browser.RefactoryChangeManager undoSize + 1.	clone := Refactory.Browser.RefactoryChangeManager instance copy.	aCollection do: 		[:each | 		each apply			ifTrue: 				[each markApplied.				each undoValue ifNotNil: [:value | currentUndos add: value]]			ifFalse: [errors := true]].	Refactory.Browser.RefactoryChangeManager instance resetFrom: clone.	currentChanges := Refactory.Browser.CompositeRefactoryChange named: 		(#MergeChangesApplied1p &lt;&lt; #store &gt;&gt; 'Merge Actions Applied : &lt;1p&gt;' expandMacrosWith: Timestamp now).	currentUndos reverseDo: [:each | currentChanges addChange: each].	Refactory.Browser.RefactoryChangeManager instance addUndo: currentChanges.	^errors</body><body package="Store-Merge Management">categorizeResolvers: aCollectionOfChangeResolvers	| resolverDict |	resolverDict := (Dictionary new)		at: #remove put: Dictionary new;		at: #addChg put: Dictionary new;		yourself.	aCollectionOfChangeResolvers do:			[:eaResolver |			eaResolver applyable				ifTrue: [					eaResolver isMethodResolver						ifTrue: [self addResolver: eaResolver type: #method to: resolverDict]						ifFalse:							[eaResolver isClassDefinitionResolver								ifTrue:									[self addResolver: eaResolver type: #class to: resolverDict]								ifFalse:									[eaResolver isNameSpaceDefinitionResolver										ifTrue:											[self addResolver: eaResolver type: #namespace to: resolverDict]										ifFalse:											[eaResolver isSharedResolver												ifTrue:													[self addResolver: eaResolver type: #shared to: resolverDict]												ifFalse:													[eaResolver isCommentResolver														ifTrue:															[self addResolver: eaResolver type: #comment to: resolverDict]														ifFalse:															[eaResolver isPropertyResolver																ifTrue:																	[self addResolver: eaResolver type: #property to: resolverDict].															eaResolver isBundleStructureResolver																ifTrue:																	[self addResolver: eaResolver type: #bundleStructure to: resolverDict]]]]]]]].	^resolverDict</body><body package="Store-Merge Management">clearMoves		| knownMoves |	knownMoves := OrderedCollection new.	self resolutionsDo: 		[:eachResolution | 		eachResolution isMove 			ifTrue: [knownMoves add: eachResolution]].	knownMoves do: [:each | each movePair: nil]</body><body package="Store-Merge Management">collectPackageVersionsFrom: aCollectionOfPundles	"Answer a collection of package versions generated by expanding the bundles in the collecion."		| pundles |	pundles := OrderedCollection new.	aCollectionOfPundles do:		[:each | 		(Gathering for: each) started.		each isBundle			ifTrue:				[bundles add: each.				pundles addAll: (self collectPackageVersionsFrom: each containedItems).				pundles add: each]			ifFalse: [pundles add: each].		(Gathering for: each) finished].	^pundles</body><body package="Store-Merge Management">createResolutionFrom: aPseudoDifference from: aVersionNode	| packageResolution packageTarget |	packageTarget := aPseudoDifference mainPackage ifNil: [aPseudoDifference otherPackage].	packageResolution := self existingOrCreateResolutionForPundle: packageTarget.	packageResolution resolutionForDifference: aPseudoDifference fromVersion: aVersionNode package.	packageResolution isBundle		ifTrue: [			packageResolution structureDifferenceUsing: aPseudoDifference fromVersion: aVersionNode package]</body><body package="Store-Merge Management">detectMoves	| moveDict |	moveDict := Dictionary new.	self resolutionsDo: [:eachResolution|		(eachResolution isPotentialMove and: [eachResolution proposed notNil])			ifTrue: [(moveDict at: eachResolution class ifAbsentPut: [OrderedCollection new]) add: eachResolution]].	moveDict do: [:eachCollection|		eachCollection size &gt; 1			ifTrue: [self markMovePairsIn: eachCollection]].</body><body package="Store-Merge Management">environmentOrderFor: aCollectionOfChangeResolvers	| orderedResolvers workingResolvers names workingSize |	orderedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	workingResolvers := aCollectionOfChangeResolvers asOrderedCollection.	workingSize := -1.	[workingSize ~= workingResolvers size and: [workingResolvers notEmpty]] whileTrue:		[names := workingResolvers collect: [:each | each definitionName].		workingSize := workingResolvers size.		workingResolvers copy do:			[:each |			(names contains: [:eachName | '*.', eachName match: each ownerNameForLoadOrdering ignoreCase: false]) ifFalse:				[orderedResolvers add: each.				workingResolvers remove: each]]].	orderedResolvers addAll: workingResolvers.	^orderedResolvers</body><body package="Store-Merge Management">existingOrCreateResolutionForPundle: pundle	| pundleType |	pundleType := pundle isPackage		ifTrue: [#package]		ifFalse: [#bundle].	^self resolutions at: (Array with: pundle name with: pundleType)		ifAbsentPut: [PundleResolutions fromPundle: pundle]</body><body package="Store-Merge Management">existingResolutionForPundle: pundle	| pundleType |	pundleType := pundle isPackage		ifTrue: [#package]		ifFalse: [#bundle].	^self resolutions at: (Array with: pundle name with: pundleType) ifAbsent: [nil].</body><body package="Store-Merge Management">extendedBlessingCommentFor: notLoadedVersions from: aPundle startingAt: historyPreambleEndPosition	| treeRecord stream |	stream := WriteStream on: String new.	stream		nextPutAll: (#BranchHistory &lt;&lt; #store &gt;&gt; 'Branch history:') asString;		cr.	treeRecord := self trees detect: [:each | (each at: 1) package name = aPundle name].	notLoadedVersions 		do: 			[:each |			| ancestorVersion |			ancestorVersion := (treeRecord at: 2) package version.			each				printPremergeCommentHistoryOn: stream				from: ancestorVersion				withLeadingCR: false]		separatedBy: 			[stream				cr;				cr].	stream position &gt; (historyPreambleEndPosition + MergeTool maxBranchHistoryTextSize) ifTrue: 		[stream position: historyPreambleEndPosition + MergeTool maxBranchHistoryTextSize.		stream			nextPutAll: ' ... ';			cr;			nextPutAll: (#MoreDots &lt;&lt; #store &gt;&gt; ' More...') asString;			cr].	^stream</body><body package="Store-Merge Management">getResolversOfType: resolverType proposedResolution: resolutionSymbol from: resolverDict	^resolutionSymbol = #all		ifFalse: [| dict |			dict := resolutionSymbol = #remove				ifTrue: [resolverDict at: #remove]				ifFalse: [resolverDict at: #addChg].			dict at: resolverType ifAbsent: [OrderedCollection new]]		ifTrue: [| resolvers |			resolvers := (resolverDict at: #remove) at: resolverType ifAbsent: [OrderedCollection new].			resolvers addAll: ((resolverDict at: #addChg) at: resolverType ifAbsent: [OrderedCollection new]).			resolvers]</body><body package="Store-Merge Management">markMovePairsIn: aCollection		| removalDict addDict |	removalDict := Dictionary new.	addDict := Dictionary new.	aCollection do: [:each| 		each proposed isRemovalResolution			ifTrue: [removalDict at: each proposed definitionValue put: each]			ifFalse: [addDict at: each proposed value put: each]].			removalDict keysAndValuesDo: [:key :removal| | add | 		add := addDict at: key ifAbsent: [nil].		add notNil			ifTrue: [				add movePair: removal.				removal movePair: add]].</body><body package="Store-Merge Management">mergeStringForPundle: aPundle	| stream notLoadedVersions trunk treeRecord historyPreambleEndPosition |	notLoadedVersions := OrderedCollection new.	(self versionsToMergeAt: aPundle classAndName) do:		[:each |		each isVersionLoaded			ifTrue: [trunk := each]			ifFalse: [notLoadedVersions add: each]].	trunk isNil ifTrue: [NoTrunkToMergeError raise].	stream := WriteStream on: String new.	stream nextPutAll: (#MergedByMergeTool &lt;&lt; #store &gt;&gt; 'Merged by Merge Tool') asString; cr.	stream nextPutAll: (#ImageVersion &lt;&lt; #store &gt;&gt; 'Image version:') asString; cr; tab.	stream nextPutAll: trunk itemString;cr.	stream nextPutAll: (#BranchVersionsIntegrated &lt;&lt; #store &gt;&gt; 'Branch versions integrated:') asString; cr.	notLoadedVersions do: 		[ :each |		each isPackage = aPundle isPackage ifTrue:			[stream 				tab;				nextPutAll: each mergeItemString; cr]].	Policies mergePolicy includeBranchBlessingCommentHistory		ifFalse: [^stream contents].	historyPreambleEndPosition := stream position.	stream cr.	stream nextPutAll: (#BranchHistory &lt;&lt; #store &gt;&gt; 'Branch history:') asString; cr.	treeRecord := self trees detect: 		[:each | 		(each at: 1) package name = aPundle name].	notLoadedVersions 		do:			[:each | 			| ancestorVersion |			ancestorVersion := (treeRecord at: 2) package version.			each printPremergeCommentHistoryOn: stream from: ancestorVersion withLeadingCR: false]		separatedBy: [stream cr;cr].	(stream position &gt; (historyPreambleEndPosition + MergeTool maxBranchHistoryTextSize))		ifTrue:  			[stream position: (historyPreambleEndPosition + MergeTool maxBranchHistoryTextSize).			stream nextPutAll: ' ... ' ; cr.			stream nextPutAll: (#MoreDots &lt;&lt; #store &gt;&gt; ' More...') asString; cr].	^stream contents</body><body package="Store-Merge Management">mostRecentlyPublished: aCollectionOfDbVersions	"Answer the most recently published of a from the collection.	NOTE: image versions are not allowed in the list, because if they are, they would always be the newest"	| newest |	newest := aCollectionOfDbVersions asOrderedCollection first.	aCollectionOfDbVersions do: 		[:each | 		each primaryKey &gt; newest primaryKey ifTrue: [newest := each]].	^newest</body><body package="Store-Merge Management">preliminaryBlessingCommentFor: notLoadedVersions using: trunk from: aPundle	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: (#MergedIntoImageVersion &lt;&lt; #store &gt;&gt; 'Merged into Image version:') asString;		cr;		tab;		nextPutAll: trunk itemString;		cr;		nextPutAll: (#BranchVersionsIntegrated &lt;&lt; #store &gt;&gt; 'Branch versions integrated:') asString;		cr.	notLoadedVersions do: 		[:each |		each isPackage = aPundle isPackage ifTrue: 			[stream				tab;				nextPutAll: each mergeItemString;				cr]].	^stream</body><body package="Store-Merge Management">setupForPundles: aCollectionOfPundles	| pundles |	aCollectionOfPundles do: 		[:each | 		each getImagePundle ifNil: 			[NoCorrespondingImageItemError onPundle: each.			^self]].	pundles := self collectPackageVersionsFrom: aCollectionOfPundles.	(self verifyAgainstImage: pundles) ifFalse: [^self].	canMerge := true.	[[self groupPundleVersionsToMerge: pundles]		on: NoCommonAncestor		do:			[:exception |			canMerge := false.			exception pass]]				on: MismatchedDatabaseError				do: 					[:exception |					| result |					result := exception outer.					result = exception parameter						ifTrue: [exception resume: result]						ifFalse: [^canMerge := false]].</body><body package="Store-Merge Management">sortResolutionsForLoading: aCollectionOfChangeResolvers	"Order of things:		1) Method removes		2) Shared removes		3) Comment removes		4) Namespace change (in hierarchy order)		5) Namespace removes (in reverse hierachy order)		6) Class changes (in hierarchy order)		7) Class removes (in reverse hierarchy order)				8) Shared changes (no order)		9) Method changes (meta before instance)		10) comment add or changes		11) Property changes		12) Bundle structure changes"	|  resolverDict  sortedResolvers nameSpaceResolvers classResolvers methodResolvers |	resolverDict := self categorizeResolvers: aCollectionOfChangeResolvers.	sortedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	sortedResolvers 		addAll: (self getResolversOfType: #method proposedResolution: #remove from: resolverDict);		addAll: (self getResolversOfType: #shared proposedResolution: #remove from: resolverDict);			addAll: (self getResolversOfType: #comment proposedResolution: #remove from: resolverDict).			nameSpaceResolvers := self getResolversOfType: #namespace proposedResolution: #addChg from: resolverDict.		sortedResolvers addAll: (self environmentOrderFor: nameSpaceResolvers).	nameSpaceResolvers := self getResolversOfType: #namespace proposedResolution: #remove from: resolverDict.	sortedResolvers addAll: (self environmentOrderFor: nameSpaceResolvers) reverse.						classResolvers := self getResolversOfType: #class proposedResolution: #addChg from: resolverDict.		sortedResolvers addAll: (self environmentOrderFor: classResolvers).		classResolvers := self getResolversOfType: #class proposedResolution: #remove from: resolverDict.	sortedResolvers addAll: (self environmentOrderFor: classResolvers) reverse.		sortedResolvers addAll: (self getResolversOfType: #shared proposedResolution: #addChg from: resolverDict).	methodResolvers := (self getResolversOfType: #method proposedResolution: #addChg from: resolverDict) groupedBy: [:ea| ea isMeta].	sortedResolvers 		addAll: (methodResolvers at: true ifAbsent: [OrderedCollection new]);		addAll: (methodResolvers at: false ifAbsent: [OrderedCollection new]).	sortedResolvers 		addAll: (self getResolversOfType: #comment proposedResolution: #addChg from: resolverDict);		addAll: (self getResolversOfType: #property proposedResolution: #all from: resolverDict);		addAll: (self getResolversOfType: #bundleStructure proposedResolution: #all from: resolverDict).	^sortedResolvers</body><body package="Store-Merge Management">updateIntegrationInformation	self versionsUsedForMerge do:		[:eachPundleVersion |		eachPundleVersion isVersionLoaded ifFalse:			[eachPundleVersion storeModel mergeInformation ifNil: 				[eachPundleVersion storeModel mergeInformation: MergeInformation new].			eachPundleVersion storeModel mergeInformation addIntegratedVersion: eachPundleVersion version]]</body><body package="Store-Merge Management">updateMergeInformationForPundle: aPundle	| notLoadedVersions trunk stream mergeInformation historyPreambleEndPosition |	notLoadedVersions := OrderedCollection new.	(self versionsToMergeAt: aPundle classAndName) do: 		[:each |		each isVersionLoaded			ifTrue: [trunk := each]			ifFalse: [notLoadedVersions add: each]].	trunk isNil ifTrue: [^nil].	mergeInformation := trunk storeModel mergeInformation ifNil: [MergeInformation new].	stream := self		preliminaryBlessingCommentFor: notLoadedVersions		using: trunk		from: aPundle.	mergeInformation addBlessingComment: stream contents.	mergeInformation blessingLevel: Policies mergePolicy blessingForMerged.	Policies mergePolicy includeBranchBlessingCommentHistory		ifFalse: [^trunk storeModel mergeInformation: mergeInformation].	historyPreambleEndPosition := stream position.	stream := self		extendedBlessingCommentFor: notLoadedVersions		from: aPundle		startingAt: historyPreambleEndPosition.	mergeInformation addBlessingComment: stream contents.	trunk storeModel mergeInformation: mergeInformation</body><body package="Store-Merge Management">verifyAgainstImage: aCollectionOfPundles 	"Verify that aPundle has an image version (that we are merging into).	If the in-image-version is itself different from the record, add it to the set of pundles to be merged as well	Raises the resumable MergingMayCausePublish"	| missingImagePundles |	missingImagePundles := OrderedCollection new.	aCollectionOfPundles do: 		[:each | 		| inImageModel |		inImageModel := each isSameAsImage 			ifTrue: [each] 			ifFalse: [each getImagePundle].		inImageModel isNil			ifTrue: [missingImagePundles add: each]			ifFalse: [	inImageModel hasBeenModified ifTrue: [aCollectionOfPundles addLast: inImageModel]]].	missingImagePundles isEmpty ifFalse: 		[ | stream result |		stream := WriteStream on: String new.		missingImagePundles			do: 				[:each | 				stream nextPutAll: (#t1QBundlePackageNamed2s &lt;&lt; #store &gt;&gt; '&lt;t&gt;&lt;1?Bundle:Package&gt; named &lt;2s&gt;' 					expandMacrosWith: each isBundle 					with: each name)]			separatedBy: [stream cr].		result := MergingMayCausePublish 			raiseRequestWith: missingImagePundles size = 1 			errorString: stream contents.		result = #continue			ifTrue: [missingImagePundles do: #loadSource]			ifFalse: [^false]].	^true</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>accessing</category><body package="Store-Merge Management">affectedBundles	"Answer a collection of image bundles that were affected by applying modifications.	Meaning, that they have modifications that will be lost.	Make sure these are in semi-Hierarchy order... parents before their children, but siblings in any order	as long as each of their children is 'after' each one somewhere... 	We build this using add: and not addFirst, so the order at the end is reversed.	Given	A		B			C			D		E	First the empty children/build dictionary pass give us E D C, with the dictionary having A and B.	This is a simple optimization to not ever bother to add it to the lookup dictionary used later 	since we know that those with no children are 'before' all others.	Now, we go over the Dictionary keys, and make sure that nothing IN each is also in the remaining targets.	On the first pass, that makes sure B does go in, but A does not (since A contains B)	Finally, A gets added."		| targetBundles sortedBundles previousSize bundleDictionary |	targetBundles := (self bundleModels select: #hasBeenModified) asOrderedCollection.	sortedBundles := OrderedCollection new.	bundleDictionary := Dictionary new.	targetBundles copy do: 		[:each | 		| children |		children := (each contentDescriptions select: #isBundle) collect: #component.		children isEmpty			ifTrue: 				[targetBundles remove: each. 				sortedBundles add: each]			ifFalse: [bundleDictionary at: each put: children]].	previousSize := -1.	[targetBundles size &gt; 0 and: [previousSize ~= targetBundles size]] whileTrue:		[previousSize := targetBundles size.		bundleDictionary copy keysAndValuesDo:			[:eachBundle :containedBundles |			((bundleDictionary at: eachBundle) contains: [:eachChild | targetBundles includes: eachChild]) ifFalse:				[sortedBundles add: eachBundle. 				targetBundles remove: eachBundle. 				bundleDictionary removeKey: eachBundle]]].	sortedBundles addAll: targetBundles.	^sortedBundles reverse</body><body package="Store-Merge Management">affectedPackages	"Answer a collection of image packages that were affected by applying modifications.	Meaning, that they have modifications that will be lost."		^self packageModels select: #hasBeenModified</body><body package="Store-Merge Management">affectedPundles	"Answer a collection of image bundles and packages that were affected by applying modifications.	Meaning, that they have modifications that will be lost."		^self affectedBundles , self affectedPackages</body><body package="Store-Merge Management">bundleModels	"Answer a collection of image packages that 	are included in this set of merge data"	| bundleModels |	bundles isNil ifTrue: [^#()].	bundleModels := Set new.	bundles do: 		[:each |		| bundleModel |		bundleModel := Registry bundleNamed: each pundle name.		bundleModel notNil ifTrue: [bundleModels add: bundleModel]].	^bundleModels asArray</body><body package="Store-Merge Management">bundles	^bundles</body><body package="Store-Merge Management">databaseSession	versionsToMerge do: 		[:each | 		each first session ifNotNil: [:value | ^value]].	^nil</body><body package="Store-Merge Management">doMerge	"For each tree divide nodes into level. For each level calculate the 	difference between the node and its parent.	Answer true if we can and did merge and there were resolutions created"		canMerge ifFalse: [^false].	trees keysAndValuesDo:		[:index :each | 		| rootNode |		rootNode := each at: 2.		rootNode maxLevel to: 1 by: -1 do:			[:eachLevel | 			(rootNode nodesAtLevel: eachLevel) do:				[:eachVersionNode | 				| delta |				(Merging for: eachVersionNode package) started.				successfullyCompared := true.				delta := self packageComparitorClass differencesWithPropertiesBetween: eachVersionNode package and: eachVersionNode parent package.				delta changedClassesNamespacesAndPropertiesForMerge do:					[:eachDifference | 					self createResolutionFrom: eachDifference from: eachVersionNode].				(Merging for: eachVersionNode package) finished]]].	self makeResolutionProposals.	self resolutions isEmpty ifTrue: [^false].	^true</body><body package="Store-Merge Management">packageModels	"Answer a collection of image packages that 	are included in this set of merge data"	| packageModels |	trees isNil ifTrue: [^#()].	packageModels := Set new.	trees do: 		[:tree |		| node packageModel |		node := tree at: 1.		packageModel := Registry packageNamed: node package name.		packageModel notNil ifTrue: [packageModels add: packageModel]].	^packageModels asArray</body><body package="Store-Merge Management">packageNames	^self packagesToMerge collect: [:eachVersionCollection | eachVersionCollection first name].</body><body package="Store-Merge Management">packagesToMerge	^versionsToMerge select: [:each | each first isPackage]</body><body package="Store-Merge Management">proposedResolutions	| proposed |	proposed := resolutions		inject: OrderedCollection new		into:			[:collection :each |			collection addAll: each proposedResolutions.			collection].	^proposed</body><body package="Store-Merge Management">resolutions	^resolutions</body><body package="Store-Merge Management">sessionFrom: aCollectionOfPundleVersions		| pundle |	pundle := aCollectionOfPundleVersions 		detect: [:each | each isKindOf: StorePundle]		ifNone: [^nil].	^pundle session</body><body package="Store-Merge Management">successfullyCompared	^successfullyCompared</body><body package="Store-Merge Management">totalResolutionItems	^resolutions inject: 0 into: [:sum :each | sum + each totalResolutionItems]</body><body package="Store-Merge Management">trees	^trees</body><body package="Store-Merge Management">versionsToMerge	^versionsToMerge</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>copying</category><body package="Store-Merge Management">copyEmpty	^self class new.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>testing</category><body package="Store-Merge Management">canApplyAll	^self hasResolutions and: [self resolutions allSatisfy: #isResolved]</body><body package="Store-Merge Management">canApplySome	^self hasResolutions and: [self resolutions anySatisfy: #isResolved]</body><body package="Store-Merge Management">canMerge	^canMerge</body><body package="Store-Merge Management">hasChangesToPublish	^self successfullyAppliedAll and: [self affectedPundles notEmpty]</body><body package="Store-Merge Management">hasResolutions	^resolutions notEmpty</body><body package="Store-Merge Management">isEmpty	^versionsToMerge isEmpty</body><body package="Store-Merge Management">successfullyAppliedAll	^self canApplyAll and: [self resolutions allSatisfy: [:each | each hasBeenApplied or: [each applyable not]]]</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>initialize-release</category><body package="Store-Merge Management">initialize		self reset.	bundles := OrderedCollection new.	successfullyCompared := false.	canMerge := false.	currentUndos := OrderedCollection new.</body><body package="Store-Merge Management">reset	resolutions := Dictionary new: 30.	versionsToMerge := Dictionary new.	trees := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>UI Support</category><body package="Store-Merge Management">sortedListResolutionValues: aSymbol	| result |	result := OrderedCollection new.	resolutions values		inject: result		into:			[:collection :each |			collection addAll: (each sortedListResolutionValues: aSymbol).			collection].	^result</body><body package="Store-Merge Management">sortedTreeResolutionValues: aSymbol	aSymbol = #unresolved ifTrue: [^self sortedTreeResolutions select: [:each | each isResolved not]].	aSymbol = #conflicts ifTrue: [^self sortedTreeResolutions select: [:each | each hasNoConflicts not]].	^self sortedTreeResolutions</body><body package="Store-Merge Management">sortedTreeResolutions	| result |	result := resolutions values select: #isBundle.	result addAll: (resolutions values select: #isPackage).	^result</body><body package="Store-Merge Management">versionsUsedForMerge	| storePundles resolvedNames |	trees ifNil: [^#()].	storePundles := Set new.	trees do:		[:eachTree |		storePundles add: eachTree first package.		storePundles addAll: (eachTree first leaves collect: #package).		storePundles add: eachTree last package.		storePundles addAll: (eachTree last leaves collect: #package)].	resolvedNames := resolutions collect: [:each | each name].	^(storePundles reject: #sameAsImage) select: [:each | each isBundle or: [resolvedNames includes: each name]]</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>merge support</category><body package="Store-Merge Management">addPundleNamed: classAndNameString versionsToMerge: aCollectionOfPundleVersions	"Specify that 'aPackageVersionCollection' are the package 	versions of 'aPackageName' to be merged.	We add the versions to the list of those to integratedVersions.	Get the image version pundle model, if there is none, or the image model is not in the current database, raise an error.	Build the root node, then if the pundleModel is nil (This happens if there is a 'new' or renamed package in a bundle),	then build a full set of resolutionsfor it.	Build the tree of packages to be merged. 	And add the the trees to integrate."	| pundleModel parentPundle rootNode builtNode delta session |	self versionsToMergeAt: classAndNameString put: aCollectionOfPundleVersions.	pundleModel := aCollectionOfPundleVersions asOrderedCollection first				getImagePundle.	(pundleModel isNil or: [pundleModel validateDatabaseId])		ifFalse: [pundleModel raiseMismatchedSignal].	session := self sessionFrom: aCollectionOfPundleVersions.	pundleModel isNil		ifTrue: 			[parentPundle := self mostRecentlyPublished: aCollectionOfPundleVersions]		ifFalse: 			[parentPundle := pundleModel parentRecordIn: session.			(self versionsToMergeAt: classAndNameString) addFirst: parentPundle].	parentPundle isNil		ifTrue: 			[self				error: (#PackageVersionOf1pDoesNotExist &lt;&lt; #store						&gt;&gt; 'Package version of &lt;1p&gt; does not exist'							expandMacrosWith: classAndNameString)].	rootNode := Store.Glorp.VersionNode on: parentPundle.	pundleModel isNil		ifTrue: 			[parentPundle class imageClass emptyPundleFrom: parentPundle.			delta := self packageComparitorClass differencesWithPropertiesBetween: parentPundle						and: PseudoPackage new.			delta changedClassesNamespacesAndPropertiesForMerge				do: [:eachDifference | self createResolutionFrom: eachDifference from: parentPundle]].	builtNode := rootNode buildTree: aCollectionOfPundleVersions.	trees add: (Array with: rootNode with: builtNode)</body><body package="Store-Merge Management">applyAll	self canApplyAll ifFalse: [^false].	^self applyResolutions: self proposedResolutions</body><body package="Store-Merge Management">applyAllResolved	self canApplySome ifFalse: [^false].	^self applyResolutions: self proposedResolutions</body><body package="Store-Merge Management">applyResolutions: aCollection	"Answer if there were errors"	| unApplied moveItems |	unApplied := aCollection select: [:each | each isResolved and: [each hasBeenApplied not]].	unApplied isEmpty ifTrue: [^false].	unApplied := self sortResolutionsForLoading: unApplied.	moveItems := unApplied select: [:each | each isMove].	moveItems do:		[:each |		(unApplied includes: each movePair) ifFalse: [unApplied add: each movePair]].	unApplied := self sortResolutionsForLoading: unApplied.	^unApplied size &lt; 2 		ifTrue: [self applyUnapplied: unApplied]		ifFalse: 			[[self applyUnapplied: unApplied]				on: IgnorePossibleOverrideNotice				do: [:notice | notice resume: true]].</body><body package="Store-Merge Management">groupPundleVersionsToMerge: aCollectionOfPundleVersions	"Since #addPundleNamed... takes class + name as a key, bundles and packages with the same name are not confused."		| map |	self reset.	map := Dictionary new.	aCollectionOfPundleVersions do: [:each | (map at: each classAndName ifAbsentPut: [OrderedSet new]) add: each].	map keysAndValuesDo:		[:classAndName :pundleVersions | 			self addPundleNamed: classAndName versionsToMerge: pundleVersions]</body><body package="Store-Merge Management">makeResolutionProposals	"if the alternatives without the one (if any) associated with the base leaves precisely 	one alternative, that single alternative is the one that becomes the proposed alternative."	| keysToRemove |	keysToRemove := OrderedCollection new.		resolutions keysAndValuesDo: [:key :packageResolutions | 		packageResolutions makeResolutionProposals.		packageResolutions removeEmptyResolvers.		packageResolutions resolutions isEmpty			ifTrue: [keysToRemove add: key]].	keysToRemove do: [:eaKey|		resolutions removeKey: eaKey ifAbsent: [nil]].	self detectMoves.</body><body package="Store-Merge Management">quietlyApplyAll	^[self applyAll]		on: ReInitializeSharedVariableNotification, IgnorePossibleOverrideNotice		do: [:notification | notification resume: true]</body><body package="Store-Merge Management">updateAffectedPackgeInformations	self affectedPundles do:		[:each |		self updateMergeInformationForPundle: each].	self updateIntegrationInformation.</body><body package="Store-Merge Management">versionsToMergeAt: classAndNameString	^versionsToMerge at: classAndNameString</body><body package="Store-Merge Management">versionsToMergeAt: classAndNameString put: aCollectionOfPundleVersions	(versionsToMerge at: classAndNameString		ifAbsentPut: [OrderedCollection new]) addAll: aCollectionOfPundleVersions</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>constants</category><body package="Store-Merge Management">packageComparitorClass	^PackageComparitor</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>publishing</category><body package="Store-Merge Management">updateIntegrationBlessingsFor: aPublishSpecificationList 	self versionsUsedForMerge do:		[:eachPundleVersion | 		| targetPundle comment newLevel |		(Publishing for: eachPundleVersion) started.		eachPundleVersion isVersionLoaded ifFalse:			[targetPundle := aPublishSpecificationList 				detect: [:each | each pundle name = eachPundleVersion name and: [each pundle isBundle = eachPundleVersion isBundle]] 				ifNone: [nil].			comment := targetPundle isNil				ifTrue: [(#IntegratedByTheMergeTool &lt;&lt; #store &gt;&gt; 'Integrated by the Merge Tool.') asString]				ifFalse: [#IntegratedByMerge1s &lt;&lt; #store &gt;&gt; 'Integrated by Merge Tool into version &lt;1s&gt;.' expandMacrosWith: (targetPundle at: #version)].			eachPundleVersion minimizeFootprintInImage.			eachPundleVersion				addBlessingLevel: (newLevel := Policies mergePolicy integratedBlessingLevelForPackage: eachPundleVersion) 				andComment: comment				informativeBlessing: (MergeTool downgradeBlessingOnMerge not and: 					[MergeTool informativeBlessingsOnly or: 					[((eachPundleVersion currentBlessingLevel ifNil: [100]) &lt; newLevel) not]])].		(Publishing for: eachPundleVersion) finished]</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>visiting</category><body package="Store-Merge Management">resolutionsDo: aBlock	resolutions do: [:ea| ea resolutionsDo: aBlock]</body></methods><methods><class-id>Store.Glorp.ResolutionManager class</class-id> <category>instance-creation</category><body package="Store-Merge Management">new		^super new initialize</body><body package="Store-Merge Management">onPundle: aStorePundle	^self onPundles: (OrderedCollection with: aStorePundle).</body><body package="Store-Merge Management">onPundles: aCollectionOfPundles	| instance |	instance := self new.	instance setupForPundles: aCollectionOfPundles.	^instance</body></methods><methods><class-id>Store.Glorp.ResolutionManager class</class-id> <category>one step merge</category><body package="Store-Merge Management">doMergeOnPundle: aPundle	^self doMergeOnPundles: (OrderedCollection with: aPundle)</body><body package="Store-Merge Management">doMergeOnPundles: aCollectionOfPundles	| instance |	Merging new started.	instance := self onPundles: aCollectionOfPundles.	instance doMerge ifFalse: [^NotifyNoMergeChanges raise].	instance canApplyAll		ifTrue: 			[instance quietlyApplyAll.			instance successfullyAppliedAll 				ifFalse: [MergeTool openOnResolutionManager: instance]				ifTrue: [instance updateAffectedPackgeInformations]]		ifFalse: [MergeTool openOnResolutionManager: instance].	Merging new finished.	^instance</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>testing</category><body package="Store-Difference Management">isMeta	^true</body><body package="Store-Difference Management">isNotMeta	^true</body><body package="Store-Difference Management">isPropertyDifference	^true</body><body package="Store-Difference Management">isShownInMethodList	^true</body><body package="Store-Difference Management">isStandin	^true</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>accessing</category><body package="Store-Difference Management">differenceName	(mainObject notNil and: [mainObject key = #structure]) ifTrue: [^(#BracketBundleStructureBracket &lt;&lt; #store &gt;&gt; '[Bundle Structure]') asString].	^self selectorListName</body><body package="Store-Difference Management">mainDefinition	^(mainObject isNil		ifTrue: ['']		ifFalse: 			[ | stream |			stream := WriteStream on: String new.			mainObject value storeOn: stream.			stream contents]) asText</body><body package="Store-Difference Management">mainPackage: aPackage property: anAssociation	self mainPackage: aPackage object: anAssociation</body><body package="Store-Difference Management">mainProtocol	^''</body><body package="Store-Difference Management">otherDefinition	^(otherObject isNil		ifTrue: ['']		ifFalse: 			[ | stream |			stream := WriteStream on: String new.			otherObject value storeOn: stream.			stream contents]) asText</body><body package="Store-Difference Management">otherPackage: aPackage property: anAssociation	self otherPackage: aPackage object: anAssociation</body><body package="Store-Difference Management">otherProtocol	^''</body><body package="Store-Difference Management">resolutionClass	(mainObject notNil and: [mainObject key = #structure]) ifTrue: [^BundleStructureResolver].	^PropertyChangeResolver</body><body package="Store-Difference Management">selectorListIcon	^String toolListIcon</body><body package="Store-Difference Management">selectorListName	^otherObject 		ifNil: [mainObject key]		ifNotNil: [otherObject key]</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	aStream		component: #package 		named: mainPackage name		property: mainObject key		value: mainObject value</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	aStream		component: #package 		named: otherPackage name		property: otherObject key		value: otherObject value</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>loading</category><body package="Store-Difference Management">loadMainDefinitionFrom: aStoreClassOrNamepace	mainPackage storeModel propertyAt: mainObject key put: mainObject value</body><body package="Store-Difference Management">loadOtherDefinitionFrom: aStoreClassOrNamepace	otherPackage storeModel propertyAt: otherObject key put: otherObject value</body></methods><methods><class-id>Store.PseudoPropertyDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage property: anAssociation	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: anAssociation;		yourself</body><body package="Store-Difference Management">otherPackage: aPackage property: anAssociation	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: anAssociation;		yourself</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>publishing</category><body package="Store-Database Model">checkForNameConflict	| nameConflict |	nameConflict := self targetSession		readOneOf: self pundleType		where:			[:each | 			each name = newPundle name &amp; (each version = newPundle version) &amp; (each timestamp ~= newPundle timestamp)].		nameConflict isNil ifFalse:		[self validateVersionStringFor: newPundle].</body><body package="Store-Database Model">dealWithAbsentParent	"If we have no parent version in the database, we are a new free-standing pundle (as far as this database is concerned;  in my subclass, we may be a target whose source is replicating unrecursively from a database where it has a parent)."	self instantiateAllOf: pundle.	self validateNewPundle: pundle.	self newPundleReconcileWith: nil.</body><body package="Store-Database Model">isPreviousVersionPresent	^self previousVersionInTargetDatabase notNil.</body><body package="Store-Database Model">isPundleTooBig: aPundle	^splitPundles and: [aPundle isBundle and: [aPundle bundles isEmpty not]].</body><body package="Store-Database Model">newPundleFromPundle	"We are publishing;  the pundle we write is the original, not a copy."		^newPundle := pundle</body><body package="Store-Database Model">newWriterFor: aPundleWriter	| instance |	instance := self class for: aPundleWriter.	instance splitPundles: self splitPundles.	^instance.</body><body package="Store-Database Model">prepareBinarySaveFor: aPundle	self deprecated: #(initial '7.7' use 'prepareBinarySaveFor:using:' sunset '7.7.1').	aPundle withAllContainedItems do:		[:each |		(each isPackage and: [each binFile notNil])			ifTrue: [each parcel ifNil: 				[ | parcelRecord |				parcelRecord := StoreParcelRecord from: each storeModel.				parcelRecord updateUserAndTimestampFrom: aPundle.				each storeModel parcelInto: parcelRecord.				each basicParcel: parcelRecord]]]</body><body package="Store-Database Model">prepareBinarySaveFor: aPundle using: aCollection	aPundle withAllContainedItems do:		[:each |		(each isPackage and: [each binFile notNil and: [aCollection contains: [:eachItem | eachItem name = each name]]])			ifTrue: [each parcel ifNil: 				[ | parcelRecord |				parcelRecord := StoreParcelRecord from: each storeModel.				parcelRecord updateUserAndTimestampFrom: aPundle.				each storeModel parcelInto: parcelRecord.				each basicParcel: parcelRecord]]]</body><body package="Store-Database Model">pundleType	^self isBundle ifTrue: [StoreBundle] ifFalse: [StorePackage].</body><body package="Store-Database Model">readPreviousVersion	"Find our previous version. If we've been told it by version name, use that. Otherwise (normally) use the previous timestamp."	^self targetSession readOneOf: self pundleType		where: 			[:each |			each timestamp = pundle previous timestamp				&amp; (each name = pundle previous name)					&amp; (each version = pundle previous version)]</body><body package="Store-Database Model">runPreWriteAction	preWriteAction isNil ifFalse: [preWriteAction value: newPundle].</body><body package="Store-Database Model">validateNewPundle: aPundle	"Validate, but using the validation for new things, which can short-circuit over things that aren't new, and so be more efficient."	aPundle isValidAsNew ifFalse:		[(InvalidStorePundleError new pundle: pundle) signal].</body><body package="Store-Database Model">validateVersionStringFor: aStorePundle	aStorePundle validateVersionString</body><body package="Store-Database Model">writeNewPundle	"This is a bit ugly. If the old pundle had a version, carry it forward (probably means we're replicating). But if it didn't, and the new one does, that means the user assigned it, and we're probably publishing. Push it back to the original, just to make sure that any logging shows it. We should never have both nil."		newPundle version isNil ifTrue: [newPundle version: pundle version].	pundle version isNil ifTrue: [pundle version: newPundle version].	self validateNewPundle: newPundle.	[self checkForNameConflict]		on: Store.UserCancelledPublish		do: 			[:exception |			^exception pass].	self targetSession transact: [self targetSession register: newPundle].	^newPundle</body><body package="Store-Database Model">writePundle: aPundle	"Copying shoved inside reconcile:with:.  Should we use self class or self parent pundleWriterClass to write subcomponents	(no difference as yet)?\	If it's too big to handle at one gulp, write the sub-components first"	pundle := aPundle.	self writeSubComponentsOf: aPundle.	self isPreviousVersionPresent		ifFalse: [self dealWithAbsentParent]		ifTrue:			[self instantiateAllOfPundle.			self instantiateAllOf: previousVersionInTargetDatabase.			self newPundleReconcileWith: previousVersionInTargetDatabase].	newPundle isNil ifTrue: [^nil].	self runPreWriteAction.	self writeNewPundle.	^newPundle</body><body package="Store-Database Model">writePundle: aPundle withChangesBasedOn: anImagePundle using: aCollection	self writePundlePhase1: aPundle withChangesBasedOn: anImagePundle using: aCollection.	^self writePundlePhase2: aPundle withChangesBasedOn: anImagePundle.</body><body package="Store-Database Model">writePundlePhase1: aPundle withChangesBasedOn: anImagePundle	"Prepare to write out the pundle, using information from the image change sets. Do our initial reading of the previous version, but don't reconcile and don't write yet"	self deprecated: #(initial '7.7' use 'writePundlePhase1:withChangesBasedOn:using:' sunset '7.7.1').	pundle := aPundle.	self prepareBinarySaveFor: aPundle.	self isPreviousVersionPresent ifFalse: [^self].	self instantiateIndividualMethodsIn: aPundle requiredFor: anImagePundle.	self instantiateAllOf: previousVersionInTargetDatabase requiredFor: anImagePundle</body><body package="Store-Database Model">writePundlePhase1: aPundle withChangesBasedOn: anImagePundle using: aCollection	"Prepare to write out the pundle, using information from the image change sets. Do our initial reading of the previous version, but don't reconcile and don't write yet"	pundle := aPundle.	self prepareBinarySaveFor: aPundle using: aCollection.	self isPreviousVersionPresent ifFalse: [^self].	self instantiateIndividualMethodsIn: aPundle requiredFor: anImagePundle.	self instantiateAllOf: previousVersionInTargetDatabase requiredFor: anImagePundle</body><body package="Store-Database Model">writePundlePhase2: aPundle withChangesBasedOn: anImagePundle	self isPreviousVersionPresent ifFalse: [^self writePundle: aPundle].	self newPundleReconcileWith: previousVersionInTargetDatabase.	newPundle isNil ifTrue: [^nil].	self runPreWriteAction.	self writeNewPundle.	^newPundle</body><body package="Store-Database Model">writeSubComponentsOf: aPundle	"If it's too big to handle at one gulp, write the sub-components first. If we're publishing, we should only write those components that have changed. We know they've changed if they've been assigned a version number by the publish dialog or whatever else set up the publishing, but don't have a primary key. Once we've written it out, read it back as a proxy, so we won't have to trace through all of its relationships when we write the parent, and so memory that we don't need any more can be reused."		(self isPundleTooBig: aPundle) ifTrue:		[aPundle componentsDo:			[:each | 			each needsPublishing				ifTrue:					[(self newWriterFor: self) writePundle: each.					each componentsDo: [:eachComponent | self targetSession refresh: eachComponent]]				ifFalse: [each]]]</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>copying</category><body package="Store-Database Model">copy	^self shallowCopy postCopy.</body><body package="Store-Database Model">postCopy	previousVersionInTargetDatabase := Object new.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>reconciling</category><body package="Store-Database Model">alreadyPresentVersionOf: aPundle	"Notes that in this case we also check for the version name, as opposed to replication, where we can't. In replication, we're looking for something potentially from a different database, and the name may have been modified if there was a conflict. In this case we know we're only dealing with one database, so the name should always be the same."	| alreadyThere |	alreadyThere := self targetSession		readOneOf: self pundleType		where:			[:each | each timestamp = aPundle timestamp &amp; (each name = aPundle name) &amp; (each version = aPundle version)].	^alreadyThere.</body><body package="Store-Database Model">matchingPundleTo: aPundle in: previousVersionOfParent	| collection |	previousVersionOfParent isNil ifTrue: [^nil].	collection := aPundle isBundle ifTrue: [previousVersionOfParent bundles] ifFalse: [previousVersionOfParent packages].	^collection detect: [:each | aPundle matchesWith: each] ifNone: [nil].</body><body package="Store-Database Model">newPundleReconcileWith: anotherPundle 	"Assign a publishable version of my pundle to newPundle and reconcile it."	self newPundleFromPundle.	newPundle reconcileWith: anotherPundle.	^newPundle</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>api-publishing</category><body package="Store-Database Model">addBlessing: aStoreBlessing	aStoreBlessing username: self targetUsername.	targetSession accessor permitEverythingDuring:		[targetSession transact:			[targetSession register: pundle.			pundle currentBlessingLevel: aStoreBlessing blessingLevel.			aStoreBlessing timestamp: (Dialect storeTimestampIn: targetSession).			pundle bless: aStoreBlessing]].</body><body package="Store-Database Model">addBlessingOnly: aStoreBlessing		aStoreBlessing username: self targetUsername.	targetSession transact:		[targetSession register: pundle.		aStoreBlessing timestamp: (Dialect storeTimestampIn: targetSession).		pundle blessings add: aStoreBlessing]</body><body package="Store-Database Model">preWriteAction: aOneArgumentBlock	"Set an action that will be taken just before the pundle is written, and which takes the pundle as an argument. This allows us, for example, to set the version number and blessing on only those components that have been modified and will actually be written."	preWriteAction := aOneArgumentBlock.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>accessing</category><body package="Store-Database Model">isBundle	^pundle isBundle.</body><body package="Store-Database Model">previousVersionInTargetDatabase	previousVersionInTargetDatabase class == Object		ifTrue: 			[previousVersionInTargetDatabase := pundle previous = nil						ifTrue: [nil]						ifFalse: [self readPreviousVersion]].	^previousVersionInTargetDatabase</body><body package="Store-Database Model">previousVersionInTargetDatabase: aStorePundle	previousVersionInTargetDatabase := aStorePundle</body><body package="Store-Database Model">pundle	^pundle</body><body package="Store-Database Model">pundle: aStorePundle	pundle := aStorePundle</body><body package="Store-Database Model">splitPundles	^splitPundles</body><body package="Store-Database Model">splitPundles: aBoolean	splitPundles := aBoolean</body><body package="Store-Database Model">targetSession	targetSession isNil ifTrue: [targetSession := StoreLoginFactory currentStoreSession].	^targetSession.</body><body package="Store-Database Model">targetSession: aSession	targetSession := aSession.</body><body package="Store-Database Model">targetUsername	^self targetSession accessor currentLogin username.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>instantiating</category><body package="Store-Database Model">follow: aThing	self followSourceFor: aThing.	self followCommentFor: aThing.</body><body package="Store-Database Model">followCommentFor: aThing	| source |	source := aThing comment.	source isString ifTrue: [^source].	source isNil ifTrue: [^source].	^[source next isNil] whileFalse: [source := source next].</body><body package="Store-Database Model">followSourceFor: aThing	| source originalSource |	originalSource := aThing basicSource.	originalSource isNil ifTrue: [^self].	originalSource next isNil ifTrue: [^self].	source := originalSource.	[source next isNil] whileFalse: [source := source next].</body><body package="Store-Database Model">instantiateAllOf: aPundle	aPundle isBundle		ifTrue: [self instantiateAllOfBundle: aPundle]		ifFalse: [self instantiateAllOfPackage: aPundle].	aPundle removeDuplicates.</body><body package="Store-Database Model">instantiateAllOf: aPundle requiredFor: anImagePundle	"Bring in only those methods which list as changed in the change set. Also don't try to remove duplicates, because we probably don't have enough information to do it, and this will be based on image data anyway, so shouldn't have duplicates"	aPundle isBundle		ifTrue: [self instantiateAllOfBundle: aPundle requiredFor: anImagePundle]		ifFalse: [self instantiateAllOfPackage: aPundle requiredFor: anImagePundle].</body><body package="Store-Database Model">instantiateAllOfBundle: aBundle	"Traverse everything in the bundle, making sure we've got no proxies left, so we have everything we need to write to the other side. Note that for sub-packages we only bring in enough to be able to print them, because we may not end up replicating them if they already exist in the target database"	aBundle bundles do: [:each | self instantiateAllOf: each].	aBundle packages do: [:each | each printString].	aBundle blessings do: [:each | self followSourceFor: each].	self followCommentFor: aBundle.	aBundle propertiesRecordDictionary yourSelf isNil ifFalse: [		aBundle propertiesRecordDictionary do: [:each | self followSourceFor: each]].	aBundle propertiesBlob yourSelf.	aBundle files do: [:each | self followSourceFor: each ].</body><body package="Store-Database Model">instantiateAllOfBundle: aBundle requiredFor: aBundleModel	"Trace everything that we will need in order to publish a new version, assuming the change set associated with the corresponding store model objects is correct. aBundle should be the trace of aBundleModel and in the same database. Don't worry about getting rid of proxies, because we know this is being read from the current database. Do touch all the packages, unlike normally, but we know that the corresponding methods for packages won't do very much if the change set for that package is empty"	aBundle bundles do: [:each | self instantiateAllOf: each requiredFor: each storeModel].	aBundle packages do: [:each | self instantiateAllOf: each requiredFor: each storeModel].	aBundle blessings do: [:each | self followSourceFor: each].	self followCommentFor: aBundle.	aBundle propertiesRecordDictionary yourSelf isNil ifFalse: [		aBundle propertiesRecordDictionary do: [:each | self followSourceFor: each]].	aBundle propertiesBlob yourSelf.	aBundle files do: [:each | self followSourceFor: each ].</body><body package="Store-Database Model">instantiateAllOfPackage: aPackage	"Trace everything, making sure we've got no proxies left, so we have everything we need to write to the other side."	aPackage methods do: [:each | self follow: each definition].	self instantiateEverythingButMethodsOf: aPackage.</body><body package="Store-Database Model">instantiateAllOfPackage: aPackage requiredFor: aPackageModel	"Trace everything that we will need in order to publish a new version, assuming the change set associated with aPackageModel is correct. aPackage should be the trace of aPackageModel and in the same database. Don't worry about getting rid of proxies, because we know this is being read from the current database"	| dbInfo methodList methodNames query parameters nonSourceFetchingQuery tempMethods batchOfMethodNames methodMapping |	aPackageModel ifNil: [^self].	dbInfo := aPackageModel databaseInformationFor: aPackage session databaseIdentifier.	dbInfo isNil 		ifTrue: [methodList := #()]		ifFalse: [			dbInfo changeSet isEmpty ifTrue: [^self].			methodList := dbInfo changeSet modifiedMethodDescriptors].	(aPackage methods isGlorpProxy not or: [aPackage methods isInstantiated]) ifTrue: [		"We've already been read. Just go over the changed list of methods to make sure we haven't got any new ones"		self instantiateIndividualMethodsIn: aPackage requiredFor: aPackageModel.		^self].	parameters := aPackage methods parameters.	methodMapping := (aPackage session system descriptorFor: StorePackage) mappingForAttributeNamed: #methods.	methodList isEmpty ifFalse:	"First, we read changed methods and alsoFetch their source."		[methodNames := methodList collect: [:eachMethodDescriptor | eachMethodDescriptor selector].		tempMethods := OrderedCollection new.		"Now we run a query to bring back methods with those names (this may bring back a few too many that haven't changed but have the same name, but that's OK). We really just want to bring these and their source into cache, but hold onto the collection against the off-chance it gets GCd"		1 to: methodNames size by: 100 do:			[:i |	"TBR:  why are we doing this 100 methods at a time instead of in a single query?"			batchOfMethodNames := methodNames copyFrom: (i min: methodNames size) to: (i + 99 min: methodNames size).			query := methodMapping query copy.	"copy the query - if it gets all the source recursively, we want that"			query AND: [:each | each definition name in: batchOfMethodNames].			tempMethods add: (query executeWithParameters: parameters in: aPackage session)]].	"Second, we read all methods but optimize by not alsoFetching the source (of the rest - the session cache already has the ones read above)."	nonSourceFetchingQuery := methodMapping buildQuery.	nonSourceFetchingQuery		collectionType: OrderedCollection;	"quick-fix Glorp bug (since mid-2005, revealed by this): query accepts GlorpVirtualCollection as collection type, then DNUs"		tracing: nonSourceFetchingQuery defaultTracing;		alsoFetch: [:each | each definition].	aPackage privateSetMethods: (nonSourceFetchingQuery executeWithParameters: parameters in: aPackage session).	tempMethods yourself.	self instantiateEverythingButMethodsOf: aPackage.</body><body package="Store-Database Model">instantiateAllOfPundle	^self instantiateAllOf: pundle.</body><body package="Store-Database Model">instantiateEverythingButMethodsOf: aPackage	aPackage classDefinitions		do:			[:each | 			self follow: each definition.			self follow: each metaclass].	aPackage namespaces do: [:each | self follow: each definition].	aPackage sharedVariables do: [:each | self follow: each definition].	aPackage blessings do: [:each | self followSourceFor: each].	self followCommentFor: aPackage.	aPackage propertiesRecordDictionary yourSelf isNil		ifFalse:			[aPackage propertiesRecordDictionary				do: [:each | self followSourceFor: each]].	aPackage propertiesBlob yourSelf.	aPackage parcel.</body><body package="Store-Database Model">instantiateIndividualMethodsIn: aPundle requiredFor: aPackageModel	"Go through the methods changed in the change set for the image model and make sure that we've touched all of them"		| methodList changeSet |	aPundle leafItems do:		[:eachPkg | 		eachPkg storeModel ifNotNil:			[changeSet := eachPkg storeModel changeSetFor: aPundle session databaseIdentifier.			methodList := (changeSet isNil or: [changeSet isEmpty]) 				ifTrue: [#()] 				ifFalse: [changeSet modifiedMethodDescriptors].			methodList do: [:eachMethod | (eachPkg methodFor: eachMethod) ifNotNil: [:method | method source yourself]]]]</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>initializing</category><body package="Store-Database Model">initialize	previousVersionInTargetDatabase := Object new.	splitPundles := false.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>private</category><body package="Store-Database Model">removePackageInfo	pundle := nil.	previousVersionInTargetDatabase := nil.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter class</class-id> <category>instance creation</category><body package="Store-Database Model">for: aStorePundleWriter	| instance |	instance := self new.	instance splitPundles: aStorePundleWriter splitPundles.	^instance</body><body package="Store-Database Model">new	^super new initialize.</body><body package="Store-Database Model">newForSession: aSession	^(self new)		targetSession: aSession.</body></methods><methods><class-id>Store.InstallingDatabaseTables</class-id> <category>accessing</category><body package="Store-Base">actionText	^(#InstallingDatabaseTables &lt;&lt; #store &gt;&gt; 'Installing Database Tables') asString</body><body package="Store-Base">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management">canBrowseVersions	^false</body><body package="Store-Merge Management">isPropertyResolver	^true</body><body package="Store-Merge Management">isProposedRemovalInPackage	^true</body><body package="Store-Merge Management">sameDefinitionAs: anAssociation	| alternative |	alternative := self standardResolutionAlternative ifNil: [^false].	alternative package pseudoPackage ifTrue: [^false].	^(alternative package propertyAt: anAssociation key) = anAssociation value</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management">apply	| newValue changeManager |	(applied or: 		[applyable not or:		[proposed isAbsentResolution or:		[proposed isNoOpResolution]]]) 			ifTrue: [^true].	newValue := proposed isRemovalResolution 		ifTrue: [nil]		ifFalse: 			[proposed isUserInputResolution				ifTrue: [proposed value]				ifFalse: [proposed value value]].	(newValue isKindOf: Text) ifTrue: [newValue := newValue asString].	refactoring := CodeComponentPropertyChange component: proposed package storeModel.	refactoring propertyAt: propertyKey put: newValue.	changeManager := RefactoryChangeManager instance.	^[changeManager performChange: refactoring.	undo := changeManager undoChange.	true]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingPropertyFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Property Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longListName).			exception return: false]</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management">propertyKey	^propertyKey</body><body package="Store-Merge Management">propertyKey: aSymbol	propertyKey := aSymbol</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>private</category><body package="Store-Merge Management">parseText: aString	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^false].	alternative value value isString ifFalse: [^false].	^aString notNil</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management">definitionTextFor: anAlternative		| target |	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value isString		ifTrue: [anAlternative value]		ifFalse: 			[(anAlternative value value isKindOf: CompiledMethod)				ifFalse: 					[(target := anAlternative value value) isString 						ifTrue: [target]						ifFalse: [target printString]]				ifTrue: [anAlternative value value method getSource]]</body><body package="Store-Merge Management">listIcon	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^PackageModel toolListIcon].	^alternative package toolListIcon</body><body package="Store-Merge Management">longListName	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [nil].	^(alternative isNil		ifTrue: ['Unkown']		ifFalse: [alternative package name]) , (#SpaceBracketPropertyBracketSpace &lt;&lt; #store &gt;&gt; ' [Property] ') asString, self propertyKey printString, self applyableString.</body><body package="Store-Merge Management">mergeDisplayName	| storeObject |	storeObject := ((base notNil and: [base isRemovalResolution]) ifTrue: [base base] ifFalse: [base ifNil: [original ifNil: [proposed]]]).	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value key printString</body><body package="Store-Merge Management">shortListName	^self longListName</body><body package="Store-Merge Management">shortTreeName	^self mergeDisplayName , self applyableString.</body></methods><methods><class-id>Store.ContainsUndeclaredError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog		warn:			(#_1sContainsValuesICtBeforePublishing &lt;&lt; #store &gt;&gt; '&lt;1s&gt; contains values in Undeclared. Please correct before publishing.' expandMacrosWith:					messageText).	^false</body></methods><methods><class-id>Store.ContainsUndeclaredError class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">commentForClassOrNameSpace: aShadowClassOrNameSpace	"Answer a string or nil"	| storeDefinition comment |	storeDefinition := package objectNamed: aShadowClassOrNameSpace longName.	storeDefinition isNil ifTrue: [^nil].	comment := storeDefinition comment.	^comment isEmpty 		ifTrue: [nil] 		ifFalse: [comment]</body><body package="Atomic Compiling and Loading">component	^package</body><body package="Atomic Compiling and Loading">externalClassesNeedingRecompile	^externalClassesNeedingRecompile</body><body package="Atomic Compiling and Loading">externalClassesNeedingRecompile: anObject	externalClassesNeedingRecompile := anObject</body><body package="Atomic Compiling and Loading">installed	^installed</body><body package="Atomic Compiling and Loading">installed: aBoolean	installed := aBoolean</body><body package="Atomic Compiling and Loading">installedWithoutBundlePostLoad	^installed</body><body package="Atomic Compiling and Loading">leafItems	^Array with: self</body><body package="Atomic Compiling and Loading">methodsMovedFromOriginalBinding	^methodsMovedFromOriginalBinding</body><body package="Atomic Compiling and Loading">methodsMovedFromOriginalBinding: aCollection	methodsMovedFromOriginalBinding := aCollection</body><body package="Atomic Compiling and Loading">needsEarlyInstall: aBoolean		needsEarlyInstall := aBoolean</body><body package="Atomic Compiling and Loading">overridden	^overridden</body><body package="Atomic Compiling and Loading">overridden: aCollection	overridden := aCollection</body><body package="Atomic Compiling and Loading">overrides		^overrides</body><body package="Atomic Compiling and Loading">overrides: aCollection		overrides := aCollection</body><body package="Atomic Compiling and Loading">package	^package</body><body package="Atomic Compiling and Loading">package: anObject	package := anObject</body><body package="Atomic Compiling and Loading">packageDifferences	^packageDifferences</body><body package="Atomic Compiling and Loading">packageDifferences: anObject	packageDifferences := anObject</body><body package="Atomic Compiling and Loading">pundle	^self package.</body><body package="Atomic Compiling and Loading">results	^nil</body><body package="Atomic Compiling and Loading">resultsFromParent	^nil</body><body package="Atomic Compiling and Loading">shadowedObjects	^shadowedObjects</body><body package="Atomic Compiling and Loading">shadowedObjects: anObject	shadowedObjects := anObject</body><body package="Atomic Compiling and Loading">unloadableDefinitions	^unloadableDefinitions</body><body package="Atomic Compiling and Loading">unloadableDefinitions: anObject	unloadableDefinitions := anObject</body><body package="Atomic Compiling and Loading">unloadableDefinitionsForBrowsing	"Answer a collection of Unloadable with the package set."	| pkg |	pkg := package createImagePundle.	unloadableDefinitions do:		[ : def | def package: pkg ].	^unloadableDefinitions</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>actions</category><body package="Atomic Compiling and Loading">finishInstall	"I do nothing but am here for being polymorphic with BundleCompilationResult"</body><body package="Atomic Compiling and Loading">install	AtomicLoader new installCompilationResult: self.</body><body package="Atomic Compiling and Loading">installWithoutBundlePostLoad	"We actually DO do a post load, but for Polymorphic reasons with the Bundle result, we let this go"	^self installWithoutPostLoad</body><body package="Atomic Compiling and Loading">installWithoutPostLoad	"We actually DO do a post load, but for Polymorphic reasons with the Bundle result, we let this go"	^self install</body><body package="Atomic Compiling and Loading">markContentsInstalled	installed := true.	package ifNotNil: 		[package applyPundleVersionsToTheImage: true.		package storeModel markNotModified]</body><body package="Atomic Compiling and Loading">markContentsInstalled: aBoolean	installed := true.	package ifNotNil: 		[package applyPundleVersionsToTheImage: true.		aBoolean ifFalse: [package storeModel markNotModified]]</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>testing</category><body package="Atomic Compiling and Loading">classForCompiledMethod: aCompiledMethod		| class |	^(class := aCompiledMethod mclass instanceBehavior) residesInStandardEnvironment		ifTrue: [class]		ifFalse: [class standardEnvironmentClass ifNil: [class]]</body><body package="Atomic Compiling and Loading">hasChanges	packageDifferences ifNotNil: [packageDifferences isEmpty ifFalse: [^true]].	shadowedObjects isEmpty ifFalse: [^true].	^unloadableDefinitions isEmpty not</body><body package="Atomic Compiling and Loading">hasChangesToLoad	^self hasChanges</body><body package="Atomic Compiling and Loading">hasShadowClassMatching: aClass	^shadowedObjects anySatisfy: [:each | each = aClass]</body><body package="Atomic Compiling and Loading">hasShadowMethodMatching: aCompiledMethod	^shadowedObjects anySatisfy: [:each | each = aCompiledMethod and: [each mclass = aCompiledMethod mclass]]</body><body package="Atomic Compiling and Loading">isAtomicallyLoadable	^isAtomicallyLoadable and: [unloadableDefinitions isEmpty]</body><body package="Atomic Compiling and Loading">isAtomicallyLoadable: aBoolean	isAtomicallyLoadable := aBoolean.</body><body package="Atomic Compiling and Loading">isCodeReader	^false</body><body package="Atomic Compiling and Loading">isCompilationResult	^true</body><body package="Atomic Compiling and Loading">isForBundle	^false</body><body package="Atomic Compiling and Loading">isFullyLoaded	"Answer true if no there are no unloadables"	^unloadableDefinitions isEmpty</body><body package="Atomic Compiling and Loading">needsEarlyInstall	needsEarlyInstall == true ifTrue: [^true].	((shadowedObjects select: [:each | each isKindOf: CompiledMethod]) anySatisfy:		[:each | 		((self classForCompiledMethod: each) includesBehavior: Scanner) or: [((self classForCompiledMethod: each) includesBehavior: SmalltalkCompiler) or: [(self classForCompiledMethod: each) = ExternalInterface]]]) 			ifTrue: [^true].	((shadowedObjects select: [:each | each isBehavior]) anySatisfy:		[:each |		(each includesBehavior: Scanner) or: [each includesBehavior: SmalltalkCompiler]])			ifTrue: [^true].	package propertyAt: #installBeforeContinuing ifAbsent: [^false].	^true</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>printing</category><body package="Atomic Compiling and Loading">description	^self printString</body><body package="Atomic Compiling and Loading">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $&lt;;		nextPutAll: package name;		nextPut: $&gt;.</body></methods><methods><class-id>AtomicCompilationResult class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading">from: aShadowPackageCompileManager	^self new		package: aShadowPackageCompileManager package;		shadowedObjects: aShadowPackageCompileManager shadowedObjects;		unloadableDefinitions: aShadowPackageCompileManager unloadableDefinitions;		packageDifferences: aShadowPackageCompileManager packageDifferences;		isAtomicallyLoadable: aShadowPackageCompileManager isAtomicallyLoadable;		overrides: aShadowPackageCompileManager overrides;		overridden: OrderedCollection new;		externalClassesNeedingRecompile: aShadowPackageCompileManager externalClassesNeedingRecompile;		methodsMovedFromOriginalBinding: aShadowPackageCompileManager methodsMovedFromOriginalBinding;		needsEarlyInstall: aShadowPackageCompileManager needsEarlyInstall;		installed: false;		yourself</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableCodeTool</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">binding	^codeModel binding</body><body package="StoreForGlorpBrowserUI">definitionOfBinding: binding 	^binding definition asText</body><body package="StoreForGlorpBrowserUI">template	^Text new</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableCodeTool</class-id> <category>tab APIs</category><body package="StoreForGlorpBrowserUI">isActive	^codeModel sharedVariableName notNil		or: [codeModel isData and: [codeModel protocol notNil]]</body><body package="StoreForGlorpBrowserUI">tabName	^#Share  &gt;&gt; 'Share' &lt;&lt; #browser</body></methods><methods><class-id>Store.ViewUnloadableDefinitionsNotification</class-id> <category>accessing</category><body package="Store-Base">unloadableDefinitionErrors		^unloadableDefinitionErrors</body><body package="Store-Base">unloadableDefinitionErrors: anObject		unloadableDefinitionErrors := anObject</body></methods><methods><class-id>Store.ViewUnloadableDefinitionsNotification</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	"What to do when the exception is unhandled."	UnloadableDefinitionsViewer openOnExceptions: unloadableDefinitionErrors</body></methods><methods><class-id>Store.ViewUnloadableDefinitionsNotification class</class-id> <category>instance creation</category><body package="Store-Base">openOnExceptions: aCollection	| instance |	instance := self new.	instance unloadableDefinitionErrors: aCollection.	instance raise</body></methods><methods><class-id>Store.ViewUnloadableDefinitionsNotification class</class-id> <category>testing</category><body package="Store-Base">mayResume	^true</body></methods><methods><class-id>Store.StoreDevelopmentSystem</class-id> <category>actions</category><body package="Store-Repository Access">setUp	DbRegistry isConnected		ifTrue:			[| action |			DbRegistry resetConnection.			action := self class reconnectAction.			action == #disconnect				ifTrue: [DbRegistry goOffLine]				ifFalse:					[(action == #reconnect and: [DbRegistry recentProfile notNil])						ifTrue: [DbRegistry connectTo: DbRegistry recentProfile]						ifFalse: [DbRegistry restoreConnection]]]</body></methods><methods><class-id>Store.StoreDevelopmentSystem</class-id> <category>prerequisites</category><body package="Store-Repository Access">prerequisiteSystems	"We don't want this to run if we are in runtime, or if we are headless, and we want to wait until the ObjectMemory dependents have been notified, because Store session flushing happens there."	^Array with: DevelopmentSystem with: WindowingSystem with: InterestNotificationSystem.</body></methods><methods><class-id>Store.StoreDevelopmentSystem class</class-id> <category>fileIn/Out</category><body package="Store-Repository Access">prerequisitesForLoading	"List those classes that must be filed or BOSSed into the system 	before I can be loaded."	^(super prerequisitesForLoading)		add: DBAccess;		yourself</body></methods><methods><class-id>Store.StoreDevelopmentSystem class</class-id> <category>accessing</category><body package="Store-Repository Access">reconnectAction	^ReconnectAction ifNil: [#prompt]</body><body package="Store-Repository Access">reconnectAction: anObject	ReconnectAction := anObject</body></methods><methods><class-id>Store.Analyzing</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">actionText	^(#Analyzing &lt;&lt; #store &gt;&gt; 'Analyzing') asString</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading">compileWith: anAtomicAnalysisLoader	[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDefinedRecord: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader addUnloadableDefinition: (exception definitionRecord: self).			exception resume]]				on: RedefinitionNotification				do: 					[:notification |					anAtomicAnalysisLoader overrides add: notification.					override := true.					notification resume]</body><body package="Atomic Compiling and Loading">gatherInto: anAtomicAnalysisLoader	anAtomicAnalysisLoader addAllNamespaces: (Array with: self).</body><body package="Atomic Compiling and Loading">installWith: anAtomicAnalysisLoader	[anAtomicAnalysisLoader installNameSpace: self]		on: RedefinitionNotification		do:			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			(currentPackage notNil and: [self packageModel name = currentPackage name or: [currentPackage name = Registry nullPackageName]]) 				ifFalse: 					[notification override install.					anAtomicAnalysisLoader overrides add: notification].			notification resume]</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">comment	^storeObject comment</body><body package="Atomic Compiling and Loading">longName	^longName</body><body package="Atomic Compiling and Loading">ownerName	^ownerName</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	aStream nextPutAll: 'aShadowedNamespace('.	aStream nextPutAll: self longName.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isForNamespace	^true</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initializeFrom: aStoreNamespaceInPackage	super initializeFrom: aStoreNamespaceInPackage.	longName := aStoreNamespaceInPackage longName.	ownerName := aStoreNamespaceInPackage definition environmentName.</body></methods><methods><class-id>Store.WasConvertedFromParcelWithUndeclaredError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog		warn: (#_1sWasConvertedFroIthUninstalledCode &lt;&lt; #store &gt;&gt; '&lt;1s&gt; was converted from a Parcel with uninstalled code.' expandMacrosWith: messageText).	^false</body></methods><methods><class-id>Store.Glorp.StoreBrowserOverviewTool</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI">overviewText	| stream |	stream := TextStream on: String new.	stream		nextPutAll: 'The ';		emphasis: #italic;		nextPutAll: 'Store Browser';		emphasis: nil;		nextPutAll:				' presents a read-only view of source published to a Store database. Use it for browsing specific versions of bundles and/or packages, with their contained classes and methods. Because this browser works with static representations of method source as opposed to operating in a "live" code environment, you cannot perform some of the operations common to the System Browser, such as searching senders/receivers of selectors in the method source, or any of the refactoring actions.'.	^stream contents</body></methods><methods><class-id>Store.IndentedListBuilder</class-id> <category>initialize-release</category><body package="Store-UI-Graphs">initializeVisualComponentAsCFList	"Return a node for the object, always return a new one."	self visualComponentBlock: 		[ :bldr :object | 		Lens.LDMListElementWrapper				on: (ElementView for: object model: bldr viewModel)				at: 0 @ 0		]</body><body package="Store-UI-Graphs">reset	bottom := 0.	spacing := 16@0</body></methods><methods><class-id>Store.LoadOrSaveInvalidArgumentsError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		Dialog warn: (#_1sInvalidArguments2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: invalid arguments &lt;2s&gt;'		expandMacrosWith: messageText first 		with: messageText last)</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinition</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">method	"Answer the method referenced by the receiver, or nil if none."	^(self implementingClass isForClassOrExtension	and: [self implementingClass includesSelector: self selector])		ifTrue: [self implementingClass compiledMethodAt: self selector]		ifFalse: [nil]</body><body package="StoreForGlorpBrowserUI">name	^selector asString</body><body package="StoreForGlorpBrowserUI">protocol	"Answer the protocol for the receiver's method definition."	^self implementingClass organization categoryOfItem: self selector asSymbol</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinition</class-id> <category>icons</category><body package="StoreForGlorpBrowserUI">toolListIcon	"None of the icons is computable based on what a text only code representation immediately offers us."	^nil</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinition</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">isOverridden	^(self implementingClass instanceMethods select: [:each | each name = selector]) size &gt; 1</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>accessing</category><body package="Store-UI">listTitle		self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title</body><body package="Store-UI">title		^title ifNil: [#VersionsOfNameSpace1s &lt;&lt; #store &gt;&gt; 'Versions of namespace &lt;1s&gt;' expandMacrosWith: self itemsInList list first name]</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>interface opening</category><body package="Store-UI">compositeViewUsing: aNamespace nameSize: longestName longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView	| iconPart currentStart nameLabel timestampLabel mainThing usernameLabel packageNameLabel |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aNamespace toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aNamespace longNameFromSmalltalk asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	timestampLabel := Label with: aNamespace definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aNamespace definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: aNamespace package name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestTimestamp := longestUsername :=  0.	items do:		[:each | 		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestName := (Label with: each longNameFromSmalltalk asText allBold attributes: widget textStyle) width max: longestName].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget tooltip: nil</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>menu</category><body package="Store-UI">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection definition correspondingImageNamespace notNil]</body><body package="Store-UI">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>actions</category><body package="Store-UI">compareSelectionWith	| nameSpace target |	nameSpace := self itemsInList selections first.	target := nameSpace class selectStoreVersionOf: nameSpace name in: nameSpace package session.	target ifNotNil: [TextDifferenceBrowser compare: nameSpace definitionString with: target definitionString]</body><body package="Store-UI">compareVersions	| nameSpace target |	nameSpace := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	TextDifferenceBrowser compare: nameSpace definitionString with: target definitionString</body><body package="Store-UI">containingPackages	| nameSpace packages |	nameSpace := self itemsInList selections first.	[(Gathering for: nameSpace name) started.	packages := StoreNamespaceInPackage allPackagesContaining: nameSpace.	(Gathering for: nameSpace name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: nameSpace longNameFromSmalltalk</body><body package="Store-UI">fileOut	| nameSpace fileName fileManager |	nameSpace := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (nameSpace longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: nameSpace package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			nameSpace fileOutOn: fileManager]				ensure: [fileManager close].			(FilingOut for: nameSpace package) finished].</body><body package="Store-UI">loadNameSpace		| package nameSpace |	nameSpace := self itemsInList selections first.	package := nameSpace package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: [nameSpace loadSource].			(Loading for: package) finished].</body><body package="Store-UI">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText emphasis: #bold.				updateText nextPutAll: each longName.				updateText emphasis: #none.				updateText cr.				updateText nextPutAll: each definition definitionString.				updateText cr.				updateText cr.				updateText emphasis: (Array with: #color-&gt; ColorValue navy).				updateText nextPutAll: each definition comment.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body></methods><methods><class-id>Tools.SinglePropertyView</class-id> <category>accessing</category><body package="Store-Code Comparison">isAddition	^isAddition</body><body package="Store-Code Comparison">isAddition: aBoolean	isAddition := aBoolean</body><body package="Store-Code Comparison">property: aPropertyBlueprint	property := aPropertyBlueprint</body></methods><methods><class-id>Tools.SinglePropertyView</class-id> <category>row population</category><body package="Store-Code Comparison">computeDetailRows	| view |	view := TextEditorView model: (self printProperty: property value) asValue.	view beReadOnly.	^Array with: view</body><body package="Store-Code Comparison">populateHeader	| header |	super populateHeader.	header := self header.	header add: (isAddition				ifTrue: [ComparisonIcons add]				ifFalse: [ComparisonIcons remove]).	header add: (Label with: property key asText allBold)</body></methods><methods><class-id>Tools.SinglePropertyView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^Array with: #singleCodeComponentProperty with: self propertyKey</body></methods><methods><class-id>Tools.SinglePropertyView</class-id> <category>private</category><body package="Store-Code Comparison">propertyKey	^property key</body></methods><methods><class-id>Store.DeletionToolFilter</class-id> <category>accessing</category><body package="Store-UI">afterDate	^afterDate</body><body package="Store-UI">afterDate: aDate	afterDate := aDate</body><body package="Store-UI">beforeDate	^beforeDate</body><body package="Store-UI">beforeDate: aDate	beforeDate := aDate</body><body package="Store-UI">blessingGreater	^blessingGreater</body><body package="Store-UI">blessingGreater: anInteger	blessingGreater := anInteger</body><body package="Store-UI">blessingLess	^blessingLess</body><body package="Store-UI">blessingLess: anInteger	blessingLess := anInteger</body><body package="Store-UI">pundleName	^pundleName</body><body package="Store-UI">pundleName: aString	pundleName := aString</body><body package="Store-UI">versionLike	^versionLike</body><body package="Store-UI">versionLike: aString	versionLike := aString</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading">compileWith: anAtomicAnalysisLoader	[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDefinedRecord: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader addUnloadableDefinition: (exception definitionRecord: self).			exception resume]]				on: RedefinitionNotification				do: 					[:notification |					anAtomicAnalysisLoader overrides add: notification.					override := true.					notification resume]</body><body package="Atomic Compiling and Loading">gatherInto: anAtomicAnalysisLoader	anAtomicAnalysisLoader addAllShareds: (Array with: self).</body><body package="Atomic Compiling and Loading">installWith: anAtomicAnalysisLoader	[anAtomicAnalysisLoader installSharedBinding: self]		on: RedefinitionNotification		do:			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			(self packageModel name = currentPackage name or: [currentPackage name = Registry nullPackageName]) 				ifFalse: 					[notification override install.					anAtomicAnalysisLoader overrides add: notification].			notification resume]</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">comment	^storeObject comment</body><body package="Atomic Compiling and Loading">longName	^longName</body><body package="Atomic Compiling and Loading">ownerName	^ownerName</body><body package="Atomic Compiling and Loading">shadowedArguments	| parse |	parse := Compiler new parse: storeObject definitionString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	^parse arguments collect: [:each | each value]</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	aStream nextPutAll: 'aShadowedShared('.	aStream nextPutAll: self longName.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isClassVariable	^self storeObject isClassVariable</body><body package="Atomic Compiling and Loading">isForSharedVariable	^true</body><body package="Atomic Compiling and Loading">isInNameSpace	^self storeObject isInNameSpace</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initializeFrom: aStoreSharedVariableInPackage	super initializeFrom: aStoreSharedVariableInPackage.	longName := aStoreSharedVariableInPackage longName.	ownerName := aStoreSharedVariableInPackage definition environmentName.</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>accessing</category><body package="Store-Difference Management">mainPackage	^mainPackage</body><body package="Store-Difference Management">mainPackageClasses	^mainPackageClasses</body><body package="Store-Difference Management">mainPackageClasses: aCollection	mainPackageClasses := aCollection asOrderedCollection</body><body package="Store-Difference Management">mainPackageMethods	^mainPackageMethods</body><body package="Store-Difference Management">mainPackageMethods: aCollection	mainPackageMethods := aCollection asOrderedCollection</body><body package="Store-Difference Management">mainPackageNamespaces	^mainPackageNamespaces</body><body package="Store-Difference Management">mainPackageNamespaces: aCollection	mainPackageNamespaces := aCollection asOrderedCollection</body><body package="Store-Difference Management">mainPackageProperties	^mainPackageProperties</body><body package="Store-Difference Management">mainPackageProperties: aCollection	mainPackageProperties := aCollection asOrderedCollection</body><body package="Store-Difference Management">mainPackageShareds	^mainPackageShareds</body><body package="Store-Difference Management">mainPackageShareds: aCollection	mainPackageShareds := aCollection asOrderedCollection</body><body package="Store-Difference Management">otherPackage	^otherPackage</body><body package="Store-Difference Management">otherPackageClasses	^otherPackageClasses</body><body package="Store-Difference Management">otherPackageClasses: aCollection	otherPackageClasses := aCollection asOrderedCollection</body><body package="Store-Difference Management">otherPackageMethods	^otherPackageMethods</body><body package="Store-Difference Management">otherPackageMethods: aCollection	otherPackageMethods := aCollection asOrderedCollection</body><body package="Store-Difference Management">otherPackageNamespaces	^otherPackageNamespaces</body><body package="Store-Difference Management">otherPackageNamespaces: aCollection	otherPackageNamespaces := aCollection asOrderedCollection</body><body package="Store-Difference Management">otherPackageProperties	^otherPackageProperties</body><body package="Store-Difference Management">otherPackageProperties: aCollection	otherPackageProperties := aCollection asOrderedCollection</body><body package="Store-Difference Management">otherPackageShareds	^otherPackageShareds</body><body package="Store-Difference Management">otherPackageShareds: aCollection	otherPackageShareds := aCollection asOrderedCollection</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>post load utilities</category><body package="Store-Difference Management">classesToRemoveAfterLoad		^otherPackageClasses select: 		[:each | 		each isOverride not and: 			[mainPackageClasses allSatisfy: [:eachClass | eachClass absoluteName ~= each absoluteName]]]</body><body package="Store-Difference Management">methodsToRemoveAfterLoad		^otherPackageMethods select:		[:each | 		each isOverride not and:			[mainPackageMethods allSatisfy:				[:eachMethod | 				eachMethod isMeta ~= each isMeta or: 					[eachMethod name ~= each name or: 					[eachMethod className asClassNameOnly ~= each className asClassNameOnly]]]]]</body><body package="Store-Difference Management">nameSpacesToRemoveAfterLoad		^otherPackageNamespaces select: 		[:each | 		each isOverride not and: 			[mainPackageNamespaces allSatisfy: [:eachNamespace | eachNamespace absoluteName ~= each absoluteName]]]</body><body package="Store-Difference Management">sharedsToRemoveAfterLoad		^otherPackageShareds select:		[:each | 		each isOverride not and: 			[mainPackageShareds allSatisfy: 				[:eachShared | 				eachShared name ~= each name or: [eachShared environmentString ~= each environmentString]]]]</body><body package="Store-Difference Management">sortedClassesToRemoveAfterLoad	| namedClassesToRemove sortedClasses sortedObjects |	namedClassesToRemove := self classesToRemoveAfterLoad.	sortedClasses := SystemUtils sortForLoading: (namedClassesToRemove collect: [:each | each actual]).	sortedObjects := OrderedCollection new: namedClassesToRemove size.	1 to: sortedClasses size do:		[:index |		sortedObjects add: (namedClassesToRemove 			detect: [:each | each absoluteName = (sortedClasses at: index) absoluteName] 			ifNone: [nil])].	^(sortedObjects reject: [:each | each isNil]) reverse</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>private</category><body package="Store-Difference Management">combineDiffsFrom: aPackageComparitor	"Add differences from aPackageComparitor into my differences."		self mainPackageMethods: self mainPackageMethods , aPackageComparitor mainPackageMethods.	self otherPackageMethods: self otherPackageMethods , aPackageComparitor otherPackageMethods.	self mainPackageClasses: self mainPackageClasses , aPackageComparitor mainPackageClasses.	self otherPackageClasses: self otherPackageClasses , aPackageComparitor otherPackageClasses.	self mainPackageShareds: self mainPackageShareds , aPackageComparitor mainPackageShareds.	self otherPackageShareds: self otherPackageShareds , aPackageComparitor otherPackageShareds.	self mainPackageNamespaces: self mainPackageNamespaces , aPackageComparitor mainPackageNamespaces.	self otherPackageNamespaces: self otherPackageNamespaces , aPackageComparitor otherPackageNamespaces.	self removeDuplicateDifferencesIn: mainPackageMethods and: otherPackageMethods.	self removeDuplicateDifferencesIn: mainPackageClasses and: otherPackageClasses.	self removeDuplicateDifferencesIn: mainPackageShareds and: otherPackageShareds.	self removeDuplicateDifferencesIn: mainPackageNamespaces and: otherPackageNamespaces</body><body package="Store-Difference Management">removeDuplicateDifferencesIn: aCollection and: anotherCollection	"Remove differences that are in both."		| definitionsToRemove |	definitionsToRemove := List new.	aCollection do:		[:each | 		| index |		(index := anotherCollection indexOf: each ifAbsent: [nil])			ifNotNil:				[anotherCollection removeAtIndex: index.				definitionsToRemove add: each]].	aCollection removeAll: definitionsToRemove</body><body package="Store-Difference Management">reverse	"Swap mainPackage with otherPackage"	| exchangeHolder |	exchangeHolder := mainPackage.	mainPackage := otherPackage.	otherPackage := exchangeHolder.	exchangeHolder := mainPackageClasses.	mainPackageClasses := otherPackageClasses.	otherPackageClasses := exchangeHolder.	exchangeHolder := mainPackageMethods.	mainPackageMethods := otherPackageMethods.	otherPackageMethods := exchangeHolder.	exchangeHolder := mainPackageShareds.	mainPackageShareds := otherPackageShareds.	otherPackageShareds := exchangeHolder.	exchangeHolder := mainPackageNamespaces.	mainPackageNamespaces := otherPackageNamespaces.	otherPackageNamespaces := exchangeHolder.</body><body package="Store-Difference Management">setMainPackage: aPackage otherPackage: anotherPackage	mainPackage := aPackage.	otherPackage := anotherPackage</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>obsolete</category><body package="Store-Difference Management">removeMatchingDefinitions	self removeMethodDifferencesIn: mainPackageMethods and: otherPackageMethods.	self cleanUpSharedDifferenceIn: mainPackageShareds and: otherPackageShareds.</body><body package="Store-Difference Management">removeMethodDifferencesIn: aCollectionOfMethods and: anotherCollectionOfMethods	| methodsToRemove |	methodsToRemove := OrderedCollection new: aCollectionOfMethods size.	aCollectionOfMethods do:		[:each |		| index |		index := anotherCollectionOfMethods findFirst: 			[:eachMethod | eachMethod selector = each selector and: [eachMethod classNameWithMeta = each classNameWithMeta]].		index isZero ifFalse:			[ |otherMethod| 			otherMethod := anotherCollectionOfMethods at: index.			(otherMethod sourceMatches: each) ifTrue:				[methodsToRemove add: each.				anotherCollectionOfMethods removeAtIndex: index]]].	aCollectionOfMethods removeAll: methodsToRemove</body><body package="Store-Difference Management">removeSharedDifferencesIn: aCollectionOfShareds and: anotherCollectionOfShareds	| sharedsToRemove |	sharedsToRemove := OrderedCollection new: aCollectionOfShareds size.	aCollectionOfShareds do:		[:each |		| index |		index := anotherCollectionOfShareds findFirst: 			[:eachShared | eachShared absoluteName = each absoluteName].		index isZero ifFalse:			[ |otherShared| 			otherShared := anotherCollectionOfShareds at: index.			(otherShared sourceMatches: each) ifTrue:				[sharedsToRemove add: each.				anotherCollectionOfShareds removeAtIndex: index]]].	aCollectionOfShareds removeAll: sharedsToRemove</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>comparison</category><body package="Store-Difference Management">cleanseSystem		Registry cleanseModels.	mainPackage cleanse: false.	otherPackage cleanse: false</body><body package="Store-Difference Management">computeDifferences	(Comparing for: mainPackage) started.	self cleanseSystem.	mainPackage computeDiffsBetween: otherPackage into: self.	(Comparing for: mainPackage) finished.</body><body package="Store-Difference Management">computeDifferencesWithProperties		(Comparing for: mainPackage) started.	self cleanseSystem.	mainPackage computeDifferencesBetween: otherPackage into: self.	mainPackage computePropertyDifferencesBetween: otherPackage into: self.	(Comparing for: mainPackage) finished.</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>counting</category><body package="Store-Difference Management">itemCount	^mainPackageClasses size + mainPackageNamespaces size + mainPackageMethods size +  mainPackageShareds size</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>testing</category><body package="Store-Difference Management">hasDifferences	^mainPackageMethods isEmpty not or:		[otherPackageMethods isEmpty not or:		[mainPackageShareds isEmpty not or: 		[otherPackageShareds  isEmpty not or: 		[mainPackageNamespaces isEmpty not or:		[otherPackageNamespaces isEmpty not or:		[mainPackageClasses  isEmpty not or: 		[otherPackageClasses isEmpty not or:		[mainPackageProperties isEmpty not or:		[otherPackageProperties isEmpty not]]]]]]]]]</body><body package="Store-Difference Management">isPackageComparitor	^true</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>private-filing out</category><body package="Store-Difference Management">fileOutDifferencesFrom: aCollectionOfFromObjects to: aCollectionOfToObjects on: aSourceCodeStream	aCollectionOfFromObjects do:		[:each || target |		target := aCollectionOfToObjects detect: [:eachObject | each absoluteName = eachObject absoluteName] ifNone: [nil].		target ifNotNil: [target fileOutDifferencesBetween: each on: aSourceCodeStream]].</body><body package="Store-Difference Management">fileOutNewFrom: someObjects notIn: someOtherObjects on: aSourceCodeStream		| target |	someObjects		do:			[:each | 			target := someOtherObjects detect: [:eachObject | each absoluteName = eachObject absoluteName] ifNone: [nil].			target ifNil: [each fileOutOn: aSourceCodeStream]]</body><body package="Store-Difference Management">fileOutNewMainObjectsOn: aSourceCodeStream		self fileOutNewFrom: mainPackageNamespaces notIn: otherPackageNamespaces on: aSourceCodeStream.	self fileOutDifferencesFrom: otherPackageNamespaces to: mainPackageNamespaces on: aSourceCodeStream.	self fileOutNewFrom: mainPackageClasses notIn: otherPackageClasses on: aSourceCodeStream.	self fileOutDifferencesFrom: otherPackageClasses to: mainPackageClasses on: aSourceCodeStream.	self fileOutNewFrom: mainPackageShareds notIn: otherPackageShareds on: aSourceCodeStream.	self fileOutDifferencesFrom: otherPackageShareds to: mainPackageShareds on: aSourceCodeStream.</body><body package="Store-Difference Management">fileOutNewOtherObjectsOn: aSourceCodeStream		self fileOutNewFrom: otherPackageNamespaces notIn: mainPackageNamespaces on: aSourceCodeStream.	self fileOutDifferencesFrom: mainPackageNamespaces to: otherPackageNamespaces on: aSourceCodeStream.	self fileOutNewFrom: otherPackageClasses notIn: mainPackageClasses on: aSourceCodeStream.	self fileOutDifferencesFrom: mainPackageClasses to: otherPackageClasses on: aSourceCodeStream.	self fileOutNewFrom: otherPackageShareds notIn: mainPackageShareds on: aSourceCodeStream.	self fileOutDifferencesFrom: mainPackageShareds to: otherPackageShareds on: aSourceCodeStream.</body><body package="Store-Difference Management">newMethodsFrom: aCollectionOfMethods	| modified classOrder protocolOrder |	modified := Dictionary new.	aCollectionOfMethods		do: 			[:each | 			classOrder := modified at: each classNameWithMeta ifAbsent: [Dictionary new].			protocolOrder := classOrder at: each protocol ifAbsent: [Set new].			protocolOrder add: each.			classOrder at: each protocol put: protocolOrder.			modified at: each classNameWithMeta put: classOrder].	^modified</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>user interface support</category><body package="Store-Difference Management">changedClassesNamespacesAndProperties	| changedObjects |	changedObjects := self collectionClass new.	self collectMainPackageClassesInto: changedObjects.	self collectOtherPackageClassesInto: changedObjects.	self collectMainPackageNamespacesInto: changedObjects.	self collectOtherPackageNamespacesInto: changedObjects.	self collectMainPackageSharedsInto: changedObjects.	self collectOtherPackageSharedsInto: changedObjects.	self collectMainPackageMethodsInto: changedObjects.	self collectOtherPackageMethodsInto: changedObjects.	changedObjects := self sortIntoDisplayOrder: changedObjects.	self collectAllChangedPackagePropertiesInto: changedObjects.	^changedObjects</body><body package="Store-Difference Management">changedClassesNamespacesAndPropertiesForMerge	| changedObjects |	changedObjects := self collectionClass new.	self collectMainPackageClassesInto: changedObjects.	self collectOtherPackageClassesInto: changedObjects.	self collectMainPackageNamespacesInto: changedObjects.	self collectOtherPackageNamespacesInto: changedObjects.	self collectMainPackageSharedsForMergeInto: changedObjects.	self collectOtherPackageSharedsForMergeInto: changedObjects.	self collectMainPackageMethodsInto: changedObjects.	self collectOtherPackageMethodsInto: changedObjects.	changedObjects := self sortIntoDisplayOrder: changedObjects.	self collectAllChangedPackagePropertiesInto: changedObjects.	otherPackage pseudoPackage		ifTrue: [changedObjects do: [:each | each otherPackage: otherPackage]].	^changedObjects</body><body package="Store-Difference Management">collectAllChangedPackagePropertiesInto: changedObjects	(mainPackageProperties notEmpty or: [otherPackageProperties notEmpty])		ifTrue: 			[| propertyChange |			propertyChange := PseudoPropertiesDifference mainPackage: mainPackage						properties: mainPackageProperties.			propertyChange otherPackage: otherPackage				properties: otherPackageProperties.			changedObjects add: propertyChange]</body><body package="Store-Difference Management">collectMainPackageClassesInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		mainPackageClasses notNil		ifTrue: [			mainPackageClasses do: [:each | 				changedObjects at: each longNameFromSmalltalk 					ifAbsentPut: [PseudoClassDifference mainPackage: mainPackage class: each]]]</body><body package="Store-Difference Management">collectMainPackageMethodsInto: changedObjects	"PseudoMethodDifferences are are contained in PseudoClassDifferences"	"The targetClassDifference should NEVER have mainPackage as nil"	| targetClassDifference |	mainPackageMethods notNil		ifTrue: 			[mainPackageMethods do: 					[:each |					targetClassDifference := changedObjects at: each longNameFromSmalltalk								ifAbsentPut: [PseudoClassDifference new].					self updateClassDifference: targetClassDifference withMainPackageMethod: each]]</body><body package="Store-Difference Management">collectMainPackageNamespacesInto: changedObjects	"The targetNamespaceDifference should NEVER have mainPackage as nil"		mainPackageNamespaces notNil		ifTrue: [			mainPackageNamespaces do: [:each | 				changedObjects at: each longNameFromSmalltalk					ifAbsentPut: [PseudoNamespaceDifference mainPackage: mainPackage namespace: each]]]</body><body package="Store-Difference Management">collectMainPackagePropertiesInto: changedObjects		changedObjects add: (PseudoPropertiesDifference mainPackage: mainPackage properties: mainPackageProperties)</body><body package="Store-Difference Management">collectMainPackageSharedsForMergeInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		mainPackageShareds notNil		ifTrue: [			mainPackageShareds do: [:each | | targetClassDifference |				targetClassDifference := changedObjects at: each environmentNameFromSmalltalk					ifAbsentPut: [						each belongsToClass							ifTrue: [PseudoClassForSharedDifference mainPackage: mainPackage 									class: (mainPackage objectNamed: each absoluteOwnerName asString)]							ifFalse: [PseudoNamespaceForSharedDifference mainPackage: mainPackage fromShared: each]].				targetClassDifference mainPackage: mainPackage shared: each]]</body><body package="Store-Difference Management">collectMainPackageSharedsInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		mainPackageShareds notNil		ifTrue: [			mainPackageShareds do: [:each | | targetClassDifference |				targetClassDifference := changedObjects at: each environmentNameFromSmalltalk					ifAbsentPut: [						each belongsToClass							ifTrue: [PseudoClassDifference mainPackage: mainPackage 									class: (mainPackage objectNamed: each absoluteOwnerName asString)]							ifFalse: [PseudoNamespaceDifference mainPackage: mainPackage fromShared: each]].				targetClassDifference mainPackage: mainPackage shared: each]]</body><body package="Store-Difference Management">collectOtherPackageClassesInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		otherPackageClasses notNil		ifTrue: [			otherPackageClasses do: [:each | | targetClassDifference |				targetClassDifference := changedObjects at: each longNameFromSmalltalk 						ifAbsentPut: [PseudoClassDifference new].				targetClassDifference otherPackage: otherPackage class: each]]</body><body package="Store-Difference Management">collectOtherPackageMethodsInto: changedObjects	otherPackageMethods notNil		ifTrue: 			[otherPackageMethods do: 					[:each |					| targetClassDifference |					targetClassDifference := changedObjects at: each longNameFromSmalltalk								ifAbsentPut: [PseudoClassDifference new].					self updateClassDifference: targetClassDifference						withOtherPackageMethod: each]]</body><body package="Store-Difference Management">collectOtherPackageNamespacesInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		otherPackageNamespaces notNil		ifTrue: [			otherPackageNamespaces do: [:each | | targetNamespaceDifference |				targetNamespaceDifference := changedObjects at: each longNameFromSmalltalk					ifAbsentPut: [ PseudoNamespaceDifference new].				targetNamespaceDifference otherPackage: otherPackage namespace: each]]</body><body package="Store-Difference Management">collectOtherPackagePropertiesInto: changedObjects	| targetChange |	targetChange := changedObjects detect: [:each | each classListName = PseudoPropertiesDifference classListName].	targetChange otherPackage: otherPackage properties: otherPackageProperties</body><body package="Store-Difference Management">collectOtherPackageSharedsForMergeInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		otherPackageShareds notNil		ifTrue: [			otherPackageShareds do: [:each | | targetClassDifference |				targetClassDifference := changedObjects at: each environmentNameFromSmalltalk					ifAbsentPut: [						each belongsToClass							ifTrue: [PseudoClassForSharedDifference otherPackage: otherPackage 									class: (otherPackage objectNamed: each absoluteOwnerName asString)]							ifFalse: [PseudoNamespaceForSharedDifference otherPackage: otherPackage fromShared: each]].				targetClassDifference otherPackage: otherPackage shared: each]]</body><body package="Store-Difference Management">collectOtherPackageSharedsInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		otherPackageShareds notNil		ifTrue: [			otherPackageShareds do: [:each | | targetClassDifference |				targetClassDifference := changedObjects at: each environmentNameFromSmalltalk					ifAbsentPut: [						each belongsToClass							ifTrue: [PseudoClassDifference otherPackage: otherPackage 									class: (otherPackage objectNamed: each absoluteOwnerName asString)]							ifFalse: [PseudoNamespaceDifference otherPackage: otherPackage fromShared: each]].				targetClassDifference otherPackage: otherPackage shared: each]]</body><body package="Store-Difference Management">makeEmpty	mainPackageMethods := otherPackageMethods := mainPackageShareds := otherPackageShareds := mainPackageNamespaces := otherPackageNamespaces := #().	mainPackageClasses := otherPackageClasses := mainPackageProperties := otherPackageProperties :=#()</body><body package="Store-Difference Management">sortIntoDisplayOrder: changedObjects	^(changedObjects collect: [:each | each classListName -&gt; each])		asSortedCollection collect: [:each | each value]</body><body package="Store-Difference Management">updateClassDifference: targetClassDifference withMainPackageMethod: each	mainPackage pseudoPackage		ifTrue: 			[targetClassDifference otherPackage: otherPackage				class: (otherPackage objectNamed: each classNameWithoutMeta)]		ifFalse: 			[targetClassDifference mainPackage: mainPackage				class: (mainPackage objectNamed: each classNameWithoutMeta).			otherPackage pseudoPackage				ifFalse: 					[(otherPackage objectNamed: each classNameWithoutMeta)						ifNotNil: [:value | targetClassDifference otherPackage: otherPackage class: value]]].	^targetClassDifference mainPackage: mainPackage method: each</body><body package="Store-Difference Management">updateClassDifference: targetClassDifference withOtherPackageMethod: each	targetClassDifference otherPackage: otherPackage		class: (otherPackage objectNamed: each classNameWithoutMeta).	(targetClassDifference mainObject isNil		and: [mainPackage pseudoPackage not])			ifTrue: 				[(mainPackage objectNamed: each classNameWithoutMeta)					ifNotNil: [:value | targetClassDifference mainPackage: mainPackage class: value]].	^targetClassDifference otherPackage: otherPackage method: each</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>filing out</category><body package="Store-Difference Management">classesToRemoveForMain	^mainPackageClasses select:		[:each |		(otherPackageClasses			detect: [:eachClass | eachClass absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management">classesToRemoveForOther	^otherPackageClasses select:		[:each |		(mainPackageClasses			detect: [:eachClass | eachClass absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management">fileOutMainToOtherDifferencesOn: aSourceCodeStream		aSourceCodeStream deferInitializations.	aSourceCodeStream cr.	aSourceCodeStream addComment: ((#PackageDifferencesFrom1sto2s &lt;&lt; #packages &gt;&gt; 'Package Differences from &lt;1s&gt; to &lt;2s&gt;')			expandMacrosWith: mainPackage itemString			with: otherPackage itemString).	self fileOutNewOtherObjectsOn: aSourceCodeStream.	self fileOutRemoveMainObjectsOn: aSourceCodeStream.	self newOtherMethods keysAndValuesDo:		[:key :value | aSourceCodeStream fileOutTTMessages: value for: key logging: false].	self methodsToRemoveForMain do:		[:each | aSourceCodeStream removeSelector: each selector fromClassNamed: each classNameWithMeta].	self		fileOutNewChangedProps: self otherPackageProperties		removeOldProps: self mainPackageProperties		of: self otherPackage		on: aSourceCodeStream.	aSourceCodeStream finishInitializations</body><body package="Store-Difference Management">fileOutNewChangedProps: targetProperties removeOldProps: sourceProperties of: aPundle on: aSourceCodeStream	"The comparitor drops volatilePropertyKeys when doing its comparison but file-out requires 	propertiesForFileOut which (if this were a PundleModel - if it is a StorePundle then they are already 	absent) omits volatile and a few more.  We therefore iterate over propertiesToFileOut, ignoring those 	that have not been found to differ by the comparitor.	This also avoids the fact that the comparitor's differing properties list may also contain #structure	(used to record the bundle structure if it has changed).	If the #structure key is absent, this is not a bundle or its bundle structure did not change."	| propKeys |	propKeys := targetProperties collect: [:each | each key].	sourceProperties do:		[:each |		(propKeys includes: each key) ifFalse:			[aSourceCodeStream component: aPundle property: each key value: nil]].	aPundle propertiesForFileOut keysAndValuesDo:		[:eachKey :eachValue |		(propKeys includes: eachKey) ifTrue:			[aSourceCodeStream component: aPundle property: eachKey value: eachValue]].	aSourceCodeStream		bundleNamed: aPundle name		structure: (targetProperties detect: [:each | each key = #structure] ifNone: [^self]) value.</body><body package="Store-Difference Management">fileOutOtherToMainDifferencesOn: aSourceCodeStream		aSourceCodeStream deferInitializations.	aSourceCodeStream addComment: ((#PackageDifferencesFrom1sto2s &lt;&lt; #packages &gt;&gt; 'Package Differences from &lt;1s&gt; to &lt;2s&gt;')			expandMacrosWith: otherPackage itemString			with: mainPackage itemString).	self fileOutNewMainObjectsOn: aSourceCodeStream.	self fileOutRemoveOtherObjectsOn: aSourceCodeStream.	self newMainMethods keysAndValuesDo:		[:key :value | aSourceCodeStream fileOutTTMessages: value for: key logging: false].	self methodsToRemoveForOther do:		[:each | aSourceCodeStream removeSelector: each selector fromClassNamed: each classNameWithMeta].	self		fileOutNewChangedProps: self mainPackageProperties		removeOldProps: self otherPackageProperties		of: self mainPackage		on: aSourceCodeStream.	aSourceCodeStream finishInitializations</body><body package="Store-Difference Management">fileOutRemoveMainObjectsOn: aSourceCodeStream		self sharedsToRemoveForMain do: [:each | aSourceCodeStream removeObject: each absoluteName type: #variable].	self classesToRemoveForMain do: [:each | aSourceCodeStream removeObject: each absoluteName type: #class].	self nameSpacesToRemoveForMain do: [:each | aSourceCodeStream removeObject: each absoluteName type: #nameSpace]</body><body package="Store-Difference Management">fileOutRemoveOtherObjectsOn: aSourceCodeStream		self sharedsToRemoveForOther do: [:each | aSourceCodeStream removeObject: each absoluteName type: #variable].	self classesToRemoveForOther do: [:each | aSourceCodeStream removeObject: each absoluteName type: #class].	self nameSpacesToRemoveForOther do: [:each | aSourceCodeStream removeObject: each absoluteName type: #nameSpace]</body><body package="Store-Difference Management">methodsToRemoveForMain	^mainPackageMethods select:		[:each |		(otherPackageMethods 			detect:				[:eachMethod | 				(eachMethod isMeta = each isMeta and: [eachMethod name = each name]) and: 					[eachMethod className asClassNameOnly = each className asClassNameOnly]]			ifNone: [nil]) isNil]</body><body package="Store-Difference Management">methodsToRemoveForOther	^otherPackageMethods select:		[:each |		(mainPackageMethods 			detect:				[:eachMethod | 				(eachMethod isMeta = each isMeta and: [eachMethod name = each name]) and: 					[eachMethod className asClassNameOnly = each className asClassNameOnly]]			ifNone: [nil]) isNil]</body><body package="Store-Difference Management">nameSpacesToRemoveForMain		^mainPackageNamespaces select: 		[:each | 		(otherPackageNamespaces 			detect: [:eachNamespace | eachNamespace absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management">nameSpacesToRemoveForOther		^otherPackageNamespaces select: 		[:each | 		(mainPackageNamespaces 			detect: [:eachNamespace | eachNamespace absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management">newMainMethods	^self newMethodsFrom: mainPackageMethods</body><body package="Store-Difference Management">newOtherMethods	^self newMethodsFrom: otherPackageMethods</body><body package="Store-Difference Management">sharedsToRemoveForMain	^mainPackageShareds select:		[:each |		(otherPackageShareds			detect: [:eachShared | eachShared name = each name and: [eachShared environmentString = each environmentString]] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management">sharedsToRemoveForOther	^otherPackageShareds select:		[:each |		(mainPackageShareds			detect: [:eachShared | eachShared name = each name and: [eachShared environmentString = each environmentString]] 			ifNone: [nil]) isNil]</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>printing</category><body package="Store-Difference Management">mainVersionNameString		^mainPackage name , mainPackage versionString</body><body package="Store-Difference Management">otherVersionNameString		^otherPackage name , otherPackage versionString</body><body package="Store-Difference Management">versionNamesString		^self mainVersionNameString , ' -&gt; ' , self otherVersionNameString</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>initialize-release</category><body package="Store-Difference Management">initialize	mainPackageMethods := self collectionClass new.	otherPackageMethods := self collectionClass new.	mainPackageShareds := self collectionClass new.	otherPackageShareds := self collectionClass new.	mainPackageNamespaces := self collectionClass new.	otherPackageNamespaces := self collectionClass new.	mainPackageClasses := self collectionClass new.	otherPackageClasses := self collectionClass new.	mainPackageProperties := self collectionClass new.	otherPackageProperties:= self collectionClass new.</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>extracting differences</category><body package="Store-Difference Management">extractFullClassDefinitionDifferencesBetween: aPackageModel and: aStorePackageOrPseudo	| mainObjects otherObjects |	mainObjects := (aStorePackageOrPseudo classesDefinedInPackage collect: [:each | each asStoreClassDefinition]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	aPackageModel classesDefinedInPackage do: [:each | | storeClassDef |		storeClassDef := each asStoreClassDefinition.		mainObjects remove: storeClassDef ifAbsent: [otherObjects add: storeClassDef]].	self otherPackageClasses: otherObjects.	self mainPackageClasses:  mainObjects.</body><body package="Store-Difference Management">extractFullMethodDifferencesBetween: aPackageModel and: aStorePackageOrPseudo	| mainObjects otherObjects |	mainObjects := (aStorePackageOrPseudo methodsWithSource collect: [:each | each asStoreMethodDefinition]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	aPackageModel methods do: [:each | | storeMethodDef | 		storeMethodDef := each asStoreMethodDefinition.		mainObjects remove: storeMethodDef ifAbsent: [otherObjects add: storeMethodDef]].	self otherPackageMethods: otherObjects.	self mainPackageMethods: mainObjects</body><body package="Store-Difference Management">extractFullNameSpaceDifferencesBetween: aPackageModel and: aStorePackageOrPseudo	| mainObjects otherObjects |	mainObjects := (aStorePackageOrPseudo nameSpacesDefinedInPackage collect: [:each | each asStoreNameSpace]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	aPackageModel nameSpacesDefinedInPackage do: [:each| | nameSpaceDef | 		nameSpaceDef := each asStoreNameSpace.		mainObjects remove: nameSpaceDef ifAbsent: [otherObjects add: nameSpaceDef]].	self otherPackageNamespaces: otherObjects.	self mainPackageNamespaces: mainObjects.</body><body package="Store-Difference Management">extractFullSharedVariableDifferencesBetween: aPackageModel and: aStorePackageOrPseudo	| mainObjects otherObjects |	mainObjects := (aStorePackageOrPseudo data collect: [:each | each asStoreSharedVariable]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	aPackageModel data do: [:each | | sharedVariableDef |		sharedVariableDef := each asStoreSharedVariable.		mainObjects remove: sharedVariableDef ifAbsent: [otherObjects add: sharedVariableDef]].	self otherPackageShareds: otherObjects.	self mainPackageShareds: mainObjects.</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>constants</category><body package="Store-Difference Management">collectionClass	^Dictionary</body></methods><methods><class-id>Store.PackageComparitor class</class-id> <category>instance creation</category><body package="Store-Difference Management">differencesBetween: aPackage and: anotherPackage	| instance |	instance := self new.	instance setMainPackage: aPackage otherPackage: anotherPackage.	instance computeDifferences.	^instance</body><body package="Store-Difference Management">differencesWithPropertiesBetween: aPackage and: anotherPackage	| instance |	instance := self new.	instance setMainPackage: aPackage otherPackage: anotherPackage.	instance computeDifferencesWithProperties.	^instance</body><body package="Store-Difference Management">new	^super new initialize</body><body package="Store-Difference Management">newForMainPackage: aPackage otherPackage: otherPackage	^(self new)		setMainPackage: aPackage otherPackage: otherPackage</body></methods><methods><class-id>Store.Glorp.StorePundleEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">at: aBinding ifAbsent: aBlock	^environment at: aBinding asString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">classForName: aString ifAbsent: aBlock	"We may sometimes hand out object name wrappers but should always receive full names back from our navigator and state.  (Our code assumes that aBlock will either return or answer something that responds to #objectNamed:)"	self pundles do: [:each | (each objectNamed: aString) ifNotNil: [:theClass | ^theClass]].	^aBlock value</body><body package="StoreForGlorpBrowserUI">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body><body package="StoreForGlorpBrowserUI">pundles	| pundles |	pundles := OrderedCollection new.	self bundleNames collect:		[:each |		pundles add: (self environment pundleNamed: each isPackage: false)].	self packageNames collect:		[:each |		pundles add: (self environment pundleNamed: each isPackage: true)].	^pundles</body><body package="StoreForGlorpBrowserUI">repositoryName	^environment repositoryName</body></methods><methods><class-id>Store.Glorp.StorePundleEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI">classForName: aString	^self classForName: aString ifAbsent: [nil]</body></methods><methods><class-id>Store.Installing</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">actionText	^(#Installing &lt;&lt; #store &gt;&gt; 'Installing') asString</body></methods><methods><class-id>Store.Glorp.PundleVersionTooltipAssistant</class-id> <category>accessing</category><body package="Store-UI">displayBoxFor: aVisualPart	"Use a non-zero hoverOffset to offset the hover window from the origin of the list item at the current mouse location.	 The list items for this widget are NOT Label or LabelAndIcon, so we cannot use the standard #globalBoundsOfElementTextAt:	 to get the elementBox bounds."	| index offset elementBounds origin extent elementBox |	index := view mouseOverIndex.	offset := self hoverOffset cull: view cull: index.	elementBounds := view globalBoundsOfElementAt: index.	origin := elementBounds origin + offset.	extent := aVisualPart preferredExtent.	"Return a box that will fit aVisualPart's desired size, and is centered around the element bounds (and at least as big as that)"	elementBox := Rectangle origin: origin extent: extent.	^elementBox		expandedBy: (aVisualPart preferredExtent - elementBox extent max: 0) half				truncated</body></methods><methods><class-id>Store.PreReadActionConfirmation</class-id> <category>constants</category><body package="Store-Base">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="Store-Base">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.PreReadActionConfirmation</class-id> <category>private - actions</category><body package="Store-Base">defaultAction		^Dialog confirm: (#PreReadActionFor1IledNttttContinue &lt;&lt; #store &gt;&gt; 'Pre-read action for &lt;1s&gt; failed.&lt;ntttt&gt;Continue?' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.Glorp.StoreClassEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">at: aBinding ifAbsent: aBlock	^environment at: aBinding asString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI">bindingReferencesDo: aBlock	environment bindingReferencesDo: aBlock</body><body package="StoreForGlorpBrowserUI">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI">includesClass: aClass 	^(aClass isMeta		ifTrue: [classBehaviorNames includes: aClass fullRootName]		ifFalse: [instanceBehaviorNames includes: aClass fullRootName])			and: [environment includesClass: aClass mainClass]</body><body package="StoreForGlorpBrowserUI">navigatorClass		^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body><body package="StoreForGlorpBrowserUI">pundles	^environment pundles</body><body package="StoreForGlorpBrowserUI">repositoryName	^environment repositoryName</body><body package="StoreForGlorpBrowserUI">sharedVariable: aName for: aClassOrNameSpace	^environment sharedVariable: aName for: aClassOrNameSpace asString</body><body package="StoreForGlorpBrowserUI">sharedVariableProtocolsFor: aClass	^environment sharedVariableProtocolsFor: aClass</body><body package="StoreForGlorpBrowserUI">sharedVariableReferencesDo: aBlock 	self bindingReferencesDo: 		[:each | 		| binding |		binding := each bindingOrNil.		(binding notNil and: [binding isForSharedVariable and: [binding isInClass]]) ifTrue: [aBlock value: each]]</body><body package="StoreForGlorpBrowserUI">sharedVariablesFor: aProtocol in: aClassOrNameSpace	^environment sharedVariablesFor: aProtocol in: aClassOrNameSpace</body><body package="StoreForGlorpBrowserUI">sharedVariablesForClass: aClass 	^environment sharedVariablesForClass: aClass</body><body package="StoreForGlorpBrowserUI">whichProtocolIncludesVariable: aSymbol in: aClass	| result |	result := self pundles first sharedVariables 		detect: [:each | each absoluteOwnerName asString = aClass longName and: [each name = aSymbol]]		ifNone: [^nil].	^result protocol</body></methods><methods><class-id>Store.Glorp.StoreClassEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI">classForName: aString ifAbsent: aBlock	"We may sometimes hand out object name wrappers but should always receive full names back from our navigator and state.  (Our code assumes that aBlock will either return or answer something that responds to #objectNamed:)"	self pundles do: [:each | (each objectNamed: aString) ifNotNil: [:theClass | ^theClass]].	^aBlock value</body><body package="StoreForGlorpBrowserUI">classesDo: aBlock 	instanceBehaviorNames do: 			[:each | 			| class |			class := environment classForName: each.			(class notNil and: [environment includesClass: class]) 				ifTrue: [aBlock value: class]].	classBehaviorNames do: 			[:each | 			| class |			class := environment classForName: each.			(class notNil and: [environment includesClass: class storeMetaClass]) 				ifTrue: [aBlock value: class storeMetaClass]]</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>aspects</category><body package="Store-UI">afterDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^afterDate isNil		ifTrue:			[afterDate := (Core.Date readFromString: '3/10/2010') asValue]		ifFalse:			[afterDate]</body><body package="Store-UI">afterDateCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^afterDateCheck isNil		ifTrue:			[afterDateCheck := false asValue]		ifFalse:			[afterDateCheck]</body><body package="Store-UI">beforeDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^beforeDate isNil		ifTrue:			[beforeDate := (Core.Date readFromString: '3/10/2010') asValue]		ifFalse:			[beforeDate]</body><body package="Store-UI">beforeDateCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^beforeDateCheck isNil		ifTrue:			[beforeDateCheck := false asValue]		ifFalse:			[beforeDateCheck]</body><body package="Store-UI">blessingGreaterThan	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingGreaterThan isNil		ifTrue:			[blessingGreaterThan := nil asValue]		ifFalse:			[blessingGreaterThan]</body><body package="Store-UI">blessingGreaterThanCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingGreaterThanCheck isNil		ifTrue:			[blessingGreaterThanCheck := false asValue]		ifFalse:			[blessingGreaterThanCheck]</body><body package="Store-UI">blessingLessThan	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLessThan isNil		ifTrue:			[blessingLessThan := nil asValue]		ifFalse:			[blessingLessThan]</body><body package="Store-UI">blessingLessThanCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLessThanCheck isNil		ifTrue:			[blessingLessThanCheck := false asValue]		ifFalse:			[blessingLessThanCheck]</body><body package="Store-UI">blessingMenu	^Policies blessingPolicy blessingLevelsMenu</body><body package="Store-UI">nameLikeCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameLikeCheck isNil		ifTrue:			[nameLikeCheck := false asValue]		ifFalse:			[nameLikeCheck]</body><body package="Store-UI">pundleName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleName isNil		ifTrue:			[pundleName := String new asValue]		ifFalse:			[pundleName]</body><body package="Store-UI">versionLike	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^versionLike isNil		ifTrue:			[versionLike := String new asValue]		ifFalse:			[versionLike]</body><body package="Store-UI">versionLikeCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^versionLikeCheck isNil		ifTrue:			[versionLikeCheck := false asValue]		ifFalse:			[versionLikeCheck]</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>actions</category><body package="Store-UI">enableAfterDate	(self widgetAt: #AfterDate) isEnabled: self afterDateCheck value</body><body package="Store-UI">enableBeforeDate	(self widgetAt: #BeforeDate) isEnabled: self beforeDateCheck value</body><body package="Store-UI">enableBlessingGreater	(self widgetAt: #BlessingGreaterThan) isEnabled: self blessingGreaterThanCheck value</body><body package="Store-UI">enableBlessingLess	(self widgetAt: #BlessingLessThan) isEnabled: self blessingLessThanCheck value</body><body package="Store-UI">enablePundleName	(self widgetAt: #PundleName) isEnabled: self nameLikeCheck value</body><body package="Store-UI">enableVerionLike	(self widgetAt: #VersionLike) isEnabled: self versionLikeCheck value</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>private</category><body package="Store-UI">fillFilter	filter ifNil: [filter := DeletionToolFilter new].	filter pundleName: (self nameLikeCheck value ifTrue: [self pundleName value]).	filter versionLike: (self versionLikeCheck value ifTrue: [self versionLike value]).	filter beforeDate: (self beforeDateCheck value ifTrue: [self beforeDate value]).	filter afterDate: (self afterDateCheck value ifTrue: [self afterDate value]).	filter blessingGreater: (self blessingGreaterThanCheck value ifTrue: [self blessingGreaterThan value]).	filter blessingLess: (self blessingLessThanCheck value ifTrue: [self blessingLessThan value])</body><body package="Store-UI">fillFrom: aDeletionToolFilter	filter := aDeletionToolFilter.	filter pundleName ifNotNil:		[self pundleName value: filter pundleName.		self nameLikeCheck value: true].	filter versionLike ifNotNil:		[self versionLike value: filter versionLike.		self versionLikeCheck value: true].	filter beforeDate ifNotNil:		[self beforeDate value: filter beforeDate.		self beforeDateCheck value: true].	filter afterDate ifNotNil:		[self afterDate value: filter afterDate.		self afterDateCheck value: true].	filter blessingGreater ifNotNil:		[self blessingGreaterThan value: filter blessingGreater.		self blessingGreaterThanCheck value: true].	filter blessingLess ifNotNil:		[self blessingLessThan value: filter blessingLess.		self blessingLessThanCheck value: true].</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>accessing</category><body package="Store-UI">filter	^filter</body><body package="Store-UI">filter: aDeletionToolFilter	filter := aDeletionToolFilter</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>interface opening</category><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self afterDateCheck onChangeSend: #enableAfterDate to: self.	self beforeDateCheck onChangeSend: #enableBeforeDate to: self.	self blessingGreaterThanCheck onChangeSend: #enableBlessingGreater to: self.	self blessingLessThanCheck onChangeSend: #enableBlessingLess to: self.	self nameLikeCheck onChangeSend: #enablePundleName to: self.	self versionLikeCheck onChangeSend: #enableVerionLike to: self.	self accept onChangeSend: #fillFilter to: self.	self fillFrom: filter</body></methods><methods><class-id>Store.ClassTag</class-id> <category>testing</category><body package="Store-Change Management">belongsToClass	^true</body><body package="Store-Change Management">existsInImage	^self actualClass notNil</body><body package="Store-Change Management">isClassTag	^true</body><body package="Store-Change Management">isForClass	^true</body><body package="Store-Change Management">isInClass	^true</body></methods><methods><class-id>Store.ClassTag</class-id> <category>private-loading</category><body package="Store-Change Management">applyDefinitionFrom: aRecord 	"Load the new class from a definition contained in 	aRecord.	Return true is the operation is successful."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body><body package="Store-Change Management">canLoad	"Answer true if a record with my tag 	can be load into the image. 	For class definition it is always true."	^self isMeta		ifTrue: [super canLoad]		ifFalse: [true]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>accessing</category><body package="Store-Change Management">containingPackage	"Answer a packge that contians the 	defintion described by me."	"(ClassCommentTag newClassName: 'MethodTag class') 	containingPackage"	^Registry containingPackageForClassNamed: self className</body><body package="Store-Change Management">description	^'class definition'</body><body package="Store-Change Management">name	^self className</body><body package="Store-Change Management">sourceTextForImage	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl definition]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>actions</category><body package="Store-Change Management">compileText: someText from: aController 	"Compile new source for this tag.  Return True if	sucessful and False on failure."	| actualClass changedClass |	actualClass := self actualClass.	actualClass isNil ifTrue: [actualClass := nil class].	Cursor execute showWhile: [changedClass := actualClass evaluatorClass "subclassDefinerClass"					evaluate: someText string					notifying: aController					logged: true].	^changedClass ~~ nil</body><body package="Store-Change Management">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	actual notNil		ifTrue: [XChangeSet current				moveClassDefinition: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	"Remove the receiver's definition from the image if aPackage owns it. If tolerantBoolean is false, 	display an error if the definition doesn't exist."	| cls |	cls := self actualClass.	cls isNil 		ifTrue: 			[tolerantBoolean 				ifFalse: 					[self error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') 								expandMacrosWith: self className)]]		ifFalse: 			[(aPackage hasDefinitionFor: cls) 				ifTrue: [Override unloadClassOrNameSpace: cls from: aPackage]]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>change list support</category><body package="Store-Change Management">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseClass: self actualClass.</body><body package="Store-Change Management">fileOutObjectType	^#class</body><body package="Store-Change Management">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self actualClass ) == nil		ifFalse:  [ obj fileOutDefinitionOn: aStream ]</body><body package="Store-Change Management">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutDefinitionOn: aStream.</body><body package="Store-Change Management">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	self isMeta		ifFalse: [ aStream removeObject: symbol type: self fileOutObjectType ]</body><body package="Store-Change Management">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'class definition'</body></methods><methods><class-id>Store.ClassTag</class-id> <category>converting</category><body package="Store-Change Management">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForClassTag: self.</body></methods><methods><class-id>Store.ClassTag class</class-id> <category>accessing</category><body package="Store-Change Management">tagBaseIndex	^1		"also reserves 5 for metaclass"</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>initialize-release</category><body package="Store-Merge Management">doInitialExpansion	self list list isEmpty		ifTrue: [^self].	self contractAll.	self expandUnresolved.	self treeModel size &gt; self policyMaxListSize		ifTrue: [^self].	mergeTool resolutionManager totalResolutionItems &lt;= self policyMaxListSize		ifTrue: [^self treeModel expandToLevel: 2].	self treeModel expandToLevel: 1.	self treeModel size &gt; self policyMaxListSize		ifTrue:			[self contractAll.			^self expandUnresolved].</body><body package="Store-Merge Management">release	oldTree := list list.	super release.</body><body package="Store-Merge Management">reset	root := mergeTool resolutionManager.	self list list: TreeModel new.</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>private</category><body package="Store-Merge Management">buildResolutionsTree	| model |	self setListWidgetDisplayStringSelector.	model := TreeModel 		on: root		displayRoot: false		childrenWith: [:item | item sortedTreeResolutionValues: mergeTool show]		testHasChildrenWith: [:item | (item sortedTreeResolutionValues: mergeTool show) notEmpty].	self list list: model</body><body package="Store-Merge Management">contractAll	| i |	i := 1.	[i &lt; list list size]		whileTrue:			[self list list contractFully: i.			i := i + 1].</body><body package="Store-Merge Management">expandAll	self list list isEmpty		ifTrue: [^self].	self list list expandToLevel: 4.</body><body package="Store-Merge Management">expandTree: aTree for: anObject 	"This method replaces TreeModel&gt;&gt;expandFound: except it does not	select a found index"	| path |	path := aTree pathToObject: anObject.	path isEmpty ifTrue: [^false].	path do: 		[:each | 		aTree expand: (aTree indexOf: each)].	^true</body><body package="Store-Merge Management">expandTree: aTreeModel toCorrespondTo: anotherTreeModel		| same |	same := true.	anotherTreeModel do: [:each | each openedChildren ifTrue: [same := (self expandTree: aTreeModel for: each value) and: [same]]].	^same</body><body package="Store-Merge Management">expandUnresolved		| index |	index := 1.	[self treeModel size &gt;= index]		whileTrue:			[(self treeModel at: index) isResolved ifFalse: [self treeModel expand: index].			index := index + 1]</body><body package="Store-Merge Management">policyMaxListSize	^Policies mergePolicy mergeToolMaxInitialTreeSize</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>updating</category><body package="Store-Merge Management">finishOpening		self list list isEmpty ifTrue: [^self].	self list list expandToLevel: 1</body><body package="Store-Merge Management">showCodeDifferences	mergeTool showCodeDifferences.</body><body package="Store-Merge Management">showSourceDifferences	mergeTool showSourceDifferences.</body><body package="Store-Merge Management">updateResolutions	oldTree := nil.	root := mergeTool resolutionManager.	self buildResolutionsTree.</body><body package="Store-Merge Management">updateResolutionsWithoutRebuild	| selection |	selection := mergeTool selectedResolution.	oldTree := nil.	list list expandFound: selection.	self widget invalidate</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>accessing</category><body package="Store-Merge Management">mergeTool: aMergeTool	super mergeTool: aMergeTool.	root := aMergeTool resolutionManager</body><body package="Store-Merge Management">tabLabel	^(#ModificationHierarchy &lt;&lt; #store &gt;&gt; 'Modification Hierarchy') asString</body><body package="Store-Merge Management">treeModel	^self list list</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>aspects</category><body package="Store-Merge Management">list	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^list isNil		ifTrue:			[list := SelectionInTree new]		ifFalse:			[list]</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>name style</category><body package="Store-Merge Management">setShowLongNames	nameStyle := #longTreeName.</body><body package="Store-Merge Management">setShowShortNames	nameStyle := #shortTreeName.</body></methods><methods><class-id>Store.ResolutionsTreePane class</class-id> <category>accessing</category><body package="Store-Merge Management">tabLabel	^(#ModificationHierarchy &lt;&lt; #store &gt;&gt; 'Modification Hierarchy') asString</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">comment	^storeObject comment</body><body package="Atomic Compiling and Loading">isExternalInterface: aBoolean	isExternalInterface := aBoolean</body><body package="Atomic Compiling and Loading">longName	^longName</body><body package="Atomic Compiling and Loading">superclassName	^superclassName</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	aStream nextPutAll: 'aShadowedClass('.	aStream nextPutAll: self longName.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading">compileWith: anAtomicAnalysisLoader	[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDefinedRecord: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader addUnloadableDefinition: (exception definitionRecord: self).			exception resume]]				on: RedefinitionNotification				do: 					[:notification |					anAtomicAnalysisLoader collectRedefinedClasses: notification override.					anAtomicAnalysisLoader overrides add: notification.					override := true.					notification resume]</body><body package="Atomic Compiling and Loading">gatherInto: anAtomicAnalysisLoader	anAtomicAnalysisLoader addAllClasses: (Array with: self).</body><body package="Atomic Compiling and Loading">installWith: anAtomicAnalysisLoader	[anAtomicAnalysisLoader installClass: self]		on: RedefinitionNotification		do: 			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			(currentPackage notNil and: 				[self packageModel name = currentPackage name or: 				[currentPackage name = Registry nullPackageName]]) 					ifFalse: 						[anAtomicAnalysisLoader collectRedefinedClasses: notification override.						notification override install.						anAtomicAnalysisLoader overrides add: notification].			notification resume]</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isExternalInterface	^isExternalInterface</body><body package="Atomic Compiling and Loading">isForClass	^true</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initializeFrom: aStoreClassDefinitionInPackage	super initializeFrom: aStoreClassDefinitionInPackage.	longName := aStoreClassDefinitionInPackage longName.	superclassName := aStoreClassDefinitionInPackage superclassName.</body></methods><methods><class-id>Store.Glorp.StoreBundlePackageRelationship</class-id> <category>accessing</category><body package="Store-Database Model">bundleID		^bundleID</body><body package="Store-Database Model">bundleID: anObject		bundleID := anObject</body><body package="Store-Database Model">expressionID		^expressionID</body><body package="Store-Database Model">expressionID: anObject		expressionID := anObject</body><body package="Store-Database Model">packageID		^packageID</body><body package="Store-Database Model">packageID: anObject		packageID := anObject</body><body package="Store-Database Model">sequence		^sequence</body><body package="Store-Database Model">sequence: anObject		sequence := anObject</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>accessing</category><body package="Store-Difference Management">classListName	| dottedName start |	dottedName := otherObject 		ifNil: [mainObject longNameFromSmalltalk]		ifNotNil: [otherObject longNameFromSmalltalk].	start := dottedName lastIndexOf: $..	start = 0 ifTrue: [^dottedName].	^dottedName copyFrom: 1 to: start - 1</body><body package="Store-Difference Management">differenceName	^otherObject 		ifNil: [mainObject longNameFromSmalltalk]		ifNotNil: [otherObject longNameFromSmalltalk].</body><body package="Store-Difference Management">mainClassStoreObject	^mainObject</body><body package="Store-Difference Management">mainDefinition	^(mainObject isNil		ifTrue: [self notDefinedInThisPackage]		ifFalse: [mainObject]) asText</body><body package="Store-Difference Management">mainPackage: aPackage shared: aStoreSharedVariable	self mainPackage: aPackage object: aStoreSharedVariable</body><body package="Store-Difference Management">mainProtocol	^''</body><body package="Store-Difference Management">otherClassStoreObject	^otherObject</body><body package="Store-Difference Management">otherDefinition	^(otherObject isNil		ifTrue: [self notDefinedInThisPackage]		ifFalse: [otherObject]) asText</body><body package="Store-Difference Management">otherPackage: aPackage shared: aStoreSharedVariable	self otherPackage: aPackage object: aStoreSharedVariable</body><body package="Store-Difference Management">otherProtocol	^''</body><body package="Store-Difference Management">resolutionClass	^SharedChangeResolver</body><body package="Store-Difference Management">selectorListIcon	^VisualStack with: BehaviorIcons Object with: BehaviorIcons SharedVariableOverlay</body><body package="Store-Difference Management">selectorListName	^otherObject 		ifNil: [mainObject name]		ifNotNil: [otherObject name]</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	mainObject fileOutSourceOn: aStream</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	otherObject fileOutSourceOn: aStream</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>testing</category><body package="Store-Difference Management">isForSharedVariable	^true</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>loading</category><body package="Store-Difference Management">loadMainDefinitionFrom: aStoreClassOrNamespaceOrNil		Store.Policies packagePolicy		forcePackage: mainPackage storeModel		while:			[mainObject loadSource.			mainObject correspondingImageBinding ifNotNil: 				[:value | 				(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]]</body><body package="Store-Difference Management">loadOtherDefinitionFrom: aStoreClassOrNamespaceOrNil	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: 			[otherObject loadSource.			otherObject correspondingImageBinding ifNotNil: 				[:value | 				(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]]</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>user interface</category><body package="Store-Difference Management">askToReinitializeSharedVariable: aVariableBinding		^ReInitializeSharedVariableNotification raiseRequestWith: aVariableBinding</body></methods><methods><class-id>Store.PseudoSharedDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management">mainPackage: aPackage shared: aStoreSharedVariable	| instance |	instance := self new.	^instance		mainPackage: aPackage shared: aStoreSharedVariable;		yourself</body><body package="Store-Difference Management">otherPackage: aPackage shared: aStoreSharedVariable	| instance |	instance := self new.	^instance		otherPackage: aPackage shared: aStoreSharedVariable;		yourself</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>accessing</category><body package="Store-Database Model">addClassDefinition: aClass	"Add the class to the package "	^classDefinitions add: (StoreClassDefinitionInPackage newFor: aClass package: self).</body><body package="Store-Database Model">addMethod: aMethod	^methods add: (StoreMethodInPackage newFor: aMethod package: self)</body><body package="Store-Database Model">addNameSpace: aNameSpace	^nameSpaces add: (StoreNamespaceInPackage newFor: aNameSpace package: self).</body><body package="Store-Database Model">addSharedVariable: aSharedVariable	^sharedVariables add: (StoreSharedVariableInPackage newFor: aSharedVariable package: self)</body><body package="Store-Database Model">addUninstalledClassDefinition: aClass	"Add the class to the package "	^classDefinitions add: (StoreClassDefinitionInPackage newForUninstalled: aClass package: self).</body><body package="Store-Database Model">allContainedItems	^#().</body><body package="Store-Database Model">allNameSpaces	^nameSpaces</body><body package="Store-Database Model">allParents	^#().</body><body package="Store-Database Model">allSubApplications	^#().</body><body package="Store-Database Model">basicParcel	^parcel</body><body package="Store-Database Model">basicParcel: aStoreBlob	parcel := aStoreBlob.</body><body package="Store-Database Model">binFile	^binFile</body><body package="Store-Database Model">binFile: anObject	binFile := anObject</body><body package="Store-Database Model">binaryVersion	"You'd think this could just be ^parcel, but trying to get rid of any proxy and actually return nil if there isn't one"	^parcel isNil ifTrue: [nil] ifFalse: [parcel].</body><body package="Store-Code Comparison">bindingBlueprints	^self classBlueprints , self namespaceBlueprints		, self sharedVariableBlueprints</body><body package="Store-Code Comparison">classBlueprints	| output |	output := Array new writeStream.	self classDefinitions do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model">classDefinitions	^classDefinitions</body><body package="Store-Database Model">classes	^classDefinitions</body><body package="Store-Database Model">classesDefinedInPackage	^self definedClasses.</body><body package="Store-Database Model">classesWithSource	^fullClasses ifNil: [#()].</body><body package="Store-Database Model">containedItems	^#().</body><body package="Store-Database Model">data	^sharedVariables.</body><body package="Store-Database Model">dataWithSource	^sharedVariables.</body><body package="Store-Database Model">datum: aSymbol forNamed: aString	| stringKey |	stringKey := aSymbol asString.	^(self sharedVariables detect: [:each |		each name = stringKey and: [			each definition environmentName = aString]]		ifNone: [nil])</body><body package="Store-Database Model">defined	^self definedClasses.</body><body package="Store-Database Model">definedClasses	^self fullClasses select: [:each | each classDefinition notNil].</body><body package="Store-Database Model">definesClass: aStoreClass	^self definedClasses contains: [:each | each absoluteName = aStoreClass absoluteName]</body><body package="Store-Database Model">definesClassNamed: aString	^self classDefinitions contains: [:each | each absoluteName = aString]</body><body package="Store-Database Model">definesObject: aStoreNameSpace	^nameSpaces anySatisfy: [:each | each absoluteName = aStoreNameSpace absoluteName]</body><body package="Store-Database Model">descriptionsAndLevels	"Answer a collection of pairs. The first element is the description	the second is level (zero)."	^OrderedCollection with: (Array with: self with: 1)</body><body package="Store-Database Model">emptyChangeSet	"We will get this if we are being used as part of a dbInfo in order to fake out Store loading into using us instead of the database. Ignore this message, as we will do this when we rebuild the proper database info later"	^self.</body><body package="Store-Database Model">environment	| environmentName |	environmentName := self propertyAt: #namespace ifAbsent: [^nil].	^environmentName asQualifiedReference valueOrDo: [nil].</body><body package="Glorp Atomic Compiling">environmentFor: aSelector in: aClass	"Return the environment for the method in question (which we assume we own). If we should not define its scope, return nil"		(self includesDefinitionOf: aClass instanceBehavior absoluteName) ifTrue: [^nil].	^self environment</body><body package="Store-Database Model">extended	^self extendedClasses.</body><body package="Store-Database Model">extendedClasses	^self fullClasses select: [:each | each classDefinition isNil].</body><body package="Store-Database Model">hasSubApplications	^false.</body><body package="Store-Database Model">isRemoved	^false.</body><body package="StoreForGlorpVWUI">itemCount	(methods isGlorpProxy and: [methods isInstantiated not]) ifTrue: [^1].	^methods size + classDefinitions size + nameSpaces size + sharedVariables size.</body><body package="StoreForGlorpVWUI">leafItems	^Array with: self.</body><body package="Store-Database Model">metaclassesDefinedInPackage	^self definedClasses collect: [:each | each classDefinition metaclass].</body><body package="Store-Code Comparison">methodBlueprints	| output |	output := Array new writeStream.	self methods do: 			[:each |			| blueprint |			blueprint := MethodBlueprint of: each.			blueprint				classReference: each className asQualifiedReference;				selector: each selector;				isInstanceBehavior: each isMeta not;				source: each sourceCode;				category: each protocol;				package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model">methodDefinitions	^methods</body><body package="Store-Database Model">methods	^methods</body><body package="Store-Database Model">methodsForClass: aClass meta: aBoolean	^aBoolean 		ifTrue: [methods select: [:each | each absoluteClassName = (aClass absoluteClassName, ' class')]]		ifFalse: [methods select: [:each | each absoluteClassName = aClass absoluteClassName]]</body><body package="Store-Database Model">methodsWithSource	^methods</body><body package="Store-Database Model">nameSpaceDefinitions	^self nameSpaces asSortedCollection collect: [:each | each nameSpaceDefinition]</body><body package="Store-Database Model">nameSpaces	^nameSpaces</body><body package="Store-Database Model">nameSpacesDefinedInPackage	^nameSpaces</body><body package="Store-Database Model">nameSpacesWithSource	^nameSpaces</body><body package="Store-Code Comparison">namespaceBlueprints	| output |	output := Array new writeStream.	self namespaces do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model">namespaces	^nameSpaces</body><body package="Store-Database Model">parcel	self basicParcel yourSelf isNil ifTrue: [^nil].	^self basicParcel binaryData</body><body package="Store-Database Model">parcelID	^parcel isNil ifTrue: [nil] ifFalse: [parcel primaryKey].</body><body package="Store-Difference Management">pseudoPundleClass	^Store.PseudoPackage</body><body package="Store-Database Model">rootApplication	^self.</body><body package="Store-Database Model">setName	"This will be sent if we are part of the dbInfo for a component while loading. Ignore it, because we're going to replace ourselves with a valid ComponentDescription later."	^self.</body><body package="Store-Code Comparison">sharedVariableBlueprints	| output |	output := Array new writeStream.	self sharedVariableDefinitions do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model">sharedVariableDefinitions	^sharedVariables</body><body package="Store-Database Model">sharedVariables	^sharedVariables</body><body package="Store-Database Model">sharedVariablesForClass: aStoreClass	^sharedVariables select: [:each | each absoluteOwnerName asString = aStoreClass longName]</body><body package="Store-Database Model">sharedVariablesForNamespaceNamed: aString	^sharedVariables select: [:each | each absoluteOwnerName asString = aString]</body><body package="Store-Database Model">signature	^self name, '(', self version, ')'.</body><body package="Store-Database Model">subApplications	^#().</body><body package="Store-Database Model">withContainedItems	^(OrderedCollection with: self).</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>testing</category><body package="Store-Database Model">definesClassOrNameSpace: aClassOrNameSpace	^(self classDefinitions, self nameSpaces) anySatisfy: [:each | each fullName = aClassOrNameSpace fullName].</body><body package="Store-Database Model">definesName: key in: nameSpace	^true</body><body package="Store-Database Model">definesSelector: aString forClass: aStoreClassExtension 	^(aStoreClassExtension instanceMethods 		detect: [:each | each selector = aString]		ifNone: [nil]) notNil</body><body package="StoreForGlorpVWUI">describesPackageNamed: aString	"Answer true if the description referes to a package named aString"	^self name = aString</body><body package="Store-Database Model">hasExtensions	"Return true if we extend a class or namespace we don't contain."	^(self fullClasses detect: [:each | each classDefinition isNil] ifNone: [nil]) notNil.</body><body package="Store-Database Model">hasRelatedParcel	^(parcel == nil) not</body><body package="Store-Database Model">hasRelatedParcelIn: aSession	^(parcel == nil) not</body><body package="Store-Database Model">includesClassNamed: aName	^(self classInPackageNamed: aName meta: false) notNil.</body><body package="Store-Database Model">includesDataKey: dataKey owner: owner	^self includesDataKey: dataKey ownerName: owner absoluteName.</body><body package="Store-Database Model">includesDataKey: dataKey ownerName: environmentName	| stringKey |	stringKey := dataKey asString.	^(self sharedVariables detect: [:each |		each name = stringKey and: [			each definition environmentName = environmentName]]		ifNone: [nil]) notNil.</body><body package="Store-Database Model">includesDatum: aDatumDescriptor	^self includesDataKey: aDatumDescriptor dataKey ownerName: aDatumDescriptor absoluteOwnerName.</body><body package="Store-Database Model">includesDefinitionOf: aName  	^( self includesClassNamed: aName ) or: [ self includesNameSpaceNamed: aName ]</body><body package="Store-Database Model">includesMethod: aMethodDescription	^self includesSelector: aMethodDescription selector className: aMethodDescription absoluteClassName asClassNameOnly meta: aMethodDescription isMeta</body><body package="Store-Database Model">includesNameSpaceNamed: aName	^(self namespaces detect: [:each | each name = aName] ifNone: [nil]) notNil.</body><body package="Store-Database Model">includesSelector: aSelector class: aClass	^self includesSelector: aSelector asString className: aClass absoluteName asClassNameOnly meta: aClass isMeta.</body><body package="Store-Database Model">includesSelector: aSelector className: aClassName meta: isMeta	| fullClass |	fullClass := self fullClasses at: aClassName ifAbsent: [^false].	isMeta ifTrue: [fullClass := fullClass storeMetaClass].	^fullClass includesSelector: aSelector asString.</body><body package="Store-Database Model">isPublishedBinary	^self hasRelatedParcel</body><body package="Store-Database Model">isValid	(methods collect: [:each | each definition]) asSet size = methods size ifFalse: [^false].	(methods anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(classDefinitions anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(nameSpaces anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(sharedVariables anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(sharedVariables collect: [:each | each definition]) asSet size = sharedVariables size ifFalse: [^false].	^true.</body><body package="Store-Database Model">method: aSelector forClassNamed: aClassName meta: isMeta		| fullClass |	(methods isGlorpProxy and: [methods isInstantiated not]) &amp; fullClasses isNil		ifTrue:			[| query |			query := Query				readOneOf: StoreMethodInPackage				where:					[:each | 					each package = self &amp; (each definition name = aSelector)						&amp; (each definition className = aClassName | (each definition className = (aClassName , ' class'))) &amp; (each definition isMetaclass = isMeta)].			query alsoFetch: [:each | each definition].			query alsoFetch: [:each | each definition source].			^session execute: query]		ifFalse:			[fullClass := self fullClasses at: aClassName ifAbsent: [self fullClasses at: aClassName asClassNameOnly ifAbsent: [^nil]].			isMeta ifTrue: [fullClass := fullClass storeMetaClass].			^fullClass compiledMethodAt: aSelector asString ifAbsent: [nil]]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>full classes</category><body package="Store-Database Model">fullClassForClass: aStoreClassDefinitionInPackage	"Private - this constructs the class definition part of a full class"	| fullClass |	fullClasses ifNil: [self fullClasses].	fullClass := fullClasses at: aStoreClassDefinitionInPackage longName ifAbsentPut: [		StoreClassExtension new 			name: aStoreClassDefinitionInPackage name;			longName: aStoreClassDefinitionInPackage longName;			package: self].	fullClass classDefinition: aStoreClassDefinitionInPackage.	^fullClass.</body><body package="Store-Database Model">fullClassForMethod: aStoreMethodInPackage	"Private - this adds the method to the full class in question"	| fullClass |	fullClasses ifNil: [fullClasses := Dictionary new].	fullClass := fullClasses at: aStoreMethodInPackage className ifAbsentPut: [		StoreClassExtension new 			longName: aStoreMethodInPackage className;			package: self].	fullClass addMethod: aStoreMethodInPackage.	^aStoreMethodInPackage isMeta		ifTrue: [fullClass classBehavior]		ifFalse: [fullClass]</body><body package="Store-Database Model">fullClassNamed: aString	^self fullClasses at: aString ifAbsent: [nil].</body><body package="Store-Database Model">fullClassNamed: aString fromMethods: methodList classDefinition: aClassDefinition	"Given that we already have the methods, so we don't have to read them, construct the class extension"	"Note that aString is the completely, ridiculously qualified name. e.g. Root.Smalltalk.Object"	| |	fullClasses isNil ifTrue: [fullClasses := Dictionary new].	fullClasses isEmpty ifFalse: [^fullClasses at: aString ifAbsent: [nil]].	methodList do: [:each | self fullClassForMethod: each].	aClassDefinition isNil 		ifTrue: [	"If the class had not methods, and we don't have a class definition, then there's no class, just return nil. Otherwise, make sure we know the class definition is explicitly nil"			(fullClasses at: aString ifAbsent: [^nil]) classDefinition: aClassDefinition]		ifFalse: [self fullClassForClass: aClassDefinition].	^fullClasses at: aString ifAbsent: [nil].</body><body package="Store-Database Model">fullClasses	(fullClasses isNil or: [fullClasses isEmpty]) ifTrue: [		fullClasses := Dictionary new.		methods isNil ifFalse: [methods do: [:each | self fullClassForMethod: each]].		classDefinitions isNil ifFalse: [classDefinitions do: [:each | self fullClassForClass: each]]].	^fullClasses.</body><body package="Store-Database Model">fullClasses: aCollection	fullClasses := (aCollection isKindOf: Dictionary)		ifTrue: [aCollection]		 ifFalse: [				| dict |			dict := Dictionary new.			aCollection do: [:each | dict at: each name put: each].			dict].</body><body package="Store-Database Model">fullClassesDetect: aBlock ifFound: foundBlock	^self fullClasses detect: aBlock ifFound: foundBlock</body><body package="Store-Database Model">nameSpacesDetect: aBlock ifFound: foundBlock	^self nameSpaces detect: aBlock ifFound: foundBlock</body><body package="Store-Database Model">objectNamed: aString	self fullClasses at: aString ifPresent: [:item | ^item].	self nameSpacesDetect: [:each | each longName = aString] ifFound: [:item | ^item].	self sharedVariablesDetect: [:each | each longName = aString] ifFound: [:item | ^item].	^nil</body><body package="Store-Database Model">resetFullClasses	fullClasses := nil</body><body package="Store-Database Model">sharedVariablesDetect: aBlock ifFound: foundBlock	^self sharedVariables detect: aBlock ifFound: foundBlock</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>reconciling</category><body package="Store-Database Model">basicReconcileClassDefinition: aStoreClassDefinition	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous classDefinitions		detect: [:each | aStoreClassDefinition reconcilesWith: each definition]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch definition].</body><body package="Store-Database Model">basicReconcileMetaClassDefinition: aStoreClassDefinition	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous classDefinitions		detect: [:each | aStoreClassDefinition reconcilesWith: each metaclass]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch metaclass].</body><body package="Store-Database Model">basicReconcileMethod: aStoreMethod with: anotherStoreMethodOrNil	self previous isNil ifTrue: [^nil].	anotherStoreMethodOrNil isNil ifTrue: [^nil].		^(aStoreMethod reconcilesWith: anotherStoreMethodOrNil)		ifTrue: [anotherStoreMethodOrNil]		ifFalse: [nil].</body><body package="Store-Database Model">basicReconcileNameSpace: aStoreNameSpace	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous nameSpaces		detect: [:each | aStoreNameSpace reconcilesWith: each definition ]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch definition].</body><body package="Store-Database Model">basicReconcileSharedVariable: aSharedVariable	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous sharedVariables		detect: [:each | aSharedVariable reconcilesWith: each definition ]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch definition].</body><body package="Store-Database Model">matchesRecursivelyWith: aStorePundle	"Return true if all of our contents match"	^self matchesWith: aStorePundle.</body><body package="Store-Database Model">matchesWith: aStorePundle	"Return true if all of our contents match"	(self ifMatchesWith: aStorePundle do: [^true] else: [^false]).	self methods size = aStorePundle methods size ifFalse: [^false].	self methods asSortedCollection with: aStorePundle methods asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].	self classDefinitions size = aStorePundle classDefinitions size ifFalse: [^false].	self classDefinitions asSortedCollection with: aStorePundle classDefinitions asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].	self nameSpaces size = aStorePundle nameSpaces size ifFalse: [^false].	self nameSpaces asSortedCollection with: aStorePundle nameSpaces asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].	self sharedVariables size = aStorePundle sharedVariables size ifFalse: [^false].	self sharedVariables asSortedCollection with: aStorePundle sharedVariables asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].		^true.</body><body package="Store-Database Model">methodsCacheDictFor: prevMethodColl	| methodsDict |	methodsDict := ClassSelectorKeyDictionary new: prevMethodColl size * 4 // 3 + 10.	prevMethodColl do: 			[:each |			methodsDict				atClass: each definition classNameWithMeta				andSelector: each definition name asSymbol				put: each].	^methodsDict</body><body package="Store-Database Model">reconcile	"When we share source with our previous version, use it instead of our own"	super reconcile.	self removeDuplicates.	self reconcileMethods.	self reconcileClasses.	self reconcileNameSpaces.	self reconcileSharedVariables.	self reconcileParcel.</body><body package="Store-Database Model">reconcileClass: aStoreClassDefinition	| exactMatch previousVersion |	exactMatch := self basicReconcileClassDefinition: aStoreClassDefinition.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreClassDefinition previous: nil].	aStoreClassDefinition previous isNil 		ifTrue: [			previousVersion := self previous classDefinitionFor: aStoreClassDefinition.			previousVersion isNil ifFalse: [aStoreClassDefinition previous: previousVersion definition]]		ifFalse: [aStoreClassDefinition previous: (self previous basicReconcileClassDefinition: aStoreClassDefinition previous)].	^aStoreClassDefinition.</body><body package="Store-Database Model">reconcileClasses	self classDefinitions size = self previous classDefinitions size ifFalse: [self markModified].	classDefinitions do: [:each |		each definition: (self reconcileClass: each definition).		each metaclass: (self reconcileMetaClass: each metaclass)].</body><body package="Store-Database Model">reconcileMetaClass: aStoreClassDefinition	| exactMatch previousVersion |	exactMatch := self basicReconcileMetaClassDefinition: aStoreClassDefinition.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreClassDefinition previous: nil].	aStoreClassDefinition previous isNil 		ifTrue: [			previousVersion := self previous metaClassDefinitionFor: aStoreClassDefinition.			previousVersion isNil ifFalse: [aStoreClassDefinition previous: previousVersion definition]]		ifFalse: [aStoreClassDefinition previous: (self previous basicReconcileMetaClassDefinition: aStoreClassDefinition previous)].	^aStoreClassDefinition.</body><body package="Store-Database Model">reconcileMethod: aStoreMethod with: previousStoreMethodOrNil	| exactMatch |	exactMatch := self basicReconcileMethod: aStoreMethod with: previousStoreMethodOrNil.	exactMatch notNil ifTrue: [^exactMatch] ifFalse: [self markModified].	self previous isNil ifTrue: [^aStoreMethod previous: nil].	aStoreMethod previous isNil 		ifTrue: [previousStoreMethodOrNil notNil ifTrue: [aStoreMethod previous: previousStoreMethodOrNil]]		ifFalse: [			(aStoreMethod previous reconcilesWith: previousStoreMethodOrNil)				ifTrue: ["do nothing, already ok"]				ifFalse: [					"change the previous method to the one in the enclosing package's previous version"					"here is where we would do something special with 2 non-matching previous versions"					aStoreMethod previous: previousStoreMethodOrNil]].	^aStoreMethod.</body><body package="Store-Database Model">reconcileMethods	| previousMethodsDict |	self previous isNil ifTrue: [^self].	(self methods isEmpty and: [self previous methods isEmpty])		ifTrue: [^self].	methods size = self previous methods size ifFalse: [self markModified].	previousMethodsDict := self methodsCacheDictFor: self previous methods.	methods do: 			[:each |			| prevMethod prevDefinition |			prevMethod := previousMethodsDict						atClass: each definition classNameWithMeta						andSelector: each definition selector						ifAbsent: [nil].			prevDefinition := prevMethod notNil						ifTrue: [prevMethod definition]						ifFalse: [nil].			each definition: (self reconcileMethod: each definition with: prevDefinition)]</body><body package="Store-Database Model">reconcileNameSpace: aStoreNameSpace	| exactMatch previousVersion |	exactMatch := self basicReconcileNameSpace: aStoreNameSpace.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreNameSpace previous: nil].	aStoreNameSpace previous isNil 		ifTrue: [			previousVersion := self previous nameSpaceFor: aStoreNameSpace.			previousVersion isNil ifFalse: [aStoreNameSpace previous: previousVersion definition]]		ifFalse: [aStoreNameSpace previous: (self previous basicReconcileNameSpace: aStoreNameSpace previous)].	^aStoreNameSpace.</body><body package="Store-Database Model">reconcileNameSpaces	(self nameSpaces isEmpty and: [self previous nameSpaces isEmpty]) ifTrue: [^self].	self nameSpaces size = self previous nameSpaces size ifFalse: [self markModified].	nameSpaces do: [:each |		each definition: (self reconcileNameSpace: each definition)].</body><body package="Store-Database Model">reconcileParcel	self basicParcel = self previous basicParcel yourSelf		ifTrue: [parcel := self previous basicParcel]		 ifFalse: [self markModified].</body><body package="Store-Database Model">reconcileSharedVariable: aStoreSharedVariable	| exactMatch previousVersion |	exactMatch := self basicReconcileSharedVariable: aStoreSharedVariable.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreSharedVariable previous: nil].	aStoreSharedVariable previous isNil 		ifTrue: [			previousVersion := self previous sharedVariableFor: aStoreSharedVariable.			previousVersion isNil ifFalse: [aStoreSharedVariable previous: previousVersion definition]]		ifFalse: [aStoreSharedVariable previous: (self previous basicReconcileSharedVariable: aStoreSharedVariable previous)].	^aStoreSharedVariable.</body><body package="Store-Database Model">reconcileSharedVariables	(self sharedVariables isEmpty and: [self previous sharedVariables isEmpty]) ifTrue: [^self].	self sharedVariables size = self previous sharedVariables size ifFalse: [self markModified].	sharedVariables do: [:each |		each definition: (self reconcileSharedVariable: each definition)].</body><body package="Store-Database Model">unreconcile	"We have no previous version. Remove any references to it"	super unreconcile.	methods do: [:each | each unreconcile].	classDefinitions do: [:each | each unreconcile].	nameSpaces do: [:each | each unreconcile].	sharedVariables do: [:each | each unreconcile].</body><body package="Store-Database Model">unreconcileBlessings	" I don't believe that blessings are ever shared between versions"	blessings do: [:each | each unreconcile].</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>changes</category><body package="Store-Database Model">changedClassDefinitionsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #classes</body><body package="Store-Database Model">changedMethodsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #methods</body><body package="Store-Database Model">changedNameSpaceDefinitionsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #nameSpaces</body><body package="Store-Database Model">changedSharedVariableDefinitionsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #sharedVariables</body><body package="Store-Database Model">changesFrom: aStorePackage ofType: aSymbol 	"Return a collection of objects that don't occur in aStorePackage, but occurs in self."	| new existing |	new := OrderedCollection new.	existing := Set withAll: (aStorePackage perform: aSymbol).	(self perform: aSymbol) 		do: [:each | (existing includes: each) ifFalse: [new add: each]].	^new</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>loading</category><body package="Store-Database Model">applyLoadingPolicyAfterLoadErrors: unloadables	"Loading errors have occurred. Check out setting AbstractPundleLoader.LoadFailedOption 	and determine how to deal with them.	- #loadButNotify = Complete the load but open a tool to manage errors	- #load = Ignore errors and load what can be loaded	- #displayDialog = Open a dialog to ask what to do	- #fail = Load only if there are no errors"	| option |	(option := AbstractPundleLoader loadFailOption) = #load ifTrue: [^self].	option = #fail		ifTrue: [LoadCanceled raiseWith: self]		ifFalse: [ViewUnloadableDefinitionsNotification openOnExceptions: unloadables]</body><body package="Store-Database Model">binLoadWithin: parentBundle	"Supress unloadable code dialog in the intial load.	Handle redefininitions by short-circutting the bundle/package handler."	| packageModel record unloadable |	(record := self binaryVersion) ifNil: [^nil].	unloadable := OrderedCollection new.	packageModel := Registry packageNamed: name.	[[[packageModel isNil		ifTrue:			[packageModel := (Registry packageNamedOrCreate: name)				dbTrace: self primaryKey;				loadFrom: record using: CodeReader new;				yourself]		ifFalse: [packageModel updateFrom: record within: parentBundle]]			on: CodeReader requestWarningSuppressionSignal			do: [:exception | exception resume: true]]				on: RedefinitionNotification				do: [:notification | notification resume]]					on: self class imageClass fileFormatSignal					do: [:exception | exception return: nil].	packageModel ifNil: [^nil].	[self checkUninstalledClasses: packageModel]		on: UnloadableDefinitionError		do:			[:exception | 			exception package: packageModel.			unloadable add: exception.			exception resume].	unloadable isEmpty ifFalse:		[Store.ViewUnloadableDefinitionsNotification openOnExceptions: unloadable].	packageModel ifNotNil:		[packageModel			dbTrace: self primaryKey;			markNotModified].	^packageModel</body><body package="Store-Database Model">binLoadWithin: parentBundle using: aCompilationManager	"Supress unloadable code dialog in the intial load.	Handle redefininitions by short-circutting the bundle/package handler."	| packageModel record unloadable |	(record := self binaryVersion) ifNil: [^nil].	(Loading for: self) started.	unloadable := OrderedCollection new.	packageModel := Registry packageNamed: name.	[[[packageModel isNil		ifTrue:			[packageModel := (Registry packageNamedOrCreate: name)				loadFrom: record using: CodeReader new with: aCompilationManager;				yourself]		ifFalse: [packageModel updateFrom: record within: parentBundle]]			on: CodeReader requestWarningSuppressionSignal			do: [:exception | exception resume: true]]				on: RedefinitionNotification				do: [:notification | notification resume]]					on: self class imageClass fileFormatSignal					do: [:exception | exception return: nil].	packageModel ifNil: 		[(Loading for: self) finished.		^nil].	[self checkUninstalledClasses: packageModel]		on: UnloadableDefinitionError		do:			[:exception | 			exception package: packageModel.			unloadable add: exception.			exception resume].	unloadable isEmpty ifFalse: [self applyLoadingPolicyAfterLoadErrors: unloadable].	packageModel ifNotNil:		[ | databaseInformation |		databaseInformation := packageModel databaseInformationOrCreate.		packageModel			setDbTraceAndVersionUsing: self for: databaseInformation dbIdentifier;			markNotModified].	(Loading for: self) finished.	^packageModel</body><body package="Store-Database Model">checkUninstalledClasses: imgPackage	"Determine if there are any uninstalled classes or methods and deal with them appropriately."		| uninstalledClasses uninstalledMethods uninstalledBindings |	uninstalledClasses := imgPackage		propertyAt: #uninstalledClasses		ifAbsent: [OrderedCollection new].	uninstalledMethods := imgPackage		propertyAt: #uninstalledMethods		ifAbsent: [OrderedCollection new].	uninstalledBindings := imgPackage		propertyAt: #uninstalledBindings		ifAbsent: [OrderedCollection new].	(uninstalledMethods isEmpty and: [uninstalledClasses isEmpty and: [uninstalledBindings isEmpty]])		ifFalse: [self checkUninstalledClasses: uninstalledClasses methods: uninstalledMethods bindings: uninstalledBindings]</body><body package="Store-Database Model">checkUninstalledClasses: aCollectionOfClasses methods: aCollectionOfMethods bindings: aCollectionOfBindings	"Determine why the uninstalled can't be installed and display a message box informing the user.	Signal the unloadable exception for the browser."		| clsRecords methRecords dataRecords |	clsRecords := self classesNamed: (aCollectionOfClasses collect: [:each | each absoluteName]).	methRecords := (aCollectionOfMethods collect:		[:each | 		self 			method: each selector 			forClassNamed: each implementingClass absoluteName 			meta: each implementingClass isMeta]) asOrderedCollection.	dataRecords := OrderedCollection new.	aCollectionOfClasses do:		[:eachClass | 		eachClass selectors do:			[:eachSelector | 			methRecords add: (self method: eachSelector forClassNamed: eachClass absoluteName meta: false)].		eachClass class selectors do:			[:eachSelector | 			methRecords add: (self method: eachSelector forClassNamed: eachClass absoluteName meta: true)].		dataRecords addAll:			(eachClass asNameSpace keys collect:				[:key | 				self datum: key forOwnerNamed: eachClass absoluteName])].	aCollectionOfBindings do:		[:eachBinding | 		eachBinding asNameSpace keys do:			[:key | 			dataRecords add: (self datum: key forOwnerNamed: eachBinding absoluteName)]].	LoadAnalyzer checkUninstalledForPackage: self classes: clsRecords methods: methRecords data: dataRecords.	"this one is called during binary loading, and unfortunately, the reason for unloadables is not visible"	clsRecords asOrderedCollection , methRecords , dataRecords 		do: [:each | each raiseUnloadableError: AbstractPundleLoader uninstalledCodeMessage inPackage: self]</body><body package="StoreForGlorpVWUI">dbLoadWithin: aBundle	"We are being told to load within the context of a Store.Bundle. Turn ourselves into an appropriate Store entity and do what it would do in these circumstances"	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource).	self loadSource</body><body package="Store-Database Model">directCompileAndLoad	| packageModel isNew success unloadables |	(Loading for: self) started.	Parcel withFileCachesDo: 		[(self checkPrerequisitesWithin: nil with: nil) ifFalse: 			[(Loading for: self) finished.			^nil].		(isNew := self getImagePundle isNil) ifTrue: 			[self runPreRead ifFalse: 				[(Loading for: self) finished.				^nil]].		(self binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]) ifTrue: 			[[^self binLoadWithin: nil using: nil] ensure: [(Loading for: self) finished]].		packageModel := self createImagePundle.		unloadables := OrderedCollection new.		self storeModel: packageModel.		Policies packagePolicy			forcePackage: packageModel			while: 				[XMainChangeSet ignoreMainChangesWhile:					[success := isNew						ifTrue: [self loadDirectNewCapturing: unloadables]						ifFalse: [self loadDirectDeltasCapturing: unloadables]]].		unloadables notEmpty ifTrue: [self applyLoadingPolicyAfterLoadErrors: unloadables].		self postLoad: packageModel.		self resetStoreModel.		packageModel cleanse: false.		self applyPundleVersionsToTheImage: true.		unloadables isEmpty			ifTrue: [packageModel markNotModified]			ifFalse: [packageModel reconcileWithDbVersion: self]].	(Loading for: self) finished.	^success		ifTrue: [packageModel]		ifFalse: [nil]</body><body package="Store-Database Model">initializeClasses	self initializeClasses: self classesDefinedInPackage methods: self methods</body><body package="Store-Database Model">initializeClasses: aCollectionOfClasses methods: aCollectionOfMethods	| extensions alreadyInitialized |	alreadyInitialized := OrderedCollection new.	extensions := aCollectionOfMethods select: [:each | each version ~= 'CTYPE' and: [(self definedClasses at: each className ifAbsent: [nil]) isNil]].	(extensions select: [:each | each isMeta and: [each selector = #initialize]]) do: 		[:each | (alreadyInitialized add: each correspondingImageClass instanceBehavior) postLoad: storeModel].	(SystemUtils sortForLoading: (aCollectionOfClasses collect: [:each | each correspondingImageClass])) do: 		[:each | 		each ifNotNil: [:value | (alreadyInitialized includes: value) ifFalse: 			[[value postLoad: storeModel]				on: InitializerFailedError				do: [:exception | exception resignalAs: MessageNotUnderstood new]]]]</body><body package="Store-Database Model">initializeShareds	self initializeShareds: self sharedVariables</body><body package="Store-Database Model">initializeShareds: anOrderedCollection	anOrderedCollection do: 		[:each | each correspondingImageBinding ifNotNil: [:value | value reinitializeValue]]</body><body package="Store-Database Model">loadClasses	^self loadClasses: self classesDefinedInPackage values</body><body package="Store-Database Model">loadClasses: aCollection	| failed |	failed := OrderedCollection new.	(self class superclassOrder: aCollection) do: 		[:each | 		each loadSourceDirect ifNil: [failed add: each]].	^failed</body><body package="Store-Database Model">loadData: aSymbol ownerName: aString ifNone: aBlock	"Load the data specified from the database."	| sharedVariableInPackage |	sharedVariableInPackage := self sharedVariable: aSymbol inPackageForOwnerNamed: aString.	sharedVariableInPackage isNil 		ifTrue: [aBlock value]		ifFalse: [sharedVariableInPackage loadSource]</body><body package="Store-Database Model">loadDirectDeltasCapturing: anOrderedCollection	| packageComparitor overrides |	self runPreLoad ifFalse: [^false].	packageComparitor := PackageComparitor 		differencesBetween: self 		and: self storeModel.	packageComparitor hasDifferences ifFalse: [^true].	overrides := OrderedCollection new.	[[SystemUtils modifySystem:		[self loadNamespaces: packageComparitor mainPackageNamespaces.		self loadClasses: packageComparitor mainPackageClasses.		self loadShareds: packageComparitor mainPackageShareds].	self loadMethods: packageComparitor mainPackageMethods.	self initializeShareds: packageComparitor mainPackageShareds.	self initializeClasses: packageComparitor mainPackageClasses methods: packageComparitor mainPackageMethods.	self storeModel removeDeletedDefinitions: packageComparitor]		on: RedefinitionNotification		do: 			[:notification |			notification currentPackage = self storeModel ifTrue: [notification resume].			overrides add: notification override.			notification installOverride]]				on: UnloadableDefinitionError				do: 					[:exception |					anOrderedCollection isEmpty ifTrue: ["check loading options on first unloadable" 						self proceedToLoad ifFalse: [LoadCanceled raiseWith: self. ^false]].					anOrderedCollection add: exception.					exception resume].	overrides do: #cleanUpAfterLoad.	self storeModel cleanUpOverrides.	^true</body><body package="Store-Database Model">loadDirectNewCapturing: anOrderedCollection	| failed overrides |	self runPreLoad ifFalse: [^false].	overrides := OrderedCollection new.	[[SystemUtils modifySystem:		[self loadNamespaces.		failed := self loadClasses.		self loadFailedClasses: failed.		self loadShareds.		[self loadFailedClasses: failed] 			on: UnloadableDefinitionNotification 			do: 				[:ex |				anOrderedCollection isEmpty ifTrue: ["check loading options on first unloadable" 					self proceedToLoad ifFalse: [LoadCanceled raiseWith: self. ^false]].				anOrderedCollection add: (UnloadableDefinitionError newException 					definitionRecord: ex parameter;					package: self;					messageText: ex messageText).				ex resume]].	self loadMethods.	self initializeShareds.	self initializeClasses]		on: RedefinitionNotification		do: 			[:notification |			notification currentPackage = self storeModel ifTrue: [notification resume].			overrides add: notification override.			notification installOverride]]				on: UnloadableDefinitionError				do: 					[:exception |					anOrderedCollection isEmpty ifTrue: ["check loading options on first unloadable" 						self proceedToLoad ifFalse: [LoadCanceled raiseWith: self. ^false]].					anOrderedCollection add: exception.					exception resume].	overrides do: #cleanUpAfterLoad.	self storeModel cleanUpOverrides.	^true</body><body package="Store-Database Model">loadFailedClasses: aCollection	aCollection copy do:		[:each |		each loadSourceDirect ifNotNil: [aCollection remove: each]]</body><body package="Store-Database Model">loadMethod: aSymbol className: aString ifNone: aBlock	"Load the method specified from the database.		aSelector		aSymbol		fullClassName	aString  		noneBlock		aBlock - execute if there is no such method in the package"		| methodInPackage |	methodInPackage := self 		method: aSymbol 		forClassNamed: aString asClassNameOnly 		meta: aString namesMetaClass.	methodInPackage isNil ifTrue: [^aBlock value].	methodInPackage loadSource</body><body package="Store-Database Model">loadMethods	"There is an issue when loading extensions to the ExternalInterface class (or meta) 	because the parser's external instance variable is nil, 	and it will blow when nil is sent #notifyCompilationOfTypeDefinitionFromClass:.	However, that is not a problem for that class! So, we simply say resume!"	self loadMethods: self methods</body><body package="Store-Database Model">loadMethods: aCollection	"There is an issue when loading extensions to the ExternalInterface class (or meta) 	because the parser's external instance variable is nil, 	and it will blow when nil is sent #notifyCompilationOfTypeDefinitionFromClass:.	However, that is not a problem for that class! So, we simply say resume!"	(self sortedMethodsForLoading: aCollection) do:		[:each |		[each loadSourceDirect]			on: MessageNotUnderstood			do: 				[:exception |				exception parameter selector = #notifyCompilationOfTypeDefinitionFromClass:					ifTrue: [exception resume: nil].				exception pass]]</body><body package="Store-Database Model">loadNamespaces	self loadNamespaces: self nameSpaces</body><body package="Store-Database Model">loadNamespaces: aCollection	aCollection do: [:each | each loadSourceDirect]</body><body package="Store-Database Model">loadShareds	self loadShareds: self sharedVariables</body><body package="Store-Database Model">loadShareds: aCollection	aCollection do: [:each | each loadSourceDirect]</body><body package="Store-Database Model">proceedToLoad	"A loading error has occurred. Check out setting AbstractPundleLoader.LoadFailedOption whether to continue loading.	- #loadButNotify = Complete the load but open a tool to manage errors	- #load = Ignore errors and load what can be loaded	- #displayDialog = Open a dialog to ask what to do	- #fail = Load only if there are no errors"	| option |	(option := AtomicLoader loadFailOption) = #fail ifTrue: [^false].	^option = #displayDialog		ifTrue: [Dialog confirm: (#LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?')]		ifFalse: [true]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>comparison</category><body package="Store-Database Model">computeDifferencesBetween: aPackage into: aPackageComparitor	"If aPackage is already a StorePackage, compute the diffs ourselves. 	Otherwise, convert it into one, either by reading it from the database if it's a Package, or by converting the image packageModel"		| other |	other := (aPackage pseudoPackage or: [aPackage class = self class])		ifTrue: [aPackage]		ifFalse:			[aPackage primaryKey = 0				ifTrue: [aPackage asStoreComparisonObjectIn: self session]				ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aPackage primaryKey]]].	^other computeDifferencesBetweenDBPackage: self into: aPackageComparitor</body><body package="Store-Database Model">computeDifferencesBetweenDBPackage: aPackage into: aPackageComparitor	^self computeDiffsBetweenDBPackage: aPackage into: aPackageComparitor</body><body package="Store-Database Model">computeDiffsBetween: aPackage into: aPackageComparitor	"If aPackage is already a StorePackage, compute the diffs ourselves. 	Otherwise, convert it into one, either by reading it from the database if it's a Package, or by converting the image packageModel"		| other |	other := (aPackage pseudoPackage or: [aPackage class = self class])		ifTrue: [aPackage]		ifFalse:			[aPackage primaryKey = 0				ifTrue: [aPackage asStoreComparisonObjectIn: self session]				ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aPackage primaryKey]]].	^other computeDifferencesBetweenDBPackage: self into: aPackageComparitor</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>fixups</category><body package="Store-Database Model">removeDuplicates	"We appear to be able to have duplicates, at least of methods, in the database. 	Remove them before proceeding. But don't bother if we're read from the database, 	because we aren't going to be written back anyway"	| classNames invalid indexes compactedNameSpaces |	self primaryKey isNil ifFalse: [^self].	methods := self uniqueObjectsIn: self methods.	sharedVariables := self uniqueObjectsIn: self sharedVariables.	compactedNameSpaces := self uniqueObjectsIn: self nameSpaces.	compactedNameSpaces size = self nameSpaces size ifFalse: [		nameSpaces := nameSpaces select: [:each |			| there |			there := compactedNameSpaces includes: each.			compactedNameSpaces remove: each ifAbsent: [].			there]].	classNames := Set new.	invalid := OrderedCollection new.	classDefinitions reverseDo: [:each |		(classNames includes: each longName) ifTrue: [invalid add: each].		classNames add: each longName].	indexes := OrderedCollection new.	invalid do: [:each | indexes add: (classDefinitions indexOf: each). classDefinitions removeIndex: indexes last].</body><body package="Store-Publishing Support">sortClassesForLoading	"Organize our classes and namespaces into an order that should load properly. Note that we rely on the image classes for this, so this will only work if their ordering corresponds to our own. Since this is really only used for publishing, that should be fine."	| defs reverseDefs sorted |	defs := classDefinitions collect: [:each | each definition correspondingImageClass ifNil: [each]].	reverseDefs := IdentityDictionary new.	classDefinitions with: defs do: [:eachStoreClass :eachImageClass |		reverseDefs at: eachImageClass put: eachStoreClass].	sorted := SystemUtils sortForLoading: defs.	classDefinitions := sorted collect: [:each | reverseDefs at: each].</body><body package="Store-Publishing Support">sortForLoading	"Organize our classes and namespaces into an order that should load properly. Note that we rely on the image classes for this, so this will only work if their ordering corresponds to our own. Since this is really only used for publishing, that should be fine. Only works in VisualWorks. We could do our own sort for other dialects, but wouldn't be able to do much more than superclass order."	Dialect isVisualWorks ifFalse: [^self].	self sortClassesForLoading.	self sortNamespacesForLoading.</body><body package="Store-Publishing Support">sortNamespacesForLoading	"Organize our classes and namespaces into an order that should load properly. Note that we rely on the image classes for this, so this will only work if their ordering corresponds to our own. Since this is really only used for publishing, that should be fine."	| defs reverseDefs sorted |	defs := nameSpaces collect: [:each | each definition correspondingImageNamespace].	reverseDefs := IdentityDictionary new.	nameSpaces with: defs do: [:eachStoreNamespace :eachImageNamespace |		reverseDefs at: eachImageNamespace put: eachStoreNamespace].	sorted := SystemUtils sortForLoading: defs.	nameSpaces := sorted collect: [:each | reverseDefs at: each].</body><body package="Store-Database Model">uniqueObjectsIn: aCollection	| wrappers answer |	answer := OrderedCollection new.	wrappers := aCollection collect: [:each | StoreSignatureObject for: each].	wrappers asSet do: [:each | answer add: each signatureObject].	^answer</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>initialize-release</category><body package="Store-Database Model">initialize	super initialize.	classDefinitions := OrderedCollection new.	nameSpaces := OrderedCollection new.	sharedVariables := OrderedCollection new.	methods := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>private</category><body package="Store-Database Model">privateSetMethods: aCollection	methods := aCollection.</body><body package="Store-Database Model">sortedMethods: aCollection	| orderedMethods classesWithMethods startingClasses orderedClasses |	orderedMethods := OrderedCollection new.	aCollection isEmpty ifTrue: [^orderedMethods].	classesWithMethods := Dictionary new.	startingClasses := OrderedSet new.	aCollection do: 		[:each | | imageClass |		(imageClass := each correspondingImageClass) isNil			ifTrue: [each raiseUnloadableError: (UnloadedObjectError class: each className asSymbol) inPackage: self]			ifFalse: 				[(classesWithMethods at: imageClass					ifAbsentPut: 						[startingClasses add: imageClass.						OrderedCollection new]) add: each]].	orderedClasses := SystemUtils sortForLoading: (startingClasses select: #isMeta).	orderedClasses addAll: (SystemUtils sortForLoading: (startingClasses reject: #isMeta)).	orderedClasses do: [:each | orderedMethods addAll: (classesWithMethods at: each)].	^orderedMethods</body><body package="Store-Database Model">sortedMethodsForLoading: aCollectionOfStoreMethod	"We sort out first any CTYPE methods, which come first	Then we sort out defined in package classes by class hierarchy	Finally we sort of extension methods by class hierarchy"	| cTypeMethods sortedMethods definedMethods extensionMethods |	cTypeMethods := OrderedCollection new.	definedMethods := OrderedCollection new.	extensionMethods := OrderedCollection new.	aCollectionOfStoreMethod do: 		[:each |		each version = 'CTYPE'			ifTrue: [cTypeMethods add: each]			ifFalse: 				[(self definedClasses includesKey: each className)					ifTrue: [definedMethods add: each]					ifFalse: [extensionMethods add: each]]].	sortedMethods := OrderedCollection new.	sortedMethods addAll: (self sortedMethods: cTypeMethods).	sortedMethods addAll: (self sortedMethods: definedMethods).	sortedMethods addAll: (self sortedMethods: extensionMethods).	^sortedMethods</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>constants</category><body package="Store-Database Model">componentType	^#package</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>enumerating</category><body package="Store-Database Model">allComponentsDo: aBlock	aBlock value: self.</body><body package="StoreForGlorpVWUI">classDefinitionFor: aClassDefinitionDescription	^self classDefinitions detect: [:each |			(each definition longName = aClassDefinitionDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI">classInPackageNamed: aClassName meta: aBoolean	| selector theClass |	selector := (aClassName includes: $.) ifTrue: [#longName] ifFalse: [#name].	theClass := self classes detect: [:each | (each perform: selector) = aClassName] ifNone: [^nil].	^(aBoolean ifTrue: [theClass metaclass] ifFalse: [theClass]) definition.</body><body package="Store-Database Model">componentsDetect: aBlock ifNone: missingBlock	(aBlock value: self) ifTrue: [^self].	^missingBlock value.</body><body package="StoreForGlorpVWUI">datum: dataKey forOwnerNamed: environmentName		^(self sharedVariables 		detect: [:each | each definition dataKey = dataKey and: [each definition environmentName = environmentName]]		ifNone: [^nil]) definition</body><body package="StoreForGlorpVWUI">descriptionClass	^PackageDescription</body><body package="StoreForGlorpVWUI">metaClassDefinitionFor: aClassDefinitionDescription	^self classDefinitions detect: [:each |			(each metaclass longName = aClassDefinitionDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI">methodFor: aMethodDescriptor	| selector fullClassName |	selector := aMethodDescriptor selector asString.	fullClassName := aMethodDescriptor fullClassName asString.	^self methods detect: [:each |		(each definition name = selector) 			and: [(each className = fullClassName)				and: [each isMetaclass = aMethodDescriptor isMeta]]]					ifNone: [nil].</body><body package="StoreForGlorpVWUI">nameSpaceFor: aNamespaceDescription	^self nameSpaces detect: [:each |			(each definition longName = aNamespaceDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI">nameSpaceInPackageNamed: aString		^(self nameSpaces detect: [:each | each definition longName = aString] ifNone: [nil]) ifNotNil: [:value | value definition]</body><body package="StoreForGlorpVWUI">sharedVariable: aSymbol inPackageForOwnerNamed: aString		^(self sharedVariables 		detect: [:each | each definition dataKey = aSymbol and: [each definition environmentName = aString]]		ifNone: [^nil])</body><body package="StoreForGlorpVWUI">sharedVariableFor: aSharedVariableDescription	^self sharedVariables detect: [:each |			(each definition longName = aSharedVariableDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI">sharedVariableWithLongName: aString		^self sharedVariables 		detect: [:each | each definition longName = aString] 		ifNone: [nil]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>copying</category><body package="Store-Database Model">postCopyIn: aDictionary	super postCopyIn: aDictionary.	nameSpaces := nameSpaces collect: [:each | each glorpCopyIn: aDictionary].	classDefinitions := classDefinitions collect: [:each | each glorpCopyIn: aDictionary].	sharedVariables := sharedVariables collect: [:each | each glorpCopyIn: aDictionary].	methods := methods collect: [:each | each glorpCopyIn: aDictionary].	parcel := parcel isNil ifTrue: [nil] ifFalse: [parcel glorpCopyIn: aDictionary].</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>converting</category><body package="Store-Publishing Support">addClassesAndMetaclassesFromPackageModel: aPackageModel	(aPackageModel definedClassModels		asSortedCollection: [:a :b | a fullClassSymbol &lt; b fullClassSymbol])			asOrderedCollection do: 				[:eaClassModel |				self addClassDefinition: eaClassModel actualClass]</body><body package="Store-Publishing Support">addMethodsFromPackageModel: aPackageModel	aPackageModel methods do: [:each | self addMethod: each]</body><body package="Store-Publishing Support">addNameSpacesFromPackageModel: aPackageModel	aPackageModel nameSpaceModels		do: [:each | each isExtension ifFalse: [self addNameSpace: each]]</body><body package="Store-Publishing Support">addOverriddenClassesAndNameSpacesFromPackageModel: aPackageModel	Override overriddenClassesAndNameSpaces keysAndValuesDo: 			[:inMemoryVersion :eachList |			eachList do: 					[:each |					(each includesSource: aPackageModel)						ifTrue: 							[inMemoryVersion isBehavior								ifTrue: [self addClassDefinition: each]								ifFalse: [self addNameSpace: each]]]]</body><body package="Store-Publishing Support">addOverriddenSharedVariablesFromPackageModel: aPackageModel	Override overriddenStaticsDo: 			[:each |			(each includesSource: aPackageModel)				ifTrue: [self addSharedVariable: each]]</body><body package="Store-Publishing Support">addSharedVariablesFromPackageModel: aPackageModel	aPackageModel data		do: [:each | self addSharedVariable: each]</body><body package="Store-Publishing Support">addUninstalledCodeFromPackageModel: aPackageModel	| relatedParcel |	relatedParcel := Parcel parcelNamed: aPackageModel name.	(relatedParcel notNil and: [relatedParcel hasUninstalledCode])		ifTrue: 			[(relatedParcel propertyAt: #uninstalledMethods ifAbsent: [#()])				do: [:each | self addMethod: each].			(relatedParcel propertyAt: #uninstalledClasses ifAbsent: [#()])				do: [:each | self addUninstalledClassDefinition: each].			"I don't know what these things look like, and don't have any examples, so ignore them for now"			(relatedParcel propertyAt: #uninstalledBindings ifAbsent: [#()])				do: [:each | self halt]]</body><body package="Store-Database Model">classesNamed: aSetOfNames	"Convert aSetOfnames into a collection of StoreClassesInPackage"		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:each :other | each name &lt; other name].	self classes do:		[:each | 		(names includes: each absoluteName) ifTrue:			[names remove: each absoluteName.			selected add: each]].	names do: [:each | selected add: (ClassDescriptor fullName: each meta: false)].	^selected</body><body package="Store-Publishing Support">minimizeFootprintInImage	super minimizeFootprintInImage.	fullClasses := nil.	self privateUninstantiate</body><body package="StoreForGlorpVWUI">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^self recordForTag: aTag</body><body package="StoreForGlorpVWUI">recordForClassTag: aTag	| theName |	theName := aTag className asString.	^self classDefinitions		detect: [:each | each longName = theName]		ifNone: [nil].</body><body package="StoreForGlorpVWUI">recordForDataTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there."		^(self sharedVariables isNil or: [self sharedVariables isEmpty])		ifTrue: [nil]		ifFalse: [self sharedVariable: aTag dataKey inPackageForOwnerNamed: aTag ownerName asString]</body><body package="StoreForGlorpVWUI">recordForMethodTag: aTag	^self methodFor: aTag.</body><body package="StoreForGlorpVWUI">recordForNameSpaceTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there."		^self nameSpaces detect: [:each | each absoluteName = aTag name] ifNone: [nil]</body><body package="StoreForGlorpVWUI">recordForStructureTag: aTag 	"Packages don't have structure objects so, answer nil"	^nil</body><body package="StoreForGlorpVWUI">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' 	or nil if not there."	^aTag recordForPackage: self.</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>private-file out</category><body package="StoreForGlorpVWUI">fileOutClassesOn: aSourceFileManager	self classDefinitions do:		[:each |		aSourceFileManager storeObjectDefinition: each.		each comment notEmpty ifTrue: [aSourceFileManager comment: each value: each comment]]</body><body package="StoreForGlorpVWUI">fileOutMethodsOn: aSourceFileManager	"First group methods by class and protocol 	and the ask aFileManager to do the job class by class"		| toFileOut classes protocols |	toFileOut := Dictionary new.	self methodDefinitions do:		[:each | 		classes := toFileOut			at: each longNameWithMetaFromSmalltalk			ifAbsent: [Dictionary new].		protocols := classes			at: each protocol asString			ifAbsent: [Set new].		protocols add: each.		classes			at: each protocol asString			put: protocols.		toFileOut			at: each longNameWithMetaFromSmalltalk			put: classes.		(each name = 'initialize' and: [each absoluteClassName namesMetaClass])			ifTrue: [aSourceFileManager initializeThisClass: (ClassDescriptor fullName: each longNameFromSmalltalk asClassNameOnly meta: false)]].	toFileOut keysAndValuesDo:		[:key :value | 		aSourceFileManager fileOutTTMessages: value for: key logging: false.		aSourceFileManager cr].</body><body package="StoreForGlorpVWUI">fileOutNameSpacesOn: aSourceFileManager		self nameSpaces do:		[:each | 		aSourceFileManager storeObjectDefinition: each.		each comment isEmpty ifFalse: [aSourceFileManager comment: each value: each comment]]</body><body package="StoreForGlorpVWUI">fileOutOn: aSourceFileManager	"When saving a Package to a aFileManager we need to ensure that there is a change to	create the package, this is why ComponentCreatedChange is used.  Also, to ensure	 that the aFileManager stores the package ownership information for any definitions	this package has. "		aSourceFileManager deferInitializations.	(ComponentCreatedChange new component: self) fileOutOn: aSourceFileManager.	aSourceFileManager sourceFormatter attributeFor: #package compute: [:ignore | self name].	aSourceFileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | self name].	aSourceFileManager cr.	aSourceFileManager addComment: 'Package ' , self itemString.	self fileOutPropertiesOn: aSourceFileManager.	self fileOutNameSpacesOn: aSourceFileManager.	self fileOutClassesOn: aSourceFileManager.	self fileOutSharedsOn: aSourceFileManager.	self fileOutMethodsOn: aSourceFileManager.	aSourceFileManager finishInitializations.	aSourceFileManager cr</body><body package="StoreForGlorpVWUI">fileOutSharedsOn: aSourceFileManager	self sharedVariables do:		[:each | 		aSourceFileManager storeObjectDefinition: each.		each comment isEmpty ifFalse: [aSourceFileManager comment: each value: each comment]]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>comparing</category><body package="Store-Database Model">allClassDefinitionDifferencesWith: anotherStorePackage	| keys query1 query2  union |	keys := Array with: self primaryKey with: anotherStorePackage primaryKey.	query1 := Query read: StoreClassDefinitionInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreClassDefinitionInPackage where: [:foo |       				foo packageRef = keys last].   			subQuery retrieve: [:x | x classRef].       			(each packageRef = keys first)           			&amp; ((each classRef) notIn: subQuery)].	query1 alsoFetch: [:each| each definition].	query1 alsoFetch: [:each| each package].	query2 := Query read: StoreClassDefinitionInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreClassDefinitionInPackage where: [:foo |       				foo packageRef = keys first].   			subQuery retrieve: [:x | x classRef].       			(each packageRef = keys last)           			&amp; ((each classRef) notIn: subQuery)].	query2 alsoFetch: [:each| each definition].	query2 alsoFetch: [:each| each package].	union := query1 unionAll: query2.	union requiresDistinct: false.	^session execute: union.</body><body package="Store-Database Model">allClassesInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage classDefinitions])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage classDefinitions]).</body><body package="Store-Database Model">allIn: aCollection butNotIn: anotherCollection	| dictionary |	dictionary := Dictionary new.	aCollection do: [:each | dictionary at: each definition put: each].	aCollection isEmpty ifTrue: [^#()].	anotherCollection do: [:each | dictionary removeKey: each definition ifAbsent: []].	^dictionary asArray collect: [:each | each definition].</body><body package="Store-Database Model">allMethodDifferencesWith: anotherStorePackage	| keys query1 query2  union |	keys := Array with: self primaryKey with: anotherStorePackage primaryKey.	query1 := Query read: StoreMethodInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreMethodInPackage where: [:foo |       				foo packageRef = keys last].   			subQuery retrieve: [:x | x methodRef].       			(each packageRef = keys first)           			&amp; ((each methodRef) notIn: subQuery)].	query1 alsoFetch: [:each| each definition].	query1 alsoFetch: [:each| each definition source].	query1 alsoFetch: [:each| each package].	query2 := Query read: StoreMethodInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreMethodInPackage where: [:foo |       				foo packageRef = keys first].   			subQuery retrieve: [:x | x methodRef].       			(each packageRef = keys last)           			&amp; ((each methodRef) notIn: subQuery)].	query2 alsoFetch: [:each| each definition].	query2 alsoFetch: [:each| each definition source].	query2 alsoFetch: [:each| each package].	union := query1 unionAll: query2.	union requiresDistinct: false.	^session execute: union.</body><body package="Store-Database Model">allMethodsInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage methods])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage methods]).</body><body package="Store-Database Model">allNamespaceDifferencesWith: anotherStorePackage	| keys query1 query2  union |	keys := Array with: self primaryKey with: anotherStorePackage primaryKey.	query1 := Query read: StoreNamespaceInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreNamespaceInPackage where: [:foo |       				foo packageRef = keys last].   			subQuery retrieve: [:x | x namespaceRef].       			(each packageRef = keys first)           			&amp; ((each namespaceRef) notIn: subQuery)].	query1 alsoFetch: [:each| each definition].	query1 alsoFetch: [:each| each package].	query2 := Query read: StoreNamespaceInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreNamespaceInPackage where: [:foo |       				foo packageRef = keys first].   			subQuery retrieve: [:x | x namespaceRef].       			(each packageRef = keys last)           			&amp; ((each namespaceRef) notIn: subQuery)].	query2 alsoFetch: [:each| each definition].	query2 alsoFetch: [:each| each package].	union := query1 unionAll: query2.	union requiresDistinct: false.	^session execute: union.</body><body package="Store-Database Model">allNamespacesInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage nameSpaces])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage nameSpaces]).</body><body package="Store-Database Model">allSharedVariableDifferencesWith: anotherStorePackage	| keys query1 query2  union |	keys := Array with: self primaryKey with: anotherStorePackage primaryKey.	query1 := Query read: StoreSharedVariableInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreSharedVariableInPackage where: [:foo |       				foo packageRef = keys last].   			subQuery retrieve: [:x | x dataRef].       			(each packageRef = keys first)           			&amp; ((each dataRef) notIn: subQuery)].	query1 alsoFetch: [:each| each definition].	query1 alsoFetch: [:each| each package].	query2 := Query read: StoreSharedVariableInPackage  		where: [:each |   |subQuery |      			subQuery := Query read: StoreSharedVariableInPackage where: [:foo |       				foo packageRef = keys first].   			subQuery retrieve: [:x | x dataRef].       			(each packageRef = keys last)           			&amp; ((each dataRef) notIn: subQuery)].	query2 alsoFetch: [:each| each definition].	query2 alsoFetch: [:each| each package].	union := query1 unionAll: query2.	union requiresDistinct: false.	^session execute: union.</body><body package="Store-Database Model">allSharedsInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage sharedVariables])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage sharedVariables]).</body><body package="Store-Database Model">computeDiffsBetweenDBPackage: aStorePackage into: aPackageComparitor	"Store  differences between receiver and a aStorePackage into an instance of PackageComparitor.	Store receiver's definitions as main and the other as other since this method	is called with arguments reversed."	| realOtherPackage allMethodDifferences allSharedVariableDifferences allNamespaceDifferences allClassDefinitionDifferences |	realOtherPackage := (aStorePackage isNil or: [aStorePackage class == self class]) 		ifTrue: [aStorePackage] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aStorePackage primaryKey]].	self = realOtherPackage ifTrue: [aPackageComparitor makeEmpty. ^self].	allMethodDifferences := self allMethodDifferencesWith: realOtherPackage.	aPackageComparitor otherPackageMethods: ((allMethodDifferences select: [:ea| ea package = self]) collect: [:ea| ea definition]).	aPackageComparitor mainPackageMethods: ((allMethodDifferences select: [:ea| ea package = realOtherPackage]) collect: [:ea| ea definition]).	allSharedVariableDifferences := self allSharedVariableDifferencesWith: realOtherPackage.	aPackageComparitor otherPackageShareds: ((allSharedVariableDifferences select: [:ea| ea package = self]) collect: [:ea| ea definition]).	aPackageComparitor mainPackageShareds: ((allSharedVariableDifferences select: [:ea| ea package = realOtherPackage]) collect: [:ea| ea definition]).	allNamespaceDifferences := self allNamespaceDifferencesWith: realOtherPackage.	aPackageComparitor otherPackageNamespaces: ((allNamespaceDifferences select: [:ea| ea package = self]) collect: [:ea| ea definition]).	aPackageComparitor mainPackageNamespaces: ((allNamespaceDifferences select: [:ea| ea package = realOtherPackage]) collect: [:ea| ea definition]).		allClassDefinitionDifferences := self allClassDefinitionDifferencesWith: realOtherPackage.	aPackageComparitor otherPackageClasses: ((allClassDefinitionDifferences select: [:ea| ea package = self]) collect: [:ea| ea definition]).	aPackageComparitor mainPackageClasses: ((allClassDefinitionDifferences select: [:ea| ea package = realOtherPackage]) collect: [:ea| ea definition]).	^aPackageComparitor</body><body package="StoreForGlorpVWUI">computeFullDiffsBetweenDBPackage: aDBPackage into: aComparitor	^self computeDiffsBetweenDBPackage: aDBPackage into: aComparitor.</body><body package="StoreForGlorpVWUI">describesSameAs: aComponentDescr	"Copied from Store.PackageDescription"	"Answer true if aComponentDescr referes to	a package named the same as my bundle"	^aComponentDescr isPackage		and: [ self describesPackageNamed: aComponentDescr name ].</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling">defaultCompileManagerClass	^ShadowPackageCompileManager</body><body package="Glorp Atomic Compiling">newDefaultCompileManagerWith: aCompilationManager	^self defaultCompileManagerClass newForPundle: self with: aCompilationManager</body><body package="Glorp Atomic Compiling">preCompileWith: aCompilationManager	"Run approapiate actions before compiling. Answer true if okay to continue."	| parentBundleOrNil |	aCompilationManager ifNotNil:		[parentBundleOrNil := aCompilationManager pundle isBundle 			ifTrue: [aCompilationManager pundle] 			ifFalse: [nil]].	(self checkPrerequisitesWithin: parentBundleOrNil with: aCompilationManager)		ifFalse: [^false].	^true</body><body package="Glorp Atomic Compiling">pundleInstallClass	^PackageInstall</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>private-utilities</category><body package="Store-Database Model">superclassOrder: aCollectionOfStoreClasses	"Sort all of the classes in the list into a collection where no class is preceded by a subclass or 	by its metaclass. I cannot use method in SystemUtils since the classes are not in the image"		| workingCopy orderedClasses classNames |	workingCopy := aCollectionOfStoreClasses copy.	orderedClasses := OrderedCollection new.	[workingCopy isEmpty]		whileFalse:			[classNames := workingCopy collect: [:each | each absoluteName].			workingCopy copy do:				[:each | 				(each isPseudo not and: [classNames includes: each superclassName])					ifFalse:						[orderedClasses add: each.						workingCopy remove: each]]].	^orderedClasses</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>constants</category><body package="Store-Database Model">propertyTypeCode	^1.</body><body package="Store-Database Model">typeStringForBlessing	^'P'</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">imageClass	^PackageModel</body><body package="StoreForGlorpVWUI">toolListIcon	^BehaviorIcons PackageDisconnected</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>query utility</category><body package="Store-Database Model">hasRelatedParcelFor: aPackageModel	^self hasRelatedParcelFor: aPackageModel in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model">hasRelatedParcelFor: aPackageModel in: aSessionOrNil	| session query primaryKey |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	(primaryKey := aPackageModel dbTrace) ifNil: [^false].	query := Query count: self where: [:each | each primaryKey = primaryKey AND: (each parcel notNil)].	^(session execute: query) &gt; 0</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>database-utilities</category><body package="Store-Database Model">allNonBinaryNamesIn: aSessionOrNil	| names |	names := super allNonBinaryNamesIn: aSessionOrNil.	names := names asSortedCollection asOrderedCollection.	^names select: 		[:each | 		(Gathering for: each) announce.		(self allVersionsWithName: each in: aSessionOrNil) allSatisfy: [:eachPackage | eachPackage binaryVersion isNil]]</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>actions</category><body package="Store-UI">compareWithImage	| pundle imageModel |	pundle := self selectedPundle.	imageModel := pundle correspondingImagePundle.	imageModel notNil		ifTrue: [self openCompareFrom: pundle  to: imageModel].</body><body package="Store-UI">fileOutDifferences	| selections dialog versions fileName session |	selections := self selectedPundles.	dialog := FileoutDifferencesDialog from: selections first to: selections last.	dialog open.	dialog cancel value		ifTrue: [^self].	versions := Array with: dialog from with: dialog to.		fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: selections first name)).	fileName isEmpty ifTrue: [^nil].	session := versions first session ifNil: [versions last session ifNil: [StoreLoginFactory currentStoreSession]].	Store.StoreProgressOverlay		subsume: builder window		while:			[(Store.FilingOut for: selections first) started.			versions first isPackage 				ifTrue: [self class fileOutDifferencesBetweenPackage: versions first and: versions last into: fileName using: session]				ifFalse: [self class fileOutDifferencesBetweenBundle: versions first and: versions last into: fileName using: session].			(Store.FilingOut for: versions first) finished]</body><body package="Store-UI">inspectSelected	self selectedPundle inspect</body><body package="Store-UI">loadSelectedVersion	| imagePundle wasAnotherVersionLoaded |	wasAnotherVersionLoaded := self selectedPundle notNil and: [(self imageVersionAt: self selectedPundle name) notNil].	super loadSelectedVersion.	imagePundle := self selectedPundle correspondingImagePundle.	imagePundle notNil		ifTrue: [self addImageVersion: imagePundle.			wasAnotherVersionLoaded				ifFalse: [self updateVersionsList]].</body><body package="Store-UI">openVersionsList	DefinitionForListTool forPackages: self selectedPundle allStoreVersions</body><body package="Store-UI">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self selections size &gt; 0		ifTrue: 			[self selectedPundles do:				[:each |				updateText					emphasize: #(#large #bold #underline)					during: 						[updateText nextPutAll: each name.						updateText space; space].				updateText					emphasize: #(#bold #underline)					during: 						[updateText 							nextPut: $(;							nextPutAll: each version;							nextPut: $)].				each isImageModel ifFalse:					[updateText						emphasize: #(#bold #underline)						during: 							[updateText								space; space;								nextPutAll: (Policies blessingPolicy blessingName:each currentBlessingLevel)]].				updateText cr.				each isImageModel 					ifFalse:						[each blessings do:							[:eachBlessing | eachBlessing blessingLevel = -1 ifFalse: [eachBlessing printTallOn: updateText]].						updateText cr]]]		ifFalse: 			[ | initial initialComment |			self itemsInList list isEmpty ifFalse:				[initial := self itemsInList list first.				initialComment := (initial comment isNil or: [initial comment isEmpty])					ifTrue: 						[updateText emphasis: #italic.						(#LastPublishedVersionOnentHasNoComment &lt;&lt; #store &gt;&gt; 'Last published version of this component has no comment.') asString]					ifFalse: 						[updateText emphasis: (Array with: #color-&gt; ColorValue navy).						initial comment].				updateText nextPutAll: initialComment]].	self updateTextPaneWith: updateText contents</body><body package="Store-UI">updateVersionsList	tool updateVersionsList</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>interface opening</category><body package="Store-UI">calculateColumnWidthsFor: items basedOn: selections	| columnWidths blessings |	columnWidths := Dictionary new.	items notEmpty		ifTrue: [ | versions |			versions := items select: [:each| each useForWidthCalculations].			versions := versions collect: [:each| each pundle].			selections size &gt; 1				ifTrue: [columnWidths at: #name						put: (self								findColumnMaxLengthFor: selections								emphasis: #bold								columnTextBlock: [:each | each name])].			columnWidths at: #version				put: (self						calculateAppropriateColumnLengthFor: versions						emphasis: #bold						columnTextBlock: [:each | each versionString]).			blessings := (versions collect: [:each | each blessingLevelString]) asSet.			columnWidths at: #blessing				put: (self						calculateAppropriateColumnLengthFor: blessings						emphasis: #bold						columnTextBlock: [:each | each]).			columnWidths at: #publishedFormatDescription				put: ((selections allSatisfy: [:each| each isBundle])						ifTrue: [0]						ifFalse: 							[self								calculateAppropriateColumnLengthFor: self publishedFormatDescriptions								emphasis: #bold								columnTextBlock: [:ea | ea asString]])].	^columnWidths</body><body package="Store-UI">compositeViewUsing: aDisplayRow columnWidths: columnWidthDictionary in: aSequenceView	^aDisplayRow displayRowUsingColumnWidths: columnWidthDictionary				textStyle: aSequenceView textStyle</body><body package="Store-UI">imageVersionAt: aPackage	^imageVersions at: aPackage ifAbsent: [nil]</body><body package="Store-UI">labelClass	^Label</body><body package="Store-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #SelectionList)		client: self versionSearchList		spec: self versionSearchList preferredWindowSpec		builder: aBuilder newSubBuilder</body><body package="Store-UI">selectEmphasisFor: aPackage	| imageModel |	^((imageModel := self imageVersionAt: aPackage name) notNil and: 			[imageModel dbTrace ~~ nil and: [aPackage primaryKey &gt; imageModel dbTrace]])		ifTrue: [#bold]		ifFalse: [nil]</body><body package="Store-UI">setUpListViewWith: columnWidthDictionary	"First we measure 2 things... 		the largest size of the version string, 		the largest size of a blessing name"		| widget |	widget := (self itemsInList listModule listWidget).	widget ifNil: [^self].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index) value				columnWidths: columnWidthDictionary				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index) value				columnWidths: columnWidthDictionary				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	(widget addTooltipAssistant: PundleVersionTooltipAssistant) tooltip: self pundleVersionPropertiesText.	widget		hoverDisplayCriteria: widget hoverTextClipped</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>accessing</category><body package="Store-UI">addImageVersion: aPundleModel	imageVersions at: aPundleModel name put: aPundleModel</body><body package="Store-UI">currentList		^currentList ifNil: [currentList := List new].</body><body package="Store-UI">fillListWith: aCollection	| list |	list := aCollection.	listFilterBlock ifNotNil: [list := aCollection select: listFilterBlock].	self versionSearchList 		entry: '';		list: (currentList := list).</body><body package="Store-UI">listOfThings	"This has this 'odd' name because of the way the window specs are set up"	versionSearchList ifNil: [self setupSearcher].	^versionSearchList</body><body package="Store-UI">listTitle	^self title</body><body package="Store-UI">publishedFormatDescriptionFor: aSymbol	^publishedFormatDescriptions at: aSymbol ifAbsent: [''].</body><body package="Store-UI">publishedFormatDescriptions	^publishedFormatDescriptions values</body><body package="Store-UI">publishedFormatStringFor: aPundle	"Note: We explictly do a == nil to keep the proxy from coming in if possible"	^aPundle isBundle		ifTrue: ['']		ifFalse: 			[aPundle isPublishedBinary				ifTrue: [self publishedFormatDescriptionFor: #binary]				ifFalse: [self publishedFormatDescriptionFor: #source]]</body><body package="Store-UI">pundleFilter	^tool pundleFilter</body><body package="Store-UI">retrievePundleVersionsFor: aCollection	| fullList |	fullList := List new.	aCollection do: 		[:each |		| pundleModel storeVersions |		(Gathering for: each name) started.		pundleModel := each isImageModel			ifTrue: [each]			ifFalse: [each correspondingImagePundle].		pundleModel ifNotNil: 			[self addImageVersion: pundleModel.			fullList add: (ImagePundleDisplayRow newFor: pundleModel parentModel: self)].		storeVersions := each storeForGlorpPundleClass 			allVersionsInitiallyNamed: each name			in: each session			usingPundleFilter: self pundleFilter.		storeVersions do: [:eachVersion|			fullList add: (StorePundleDisplayRow newFor: eachVersion parentModel: self)].		(Gathering for: each name) finished].	^fullList</body><body package="Store-UI">selectedPundle	^self selection pundle</body><body package="Store-UI">selectedPundles	^self selections collect: [:ea| ea pundle].</body><body package="Store-UI">versionSearchList	^self listOfThings</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>menu</category><body package="Store-UI">compareBundleStructures	| selections |	selections := self publishOrderedSelectionPair.	(BundleStructureComparisonView new)		left: selections first right: selections last;		openScrolledWindow</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>private</category><body package="Store-UI">setupSearcher	versionSearchList := IncrementalSearchModule 		forSelectionWithSearch: [:pattern | self versionsMatching: pattern].	versionSearchList		useEagerSelection: false;		pasteSelected: false;		showLabels: false;		useMultiSelection: true;		menuHolder: [self listMenu value] performer: self.	versionSearchList selectionIndexHolder onChangeSend: #selectionsUpdated to: self</body><body package="Store-UI">versionsMatching: aString	| pattern |	pattern := aString trimBlanks, '*'.	^self currentList select: [:some | some alwaysShow or: [(pattern match: some version) or: [some isImageObject not and: [pattern match: some username]]]]</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>initialize-release</category><body package="Store-UI">initialize	self initializePublishedFormatDescriptions.	self resetImageVersions</body><body package="Store-UI">initializePublishedFormatDescriptions	publishedFormatDescriptions := Dictionary new		at: #binary put: (#binary &lt;&lt; #store &gt;&gt; 'binary') asString;		at: #source put: (#source &lt;&lt; #store &gt;&gt; 'source') asString;		yourself.</body><body package="Store-UI">resetImageVersions	imageVersions := Dictionary new</body><body package="Store-UI"> resetWith: selections withFeedbackOn: aWindow	| versions columnWidths |	self resetImageVersions.	self fillListWith: #().	selections isEmpty		ifTrue: [^self].	[versions := self retrievePundleVersionsFor: selections.	columnWidths := self calculateColumnWidthsFor: versions				basedOn: selections.	self setUpListViewWith: columnWidths.	self fillListWith: versions]			withStoreFeedbackOn: aWindow</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>testing</category><body package="Store-UI">atLeastOnePundleSelected	^tool searchModule selections notEmpty</body><body package="Store-UI">atLeastOnePundleVersionSelected	^self itemsInList selections notEmpty</body><body package="Store-UI">hasFilterSet	^self pundleFilter hasVersionFilterSet</body><body package="Store-UI">hasTwoBundlesSelected	| selections |	selections := self selectedPundles.	^selections size = 2 and: [selections any isBundle]</body><body package="Store-UI">onlyOnePundleSelected	^tool searchModule selections size = 1</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>text length calculation</category><body package="Store-UI">calculateAppropriateColumnLengthFor: aCollection emphasis: emphasisSymbol columnTextBlock: aTextBlock	| string selectedFont textMeasurer count widthCollection sum mean sumSq stdDev width widget |	aCollection isEmpty ifTrue: [^0].	widget := (self itemsInList listModule listWidget).	widget container isNil ifTrue: [^0].	selectedFont := widget fontForEmphasis: emphasisSymbol.	textMeasurer := TextMeasurer forFont: selectedFont.	widthCollection := OrderedCollection new: aCollection size.	aCollection do: 			[:each |			string := aTextBlock value: each.			string notNil				ifTrue: [widthCollection addLast: (textMeasurer measureString: string)]].	count := widthCollection size.	sum := 0.	widthCollection do: [:each | sum := sum + each].	mean := sum // count.	sumSq := 0.	widthCollection do: [:each | sumSq := sumSq + (mean - each raisedTo: 2)].	stdDev := (sumSq / count) sqrt.	width := mean + ((stdDev * 2) rounded max: 35).	^width</body><body package="Store-UI">findColumnMaxLengthFor: aCollection emphasis: emphasisSymbol columnTextBlock: aTextBlock	 | longestValue string selectedFont textMeasurer widget |	aCollection isEmpty ifTrue: [^0].	widget := self itemsInList listModule listWidget.	widget container isNil ifTrue: [^0].	selectedFont := widget fontForEmphasis: emphasisSymbol.	textMeasurer := TextMeasurer forFont: selectedFont.	longestValue := 0.	aCollection do: [:each| 		string := aTextBlock value: each.		string notNil			ifTrue: [longestValue :=  (textMeasurer measureString: string) max: longestValue]].	^longestValue</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>aspects</category><body package="Store-UI">itemsInList	"This is a kind of fake out. For all other panes, this is a MultiSelectionInList object, but for me	I point to the search module"	^self versionSearchList</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>hoverhelp</category><body package="Store-UI">pundleVersionPropertiesText	^[:view|		| index |		index := view mouseOverIndex.		(view isValidIndex: index)			ifTrue: [				|  displayRow |				displayRow := (view elementAt: index) value.				displayRow toolTipText]			ifFalse: [nil]]</body></methods><methods><class-id>Store.Glorp.PundleVersionPane class</class-id> <category>resources</category><body package="Store-UI">listSpec	^self windowSpec</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>event driven</category><body package="Store-Code Comparison">getEventHandler		^self</body><body package="Store-Code Comparison">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-Code Comparison">handlerForMouseEvent: anEvent	"Give subparts a chance first, and then if I contain it, I'll take them."		^(super handlerForMouseEvent: anEvent)		ifNil:			[(self containsMouseEvent: anEvent)				ifTrue: [self]				ifFalse: [nil]]</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>scrolling</category><body package="Store-Code Comparison">scrollOffsetHolder: aScrollOffsetHolder	aScrollOffsetHolder grid: 1 @ 18</body><body package="Store-Code Comparison">scroller	^self findParent: [:each | each isKindOf: ScrollWrapper]</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>accessing</category><body package="Store-Code Comparison">comparisonSource	^comparisonSource</body><body package="Store-Code Comparison">comparisonSource: anObject	comparisonSource := anObject.	self populate</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>initialize-release</category><body package="Store-Code Comparison">initialize	super initialize.	expansionMemory := Dictionary new</body><body package="Store-Code Comparison">initializeLayoutAlgorithm	self beFullColumn</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>view construction</category><body package="Store-Code Comparison">newBundleRollup: aBundleName	| propertiesView |	propertiesView := CodeComponentPropertiesComparisonView new.	propertiesView rightProperties: (comparisonSource addedBundleProperties at: aBundleName ifAbsent: [Array new]).	propertiesView leftProperties: (comparisonSource removedBundleProperties at: aBundleName ifAbsent: [Array new]).	^propertiesView</body><body package="Store-Code Comparison">newClassRollup: aBindingReference	| classView |	classView := ClassBlueprintComparisonView new.	classView		leftClass: (comparisonSource removedClasses at: aBindingReference ifAbsent: [nil])		leftMethods: (comparisonSource removedMethods at: aBindingReference ifAbsent: [Array new])		rightClass: (comparisonSource addedClasses at: aBindingReference ifAbsent: [nil])		rightMethods: (comparisonSource addedMethods at: aBindingReference ifAbsent: [Array new]).	^classView</body><body package="Store-Code Comparison">newNamespaceRollup: aBindingReference	| namespaceView |	namespaceView := NamespaceBlueprintComparisonView new.	namespaceView leftNamespace: (comparisonSource removedNamespaces at: aBindingReference ifAbsent: [nil])		rightNamespace: (comparisonSource addedNamespaces at: aBindingReference ifAbsent: [nil]).	^namespaceView</body><body package="Store-Code Comparison">newPackageRollup: aPackageName	| propertiesView |	propertiesView := CodeComponentPropertiesComparisonView new.	propertiesView rightProperties: (comparisonSource addedPackageProperties at: aPackageName ifAbsent: [Array new]).	propertiesView leftProperties: (comparisonSource removedPackageProperties at: aPackageName ifAbsent: [Array new]).	^propertiesView</body><body package="Store-Code Comparison">newSharedVariableRollup: aBindingReference	| sharedVariableView |	sharedVariableView := SharedVariableBlueprintComparisonView new.	sharedVariableView leftSharedVariable: (comparisonSource removedSharedVariables at: aBindingReference ifAbsent: [nil])		rightSharedVariable: (comparisonSource addedSharedVariables at: aBindingReference ifAbsent: [nil]).	^sharedVariableView</body><body package="Store-Code Comparison">populate	| views classKeys namespaceKeys sharedVariableKeys packageKeys bundleKeys |	self updateExpansionMemory.	views := OrderedCollection new.	classKeys := comparisonSource allClassReferences.	namespaceKeys := comparisonSource allNamespaceReferences.	sharedVariableKeys := comparisonSource allSharedVariableReferences.	(((Set withAll: classKeys)		addAll: namespaceKeys;		addAll: sharedVariableKeys;		yourself) sorted: [:a :b | a path last &lt;= b path last])		do: 			[:each |			(namespaceKeys includes: each)				ifTrue: [views add: (self newNamespaceRollup: each)].			(classKeys includes: each)				ifTrue: [views add: (self newClassRollup: each)].			(sharedVariableKeys includes: each)				ifTrue: [views add: (self newSharedVariableRollup: each)]].	packageKeys := comparisonSource allPropertyPackageNames.	bundleKeys := comparisonSource allPropertyBundleNames.	((Set withAll: packageKeys)		addAll: bundleKeys;		yourself) sorted do: 			[:each |			(bundleKeys includes: each)				ifTrue: [views add: (self newBundleRollup: each)].			(packageKeys includes: each)				ifTrue: [views add: (self newPackageRollup: each)]].	self releaseAllComponents.	self addAll: views.	self recallExpansionMemory</body><body package="Store-Code Comparison">recallExpansionMemory	self childrenDo: [:each | each restoreExpandedIn: expansionMemory].	self relayout</body><body package="Store-Code Comparison">updateExpansionMemory	"Assumes all my children are Rollup views."	self childrenDo: 			[:each |			each				rememberIfExpandedIn: expansionMemory;				forgetIfCollapsedIn: expansionMemory]</body></methods><methods><class-id>Store.InitializerFailedError class</class-id> <category>testing</category><body package="Atomic Compiling and Loading">mayResume	^true</body></methods><methods><class-id>Tools.PropertyComparisonView</class-id> <category>row population</category><body package="Store-Code Comparison">computeDetailRows	^Array with: (SideBySideTextComparisonView new				leftText: (self printProperty: leftProperty value)				rightText: (self printProperty: rightProperty value))</body><body package="Store-Code Comparison">populateHeader	| header |	super populateHeader.	header := self header.	header add: ComparisonIcons modify.	header add: (Label with: leftProperty key asText allBold)</body></methods><methods><class-id>Tools.PropertyComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison">leftProperty: aLeftProperty rightProperty: aRightProperty	leftProperty := aLeftProperty.	rightProperty := aRightProperty.	self populate</body></methods><methods><class-id>Tools.PropertyComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison">expansionMemoryKey	^Array with: #compareCodeComponentProperty with: self propertyKey</body></methods><methods><class-id>Tools.PropertyComparisonView</class-id> <category>private</category><body package="Store-Code Comparison">propertyKey	^leftProperty key</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">className	^className</body><body package="Atomic Compiling and Loading">ctype	^ctype</body><body package="Atomic Compiling and Loading">ctype: aBoolean	ctype := aBoolean</body><body package="Atomic Compiling and Loading">definitionString	^storeObject definitionString</body><body package="Atomic Compiling and Loading">extension	^extension</body><body package="Atomic Compiling and Loading">mclass	^shadowCompiledDefinition ifNotNil: [:value | value mclass]</body><body package="Atomic Compiling and Loading">protocol	^storeObject protocol</body><body package="Atomic Compiling and Loading">selector	^selector</body><body package="Atomic Compiling and Loading">superclassNameFrom: aCollectionOfShadowedClasses	"We try to get the image class if it is there, otherwise we use the collection of ShadowedClassObject	and see if we can find the class's superclass there"	storeObject correspondingImageClass ifNotNil: [:value | ^value superclass ifNil: ['nil'] ifNotNil: [:innerValue | innerValue absoluteName]].	^(aCollectionOfShadowedClasses 		detect: [:each | each longName = self className]		ifNone: [^'nil']) superclassName.</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading">compileWith: anAtomicAnalysisLoader	[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDbMethod: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader addUnloadableDefinition: (exception definitionRecord: self).			exception resume]]				on: RedefinitionNotification				do: 					[:notification |					anAtomicAnalysisLoader overrides add: notification.					override := true.					notification resume]</body><body package="Atomic Compiling and Loading">gatherInto: anAtomicAnalysisLoader	anAtomicAnalysisLoader addAllDefinedClassMethods: (Array with: self).</body><body package="Atomic Compiling and Loading">installWith: anAtomicAnalysisLoader	[anAtomicAnalysisLoader installMethod: self]		on: RedefinitionNotification		do: 			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			(self packageModel name = currentPackage name or: [currentPackage name = Registry nullPackageName]) 				ifTrue: [notification resume].			anAtomicAnalysisLoader overrides add: notification.			notification installOverride]</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isExternalMethod	^shadowCompiledDefinition isExternalMethod</body><body package="Atomic Compiling and Loading">isForMethod	^true</body><body package="Atomic Compiling and Loading">isMeta	^storeObject isMeta</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading">printOn: aStream	aStream nextPutAll: 'aShadowedMethod('.	aStream nextPutAll: storeObject signature.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading">initializeFrom: aStoreMethodInPackage	super initializeFrom: aStoreMethodInPackage.	className := aStoreMethodInPackage className.	selector := aStoreMethodInPackage selector.	ctype := aStoreMethodInPackage version = 'CTYPE'.	extension := (package definesClassNamed: className) not</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>comparing</category><body package="Atomic Compiling and Loading">= anObject	^self class = anObject class		and: [self className = anObject className		and: [self selector = anObject selector]]</body><body package="Atomic Compiling and Loading">hash	^(self class hash hashMultiply bitXor: self className hash) hashMultiply bitXor: self selector hash</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentInspectorField</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">isProtected	^true</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentInspectorField</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI">value: anObject	Dialog warn: (#UpdatingChangingPropertiesNotAllowed &lt;&lt; #store &gt;&gt; 'Updating/Changing properties is not allowed on a Store database object')</body></methods><methods><class-id>Store.PseudoNamespaceDefinitionDifference</class-id> <category>loading</category><body package="Store-Difference Management">loadMainDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: mainPackage storeModel		while: [aStoreClassOrNamepace definition loadSource].</body><body package="Store-Difference Management">loadOtherDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: [aStoreClassOrNamepace definition loadSource].</body></methods><methods><class-id>Store.PseudoNamespaceDefinitionDifference</class-id> <category>accessing</category><body package="Store-Difference Management">resolutionClass	^NamespaceChangeResolver</body><body package="Store-Difference Management">selectorListName	^(#BracketNameSpaceDefinition &lt;&lt; #store &gt;&gt; '[NameSpace Definition]') asString</body></methods><methods><class-id>Store.PseudoNamespaceDefinitionDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management">fileOutMainOn: aStream from: aStoreClassOrNamespace	aStoreClassOrNamespace fileOutSourceOn: aStream</body><body package="Store-Difference Management">fileOutOtherOn: aStream from: aStoreClassOrNamespace	aStoreClassOrNamespace fileOutSourceOn: aStream</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="Store-Base">contentsOfEntireBinaryFile	"Answer the contents of a binary file represented by the receiver."	| stream |	stream := self readStream binary.	^[ stream contents ] 		ensure: [ stream close ]</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>private - actions</category><body package="Store-Base">defaultAction	"This catches errors which might occur when we have Store Browsers open, but the database connection has been lost or terminated.	 At this point any database information any open browsers is obsolete and reconnecting the database will not restore	 the browsers to working order.  When this happens there is no browser specific code in the stack in which to place any 	 exception handler, so we need to be notified asynchronously of the event."	| announcement |	announcement := Store.ObsoleteBrowserContent new session: self session.	Announcements announce: announcement.	^super defaultAction.</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>private-compiling</category><body package="Store-Base">compileWithoutUsingChangeFile: code classified: heading notifying: requestor attributes: attributes 	| selector |	self 		compile: code		notifying: requestor		attributes: attributes		selectorBlock: [:sel :oldMeth | selector := sel]		ifFail: [^nil].	(methodDict at: selector) sourcePointer: code.	self organization classify: selector under: heading.	^selector</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>binary storage</category><body package="Store-Base">binoutOn: outputStream	self timeStampFileOut.	outputStream nextPutPackage: self</body></methods><methods><class-id>Core.Object</class-id> <category>tt-utilities</category><body package="Store-Base">debugVersionOnly	"Senders of this method should be present	in the development version only."</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Store-Base">isForNameSpace	^false</body></methods><methods><class-id>Core.Object</class-id> <category>tt-utilities</category><body package="Store-Base">needsMoreWork	"Senders of this method require redesign.."</body><body package="Store-Base">textRepresentation	^self printString.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="Store-Base">equalsAcrossPlatforms: aCharacterArray	"Answer whether the argument and the receiver's size is the same as aCharacterArray's size, 	and each of the receiver's elements equal the corresponding element of aCharacterArray.	Notes: 		The platforms are: Gemstone and VisualWorks.		We hope the future will have Gemstone bring source in the future to be VW format (CR)		If that happens then this can be much faster by no longer having to do this."		| eofs |	aCharacterArray isCharacters ifFalse: [^false].	self size = aCharacterArray size ifFalse: [^false].	eofs := Array with: Character lf with: Character cr with: (Character value: 11).	self with: aCharacterArray do: 		[:char1 :char2 | 		char1 = char2 ifFalse: [((eofs includes: char1) and: [eofs includes: char2])			ifFalse: [^false]]].	^true</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-accessing</category><body package="Store-Broker-Obsolete">cursor: anObj</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>accessing</category><body package="Store-Broker-Obsolete">storeBroker	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-accessing</category><body package="Store-Broker-Obsolete">nilParams</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Store-Image Objects">isDataModel	"Is this a Bernstein data model?"	^false</body></methods><methods><class-id>Core.Metaclass</class-id> <category>team tools</category><body package="Store-Image Objects">classSymbol	^self soleInstance name</body><body package="Store-Image Objects">nonMeta	^self soleInstance</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>converting</category><body package="Store-Image Objects">asCommentTag	"Answer an instance of TT_ClassCommentTag"	^ClassCommentTag newClassName: self absoluteName</body><body package="Store-Image Objects">asTag	"Answer an instance of TT_ClassTag."	^ClassTag newClassName: self absoluteName isMeta: self isMeta</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="Store-Image Objects">definitionAndComment		| class |	(class := self myClass) isNil 		ifTrue: [^''] 		ifFalse: [^'&lt;1s&gt;&lt;nn&gt;COMMENT:&lt;n&gt;&lt;2s&gt;' expandMacrosWith: class definition with: class comment]</body><body package="Store-Image Objects">package	"Answer the package that contains the class that this descriptor describes.	 If none can be found, then answer nil.  This method is intended to provide 	 polymorphic behavior with ClassRecord so that the PackageComparisonApplication	 can handle both instances of ClassRecord and ClassDescriptor."	^Registry containingPackageForClassSymbol: self absoluteSymbol</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>comparing</category><body package="Store-Image Objects">sameAsDBThing: aClass	^aClass sameAsImThing: self</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>private-store</category><body package="Store-Image Objects">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different classes it computed.  If the 	 list of classes already has the same class then remove it because it will be	 the class in the system (the override) and add the overridden version of the	 class (the receiver).  Otherwise, simply add the receiver to the list of different 	 classes."	| classes classDescriptor |	classes := self diffs: packageDifferences side: side.	classDescriptor := classes 				detect: [:descriptor | descriptor absoluteName = self absoluteName]				ifNone: [nil].	classDescriptor 		ifNotNil: [classes remove: classDescriptor].	classes add: self</body><body package="Store-Image Objects">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different classes it computed.  If the 	 list of classes already has the same class then remove it because it will be	 the class in the system (the override) and add the overridden version of the	 class (the receiver).  Otherwise, simply add the receiver to the list of different 	 classes."		| classes classDescriptor |	classes := self otherDiffs: aPackageComparitor.	classDescriptor := classes 		detect: [:descriptor | descriptor absoluteName = self absoluteName] 		ifNone: [nil].	classDescriptor ifNotNil: [classes remove: classDescriptor].	classes add: self</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="Store-Image Objects">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		classInPackageNamed: self absoluteName 		meta: self isMeta</body><body package="Store-Image Objects">definitionAndComment	^'&lt;1s&gt;&lt;nn&gt;COMMENT:&lt;n&gt;&lt;2s&gt;' expandMacrosWith: self text with: self comment</body><body package="Store-Image Objects">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^self isMeta		ifTrue: [ diffs metaSide: side ]		ifFalse: [ diffs classesSide: side ]</body><body package="Store-Image Objects">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageClasses]		ifFalse: [aPackageComparitor classesSide: 1]</body><body package="Store-Image Objects">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageClasses]		ifFalse: [aPackageComparitor classesSide: 2]</body></methods><methods><class-id>Core.Class</class-id> <category>store tools</category><body package="Store-Image Objects">classSymbol	^self name</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="Store-Image Objects">decode: aByteArray	"self decode: (self encode: self new)"	| stream bos data |	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	data := bos next.	bos close.	^data</body></methods><methods><class-id>Core.Class</class-id> <category>store tools</category><body package="Store-Image Objects">nonMeta	^self</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="Store-Image Objects">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self dataAt: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printString asText</body></methods><methods><class-id>Kernel.Override</class-id> <category>private-store</category><body package="Store-Image Objects">addDiffTo: aStorePackage into: aPackageComparitor	"Add the appropiate diff to a difference holder."	"NOTE: called after other diffs have been calculated, so got to clean out db version."		| storeRecord |	(storeRecord := self dbVersionFrom: aStorePackage) ifNil: 		[^self addOrReplaceInOtherDiffs: aPackageComparitor].	(storeRecord sourceMatches: self)		ifTrue: [(self mainDiffs: aPackageComparitor) remove: storeRecord ifAbsent: [nil]]		ifFalse:			[(self mainDiffs: aPackageComparitor) add: storeRecord.			(self otherDiffs: aPackageComparitor) add: self]</body><body package="Store-Image Objects">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different definitions it has computed.  If the 	 differences already have the same definition then remove it because it will be	 the definition in the system (the override) and add the overridden version of the	 definition (the receiver).  Otherwise, simply add the receiver to the list of different 	 definitions."		self subclassResponsibility</body><body package="Store-Image Objects">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different definitions it has computed.  If the 	 differences already have the same definition then remove it because it will be	 the definition in the system (the override) and add the overridden version of the	 definition (the receiver).  Otherwise, simply add the receiver to the list of different 	 definitions."		self subclassResponsibility</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="Store-Image Objects">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	self subclassResponsibility</body><body package="Store-Image Objects">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	self subclassResponsibility</body><body package="Store-Image Objects">mainDiffs: aPackageComparitor	self subclassResponsibility</body><body package="Store-Image Objects">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	self subclassResponsibility.</body><body package="Store-Image Objects">myClass    ^self implementingClass</body><body package="Store-Image Objects">otherDiffs: differances	self subclassResponsibility</body><body package="Store-Image Objects">primaryKey	^0</body></methods><methods><class-id>Kernel.Override</class-id> <category>private-store</category><body package="Store-Image Objects">setOverriddenDefinition: aMessageSend	definition := aMessageSend</body><body package="Store-Image Objects">source	^self text</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="Store-Image Objects">sourceMatches: anObject	"Answer whether the source matches."	^anObject sourceMatches: self.</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>converting</category><body package="Store-Image Objects">asTag	"Answer an instance of TT_MethodTag."	^MethodTag newClassName: self fullClassName selector: self selector meta: self isMeta.</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>comparing</category><body package="Store-Image Objects">sameAsDBThing: aMethod 	"When comparing with DB method take protocol into account."	| cls |	(cls := self myClass) ifNil: [^false].	^(cls includesSelector: self selector)		and: [aMethod sameAsSelector: self selector class: cls]</body><body package="Store-Image Objects">sourceMatches: aMethod	"Answer whether the source match."		^self protocol = aMethod protocol		and: [self sourceCode equalsAcrossPlatforms: aMethod sourceCode]</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing</category><body package="Store-Image Objects">textRepresentationForTag: aTag	^self sourceCode</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>private-store</category><body package="Store-Image Objects">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different methods it computed.  If the 	 list of methods already has the same method then remove it because it will be	 the method in the system (the override) and add the overridden version of the	 method (the receiver).  Otherwise, simply add the receiver to the list of different 	 methods."	| methods methodDescriptor |	methods := self diffs: packageDifferences side: side.	methodDescriptor := methods detect: 					[:descriptor | 					descriptor classNameWithMeta = self classNameWithMeta and: 							[descriptor selector = self selector and: 									[descriptor protocol = self protocol and: [descriptor isMeta = self isMeta]]]]				ifNone: [nil].	methodDescriptor ifNotNil: [methods remove: methodDescriptor].	methods add: self</body><body package="Store-Image Objects">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different methods it computed.  If the 	 list of methods already has the same method then remove it because it will be	 the method in the system (the override) and add the overridden version of the	 method (the receiver).  Otherwise, simply add the receiver to the list of different 	 methods."		| methods methodDescriptor |	methods := self otherDiffs: aPackageComparitor.	methodDescriptor := methods		detect:			[:descriptor | 			descriptor classNameWithMeta = self classNameWithMeta and: 				[descriptor selector = self selector and: 				[descriptor protocol = self protocol and: 				[descriptor isMeta = self isMeta]]]]		ifNone: [nil].	methodDescriptor ifNotNil: [methods remove: methodDescriptor].	methods add: self</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="Store-Image Objects">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		method: self selector 		forClassNamed: self implementingClass absoluteName 		meta: self isMeta</body><body package="Store-Image Objects">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs methodsSide: side</body><body package="Store-Image Objects">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageMethods]		ifFalse: [aPackageComparitor methodsSide: 1]</body><body package="Store-Image Objects">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	#{Store.XChangeSet} ifDefinedDo:		[ :xs | xs current moveSelector: self selector class: self owner toPackage: aPackage ]</body><body package="Store-Image Objects">myClass	"Answer ther receiver's class. Compatibility."	^self implementingClass</body><body package="Store-Image Objects">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageMethods]		ifFalse: [aPackageComparitor methodsSide: 2]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>comparing</category><body package="Store-Image Objects">sameAsDBThing: aMethod 	aMethod isMeta = self isMeta ifFalse: [ ^false ].	self absoluteClassName = aMethod absoluteClassName ifFalse: [ ^false ].	self selector = aMethod selector ifFalse: [ ^false ].	self protocol = aMethod protocol ifFalse: [^false].	^self sourceCode asString = aMethod sourceCode asString.</body><body package="Store-Image Objects">sameAsImThing: aMethod	^self classNameWithMeta = aMethod classNameWithMeta		and: [self selector = aMethod selector		and: [(self sources notEmpty ifTrue: [self sources any]) = (aMethod sources notEmpty ifTrue: [aMethod sources any])]]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>private-store</category><body package="Store-Image Objects">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different shareds it computed.  If the 	 list of shareds already has the same shared then remove it because it will be	 the shared in the system (the override) and add the overridden version of the	 shared (the receiver).  Otherwise, simply add the receiver to the list of different 	 shareds."	| shareds sharedDescriptor |	shareds := packageDifferences dataSide: side.	sharedDescriptor := shareds 				detect: [:descriptor | descriptor absoluteName = self absoluteName]				ifNone: [nil].	sharedDescriptor ifNotNil: [shareds remove: sharedDescriptor].	shareds add: self</body><body package="Store-Image Objects">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different shareds it computed.  If the 	 list of shareds already has the same shared then remove it because it will be	 the shared in the system (the override) and add the overridden version of the	 shared (the receiver).  Otherwise, simply add the receiver to the list of different 	 shareds."		| shareds sharedDescriptor |	shareds := self otherDiffs: aPackageComparitor.	sharedDescriptor := shareds 		detect: [:descriptor | descriptor absoluteName = self absoluteName] 		ifNone: [nil].	sharedDescriptor ifNotNil: [shareds remove: sharedDescriptor].	shareds add: self</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="Store-Image Objects">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		datum: self key		forNamed: self owner absoluteName</body><body package="Store-Image Objects">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs dataSide: side</body><body package="Store-Image Objects">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageShareds]		ifFalse: [aPackageComparitor dataSide: 1]</body><body package="Store-Image Objects">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	#{Store.XChangeSet} ifDefinedDo:		[ :xs | xs current moveDataKey: self dataKey owner: self owner toPackage: aPackage ]</body><body package="Store-Image Objects">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageShareds]		ifFalse: [aPackageComparitor dataSide: 2]</body><body package="Store-Image Objects">sourceMatches: aDatum 	"Answer whether the source matches."	^self text equalsAcrossPlatforms: aDatum definition</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="Store-Image Objects">decode: aByteArray	"self decode: (self encode: self new)"	| stream bos data |	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	data := bos next.	bos close.	^data</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store utils</category><body package="Store-Image Objects">definitionOf: aSymbol ifAbsent: aBlock	| binding |	( binding := self bindingFor: aSymbol ) == nil		ifTrue: [ ^aBlock value ].	^binding isForGeneral		ifTrue: [ self definitionOfStatic: binding ] 		ifFalse: [ binding value definition ]</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="Store-Image Objects">encode: data	"self encode: self new"	| stream bos |	stream := WriteStream on: ByteArray new.	bos := BinaryObjectStorage onNew: stream.	bos nextPut: data.	bos close.	^stream contents</body><body package="Store-Image Objects">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self definitionOf: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printString asText</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>converting</category><body package="Store-Image Objects">asTag	"Answer an instance of TT_DataTag."	^self isInClass		ifTrue: [ 	DataTag newClassName: self ownerName dataKey: self dataKey ]		ifFalse: [ DataTag newNameSpaceName: self ownerName dataKey: self dataKey ]</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="Store-Image Objects">package	"Answer the package that contains the shared variable that this descriptor describes.	 If none can be found, then answer nil.  This method is intended to provide 	 polymorphic behavior with DataElement so that the PackageComparisonApplication	 can handle both instances of DataElement and DatumDescriptor."	^Registry containingPackageForDataKey: dataKey symbol: self owner absoluteSymbol</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>comparing</category><body package="Store-Image Objects">sameAsDBThing: aDatum 	"When comparing with DB - the definition has it all"	"Note: at the moment, no comments for data."	^self definition = aDatum definition</body><body package="Store-Image Objects">sourceMatches: aDatumDescriptor 	"Answer whether the source matches.	Note: since protocol is part of the definition, we don't need to check it."	^aDatumDescriptor notNil and: [self definition equalsAcrossPlatforms: aDatumDescriptor definition]</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="Store-Image Objects">textRepresentationForTag: aTag	^self definition</body></methods><methods><class-id>Store.Model</class-id> <category>testing</category><body package="Store-Image Objects">isForFile	^false</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>converting</category><body package="Store-Image Objects">asCommentTag	"Answer an instance of NameSpaceCommentTag"	^NameSpaceCommentTag newNameSpaceName: self absoluteName</body><body package="Store-Image Objects">asTag	"Answer an instance of TT_NameSpaceTag"	^NameSpaceTag newNameSpaceName: self absoluteName</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>accessing</category><body package="Store-Image Objects">definitionAndComment		| namespace |	(namespace := self nameSpace) isNil 		ifTrue: [^''] 		ifFalse: [^'&lt;1s&gt;&lt;nn&gt;COMMENT:&lt;n&gt;&lt;2s&gt;' expandMacrosWith: namespace definition with: namespace comment]</body><body package="Store-Image Objects">package	"Answer the package that contains the name space that this descriptor describes.	 If none can be found, then answer nil.  This method is intended to provide 	 polymorphic behavior with NameSpaceRecord so that the PackageComparisonApplication	 can handle both instances of NameSpaceRecord and NameSpaceDescriptor."	^Registry containingPackageForNameSpaceSymbol: self absoluteSymbol</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>comparing</category><body package="Store-Image Objects">sameAsDBThing: aNameSpace	^aNameSpace sameAsImThing: self</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>private-store</category><body package="Store-Image Objects">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different namespaces it computed.  If the 	 list of namespaces already has the same namespace then remove it because it will be	 the namespace in the system (the override) and add the overridden version of the	 namespace (the receiver).  Otherwise, simply add the receiver to the list of different 	 namespaces."	| namespaces namespaceDescriptor |	namespaces := self diffs: packageDifferences side: side.	namespaceDescriptor := namespaces 				detect: [:descriptor | descriptor absoluteName = self absoluteName]				ifNone: [nil].	namespaceDescriptor 		ifNotNil: [namespaces remove: namespaceDescriptor].	namespaces add: self</body><body package="Store-Image Objects">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different namespaces it computed.  If the 	 list of namespaces already has the same namespace then remove it because it will be	 the namespace in the system (the override) and add the overridden version of the	 namespace (the receiver).  Otherwise, simply add the receiver to the list of different 	 namespaces."		| namespaces namespaceDescriptor |	namespaces := self otherDiffs: aPackageComparitor.	namespaceDescriptor := namespaces 		detect: [:descriptor | descriptor absoluteName = self absoluteName] 		ifNone: [nil].	namespaceDescriptor ifNotNil: [namespaces remove: namespaceDescriptor].	namespaces add: self</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="Store-Image Objects">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage nameSpaceInPackageNamed: self absoluteName</body><body package="Store-Image Objects">definitionAndComment	^'&lt;1s&gt;&lt;nn&gt;COMMENT:&lt;n&gt;&lt;2s&gt;' expandMacrosWith: self text with: self comment</body><body package="Store-Image Objects">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs nameSpacesSide: side</body><body package="Store-Image Objects">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageNamespaces]		ifFalse: [aPackageComparitor nameSpacesSide: 1]</body><body package="Store-Image Objects">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageNamespaces]		ifFalse: [aPackageComparitor nameSpacesSide: 2]</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>private</category><body package="Store-Component Support">descriptionsAndLevels	"Answer a list of pairs. The first element contains a descriptions the second the 	level on which the description was found."	| comp coll |	comp := self component.	comp isNil ifTrue: [^#()].	coll := comp descriptionsAndLevels.	coll do: [:pair | pair at: 2 put: (pair at: 2) + 1].	coll addFirst: (Array with: self with: 1).	^coll</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="Store-Component Support">addFileDescription: aFilename	"Add the file specified by aFilename to the contents"	|filename|	filename := aFilename asLogicalFileSpecification.	( self fileDescriptions contains: [ :fm | fm portableFilename = filename ] )		ifTrue: [ ^false ].		self fileDescriptions add: ( ( FileModel from: filename ) bundle: self pundle ).	self shouldTrackChanges 		ifTrue: [ self addOtherChange: BundleModel fileMark ].	^true</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>accessing</category><body package="Store-Component Support">fileDescriptions		fileDescriptions == nil		ifTrue: [ fileDescriptions := List new.].	^fileDescriptions</body><body package="Store-Component Support">fileDescriptions: aCollection	fileDescriptions := aCollection asList.	fileDescriptions do: [:fd | fd bundle: self pundle]</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="Store-Component Support">removeFile: aFileDescription	"Remove aFileDescription to the contents"	aFileDescription isString		ifTrue: [ fileDescriptions do: 					[ :fd | fd portableFilename asString = aFileDescription							ifTrue: [ ^self removeFile: fd ]					].				^true				]		ifFalse: [ fileDescriptions remove: aFileDescription ifAbsent: nil ].	self shouldTrackChanges 		ifTrue: [ self addOtherChange: BundleModel fileMark ].	^true</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="Store-Component Support">resetContentsFrom: aBundleConnectionInformation	"Make this database information adopt the parameter information's view of what pundles the bundle contains and in what order.  Since addComponentDescription: is lazy (does nothing if it is already there), the first statement only adds pundles we do not already have.  The second removes pundles which we have but which the newly loaded version does not have.  If the two content description collections are still not equal (content description equality only checks names) then we resort our pundle orders to match that of the (about-to-be) loaded pundle."	(self copy initializeContentsFrom: aBundleConnectionInformation)		contentDescriptions do: [:each | self addComponentDescription: each].	(contentDescriptions reject:		[:each | aBundleConnectionInformation contentDescriptions includes: each])			do: [:each | self removeComponentDescription: each].	contentDescriptions = aBundleConnectionInformation contentDescriptions ifFalse:		[self shouldTrackChanges ifTrue: [self addOtherChange: pundle structureMark].		Registry changedBundleStructure: self pundle.		SequenceableCollectionSorter			sort: contentDescriptions			using: [:a :b | (aBundleConnectionInformation contentDescriptions indexOf: a)						&lt; (aBundleConnectionInformation contentDescriptions indexOf: b)]].</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>api</category><body package="Store-Component Support">ensureLoadedParcel: parcelName withVersion: versionString forPundle: aPundle	"Check if a Parcel named parcelName is loaded with an appropriate version.	 If its not then attempt to load it."	"Called while trying to meet a Store parcel prerequisite"	| newParcel |	Cursor wait showWhile:		[self withFileCachesDo: 			[newParcel := self								ensureLoadedParcel: parcelName								withVersion: versionString								for: aPundle]].	self broadcastParcels.	^newParcel</body><body package="Store-Component Support">ensureLoadedParcel: parcelName withVersion: versionString forPundle: aPundle with: aCompilationManager	"Check if a Parcel named parcelName is loaded with an appropriate version.	 If its not then attempt to load but not install it.	Called while trying to meet a Store parcel prerequisite"		| uninstalledParcel |	self withFileCachesDo: 		[uninstalledParcel := self ensureLoadedParcel: parcelName withVersion: versionString for: aPundle with: aCompilationManager].	aCompilationManager ifNotNil: [aCompilationManager reinitializeShadowRoot].	^uninstalledParcel</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>updating</category><body package="Store-Component Support">traceChangedForComponent: aCodeComponent"	self changed: #parcelTraceChanged with: aCodeComponent"</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>accessing</category><body package="Store-Component Support">pundleName	"Used by parcel resolving pundle prereqs- Answers a name regardless"	( name := self bundleName ) == nil		ifTrue: 			[ ( name := self packageName ) == nil 				ifTrue: [ name := self name ].			].	^name</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>testing</category><body package="Store-Component Support">exactLoadedComponent	"Find if a bundle with my id is loaded into the image."	id isNil ifTrue: [^nil].	Registry packagesDo: 		[ :pkg | 		( pkg dbTraceFor: dbIdentifier ) = id 			ifTrue: 				[ ^pkg hasBeenModified					ifTrue: [ nil ]					ifFalse: [ pkg ]				]		].	^nil</body><body package="Store-Component Support">isLoaded	"Find if a package fulfilling 	my description is loaded into the image."	^Registry isPackageLoaded: self name</body><body package="Store-Component Support">loadedComponent	"Find if a package fulfilling exactly my description is loaded into the image."	componentName == nil		ifFalse: [ ^Registry packageNamed: componentName ].	id isNil ifTrue: [ ^nil ].	Registry packagesDo: 		[ :pkg | 		( pkg dbTraceFor: dbIdentifier ) = id 			ifTrue: 				[ ^pkg hasBeenModified					ifTrue: [ nil ]					ifFalse: [ pkg ]				]		].	^nil</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="Store-Component Support">createPDPBundle	"Creates the PDP bundle from the tobc file created with:		( Store.Registry bundleNamed: 'PDP 3.0' ) 				tableOfBundleContentsOnFile: 'pdp.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'pdp.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="Store-Component Support">createRBBundle	"Creates the system bundle from the tobc file created with:		( Store.Registry bundleNamed: 'RefactoringBrowser' ) 				tableOfBundleContentsOnFile: 'RefactoringBrowser.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'RefactoringBrowser.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="Store-Component Support">createToolsBundle	"Creates the Tools bundle from the tobc file created with:		( Store.Registry bundleNamed: 'Tools-IDE' ) 				tableOfBundleContentsOnFile: 'Tools-IDE.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'Tools-IDE.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>parcel load/unload/save</category><body package="Store-Component Support">postLoadActionFor: aParcel 	self createStoreBundle: aParcel</body><body package="Store-Component Support">preUnloadActionFor: aParcel "Removed for now... reinstate if major UI changes made	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel."</body><body package="Store-Component Support">preUpdateActionFor: aParcel	"Do the part of postLoad necessary for Store to update itself."	Override registerSourceManager: Store.Registry.	self addImports.	( Store.Registry dependents includes: Store.Registry )		ifFalse: [ Store.Registry addDependent: Store.Registry ].</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-bundle</category><body package="Store-Component Support">allBundlesWithNewerInDB	"Answer a collection of packages with newer published versions."	"Store.Registry allBundlesWithNewerInDB"	^self allBundlesWithNewerInDBIn: Store.Glorp.StoreLoginFactory currentStoreSession</body><body package="Store-Component Support">allBundlesWithNewerInDBIn: aSession	"Answer a collection of packages with newer published versions."	"Store.Registry allBundlesWithNewerInDB"		^Store.Glorp.StoreBundle allPundlesIn: bundles withNewerInDBIn: aSession</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-package</category><body package="Store-Component Support">allPackagesWithNewerInDB	"Answer a collection of packages with newer published versions."	"Store.Registry allPackagesWithNewerInDB"	^self allPackagesWithNewerInDBIn: Store.Glorp.StoreLoginFactory currentStoreSession</body><body package="Store-Component Support">allPackagesWithNewerInDBIn: aSession	"Answer a collection of packages with newer published versions."	^Store.Glorp.StorePackage allPundlesIn: packages withNewerInDBIn: aSession</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="Store-Component Support">checkUnpublishedPundlesOn: aStream 	| first |	first := true.	self packagesDo: 			[:pkg | 			pkg hasBeenModified 				ifTrue: 					[first 						ifTrue: 							[aStream								nextPutAll: (#TheFollowingPackagesAreModified &lt;&lt; #store 											&gt;&gt; 'The following packages are modified:') asString;								cr.							first := false].					aStream						tab;						nextPutAll: pkg name;						cr]].	first ifFalse: [aStream cr].	first := true.	self bundlesDo: 			[:bndl | 			bndl hasBeenModified 				ifTrue: 					[first 						ifTrue: 							[aStream								nextPutAll: (#TheFollowingBundlesAreModified &lt;&lt; #store 											&gt;&gt; 'The following bundles are modified:') asString;								cr.							first := false].					aStream						tab;						nextPutAll: bndl name;						cr]]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>change set conversion</category><body package="Store-Component Support">conversionSetForComponentChange: aComponentChange into: pkgDictionary	"Private- get the appropiate package for a change, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet, nil if not for us."	 | pkg thePackage |	pkg := aComponentChange component.	( pkg == nil or: [ pkg isPackage not ] )		ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-Component Support">conversionSetForDataKey: key in: aClassOrNameSpace into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForDataKey: key symbol: aClassOrNameSpace absoluteSymbol.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-Component Support">conversionSetForDataRemoval: aName into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer an array with the changeSet and the removed DatumDescriptor."	 | pkg thePackage descr |	pkg := self allPackages detect:			[ :p | ( p changeSet removedDatumDescriptors collect: [ :dd | dd fullName ] ) includes: aName ]						ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	descr := pkg removedDatumDescriptors select: [ :dd | dd fullName = aName ].	^Array with: thePackage changeSet with: descr first</body><body package="Store-Component Support">conversionSetForDefinition: aClassOrNameSpace into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForSymbol: aClassOrNameSpace absoluteSymbol.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-Component Support">conversionSetForDefinitionRemoval: aName into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self allPackages detect:			[ :p | p changeSet removedNameSpaceOrDefinitionNames includes: aName ] ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-Component Support">conversionSetForMethodRemoval: selector className: aName meta: meta into: pkgDictionary	"Private- look up the appropiate package for a method, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage descr |	pkg := self allPackages detect:			[ :p | p changeSet removedMethodDescriptors contains: 				[ :md | 				descr := md.				( ( md isMeta = meta ) &amp; ( md selector = selector ) ) 						and: [ md className = aName ]				]			] ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet</body><body package="Store-Component Support">conversionSetForSelector: selector in: aClass into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForSelector: selector class: aClass.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-Component Support">convertComponentChange: aComponentChange into: pkgDictionary	"Private-Add the component change to aChangeSet."	 | xcs |	xcs := self conversionSetForComponentChange: aComponentChange into: pkgDictionary.	xcs == nil		ifFalse: [ aComponentChange doChangeTo: xcs ].</body><body package="Store-Component Support">convertDefinitionChanges: aClassOrNameSpace into: pkgDictionary from: aChangeSet	"Private-Look up aClassOrNameSpace that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change real |	real := aClassOrNameSpace isForClass				ifTrue: [ aClassOrNameSpace instanceBehavior ]				ifFalse: [ aClassOrNameSpace ].	( aChangeSet changeTypesFor: real fullName ) isEmpty		ifTrue: [ ^self ].		"no definition changes."	xcs := self conversionSetForDefinition: real into: pkgDictionary.	change :=  aClassOrNameSpace isForClass 		ifTrue: [ Change new class: real ]		ifFalse: [ Change new nameSpace: real ].	( aChangeSet atClass: aClassOrNameSpace includes: #add )		ifTrue: 			[ xcs doChange: change add.			"Since added classes include all selectors for that class, get them here."			( real isForClass and: [  aClassOrNameSpace isMeta not ] )				ifTrue: [ self convertRestOfClassAdd: real into: pkgDictionary from: aChangeSet ].			].	( aChangeSet atClass: aClassOrNameSpace includes: #change )				ifTrue: [ xcs doChange: change change ].	( aChangeSet atClass: aClassOrNameSpace includes: #comment )		ifTrue: [ xcs doChange: change comment ].	( aChangeSet atClass: aClassOrNameSpace includes: #reorganize )		ifTrue: [ xcs doChange: change reorganize ].</body><body package="Store-Component Support">convertMethodChange: methodDescriptor into: pkgDictionary from: aChangeSet	"Private-Look up aClass that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change type |	xcs := self conversionSetForSelector: methodDescriptor selector in: methodDescriptor implementingClass into: pkgDictionary.	change :=  Change new 				class: methodDescriptor implementingClass; 				selector: methodDescriptor selector.	type := aChangeSet atSelector: methodDescriptor selector class: methodDescriptor implementingClass.	change perform: type.	xcs doSubdefChange: change.</body><body package="Store-Component Support">convertMethodRemoval: selector className: className into: pkgDictionary	"Private- className&gt;&gt;selector was removed. Class may not exist. Figure out where it was removed from."	 | xcs name meta |	meta := className namesMetaClass.	name := SystemUtils convertFullNameToAbsolute: className asClassNameOnly.	( xcs := self conversionSetForMethodRemoval: selector className: name meta: meta into: pkgDictionary ) == nil		ifTrue: [ ^self ].	xcs doSubdefChange: ( Change new classSymbol: name asSymbol; meta: meta; selector: selector; remove ).</body><body package="Store-Component Support">convertNamedChangeSet: aChangeSet	"Answer a dictionary of package copies with changelist determined by aChangeSet"	"Store.Registry convertNamedChangeSet: ( NamedChangeSet lookup: #test )"	| pkgDictionary |	pkgDictionary := Dictionary new.		aChangeSet changedNameSpaces do:		[ :ns | self convertDefinitionChanges: ns into: pkgDictionary from: aChangeSet ].	aChangeSet changedClasses do: 		[ :cls | self convertDefinitionChanges: cls into: pkgDictionary from: aChangeSet ].	aChangeSet changedMessageList do:		[ :md | self convertMethodChange: md into: pkgDictionary  from: aChangeSet ].	aChangeSet changedStatics do:		[ :name | self convertStaticChange: name into: pkgDictionary  from: aChangeSet ].	aChangeSet objectRemoves keysAndValuesDo:		[ :key :value | self convertRemoval: key type: value into: pkgDictionary ].	aChangeSet removedMethodsDo:		[ :className :selector | self convertMethodRemoval: selector className: className into: pkgDictionary ].	aChangeSet componentChangesDo:		[ :componentChange | self convertComponentChange: componentChange into: pkgDictionary ].	^pkgDictionary</body><body package="Store-Component Support">convertRemoval: aString type: aSymbol into: pkgDictionary	"Private- aString names a class/namespace/static indicated by type. Figure out where it was removed from."	 | xcs name change descr array |	name := SystemUtils convertFullNameToAbsolute: aString.	change := Change new remove.	aSymbol == #variable		ifTrue:			[ ( array := self conversionSetForDataRemoval: name into: pkgDictionary ) == nil				ifTrue: [ ^self ].			xcs := array first.			descr := array last.			descr isInClass				ifTrue: [ change classSymbol: descr ownerName asSymbol ]				ifFalse: [ change nameSpaceSymbol: descr ownerName asSymbol ].			change dataKey: descr key.			xcs doSubdefChange: change.			]		ifFalse: 			[ "must be class or namespace"			( xcs := self conversionSetForDefinitionRemoval: name into: pkgDictionary ) == nil				ifTrue: [ ^self ].			aSymbol == #class				ifTrue: [ change classSymbol: name asSymbol ]				ifFalse: [ change nameSpaceSymbol: name asSymbol ].			xcs doChange: change.			].</body><body package="Store-Component Support">convertRestOfClassAdd: aClass into: pkgDictionary from: aChangeSet	"Private-Look up aClass that came from a ChangeSet and create changes in the appropiate packages."	aClass selectors do:		[ :selector | | xcs change |		xcs := self conversionSetForSelector: selector in: aClass into: pkgDictionary.		change :=  Change new class: aClass; selector: selector; add.		xcs doSubdefChange: change.		].	aClass class selectors do:		[ :selector | | xcs change |		xcs := self conversionSetForSelector: selector in: aClass into: pkgDictionary.		change :=  Change new class: aClass; selector: selector; add.		xcs doSubdefChange: change.		].</body><body package="Store-Component Support">convertStaticChange: aString into: pkgDictionary from: aChangeSet	"Private-Look up a static that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change ref env |	ref := aString asStrictReference.	env := ref environment.	change := env isForClass		ifTrue: [ Change new class: env ]		ifFalse: [ Change new nameSpace: env ].	xcs := self conversionSetForDataKey: ref simpleName in: env into: pkgDictionary.	change dataKey: ref simpleName.	( aChangeSet atName: aString includes: #add )		ifTrue: [ change add ].	( aChangeSet atName: aString includes: #change )		ifTrue: [ change change ].		xcs doSubdefChange: change.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="Store-Component Support">makeConsistent	"Review state of the image. All Packages remove bogus changeSet references &amp; 	the Registry needs to validate nil class defs."	"Store.Registry makeConsistent"		( packages keys select: [ : key | key isSymbol ] ) do:		[ :key | 	packages at: key asString put: ( packages removeKey: key ) ].	( bundles keys select: [ : key | key isSymbol ] ) do:		[ :key | 	bundles at: key asString put: ( bundles removeKey: key ) ].	self packagesDo: 		[ :pkg | pkg makeConsistent ].	modelDictionary associationsDo:		[ :assoc | 	| pkg |		assoc value first == nil			ifTrue: 				[ ( pkg := packages detect: [ :p | p includesDefinitionOf: assoc key ] ) == nil					ifFalse: [ modelDictionary at: assoc key put: ( pkg modelAtSymbol: assoc key asSymbol ifAbsent: nil ) ]				]		]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>utility</category><body package="Store-Component Support">removeDatabaseLinks	"Remove the all loaded pundles to a different database.	Store.Registry removeDatabaseLinks"		| allPundles identifiersToRemove |	allPundles := self allBundles , self allPackages.	identifiersToRemove := PundleModel		selectDatabasesFor: allPundles		prompt: (#SelectDatabasesToUnlink &lt;&lt; #store &gt;&gt; 'Select databases to unlink') asString.	identifiersToRemove isEmpty ifTrue: [^self].	allPundles do: [:each | each removeDbInformationFor: identifiersToRemove].	Store.DbRegistry refreshBrowsers</body><body package="Store-Component Support">switchDatabases	"Reconcile the all loaded pundles to a different database."	"Store.Registry switchDatabases"		| pundleModels databaseIdentifiers |	pundleModels := self allBundles , self allPackages.	databaseIdentifiers := Set new.	pundleModels do: [:eachPundleModel | databaseIdentifiers addAll: eachPundleModel allDatabases].	databaseIdentifiers remove: DbRegistry dbIdentifier ifAbsent: nil.	databaseIdentifiers := databaseIdentifiers reject:		[:eachIdentifier | 		Dialog confirm: (#MaintainExistingLinksTo1s &lt;&lt; #store &gt;&gt; 'Maintain existing links to: &lt;1s&gt;?' expandMacrosWith: eachIdentifier)].	self switchDatabases: pundleModels remove: databaseIdentifiers</body><body package="Store-Component Support">switchDatabases: aCollectionOfPundleModel remove: aCollectionOfDatabaseIdentifiers 	"Reconcile the pundles in aPundleCollection to a different database."	| which trace |	which := Dialog 		choose: #WhichVersionsShouldBeUsedToReconcile &lt;&lt; #store &gt;&gt; 'Which versions should be used to reconcile?'		labels: (Array 			with: (#UseMostRecentlyPublished &lt;&lt; #store  &gt;&gt; 'Use most recently published?') asString			with: (#SelectPublishedVersions &lt;&lt; #store &gt;&gt; 'Select published versions') asString			with: (#Cancel &lt;&lt; #store &gt;&gt; 'Cancel') asString)		values: #(#recent #select #cancel)		default: #recent.	which == #cancel ifTrue: [^self].	aCollectionOfPundleModel do: [:eachPundleModel | eachPundleModel removeDbs: aCollectionOfDatabaseIdentifiers].		[aCollectionOfPundleModel do: 		[:eachPundleModel | 		eachPundleModel dbTrace ifNil: 			[trace := which == #recent 				ifTrue: [eachPundleModel newestVersionWithName: eachPundleModel name]				ifFalse: [eachPundleModel selectStoreVersionWarnIfNone: false].			trace isNil				ifTrue: 					[Transcript						cr;						show: (#CouldNotReconcile2sColon1s &lt;&lt; #store &gt;&gt; 'Could not reconcile &lt;2s&gt;: &lt;1s&gt;' 								expandMacrosWith: eachPundleModel name								with: eachPundleModel classDescription)]				ifFalse: 					[[eachPundleModel reconcileWithDb: trace] 						on: Error						do: 							[:exception | 							Transcript								cr;								show: (#_1sERRORReconciling2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: ERROR reconciling: &lt;2s&gt;' 									expandMacrosWith: eachPundleModel name									with: exception description).							exception return]]]]] 			on: DbRegistry errorSignals			do: [:exception | exception return]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>table of contents</category><body package="Store-Component Support">tableOfContentsTagsFrom: aStream 	| pkgTags defKey |	pkgTags := OrderedCollection new: 20.		[ aStream skipSeparators.	defKey := aStream upToSeparator.	defKey = ';' ] whileFalse: 		[ | index defTag start |		index := defKey indexOf: $&gt; ifAbsent: [nil].		defTag := index notNil			ifTrue: [ MethodTag new selector: ( defKey copyFrom: index + 1 to: defKey size ) asSymbol ]			ifFalse: 				[ index := defKey indexOf: $@ ifAbsent: [nil].				index notNil					ifTrue: [ DataTag new dataKey: ( defKey copyFrom: index + 1 to: defKey size ) asSymbol ]					ifFalse: 						[ index := defKey size + 1.						defKey first = $!							ifTrue: [ NameSpaceTag new ]							ifFalse: [ ClassTag new ]						]				].		defTag isMeta: defKey first = $%.		start := ( defTag isMeta  or: [ defTag isNameSpaceTag ] )			ifTrue: [ 2 ]  ifFalse: [ 1 ].		defTag classSymbol: ( defKey copyFrom: start to: index - 1 ) asSymbol.		pkgTags add: defTag		].	^pkgTags</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="Store-Component Support">zeroTraceForAll	"Elimate references to database  ids- neccessary when moving to	a new database."	"TT_Registry zeroTraceForAll"	self packagesDo: [:pkg | pkg setNoTrace; markNotModified].	self  bundlesDo: [:bun | bun setNoTrace; markNotModified].</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>relationships</category><body package="Store-Component Support">elementLabel: hints	"This method returns a visual component used to represent me in a browser graph."	| label |	label := LabelAndIcon with: (self stringKey: hints).	label icon: (Store.AbstractTool iconForPundle: self).	^label</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>utilities-store</category><body package="Store-Component Support">parcelInto: aStoreParcelRecord	"Convert the parcel to binary and install in dbParcel."		| codeWriter |	codeWriter := CodeWriter new.	self prepareCodeWriter: codeWriter.	[codeWriter parcelInto: aStoreParcelRecord] 		on: CodeWriter invalidTraceSignal 		do: [:exception | Parcel invalidNamedObjectSignal raiseWith: exception parameter]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing-store</category><body package="Store-Component Support">primaryKey	"unpublished"	^0</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>relationships</category><body package="Store-Component Support">relatedBy: token		token == #tt_derivesRel ifTrue: [^Set new].	token == #tt_derivesRRel ifTrue: [^Set with: self parentRecord].	^super relatedBy: token</body></methods><methods><class-id>Store.DatabaseConnectionInformation class</class-id> <category>instance creation</category><body package="Store-Component Support">databaseId: aString dbTrace: anInteger	"Answer an instance of the receiver initialized (with a nil changeset)"	^self new		dbIdentifier: aString;		dbTrace: anInteger</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-Component Support">changeSet: anXChangeSet	changeSet := anXChangeSet</body><body package="Store-Component Support">changeSetifNone: aBlock	^changeSet == nil		ifTrue: [ aBlock value ]		ifFalse: [ changeSet ]</body><body package="Store-Component Support">dbTrace: anInteger in: aSession	(dbTrace isNil or: [self shouldTrackChanges]) ifFalse:		[self addOtherChange: pundle parentChangedMark].	dbTrace := anInteger.	versionString := nil.	(anInteger notNil and: [pundle shouldTrackChanges]) ifTrue: 		[#{Store.DbRegistry} ifDefinedDo: [:ignored | self updateTraceInformationIn: aSession]].	self isInCurrentDatabase ifTrue:		[self manager traceChangedForComponent: pundle].</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>testing</category><body package="Store-Component Support">hasTrace	^self dbTrace notNil and: [ self dbTrace ~= 0 ]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>utility</category><body package="Store-Component Support">inspectChangeSet		changeSet ifNil: [^Dialog warn: (#NoChangesFor1s &lt;&lt; #store &gt;&gt; 'No changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)].	changeSet inspectorClass		inspect: changeSet copy		label: (#ChangesFor1s &lt;&lt; #store &gt;&gt; 'Changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-Component Support">markNotModified	self emptyChangeSet</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>printing</category><body package="Store-Component Support">printOn: aStream 	aStream nextPutAll: self class name asString.	aStream nextPutAll: ' ('.	dbIdentifier notNil 		ifTrue: [ aStream nextPutAll: dbIdentifier ].	aStream nextPut: $).</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-Component Support">setNoTrace	versionString := nil.	self dbTrace: nil.</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-Component Support">traceVersion	"Answer a string describing a version of my trace  pundle."	^Store.DbRegistry isOnlineImage 		ifTrue: [(pundle storeForGlorpPundleClass traceVersionFor: self dbTrace) ifNil: ['']]		ifFalse: ['']</body><body package="Store-Component Support">traceVersionIn: aSession	"Answer a string describing a version of my trace  pundle."	^Store.DbRegistry isOnlineImage 		ifTrue: [(pundle storeForGlorpPundleClass traceVersionFor: self dbTrace in: aSession) ifNil: ['']]		ifFalse: ['']</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-Component Support">unhook	"Remove db identitity from the receiver."		dbTrace := nil.	dbIdentifier := nil.	versionString := nil.</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>Signal constants</category><body package="Store-Component Support">cannotLoadComponentSignal	^CannotLoadComponentSignal</body><body package="Store-Component Support">cannotStoreComponentSignal	^CannotStoreComponentSignal</body><body package="Store-Component Support">cannotUnloadComponentSignal	^CannotUnloadComponentSignal</body><body package="Store-Component Support">componentNotFoundSignal	^Store.Glorp.StorePundle componentNotFoundSignal</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>instance creation</category><body package="Store-Component Support">fromBos: aString	"This method is used by the bos reader to create 	instances while loading a bundle."	| baby |	baby := self new.	baby fileNameString: aString.	^baby</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>parcel support</category><body package="Store-Component Support">fromParcelPrerequisite: aPreqArray	"Answer a ComponentDescription that represents the parcel prerequisite as a pundle."	"Parcel prereqs are #( name version )."	"self fromParcelPrerequisite: #( 'TestBundle876-B', '876' )"	"self fromParcelPrerequisite: #( 'TestPackage876', '876' )"	| cname version descclass |	cname := aPreqArray first.	version := aPreqArray last.	( cname copyFrom: ( cname size - 1 ) to: cname size ) = '-B'		ifTrue: 			[ descclass := BundleDescription.			cname := cname copyFrom: 1 to: ( cname size - version size - 2 ).			]		ifFalse: 			[ descclass := PackageDescription.			cname := cname copyFrom: 1 to: ( cname size - version size ).			].		^descclass new			componentName: cname;			id: version asNumber.</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>class initialization</category><body package="Store-Component Support">initialize	"self initialize"	CannotLoadComponentSignal := (Object informationSignal newSignal)				notifierString: (#CannotLoadAComponent &lt;&lt; #store 							&gt;&gt; 'Cannot load a component') asString;				nameClass: self message: #cannotLoadComponentSignal.	CannotStoreComponentSignal := (Object informationSignal newSignal)				notifierString: (#CannotStoreAComponent &lt;&lt; #store 							&gt;&gt; 'Cannot store a component') asString;				nameClass: self message: #cannotStoreComponentSignal.	CannotUnloadComponentSignal := (Object informationSignal newSignal)				notifierString: (#CannotUnloadAComponent &lt;&lt; #store 							&gt;&gt; 'Cannot unload a component') asString;				nameClass: self message: #cannotUnloadComponentSignal</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-Component Support">descriptionsAndLevels	"Answer a collection of pairs. The first element is the description	the second is level (zero)."	| comp |	comp := self component.	^comp isNil 		ifTrue: [#()]		ifFalse: [OrderedCollection with: (Array with: self with: 1)]</body><body package="Store-Component Support">fileName	^fileName</body><body package="Store-Component Support">fileName: aFilename	fileName := aFilename tail.</body><body package="Store-Component Support">fileNameString: aString	fileName := aString</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>testing</category><body package="Store-Component Support">isComponentLoaded	"Answer true if the actual component is already	loaded into the image."	^self component notNil</body><body package="Store-Component Support">isInCurrentDatabase	^#{Store.DbRegistry}		ifDefinedDo: [:registry | registry notNil and: [registry dbIdentifier = self dbIdentifier]]		elseDo: [false]</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-Component Support">isNotLoaded	"Answer true if there is no compatible version of the component 	already loaded into the image."	^self exactLoadedComponent isNil</body><body package="Store-Component Support">publishComponent	"Publish the component I hold onto and modify my description	to reflect changes."	| comp | 	comp := self component.	comp storeInDB.	id := comp dbTrace.</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>binary storage</category><body package="Store-Component Support">representBinaryOn: binWriter	"When we store description we only need to know the	type of the component and the file name used for storage."	^MessageSend				receiver: self class				selector: #fromBos:				arguments: (Array with: fileName)</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-Component Support">updateVersion	"The underlying component has been published. 	Update my data to reflect this change."	| comp |	comp := self component.	comp == nil 		ifFalse: 	[ id := comp dbTraceFor: dbIdentifier ]</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-instance creation</category><body package="Store-Component Support">newFromBinFile: aFilename 	"Create new instance and initilaize it form data stored in	the bos file. Do not load components."		| bos baby |	bos := BinaryObjectStorage onOld: aFilename asFilename readStream.	[baby := self readFrom: bos]		ensure: [bos close].	^baby</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>constants</category><body package="Store-Component Support">storeDatabaseClass	^Store.Glorp.StoreBundle</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-Component Support">addFile: aFileDescription	"Add a external file to the receiver."	dbInfo isEmpty		ifTrue: [ self databaseInformationForOrCreate: self noDbSymbol ].	self databaseInformationsDo:		[ : info | info addFileDescription: aFileDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>binary storage</category><body package="Store-Component Support">adjustComponents	"Iterate over description and make sure that	the names of components are OK.	Descriptions for which components were loaded have	names not set up/"	self databaseInformation adjustComponents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-Component Support">anyFileDescriptions	"Answer a collection of file descriptors for any database connection"	dbInfo isEmpty ifTrue: [^OrderedCollection new].	dbInfo size &gt; 1 ifTrue: [dbInfo removeKey: self noDbSymbol ifAbsent: nil].	^dbInfo values first fileDescriptions collect: [:each | each copy dbTrace: nil]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-Component Support">canReplaceVersions	super canReplaceVersions ifFalse: [^false].	^self containedItems allSatisfy: #canReplaceVersions</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-Component Support">changedItemCount	"Answer a count of work to be done for filing out changes."	^self contents inject: 1 into:		[ :sz :pun | 		pun == nil			ifTrue: [ sz ]			ifFalse: [ sz + pun changedItemCount ]		].</body><body package="Store-Component Support">changedItemCountFor: dbid	"Answer a count of work to be done for filing out changes."	^self contents inject: 1 into:		[ :sz :pun | 		pun == nil			ifTrue: [ sz ]			ifFalse: [ sz + ( pun changedItemCountFor: dbid ) ]		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-Component Support">comparePackages: aBundle	"Compare all packages that I contain with	packages that are contained by aBundle."</body></methods><methods><class-id>Store.BundleModel</class-id> <category>compaisons</category><body package="Store-Component Support">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isBundle and: [ name = aCodeComponent name ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-Component Support">computeDifferencesBetween: aBundle into: aComparitor 	"Since I am a Bundle, I have no non property differences."		^aComparitor</body><body package="Store-Component Support">computeDiffsBetween: aBundle into: aComparitor	"Since the receiver is a loaded package an argument aBundle	has to be a DB packagge."		[aComparitor reverse.	self computeDiffsBetweenDBBundle: aBundle into: aComparitor] 		ensure: [aComparitor reverse].	^aComparitor</body><body package="Store-Component Support">computeDiffsBetweenDBBundle: aBundle into: diffHolder	diffHolder methodsSide: 2 put: OrderedCollection new.	diffHolder methodsSide: 1 put: OrderedCollection new.	diffHolder dataSide: 2 put: OrderedCollection new.	diffHolder dataSide: 1 put: OrderedCollection new.	diffHolder classesSide: 2 put: OrderedCollection new.	diffHolder classesSide: 1 put: OrderedCollection new.	diffHolder metaSide: 2 put: OrderedCollection new.	diffHolder metaSide: 1 put: OrderedCollection new.	diffHolder nameSpacesSide: 2 put: OrderedCollection new.	diffHolder nameSpacesSide: 1 put: OrderedCollection new.	^diffHolder</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-Component Support">fileDescriptions	"Answer a collection of FileModels for any files that are associated with the current/last database connection."	| dbinfo |	^( dbinfo := self databaseInformation ) == nil		ifTrue: [ self anyFileDescriptions ]		ifFalse: [ dbinfo fileDescriptions ].</body><body package="Store-Component Support">fileDescriptions: aCollectionOfFileModels	"Set my files to be aCollectionOfFileModels."	( self databaseInformationOrCreate )		fileDescriptions: aCollectionOfFileModels.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="Store-Component Support">fileOutChangesForDb: aSymbol on: aStream within: aBundle	"If unreconciled to the database denoted by aSymbol, write out everything.  	If a subpundle's id in the database does not match the id I have in my description for it	(or it is nilled) then we file out everything because that it means the reconciled bundle does not contain the subpundle."	(self dbTraceFor: aSymbol) ifNil: [^self fileOutOn: aStream].	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[self fileOutChangedPropertiesForDb: aSymbol on: aStream].	self contentDescriptions do:		[:each |		| component | 		component := each component.		component isNil ifFalse:			[(component dbTraceFor: aSymbol) = each id				ifTrue: [component fileOutChangesForDb: aSymbol on: aStream within: aBundle]				ifFalse: [component fileOutOn: aStream]]].	(self databaseInformationFor: aSymbol) isChangeSetEmpty ifTrue: [^self].			(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[((self changeSetFor: aSymbol) otherChangesInclude: self structureMark) ifTrue:			[(BundleStructureChange new component: self) fileOutOn: aStream]].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="Store-Component Support">fileOutChangesOn: aFileManager 	Notice 		showProgress: (#FilingOutChangesFor1s &lt;&lt; #store 				&gt;&gt; 'Filing out changes for &lt;1s&gt;' expandMacrosWith: name)		complete: self changedItemCount		while: [self fileOutChangesOn: aFileManager within: self]		title: (#Store &lt;&lt; #store &gt;&gt; 'Store') asString</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="Store-Component Support">fileOutChangesOn: aStream within: aBundle	"Write out all the changes the receiver knows about."		| changeSet |	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse: 		[self fileOutChangedPropertiesOn: aStream].	self containedItems do: [:each | each fileOutChangesOn: aStream within: aBundle].	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[changeSet := self changeSet.		(changeSet otherChangesInclude: self structureMark) ifTrue: 			[(BundleStructureChange new component: self) fileOutOn: aStream]]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>initialize-release</category><body package="Store-Component Support">initializeForReconcileWith: aDbBundle	"Ensure that the receiver is set up for the current database.  Do not inline the descs and fdescs temporaries: their values must be obtained before the databaseInformation for the current database is created."	| descs fdescs |	self databaseInformation == nil ifFalse: [ ^self ].	descs := self anyContentDescriptions.		"do not inline this assignment"	fdescs := self anyFileDescriptions.			"do not inline this assignment"	self databaseInformationOrCreate 		contentDescriptions: descs;		fileDescriptions: fdescs;		dbTrace: ((aDbBundle == nil) ifFalse: [aDbBundle primaryKey]) in: aDbBundle session.</body><body package="Store-Component Support">initializeFromDB: aStoreBundle		self properties: aStoreBundle properties.	self comment: aStoreBundle commentOrNil.	self databaseInformationOrCreate contentDescriptions: 		(aStoreBundle containedItems collect: [:each | each asComponentDescription]).	self databaseInformation fileDescriptions: 		(aStoreBundle files collect: [:each | each asComponentDescription bundle: self]).	dbInfo removeKey: self noDbSymbol ifAbsent: [nil]</body><body package="Store-Component Support">initializeFromImage: anImgBundle for: aSymbol	"We have just loaded or published a database version to which this image model is now being synchronised.  We have already synchronised the aSymbol database information in anImgBundle (which in typical calls will be identical to self, but we pass it as a parameter for flexibility).  Now we move over that database info's structural data to the other database informations, so that all will reflect the structure of the bundle."	anImgBundle ifNil: [^self].	anImgBundle databaseInformationsDo:		[:info | info dbIdentifier = aSymbol ifFalse:			[dbInfo at: info dbIdentifier put:				(info resetContentsFrom: (self databaseInformationFor: aSymbol))]]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-Component Support">modifications	"Answer my content as a collection of modifications in order."	| mods |	mods := List new.	self leafItems do:		[ :pkg | mods addAll: pkg modifications ].	^mods</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-Component Support">pundleChangesClass	^BundleChanges</body></methods><methods><class-id>Store.BundleModel</class-id> <category>utilities-repository</category><body package="Store-Component Support">reconcileWithDb: aPundleOrStorePundle	"Change the receiver to reflect dbPundle as it's parent."		| storePundle |	storePundle := aPundleOrStorePundle asStorePundle.	self initializeForReconcileWith: storePundle.	super reconcileWithDb: storePundle.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>relationships</category><body package="Store-Component Support">relatedBy: token		token == #tt_containsRel ifTrue: [^self contents asSet].	^super relatedBy: token</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-Component Support">removeFile: aFileDescription	self databaseInformationsDo:		[ :info | info removeFile: aFileDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-validation</category><body package="Store-Component Support">removeNonexistentComponentsRecursive	self databaseInformationsDo:		[ :info | info removeNonexistentComponentsRecursive ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>parcel support</category><body package="Store-Component Support">saveAsParcelFromSpecs: publishSpec	"Save the receiver as a parcel -without creating the parcel in the image.	specs fullPathName is a directory/parcelName with no extension.	If specs bundleStructure is true, fill in the bundleStructure property with bundle/package contents.	If specs databaseLinks is true, save the db links for every component.	For a bundle, we now always save the structure and thus the saveStructure parameter of the publishSpec is ignored"		| dir link pname |	link := publishSpec databaseLinks.	link &amp; self hasBeenModified		ifTrue:			[(BundleHasUnpublisedChangesConfirmation raiseRequestErrorString: name) ifFalse: [^self].			link := false].	pname := publishSpec basePath asFilename tail.	dir := publishSpec basePath asFilename directory.	dir exists		ifFalse:			[(CreateParcelDirectoryConfirmation raiseRequestErrorString: dir asString) ifFalse: [^self].			dir makeDirectory].	properties		at: #bundleName put: self name;		at: #parcelName put: pname.	properties at: #bundleStructure put: (PundleForParcel from: self saveLinks: link).	[self 		parcelOutTo: (dir construct: pname , '.pcl') asString 		sourceFileName: (dir construct: pname , '.pst') asString 		parcelOptions: publishSpec]			ensure:				[properties					removeKey: #bundleStructure ifAbsent: [];					removeKey: #bundleName ifAbsent: []]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>utilities-repository</category><body package="Store-Component Support">setNewTraceTo: dbPundle	"Change the receiver to reflect dbPundle as it's parent."			| dbItems |	super reconcileWithDb: dbPundle.	dbItems := dbPundle containedItems.	self contentDescriptions do:		[ :desc |  | match item |		item := desc component.		( item dbTrace == nil or: [ item dbTrace == 0 ] )			ifTrue:				[				( match := dbItems 					detect: 						[ :dbitem |  						( ( item isBundle == dbitem isBundle ) and: [ item name = dbitem name ] )						]					ifNone: [ nil ] ) == nil						ifFalse: 							[ item setNewTraceTo: match.							desc  id: item dbTrace.	"so we match"								].				].		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="Store-Component Support">shouldProceedToUnload: aPundle	"We find out if the new bundle might have as a prereq the passed in package or bundle.	We start off with no, don't.	Then we go over my prereqs. If the passed in package or bundle name is the same as a prereq name,	and the details of the version are the same (or not specified) we say, continue with don't.	If the details are NOT the same, we say DO, which will allow the package or bundle passed in to be unloaded"	| prerequisites |	prerequisites := self prerequisiteDescriptions.	(prerequisites isNil or: [prerequisites isEmpty]) ifTrue: [^true].	^prerequisites anySatisfy: 			[:each |			| target eachPrerequisiteName |			eachPrerequisiteName := each name.			aPundle name = eachPrerequisiteName and: 					[target := (Registry bundleNamed: aPundle name)								ifNil: [Registry packageNamed: aPundle name].					target notNil						ifTrue: 							[| block |							block := CodeComponent asActionBlock: self versionSelectionBlock.							block isNil								ifTrue: 									[each versionFilter notEmpty										and: [target traceVersion ~= each versionFilter]]								ifFalse: 									[(block										value: eachPrerequisiteName										value: target traceVersion										value: each versionFilter) not]]]]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>converting</category><body package="Store-Component Support">storeForGlorpPundleClass	^self class storeDatabaseClass</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-repository storage</category><body package="Store-Component Support">storeInDB	"Open a dialog that will let us store into the database all components that have been modified and the bundle description.  Return the dialog if we succeed in opening it (lets callers prep values further if needed), nil if not.  Accepting the dialog stores into DB and empties the change set."	Undeclared purgeUnusedBindings.	self removeNonexistentComponentsRecursive.	^self shouldSaveIfNotNewestVersion ifTrue:		[PublishPundleDialog publishBundle: self]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-Component Support">typeStringForBlessing		^Store.Glorp.StoreBundle typeStringForBlessing</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>utility storage</category><body package="Store-Component Support">parcelInto: aStoreParcelRecord 	"Store the parcel to a database record.  Answer true if successful."	| success |	((properties at: #packageName ifAbsent: [nil]) notNil and: [(properties at: #name) = (properties at: #packageName)])		ifFalse: [properties at: #name put: (properties at: #packageName)].	analysisTracer trace: properties.	self traceNamedObjects.	newSourceKeys := IdentityDictionary new: analysisTracer compiledMethodCount * 3 // 2.	self createInternalSourceStreams.	hideOnLoad := false.	success := true.	[ self allocate.	self layout.	self storePackage.	stream close.	sourceStream close.	aStoreParcelRecord privateSetBlob: (Store.Glorp.StoreBinaryBlob forByteArray: stream contents).	aStoreParcelRecord privateSetSource: (Store.Glorp.StoreBinaryBlob forByteArray: sourceStream targetFile stream contents) 	] ifCurtailed: [ success := false ].	^success</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>binary storage</category><body package="Store-Component Support">describeBOSS: p on: strm 	| lines |	self shouldNotImplement.	"FOR REFERENCE ONLY"	lines := 0.	p first size &gt; 0 		ifTrue: 			[strm 				nextPutAll: (#ThisPackageContainsTheClasses &lt;&lt; #store &gt;&gt; 'This package contains the classes:') asString.			p first do: 					[:clsName | 					strm nextPut: Character cr.					lines := lines + 1.					lines &gt; 10 						ifTrue: 							[strm nextPutAll: '...'.							^self].					strm nextPutAll: '   '.					strm nextPutAll: clsName].			strm nextPut: Character cr.			strm nextPut: Character cr].	strm nextPutAll: (#ThisPackageContainsTheMethods &lt;&lt; #store &gt;&gt; 'This package contains the methods: ').	(p at: 2) do: 			[:sel | 			strm nextPut: Character cr.			lines := lines + 1.			lines &gt; 10 				ifTrue: 					[strm nextPutAll: '...'.					^self].			strm nextPutAll: '   '.			strm nextPutAll: sel className.			strm nextPutAll: '&gt;&gt;'.			strm nextPutAll: sel selector]</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>constants</category><body package="Store-Component Support">storeDatabaseClass	^Store.Glorp.StorePackage</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>utilities</category><body package="Store-Component Support">zeroTraceForAll	"self zeroTraceForAll"	Registry packagesDo: [:pkg | pkg setNoTrace].	Registry bundlesDo: [:bun | bun setNoTrace].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Store-Component Support">changedItemCount	"Answer a count of work to be done for filing out changes	from the current database."	^self changeSet == nil		ifTrue: [ 0 ]		ifFalse: [ self changeSet itemCount ]</body><body package="Store-Component Support">changedItemCountFor: dbid	"Answer a count of work to be done for filing out changes from the indicated database."	| cs |	^( cs := self changeSetFor: dbid ) == nil		ifTrue: [ 0 ]		ifFalse: [ cs itemCount ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>public-change set access</category><body package="Store-Component Support">changedMessageList	^self changedMethodsFor: DbRegistry dbIdentifier</body><body package="Store-Component Support">changedMethodList	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet modifiedMethodDescriptors  ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-Component Support">changeSetClassDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Compute differences between me and my trace package. 	Use change set."		| otherClasses mainClasses mainNamespaces otherNamespaces |	otherNamespaces := self affectedNameSpaceNames.	mainNamespaces := Set new: otherNamespaces size.	otherClasses := self affectedClassNamesMeta: false.	mainClasses := Set new: otherClasses size.	aStorePackage notNil		ifTrue:			[otherNamespaces				do:					[:each | 					| storeNameSpace |					storeNameSpace := aStorePackage nameSpaceInPackageNamed: each.					storeNameSpace notNil ifTrue: [mainNamespaces add: storeNameSpace]].			otherClasses				do:					[:each | 					| storeClass |					storeClass := aStorePackage classInPackageNamed: each meta: false.					storeClass notNil ifTrue: [mainClasses add: storeClass]].			self removedClassOrDefinitionNames				do:					[:each | 					| storeClass |					storeClass := aStorePackage classInPackageNamed: each meta: false.					storeClass notNil ifTrue: [mainClasses add: storeClass]].			self removedNameSpaceOrDefinitionNames				do:					[:each | 					| storeNameSpace |					storeNameSpace := aStorePackage nameSpaceInPackageNamed: each.					storeNameSpace notNil ifTrue: [mainNamespaces add: storeNameSpace]]].	aPackageComparitor otherPackageNamespaces: (otherNamespaces collect: [:each | (NameSpaceDescriptor new fullName: each) asStoreNameSpace]).	aPackageComparitor mainPackageNamespaces: mainNamespaces.	aPackageComparitor otherPackageClasses: (otherClasses collect: [:each | (ClassDescriptor fullName: each meta: false) asStoreClassDefinition]).	aPackageComparitor mainPackageClasses: mainClasses</body><body package="Store-Component Support">changeSetClassDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	| classes2 classes1 meta2 meta1 namespaces1 namespaces2 |	namespaces2 := self affectedNameSpaceNames.	namespaces1 := Set new: namespaces2 size.	classes2 := self affectedClassNamesMeta: false.	classes1 := Set new: classes2 size.	meta2 := self affectedClassNamesMeta: true.	meta1 := Set new: meta2 size.	aTracePackage notNil		ifTrue: 			[ namespaces2 do: 				[: nsName | | nsDb |				nsDb := aTracePackage nameSpaceInPackageNamed: nsName.				nsDb notNil ifTrue: [ namespaces1 add: nsDb ]				].			classes2 do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: false.				cdb notNil ifTrue: [ classes1 add: cdb ]				].			meta2 do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: true.				cdb notNil ifTrue: [meta1 add: cdb]				].			self removedClassOrDefinitionNames do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: false.				cdb notNil ifTrue: [ classes1 add: cdb ].				cdb := aTracePackage classInPackageNamed: cName meta: true.				cdb notNil ifTrue: [ meta1 add: cdb ]				].			self removedNameSpaceOrDefinitionNames do: 				[ :nsName | | cdb |				cdb := aTracePackage nameSpaceInPackageNamed: nsName.				cdb notNil ifTrue: [ namespaces1 add: cdb ].				]			].	diff nameSpacesSide: 2 put: ( namespaces2 collect: [:cName | NameSpaceDescriptor new fullName: cName ] ).	diff nameSpacesSide: 1 put: namespaces1.	diff classesSide: 2 put: ( classes2 collect: [:cName | ClassDescriptor fullName: cName meta: false ] ).	diff classesSide: 1 put: classes1.	diff metaSide: 2 put: (meta2 collect: [:cName | ClassDescriptor fullName: cName meta: true ] ).	diff metaSide: 1 put: meta1.</body><body package="Store-Component Support">changeSetDataDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Compute differences between me and my trace package. 	Use change set."	"Get all modified data."		| otherShareds mainShareds |	otherShareds := self modifiedDatumDescriptors.	mainShareds := Set new: otherShareds size.	aStorePackage notNil		ifTrue:			[otherShareds				do:					[:each | 					| storeShared |					storeShared := aStorePackage datum: each dataKey forOwnerNamed: each ownerName.					storeShared notNil ifTrue: [mainShareds add: storeShared]].			self removedDatumDescriptors				do:					[:each | 					| storeShared |					storeShared := aStorePackage datum: each dataKey forOwnerNamed: each ownerName.					storeShared == nil ifFalse: [mainShareds add: storeShared]]].	aPackageComparitor otherPackageShareds: (otherShareds collect: [:each | each asStoreSharedVariable]).	aPackageComparitor mainPackageShareds: (mainShareds collect: [:each | each asStoreSharedVariable]).</body><body package="Store-Component Support">changeSetDataDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	"Get all modified data."	| data2 data1 |	data2 := self modifiedDatumDescriptors.	data1 := Set new: data2 size.	aTracePackage notNil		ifTrue: 			[ data2 do: 				[:dd | | ddb |				ddb := aTracePackage datum: dd dataKey forOwnerNamed: dd ownerName.					ddb notNil ifTrue: [ data1 add: ddb ]			].			self removedDatumDescriptors do: 				[ :dd | 	| ddb |				ddb := aTracePackage datum: dd dataKey forOwnerNamed: dd ownerName.				ddb == nil ifFalse: [ data1 add: ddb ]				]			].		"At this point data1 contains data that are only in a trace package 	and data2 data that are only the receiver."	diff dataSide: 2 put: data2.	diff dataSide: 1 put: data1.</body><body package="Store-Component Support">changeSetDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor 	"Compute differences between me and my trace package. 	Use change set."	self changeSetClassDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor.	self changeSetMethodDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor.	self changeSetDataDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor.	self computeOverrideDiffsBetweenDBPackage: aTracePackage into: aPackageComparitor.	^aPackageComparitor</body><body package="Store-Component Support">changeSetDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	self changeSetClassDiffsBetweenDBPackage: aTracePackage into: diff.	self changeSetMethodDiffsBetweenDBPackage: aTracePackage into: diff.	self changeSetDataDiffsBetweenDBPackage: aTracePackage into: diff.	self computeOverrideDiffsBetweenDBPackage: aTracePackage into: diff.	^diff</body><body package="Store-Component Support">changeSetMethodDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Compute differences between me and my trace package. 	Use change set."	"Get all modified methods."		| otherMethods mainMethods |	otherMethods := self modifiedAndReorganizedMethodDescriptors.	mainMethods := Set new: otherMethods size.	aStorePackage notNil ifTrue:		[otherMethods do:			[:each | 			| storeMethodInPackage |			storeMethodInPackage := aStorePackage 				method: each selector 				forClassNamed: each className asClassNameOnly 				meta: each isMeta.			storeMethodInPackage notNil ifTrue: [mainMethods add: storeMethodInPackage definition]].		self removedMethodDescriptors do:			[:each | 			| storeMethodInPackage |			storeMethodInPackage := aStorePackage 				method: each selector 				forClassNamed: each className asClassNameOnly 				meta: each isMeta.			storeMethodInPackage notNil ifTrue: [mainMethods add: storeMethodInPackage definition]]].	aPackageComparitor otherPackageMethods: (otherMethods collect: [:each | each asStoreMethodDefinition]).	aPackageComparitor mainPackageMethods: mainMethods</body><body package="Store-Component Support">changeSetMethodDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	"Get all modified methods."	| meth2 meth1 | 	meth2 := self modifiedAndReorganizedMethodDescriptors.	meth1 := Set new: meth2 size.	aTracePackage notNil		ifTrue: 			[ meth2 do: 				[ :md | | mdb |				mdb := aTracePackage							method: md selector							forClassNamed: md className asClassNameOnly							meta: md isMeta.				mdb notNil ifTrue: [ meth1 add: mdb ]				].			self removedMethodDescriptors do: 				[ :md | | mdb |				mdb := aTracePackage							method: md selector							forClassNamed: md className asClassNameOnly							meta: md isMeta.				mdb notNil ifTrue: [ meth1 add: mdb ]				]			].		"At this point meth1 contains methods that are only in a trace package 	and meth2 methods that are only the receiver."	diff methodsSide: 2 put: meth2.	diff methodsSide: 1 put: meth1.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>consistency checking</category><body package="Store-Component Support">checkConsistencyOn: aStream 	self cleanse.	self isChangeSetEmpty 		ifFalse: [self changeSet checkConsistencyInPackage: self on: aStream].	self modelsDo: 			[:model | 			(Registry modelsForSymbol: model absoluteSymbol) 				detect: [:aModel | aModel == model]				ifNone: 					[aStream nextPutAll: ((#model1sInPackagIsNotRegisteredN &lt;&lt; #store &gt;&gt; 'model "&lt;1s&gt;" in package &lt;1p&gt; is not registered&lt;n&gt;') 								expandMacrosWith: model absoluteSymbol								with: self)]]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-Component Support">classListForPackage	^self definedClassModels collect: [:cm| cm actualClass]</body><body package="Store-Component Support">compiledMethods	| comp |	comp := OrderedCollection new.	self classModelsDo: [:cm| comp addAll: cm compiledMethods].	^comp</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-Component Support">computeDiffsBetween: aPackage into: aComparitor 	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[aComparitor reverse.	self computeDiffsBetweenDBPackage: aPackage into: aComparitor]		ensure: [aComparitor reverse].	^aComparitor</body><body package="Store-Component Support">computeDiffsBetweenDBPackage: aDBPackage into: diff	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number-2 since this method	is called with arguments reversed.	The comparison is done in two steps. First we compare,	image with trace and then we compare trace	with aDBpackage and combine the restults."	|  tracePkg diff2| 	"If aDB package is a pseudo package use change set only"	(aDBPackage pseudoPackage) 		ifTrue: [^self changeSetDiffsBetweenDBPackage: aDBPackage into: diff].	((self otherChangesInclude: self parentChangedMark) 			or: [(tracePkg := self tracePackage) isNil  					or: [self userWantsFullCompare]])		ifTrue: 			["I do not have a parent package do the full comparison"			^self computeFullDiffsBetweenDBPackage: aDBPackage into: diff].	"Calculate differences between me and the trace."	self changeSetDiffsBetweenDBPackage: tracePkg into: diff.	(aDBPackage sameAs: tracePkg) 		ifTrue: ["We are done" ^self].	"Now calculate differences between my trace and aDBPackage." 	diff2 := PackageDifferences with: aDBPackage with: tracePkg. 	diff combineDiffsFrom: diff2.	^diff</body><body package="Store-Component Support">computeFullDiffsBetweenDBPackage: aDBPackage into: diff 	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number2 since this method	is called with arguments reversed."	| coll1 coll2 |	"methods"	coll1 := aDBPackage methodsWithSource asSet.	coll2 := OrderedCollection new: coll1 size.	self methods 		do: [:method | coll1 remove: method ifAbsent: [coll2 add: method]].	"At this point coll1 contains methods that are only in aDBPackage	and coll2 methods that are only the receiver."	diff methodsSide: 2 put: coll2.	diff methodsSide: 1 put: coll1.	"data"	coll1 := aDBPackage data asSet.	coll2 := OrderedCollection new: coll1 size.	self data do: [:datum | coll1 remove: datum ifAbsent: [coll2 add: datum]].	"At this point coll1 contains data that are only in aDBPackage	and coll2 data that are only the receiver."	diff dataSide: 2 put: coll2.	diff dataSide: 1 put: coll1.	"namespaces"	coll1 := aDBPackage nameSpacesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self nameSpacesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff nameSpacesSide: 2 put: coll2.	diff nameSpacesSide: 1 put: coll1.	"classes"	coll1 := aDBPackage classesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self classesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff classesSide: 2 put: coll2.	diff classesSide: 1 put: coll1.	coll1 := aDBPackage metaclassesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self metaclassesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff metaSide: 2 put: coll2.	diff metaSide: 1 put: coll1.	self computeOverrideDiffsBetweenDBPackage: aDBPackage into: diff.	^diff</body><body package="Store-Component Support">computeOverrideDiffsBetweenDBPackage: aTracePackage into: diff 	"Add overriden stuff to diff. Valid for all methods of calculation"	self overrides do:		[ :over | over addDiffTo: aTracePackage into: diff ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-Component Support">currentTag 	^self class currentTag</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="Store-Component Support">fileOutChangesForDb: aSymbol on: aFileManager within: aBundle	"If unreconciled to the database denoted by aSymbol, write out everything."	| info commentString |	((info := self databaseInformationFor: aSymbol) isNil or: [info dbTrace isNil])		ifTrue: [^self fileOutOn: aFileManager].	info isChangeSetEmpty ifTrue: [^self].	commentString := #PackageChangesFor1s &lt;&lt; #packages &gt;&gt; 'Package Changes for &lt;1s&gt;' expandMacrosWith: self itemString.	aFileManager addComment: commentString.	(#{Store.StoreSettings} ifDefinedDo: [:object | object preferenceFor: #fileoutOption] elseDo: [nil]) == #never ifFalse:		[(aFileManager sourceFormatter)			attributeFor: #package compute: [:ignore | self name];			attributeForMethods: #package compute: [:ignore :moreIgnore | self name].		self fileOutChangedPropertiesForDb: aSymbol on: aFileManager].	info changeSet fileOutOn: aFileManager for: info pundle within: aBundle.</body><body package="Store-Component Support">fileOutChangesOn: aFileManager within: aBundle	self fileOutChangesForDb: DbRegistry dbIdentifier on: aFileManager within: aBundle</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-Component Support">indexTag	^self class indexTag</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="Store-Component Support">isSaveable	"Answer true if ok to save"	"NOTE: must match #isSaveableWithWarning"		^self isNullPackage not and: 		[super isSaveable and: 		[self checkUndeclared]]</body><body package="Store-Component Support">isSaveableWithWarning	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveable"		self isNullPackage		ifTrue:			[NullPackageCanNotBeSavedError raiseSignal.			^false].	super isSaveableWithWarning ifFalse: [^false].	self checkUndeclared		ifFalse:			[ContainsUndeclaredError raiseRequestErrorString: name.			^false].	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-Component Support">literalClassListForPackage	^(self definedClassModels 		collect: [:cm | cm className])			asArray</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Store-Component Support">pundleChangesClass	^PackageChanges</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-Component Support">readFromCodeReader: aReader 	self comment: aReader comment.	aReader classes do: [:cl | self addFullClassSymbol: cl fullClassSymbol].	aReader extensionMethods do: [:marr | 		self addSelector: (marr at: 1)			class: (marr at: 2) mclass].	self markNotModified</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-descriptors</category><body package="Store-Component Support">reorganizedMethodDescriptors	| parentID reorginizedMethods |	(DbRegistry isOnline and: [self hasTrace])		ifFalse: [^Array new].	parentID := self dbTrace.	reorginizedMethods := Set new. 	self changeSet reorganizedClassNames do: 		[:eachAbsoluteName | 		| actualClass isMeta |		isMeta := eachAbsoluteName namesMetaClass.		actualClass := eachAbsoluteName asClassNameOnly asStrictReference value.		isMeta ifTrue: [actualClass := actualClass class].		actualClass organization elements do: 			[:eachSelector | 			| protocolOrNil |			protocolOrNil := Store.Glorp.StoreMethodInPackage				protocolOrNilFor: eachSelector asString				inClass: eachAbsoluteName				packageID: parentID.			(protocolOrNil notNil and: [(actualClass organization categoryOfElement: eachSelector) ~= protocolOrNil])				ifTrue: 					[reorginizedMethods add: (MethodDescriptor 						fromSelector: eachSelector 						className: eachAbsoluteName 						meta: isMeta)]]].	^reorginizedMethods</body></methods><methods><class-id>Store.PackageModel</class-id> <category>parcel support</category><body package="Store-Component Support">saveAsParcelFromSpecs: publishSpec	"Save the receiver as a parcel -without creating the parcel in the image.	specs fullPathName is a directory/parcelName with no extension."		| dir pname |	pname := publishSpec basePath asFilename tail.	dir := publishSpec basePath asFilename directory.	dir exists		ifFalse:			[(CreateParcelDirectoryConfirmation raiseRequestErrorString: dir asString) ifFalse: [^self].			dir makeDirectory].	properties at: #packageName put: name.	self 		parcelOutTo: (dir construct: pname , '.pcl') asString 		sourceFileName: (dir construct: pname , '.pst') asString 		parcelOptions: publishSpec</body></methods><methods><class-id>Store.PackageModel</class-id> <category>converting</category><body package="Store-Component Support">storeForGlorpPundleClass	^self class storeDatabaseClass</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-repository storage</category><body package="Store-Component Support">storeInDB	"Open a dialog that will let us store the source code into the database.  Return the dialog if we succeed in opening it (lets callers prep values further if needed), nil if not.  Accepting the dialog stores into DB and empties the change set."		Undeclared purgeUnusedBindings.	self removeEmptyModels.	^(self shouldSaveIfNotNewestVersion		and: [self isSaveableWithWarning])			ifTrue: [PublishPackageDialog publishPackage: self]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing-fake</category><body package="Store-Component Support">typeStringForBlessing		^Store.Glorp.StorePackage typeStringForBlessing</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-load/unload</category><body package="Store-Component Support">updateFrom: aStoreParcelRecord within: aBundleOrNil	"Load code from aStoreParcelRecord (a fast-loading binary parcel stream) and update the system with the new code.	 Update the receiver to reflect the new code. Answer the receiver."	| aCodeReader |	aCodeReader := CodeReader new.	"First get the CodeReader to read-in all code objects into shadow namespaces	 internal to the CodeReader, leaving the system unmodified."	[ self startLoad.	self class		handleCodeReaderSignalsDo: [aCodeReader readFromStore: aStoreParcelRecord]		for: aStoreParcelRecord.	] ensure: [ self endLoad ].	aCodeReader properties removeKey: #dbTrace ifAbsent: [nil].	^self		updateCodeReadBy: aCodeReader		from: aStoreParcelRecord		within: aBundleOrNil</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private</category><body package="Store-Component Support">createStreamFromGlorpRecord: aParcelRecord		| sourceFileInTempDirectory |	stream := InternalCodeReaderStream on: aParcelRecord binaryData.	tempSourceFile := Filename filterFilename: aParcelRecord defaultParcelName , '.pst'.	streamDir := aParcelRecord yourself class parcelDirectory.	streamDir exists ifFalse: [streamDir asFilename makeDirectory].	sourceFileInTempDirectory := streamDir construct: tempSourceFile.	sourceFileInTempDirectory exists ifFalse:		[sourceFileInTempDirectory := (sourceFileInTempDirectory withEncoding: #binary) writeStream.		[sourceFileInTempDirectory nextPutAll: aParcelRecord source binaryData] ensure: [sourceFileInTempDirectory close]]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>atomic installation</category><body package="Store-Component Support">isAtomicallyLoadable	^self packageUndeclared isNil or: [self packageUndeclared isEmpty]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>testing</category><body package="Store-Component Support">isFullyLoaded	^self isLoaded</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>atomic installation</category><body package="Store-Component Support">unloadableDefinitionsForBrowsing	^#()</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-Component Support">abortLoadingSignal	^ComponentDescription cannotLoadComponentSignal.</body><body package="Store-Component Support">abortUnloadingSignal	^ComponentDescription cannotUnloadComponentSignal.</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="Store-Component Support">allDatabasesFor: aCollection	"Answer a list of existing dbIdentifiers linked to pundles."		| dbIdentifiers |	dbIdentifiers := Set new.	aCollection do: [:each | dbIdentifiers addAll: each allDatabases].	^dbIdentifiers asSortedCollection</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private</category><body package="Store-Component Support">changeSetClass	^XChangeSet</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-Component Support">classAlreadyLoadedSignal	^Parcel classAlreadyLoadedSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-Component Support">compilationErrorSignal	^TextEditorController compilationErrorSignal</body><body package="Store-Component Support">componentNotFoundSignal	^Store.Glorp.StorePundle componentNotFoundSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private</category><body package="Store-Component Support">currentBosFormat 	^1</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>constants</category><body package="Store-Component Support">databaseClass	^self storeDatabaseClass</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="Store-Component Support">databaseListFor: pundles	"Answer a list of existing db names linked to pundles."	| dbs |	dbs := Set new.	pundles do: [ :p | dbs addAll: p databaseList ].	^dbs asSortedCollection</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-Component Support">emergencyUnloadSignal	^EmergencyUnloadSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private-loading</category><body package="Store-Component Support">handlePrerequisite: anArray 	"With StORE loading all prereqs have been loaded before the CodeReader	 is used to load code, so we can ignore all prerequisites."	^self</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-Component Support">invalidClassFormatSignal	^Parcel invalidClassFormatSignal</body><body package="Store-Component Support">invalidNamedObjectSignal	^Parcel invalidNamedObjectSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-Component Support">mismatchedDatabaseSignal	^Store.MismatchedDatabaseError</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-Component Support">missingClassSignal	^Parcel missingClassSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>accessing</category><body package="Store-Component Support">useChangeSetsForCompare 	^UseChangeSetsForCompare</body><body package="Store-Component Support">useChangeSetsForCompare: aBoolean	UseChangeSetsForCompare := aBoolean</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support">allDatabases	"Answer an array of datbase identifiers that the receiver has links to"	^( ( dbInfo select: [ :info | info hasTrace ] )		collect: [ :info | info dbIdentifier ]	) asArray.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="Store-Component Support">asStoreComparisonObjectIn: ignore	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-Component Support">canBePublishedToCurrentDatabase	"Answer true if the receiver can safely be published to the current database."		(self hasTraceFor: DbRegistry dbIdentifier) ifTrue: [^true].	^(self storeForGlorpPundleClass hasVersionNamed: name) not</body><body package="Store-Component Support">canBePublishedToCurrentDatabaseIn: aSession	"Answer true if the receiver can safely be published to the current database."		(self hasTraceFor: DbRegistry dbIdentifier) ifTrue: [^true].	^(self storeForGlorpPundleClass hasVersionNamed: name in: aSession) not</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-Component Support">canReplaceVersions	"Answer true if the users agrees to replace versions."	^self hasItselfBeenModified not or: 			[ReplaceModifiedPackageNotice raiseRequestErrorString: self name]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>TEMP</category><body package="Store-Component Support">convertDbInfos	| new |	new := IdentityDictionary new.	dbInfo keysAndValuesDo:		[ :key : value |		new at: key asSymbol put: value 		].	dbInfo := new.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support">databaseClass	^self class databaseClass</body><body package="Store-Component Support">databaseId	"Answer the db identifier for the current connection, nil if none."	^self dbIdentifier</body><body package="Store-Component Support">databaseId: dbIndentifier 	"Set the database identifier."	self dbIdentifier: dbIndentifier</body><body package="Store-Component Support">dbTrace: aKeyOfDBPackage 	"Store a key of the trace package."	self databaseInformationOrCreate		dbTrace: aKeyOfDBPackage.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="Store-Component Support">doComponentUpdatingActions: codeReader	self needsMoreWork</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-file out</category><body package="Store-Component Support">fileOutChangedPropertiesForDb: dbid on: aFileManager	"File out only changed, saveable properties to aFileManager.  (If unreconciled, file out everything.	In practice, standard callers will already have done that check so this branch is unlikely to be called, 	so we do not bother protecting lazy creation of the changeSet.)"	| cs changed props |	(cs := self changeSetFor: dbid) ifNil:		[^self fileOutPropertiesOn: aFileManager].	"Not reconciled to this DB, so everything counts as changed"	cs propertiesOrNil ifNil: [^self].	"No property changes"	props := self propertiesForFileOut.	changed := IdentityDictionary new.	cs properties do:		[:symbol | 		(props includesKey: symbol) 			ifTrue: [changed at: symbol put: (props at: symbol)]].	changed size == 0 ifTrue: [^self].	self fileOutProperties: changed on: aFileManager</body><body package="Store-Component Support">fileOutChangedPropertiesOn: aFileManager	"File out only changed, saveable properties to aFileManager."	self fileOutChangedPropertiesForDb: DbRegistry dbIdentifier on: aFileManager.</body><body package="Store-Component Support">fileOutChangesForDb: dbid on: aFileManager 	self 		fileOutChangesForDb: dbid		on: aFileManager		within: (self isBundle ifTrue: [self])</body><body package="Store-Component Support">fileOutChangesOn: aFileManager 	Notice 		showProgress: (#FilingOutChangesFor1s &lt;&lt; #store &gt;&gt; 'Filing out changes for &lt;1s&gt;' expandMacrosWith: name)		complete: self changedItemCount		while: [self fileOutChangesOn: aFileManager within: nil]		title: #Store &lt;&lt; #store &gt;&gt; 'Store'</body><body package="Store-Component Support">fileOutPropertiesOn: aFileManager		| props |	props := self propertiesForFileOut.	props size isZero ifTrue:		[^aFileManager			createdComponent: self componentType			named: self name].	self fileOutProperties: props on: aFileManager</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-Component Support">hasTrace	^self dbTrace notNil and: [ self dbTrace ~= 0 ]</body><body package="Store-Component Support">hasTraceFor: aString	"Answer true if the receiver has a parent in the database, aString."	| info |	^( info := self databaseInformationFor: aString ) == nil		ifTrue: [ false ]		ifFalse: [ info hasTrace ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>public-change set access</category><body package="Store-Component Support">inspectChangeSet		self databaseInformationsDo: [:each | each inspectChangeSet]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Component Support">isConnectedToAny	^dbInfo contains: 		[ :info | info hasTrace ].</body><body package="Store-Component Support">isSameAsImage	^true</body><body package="Store-Component Support">isSaveable	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveableWithWarning"		readonly == nil ifTrue: [readonly := false].	^readonly not</body><body package="Store-Component Support">isSaveableWithWarning	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveable"		readonly == nil ifTrue: [readonly := false].	^readonly		ifTrue:			[WasConvertedFromParcelWithUndeclaredError raiseRequestErrorString: name.			false]		ifFalse: [true]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-Component Support">newestVersionWithName: aName 	"Answer the user selected published version of the receiver.	nil if none."	^self class storeDatabaseClass newestVersionWithName: aName</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-Component Support">otherChangesInclude: aChange 	^self isChangeSetEmpty		ifTrue: [false]		ifFalse: [self changeSet otherChangesInclude: aChange]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>ownership</category><body package="Store-Component Support">owner	"Returns the owner of the pundle"	^Policies ownershipPolicy ownerOfPundle: self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support">parentRecord	"Answer an instance of the glorp database record that echos the receiver.	Use the dbTrace field to retrieve record from the DB. For new packages/bundles trace can be nil.	The only time that DbRegistry might be defined and still be nil is	if StoreBase is being loaded into the image for the first time.  So,	the following check is simply to prevent walkbacks while loading StoreBase."	^self parentRecordIn: nil</body><body package="Store-Component Support">parentRecordIn: aSessionOrNil	"Answer an instance of the glorp database record that echos the receiver.	Use the dbTrace field to retrieve record from the DB. For new packages/bundles trace can be nil.	The only time that DbRegistry might be defined and still be nil is	if StoreBase is being loaded into the image for the first time.  So,	the following check is simply to prevent walkbacks while loading StoreBase."	| storePundle |	#{Store.DbRegistry}		ifDefinedDo:			[:registry | 			(registry notNil and: [registry isOnline]) ifFalse: [^nil]]		elseDo: [^nil].	self dbTrace ifNil: [^nil].	(self dbIdentifier notNil and: [self dbIdentifier = Store.DbRegistry dbIdentifier]) ifFalse: [^nil].	[storePundle := self storeForGlorpPundleClass aRecordWithID: self dbTrace in: aSessionOrNil]		on: self errorSignals		do:			[:exception | 			exception outer.			^nil].	^storePundle</body><body package="Store-Component Support">parentVersionString	"Answer a string describing the parent version."		^self traceVersion</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Component Support">pseudoPackage	"Answer false since I'm genuine."	^false</body><body package="Store-Component Support">publishedBefore: aTimestamp	| myTimestamp |	myTimestamp := self dbTimestamp notNil		ifTrue: [self dbTimestamp]		ifFalse: [Timestamp fromSeconds: 0].	^myTimestamp &lt; aTimestamp</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support">pundleChangesClass	self subclassResponsibility</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-Component Support">reconcileWithDb	"Select a database pundle as the new parent of the receiver.	Answer nil if we haven't selected anything, otherwise, we don't care what we answer"		| storePundle |	(storePundle := self selectStoreVersion) ifNil: [^nil].	self reconcileWithDbVersion: storePundle</body><body package="Store-Component Support">reconcileWithDb: aPundleOrStorePundle	"Change the receiver's change set to reflect the differences between it and &lt;aPundleOrStorePundle&gt;."		| storePundle |	storePundle := aPundleOrStorePundle asStorePundle.	ReconcilingComparitor reconcile: self against: storePundle</body><body package="Store-Component Support">reconcileWithDbIn: aSession	"Select a database pundle as the new parent of the receiver.	Answer nil if we haven't selected anything, otherwise, we don't care what we answer"		| storePundle |	(storePundle := self selectStoreVersionIn: aSession) ifNil: [^nil].	self reconcileWithDbVersion: storePundle</body><body package="Store-Component Support">reconcileWithDbVersion: dbPundle	"Select a database pundle as the new parent of the receiver."		self reconcileWithDb: dbPundle</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-Component Support">removeDbInformationFor: aCollection	"Remove any existing infos for the list of dbIdentifiers	Be careful not to remove the last one."		aCollection do:		[:eachIdentifier | 		(dbInfo size == 1 and: [dbInfo includesKey: eachIdentifier])			ifTrue: [self unlinkLastLink: eachIdentifier]			ifFalse: [dbInfo removeKey: eachIdentifier ifAbsent: [nil]]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support">removeDbs: aCollectionOfDatabaseIdentifiers	"Removes anything associated with databases in aCollectionOfDatabaseIdentifiers	This is only reached through the switchDatabase operation, 	which is only available while logged in."		dbInfo copy keys do:		[:eachDatabaseInfoSymbol | 		(aCollectionOfDatabaseIdentifiers includes: eachDatabaseInfoSymbol) ifTrue:			[dbInfo size == 1 ifTrue: [self databaseInformationForOrCreate: DbRegistry dbIdentifier].			dbInfo removeKey: eachDatabaseInfoSymbol]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>TEMP</category><body package="Store-Component Support">removeOtherDbInfos	"Store.PundleModel allGeneralInstances do:			[ :p | p removeOtherDbInfos ]		"	| id |	id := DbRegistry dbIdentifier.	dbInfo keys do:		[ :k | k = id				ifFalse: [ dbInfo removeKey: k ]		].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="Store-Component Support">runClassExtensionPostLoadMethods	"Run the #postLoad: method on any classes extended with a class-side initialize method."	"We simply ignore this because for now this is already accomplished by Package&gt;&gt;#initializeClasses:.	 That method should probably have its code to initialize extended classes removed and equivalent	 code placed here." 	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-Component Support">sameVersionAs: aPundle		^aPundle sameVersionAsLoadedPundle: self</body><body package="Store-Component Support">sameVersionAsLoadedPundle: aPundle		^aPundle name = self name and: [aPundle isPackage = self isPackage]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Component Support">sameVersionAsPublished: aDbRecord		| info |	^( info := self databaseInformationFor: aDbRecord dbIdentifier ) == nil		ifTrue: [ false ]		ifFalse: 			[ ( self hasBeenModifiedIn: aDbRecord dbIdentifier ) not				and: [ info dbTrace = aDbRecord primaryKey 				and: [self isPackage = aDbRecord isPackage]]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-Component Support">setDbTraceAndVersionUsing: aPundle for: aDatabaseIdentifierKey	| databaseInformation |	databaseInformation := self databaseInformationFor: aDatabaseIdentifierKey.	(databaseInformation isNil or: [self shouldTrackChanges]) ifFalse:		[self addOtherChange: self parentChangedMark].	(databaseInformation notNil and: [self shouldTrackChanges])		ifTrue: [databaseInformation versionString: aPundle versionString].	databaseInformation ifNotNil: [		databaseInformation setDbTrace: aPundle primaryKey;			dbTimestamp: aPundle timestamp;			dbVersion: aPundle version;			dbUsername: aPundle username].	self isInCurrentDatabase ifTrue:		[Registry traceChangedForComponent: self].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-Component Support">setNewTrace	"Select a database pundle as the new parent of the receiver."		| storePundle |	(storePundle := self selectStoreVersion) ifNil: [^nil].	self isBundle ifTrue: [self allItems do: [:each | each setNoTrace]].	self setNewTraceTo: storePundle</body><body package="Store-Component Support">setNewTraceTo: dbPundle	"Change the receiver to reflect dbPundle as it's parent."		self databaseInformationOrCreate		dbTrace: dbPundle primaryKey;		markNotModified.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support">setNoTrace	| info |	( info := self databaseInformation ) == nil		ifTrue: [ ^self ].		"already none"	info setNoTrace.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-Component Support">shortItemString	^self name, self traceVersionString</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Component Support">shouldSaveIfNotNewestVersion	| versions result pundle |	Store.Glorp.StoreObject warnIfNewerVersionPublished ifFalse: [^true].	(pundle := self asStorePundle) ifNil: [^true].	versions := self storeForGlorpPundleClass newerVersionsOf: pundle.	versions isEmpty ifTrue: [^true].	result := StoreNewVersionWarning raiseSignal: (#AtLeastOneNew1Bool2sn &lt;&lt; #store &gt;&gt;		'There is at least one newer version of &lt;1?Bundle:Package&gt; &lt;2s&gt; in the repository.&lt;n&gt;Continue to Publish?' expandMacrosWith: self isBundle with: pundle shortItemString).	^result</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="Store-Component Support">storeForGlorpPundleClass	^self subclassResponsibility.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-Component Support">storeVersions	"Return all versions for the receiver.  This assumes the system is already connected to the database."	^self storeForGlorpPundleClass allVersionsWithName: self name</body><body package="Store-Component Support">storeVersionsIn: aSession	"Return all versions for the receiver. This assumes the system is already connected to the database."	^self storeForGlorpPundleClass allVersionsWithName: self name in: aSession</body></methods><methods><class-id>Store.PundleModel</class-id> <category>relationships</category><body package="Store-Component Support">stringKey: hints 	"A string used to represent myself in browsers, for example in a menu. The 	default is to use my displayString"	^(hints includes: #blessing) 		ifTrue: 			[#Image1s &lt;&lt; #store &gt;&gt; 'Image: &lt;1s&gt;' expandMacrosWith: self versionString]		ifFalse: [self name , self traceVersionString	"displayString"]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Component Support">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body><body package="Store-Component Support">timeStampString	^'(image)'</body><body package="Store-Component Support">tracePackage		^self parentRecord</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-Component Support">traceVersionIn: aSession	"Answer a string describing a version of my trace 	pundle appropiate for version	comparisons."	| info |	^self shouldTrackChanges		ifTrue: 			[(info := self databaseInformation) isNil				ifTrue: ['']				ifFalse: [info traceVersionIn: aSession]]		ifFalse: [self version]</body><body package="Store-Component Support">traceVersionString	"Answer a string describing a version of my trace 	pundle. Use cache if possible."	| info |	^( info := self databaseInformation ) == nil		ifTrue: [ '' ]		ifFalse: [ info versionString ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-Component Support">unlinkLastLink: id 	"Remove the last dbInfo. If it has something of value, move it to no db."	| theLast |	dbInfo size == 1 ifFalse: 		[self notify: #UnexpectedShouldBeSingularDb &lt;&lt; #store &gt;&gt; 'Unexpected - should be singular db'].	theLast := dbInfo removeKey: id.	(theLast isChangeSetEmpty and: [self isPackage]) ifFalse:        [theLast unhook; dbIdentifier: self noDbSymbol.       dbInfo at: theLast dbIdentifier put: theLast].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-Component Support">userWantsFullCompare	"Answer true if the preferences are set or if the control key is down.  Otherwise, 	changesets will be used for comparison."	^self class useChangeSetsForCompare not or: [InputState default ctrlDown]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Component Support">validateDatabaseId	"Answer tuee if the receiver is linked to the current database."	^self isInCurrentDatabase</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-Component Support">versions	"Return all versions for the receiver.  This assumes the system is already connected to the database."	^self storeForGlorpPundleClass allVersionsWithName: self name</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-Component Support">versionStringAlternate	^(self hasBeenModified 		ifTrue: [(#InImage &lt;&lt; #store &gt;&gt; ' - in image - ') asString]		ifFalse: [' ']) , self traceVersionString</body><body package="Store-Component Support">versionStringFor: dbid	| info |	info := self databaseInformationFor: dbid.	info == nil		ifTrue: [ ^'' ].	^info  versionString, 		( info isChangeSetEmpty		"hasBeenModified"			ifTrue: [ '=' ]			ifFalse: [ '*' ]		)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Component Support">youngerThan: aDBPackage	^self hasBeenModified		ifTrue: [ true ]		ifFalse: [ ( self dbTraceFor: aDBPackage dbIdentifier ) &gt;= aDBPackage primaryKey ]</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>scanning-code components</category><body package="Store-Change Management">scan_pundle_loaded: anElement 	self doChange: 		( Store.PundleLoadedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			databaseId: ( self getString: 'databaseId' from: anElement default: '' );			primaryKey: ( self getString: 'primaryKey' from: anElement default: '0' ) asNumber			yourself 		  )</body><body package="Store-Change Management">scan_pundle_saved: anElement 	self doChange: 		( Store.PundleSavedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			databaseId: ( self getString: 'databaseId' from: anElement default: '' );			primaryKey: ( self getString: 'primaryKey' from: anElement default: '0' ) asNumber			yourself 		  )</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="Store-Change Management">asTag	^Store.ClassTag newClassName: self absoluteName isMeta: false.</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management">loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	"So it shows up in references and senders..."	Array with: CodeComponent with: #reloadPundle:named:id:fromDatabase:.	aStream nextChunkPut: 		( '#{Store.Glorp.StorePundle} ifDefinedDo:&lt;n&gt;[ :pundleClass |&lt;n&gt;pundleClass reloadPundle: &lt;1s&gt; named: &lt;2s&gt; id: &lt;3s&gt; fromDatabase: &lt;4s&gt;&lt;n&gt;].'				expandMacrosWith: pundleType storeString				with: name printString				with: key storeString				with: databaseId asString printString		); cr.</body><body package="Store-Change Management">savePundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the saving of a Pundle event on a stream - action is same as loading. "	"For packages there is no difference in restoring a save and a load."	self loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management">bundleStructure:  aBundle on: aStream	"Add the loading of a package/bundle event on a stream. "	^self subclassResponsibility</body><body package="Store-Change Management">loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a package/bundle event on a stream. "	^self subclassResponsibility</body><body package="Store-Change Management">savePundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the saving of a package/bundle event on a stream. "	^self subclassResponsibility</body></methods><methods><class-id>Kernel.ComponentDefinitionChange</class-id> <category>store</category><body package="Store-Change Management">doChangeTo: aChangeSet	"Perfrom the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := self isForClass		ifTrue: [ Store.Change new className: definitionName meta: false ]		ifFalse: [ Store.Change new nameSpaceSymbol: definitionName ].	self performChange: change to: aChangeSet.</body><body package="Store-Change Management">performChange: aChange to: aChangeSet	definitionChange == #added		ifTrue: [ aChange add ]		ifFalse: [ aChange remove ].		aChangeSet doChange: aChange.</body></methods><methods><class-id>Kernel.ChangeSet class</class-id> <category>component change management</category><body package="Store-Change Management">loadPundle: aPundle	"Include indication that aPundle was loaded."	self changed: #loadPundle: with: ( Array with: aPundle )</body><body package="Store-Change Management">savePundle: aPundle	"Include indication that aPundle was loaded."	self changed: #savePundle: with: ( Array with: aPundle )</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>component change management</category><body package="Store-Change Management">loadPundle: aPundle	"Include indication that aPundle was loaded."	self addComponentChange:			( Store.PundleLoadedChange new				component: aPundle;				yourself 			)</body><body package="Store-Change Management">savePundle: aPundle	"Include indication that aPundle was loaded."	self addComponentChange:			( Store.PundleSavedChange new				component: aPundle;				yourself 			)</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>fileIn/Out</category><body package="Store-Change Management">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#class</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>accessing</category><body package="Store-Change Management">modifiedTags	"Answer a collection of tags for changed or add definitions, methods or data, 	not including removed definitions."		| tags |	tags := OrderedCollection new.	(self isAdded or: [self isClassChangedMeta: false]) ifTrue: 		[tags add: (ClassTag newClassSymbol: symbol isMeta: false)].	(self isClassChangedMeta: true) ifTrue: 		[tags add: (ClassTag newClassSymbol: symbol isMeta: true)].	self isCommented ifTrue: 		[tags add: (ClassCommentTag newClassSymbol: symbol isMeta: false)].	(self modifiedSelectorsMeta: false) do: 		[:each | tags add: (MethodTag newClassSymbol: symbol isMeta: false selector: each)].	(self modifiedSelectorsMeta: true) do: 		[:each | tags add: (MethodTag newClassSymbol: symbol isMeta: true selector: each)].	self modifiedDataKeys do: 		[:each | tags add: (DataTag newClassSymbol: symbol dataKey: each)].	^tags</body><body package="Store-Change Management">removedTags	"Answer a collection of tags for removed definitions, methods or data."		| tags |	tags := OrderedCollection new.	(self isRemoved or: [self isDefinitionRemoved]) ifTrue: 		[tags add: (ClassTag newClassSymbol: symbol isMeta: false)].	(self removedSelectorsMeta: false) do: 		[:selector | tags add: (MethodTag newClassSymbol: symbol isMeta: false selector: selector)].	(self removedSelectorsMeta: true) do: 		[:selector | tags add: (MethodTag newClassSymbol: symbol isMeta: true selector: selector)].	self removedDataKeys do: 		[:dataKey | tags add: (DataTag newClassSymbol: symbol dataKey: dataKey)].	^tags</body></methods><methods><class-id>Kernel.ComponentChange</class-id> <category>store</category><body package="Store-Change Management">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	" self subclassResponsibility "	"default to do nothing"</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>accessing</category><body package="Store-Change Management">dataChanges	"Answer a collection of Changes for all modified/added/removed statics"	| coll |	dataChanges == nil		ifTrue: [ ^#( ) ].	coll := OrderedCollection new.	dataChanges keysAndValuesDo:		[ :key :type | 		coll add:			( Change new				nameSpaceSymbol: symbol;				dataKey: key;				perform: type;				yourself				)		].	^coll</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>fileIn/Out</category><body package="Store-Change Management">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#namespace</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>accessing</category><body package="Store-Change Management">modifiedDatumDescriptors	^( self getDataChangesIfNone: [ ^#( ) ] ) keys collect:		[ :key  | DatumDescriptor fromDataKey: key nameSpaceName: symbol asString ].</body><body package="Store-Change Management">modifiedTags	"Answer a collection of tags for changed or add definitions, methods or data, 	not including removed definitions."		| tags |	tags := OrderedCollection new.	(self isAdded or: [self isChanged]) ifTrue: 		[tags add: (NameSpaceTag newNameSpaceSymbol: symbol)].	self isCommented ifTrue: 		[tags add: (NameSpaceCommentTag newNameSpaceSymbol: symbol)].	self modifiedDataKeys do: 		[:each | tags add: (DataTag newNameSpaceSymbol: symbol dataKey: each)].	^tags</body><body package="Store-Change Management">removedTags	"Answer a collection of tags for removed definitions or data."	| tags |	tags := OrderedCollection new.	( self isDefinitionRemoved )		ifTrue: [ tags add: ( NameSpaceTag newNameSpaceSymbol: symbol ) ].	self removedDataKeys do: 		[ :dataKey | tags add: ( DataTag newNameSpaceSymbol: symbol dataKey: dataKey ) ].	^tags</body></methods><methods><class-id>Kernel.ComponentSelectorChange</class-id> <category>store</category><body package="Store-Change Management">doChangeTo: aChangeSet	"Perfrom the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := Store.Change new className: definitionName meta: meta.	change selector: self selector.	self performChange: change to: aChangeSet.</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="Store-Change Management">asTag	^Store.MethodTag 		newClassName: self implementingClass absoluteName		meta: self isMeta		selector: self selector asSymbol		protocol: self protocol.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-method changes</category><body package="Store-Change Management">revertData: aSymbol owner: aClassOrNameSpace	"Reload from the database the most recently loaded version of the data described. 	Assumes that we've already verified that this is actually possible. "		| tracePackage packageModel |	packageModel := Registry containingPackageForDataKey: aSymbol symbol: aClassOrNameSpace absoluteSymbol.	Cursor wait showWhile:		[DbRegistry doIfOnlineImage:			[(tracePackage := packageModel tracePackage) ifNil: [^self warnNoParentForSharedInDatabase].			tracePackage 				loadData: aSymbol 				ownerName: aClassOrNameSpace absoluteName 				ifNone: [^self warnCanNotRevertSharedNoParent: tracePackage].			packageModel changeSet forgetDataChange: aSymbol owner: aClassOrNameSpace]]</body><body package="Store-Change Management">revertSelector: selector class: class	"Reload from the database the most recently loaded version of the method described. 	Assumes that we've already verified that this is actually possible. 	Answer true if sucessful."		| traceStorePackage packageModel |	packageModel := Registry containingPackageForSelector: selector class: class.	Cursor wait showWhile:		[DbRegistry doIfOnlineImage:			[(traceStorePackage := packageModel tracePackage) isNil ifTrue: 				[^self warnForNoParentInDatabase].			traceStorePackage 				loadMethod: selector 				className: class absoluteName 				ifNone: [^self warnForCanNotRevertInPackage: traceStorePackage].			packageModel changeSet forgetMethodChange: selector class: class]].	^true</body><body package="Store-Change Management">warnCanNotRevertSharedNoParent: tracePackage		^Dialog		warn:			(#ParentDoesNotContainData &lt;&lt; #store &gt;&gt;					'The parent package &lt;1s&gt; does not contain this data.&lt;n&gt;Cannot revert method to previous version.&lt;n&gt;Perhaps you want "remove..."'				expandMacrosWith: tracePackage itemString)</body><body package="Store-Change Management">warnForCanNotRevertInPackage: traceStorePackage		Dialog		warn:			(#ParentDoesNotContainMethod &lt;&lt; #store &gt;&gt;					'The parent package &lt;1s&gt; does not contain this method.&lt;n&gt;Cannot revert method to previous version.&lt;n&gt;Perhaps you want "remove..."'				expandMacrosWith: traceStorePackage itemString).	^false</body><body package="Store-Change Management">warnForNoParentInDatabase		Dialog		warn:			(#NoParentForMethod &lt;&lt; #store &gt;&gt; 'The package containing this method has no parent in the database.&lt;n&gt;Cannot revert method to previous version.')				expandMacros.	^false</body><body package="Store-Change Management">warnNoParentForSharedInDatabase		^Dialog		warn:			(#NoParentForDataKey &lt;&lt; #store &gt;&gt; 'The package containing this datakey has no parent in the database.&lt;n&gt;Cannot revert datakey to previous version.')				expandMacros</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="Store-Change Management">asTag	^self isInClass		ifTrue: [ Store.DataTag newClassName: self absoluteOwnerName dataKey: self dataKey ]		ifFalse: [ Store.DataTag newNameSpaceName: self absoluteOwnerName dataKey: self dataKey ]</body></methods><methods><class-id>Kernel.ComponentStaticChange</class-id> <category>store</category><body package="Store-Change Management">doChangeTo: aChangeSet	"Perform the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := Store.Change new actual: self owner.	change dataKey: self dataKey.	self performChange: change to: aChangeSet.</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management">loadPundle: name type: typeSymbol primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'pundle-loaded' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str cr.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'primaryKey' value: key storeString.		str cr.		xml on: str tag: 'databaseId' value: databaseId storeString.		str cr.		]</body><body package="Store-Change Management">savePundle: name type: typeSymbol primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'pundle-saved' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str cr.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'primaryKey' value: key storeString.		str cr.		xml on: str tag: 'databaseId' value: databaseId storeString.		str cr.		]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="Store-Change Management">loadPundle: aPundle	self 		loadPundleNamed: aPundle name		type: aPundle componentType		primaryKey: aPundle primaryKey 		databaseId: aPundle dbIdentifier</body><body package="Store-Change Management">loadPundleNamed: pundleName type: typeSymbol primaryKey: anInteger databaseId: aString 	self noTargetForWrites 		ifFalse: 			[self targetFormatter 				loadPundle: pundleName				type: typeSymbol				primaryKey: anInteger				databaseId: aString				on: self targetFile]</body><body package="Store-Change Management">savePundle: aPundle	self 		savePundleNamed: aPundle name		type: aPundle componentType		primaryKey: aPundle primaryKey 		databaseId: aPundle databaseId</body><body package="Store-Change Management">savePundleNamed: pundleName type: typeSymbol primaryKey: anInteger databaseId: aString 	self noTargetForWrites 		ifFalse: 			[self targetFormatter 				savePundle: pundleName				type: typeSymbol				primaryKey: anInteger				databaseId: aString				on: self targetFile]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-fileIn/Out</category><body package="Store-Change Management">fileOutOn: outputStream classSymbol: classSymbol	"Write out all the changes the receiver knows about."		| fileManager cc |	fileManager := outputStream.	fileManager deferInitializations.	cc := self at: classSymbol.	(cc isRemoved or: [cc isDefinitionRemoved])		ifTrue: [fileManager removeObject: classSymbol type: cc fileOutObjectType]		ifFalse:			[| class |			class := classSymbol asStrictReference				valueOrDo: [^FileOutClassDoesntExistError raiseRequestErrorString: classSymbol].			cc fileOutChangesFor: class for: nil within: nil on: fileManager.			cc fileOutChangesFor: class class for: nil within: nil on: fileManager].	fileManager finishInitializations.	fileManager cr</body><body package="Store-Change Management">fileOutOn: outputStream within: aBundle	"Write out all the changes the receiver knows about."	self fileOutOn: outputStream for: nil within: aBundle</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-lists</category><body package="Store-Change Management">modifiedTags	"Answer a collection of tags for changed or add class definitions,	methods or data, not including removed definitions."	| tags props |	tags := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc | tags addAll: cc modifiedTags ].	( props := self propertiesOrNil ) == nil		ifFalse: [ props do: [ :prop | tags add: ( PropertyTag new property: prop ) ] ].	( other ~~ nil and: [ other includes: BundleModel structureMark ] )		ifTrue: [ tags add: BundleStructureTag new ].	^tags</body><body package="Store-Change Management">removedTags	"Answer a collection of tags for removed class/namespace definitions,	methods and data."	| tags |	tags := OrderedCollection new.	self keysAndValuesDo: [ :symbol :cc | tags addAll: cc removedTags ].	^tags</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-Change Management">modificationsFor: dbid	"Answer my content as a collection of modifications in order."	| mods |	mods := List new.	mods addAll: ( self basicModificationsFor: dbid ).	self leafItems do:		[ :pkg | mods addAll: ( pkg modificationsFor: dbid ) ].	^mods</body></methods><methods><class-id>Kernel.PropertyChange</class-id> <category>store</category><body package="Store-Change Management">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	aChangeSet addPropertyChange: property</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-Change Management">modifications	"Answer my content as a collection of modifications."	| mods |	mods := List new.	self isChangeSetEmpty ifTrue: [ ^mods ].	self changeSet modifiedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: tag sourceTextForImage				)		].	self changeSet removedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: nil				)		].	^mods</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>compiling-code components</category><body package="Store-Change Management">compile_pundle_loaded: anElement		#{Store.Glorp.StorePundle}		ifDefinedDo:			[:pundleClass | 			pundleClass				reloadPundle: (self getSymbol: 'type' from: anElement)				named: (self getString: 'name' from: anElement default: '')				id: (self getString: 'primaryKey' from: anElement default: '0') asNumber				fromDatabase: (self getString: 'databaseId' from: anElement default: '')]</body><body package="Store-Change Management">compile_pundle_saved: anElement		#{Store.Glorp.StorePundle}		ifDefinedDo:			[:pundleClass | 			pundleClass				reloadPundle: (self getSymbol: 'type' from: anElement)				named: (self getString: 'name' from: anElement default: '')				id: (self getString: 'primaryKey' from: anElement default: '0') asInteger				fromDatabase: (self getString: 'databaseId' from: anElement default: '')]</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="Store-Change Management">asTag	^Store.NameSpaceTag newNameSpaceName: self absoluteName</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Change Management">basicallySameVersionAsPublished: aDbRecord		| info |	^( info := self databaseInformationFor: aDbRecord dbIdentifier ) notNil		and: [ info dbTrace = aDbRecord primaryKey ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="Store-Change Management">basicModificationsFor: dbid	"Answer my content as a collection of modifications."	| mods cs |	mods := List new.	cs := self changeSetFor: dbid.	cs == nil		ifTrue: [ cs :=  ( dbInfo at: self noDbSymbol ifAbsent: [ ^mods ] ) changeSet ].	cs isEmpty ifTrue: [ ^mods ].	cs modifiedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: ( tag sourceTextForImage: self )				)		].	cs removedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: nil				)		].	^mods</body></methods><methods><class-id>OS.LogicalFilename</class-id> <category>testing</category><body package="Store-User Management">hasSystemVariable	^false</body></methods><methods><class-id>OS.PortableFilename</class-id> <category>testing</category><body package="Store-User Management">hasSystemVariable	^components first isString not</body></methods><methods><class-id>Store.Access class</class-id> <category>filein/fileout</category><body package="Store-User Management">prerequisitesForLoading	^super prerequisitesForLoading		add: BasicBlessingPolicy;		add: BasicPublishPolicy;		add: BasicMergePolicy;		add: BasicOwnershipPolicy;		add: BasicPackagePolicy;		add: BasicVersionPolicy;		add: BranchingVersionPolicy;		add: BasicTableSpacePolicy;		add: BasicFilePolicy;		yourself</body></methods><methods><class-id>Store.Access</class-id> <category>accessing</category><body package="Store-User Management">includeBranchBlessingCommentHistory	^self mergePolicy includeBranchBlessingCommentHistory</body><body package="Store-User Management">includeBranchBlessingCommentHistory: aSymbol	self mergePolicy includeBranchBlessingCommentHistory: aSymbol</body><body package="Store-User Management">integratedBlessingChangePolicy	^self mergePolicy integratedBlessingChangePolicy</body><body package="Store-User Management">integratedBlessingChangePolicy: aSymbol	self mergePolicy integratedBlessingChangePolicy: aSymbol</body><body package="Store-User Management">mergeToolMaxInitialTreeSize	^self mergePolicy mergeToolMaxInitialTreeSize</body><body package="Store-User Management">mergeToolMaxInitialTreeSize: anInteger	self mergePolicy mergeToolMaxInitialTreeSize: anInteger</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="Store-Database Model">glorpCopyIn: aDictionary	"For non-storeForGlorp objects, just copy normally"	^self copy.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Store-Database Model">isImageObject	^true</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor role: roleName	"DatabaseAccessor not really needed for this platform because it uses an 	implicit schema and doesn't need changes for script vs direct execution."	^'CREATE VIEW TW_MethodsView as	SELECT TW_Method.primaryKey, TW_Method.name, TW_Method.timeStamp, TW_Method.version, TW_Method.userName, TW_Method.trace, TW_Method.className, TW_Methods.packageRef, TW_Method.sourceCodeID, TW_Method.protocolName	FROM TW_Methods, TW_Method	WHERE TW_Methods.methodRef = TW_Method.primaryKey;GRANT SELECT ON TW_MethodsView TO &lt;1s&gt;;CREATE VIEW TW_PkgClassesView as	SELECT TW_ClassRecord.primaryKey, TW_ClassRecord.name, TW_ClassRecord.timeStamp, TW_ClassRecord.userName, TW_ClassRecord.trace, TW_ClassRecord.superclass, TW_ClassRecord.definitionID, TW_ClassRecord.environmentString, TW_ClassRecord.commentID, TW_PkgClasses.packageRef, TW_PkgClasses.definitionOrder	FROM TW_PkgClasses, TW_ClassRecord	WHERE TW_PkgClasses.classRef = TW_ClassRecord.primaryKey;GRANT SELECT ON TW_PkgClassesView TO &lt;1s&gt;;CREATE VIEW TW_PkgMetaclassesView as	SELECT TW_ClassRecord.primaryKey, TW_ClassRecord.name, TW_ClassRecord.timeStamp, TW_ClassRecord.userName, TW_ClassRecord.trace, TW_ClassRecord.superclass, TW_ClassRecord.definitionID, TW_ClassRecord.environmentString, TW_ClassRecord.commentID, TW_PkgClasses.packageRef, TW_PkgClasses.definitionOrder	FROM TW_PkgClasses, TW_ClassRecord	WHERE TW_PkgClasses.metaclassRef = TW_ClassRecord.primaryKey;GRANT SELECT ON TW_PkgMetaclassesView TO &lt;1s&gt;;CREATE VIEW TW_PkgNameSpacesView as	SELECT TW_NameSpaceRecord.primaryKey, TW_NameSpaceRecord.name, TW_NameSpaceRecord.timeStamp, TW_NameSpaceRecord.userName, TW_NameSpaceRecord.trace, TW_NameSpaceRecord.definitionID, TW_NameSpaceRecord.commentID, TW_NameSpaceRecord.environmentString, TW_PkgNameSpaces.packageRef, TW_PkgNameSpaces.definitionOrder	FROM TW_PkgNameSpaces, TW_NameSpaceRecord	WHERE TW_PkgNameSpaces.nameSpaceRef = TW_NameSpaceRecord.primaryKey;GRANT SELECT ON TW_PkgNameSpacesView TO &lt;1s&gt;;CREATE VIEW TW_DataView as	SELECT TW_DataElement.primaryKey, TW_DataElement.name, TW_DataElement.timeStamp, TW_DataElement.userName, TW_DataElement.trace, TW_Data.packageRef, TW_DataElement.definitionID, TW_DataElement.commentID, TW_DataElement.environmentString, TW_DataElement.protocolName, TW_DataElement.typeString	FROM TW_Data, TW_DataElement	WHERE TW_Data.dataRef = TW_DataElement.primaryKey;GRANT SELECT ON TW_DataView TO &lt;1s&gt;;CREATE VIEW TW_PropertiesView as	SELECT TW_PropertyRecord.primaryKey, TW_PropertyRecord.name, TW_PropertyRecord.timeStamp, TW_PropertyRecord.userName, TW_PropertyRecord.trace, TW_PropertyRecord.definitionID, TW_PropertyRecord.commentID, TW_PropertyRecord.environmentString, TW_PropertyRecord.searchString, TW_Properties.pundleRef, TW_Properties.recType	FROM TW_Properties, TW_PropertyRecord	WHERE TW_Properties.propertyRef = TW_PropertyRecord.primaryKey;GRANT SELECT ON TW_PropertiesView TO &lt;1s&gt;;CREATE VIEW TW_MethodsAndSourcesView as	SELECT TW_Method.primaryKey, TW_Method.name, TW_Method.timeStamp, TW_Method.version, TW_Method.userName, TW_Method.trace, TW_Method.className, TW_Methods.packageRef, TW_Method.sourceCodeID, TW_Method.protocolName, TW_Blob.blobData, TW_Blob.blobType	FROM TW_Method JOIN TW_Methods ON ((TW_Method.primaryKey = TW_Methods.methodRef))  JOIN TW_Blob ON ((TW_Method.sourceCodeID = TW_Blob.primaryKey));GRANT SELECT ON TW_MethodsAndSourcesView TO &lt;1s&gt;;CREATE VIEW TW_DataAndSourcesView as	SELECT TW_DataElement.primaryKey, TW_DataElement.name, TW_DataElement.timeStamp, TW_DataElement.userName, TW_DataElement.trace, TW_Data.packageRef, TW_DataElement.definitionID, TW_DataElement.commentID, TW_DataElement.environmentString, TW_DataElement.protocolName, TW_DataElement.typeString, TW_Blob.blobData, TW_Blob.blobType	FROM TW_DataElement JOIN TW_Data ON ((TW_DataElement.primaryKey = TW_Data.dataRef))  JOIN TW_Blob ON ((TW_DataElement.definitionID = TW_Blob.primaryKey));GRANT SELECT ON TW_DataAndSourcesView TO &lt;1s&gt;;CREATE VIEW TW_PkgClassesAndSourcesView as	SELECT TW_ClassRecord.primaryKey, TW_ClassRecord.name, TW_ClassRecord.timeStamp, TW_ClassRecord.userName, TW_ClassRecord.trace, TW_ClassRecord.superclass, TW_ClassRecord.definitionID, TW_ClassRecord.environmentString, TW_ClassRecord.commentID, TW_PkgClasses.packageRef, TW_PkgClasses.definitionOrder, TW_Blob.blobData, TW_Blob.blobType	FROM TW_ClassRecord JOIN TW_PkgClasses ON ((TW_ClassRecord.primaryKey = TW_PkgClasses.classRef))  JOIN TW_Blob ON ((TW_ClassRecord.definitionID = TW_Blob.primaryKey));GRANT SELECT ON TW_PkgClassesAndSourcesView TO &lt;1s&gt;;CREATE VIEW TW_PkgNameSpacesAndSourcesView as	SELECT TW_NameSpaceRecord.primaryKey, TW_NameSpaceRecord.name, TW_NameSpaceRecord.timeStamp, TW_NameSpaceRecord.userName, TW_NameSpaceRecord.trace, TW_NameSpaceRecord.definitionID, TW_NameSpaceRecord.commentID, TW_NameSpaceRecord.environmentString, TW_PkgNameSpaces.packageRef, TW_PkgNameSpaces.definitionOrder, TW_Blob.blobData, TW_Blob.blobType	FROM TW_NameSpaceRecord JOIN TW_PkgNameSpaces ON ((TW_NameSpaceRecord.primaryKey = TW_PkgNameSpaces.nameSpaceRef))  JOIN TW_Blob ON ((TW_NameSpaceRecord.definitionID = TW_Blob.primaryKey));GRANT SELECT ON TW_PkgNameSpacesAndSourcesView TO &lt;1s&gt;'	expandMacrosWith: roleName</body><body package="Store-Database Model">dropStoreSpecificViewsSQL	^'DROP VIEW TW_PkgNameSpacesAndSourcesView;DROP VIEW TW_PkgClassesAndSourcesView;DROP VIEW TW_DataAndSourcesView;DROP VIEW TW_MethodsAndSourcesView;DROP VIEW TW_PropertiesView;DROP VIEW TW_DataView;DROP VIEW TW_PkgNameSpacesView;DROP VIEW TW_PkgMetaclassesView;DROP VIEW TW_PkgClassesView;DROP VIEW TW_MethodsView'</body><body package="Store-Database Model">grantStoreSpecificPermissionsSQLOnSchema: schemaName toRole: roleName	"DatabaseAccessor not really needed for this platform because it uses an 	implicit schema and doesn't need changes for script vs direct execution."	^'GRANT SELECT, INSERT ON TABLE tw_binaryblob TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT ON TABLE tw_blessing TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_blob TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT ON TABLE tw_bundle TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_bundles TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_classrecord TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT, DELETE ON TABLE tw_data TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_databaseidentifier TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_dataelement TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT ON TABLE tw_filerecord TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_files TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT ON TABLE tw_method TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT, DELETE ON TABLE tw_methods TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_namespacerecord TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT ON TABLE tw_package TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_packages TO &lt;1s&gt;;GRANT SELECT, UPDATE, INSERT ON TABLE tw_parcelrecord TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_pkgclasses TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_pkgnamespaces TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_properties TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_propertyrecord TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_binaryblob_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_blessing_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_blob_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_bundle_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_classrecord_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_dataelement_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_filerecord_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_method_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_namespacerecord_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_package_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_parcelrecord_sequence TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TABLE tw_propertyrecord_sequence TO &lt;1s&gt;;GRANT SELECT ON TABLE tw_dbpundleprivileges TO &lt;1s&gt;;GRANT SELECT ON TABLE tw_dbusergroup TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_loadrecord TO &lt;1s&gt;;GRANT SELECT, INSERT ON TABLE tw_methoddocs TO &lt;1s&gt;'	expandMacrosWith: roleName asLowercase.</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>testing - errors</category><body package="Store-Database Model">isRoleAlreadyExistsError: dbmsError	^'* role * already exists*' match: dbmsError dbmsErrorString</body><body package="Store-Database Model">isUserAlreadyExistsError: dbmsError	^self isRoleAlreadyExistsError: dbmsError</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>services - users and roles</category><body package="Store-Database Model">sqlStatementToCreateRole: roleName	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE ROLE ';		nextPutAll: roleName.	^writeStream contents</body><body package="Store-Database Model">sqlStatementToCreateUser: loginName password: loginPassword	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE USER ';		nextPutAll: loginName;		nextPutAll: ' PASSWORD ';		nextPut: $';		nextPutAll: loginPassword;		nextPut: $'.	^writeStream contents</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^#{PostgreSQLError} ifDefinedDo: [:value | value] elseDo: [nil]</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>sequences</category><body package="Store-Database Model">storeSequenceNameFor: aString	"Return a string representing the default Store sequence name on this platform"	^aString, '_sequence'.</body></methods><methods><class-id>Core.Metaclass</class-id> <category>store for glorp</category><body package="Store-Database Model">asStoreClassDefinition	^Store.Glorp.StoreClassDefinition newFrom: self</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">configureSystemForStore: aStoreDescriptorSystem	"The need for this may be dropped from 8.2 or later StoreDescriptorSystem subclasses."		| blobTableNames methodTableNames userGroupTableNames skipTableNames defaultTableNames |	blobTableNames := #('TW_Blob' 'TW_BinaryBlob').	self setSchemaForTablesNamed: blobTableNames		tablespaceName: Store.Policies tableSpacePolicy blobTableSpace		descriptorSystem: aStoreDescriptorSystem.		methodTableNames := #('TW_Method' 'TW_Methods').	self setSchemaForTablesNamed: methodTableNames		tablespaceName: Store.Policies tableSpacePolicy methodsTableSpace		descriptorSystem: aStoreDescriptorSystem.	userGroupTableNames := #('TW_DBUserGroup' 'TW_DBPundlePrivileges').	self setSchemaForTablesNamed: userGroupTableNames		tablespaceName: Store.Policies tableSpacePolicy userAndOwnershipTableSpace		descriptorSystem: aStoreDescriptorSystem.	skipTableNames := Set new		addAll: blobTableNames;		addAll: methodTableNames;		addAll: userGroupTableNames;		yourself.		defaultTableNames := aStoreDescriptorSystem allTableNames reject: [:ea| skipTableNames includes: ea].	self setSchemaForTablesNamed: defaultTableNames		tablespaceName: Store.Policies tableSpacePolicy defaultTableSpace		descriptorSystem: aStoreDescriptorSystem</body><body package="Store-Database Model">createDatabase: aDatabaseName onDevice: aDeviceName size: aString in: aDatabaseAccessor	"SQLServer will perform some DDL operations in a transaction but not others.  Database creation must be outside a transaction."	| sqlString |	self setCurrentDatabase: 'master' inAccessor: aDatabaseAccessor.	sqlString := self createDatabaseStringFor: aDatabaseName on: aDeviceName size: aString.	aDatabaseAccessor executeSQLStringNoResult: sqlString.</body><body package="Store-Database Model">createDatabaseStringFor: aDatabaseName on: aDeviceName size: aString	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE DATABASE ';		nextPutAll: aDatabaseName;		nextPutAll: ' ON  ( NAME = ';		nextPutAll: aDatabaseName , '_dat';		nextPutAll: ', FILENAME = ';		nextPut: $';		nextPutAll: aDeviceName;		nextPut: $';		nextPutAll: ', SIZE = ';		nextPutAll: aString;		nextPutAll: ' )'.	^writeStream contents</body><body package="Store-Database Model">createNewAccountIn: aDatabaseAccessor	"Create the  SQL Server security account."	| str res tableOwner |	tableOwner := aDatabaseAccessor currentLogin schema.	(tableOwner equivalentTo: 'dbo' ignoreCase:  true) ifTrue: [^false].	str := (String new: 50) writeStream. 	str nextPutAll: ((#PressYesToCreateAccount1s1sn &lt;&lt; #store &gt;&gt; 'Press Yes to create a new account: &lt;1s&gt; password: &lt;1s&gt;&lt;n&gt;') expandMacrosWith: tableOwner).	str nextPutAll: (#PressNoToUseDBO &lt;&lt; #store &gt;&gt; 'Press No to use the dbo account&lt;n&gt;') expandMacros.	str nextPutAll:(#PressCancelToCancel &lt;&lt; #store &gt;&gt; 'Press Cancel  to cancel the installation') asString.		res := Dialog		choose: str contents		labels: (Array with: 'Yes' with: 'No'  with: 'Cancel')		values: #(#yes #no #cancel)		default: #maybe.	res == #yes ifTrue: 		[aDatabaseAccessor createUser: tableOwner password: tableOwner.		^ true].	res == #no ifTrue: 		[Store.DbRegistry updateTablePrefix: 'dbo'. 		^ false].	res == #cancel ifTrue: [Error raiseSignal: self installationCanceledMessage].</body><body package="Store-Database Model">createRole: roleName database: databaseName usingAccessor: aDatabaseAccessor	self setCurrentDatabase: databaseName inAccessor: aDatabaseAccessor.		[aDatabaseAccessor		executeSQLStringNoResult: (self sqlStatementToCreateDatabaseRole: roleName authorizedBy: aDatabaseAccessor currentLogin schema).	aDatabaseAccessor logOnly		ifTrue: [aDatabaseAccessor platform endBatchForScriptIn: aDatabaseAccessor]]			on: Error			do: [:ex | self halt].</body><body package="Store-Database Model">createSchemaIfNecessaryIn: tableSpaceName usingAccessor: aDatabaseAccessor	self createSchemaIn: tableSpaceName named: aDatabaseAccessor schema ownedBy: aDatabaseAccessor schema accessor: aDatabaseAccessor</body><body package="Store-Database Model">createSchemaIn: databaseName named: schemaName ownedBy: schemaOwner accessor: aDatabaseAccessor	aDatabaseAccessor executeSQLStringNoResult: 'USE ' , databaseName.	self endBatchForScriptIn: aDatabaseAccessor.	aDatabaseAccessor		executeSQLStringNoResult: (self sqlStatementToCreateSchema: schemaName				ownedBy: schemaOwner).	self endBatchForScriptIn: aDatabaseAccessor</body><body package="Store-Database Model">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor role: roleName	| endOfBatchString tablespacePolicy arguments |	endOfBatchString := (aDatabaseAccessor logOnly)		ifTrue: [self sqlStatementForEndOfBatch]		ifFalse: ['--'].	tablespacePolicy := Store.Policies tableSpacePolicy.	arguments := (OrderedCollection new)		add: tablespacePolicy defaultTableSpace;		add: tablespacePolicy methodsTableSpace;		add: tablespacePolicy blobTableSpace;		add: endOfBatchString;		add: aDatabaseAccessor schema;		add: roleName;		yourself.	^'USE  &lt;2s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_MethodsView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.version, t2.userName, t2.trace, t2.className, 		t1.packageRef, t2.sourceCodeID, t2.protocolName	FROM &lt;5s&gt;.TW_Methods t1, &lt;5s&gt;.TW_Method t2	WHERE t1.methodRef = t2.primaryKey;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_MethodsView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_PkgClassesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.superclass, t2.definitionID, 		t2.environmentString, t2.commentID, t1.packageRef, t1.definitionOrder	FROM &lt;5s&gt;.TW_PkgClasses t1, &lt;5s&gt;.TW_ClassRecord t2	WHERE t1.classRef = t2.primaryKey;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_PkgClassesView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_PkgMetaclassesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.superclass, t2.definitionID, 		t2.environmentString, t2.commentID, t1.packageRef, t1.definitionOrder	FROM &lt;5s&gt;.TW_PkgClasses t1, &lt;5s&gt;.TW_ClassRecord t2	WHERE t1.metaclassRef = t2.primaryKey;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_PkgMetaclassesView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_PkgNameSpacesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.definitionID, 		t2.commentID, t2.environmentString, t1.packageRef, t1.definitionOrder	FROM &lt;5s&gt;.TW_PkgNameSpaces t1, &lt;5s&gt;.TW_NameSpaceRecord t2	WHERE t1.nameSpaceRef = t2.primaryKey;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_PkgNameSpacesView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_DataView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t1.packageRef, 		t2.definitionID, t2.commentID, t2.environmentString, t2.protocolName, t2.typeString	FROM &lt;5s&gt;.TW_Data t1, &lt;5s&gt;.TW_DataElement t2	WHERE t1.dataRef = t2.primaryKey;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_DataView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_PropertiesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.definitionID, 		t2.commentID, t2.environmentString, t2.searchString, t1.pundleRef, t1.recType	FROM &lt;5s&gt;.TW_Properties t1, &lt;5s&gt;.TW_PropertyRecord t2	WHERE t1.propertyRef = t2.primaryKey;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_PropertiesView TO &lt;6s&gt;;USE  &lt;2s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_MethodsAndSourcesView as	SELECT t1.primaryKey, t1.name, t1.timeStamp, t1.version, t1.userName, t1.trace, t1.className, 		t2.packageRef, t1.sourceCodeID, t1.protocolName, t3.blobData, t3.blobType	FROM &lt;5s&gt;.TW_Method t1 	JOIN &lt;5s&gt;.TW_Methods t2 ON ((t1.primaryKey = t2.methodRef))  	JOIN &lt;3s&gt;.&lt;5s&gt;.TW_Blob t3 ON ((t1.sourceCodeID = t3.primaryKey)) ;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_MethodsAndSourcesView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_DataAndSourcesView as	SELECT t1.primaryKey, t1.name, t1.timeStamp, t1.userName, t1.trace, t2.packageRef, t1.definitionID, 		t1.commentID, t1.environmentString, t1.protocolName, t1.typeString, t3.blobData, t3.blobType	FROM &lt;5s&gt;.TW_DataElement t1 	JOIN &lt;5s&gt;.TW_Data t2 ON ((t1.primaryKey = t2.dataRef))  	JOIN &lt;3s&gt;.&lt;5s&gt;.TW_Blob t3 ON ((t1.definitionID = t3.primaryKey)) ;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_DataAndSourcesView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_PkgClassesAndSourcesView as	SELECT t1.primaryKey, t1.name, t1.timeStamp, t1.userName, t1.trace, t1.superclass, t1.definitionID, 		t1.environmentString, t1.commentID, t2.packageRef, t2.definitionOrder, t3.blobData, t3.blobType	FROM &lt;5s&gt;.TW_ClassRecord t1	JOIN &lt;5s&gt;.TW_PkgClasses t2 ON ((t1.primaryKey = t2.classRef))  	JOIN &lt;3s&gt;.&lt;5s&gt;.TW_Blob t3 ON ((t1.definitionID = t3.primaryKey)) ;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_PkgClassesAndSourcesView TO &lt;6s&gt;;USE  &lt;1s&gt;;&lt;4s&gt;;CREATE VIEW &lt;5s&gt;.TW_PkgNameSpacesAndSourcesView as	SELECT t1.primaryKey, t1.name, t1.timeStamp, t1.userName, t1.trace, t1.definitionID, t1.commentID, 		t1.environmentString, t2.packageRef, t2.definitionOrder, t3.blobData, t3.blobType	FROM &lt;5s&gt;.TW_NameSpaceRecord t1	JOIN &lt;5s&gt;.TW_PkgNameSpaces t2 ON ((t1.primaryKey = t2.nameSpaceRef))  	JOIN &lt;3s&gt;.&lt;5s&gt;.TW_Blob t3 ON ((t1.definitionID = t3.primaryKey)) ;&lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_PkgNameSpacesAndSourcesView TO &lt;6s&gt;'	expandMacrosWithArguments: arguments.</body><body package="Store-Database Model">dropStoreSpecificViewsSQL	^'USE  &lt;1s&gt;;DROP VIEW BERN.TW_PkgNameSpacesAndSourcesView;USE  &lt;1s&gt;;DROP VIEW BERN.TW_PkgClassesAndSourcesView;USE  &lt;1s&gt;;DROP VIEW BERN.TW_DataAndSourcesView;USE  &lt;2s&gt;;DROP VIEW BERN.TW_MethodsAndSourcesView;USE  &lt;1s&gt;;DROP VIEW BERN.TW_PropertiesView;USE  &lt;1s&gt;;DROP VIEW BERN.TW_DataView;USE  &lt;1s&gt;;DROP VIEW BERN.TW_PkgNameSpacesView;USE  &lt;1s&gt;;DROP VIEW BERN.TW_PkgMetaclassesView;USE  &lt;1s&gt;;DROP VIEW BERN.TW_PkgClassesView;USE  &lt;2s&gt;;DROP VIEW BERN.TW_MethodsView'	expandMacrosWith: Store.Policies tableSpacePolicy defaultTableSpace	with: Store.Policies tableSpacePolicy methodsTableSpace</body><body package="Store-Database Model">endBatchForScriptIn: aDatabaseAccessor	aDatabaseAccessor logOnly		ifTrue: 			[aDatabaseAccessor executeSQLStringNoResult: self sqlStatementForEndOfBatch]</body><body package="Store-Database Model">grantStoreSpecificPermissionsSQLOnSchema: schemaName toRole: roleName	| tablespacePolicy arguments |	tablespacePolicy := Store.Policies tableSpacePolicy.	arguments := (OrderedCollection new)		add: tablespacePolicy defaultTableSpace;		add: tablespacePolicy methodsTableSpace;		add: tablespacePolicy blobTableSpace;		add: tablespacePolicy userAndOwnershipTableSpace;		add:schemaName;		add: roleName;		yourself.	^'USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_ClassRecord TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_NameSpaceRecord TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Package TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT UPDATE ON &lt;5s&gt;.TW_Package ( version, blessingLevel )  TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_ParcelRecord TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT UPDATE ON &lt;5s&gt;.TW_ParcelRecord ( version )  TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_PkgClasses TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_PkgNameSpaces TO &lt;6s&gt;;USE  &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Method TO &lt;6s&gt;;USE  &lt;2s&gt;;GRANT UPDATE ON &lt;5s&gt;.TW_Method ( version )  TO &lt;6s&gt;;USE  &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Methods TO &lt;6s&gt;;USE  &lt;2s&gt;;GRANT UPDATE, DELETE ON &lt;5s&gt;.TW_Methods TO &lt;6s&gt;;USE  &lt;3s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Blob TO &lt;6s&gt;;USE  &lt;3s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_BinaryBlob TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Blessing TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT UPDATE ON &lt;5s&gt;.TW_Blessing ( blessingLevel )  TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Bundle TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT UPDATE ON &lt;5s&gt;.TW_Bundle ( version, blessingLevel )  TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Bundles TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Packages TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_DataElement TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Data TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT UPDATE, DELETE ON &lt;5s&gt;.TW_Data TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT SELECT, UPDATE ON &lt;5s&gt;.TW_DatabaseIdentifier TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Files TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_FileRecord TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT UPDATE ON &lt;5s&gt;.TW_FileRecord ( version )  TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_Properties TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT INSERT, SELECT ON &lt;5s&gt;.TW_PropertyRecord TO &lt;6s&gt;;USE  &lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_DBUserGroup TO &lt;6s&gt;;USE  &lt;4s&gt;;GRANT SELECT ON &lt;5s&gt;.TW_DBPundlePrivileges TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT SELECT, INSERT ON &lt;5s&gt;.TW_LoadRecord TO &lt;6s&gt;;USE  &lt;1s&gt;;GRANT SELECT, INSERT ON &lt;5s&gt;.TW_MethodDocs TO &lt;6s&gt;'	expandMacrosWithArguments: arguments</body><body package="Store-Database Model">grantStoreTableOwnerAccessToDB: databaseName usingAccessor: aDatabaseAccessor	| tableOwner |	tableOwner := aDatabaseAccessor currentLogin schema.	(tableOwner equivalentTo: 'dbo' ignoreCase: true) ifTrue: [^self].	self setCurrentDatabase: databaseName inAccessor: aDatabaseAccessor.	aDatabaseAccessor		executeSQLStringNoResult: (self sqlStatementToGrantDBAccessTo: tableOwner).	aDatabaseAccessor executeSQLStringNoResult: (self				sqlStatementToGrantStoreTableOwnerPermissionsTo: tableOwner).	self endBatchForScriptIn: aDatabaseAccessor</body><body package="Store-Database Model">grantStoreTableOwnerPrivilegesOnDB: databaseName usingAccessor: aDatabaseAccessor	| tableOwner |	tableOwner := aDatabaseAccessor currentLogin schema.	(tableOwner equivalentTo: 'dbo' ignoreCase: true) ifTrue: [^self].	self setCurrentDatabase: databaseName inAccessor: aDatabaseAccessor.	aDatabaseAccessor executeSQLStringNoResult: (self				sqlStatementToGrantStoreTableOwnerPermissionsTo: tableOwner).	self endBatchForScriptIn: aDatabaseAccessor</body><body package="Store-Database Model">grantStoreTableSpaceAccessTo: tableOwnerRolename database: databaseName usingAccessor: aDatabaseAccessor	(tableOwnerRolename equivalentTo: 'dbo' ignoreCase: true) ifTrue: [^self].	self setCurrentDatabase: databaseName inAccessor: aDatabaseAccessor.	aDatabaseAccessor		executeSQLStringNoResult: (self sqlStatementToGrantDBAccessTo: tableOwnerRolename).	self endBatchForScriptIn: aDatabaseAccessor.</body><body package="Store-Database Model">installPhysicalSpacesIn: aDatabaseAccessor	| path baseFilename spaceForBlobs defaultTableSpace accountCreated names name methodsTableSpace userTableSpace schemaOwner |	(Dialog confirm: #CreateTablespacesQ &lt;&lt; #store				&gt;&gt; 'Create tablespaces? (Answer no only if they have already been created)')		ifFalse: [^self].	path := Dialog request: #PleaseEnterTableSpaceDirectory &lt;&lt; #store						&gt;&gt; 'Please, enter directory for the table spaces.'				initialAnswer: ''.	path isEmpty ifTrue: [Error raiseSignal: self installationCanceledMessage].	baseFilename := (path includes: Filename getSeparator)				ifTrue: [path asFilename]				ifFalse: 					[(path includes: UnixFilename getSeparator)						ifTrue: [UnixFilename named: path]						ifFalse: [PCFilename named: path]].	names := Set new.	name := baseFilename				constructString: (spaceForBlobs := Store.Policies tableSpacePolicy								blobTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; spaceForBlobs.	name := baseFilename				constructString: (defaultTableSpace := Store.Policies tableSpacePolicy								defaultTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; defaultTableSpace.	name := baseFilename				constructString: (methodsTableSpace := Store.Policies tableSpacePolicy								methodsTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; methodsTableSpace.	name := baseFilename				constructString: (userTableSpace := Store.Policies tableSpacePolicy								userAndOwnershipTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; userTableSpace.	^	[accountCreated := self isNewAccountCreatedIn: aDatabaseAccessor.	names do: 			[:each |			| size |			size := each value = spaceForBlobs						ifTrue: [self spaceForBlobs]						ifFalse: [self spaceForClasses].			self				createDatabase: each value				onDevice: each key				size: size				in: aDatabaseAccessor.			self endBatchForScriptIn: aDatabaseAccessor.			accountCreated				ifTrue: 					[self grantStoreTableOwnerAccessToDB: each value usingAccessor: aDatabaseAccessor].			schemaOwner := accountCreated						ifTrue: [aDatabaseAccessor schema]						ifFalse: ['dbo'].			self				createSchemaIn: each value				named: aDatabaseAccessor schema				ownedBy: schemaOwner				accessor: aDatabaseAccessor].	true]			on: Error			do: 				[:ex |				ex messageText = self installationCanceledMessage					ifTrue: [ex pass]					ifFalse: [nil]]</body><body package="Store-Database Model">isLoginExist: aName in: aDatabaseAccessor	aDatabaseAccessor executeSQLStringNoResult: 'USE master'.	^ [[aDatabaseAccessor executeSQLStringNoResult: ( 'EXEC sp_addlogin '  ,  aName, ', ', aName  ) asString]		on: Error		do: [:ex || dbmsError |			dbmsError := ex parameter first.			(dbmsError dbmsErrorCode == 15025 or: [dbmsError sqlState = '37000'])				ifTrue: [ex return: true]				ifFalse: [ex pass]].		false] 	on: Error	do: 		[ :exception | 		Transcript show:  exception  message; cr.		exception return: false].</body><body package="Store-Database Model">isNewAccountCreatedIn: aDatabaseAccessor		| tableOwner |	tableOwner := aDatabaseAccessor currentLogin schema.	(tableOwner equivalentTo: 'dbo' ignoreCase: true) ifTrue: [^false].	^(aDatabaseAccessor logOnly not and: [self isLoginExist: tableOwner in: aDatabaseAccessor]) 		or: [self createNewAccountIn: aDatabaseAccessor]</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>testing - errors</category><body package="Store-Database Model">isRoleAlreadyExistsError: dbmsError	^dbmsError sqlState = '37000' and: [dbmsError dbmsErrorCode = 15025]</body><body package="Store-Database Model">isUserAlreadyExistsError: dbmsError	^dbmsError sqlState = '37000' and: [dbmsError dbmsErrorCode = 15025]</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">setCurrentDatabase: databaseName inAccessor: aDatabaseAccessor	aDatabaseAccessor executeInDDLOperation: 			[aDatabaseAccessor executeSQLStringNoResult: 'USE ' , databaseName]		ifError: [:ex | self halt].	self endBatchForScriptIn: aDatabaseAccessor</body><body package="Store-Database Model">setSchemaForTablesNamed: tableNames tablespaceName: tablespaceName descriptorSystem: descriptorSystem	"The need for this may be dropped from 8.2 or later StoreDescriptorSystem subclasses."	|  matchString |		matchString := tablespaceName, '.*'.	tableNames do: [:eachTableName | | table | 		table := descriptorSystem tableNamed: eachTableName.		(table schema isNil or: [table schema isEmpty])			ifTrue: [table schema: tablespaceName]			ifFalse: [				(matchString match: table schema)					ifFalse: [table schema: tablespaceName,'.',table schema]]].</body><body package="Store-Database Model">spaceForBlobs"MB"	^'32'</body><body package="Store-Database Model">spaceForClasses"MB"	^'32'</body><body package="Store-Database Model">spaceForDefault"MB"	^'48'</body><body package="Store-Database Model">sqlStatementForEndOfBatch	^'GO --'</body><body package="Store-Database Model">sqlStatementToCreateDatabaseRole: roleName authorizedBy: userName	| writeStream |	writeStream := WriteStream on: String new.	writeStream		nextPutAll: 'CREATE ROLE ';		nextPutAll: roleName;		nextPutAll: ' AUTHORIZATION ';		nextPutAll: userName.	^writeStream contents</body><body package="Store-Database Model">sqlStatementToCreateSchema: schemaName ownedBy: tableOwner	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE SCHEMA ';		nextPutAll: schemaName;		nextPutAll: ' AUTHORIZATION ';		nextPutAll: tableOwner.	^writeStream contents</body><body package="Store-Database Model">sqlStatementToCreateServerUser: tableOwner password: tableOwnerPassword	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE LOGIN ';		nextPutAll: tableOwner;		nextPutAll: ' WITH PASSWORD = ';		nextPut: $';		nextPutAll: tableOwnerPassword;		nextPut: $'.	^writeStream contents</body><body package="Store-Database Model">sqlStatementToCreateUser: userName ForLogin: loginName	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE USER ';		nextPutAll: userName;		nextPutAll: ' FOR LOGIN ';		nextPutAll: loginName.	^writeStream contents</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services - users and roles</category><body package="Store-Database Model">sqlStatementToCreateUser: loginName password: loginPassword	| writeStream |	writeStream := WriteStream on: String new.	writeStream 		nextPutAll: 'CREATE LOGIN ';		nextPutAll: loginName;		nextPutAll: ' WITH PASSWORD = ';		nextPut: $';		nextPutAll: loginPassword;		nextPut: $'.	^writeStream contents</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">sqlStatementToGrantDBAccessTo: tableOwner	^self sqlStatementToCreateUser: tableOwner ForLogin: tableOwner</body><body package="Store-Database Model">sqlStatementToGrantStoreTableOwnerPermissionsTo: tableOwner	^'GRANT CREATE TABLE, CREATE VIEW, CREATE DEFAULT,  CREATE PROCEDURE TO '		, tableOwner</body><body package="Store-Database Model">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^UnableToExecuteSQL</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>testing</category><body package="Store-Database Model">supportsPhysicalSpaces	^true</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">tableSpaceFileSuffix	^'.mdf'</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">configureSystemForStore: aStoreDescriptorSystem	"Drop SQLServerPlatform superclass behaviour."</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>testing</category><body package="Store-Database Model">supportsPhysicalSpaces	^false</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="Store-Database Model">asStoreClassDefinition	"Convert this to a StoreForGlorp class definition, ignoring the metaclass"	^Store.Glorp.StoreClassDefinition newFrom: self</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>converting</category><body package="Store-Database Model">asStoreClassDefinition	^Store.Glorp.StoreClassDefinition newFrom: self</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="Store-Database Model">hasRelatedParcel	^self storeForGlorpPundleClass hasRelatedParcelFor: self</body><body package="Store-Database Model">hasRelatedParcelIn: aSession	^self storeForGlorpPundleClass hasRelatedParcelFor: self in: aSession</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>dates</category><body package="Store-Database Model">storeTimestamp	"Return a timestamp appropriate to use for publishing Store entities. Be exceedingly careful about errors due to databases that don't support this, 	or old code in various interesting combinations.	Note, if you are not connected, or can not connect, it gives you a local UTC timestamp.	Dialect storeTimestamp	Whenever possible, use the #storeTimestampIn: method, passing along a GlorpSession object"	^self storeTimestampIn: nil</body><body package="Store-Database Model">storeTimestampIn: aSession	"Return a timestamp appropriate to use for publishing Store entities. Be exceedingly careful about errors due to databases that don't support this.	In order to avoid excessive trips to the database, if we ask this more than once within a second, just return the previous result.	Note, if you are not connected, or can not connect, it gives you a local UTC timestamp.	Dialect storeTimestampIn: Store.Glorp.StoreLoginFactory currentStoreSession"	| possibleTimestamp session systemTime |	session := aSession ifNil: [Store.DbRegistry isOnlineImage ifTrue: [Store.Glorp.StoreLoginFactory currentStoreSession]].	systemTime := self timestampNowUTC asSeconds.	lastSystemTime = systemTime 		ifTrue: [^lastServerTime] ifFalse: [lastSystemTime := systemTime].	possibleTimestamp := session ifNotNil: [:value | value currentServerUTCTimestampOrNil].	^lastServerTime := (possibleTimestamp isKindOf: Timestamp)		ifTrue: [possibleTimestamp]		ifFalse: [self timestampNowUTC].</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>store constants</category><body package="Store-Database Model">volatilePropertyKeys	"Duplicated out of Store so that we don't need to worry about other dialects."	^#(sourceIndex recompile blessingLevel printStringCache dbTrace updating dbIdentifier databaseId loading packageUndeclared packageEnvironment timestamp parcel parcelDirectory)</body></methods><methods><class-id>Core.Class</class-id> <category>store for glorp</category><body package="Store-Database Model">asStoreClassDefinition	^Store.Glorp.StoreClassDefinition newFrom: self</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>accessing</category><body package="Store-Database Model">databaseIdentifier	"Round trip minimizing version"	^(self accessor == Store.DbRegistry currentDatabaseAccessor and: [Store.DbRegistry databaseIdentifier notNil])		ifTrue: [Store.DbRegistry databaseIdentifier asSymbol]		ifFalse: [self system databaseIdentifier]</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>types</category><body package="Store-Database Model">binary32k	"Use an inline type for performance."	^self longRaw</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">createDatabase: aDatabaseName onDevice: aDeviceName size: aString in: aDatabaseAccessor	| sqlString |	sqlString := self createDatabaseStringFor: aDatabaseName on: aDeviceName size: aString.	aDatabaseAccessor		executeInDDLOperation: 			[aDatabaseAccessor executeSQLStringNoResult: sqlString]		ifError: [:ex | self halt]</body><body package="Store-Database Model">createDatabaseStringFor: aTablespaceName on: aFileNameString size: aString		^'CREATE TABLESPACE ' , aTablespaceName , ' DATAFILE ''' , aFileNameString , '''  SIZE ' , aString ,	'  REUSE DEFAULT STORAGE (INITIAL 1M NEXT 512K PCTINCREASE 1)'</body><body package="Store-Database Model">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor role: roleName	| schema |	schema := aDatabaseAccessor schema.	^'CREATE VIEW &lt;1s&gt;.TW_MethodsView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.version, t2.userName, t2.trace, t2.className, t1.packageRef, 		t2.sourceCodeID, t2.protocolName	FROM &lt;1s&gt;.TW_Methods t1, &lt;1s&gt;.TW_Method t2	WHERE t1.methodRef = t2.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_MethodsView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgClassesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.superclass, t2.definitionID, t2.environmentString, 		t2.commentID, t1.packageRef, t1.definitionOrder	FROM &lt;1s&gt;.TW_PkgClasses t1, &lt;1s&gt;.TW_ClassRecord t2	WHERE t1.classRef = t2.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PkgClassesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgMetaclassesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.superclass, t2.definitionID, t2.environmentString, 		t2.commentID, t1.packageRef, t1.definitionOrder	FROM &lt;1s&gt;.TW_PkgClasses t1, &lt;1s&gt;.TW_ClassRecord t2	WHERE t1.metaclassRef = t2.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PkgMetaclassesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgNameSpacesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.definitionID, t2.commentID, t2.environmentString, 		t1.packageRef, t1.definitionOrder	FROM &lt;1s&gt;.TW_PkgNameSpaces t1, &lt;1s&gt;.TW_NameSpaceRecord t2	WHERE t1.nameSpaceRef = t2.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PkgNameSpacesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_DataView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t1.packageRef, t2.definitionID, t2.commentID, 		t2.environmentString, t2.protocolName, t2.typeString	FROM &lt;1s&gt;.TW_Data t1, &lt;1s&gt;.TW_DataElement t2	WHERE t1.dataRef = t2.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_DataView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PropertiesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.userName, t2.trace, t2.definitionID, t2.commentID, 		t2.environmentString, t2.searchString, t1.pundleRef, t1.recType	FROM &lt;1s&gt;.TW_Properties t1, &lt;1s&gt;.TW_PropertyRecord t2	WHERE t1.propertyRef = t2.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PropertiesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_MethodsAndSourcesView as	SELECT t2.primaryKey, t2.name, t2.timeStamp, t2.version, t2.userName, t2.trace, t2.className, 		t1.packageRef, t2.sourceCodeID, t2.protocolName, t3.blobData, t3.blobType	FROM &lt;1s&gt;.TW_Method t2, &lt;1s&gt;.TW_Methods t1, &lt;1s&gt;.TW_Blob t3	WHERE (t2.primaryKey = t1.methodRef) 		AND (t2.sourceCodeID = t3.primaryKey);GRANT SELECT ON &lt;1s&gt;.TW_MethodsAndSourcesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_DataAndSourcesView as	SELECT t1.primaryKey, t1.name, t1.timeStamp, t1.userName, t1.trace, t2.packageRef, t1.definitionID, 		t1.commentID, t1.environmentString, t1.protocolName, t1.typeString, t3.blobData, t3.blobType	FROM &lt;1s&gt;.TW_DataElement t1, &lt;1s&gt;.TW_Data t2, &lt;1s&gt;.TW_Blob t3	WHERE (t1.primaryKey = t2.dataRef) AND (t1.definitionID = t3.primaryKey);GRANT SELECT ON &lt;1s&gt;.TW_DataAndSourcesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgClassesAndSourcesView as	SELECT t1.primaryKey, t1.name, t1.timeStamp, t1.userName, t1.trace, t1.superclass, t1.definitionID, 		t1.environmentString, t1.commentID, t2.packageRef, t2.definitionOrder, t3.blobData, t3.blobType	FROM &lt;1s&gt;.TW_ClassRecord t1, &lt;1s&gt;.TW_PkgClasses t2, &lt;1s&gt;.TW_Blob t3	WHERE (t1.primaryKey = t2.classRef) AND (t1.definitionID = t3.primaryKey);GRANT SELECT ON &lt;1s&gt;.TW_PkgClassesAndSourcesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgNameSpacesAndSourcesView as	SELECT t1.primaryKey, t1.name, t1.timeStamp, t1.userName, t1.trace, t1.definitionID, t1.commentID, 		t1.environmentString, t2.packageRef, t2.definitionOrder, t3.blobData, t3.blobType	FROM &lt;1s&gt;.TW_NameSpaceRecord t1, &lt;1s&gt;.TW_PkgNameSpaces t2, &lt;1s&gt;.TW_Blob t3	WHERE (t1.primaryKey = t2.nameSpaceRef) AND (t1.definitionID = t3.primaryKey);GRANT SELECT ON &lt;1s&gt;.TW_PkgNameSpacesAndSourcesView TO &lt;2s&gt;'	expandMacrosWith: schema with: roleName</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>services tables</category><body package="Store-Database Model">createTableIndexStatementStringFor: aGLORPDatabaseTable index: aGlorpDatabaseIndex	| sqlString writeStream |	sqlString := super createTableIndexStatementStringFor: aGLORPDatabaseTable index: aGlorpDatabaseIndex.	writeStream := WriteStream with: sqlString.	(aGLORPDatabaseTable respondsTo: #propertyAt:) ifTrue:		[(aGLORPDatabaseTable propertyAt: #tableSpaceName) ifNotNil:			[:value |			writeStream nextPutAll: ' TABLESPACE ' , value]].	^writeStream contents</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">createTableStatementStringFor: aGLORPDatabaseTable	| sqlString stream |	sqlString := super createTableStatementStringFor: aGLORPDatabaseTable.	stream := WriteStream with: sqlString.	(aGLORPDatabaseTable respondsTo: #propertyAt:) ifTrue:		[(aGLORPDatabaseTable propertyAt: #tableSpaceName) ifNotNil:			[:value |			stream nextPutAll: ' TABLESPACE ' , value]].	^stream contents</body><body package="Store-Database Model">dropStoreSpecificViewsSQL	^'DROP VIEW BERN.TW_PkgNameSpacesAndSourcesView;DROP VIEW BERN.TW_PkgClassesAndSourcesView;DROP VIEW BERN.TW_DataAndSourcesView;DROP VIEW BERN.TW_MethodsAndSourcesView;DROP VIEW BERN.TW_PropertiesView;DROP VIEW BERN.TW_DataView;DROP VIEW BERN.TW_PkgNameSpacesView;DROP VIEW BERN.TW_PkgMetaclassesView;DROP VIEW BERN.TW_PkgClassesView;DROP VIEW BERN.TW_MethodsView'</body><body package="Store-Database Model">grantStoreSpecificPermissionsSQLOnSchema: schemaName toRole: roleName	^'GRANT INSERT, SELECT ON &lt;1s&gt;.TW_ClassRecord TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_ClassRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_NameSpaceRecord TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_NameSpaceRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Package TO &lt;2s&gt;;GRANT UPDATE ( version, blessingLevel )  ON &lt;1s&gt;.TW_Package TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_PackageSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_ParcelRecord TO &lt;2s&gt;;GRANT UPDATE ( version )  ON &lt;1s&gt;.TW_ParcelRecord TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_ParcelRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_PkgClasses TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_PkgNameSpaces TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Method TO &lt;2s&gt;;GRANT UPDATE ( version )  ON &lt;1s&gt;.TW_Method TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_MethodSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Methods TO &lt;2s&gt;;GRANT UPDATE, DELETE ON &lt;1s&gt;.TW_Methods TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Blob TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_BlobSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_BinaryBlob TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_BinaryBlobSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Blessing TO &lt;2s&gt;;GRANT UPDATE ( blessingLevel )  ON &lt;1s&gt;.TW_Blessing TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_BlessingSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Bundle TO &lt;2s&gt;;GRANT UPDATE ( version, blessingLevel )  ON &lt;1s&gt;.TW_Bundle TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_BundleSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Bundles TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Packages TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_DataElement TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_DataElementSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Data TO &lt;2s&gt;;GRANT UPDATE, DELETE ON &lt;1s&gt;.TW_Data TO &lt;2s&gt;;GRANT SELECT, UPDATE ON &lt;1s&gt;.TW_DatabaseIdentifier TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Files TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_FileRecord TO &lt;2s&gt;;GRANT UPDATE ( version )  ON &lt;1s&gt;.TW_FileRecord TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_FileRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Properties TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_PropertyRecord TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_PropertyRecordSeq TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_DBUserGroup TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_DBPundlePrivileges TO &lt;2s&gt;;GRANT SELECT, INSERT ON &lt;1s&gt;.TW_LoadRecord TO &lt;2s&gt;;GRANT SELECT, INSERT ON &lt;1s&gt;.TW_MethodDocs TO &lt;2s&gt;'	expandMacrosWith: schemaName with: roleName.</body><body package="Store-Database Model">installPhysicalSpacesIn: aDatabaseAccessor	| path baseFilename spaceForBlobs defaultTableSpace names name methodsTableSpace userTableSpace |	(Dialog confirm: #CreateTablespacesQ &lt;&lt; #store				&gt;&gt; 'Create tablespaces? (Answer no only if they have already been created)')		ifFalse: [^self].	path := Dialog request: #PleaseEnterTableSpaceDirectory &lt;&lt; #store						&gt;&gt; 'Please, enter directory for the table spaces.'				initialAnswer: ''.	path isEmpty ifTrue: [Error raiseSignal: self installationCanceledMessage].	baseFilename := (path includes: Filename getSeparator)				ifTrue: [path asFilename]				ifFalse: 					[(path includes: UnixFilename getSeparator)						ifTrue: [UnixFilename named: path]						ifFalse: [PCFilename named: path]].	names := Set new.	name := baseFilename				constructString: (spaceForBlobs := Store.Policies tableSpacePolicy								blobTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; spaceForBlobs.	name := baseFilename				constructString: (defaultTableSpace := Store.Policies tableSpacePolicy								defaultTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; defaultTableSpace.	name := baseFilename				constructString: (methodsTableSpace := Store.Policies tableSpacePolicy								methodsTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; methodsTableSpace.	name := baseFilename				constructString: (userTableSpace := Store.Policies tableSpacePolicy								userAndOwnershipTableSpace) , self tableSpaceFileSuffix.	names add: name -&gt; userTableSpace.	names do: 			[:each |			| size |			size := each value = spaceForBlobs						ifTrue: [self spaceForBlobs]						ifFalse: [self spaceForClasses].			self				createDatabase: each value				onDevice: each key				size: size				in: aDatabaseAccessor.			self setAutoExtentFor: each key in: aDatabaseAccessor]</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>testing - errors</category><body package="Store-Database Model">isRoleAlreadyExistsError: dbmsError	^dbmsError dbmsErrorCode = 1921</body><body package="Store-Database Model">isUserAlreadyExistsError: dbmsError	^dbmsError dbmsErrorCode = 1920</body><body package="Store-Database Model">isUserDoesNotExistError: dbmsError	^dbmsError dbmsErrorCode = 1918</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">setAutoExtentFor: fileName1 in: aDatabaseAccessor		aDatabaseAccessor		executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: 'ALTER DATABASE DATAFILE ''' , fileName1 , ''' AUTOEXTEND ON']		ifError: [:exception | self halt]</body><body package="Store-Database Model">spaceForBlobs	^ '32M'</body><body package="Store-Database Model">spaceForClasses	^ '32M'</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>services - users and roles</category><body package="Store-Database Model">sqlStatementToCreateRole: roleName	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE ROLE ';		nextPutAll: roleName.	^writeStream contents</body><body package="Store-Database Model">sqlStatementToCreateUser: loginName password: loginPassword	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE USER ';		nextPutAll: loginName;		nextPutAll: ' IDENTIFIED BY ';		nextPutAll: loginPassword.	^writeStream contents</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">storeSchemaNotFoundError	^InvalidTableName</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>testing</category><body package="Store-Database Model">supportsPhysicalSpaces	^true</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">tableSpaceFileSuffix	^'.dbf'</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>database-specific</category><body package="Store-Database Model">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor role: roleName	"DatabaseAccessor not really needed for this platform because it uses an 	implicit schema and doesn't need changes for script vs direct execution."	^'CREATE VIEW TW_MethodsView AS	SELECT TW_Method.primaryKey as primaryKey,  TW_Method.name as name,  TW_Method.timeStamp as timeStamp,  TW_Method.version as version,  TW_Method.userName as userName,  TW_Method.trace as trace,  TW_Method.className as className,  TW_Methods.packageRef as packageRef,  TW_Method.sourceCodeID as sourceCodeID,  TW_Method.protocolName as protocolName	FROM TW_Methods,  TW_Method	WHERE TW_Methods.methodRef = TW_Method.primaryKey;CREATE VIEW TW_PkgClassesView AS	SELECT TW_ClassRecord.primaryKey as primaryKey,  TW_ClassRecord.name as name,  TW_ClassRecord.timeStamp as timeStamp,  TW_ClassRecord.userName as userName,  TW_ClassRecord.trace as trace,  TW_ClassRecord.superclass as superclass,  TW_ClassRecord.definitionID as definitionID,  TW_ClassRecord.environmentString as environmentString,  TW_ClassRecord.commentID as commentID,  TW_PkgClasses.packageRef as packageRef,  TW_PkgClasses.definitionOrder as definitionOrder	FROM TW_PkgClasses,  TW_ClassRecord	WHERE TW_PkgClasses.classRef = TW_ClassRecord.primaryKey;CREATE VIEW TW_PkgMetaclassesView AS	SELECT TW_ClassRecord.primaryKey as primaryKey,  TW_ClassRecord.name as name,  TW_ClassRecord.timeStamp as timeStamp,  TW_ClassRecord.userName as userName,  TW_ClassRecord.trace as trace,  TW_ClassRecord.superclass as superclass,  TW_ClassRecord.definitionID as definitionID,  TW_ClassRecord.environmentString as environmentString,  TW_ClassRecord.commentID as commentID,  TW_PkgClasses.packageRef as packageRef,  TW_PkgClasses.definitionOrder as definitionOrder	FROM TW_PkgClasses,  TW_ClassRecord	WHERE TW_PkgClasses.metaclassRef = TW_ClassRecord.primaryKey;CREATE VIEW TW_PkgNameSpacesView AS	SELECT TW_NameSpaceRecord.primaryKey as primaryKey,  TW_NameSpaceRecord.name as name,  TW_NameSpaceRecord.timeStamp as timeStamp,  TW_NameSpaceRecord.userName as userName,  TW_NameSpaceRecord.trace as trace,  TW_NameSpaceRecord.definitionID as definitionID,  TW_NameSpaceRecord.commentID as commentID,  TW_NameSpaceRecord.environmentString as environmentString,  TW_PkgNameSpaces.packageRef as packageRef,  TW_PkgNameSpaces.definitionOrder as definitionOrder	FROM TW_PkgNameSpaces,  TW_NameSpaceRecord	WHERE TW_PkgNameSpaces.nameSpaceRef = TW_NameSpaceRecord.primaryKey;CREATE VIEW TW_DataView AS	SELECT TW_DataElement.primaryKey as primaryKey,  TW_DataElement.name as name,  TW_DataElement.timeStamp as timeStamp,  TW_DataElement.userName as userName,  TW_DataElement.trace as trace,  TW_Data.packageRef as packageRef,  TW_DataElement.definitionID as definitionID,  TW_DataElement.commentID as commentID,  TW_DataElement.environmentString as environmentString,  TW_DataElement.protocolName as protocolName,  TW_DataElement.typeString as typeString	FROM TW_Data,  TW_DataElement	WHERE TW_Data.dataRef = TW_DataElement.primaryKey;CREATE VIEW TW_PropertiesView AS	SELECT TW_PropertyRecord.primaryKey as primaryKey,  TW_PropertyRecord.name as name,  TW_PropertyRecord.timeStamp as timeStamp,  TW_PropertyRecord.userName as userName,  TW_PropertyRecord.trace as trace,  TW_PropertyRecord.definitionID as definitionID,  TW_PropertyRecord.commentID as commentID,  TW_PropertyRecord.environmentString as environmentString,  TW_PropertyRecord.searchString as searchString,  TW_Properties.pundleRef as pundleRef,  TW_Properties.recType as recType	FROM TW_Properties,  TW_PropertyRecord	WHERE TW_Properties.propertyRef = TW_PropertyRecord.primaryKey;CREATE VIEW TW_MethodsAndSourcesView AS	SELECT TW_Method.primaryKey as primaryKey, TW_Method.name as name, TW_Method.timeStamp as timeStamp, TW_Method.version as version, TW_Method.userName as userName, TW_Method.trace as trace, TW_Method.className as className, TW_Methods.packageRef as packageRef, TW_Method.sourceCodeID as sourceCodeID, TW_Method.protocolName as protocolName, TW_Blob.blobData as blobData, TW_Blob.blobType as blobType	FROM TW_Methods, TW_Method, TW_Blob	WHERE TW_Methods.methodRef = TW_Method.primaryKey 	AND TW_Method.sourceCodeID = TW_Blob.primaryKey;CREATE VIEW TW_DataAndSourcesView AS	SELECT TW_DataElement.primaryKey as primaryKey, TW_DataElement.name as name, TW_DataElement.timeStamp as timeStamp, TW_DataElement.userName as userName, TW_DataElement.trace as trace, TW_Data.packageRef as packageRef, TW_DataElement.definitionID as definitionID, TW_DataElement.commentID as commentID, TW_DataElement.environmentString as environmentString, TW_DataElement.protocolName as protocolName, TW_DataElement.typeString as typeString, TW_Blob.blobData as blobData, TW_Blob.blobType as blobType	FROM TW_Data, TW_DataElement, TW_Blob	WHERE TW_Data.dataRef = TW_DataElement.primaryKey 	AND TW_DataElement.definitionID = TW_Blob.primaryKey;CREATE VIEW TW_PkgClassesAndSourcesView AS	SELECT TW_ClassRecord.primaryKey as primaryKey, TW_ClassRecord.name as name, TW_ClassRecord.timeStamp as timeStamp, TW_ClassRecord.userName as userName, TW_ClassRecord.trace as trace, TW_ClassRecord.superclass as superclass, TW_ClassRecord.definitionID as definitionID, TW_ClassRecord.environmentString as environmentString, TW_ClassRecord.commentID as commentID, TW_PkgClasses.packageRef as packageRef, TW_PkgClasses.definitionOrder as definitionOrder, TW_Blob.blobData as blobData, TW_Blob.blobType as blobType	FROM TW_PkgClasses, TW_ClassRecord, TW_Blob	WHERE TW_PkgClasses.classRef = TW_ClassRecord.primaryKey 	AND TW_ClassRecord.definitionID = TW_Blob.primaryKey;CREATE VIEW TW_PkgNameSpacesAndSourcesView AS	SELECT TW_NameSpaceRecord.primaryKey as primaryKey, TW_NameSpaceRecord.name as name, TW_NameSpaceRecord.timeStamp as timeStamp, TW_NameSpaceRecord.userName as userName, TW_NameSpaceRecord.trace as trace, TW_NameSpaceRecord.definitionID as definitionID, TW_NameSpaceRecord.commentID as commentID, TW_NameSpaceRecord.environmentString as environmentString, TW_PkgNameSpaces.packageRef as packageRef, TW_PkgNameSpaces.definitionOrder as definitionOrder, TW_Blob.blobData as blobData, TW_Blob.blobType as blobType	FROM TW_PkgNameSpaces, TW_NameSpaceRecord, TW_Blob	WHERE TW_PkgNameSpaces.nameSpaceRef = TW_NameSpaceRecord.primaryKey 	AND TW_NameSpaceRecord.definitionID = TW_Blob.primaryKey'</body><body package="Store-Database Model">dropStoreSpecificViewsSQL	"The create code for SQLite3 already drops the views before recreation so thevalue of this method is debatable;  included for completeness."	^'SELECT 	* FROM TW_MethodsView WHERE 1 = 2;DROP VIEW TW_MethodsView;SELECT 	* FROM TW_PkgClassesView WHERE 1 = 2;DROP VIEW TW_PkgClassesView;SELECT 	* FROM TW_PkgMetaclassesView WHERE 1 = 2;DROP VIEW TW_PkgMetaclassesView;SELECT 	* FROM TW_PkgNameSpacesView WHERE 1 = 2;DROP VIEW TW_PkgNameSpacesView;SELECT 	* FROM TW_DataView WHERE 1 = 2;DROP VIEW TW_DataView;SELECT 	* FROM TW_PropertiesView WHERE 1 = 2;DROP VIEW TW_PropertiesView;SELECT 	* FROM TW_MethodsAndSourcesView WHERE 1 = 2;DROP VIEW TW_MethodsAndSourcesView;SELECT 	* FROM TW_DataAndSourcesView WHERE 1 = 2;DROP VIEW TW_DataAndSourcesView;SELECT 	* FROM TW_PkgClassesAndSourcesView WHERE 1 = 2;DROP VIEW TW_PkgClassesAndSourcesView;SELECT 	* FROM TW_PkgNameSpacesAndSourcesView WHERE 1 = 2;DROP VIEW TW_PkgNameSpacesAndSourcesView'</body><body package="Store-Database Model">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^UnableToPrepare</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>testing</category><body package="Store-Database Model">supportsUsers	^false</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-Database Model">updateTraceInformation	^self updateTraceInformationIn: nil</body><body package="Store-Database Model">updateTraceInformationIn: aSession	| key result |	key := self dbTrace.	(key notNil and: [DbRegistry isOnlineImage]) ifTrue:			[| session |			session := aSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].			result := pundle storeForGlorpPundleClass getTraceDataFor: key in: session.			(result notNil and: [result notEmpty]) ifTrue:				[self dbTimestamp: (result at: #timestamp);					dbVersion: (result at: #version);					dbUsername: (result at: #username).				^true]].	^false</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>executing</category><body package="Store-Database Model">createRole: roleName	| result |	result := self executeInDDLOperation: 					[self						executeSQLStringsNoResult: (self platform sqlStatementToCreateRole: roleName).					true]				ifError: 					[:ex |					| dbmsError |					dbmsError := ex parameter first.					(self platform isRoleAlreadyExistsError: dbmsError)						ifTrue: 							["User already exists"							ex return: false]						ifFalse: [ex pass]].	^result</body><body package="Store-Database Model">createStoreSpecificViewsAndGrantViewPermissionsToUserOrRole: userOrRoleString	^self executeSQLStringsNoResult: 		(self platform				createStoreSpecificViewsSQLUsingAccessor: self role: userOrRoleString)</body><body package="Store-Database Model">createUser: loginName password: loginPassword	| result |	self platform isSQLServerPlatform		ifTrue: [self platform setCurrentDatabase: 'master' inAccessor: self].	result := self executeInDDLOperation: 					[self						executeSQLStringsNoResult: (self platform sqlStatementToCreateUser: loginName								password: loginPassword).					true]				ifError: 					[:ex |					| dbmsError |					dbmsError := ex parameter first.					(self platform isUserAlreadyExistsError: dbmsError)						ifTrue: 							["User already exists"							ex return: false]						ifFalse: [ex pass]].	^result</body><body package="Store-Database Model">grantStoreDeveloperSpecificPermissionsToUserOrRole: userOrRoleString	self executeSQLStringsNoResult: 		(self platform				grantStoreSpecificPermissionsSQLOnSchema: self schema toRole: userOrRoleString)</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>database-specific</category><body package="Store-Database Model">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor role: roleName	| schema |	schema := aDatabaseAccessor schema.	^'CREATE VIEW &lt;1s&gt;.TW_MethodsView as	SELECT &lt;1s&gt;.TW_Method.primaryKey, &lt;1s&gt;.TW_Method.name, &lt;1s&gt;.TW_Method.timeStamp, &lt;1s&gt;.TW_Method.version, &lt;1s&gt;.TW_Method.userName, &lt;1s&gt;.TW_Method.trace, &lt;1s&gt;.TW_Method.className, &lt;1s&gt;.TW_Methods.packageRef, &lt;1s&gt;.TW_Method.sourceCodeID, &lt;1s&gt;.TW_Method.protocolName	FROM &lt;1s&gt;.TW_Methods, &lt;1s&gt;.TW_Method	WHERE &lt;1s&gt;.TW_Methods.methodRef = &lt;1s&gt;.TW_Method.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_MethodsView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgClassesView as	SELECT &lt;1s&gt;.TW_ClassRecord.primaryKey, &lt;1s&gt;.TW_ClassRecord.name, &lt;1s&gt;.TW_ClassRecord.timeStamp, &lt;1s&gt;.TW_ClassRecord.userName, &lt;1s&gt;.TW_ClassRecord.trace, &lt;1s&gt;.TW_ClassRecord.superclass, &lt;1s&gt;.TW_ClassRecord.definitionID, &lt;1s&gt;.TW_ClassRecord.environmentString, &lt;1s&gt;.TW_ClassRecord.commentID, &lt;1s&gt;.TW_PkgClasses.packageRef, &lt;1s&gt;.TW_PkgClasses.definitionOrder	FROM &lt;1s&gt;.TW_PkgClasses, &lt;1s&gt;.TW_ClassRecord	WHERE &lt;1s&gt;.TW_PkgClasses.classRef = &lt;1s&gt;.TW_ClassRecord.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PkgClassesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgMetaclassesView as	SELECT &lt;1s&gt;.TW_ClassRecord.primaryKey, &lt;1s&gt;.TW_ClassRecord.name, &lt;1s&gt;.TW_ClassRecord.timeStamp, &lt;1s&gt;.TW_ClassRecord.userName, &lt;1s&gt;.TW_ClassRecord.trace, &lt;1s&gt;.TW_ClassRecord.superclass, &lt;1s&gt;.TW_ClassRecord.definitionID, &lt;1s&gt;.TW_ClassRecord.environmentString, &lt;1s&gt;.TW_ClassRecord.commentID, &lt;1s&gt;.TW_PkgClasses.packageRef, &lt;1s&gt;.TW_PkgClasses.definitionOrder	FROM &lt;1s&gt;.TW_PkgClasses, &lt;1s&gt;.TW_ClassRecord	WHERE &lt;1s&gt;.TW_PkgClasses.metaclassRef = &lt;1s&gt;.TW_ClassRecord.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PkgMetaclassesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgNameSpacesView as	SELECT &lt;1s&gt;.TW_NameSpaceRecord.primaryKey, &lt;1s&gt;.TW_NameSpaceRecord.name, &lt;1s&gt;.TW_NameSpaceRecord.timeStamp, &lt;1s&gt;.TW_NameSpaceRecord.userName, &lt;1s&gt;.TW_NameSpaceRecord.trace, &lt;1s&gt;.TW_NameSpaceRecord.definitionID, &lt;1s&gt;.TW_NameSpaceRecord.commentID, &lt;1s&gt;.TW_NameSpaceRecord.environmentString, &lt;1s&gt;.TW_PkgNameSpaces.packageRef, &lt;1s&gt;.TW_PkgNameSpaces.definitionOrder	FROM &lt;1s&gt;.TW_PkgNameSpaces, &lt;1s&gt;.TW_NameSpaceRecord	WHERE &lt;1s&gt;.TW_PkgNameSpaces.nameSpaceRef = &lt;1s&gt;.TW_NameSpaceRecord.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PkgNameSpacesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_DataView as	SELECT &lt;1s&gt;.TW_DataElement.primaryKey, &lt;1s&gt;.TW_DataElement.name, &lt;1s&gt;.TW_DataElement.timeStamp, &lt;1s&gt;.TW_DataElement.userName, &lt;1s&gt;.TW_DataElement.trace, &lt;1s&gt;.TW_Data.packageRef, &lt;1s&gt;.TW_DataElement.definitionID, &lt;1s&gt;.TW_DataElement.commentID, &lt;1s&gt;.TW_DataElement.environmentString, &lt;1s&gt;.TW_DataElement.protocolName, &lt;1s&gt;.TW_DataElement.typeString	FROM &lt;1s&gt;.TW_Data, &lt;1s&gt;.TW_DataElement	WHERE &lt;1s&gt;.TW_Data.dataRef = &lt;1s&gt;.TW_DataElement.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_DataView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PropertiesView as	SELECT &lt;1s&gt;.TW_PropertyRecord.primaryKey, &lt;1s&gt;.TW_PropertyRecord.name, &lt;1s&gt;.TW_PropertyRecord.timeStamp, &lt;1s&gt;.TW_PropertyRecord.userName, &lt;1s&gt;.TW_PropertyRecord.trace, &lt;1s&gt;.TW_PropertyRecord.definitionID, &lt;1s&gt;.TW_PropertyRecord.commentID, &lt;1s&gt;.TW_PropertyRecord.environmentString, &lt;1s&gt;.TW_PropertyRecord.searchString, &lt;1s&gt;.TW_Properties.pundleRef, &lt;1s&gt;.TW_Properties.recType	FROM &lt;1s&gt;.TW_Properties, &lt;1s&gt;.TW_PropertyRecord	WHERE &lt;1s&gt;.TW_Properties.propertyRef = &lt;1s&gt;.TW_PropertyRecord.primaryKey;GRANT SELECT ON &lt;1s&gt;.TW_PropertiesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_MethodsAndSourcesView as	SELECT &lt;1s&gt;.TW_Method.primaryKey, &lt;1s&gt;.TW_Method.name, &lt;1s&gt;.TW_Method.timeStamp, &lt;1s&gt;.TW_Method.version, &lt;1s&gt;.TW_Method.userName, &lt;1s&gt;.TW_Method.trace, &lt;1s&gt;.TW_Method.className, &lt;1s&gt;.TW_Methods.packageRef, &lt;1s&gt;.TW_Method.sourceCodeID, &lt;1s&gt;.TW_Method.protocolName, &lt;1s&gt;.TW_Blob.blobData, &lt;1s&gt;.TW_Blob.blobType	FROM &lt;1s&gt;.TW_Method JOIN &lt;1s&gt;.TW_Methods ON ((&lt;1s&gt;.TW_Method.primaryKey = &lt;1s&gt;.TW_Methods.methodRef))  JOIN &lt;1s&gt;.TW_Blob ON ((&lt;1s&gt;.TW_Method.sourceCodeID = &lt;1s&gt;.TW_Blob.primaryKey)) ;GRANT SELECT ON &lt;1s&gt;.TW_MethodsAndSourcesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_DataAndSourcesView as	SELECT &lt;1s&gt;.TW_DataElement.primaryKey, &lt;1s&gt;.TW_DataElement.name, &lt;1s&gt;.TW_DataElement.timeStamp, &lt;1s&gt;.TW_DataElement.userName, &lt;1s&gt;.TW_DataElement.trace, &lt;1s&gt;.TW_Data.packageRef, &lt;1s&gt;.TW_DataElement.definitionID, &lt;1s&gt;.TW_DataElement.commentID, &lt;1s&gt;.TW_DataElement.environmentString, &lt;1s&gt;.TW_DataElement.protocolName, &lt;1s&gt;.TW_DataElement.typeString, &lt;1s&gt;.TW_Blob.blobData, &lt;1s&gt;.TW_Blob.blobType	FROM &lt;1s&gt;.TW_DataElement JOIN &lt;1s&gt;.TW_Data ON ((&lt;1s&gt;.TW_DataElement.primaryKey = &lt;1s&gt;.TW_Data.dataRef))  JOIN &lt;1s&gt;.TW_Blob ON ((&lt;1s&gt;.TW_DataElement.definitionID = &lt;1s&gt;.TW_Blob.primaryKey)) ;GRANT SELECT ON &lt;1s&gt;.TW_DataAndSourcesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgClassesAndSourcesView as	SELECT &lt;1s&gt;.TW_ClassRecord.primaryKey, &lt;1s&gt;.TW_ClassRecord.name, &lt;1s&gt;.TW_ClassRecord.timeStamp, &lt;1s&gt;.TW_ClassRecord.userName, &lt;1s&gt;.TW_ClassRecord.trace, &lt;1s&gt;.TW_ClassRecord.superclass, &lt;1s&gt;.TW_ClassRecord.definitionID, &lt;1s&gt;.TW_ClassRecord.environmentString, &lt;1s&gt;.TW_ClassRecord.commentID, &lt;1s&gt;.TW_PkgClasses.packageRef, &lt;1s&gt;.TW_PkgClasses.definitionOrder, &lt;1s&gt;.TW_Blob.blobData, &lt;1s&gt;.TW_Blob.blobType	FROM &lt;1s&gt;.TW_ClassRecord JOIN &lt;1s&gt;.TW_PkgClasses ON ((&lt;1s&gt;.TW_ClassRecord.primaryKey = &lt;1s&gt;.TW_PkgClasses.classRef))  JOIN &lt;1s&gt;.TW_Blob ON ((&lt;1s&gt;.TW_ClassRecord.definitionID = &lt;1s&gt;.TW_Blob.primaryKey)) ;GRANT SELECT ON &lt;1s&gt;.TW_PkgClassesAndSourcesView TO &lt;2s&gt;;CREATE VIEW &lt;1s&gt;.TW_PkgNameSpacesAndSourcesView as	SELECT &lt;1s&gt;.TW_NameSpaceRecord.primaryKey, &lt;1s&gt;.TW_NameSpaceRecord.name, &lt;1s&gt;.TW_NameSpaceRecord.timeStamp, &lt;1s&gt;.TW_NameSpaceRecord.userName, &lt;1s&gt;.TW_NameSpaceRecord.trace, &lt;1s&gt;.TW_NameSpaceRecord.definitionID, &lt;1s&gt;.TW_NameSpaceRecord.commentID, &lt;1s&gt;.TW_NameSpaceRecord.environmentString, &lt;1s&gt;.TW_PkgNameSpaces.packageRef, &lt;1s&gt;.TW_PkgNameSpaces.definitionOrder, &lt;1s&gt;.TW_Blob.blobData, &lt;1s&gt;.TW_Blob.blobType	FROM &lt;1s&gt;.TW_NameSpaceRecord JOIN &lt;1s&gt;.TW_PkgNameSpaces ON ((&lt;1s&gt;.TW_NameSpaceRecord.primaryKey = &lt;1s&gt;.TW_PkgNameSpaces.nameSpaceRef))  JOIN &lt;1s&gt;.TW_Blob ON ((&lt;1s&gt;.TW_NameSpaceRecord.definitionID = &lt;1s&gt;.TW_Blob.primaryKey)) ;GRANT SELECT ON &lt;1s&gt;.TW_PkgNameSpacesAndSourcesView TO &lt;2s&gt;'	expandMacrosWith: schema with: roleName.</body><body package="Store-Database Model">dropStoreSpecificViewsSQL	^'DROP VIEW BERN.TW_PkgNameSpacesAndSourcesView;DROP VIEW BERN.TW_PkgClassesAndSourcesView;DROP VIEW BERN.TW_DataAndSourcesView;DROP VIEW BERN.TW_MethodsAndSourcesView;DROP VIEW BERN.TW_PropertiesView;DROP VIEW BERN.TW_DataView;DROP VIEW BERN.TW_PkgNameSpacesView;DROP VIEW BERN.TW_PkgMetaclassesView;DROP VIEW BERN.TW_PkgClassesView;DROP VIEW BERN.TW_MethodsView'</body><body package="Store-Database Model">grantStoreSpecificPermissionsSQLOnSchema: schemaName toRole: roleName	^'GRANT INSERT, SELECT ON &lt;1s&gt;.TW_ClassRecord TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_ClassRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_NameSpaceRecord TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_NameSpaceRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Package TO &lt;2s&gt;;GRANT UPDATE ON &lt;1s&gt;.TW_Package TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_PackageSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_ParcelRecord TO &lt;2s&gt;;GRANT UPDATE ON &lt;1s&gt;.TW_ParcelRecord TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_ParcelRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_PkgClasses TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_PkgNameSpaces TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Method TO &lt;2s&gt;;GRANT UPDATE ON &lt;1s&gt;.TW_Method TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_MethodSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Methods TO &lt;2s&gt;;GRANT UPDATE, DELETE ON &lt;1s&gt;.TW_Methods TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Blob TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_BlobSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_BinaryBlob TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_BinaryBlobSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Blessing TO &lt;2s&gt;;GRANT UPDATE ON &lt;1s&gt;.TW_Blessing TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_BlessingSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Bundle TO &lt;2s&gt;;GRANT UPDATE ON &lt;1s&gt;.TW_Bundle TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_BundleSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Bundles TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Packages TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_DataElement TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_DataElementSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Data TO &lt;2s&gt;;GRANT UPDATE, DELETE ON &lt;1s&gt;.TW_Data TO &lt;2s&gt;;GRANT SELECT, UPDATE ON &lt;1s&gt;.TW_DatabaseIdentifier TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Files TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_FileRecord TO &lt;2s&gt;;GRANT UPDATE ON &lt;1s&gt;.TW_FileRecord TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_FileRecordSeq TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_Properties TO &lt;2s&gt;;GRANT INSERT, SELECT ON &lt;1s&gt;.TW_PropertyRecord TO &lt;2s&gt;;GRANT USAGE ON  SEQUENCE &lt;1s&gt;.TW_PropertyRecordSeq TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_DBUserGroup TO &lt;2s&gt;;GRANT SELECT ON &lt;1s&gt;.TW_DBPundlePrivileges TO &lt;2s&gt;;GRANT SELECT, INSERT ON &lt;1s&gt;.TW_LoadRecord TO &lt;2s&gt;;GRANT SELECT, INSERT ON &lt;1s&gt;.TW_MethodDocs TO &lt;2s&gt;'	expandMacrosWith: schemaName with: roleName.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>services - users and roles</category><body package="Store-Database Model">sqlStatementToCreateRole: roleName	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'CREATE ROLE ';		nextPutAll: roleName.	^writeStream contents</body><body package="Store-Database Model">sqlStatementToCreateSchema: schemaName withOwner: ownerName	| writeStream |	writeStream := WriteStream on: String new.	writeStream		nextPutAll: 'CREATE SCHEMA ';		nextPutAll: schemaName;		nextPutAll: ' AUTHORIZATION ';		nextPutAll: ownerName.	^writeStream contents</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>database-specific</category><body package="Store-Database Model">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^UnableToExecuteSQL</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>types</category><body package="Store-Database Model">binary32k	"Return a type suitable for holding StoreBlob binary data, known to be 32000 bytes or less in length.  For performance, platforms override to use an inline type where such a type is available."	^self blob</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">configureSystemForStore: aStoreDescriptorSystem	"Do nothing."</body><body package="Store-Database Model">createSchemaIfNecessaryIn: tableSpaceName usingAccessor: aDatabaseAccessor	"Do nothing"		^self</body><body package="Store-Database Model">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor role: roleName	^nil</body><body package="Store-Database Model">dropStoreSpecificViewsSQL	^nil</body><body package="Store-Database Model">grantStoreSpecificPermissionsSQLOnSchema: schemaName toRole: roleName	^nil</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>constants</category><body package="Store-Database Model">installationCanceledMessage	^'Installation was canceled'</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">installPhysicalSpacesIn: aDatabaseAccessor	"By default do nothing. Subclasses may want to do something"	^self</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>testing - errors</category><body package="Store-Database Model">isRoleAlreadyExistsError: dbmsError	^self subclassResponsibility</body><body package="Store-Database Model">isUserAlreadyExistsError: dbmsError	^self subclassResponsibility</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">postLoginInitializeStoreFromAccessor: anAccessor	"Subclasses, extended in StoreFor&lt;Platform&gt; packages, do Store-specific configuration if needed."</body><body package="Store-Database Model">preLoginInitializeStoreFromAccessor: anAccessor	"Subclasses, extended in StoreFor&lt;Platform&gt; packages, do Store-specific configuration if needed."</body><body package="Store-Database Model">spaceForBlobs	"Default is same as for Oracle"	^ '32M'</body><body package="Store-Database Model">spaceForClasses	"Default is same as for Oracle"	^ '32M'</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services - users and roles</category><body package="Store-Database Model">sqlStatementToCreateRole: roleName	^self subclassResponsibility</body><body package="Store-Database Model">sqlStatementToCreateSchema: schemaName withOwner: ownerName	^self subclassResponsibility</body><body package="Store-Database Model">sqlStatementToCreateUser: loginName password: loginPassword	^self subclassResponsibility</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>database-specific</category><body package="Store-Database Model">storeSchemaNotFoundError	"Subclasses should supply a Database specific error that is raised if a table is not found	UnableToExecuteSQL is a standin for a more specific type of error"	^UnableToExecuteSQL</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>sequences</category><body package="Store-Database Model">storeSequenceNameFor: aString	"Return a string representing the default Store sequence name on this platform"	^aString, 'Seq'.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>testing</category><body package="Store-Database Model">supportsPhysicalSpaces	^false</body><body package="Store-Database Model">supportsUsers	^true</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>database-specific</category><body package="Store-Database Model">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor role: roleName	"DatabaseAccessor not really needed for this platform because it uses an 	implicit schema and doesn't need changes for script vs direct execution."	^'CREATE VIEW TW_MethodsView as	SELECT TW_Method.primaryKey, TW_Method.name, TW_Method.timestmp, TW_Method.version, TW_Method.userName, TW_Method.trace, TW_Method.className, TW_Methods.packageRef, TW_Method.sourceCodeID, TW_Method.protocolName	FROM TW_Methods, TW_Method	WHERE TW_Methods.methodRef = TW_Method.primaryKey;GRANT SELECT ON TW_MethodsView TO &lt;1s&gt;;CREATE VIEW TW_PkgClassesView as	SELECT TW_ClassRecord.primaryKey, TW_ClassRecord.name, TW_ClassRecord.timestmp, TW_ClassRecord.userName, TW_ClassRecord.trace, TW_ClassRecord.superclass, TW_ClassRecord.definitionID, TW_ClassRecord.environmentString, TW_ClassRecord.commentID, TW_PkgClasses.packageRef, TW_PkgClasses.definitionOrder	FROM TW_PkgClasses, TW_ClassRecord	WHERE TW_PkgClasses.classRef = TW_ClassRecord.primaryKey;GRANT SELECT ON TW_PkgClassesView TO &lt;1s&gt;;CREATE VIEW TW_PkgMetaclassesView as	SELECT TW_ClassRecord.primaryKey, TW_ClassRecord.name, TW_ClassRecord.timestmp, TW_ClassRecord.userName, TW_ClassRecord.trace, TW_ClassRecord.superclass, TW_ClassRecord.definitionID, TW_ClassRecord.environmentString, TW_ClassRecord.commentID, TW_PkgClasses.packageRef, TW_PkgClasses.definitionOrder	FROM TW_PkgClasses, TW_ClassRecord	WHERE TW_PkgClasses.metaclassRef = TW_ClassRecord.primaryKey;GRANT SELECT ON TW_PkgMetaclassesView TO &lt;1s&gt;;CREATE VIEW TW_PkgNameSpacesView as	SELECT TW_NameSpaceRecord.primaryKey, TW_NameSpaceRecord.name, TW_NameSpaceRecord.timestmp, TW_NameSpaceRecord.userName, TW_NameSpaceRecord.trace, TW_NameSpaceRecord.definitionID, TW_NameSpaceRecord.commentID, TW_NameSpaceRecord.environmentString, TW_PkgNameSpaces.packageRef, TW_PkgNameSpaces.definitionOrder	FROM TW_PkgNameSpaces, TW_NameSpaceRecord	WHERE TW_PkgNameSpaces.nameSpaceRef = TW_NameSpaceRecord.primaryKey;GRANT SELECT ON TW_PkgNameSpacesView TO &lt;1s&gt;;CREATE VIEW TW_DataView as	SELECT TW_DataElement.primaryKey, TW_DataElement.name, TW_DataElement.timestmp, TW_DataElement.userName, TW_DataElement.trace, TW_Data.packageRef, TW_DataElement.definitionID, TW_DataElement.commentID, TW_DataElement.environmentString, TW_DataElement.protocolName, TW_DataElement.typeString	FROM TW_Data, TW_DataElement	WHERE TW_Data.dataRef = TW_DataElement.primaryKey;GRANT SELECT ON TW_DataView TO &lt;1s&gt;;CREATE VIEW TW_PropertiesView as	SELECT TW_PropertyRecord.primaryKey, TW_PropertyRecord.name, TW_PropertyRecord.timestmp, TW_PropertyRecord.userName, TW_PropertyRecord.trace, TW_PropertyRecord.definitionID, TW_PropertyRecord.commentID, TW_PropertyRecord.environmentString, TW_PropertyRecord.searchString, TW_Properties.pundleRef, TW_Properties.recType	FROM TW_Properties, TW_PropertyRecord	WHERE TW_Properties.propertyRef = TW_PropertyRecord.primaryKey;GRANT SELECT ON TW_PropertiesView TO &lt;1s&gt;;CREATE VIEW TW_MethodsAndSourcesView as	SELECT TW_Method.primaryKey, TW_Method.name, TW_Method.timestmp, TW_Method.version, TW_Method.userName, TW_Method.trace, TW_Method.className, TW_Methods.packageRef, TW_Method.sourceCodeID, TW_Method.protocolName, TW_Blob.blobData, TW_Blob.blobType	FROM TW_Method JOIN TW_Methods ON ((TW_Method.primaryKey = TW_Methods.methodRef))  JOIN TW_Blob ON ((TW_Method.sourceCodeID = TW_Blob.primaryKey));GRANT SELECT ON TW_MethodsAndSourcesView TO &lt;1s&gt;;CREATE VIEW TW_DataAndSourcesView as	SELECT TW_DataElement.primaryKey, TW_DataElement.name, TW_DataElement.timestmp, TW_DataElement.userName, TW_DataElement.trace, TW_Data.packageRef, TW_DataElement.definitionID, TW_DataElement.commentID, TW_DataElement.environmentString, TW_DataElement.protocolName, TW_DataElement.typeString, TW_Blob.blobData, TW_Blob.blobType	FROM TW_DataElement JOIN TW_Data ON ((TW_DataElement.primaryKey = TW_Data.dataRef))  JOIN TW_Blob ON ((TW_DataElement.definitionID = TW_Blob.primaryKey));GRANT SELECT ON TW_DataAndSourcesView TO &lt;1s&gt;;CREATE VIEW TW_PkgClassesAndSourcesView as	SELECT TW_ClassRecord.primaryKey, TW_ClassRecord.name, TW_ClassRecord.timestmp, TW_ClassRecord.userName, TW_ClassRecord.trace, TW_ClassRecord.superclass, TW_ClassRecord.definitionID, TW_ClassRecord.environmentString, TW_ClassRecord.commentID, TW_PkgClasses.packageRef, TW_PkgClasses.definitionOrder, TW_Blob.blobData, TW_Blob.blobType	FROM TW_ClassRecord JOIN TW_PkgClasses ON ((TW_ClassRecord.primaryKey = TW_PkgClasses.classRef))  JOIN TW_Blob ON ((TW_ClassRecord.definitionID = TW_Blob.primaryKey));GRANT SELECT ON TW_PkgClassesAndSourcesView TO &lt;1s&gt;;CREATE VIEW TW_PkgNameSpacesAndSourcesView as	SELECT TW_NameSpaceRecord.primaryKey, TW_NameSpaceRecord.name, TW_NameSpaceRecord.timestmp, TW_NameSpaceRecord.userName, TW_NameSpaceRecord.trace, TW_NameSpaceRecord.definitionID, TW_NameSpaceRecord.commentID, TW_NameSpaceRecord.environmentString, TW_PkgNameSpaces.packageRef, TW_PkgNameSpaces.definitionOrder, TW_Blob.blobData, TW_Blob.blobType	FROM TW_NameSpaceRecord JOIN TW_PkgNameSpaces ON ((TW_NameSpaceRecord.primaryKey = TW_PkgNameSpaces.nameSpaceRef))  JOIN TW_Blob ON ((TW_NameSpaceRecord.definitionID = TW_Blob.primaryKey));GRANT SELECT ON TW_PkgNameSpacesAndSourcesView TO &lt;1s&gt;'	expandMacrosWith: roleName</body><body package="Store-Database Model">dropStoreSpecificViewsSQL	^'DROP VIEW TW_PkgNameSpacesAndSourcesView;DROP VIEW TW_PkgClassesAndSourcesView;DROP VIEW TW_DataAndSourcesView;DROP VIEW TW_MethodsAndSourcesView;DROP VIEW TW_PropertiesView;DROP VIEW TW_DataView;DROP VIEW TW_PkgNameSpacesView;DROP VIEW TW_PkgMetaclassesView;DROP VIEW TW_PkgClassesView;DROP VIEW TW_MethodsView'</body><body package="Store-Database Model">grantStoreSpecificPermissionsSQLOnSchema: schemaName toRole: roleName	"DatabaseAccessor not really needed for this platform because it uses an 	implicit schema and doesn't need changes for script vs direct execution."	^'GRANT INSERT, SELECT ON TW_ClassRecord TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_NameSpaceRecord TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Package TO &lt;1s&gt;;GRANT UPDATE ON TW_Package TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_ParcelRecord TO &lt;1s&gt;;GRANT UPDATE ON TW_ParcelRecord TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_PkgClasses TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_PkgNameSpaces TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Method TO &lt;1s&gt;;GRANT UPDATE ON TW_Method TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Methods TO &lt;1s&gt;;GRANT UPDATE, DELETE ON TW_Methods TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Blob TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_BinaryBlob TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Blessing TO &lt;1s&gt;;GRANT UPDATE ON TW_Blessing TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Bundle TO &lt;1s&gt;;GRANT UPDATE ON TW_Bundle TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Bundles TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Packages TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_DataElement TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Data TO &lt;1s&gt;;GRANT UPDATE, DELETE ON TW_Data TO &lt;1s&gt;;GRANT SELECT, UPDATE ON TW_DatabaseIdentifier TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Files TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_FileRecord TO &lt;1s&gt;;GRANT UPDATE ON TW_FileRecord TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_Properties TO &lt;1s&gt;;GRANT INSERT, SELECT ON TW_PropertyRecord TO &lt;1s&gt;;GRANT SELECT ON TW_DBUserGroup TO &lt;1s&gt;;GRANT SELECT ON TW_DBPundlePrivileges TO &lt;1s&gt;'	expandMacrosWith: roleName</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Database Model">compareToPundle: aPundleRecord	| info |	^( info := self databaseInformationFor: aPundleRecord dbIdentifier ) == nil		ifTrue: [#notLoaded]		ifFalse: 			[info dbTrace = aPundleRecord primaryKey				ifTrue:					[( self hasBeenModifiedIn: aPundleRecord dbIdentifier )						ifTrue: [#modified]						ifFalse: [#same]]				ifFalse: [#notSame]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-Database Model">extractVersionFromVersionDisplayString	| result versionString |	versionString := self versionString.	result := versionString first = $( 		ifFalse: [(versionString = '*' or:  [versionString = '=']) ifTrue: [''] ifFalse: [versionString]]		ifTrue: 			[ | index | 			(index := versionString lastIndexOf: $,) &gt; 0 				ifTrue: [versionString copyFrom: 2 to: index -1]				ifFalse: 					[(index := versionString lastIndexOf: $)) &gt; 0						ifTrue: [versionString copyFrom: 2 to: index - 1]						ifFalse: [versionString copyFrom: 2 to: versionString size]]].	^result</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Database Model">hasRelatedParcel	^false</body><body package="Store-Database Model">hasRelatedParcelIn: aSession	^false</body><body package="Store-Database Model">isVersionLoaded	^true</body><body package="Store-Database Model">sameAsImage	^true</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	^self instanceBehavior isInStandardEnvironment</body></methods><methods><class-id>Kernel.AssemblerCodeStream</class-id> <category>private</category><body package="Atomic Compiling and Loading">realClassOrNil	"This method is supplied by the Shadowed Compiling package.  It is used to help determine	if the destination class for the method will be in the Context hierarchy.	We should not track up the superclass chain. If the class's standardEnvironmentClass is nil, 	it should just directly answer nil. Otherwise, if I'm adding a new subclass to Object, its realClassOrNil will be Object. 	This new class can't be an ancestor of Context or SmallInteger, but Object is an ancestor class of Context and SmallInteger, 	so the analysis of forNonImmediate and forContext will be wrong"	Store.DbRegistry useAtomicLoader ifFalse: [^class].	^class standardEnvironmentClass.</body><body package="Atomic Compiling and Loading">setContextFlag	"We just saw our first reference to	an instance variable.  Check whether	this class might be a sub- or superclass	of Context, which requires special	action at run time."	"This method is overridden by the Shadow Compiling package to ensure that if 	 an extension method is being installed on Context, a proper CompiledMethod is	 created.  Context (and subclasses) have special CompiledMethods that are not	 short."	|realClass|	realClass := self realClassOrNil.	realClass == nil ifTrue: 		[forContext := false. 		^self].	forContext := realClass instSize &lt; Context instSize		ifTrue: [Context inheritsFrom: realClass]		ifFalse: [realClass == Context or: [realClass inheritsFrom: Context]]</body></methods><methods><class-id>Kernel.HintedCodeStream</class-id> <category>private</category><body package="Atomic Compiling and Loading">isShadowClassIsForNonImmediate	"Make an explicit test for realClass if it is nil. 	The problem is that SmallInteger inheritsFrom nil, so if this method didn't test for nil it would answer true, 	when the desired behavior when realClass is nil is for this method to answer false."		| realClass |	(realClass := self realClassOrNil) ifNil: [^false].	^(SmallInteger inheritsFrom: realClass) or:		[(Character inheritsFrom: realClass)			or: [SmallDouble inheritsFrom: realClass]]</body><body package="Atomic Compiling and Loading">setClassProperties	"Set the flags indicating whether this class	is definitely a non-subclassable (immediate) class,	or if this class is definitely not	an immediate class or a superclass of one."	class instSize &gt; 0	  ifTrue:  "can't be a super of an immediate"		[forNonImmediate := true.		forNonSubclassable := false]	  ifFalse:		[class hasImmediateInstances		  ifTrue:			[forNonImmediate := false.			forNonSubclassable := true]		  ifFalse:			[forNonImmediate := ((SmallInteger inheritsFrom: class)								or: [(Character inheritsFrom: class)								or: [(SmallDouble inheritsFrom: class)								or: [self isShadowClassIsForNonImmediate]]]) not.			forNonSubclassable := false]]</body></methods><methods><class-id>Kernel.BehaviorBuilderRecord</class-id> <category>accessing</category><body package="Atomic Compiling and Loading">classOfBehavior: aBehavior	^aBehavior isBehavior		ifTrue: [aBehavior class]		ifFalse: [aBehavior isNil			ifTrue: [ RequestNilSuperClassNotification raiseSignal ]			ifFalse: [self buildError: (#ThisObjectShouldBeNilOrBehavior &lt;&lt; #dialogs &gt;&gt; 'This object should be nil or a Behavior')]]</body></methods><methods><class-id>Kernel.BehaviorBuilderRecord</class-id> <category>accessing shadow compiliation</category><body package="Atomic Compiling and Loading">standardEnvironmentClass	"If the receiver has a targetClass, then ask the targetClass for its standardEnvironmentClass.  	 See Behavior&gt;&gt;standardEnvironmentClass for more details."	^targetClass ifNotNil: [targetClass standardEnvironmentClass]</body></methods><methods><class-id>Core.Class</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	| myEnvironment |	myEnvironment := self environment == nil 				ifTrue: [environment]				ifFalse: [self environment].	[myEnvironment environment == nil] 		whileFalse: [myEnvironment := myEnvironment environment].	^myEnvironment == Root</body></methods><methods><class-id>Core.Class</class-id> <category>accessing-store shadow compilation</category><body package="Atomic Compiling and Loading">reallyFullyQualifiedReference	| mySmalltalk |	mySmalltalk := self.	mySmalltalk environment == nil 		ifTrue: [^self fullyQualifiedReferenceFrom: mySmalltalk].	[mySmalltalk environment environment == nil] 		whileFalse: [mySmalltalk := mySmalltalk environment].	^self fullyQualifiedReferenceFrom: mySmalltalk</body></methods><methods><class-id>Core.Class</class-id> <category>accessing shadow compilation</category><body package="Atomic Compiling and Loading">relocateImportsToShadow	"The class has just been created in shadow. Make sure imports refer to shadow too, 	so that the compiler can resolve names that refer to shadow objects as well.	One example is an ExternalDictionary which coexists with the freshly created ExternalInterface class in shadow only."	| p aShadowNameSpaceHandler shadowSmalltalk |	p := Processor activeProcess.	(aShadowNameSpaceHandler := p environment bindingHandler) == #unset		ifTrue: [^self].	shadowSmalltalk := aShadowNameSpaceHandler shadowRoot at: #Smalltalk.	self importDefinitions do: [:x| x home: shadowSmalltalk]</body></methods><methods><class-id>Core.Class</class-id> <category>class variables</category><body package="Atomic Compiling and Loading">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	^self asNameSpace 		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString</body><body package="Atomic Compiling and Loading">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes	^self asNameSpace 		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: attributes</body><body package="Atomic Compiling and Loading">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	"Backward compatibility."	^self		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString</body><body package="Atomic Compiling and Loading">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes	"Backward compatibility."	^self		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: attributes</body></methods><methods><class-id>Core.Class</class-id> <category>subclass creation</category><body package="Atomic Compiling and Loading">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver). This method has been retained for	VisualSmalltalk file-out compatibility."	^self shadowLoadSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: self environment organization class defaultProtocol</body><body package="Atomic Compiling and Loading">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver)."	| approved builder |	approved := SystemUtils validateClassName: t for: nil.	approved ifNil: [^nil].	builder := self classBuilder addRecord: (BehaviorBuilderRecord forName: approved in: Smalltalk).	^builder		superclass: self;		instVarString: f;		classVarString: d;		poolString: (self computeFullPoolString: s);		category: cat;		beFixed;		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading">shadowLoadVariableByteSubclass: t classVariableNames: d poolDictionaries: s	"This is a compatibility API method for creating a new class 	as a subclass of an existing class (the receiver) in which the 	subclass is to have indexable byte-sized nonpointer variables.	This method has been retained for VisualSmalltalk file-out	compatibility."	^self shadowLoadVariableByteSubclass: t		instanceVariableNames: ''		classVariableNames: d		poolDictionaries: s		category: self environment organization class defaultProtocol</body><body package="Atomic Compiling and Loading">shadowLoadVariableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is a compatibility API method for creating a new class 	as a subclass of an existing class (the receiver) in which the 	subclass is to have indexable byte-sized nonpointer variables."	| approved |	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^nil].	^(self classBuilder) 		superclass: self; 		environment: Smalltalk; 		className: approved; 		instVarString: f; 		classVarString: d; 		poolString: (self computeFullPoolString: s); 		category: cat; 		beBytes; 		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading">shadowLoadVariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver) in which the subclass is to have indexable	pointer variables. This method has been retained for VisualSmalltalk file-out compatibility."	^self shadowLoadVariableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: self environment organization class defaultProtocol</body><body package="Atomic Compiling and Loading">shadowLoadVariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver) in which the subclass is to have indexable	pointer variables. This method has been retained for VisualSmalltalk file-out	compatibility."	| approved |	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^nil].	^self classBuilder		superclass: self;		environment: Smalltalk;		className: approved;		instVarString: f;		classVarString: d;		poolString: (self computeFullPoolString: s);		category: cat;		beVariable;		reviseSystemForAtomicCompiling</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>private-compiling</category><body package="Atomic Compiling and Loading">compileForShadow: aString classified: aCategoryName notifying: requestor environment: aNamespace attributes: attributes	"Compile the argument, code, as source code in the context of the receiver 	and install the result in the receiver's method dictionary under the 	classification indicated by the second argument, heading.  The third 	argument, requestor, is to be notified if an error occurs.  The argument code 	is either a string or an object that converts to a string or a 	PositionableStream on an object that converts to a string."		| selector |	self		compileForShadow: aString		notifying: requestor		attributes: attributes		selectorBlock: [:newSelector :existingMethod | selector := newSelector]		ifFail: [^nil]		environment: aNamespace.	(methodDict at: selector) sourcePointer: aString.	self organization classify: selector under: aCategoryName.	^selector</body><body package="Atomic Compiling and Loading">compileForShadow: aString notifying: requestor attributes: attributes selectorBlock: selectorBlock ifFail: failBlock environment: aNamespace	"Intercept this message in order to remember system changes."		| methodNode selector compiler message existingMethod |	compiler := self compilerClass new.	compiler environment: aNamespace.	methodNode := compiler 		compile: aString 		in: self 		notifying: requestor 		ifFail: failBlock.	(aNamespace notNil and: [aNamespace ~~ self environment]) ifTrue:		[message := Message selector: #__namespace: argument: aNamespace.		methodNode method: (methodNode generate withAdditionalProperties: (Array with: message))].	selector := methodNode selector.	existingMethod := methodDict at: selector ifAbsent: [nil].	selectorBlock value: selector value: existingMethod.	existingMethod ifNotNil:		[RedefinitionNotification redefinedSelector: selector class: self attributes: existingMethod attributes].	self addSelectorForShadow: selector withMethod: methodNode generate.	^selector</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading">postCopyFromShadow: shadowClass	"We have just been copied from a shadow namespace, either because we were just loaded, or because changes to us were just loaded. Normally we shouldn't have to do anything, but in some circumstances we might. For example, subclasses of GeneralParser rely on side effects of method compilation to populate the methodInfo class instance variable. If the class is compiled in shadow and then the resulting compiled methods are applied, those side effects will have happened only to the shadow class. This method gives us an opportunity to do anything necessary."</body><body package="Atomic Compiling and Loading">redirectInstallTo: mgr	^mgr installClass: self.</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>private-loading</category><body package="Atomic Compiling and Loading">ensureLoadedParcel: parcelName withVersion: versionString for: aPundle with: aCompilationManagerOrNil	"Check if a Parcel named parcelName is loaded with an appropriate version.	If its not then attempt to load it.  If codeReaderOrNil is non-nil then substitute codeReaderOrNil streamDirectory for `current directory' in the SearchPath directory list.	If the parcel is already loaded check its version and bail if its not acceptable.	If aDirectoryOrNil notNil include it after the list.	As a last resort include the current directory.	Map the current directory onto the supplied current directory if dirName is dot and we're not searching the current directory."	| aDirectoryOrNil parcelOrPundle directories found |	aDirectoryOrNil := aPundle ifNotNil: [aPundle streamDirectory].	(parcelOrPundle := self parcelOrPundleNamed: parcelName) ifNotNil:		[(aPundle isNil or: [aPundle checkPrerequisiteNamed: parcelName withVersion: parcelOrPundle traceVersion requiredVersion: versionString])			ifFalse: [CodeReader incompatibleVersionIdSignal raiseRequestWith: (Array with: parcelName with: versionString)].		^parcelOrPundle].	directories := OrderedCollection withAll: self searchPathModel value.		aDirectoryOrNil notNil ifTrue: [directories addLast: aDirectoryOrNil asLogicalFileSpecification].	Parcel parcelFileDirectoryCache removeKey: directories last asResolvedString ifAbsent: [nil].	directories addLast: Filename currentDirectory.	Parcel parcelFileDirectoryCache removeKey: directories last asResolvedString ifAbsent: [nil].	found := false.	1 to: directories size do:		[:index | 		| directoryName directory |		directoryName := directories at: index.		directory := (directoryName asString = Filename defaultClass currentDirectoryString and: [index &lt; directories size]) 			ifTrue: [aDirectoryOrNil] 			ifFalse: [directoryName].		directory ifNotNil:			[self				cachedParcelFileInfoIn: directory asLogicalFileSpecification				for: parcelName				do:					[:info :filename | 					found := found or: [parcelName = (info at: #parcel)].					(parcelName = (info at: #parcel) and: [aPundle isNil or: [aPundle checkPrerequisiteNamed: parcelName withVersion: (info at: #version ifAbsent: ['']) requiredVersion: versionString]])						ifTrue:							[Transcript cr; show: (#autoloadParcelFrom &lt;&lt; #dialogs &gt;&gt; 'Autoloading &lt;1s&gt; from &lt;2s&gt;' expandMacrosWith: parcelName with: filename asString).							^aCompilationManagerOrNil isNil								ifTrue: [self loadParcelCachedFrom: filename]								ifFalse: [self loadParcelCachedFrom: filename with: aCompilationManagerOrNil]]]]].	found ifTrue: [CodeReader incompatibleVersionIdSignal raiseRequestWith: (Array with: parcelName with: versionString)].	^Parcel missingParcelSignal raiseRequestWith: parcelName</body><body package="Atomic Compiling and Loading">loadParcelCachedFrom: aStringOrFilename with: aCompilationManagerOrNil	"Load the required parcel, using the info cache to locate the parcel and any prerequisites.	First see if this parcel is already in the process of being loaded.	If the parcel is being reloaded loadFrom: will return the old parcel."	| loadedParcel loadTag |	loadedParcel := QueryNotification newSignal		parameter: (loadTag := #parcel -&gt; aStringOrFilename asString);		valueWithDefault: [nil].	loadedParcel notNil ifTrue: [^loadedParcel].	aCompilationManagerOrNil ifNotNil: [aCompilationManagerOrNil installEarlyWith: aCompilationManagerOrNil].	loadedParcel := self new.	[	loadedParcel startLoad.		[[loadedParcel := loadedParcel loadFrom: aStringOrFilename with: aCompilationManagerOrNil]			on: QueryNotification			do: 				[:exception|				loadTag = exception parameter ifTrue: [exception resume: loadedParcel].				exception pass].		self replaceParcel: loadedParcel]					on: self abortedActionSignal					do: 						[:exception|						(exception parameter size &lt; 4 or: [(exception parameter at: 4) ~~ #silent]) 							ifTrue: [Dialog warn: exception errorString].						exception parameter first isNil ifFalse: [exception parameter first unload].						^nil].		self loadUninstalledCodePostLoadOf: loadedParcel]							ensure: [loadedParcel endLoad].	^loadedParcel</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>creating subclasses</category><body package="Atomic Compiling and Loading">shadowLoadSubclass: t includeFiles: if includeDirectories: id libraryFiles: lf libraryDirectories: ld generateMethods: gm beVirtual: bv optimizationLevel: optLevel instanceVariableNames: f classVariableNames: d poolDictionaries: pd category: cat	"This is the enhanced initialization message for creating a new class as a subclass of the receiver.  Answer the new subclass."	| attrs theClass |	attrs := OrderedCollection new			add: (Array with: #includeFiles with: if);			add: (Array with: #includeDirectories with: id);			add: (Array with: #libraryFiles with: lf);			add: (Array with: #libraryDirectories with: ld);			add: (Array with: #beVirtual with: bv);			add: (Array with: #optimizationLevel with: optLevel);			asArray.	theClass := self classBuilder		superclass: self fullyQualifiedReference;		environment: Smalltalk;		className: ((SystemUtils validateClassName: t for: nil) ifNil: [^nil]);		instVarString: f;		classVarString: d;		poolString: pd;		attributes: attrs;		category: cat;		beFixed;		reviseSystemForAtomicCompiling.	^theClass</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>subclass creation</category><body package="Atomic Compiling and Loading">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a subclass of an existing class (the receiver).  Use default values for arguments supported by the receiver not specified by this message."	^self		subclass: t		includeFiles: ''		includeDirectories: ''		libraryFiles: ''		libraryDirectories: ''		generateMethods: ''		beVirtual: false		optimizationLevel: self defaultOptimizationLevel		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating method dictionary</category><body package="Atomic Compiling and Loading">addSelectorForShadow: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method	to the receiver's method dictionary 	but do not send #instanceMethodsChanged to the class if the method has attributes."	| method |	method := self validateMethod: compiledMethod forSelector: selector.	methodDict at: selector put: method.	self flushVMmethodCacheEntriesFor: selector.</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing shadow compilation</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	"Are we part of the real system, or of a shaow namespace. For anonymous behaviors, we assert that they are in the standard environment, since they don't really exist in a namespace."	^true.</body></methods><methods><class-id>Core.Behavior</class-id> <category>compiling</category><body package="Atomic Compiling and Loading">recompileForSunshine: selector from: oldClass	"Recompile the method associated with selector in the receiver's method dictionary.	Take care not to write out any new source code - just generate new bytes.	oldClass may differ from self in order to decompile right (if sourceFiles == nil)	when adding or removing fields of a class."	self recompileForSunshine: selector from: oldClass in: nil.</body><body package="Atomic Compiling and Loading">recompileForSunshine: selector from: oldClass in: aNamespace	"Recompile the method associated with selector in the receiver's method dictionary.	Take care not to write out any new source code - just generate new bytes.	oldClass may differ from self in order to decompile right (if sourceFiles == nil)	when adding or removing fields of a class.	Whereas we are compiling in sunshine, we don't want to force the instanceBehaviorChange at this time	by calling addSelector:withMethod: "		| method methodNode sourcePointer compiler |	method := oldClass compiledMethodAt: selector.	sourcePointer := method sourcePointer.	compiler := (self isMeta ifTrue: [self instanceBehavior classCompilerClass] ifFalse: [self compilerClass]) new.	compiler environment: aNamespace.	methodNode := compiler		compile: (oldClass sourceCodeAt: selector)		in: self		notifying: nil		ifFail: [self error: #errFailureWhileRecompiling &lt;&lt; #dialogs &gt;&gt; 'Failure during recompiling method'].	methodNode == nil ifTrue: [^self recompileForSunshine: selector in: aNamespace].	"Try again after proceed from SyntaxError"	method := methodNode generate.	method sourcePointer: sourcePointer.	self addSelectorForShadow: selector withMethod: method</body><body package="Atomic Compiling and Loading">recompileForSunshine: selector in: aNamespace	"Recompile the method associated with selector in the receiver's method dictionary.	Take care not to write out any new source code - just generate new bytes.	It's possible that we won't be able to recompile, e.g. if it's a DLL/CC method, and the DLL/CC compiler is not available. If so, we'll get a SyntaxErrorException. Since we know the method compiled previously, assume that means a missing compiler, and just leave the method as is."	^[self recompileForSunshine: selector from: self in: aNamespace]		on: SyntaxErrorException		do: [:ex | ex return: (self compiledMethodAt: selector)].</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing shadow compilation</category><body package="Atomic Compiling and Loading">standardEnvironmentClass	"The receiver is assumed to exist in a shadow namespace created by the shadow compliation system.	 If the receiver is shadowing a class from the system, return that class it shadows.  Otherwise return	 nil.  The shadow compliation system is expected to know how to treat nil."		| realClass |	self residesInStandardEnvironment ifTrue: [^self].	realClass := self absoluteName asClassNameOnly asStrictReference		ifDefinedDo: [:value | value]		elseDo: [^nil].	^self isMeta		ifTrue: [realClass class]		ifFalse: [realClass]</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	^true</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>class creation</category><body package="Atomic Compiling and Loading">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a subclass	of nil (UndefinedObject)."	| approved builder |	ClassBuilder nilSuperclassSignal raiseRequest.	approved := SystemUtils validateClassName: t for: nil.	approved ifNil: [^self].	builder := self class classBuilder addRecord: (BehaviorBuilderRecord forName: approved in: Smalltalk).	^builder		superclass: self;		instVarString: f;		classVarString: d;		poolString: s;		category: cat;		beFixed;		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading">shadowLoadVariableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as asubclass	of an existing class (the receiver) in which the subclass is to have indexable	byte-sized nonpointer variables."	| approved |	ClassBuilder nilSuperclassSignal raiseRequest.	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^self].	^self class classBuilder		superclass: self;		environment: Smalltalk;		className: approved;		instVarString: f;		classVarString: d;		poolString: s;		category: cat;		beBytes;		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading">shadowLoadVariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a subclass	of an existing class (the receiver) in which the subclass is to have indexable	pointer variables."	| approved |	ClassBuilder nilSuperclassSignal raiseRequest.	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^self].	^self class classBuilder		superclass: self;		environment: Smalltalk;		className: approved;		instVarString: f;		classVarString: d;		poolString: s;		category: cat;		beVariable;		reviseSystemForAtomicCompiling</body></methods><methods><class-id>Kernel.BindingReference</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	"Return a boolean indicating whether the receiver actually lives in the system."	| myParent |	myParent := self environment == nil 		ifTrue: [ environment ]		ifFalse:  [ self environment ].	[ myParent environment == nil ] 		whileFalse: [myParent := myParent environment].	^myParent == Root</body></methods><methods><class-id>Kernel.BindingReference</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading">redirectInstallTo: mgr	^mgr installSharedBinding: self.</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>linking</category><body package="Atomic Compiling and Loading">quietlyEnsureName: newName in: aNameSpace	"The binding is assumed to be new--i.e., it does not exist in	any NameSpace. Add it to Undeclared."	| new old |	(aNameSpace asNameSpace includesKey: newName)		ifTrue: [^aNameSpace bindingFor: newName].	new := aNameSpace asNameSpace createKey: newName value: nil.	(old := Undeclared bindingFor: newName) notNil		ifTrue: [new value: old value].	aNameSpace asNameSpace simpleAddBinding: new.	^new</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>definition</category><body package="Atomic Compiling and Loading">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: #()</body><body package="Atomic Compiling and Loading">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: attributes		recordIn: #()</body><body package="Atomic Compiling and Loading">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes recordIn: logNames	"Unlike our not shadowLoad... cousins, we don't touch change sets or try to push ourselves into the file manager.	We're quiet that way, and must be because we're just compiling in the shadow world, not installing.	The resulting object will be put into the appropriate change set and written to the file manager when it is (later) installed"	| targetSelf approved initializer variableBinding bindingReference |	targetSelf := self residesInStandardEnvironment		ifTrue: [(SharedNeedsShadowRoot raiseSignal shadowAt: self absoluteReference path) ifNil: [self]]		ifFalse: [self].	(self isKindOf: NameSpaceOfClass) ifTrue: [targetSelf := targetSelf asNameSpace].	targetSelf checkInstalled.	(approved := SystemUtils validateStaticVariableName: varName for: nil) ifNil: [^nil].	initString ifNotNil:		[initializer := targetSelf compileInitializer: initString.		initializer method sourcePointer: initString].	(targetSelf includesKey: approved) ifTrue:		[variableBinding := targetSelf bindingFor: approved.		variableBinding isForGeneral ifFalse:			[| errorMessage |			errorMessage := (#errGeneralVariable &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; exists but is not a general variable. It must be removed from the NameSpace &lt;2p&gt; before this definition can be accepted.')				expandMacrosWith: approved 				with: targetSelf.			targetSelf class failureSignal raiseWith: approved errorString: errorMessage]].	variableBinding isNil		ifTrue:			[variableBinding := SystemUtils ensureName: approved in: targetSelf.			variableBinding forGeneral]		ifFalse: [RedefinitionNotification redefinedBinding: variableBinding in: targetSelf attributes: attributes].	(targetSelf organization notNil and: [newCategory notNil]) ifTrue: 		[targetSelf organization classify: approved under: newCategory asSymbol].	variableBinding bePrivate: isPrivate.	variableBinding beStaticallyDefined: initString notNil.	variableBinding initializer: initializer.	variableBinding beConstant: isConstant.	bindingReference := (BindingReference simpleName: variableBinding key) home: targetSelf namedReferent.	^bindingReference</body><body package="Atomic Compiling and Loading">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	"Backward compatibility."	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: #()</body><body package="Atomic Compiling and Loading">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: aCollection	"Backward compatibility."	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: aCollection</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isCompilationResult	^false</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>atomic loading</category><body package="Atomic Compiling and Loading">queryAtomicallyLoaded: aParcelName ifPreviouslyLoadedAndOK: anUpdateBlock ifFail: aFailBlock	"Check if the receiver is already loaded and if so, take whatever error actions are required and 	 evaluate aBlock with the error value, which will probably be derived from some exception handler."		| parcelOrPundle |	parcelOrPundle := self class parcelOrPundleNamed: aParcelName.	parcelOrPundle isNil ifTrue: [^self].	parcelOrPundle isLoaded ifFalse: [^self].	^(Parcel parcelAlreadyLoadedSignal raiseRequestWith: aParcelName)		ifTrue: [anUpdateBlock value: parcelOrPundle asParcel]		ifFalse:			[aFailBlock value:				(self class abortedActionSignal					raiseRequestWith: (Array with: self with: aParcelName with: #parcelAlreadyLoaded &lt;&lt; #dialogs &gt;&gt; 'Parcel already loaded' with: #silent)					errorString: #loadAborted &lt;&lt; #dialogs &gt;&gt; 'Parcel load aborted')]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>actions</category><body package="Atomic Compiling and Loading">recompileExtensionsForSunshine	"I don't do this, but subclasses might"	^self</body><body package="Atomic Compiling and Loading">runComponentPostLoad	"Run the postLoad code for the receiver. "		| loadBlock |	(loadBlock := self postLoadBlock) ifNil: [^true].	self recompileExtensions.	[loadBlock value: self]		on: Error		do: 			[:exception | 			(Store.LoadingActionError pundle: self action: #postLoad error: exception) ifFalse: [^false]].	^true</body></methods><methods><class-id>Kernel.ClassBuilder</class-id> <category>private</category><body package="Atomic Compiling and Loading">reviseSystemForAtomicCompiling	| cls |	records do: [:each | each redefinitionCheck].	cls := self reviseSystemSilently.	cls relocateImportsToShadow.	^cls</body></methods><methods><class-id>Kernel.NameSpaceOfClass</class-id> <category>testing</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	^self owner isInStandardEnvironment</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	"Return a boolean indicating whether the receiver actually lives in the system."	| myEnvironment |	myEnvironment := self environment == nil ifTrue: [self] ifFalse: [self environment].	[myEnvironment environment == nil] whileFalse: 		[myEnvironment := myEnvironment environment].	^myEnvironment == Root</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing-store shadow compilation</category><body package="Atomic Compiling and Loading">mergeDeeplyFrom: aShadowEnvironment	aShadowEnvironment keys do: 		[:each | 		(self at: each ifAbsent: [nil]) isNil 			ifTrue: [self at: each put: (aShadowEnvironment at: each)] 			ifFalse:				[((self at: each) isForNameSpace and: [(aShadowEnvironment at: each) isForNameSpace]) ifTrue: 					[(self at: each) mergeDeeplyFrom: (aShadowEnvironment at: each)]]]</body><body package="Atomic Compiling and Loading">mergeDeeplyFrom: aShadowEnvironment butNot: aSet	aShadowEnvironment keys do: 		[:each | 		(self at: each ifAbsent: [nil]) isNil 			ifTrue: [(aShadowEnvironment at: each) ifNotNil: [:value | self at: each put: value]]			ifFalse:				[((aSet includes: each) not and: [(self at: each) isForNameSpace and: [(aShadowEnvironment at: each) isForNameSpace]]) ifTrue: 					[aSet add: each.					(self at: each) mergeDeeplyFrom: (aShadowEnvironment at: each) butNot: aSet]]]</body><body package="Atomic Compiling and Loading">reallyFullyQualifiedReference	| mySmalltalk |	mySmalltalk := self.	mySmalltalk environment == nil 		ifTrue: [^self fullyQualifiedReferenceFrom: mySmalltalk].	[  ( mySmalltalk environment == nil ) | ( mySmalltalk = Smalltalk ) ]		whileFalse: [mySmalltalk := mySmalltalk environment].	^self fullyQualifiedReferenceFrom: mySmalltalk	"FileTools fullyQualifiedReference"	"FileTools fullyQualifiedReferenceFrom: Smalltalk"	"FileTools fullyQualifiedReferenceFrom: FileTools environment"	"FileTools reallyFullyQualifiedReference"	"FileTools fullyQualifiedReferenceFrom: Smalltalk"	"FileTools fullyQualifiedReferenceFrom: FileTools environment"</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading">redirectInstallTo: mgr	^mgr installNameSpace: self.</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="Atomic Compiling and Loading">shadowLoadDefineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category	^self shadowLoadDefineClass: className		superclass: superID		indexedType: typeName		private: isPrivate		instanceVariableNames: iVars		classInstanceVariableNames: ciVars		imports: pools		category: category		attributes: #( )</body><body package="Atomic Compiling and Loading">shadowLoadDefineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes	"In the Shadow world, we don't care if the binding is constant"	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding value isBehavior]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystemForAtomicCompiling.	^class</body><body package="Atomic Compiling and Loading">shadowLoadDefineNameSpace: poolName private: isPrivate imports: importString category: newCategory	^self shadowLoadDefineNameSpace: poolName		private: isPrivate		imports: importString		category: newCategory		attributes: #()</body><body package="Atomic Compiling and Loading">shadowLoadDefineNameSpace: poolName private: isPrivate imports: importString category: newCategory attributes: attributes		| newNamespace approved isNew |	approved := SystemUtils validateStaticVariableName: poolName for: nil.	approved == nil ifTrue: [^nil].	(self includesKey: approved)		ifTrue:			[| which |			which := self bindingFor: approved.			(which value class == self class and: [which isForNameSpace])				ifTrue: [newNamespace := which value]				ifFalse:					[| errorMessage |					newNamespace := nil.					errorMessage := #errIsNotNameSpace &lt;&lt; #dialogs &gt;&gt;							'&lt;1s&gt; is a global but is not an existing NameSpace. It must be removed from the NameSpace &lt;2p&gt; before this definition can be accepted.'						expandMacrosWith: approved with: self.					self class failureSignal raiseWith: approved errorString: errorMessage]]		ifFalse: [newNamespace := nil].	(isNew := newNamespace == nil)		ifTrue:			[| newVariableBinding |			newNamespace := self class new.			newNamespace name: approved.			newNamespace environment: self.			newVariableBinding := SystemUtils				quietlyEnsureName: newNamespace name				in: self.			newVariableBinding setValue: newNamespace.			newVariableBinding forNameSpace]		ifFalse:			[RedefinitionNotification redefinedNameSpace: newNamespace attributes: attributes].	self organization == nil		ifFalse:			[self organization				classify: approved				under: newCategory asSymbol].	newNamespace imports: importString.	newNamespace reallyFullyQualifiedReference binding bePrivate: isPrivate.	newNamespace residesInStandardEnvironment ifTrue:		[isNew			ifTrue: [ChangeSet addNameSpace: newNamespace attributes: attributes]			ifFalse: [ChangeSet changeNameSpace: newNamespace attributes: attributes]].	newNamespace fileOutDefinitionOn: SourceFileManager default.	^newNamespace</body><body package="Atomic Compiling and Loading">shadowLoadDefinitionMessage		| argumentStream extraAttributes selector |	argumentStream := (Array new: 5) writeStream.	argumentStream		nextPut: self name;		nextPut: (self environment isNil			ifTrue: [self fullyQualifiedReference binding isPrivate]			ifFalse: [(self environment bindingFor: self name) isPrivate]);		nextPut: self importString;		nextPut: self category asString.	extraAttributes := self extraAttributesForDefinition.	extraAttributes isEmpty		ifTrue: [selector := #shadowLoadDefineNameSpace:private:imports:category:]		ifFalse:			[selector := #shadowLoadDefineNameSpace:private:imports:category:attributes:.			argumentStream nextPut: extraAttributes].	^MessageSend		receiver: self environment		selector: selector		arguments: argumentStream contents</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading">isInStandardEnvironment	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>changes</category><body package="Atomic Compiling and Loading">recompileExtensionsForSunshine	"Our compilation scope has changed. Recompile any extension methods which may be affected"		self extensionsDo:		[:eachClass :eachSelector | 		| method |		method := eachClass compiledMethodAt: eachSelector.		((method isKindOf: ExternalMethod) not and: [(method mclass instanceBehavior includesBehavior: ExternalInterface) not])			ifTrue: [eachClass recompileForSunshine: eachSelector in: (self environmentFor: eachSelector in: eachClass)]]</body><body package="Atomic Compiling and Loading">recompileOverrideAffectedMethods	| affectedClasses |	affectedClasses := self allClasses select: [:each | Override inheritsFromOverriddenClass: each value].	affectedClasses := affectedClasses collect: [:each | each value].	affectedClasses := SystemUtils sortForLoading: affectedClasses.	affectedClasses do: [:each | each selectors do: [:eachSelector | each recompile: eachSelector]]</body><body package="Atomic Compiling and Loading">recompileSunshineMethodsFor: aClass	"Our compilation scope has changed. Recompile any methods which may be affected."		| environment realClass |	realClass := aClass isBehavior		ifTrue: [aClass instanceBehavior]		ifFalse: [aClass actualClass instanceBehavior].	environment := (self includesDefinitionOf: realClass absoluteName)		ifTrue: [nil]		ifFalse: [self environment].	self methodsFor: aClass do:		[:eachClass :eachSelector | 		eachClass recompileForSunshine: eachSelector in: environment]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change management</category><body package="Atomic Compiling and Loading">removeDeletedDefinitions: packageDifferences	"Using packageDifferences, adjust the receiver so that those definitions are removed are removed 	 in such a way that any overrides are restored.  This is used by the shadow loading system."		packageDifferences methodsToRemoveAfterLoad do:		[:each | Override unloadSelector: each selector class: each correspondingImageClass from: self logged: true].	packageDifferences sharedsToRemoveAfterLoad do:		[:each | Override unloadStatic: each in: each owner from: self logged: #(#changes #file)].	packageDifferences sortedClassesToRemoveAfterLoad , packageDifferences nameSpacesToRemoveAfterLoad do:		[:each | Override unloadClassOrNameSpace: each actual from: self]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private</category><body package="Atomic Compiling and Loading">basicClasses	^classes</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>testing</category><body package="Atomic Compiling and Loading">installed	^self isLoaded</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading">redirectInstallTo: mgr	^mgr installMethod: self.</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI">isPundleEnvironemt	^false</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>printing</category><body package="StoreForGlorpVWUI">definitionString	^self definition</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>testing</category><body package="StoreForGlorpVWUI">isExtension	^false</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">longName	^self absoluteName</body><body package="StoreForGlorpVWUI">shortItemString	^self name</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>converting</category><body package="StoreForGlorpVWUI">allStoreVersions	| session |	^[(Store.Gathering for: self selector asString) started.		session := Store.Glorp.StoreLoginFactory currentStoreSession.	Store.Glorp.StoreMethodInPackage		allVersionsWithName: self selector asString		inClass: self implementingClass absoluteName		in: session] 			ensure: [(Store.Gathering for: self selector asString) finished]</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>instance creation</category><body package="StoreForGlorpVWUI">emptyPundleFrom: aStorePundle	| instance |	instance := self named: aStorePundle name.	Store.ReconcilingComparitor reconcile: instance against: aStorePundle.	aStorePundle applyPundleVersionsToTheImage: false.	^instance</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">allStoreVersions	^[(Gathering for: self name) started.		self storeForGlorpPundleClass allVersionsInitiallyNamed: self name]		ensure: [(Gathering for: self name) finished]</body><body package="StoreForGlorpVWUI">allStoreVersionsIn: aSession	^[(Gathering for: self name) started.		self storeForGlorpPundleClass allVersionsInitiallyNamed: self name in: aSession]		ensure: [(Gathering for: self name) finished]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStorePundle		| session storePundle |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	storePundle := self asStorePundleEvenIfModifiedIn: session.	^storePundle</body><body package="StoreForGlorpVWUI">asStorePundleEvenIfModifiedIn: aGlorpSession		| storePundle dbName info session |	session := aGlorpSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	dbName := session databaseIdentifier.	info := dbInfo		at: dbName		ifAbsent: [nil].	(info notNil and: [info dbTrace notNil])		ifTrue:			[storePundle := session				readOneOf: self storeForGlorpPundleClass				where: [:each | each primaryKey = info dbTrace]].	^storePundle</body><body package="StoreForGlorpVWUI">asStorePundleFromCache	| cache session |	session := (cache := self storeForGlorpPundleClass cache) notEmpty 		ifTrue: [cache any session]		ifFalse: [Store.Glorp.StoreLoginFactory currentStoreSession].	^self storeForGlorpPundleClass cachedItemFor: (self asStorePundleIn: session)</body><body package="StoreForGlorpVWUI">asStorePundleIn: aGlorpSession	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"	| session |	session := aGlorpSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	^self		asStorePundleIn: session		returnOriginalIfUnmodified: true		includeUninstalled: true.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="StoreForGlorpVWUI">continueToReconcile	^ReconcileWarning raiseSignal: ((#x1sIsNotLinkedToDatabaseReconcileQ &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not linked to the current database.&lt;n&gt;It cannot be loaded until it has been reconciled.&lt;n&gt;Do you want to do that now?') 		expandMacrosWith: self name)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">dbTrace: anInteger for: databaseId	"Answer the db parent id for the specified database, nil if none."	| info |	^( info := self databaseInformationFor: databaseId ) == nil		ifFalse: [ info dbTrace: anInteger ].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="StoreForGlorpVWUI">emptyChangeSetFor: aDatabaseIdentifier	"Empty the currently active ChangeSet."	| info |	( info := self databaseInformationFor: aDatabaseIdentifier ) == nil		ifFalse: 			[ self updateAfterDo:  				[ info emptyChangeSet ]			]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI">glorpReconciledVersion	^self glorpReconciledVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession.</body><body package="StoreForGlorpVWUI">glorpReconciledVersionFrom: aPundle	self databaseInformation isNil ifTrue:		[self continueToReconcile ifFalse: [^nil].		self isBundle			ifTrue: [self allItems do: [:each | each setNoTrace]]			ifFalse: [self setNoTrace].		self reconcileWithDb: aPundle].	^self canReplaceVersions ifTrue:		[aPundle ifNotNil: [aPundle asStorePundle]]</body><body package="StoreForGlorpVWUI">glorpReconciledVersionIn: aSession	| dbSelection |	dbSelection := self databaseInformation isNil		ifFalse: [self selectStoreVersion]		ifTrue: [self continueToReconcile ifTrue: [self reconcileWithDb]].	^dbSelection ifNotNil:		[(dbSelection isBundle or: [self canReplaceVersions]) ifTrue:			[dbSelection asStorePundleIn: aSession]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>public-change set access</category><body package="StoreForGlorpVWUI">markNotModifiedFor: aDatabaseIdentifier	self shouldTrackChanges 		ifTrue: [ self emptyChangeSetFor: aDatabaseIdentifier ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="StoreForGlorpVWUI">mergeItemString	^self itemString , ' [Image]'</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">pundle	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="StoreForGlorpVWUI">selectStoreVersion 	"Answer the user selected published version of the receiver.	nil if none."	^self selectStoreVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession.</body><body package="StoreForGlorpVWUI">selectStoreVersionIn: aSession	"Answer the user selected published version of the receiver.	nil if none."	^self class storeDatabaseClass selectStoreVersionOf: self name in: aSession</body><body package="StoreForGlorpVWUI">selectStoreVersionIn: aSession warnIfNone: aBoolean	"Answer the user selected published version of the receiver.	nil if none."	^self class storeDatabaseClass selectStoreVersionOf: self name in: aSession warnIfNone: aBoolean</body><body package="StoreForGlorpVWUI">selectStoreVersionWarnIfNone: aBoolean	"Answer the user selected published version of the receiver.	nil if none."	^self selectStoreVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession warnIfNone: aBoolean</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">session	"This for being compatable with StorePundle objects"	^nil</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI">storeTracePackage	| storePundle session |	#{Store.DbRegistry}		ifDefinedDo:			[:registry | 			(registry notNil and: [registry isOnline]) ifFalse: [^nil]]		elseDo: [^nil].	self dbTrace ifNil: [^nil].	(self dbIdentifier notNil and: [self dbIdentifier = Store.DbRegistry dbIdentifier]) ifFalse: [^nil].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	storePundle := session		readOneOf: self storeForGlorpPundleClass		where: [:each | each primaryKey = self dbTrace].	^storePundle</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI">stripIgnorablePropertiesToMatch: aVersion	"Remove from ourselves any of the properties that we probably got from a parcel. Makes comparing to the database simpler."	Store.Glorp.StorePundle new ignorableProperties		do: [:each | self propertyAt: each put: (aVersion propertyAt: each ifAbsent: [nil])].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">withAllItems	^Array with: self</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>definition</category><body package="StoreForGlorpVWUI">asString	^self absoluteName</body><body package="StoreForGlorpVWUI">definitionString	^self definition</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>testing</category><body package="StoreForGlorpVWUI">isForClassOrExtension	^self isForClass</body><body package="StoreForGlorpVWUI">isForSharedVariable	^false</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>definition</category><body package="StoreForGlorpVWUI">longName	^self absoluteName</body><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^(self fullyQualifiedReferenceFrom: Smalltalk) asString</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI">computeDifferencesBetween: aPackage into: aComparitor 	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[aComparitor reverse.	self computeDifferencesBetweenDBPackage: aPackage into: aComparitor]		ensure: [aComparitor reverse].	^aComparitor</body><body package="StoreForGlorpVWUI">computeDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Store  differences between receiver and a aDBPackage  into an instance of TT_PackageDifferences.	Store receiver's definitions as number-2 since this method is called with arguments reversed.	The comparison is done in two steps. First we compare, image with trace and then we compare trace	with aDBpackage and combine the restults.	If aDB package is a pseudo package use change set only"		| storePackageParent comparitorToParent |	aStorePackage pseudoPackage ifTrue: 		[^self computeFullDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor].	((self otherChangesInclude: self parentChangedMark) or: 		[(storePackageParent := self storeTracePackage) isNil or: 		[self userWantsFullCompare]]) ifTrue:			[^self computeFullDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor].	self changeSetDifferencesBetweenDBPackage: storePackageParent into: aPackageComparitor.	(aStorePackage sameAs: storePackageParent) ifTrue:		[^aPackageComparitor].	comparitorToParent := Store.PackageComparitor differencesBetween: aStorePackage and: storePackageParent.	aPackageComparitor combineDiffsFrom: comparitorToParent .	^aPackageComparitor</body><body package="StoreForGlorpVWUI">computeFullDifferencesBetweenDBPackage: aStorePackageOrPseudo into: aPackageComparitor	"Store general differences between receiver and a aDBPackage into aPackageComparitor	We turn everything into a StoreObject which does the trick when we do removes of comparing the right things"		aPackageComparitor extractFullMethodDifferencesBetween: self and: aStorePackageOrPseudo.	aPackageComparitor extractFullSharedVariableDifferencesBetween: self and: aStorePackageOrPseudo.	aPackageComparitor extractFullNameSpaceDifferencesBetween: self and: aStorePackageOrPseudo.	aPackageComparitor extractFullClassDefinitionDifferencesBetween: self and: aStorePackageOrPseudo.	self computeOverrideDiffsBetweenDBPackage: aStorePackageOrPseudo into: aPackageComparitor.	^aPackageComparitor</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">definedObjectNamed: aString	| target |	target := self modelAtName: aString ifAbsent: [^nil].	^target isExtension ifTrue: [nil] ifFalse: [target actual]</body><body package="StoreForGlorpVWUI">objectNamed: aString	| target |	target := self modelAtName: aString ifAbsent: [^nil].	^target actual</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="StoreForGlorpVWUI">asStoreMethodDefinition	| method |	method := Store.Glorp.StoreMethod new name: self selector asString.	method className: self classNameWithMeta.	method isMetaclass: self isMeta.	method basicSource: (Glorp.AdHocProxy readBlock: [Store.Glorp.StoreBlob forString: self sourceCode asString]).	method protocol: self protocol asString.	method setCTypeForPre77StoreFrom: definition.	^method.</body><body package="StoreForGlorpVWUI">asText	^self text asText.</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">classNameWithoutMeta	"6 is the size of the text ' class'... Not a magic number"		^self isMeta		ifTrue: [self absoluteClassName copyFrom: 1 to: self absoluteClassName size - 6]		ifFalse: [self absoluteClassName]</body><body package="StoreForGlorpVWUI">correspondingImageClass	^self method mclass</body><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^self implementingClass longNameFromSmalltalk</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI">allStoreVersions	^[(Gathering for: self name) started.		Store.Glorp.StoreNamespaceInPackage allVersionsWithName: self name inOwner: self environmentString]		ensure: [(Gathering for: self name) finished]</body><body package="StoreForGlorpVWUI">asStoreNameSpace	| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	namespace environmentName: self environmentString.	namespace definition: self actual definition. 	(self actual comment notNil and: [self actual comment notEmpty]) ifTrue: 		[namespace comment: self actual comment asString].	^namespace.</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI">allStoreVersions	^[(Gathering for: self name) started.		Store.Glorp.StoreClassDefinitionInPackage allVersionsWithName: self name inOwner: self actualClass environment absoluteName]		ensure: [(Gathering for: self name) finished]</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>testing</category><body package="StoreForGlorpVWUI">isForClassOrExtension	^true</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI">asStoreMethodDefinition	| method |	method := self asStoreMethodDefinitionWithoutProtocol.	method protocol: (self mclass organization categoryOfItem: self selector).	^method.</body><body package="StoreForGlorpVWUI">asStoreMethodDefinitionWithoutProtocol	"We fix the class name for absent class imports, for which absoluteName doesn't include the 'class' portion"		| method |	method := Store.Glorp.StoreMethod new name: self selector asString.	method className: self mclass absoluteName asString.	(mclass isMeta and: [(method classNameWithMeta last: (6 min: method classNameWithMeta size)) ~= ' class'])		ifTrue: [method className: method classNameWithMeta , ' class'].	method isMetaclass: mclass isMeta.	method basicSource: (Glorp.AdHocProxy readBlock: [Store.Glorp.StoreBlob forString: self getSource asString]).	method setCTypeForPre77StoreFrom: self.	^method</body><body package="StoreForGlorpVWUI">correspondingImageMethod	^self</body></methods><methods><class-id>Tools.MethodInstallationRecord</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI">asStoreMethodDefinition	| storeGlorpMethod |	storeGlorpMethod := method asStoreMethodDefinitionWithoutProtocol.	storeGlorpMethod name: self selector asString.	storeGlorpMethod protocol: self protocol asString.	^storeGlorpMethod.</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>store-packages</category><body package="StoreForGlorpVWUI">fileOutDifferencesBetween: aPundle and: anotherPundle	"File out code that would convert aPundle into anotherPundle if it were filed into an image with aPundle loaded.  This ordering reflects the general pattern that the parameter of the 'Between:' selector is the start point with the end point, whose code if different is filed-out, being either the receiver or another selector's parameter."		| fileName session |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: aPundle name)).	session := Store.Glorp.StoreLoginFactory currentStoreSession.	fileName isEmpty ifTrue: [^nil].	Store.StoreProgressOverlay		subsume: builder window		while:			[(Store.FilingOut for: aPundle) started.			aPundle isPackage 				ifTrue: [Store.Glorp.DefinitionsForListPane fileOutDifferencesBetweenPackage: aPundle and: anotherPundle into: fileName using: session]				ifFalse: [Store.Glorp.DefinitionsForListPane fileOutDifferencesBetweenBundle: aPundle and: anotherPundle into: fileName using: session].			(Store.FilingOut for: aPundle) finished]</body><body package="StoreForGlorpVWUI">publishStorePundles	Undeclared purgeUnusedBindings.	self pundles do: 		[:each | 		each isBundle 			ifTrue: 				[each removeNonexistentComponentsRecursive.				each leafItems do: #removeEmptyModels]			ifFalse: [each removeEmptyModels]].	Store.PublishPundlesDialog publishPundles: self pundles</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>actions</category><body package="StoreForGlorpVWUI">storeClassChanges	| pundles pundleNames methodsInPackage session classes classNames differentMethods uniqueThings moreGroup final |	classes := self selectedClasses.	pundles := Set new.	classes do: 		[:each | pundles addAll: (Store.Registry packagesContaining: each)].	pundles isEmpty ifTrue: [^self].		[(Store.Gathering for: classes first longNameFromSmalltalk) started.	session := Store.Glorp.StoreLoginFactory currentStoreSession.	pundleNames := pundles collect: [:each | each name].	classNames := classes collect: [:each | each absoluteName].	classNames addAll: (classes collect: [:each | each class absoluteName]).	methodsInPackage := session		read: Store.Glorp.StoreMethodInPackage		where:			[:eachMethod | 			((eachMethod definition className in: classNames)				&amp; (eachMethod package name in: pundleNames))].	differentMethods := OrderedCollection new.	differentMethods := methodsInPackage groupedBy: [:each | each signature].	uniqueThings := OrderedCollection new.	differentMethods do:		[:eachGroup |		eachGroup do:			[:eachMethod |			uniqueThings isEmpty 				ifTrue: [uniqueThings add: eachMethod]				ifFalse:					[uniqueThings 						detect: [:each | each definition definition = eachMethod definition definition]						ifNone: [uniqueThings add: eachMethod]]]].	moreGroup := uniqueThings groupedBy: [:each | each signature].	final := OrderedCollection new.	moreGroup do:		[:eachGroup | 		eachGroup size &gt; 1 ifTrue: [final addAll: eachGroup]].	(Store.Gathering for: classes first longNameFromSmalltalk) finished]			withStoreFeedbackOn: self mainWindow.	Store.Glorp.DefinitionForListTool forMethodChangesInClass: final</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="StoreForGlorpVWUI">asStoreSharedVariable	| sharedVariable |	sharedVariable := Store.Glorp.StoreSharedVariable new name: self name asString.	sharedVariable environmentName: self absoluteOwnerName.	sharedVariable definition: self definition.	sharedVariable protocol: self protocol asString.	sharedVariable isClassVariable: self isInClass.	^sharedVariable.</body></methods><methods><class-id>Core.Behavior</class-id> <category>testing</category><body package="StoreForGlorpVWUI">correspondingImageClass	^self</body><body package="StoreForGlorpVWUI">isForClassOrExtension	^self isForClass</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>private</category><body package="StoreForGlorpVWUI">definitionBrowserTool		^Store.Glorp.DefinitionForListTool</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-classes</category><body package="StoreForGlorpVWUI">storeBrowseClassVersions		self dbRegistry doIfOnlineImage: 		[[self definitionBrowserTool forClassesOrNameSpaces: self storeClass allStoreVersions] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-methods</category><body package="StoreForGlorpVWUI">storeBrowseMethodVersions		self dbRegistry doIfOnlineImage: 		[[self definitionBrowserTool forMethods: self definition allStoreVersions] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-packages</category><body package="StoreForGlorpVWUI">storeBrowsePundleVersions		| session |	self dbRegistry doIfOnlineImage: 		[[session := Store.Glorp.StoreLoginFactory currentStoreSession.		self pundles do: [:each | self definitionBrowserTool forPackages: (each allStoreVersionsIn: session)]] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-shared variables</category><body package="StoreForGlorpVWUI">storeBrowseSharedVariableVersions		self dbRegistry doIfOnlineImage: 		[[self definitionBrowserTool forSharedVariables: self definition allStoreVersions] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="StoreForGlorpVWUI">asStoreClassDefinitionWithMetaclass	"Convert this to a StoreForGlorp class definition, with appropriate metaclass. Note that these appear to be always for classes, never metaclasses. Return an array of the class and metaclass."	| cl metacl |	cl := self asStoreClassDefinition.	metacl := Store.Glorp.StoreClassDefinition new.	metacl name:  self name, ' class'.	metacl definition: 'self error: ''no metaclass def'''. "We don't have a way to get the metaclass definition from this without creating the class or faking it up. But since it isn't used anyway, just leave it blank."	metacl environmentName: self environment absoluteName.	metacl superclassName: (self superclass isNil ifTrue: [nil] ifFalse: [self superclass class absoluteName]).	^Array with: cl with: metacl.</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">classNameWithMeta	^self implementingClass absoluteName.</body></methods><methods><class-id>Glorp.CannotFindSession</class-id> <category>private - actions</category><body package="StoreForGlorpVWUI">defaultAction	"What to do when the exception is unhandled.	 Users must still be able to catch this unhandled exception.	 Do not intercept with the immediate superclass extension method, but use the GenericException implementation."	^self noHandler</body></methods><methods><class-id>Tools.InitializerDefinition</class-id> <category>converting</category><body package="StoreForGlorpVWUI">allStoreVersions	| session |	^[(Store.Gathering for: self variableName asString) started.		session := Store.Glorp.StoreLoginFactory currentStoreSession.	Store.Glorp.StoreSharedVariableInPackage		allVersionsWithName: self variableName asString		inOwner: self classOrNameSpace absoluteName		in: session]		ensure: [(Store.Gathering for: self variableName asString) finished]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI">stripIgnorablePropertiesToMatch: aVersion	"Remove from ourselves any 'volatile' properties that we probably got from a parcel. Makes comparing to the database simpler."	super stripIgnorablePropertiesToMatch: aVersion.	self containedItems with: aVersion containedItems		do: [:each :eachVersion | each stripIgnorablePropertiesToMatch: eachVersion].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">withAllItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this 	bundle. 	The list preserves the bundle order. Put this bundle as a first item on the list."		| items |	items := OrderedCollection with: self.	self containedItems do: 		[:item | 		item isBundle 			ifTrue: [items addAll: item allItems] 			ifFalse: [items add: item]].	^items</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asComponentDescription	^self.</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="StoreForGlorpVWUI">asStoreNameSpace		| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	(self comment notNil and: [self comment notEmpty])		ifTrue: [namespace comment: self comment asString].	namespace definition: self definition.	self environment ifNotNil: [:value | namespace environmentName: value absoluteName].	^namespace</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI">asStoreNameSpace	| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	(self comment notNil and: [self comment notEmpty])		ifTrue: [namespace comment: self comment asString].	namespace definition: self definition.	self environment ifNotNil: [:value | namespace environmentName: value absoluteName].	^namespace.</body><body package="StoreForGlorpVWUI">correspondingImageNamespace	^self</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>aspects</category><body package="StoreForGlorpVWUI">ClassVersionsNavigatorPart	^partsDictionary at: #ClassVersionsNavigatorPart		ifAbsentPut: [parts add: (Store.Glorp.ClassVersionsNavigatorPart onNavigator: self)]</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>private</category><body package="StoreForGlorpVWUI">privateSetState: aNavigatorState	state := aNavigatorState.</body></methods><methods><class-id>Core.Metaclass</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI">asUninstalledStoreClassDefinition	| storeClassDefinition |	storeClassDefinition := self asStoreClassDefinition.	storeClassDefinition superclassName: (self absentSuperclassName).	^storeClassDefinition.</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^(self instanceBehavior fullyQualifiedReferenceFrom: Smalltalk) asString</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>printing</category><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^Store.Glorp.StoreSourceObject longNameFromSmalltalkUsing: self absoluteName</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStoreSharedVariable	| sharedVariable |	sharedVariable := Store.Glorp.StoreSharedVariable new name: self name asString.	sharedVariable environmentName: self environmentString.	sharedVariable definition: self definition.	sharedVariable protocol: (self protocol ifNil: ['']) asString.	sharedVariable isClassVariable: self isInClass.	^sharedVariable.</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>testing</category><body package="StoreForGlorpVWUI">isMeta 	"This can be called if an old class definition that defines a class variable is loaded from Store, and so the class var is converted to a shared variable in the class' namespace."	^className namesMetaClass</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>testing</category><body package="StoreForGlorpVWUI">isForClassOrExtension	^false</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>browser support</category><body package="StoreForGlorpVWUI">longName	^self absoluteName</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">fileOutObjectType	^#class</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStoreMethodDefinition	^Store.Glorp.StoreMethod newFromMethodDescriptor: self</body></methods><methods><class-id>Core.Class</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI">asStoreClassDefinitionWithMetaclass	"Convert this to a StoreForGlorp class definition, with appropriate metaclass. Return an array of the class and metaclass."	^Array with: self asStoreClassDefinition with: self class asStoreClassDefinition.</body><body package="StoreForGlorpVWUI">asUninstalledStoreClassDefinition	| storeClassDefinition |	storeClassDefinition := self asStoreClassDefinition.	storeClassDefinition superclassName: (self absentSuperclassName).	^storeClassDefinition.</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^(self fullyQualifiedReferenceFrom: Smalltalk) asString</body></methods><methods><class-id>Core.VariableBinding</class-id> <category>accessing</category><body package="StoreForGlorpVWUI">correspondingImageBinding	^self</body><body package="StoreForGlorpVWUI">correspondingImageSharedVariable	^self</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>converting</category><body package="StoreForGlorpVWUI">asStoreNameSpace	| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	(self comment notNil and: [self comment notEmpty])		ifTrue: [namespace comment: self comment asString].	namespace definition: self definition.	self environment ifNotNil: [:value | namespace environmentName: value absoluteName].	^namespace.</body></methods><methods><class-id>Kernel.Override</class-id> <category>printing</category><body package="StoreForGlorpVWUI">longNameFromSmalltalk	^(self fullyQualifiedReferenceFrom: Smalltalk) asString</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>actions</category><body package="Store-Difference Management">removeSelector: aSelectorName fromClassNamed: aString on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'remove-selector' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagForType: #class) value: aString.		str space.		xml on: str tag: 'selector' value: aSelectorName.		str cr]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Store-Difference Management">removeSelector: aSelectorName fromClassNamed: aString 	self noTargetForWrites ifTrue: [^self].	self targetFormatter 		removeSelector: aSelectorName		fromClassNamed: aString		on: self targetFile</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>actions</category><body package="Store-Difference Management">removeSelector: aSelectorName fromClassNamed: aString on: aStream	"Record on the stream that the given selector	has been removed from the class argument."	^self subclassResponsibility</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="Store-Difference Management">includesUninstalledMethod: aStoreMethodInPackage	"Answer true if the receiver contains a definition of aMethodDescriptor in a related parcel"	| relatedParcel |	relatedParcel := self relatedParcel ifNil: [^false].	relatedParcel uninstalledMethods		detect: 			[:each | 			each implementingClass absoluteName = aStoreMethodInPackage definition classNameWithoutMeta and:				[each implementingClass isMeta = aStoreMethodInPackage isMeta and:				[each selector = aStoreMethodInPackage selector and:				[each protocol = aStoreMethodInPackage protocol and: 				[each method getSource asString = aStoreMethodInPackage definition definition]]]]]		ifNone: [^false].	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Store-Difference Management">pseudoPundleClass	^Store.PseudoPackage</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing</category><body package="Store-Difference Management">propertiesWithoutVolatileKeys	"Answer a copy of the component's properties"	| propertiesCopy |	propertiesCopy := properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-Difference Management">pseudoPundleClass	^Store.PseudoBundle</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="Store-Difference Management">allPropertiesAndValuesIn: firstDictionary butNotIn: secondDictionary	| dictionary |	dictionary := Dictionary new.	firstDictionary notEmpty 		ifTrue: [			firstDictionary keysAndValuesDo: 				[:key :value | dictionary at: key put: key -&gt; value].			secondDictionary keysAndValuesDo: 				[:key :value | 					(dictionary at: key ifAbsent: [nil -&gt; nil]) value = value 						ifTrue: [							dictionary removeKey: key ifAbsent: []]]].	^dictionary</body><body package="Store-Difference Management">allPropertiesAndValuesInPundle: aPackageModelOrStorePackage butNotIn: anotherPackageModelStorePackage	^self		allPropertiesAndValuesIn: (aPackageModelOrStorePackage ifNil: [#()] ifNotNil: [aPackageModelOrStorePackage propertiesWithoutVolatileKeys])		butNotIn: (anotherPackageModelStorePackage ifNil: [#()] ifNotNil: [anotherPackageModelStorePackage propertiesWithoutVolatileKeys]).</body><body package="Store-Difference Management">computePropertyDifferencesBetween: aPundle into: aPackageComparitor 	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		self computePropertyDiffsBetweenDBPundle: aPundle into: aPackageComparitor.	^aPackageComparitor</body><body package="Store-Difference Management">computePropertyDiffsBetweenDBPundle: aStorePackage into: aPackageComparitor		aPackageComparitor mainPackageProperties: (self allPropertiesAndValuesInPundle: self butNotIn: aStorePackage).	aPackageComparitor otherPackageProperties: (self allPropertiesAndValuesInPundle: aStorePackage butNotIn: self).	^aPackageComparitor</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="Store-Difference Management">removeSelector: aSelectorName fromClassNamed: aString on: aStream		aStream		cr;		cr;		nextChunkPut: aString storeString , ' removeSelector: ' , aSelectorName storeString</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>copying</category><body package="Store-Merge Management">postCopy	redo := redo copy.	undo := undo copy.</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>merge support</category><body package="Store-Merge Management">privateGetUndo	^undo</body><body package="Store-Merge Management">resetFrom: aRefactoryChangeManager	undo := aRefactoryChangeManager privateGetUndo</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-Merge Management">classAndName	^self databaseClass name, '-', self name</body></methods><methods><class-id>Kernel.Compiler</class-id> <category>private</category><body package="Store-Merge Management">parseWithSignalling: textOrStream in: aClass noPattern: noPattern notifying: req	"Compile the incoming text and answer with the resulting parse tree.	This is the only public message that saves the source map	and the comments.  If the requestor is nil,	warning messages (as opposed to outright errors)	are silently discarded."	self		from: textOrStream		class: aClass		context: nil		notifying: req.	^self		translate: sourceStream		noPattern: noPattern		ifFail: [^nil]		needSourceMap: true		handlerClass: SignallingCompilerErrorHandler</body></methods><methods><class-id>UI.Panel</class-id> <category>layout algorithms</category><body package="Store-Code Comparison">beFullColumn	self layoutAlgorithm: 			[:rect :parts |			| bottom |			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + each preferredHeight.					(rect copy)						top: top;						bottom: bottom]]</body><body package="Store-Code Comparison">beFullColumnStretchIf: aPredicateBlock	self layoutAlgorithm: 			[:rect :parts |			| bottom stretchHeight unstretched |			stretchHeight := 0.			unstretched := parts reject: aPredicateBlock.			unstretched size &lt; parts size				ifTrue: 					[stretchHeight := (rect height								- (unstretched inject: 0 into: [:sum :each | sum + each preferredHeight]))									/ (parts size - unstretched size) max: 0].			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + ((aPredicateBlock value: each)										ifTrue: [stretchHeight]										ifFalse: [each preferredHeight]).					(rect copy)						top: top;						bottom: bottom]]</body></methods><methods><class-id>UI.Label</class-id> <category>accessing</category><body package="Store-Code Comparison">extent	^self width @ self height</body></methods><methods><class-id>Store.PackageModel</class-id> <category>converting</category><body package="Store-Publishing Support">asStorePundleIn: aGlorpSession returnOriginalIfUnmodified: returnOriginalIfUnmodified includeUninstalled: includeUninstalledCode	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new  versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"	| package |	package := super				asStorePundleIn: aGlorpSession				returnOriginalIfUnmodified: returnOriginalIfUnmodified				includeUninstalled: true.	package primaryKey isNil ifFalse: [^package].	"currentVersion := info isNil ifTrue: [nil] ifFalse: [info versionString]."	package addClassesAndMetaclassesFromPackageModel: self.	package addNameSpacesFromPackageModel: self.	package addOverriddenClassesAndNameSpacesFromPackageModel: self.	package addMethodsFromPackageModel: self.	includeUninstalledCode		ifTrue: [package addUninstalledCodeFromPackageModel: self].	package addSharedVariablesFromPackageModel: self.	package addOverriddenSharedVariablesFromPackageModel: self.	package sortForLoading.	^package</body></methods><methods><class-id>Store.BundleModel</class-id> <category>converting</category><body package="Store-Publishing Support">asStorePundleIn: aGlorpSession returnOriginalIfUnmodified: returnOriginalIfUnmodified includeUninstalled: includeUninstalledCode	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"	| bundle bundlesAndPackages |	bundle := super		asStorePundleIn: aGlorpSession		returnOriginalIfUnmodified: returnOriginalIfUnmodified		includeUninstalled: true.	bundle primaryKey isNil ifFalse: [^bundle].	bundlesAndPackages := self contents.	1		to: bundlesAndPackages size		do:			[:i | 			| each dict |			each := bundlesAndPackages at: i.			dict := each isBundle				ifTrue: [bundle bundles]				ifFalse: [bundle packages].			dict at: i put: (each asStorePundleIn: aGlorpSession)].	(self respondsTo: #fileDescriptions)		ifTrue:			[self fileDescriptions do: [:each | bundle addFile: each]].	^bundle.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>initialize-release</category><body package="Store-Publishing Support">setContentsFromDB: aDBBundle for: aDatabaseIdentifier		| databaseInfo |	databaseInfo := self databaseInfomationForOrCreate: aDatabaseIdentifier.	databaseInfo contentDescriptions: (aDBBundle containedItems collect: [:each | each asComponentDescription]).	databaseInfo fileDescriptions: (aDBBundle files collect: [:each | each asComponentDescription]).	dbInfo removeKey: self noDbSymbol ifAbsent: nil</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>constants</category><body package="Store-Publishing Support">publishSpecificationClass	^self storeDatabaseClass publishSpecificationClass</body><body package="Store-Publishing Support">publishSpecificationListClass	^self storeDatabaseClass publishSpecificationListClass</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="Store-Publishing Support">asNewStorePundleIn: aGlorpSession	"Create a new StoreForGlorp pundle corresponding to ourselves. Note that for new  versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asNewStorePundleIn: aSession"	| session |	session := aGlorpSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	^self		asStorePundleIn: session		returnOriginalIfUnmodified: false		includeUninstalled: true.</body><body package="Store-Publishing Support">asStorePundleIn: aGlorpSession returnOriginalIfUnmodified: returnOriginalIfUnmodified includeUninstalled: includeUninstalledCode	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new  versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"	| pundle info dbName previous |	dbName := aGlorpSession databaseIdentifier.	info := dbInfo at: dbName ifAbsent: [nil].	(info notNil and: [info dbTrace notNil])		ifTrue:			[previous := aGlorpSession				readOneOf: self storeForGlorpPundleClass				where: [:each | each primaryKey = info dbTrace]].	returnOriginalIfUnmodified		ifTrue:			[((self hasBeenModifiedIn: dbName) not and: [previous notNil])				ifTrue: [^previous minimizeFootprintInImage]].	pundle := self storeForGlorpPundleClass new.	pundle previous: previous.	pundle name: self name.	pundle properties: (self propertiesForSave removeKey: #version ifAbsent: [nil]; yourself).	pundle comment: self comment.	pundle username: aGlorpSession accessor currentLogin username.	pundle timestamp: (Glorp.Dialect storeTimestampIn: aGlorpSession).	pundle storeModel: self.	pundle session: aGlorpSession.	^pundle.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-Publishing Support">resetNoDatabaseInformation	dbInfo removeKey: self noDbSymbol ifAbsent: [nil].</body></methods><methods><class-id>Lens.LDMArrowView class</class-id> <category>instance creation</category><body package="Store-UI-Graphs">model: mdl fullImage: fullImage emptyImage: emptyImage	| dv |	dv := super model: mdl.	dv beVisual: emptyImage ifTrue: fullImage.	^dv</body></methods><methods><class-id>Lens.LensBrowsingToolModel</class-id> <category>store</category><body package="Store-UI-Graphs">openInLevels: levels	self selectionDo: 		[ :e | self browserModel body openAllFrom: e side: 2 levels: levels ]</body><body package="Store-UI-Graphs">openOutLevels: levels	self selectionDo: 		[ :e | self browserModel body openAllFrom: e side: 1 levels: levels ]</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>interface specs</category><body package="Store-UI">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #windowLabel 			#min: #(#Point 265 317 ) 			#max: #(#Point 265 317 ) 			#bounds: #(#Rectangle 260 120 525 437 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 2 0 2 0 -2 1 -2 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="Store-UI">windowNotebookSpec	"UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#min: #(#{Point} 523 340 ) 			#bounds: #(#{Rectangle} 186 175 762 517 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{TabControlSpec} 					#layout: #(#{LayoutFrame} 2 0 5 0 -6 1 -3 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#rightInset: 120 					#bottomInset: 0 ) ) ) )</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>interface specs</category><body package="Store-UI">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 332 332 ) 			#bounds: #(#{Graphics.Rectangle} 276 144 748 624 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 7 0 -2 1 -7 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="Store-UI">filesSpec	"Tools.UIPainter new openOnClass: self andSelector: #filesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PublishPundles 				#defaultString: 'Publish Pundles' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1372 1030 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -75 1 ) 					#name: #fileList 					#model: #files 					#menu: #filesMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 -70 1 ) 					#name: #publishSelectedCheckBox 					#model: #publish 					#label: 'Publish the selected file' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -140 1 -70 1 -10 1 -45 1 ) 					#name: #publishAllYes 					#model: #publishAllYes 					#label: 'Include All' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -140 1 -40 1 -10 1 -15 1 ) 					#name: #publishAllNo 					#model: #publishAllNo 					#label: 'Include Modified Only' 					#defaultable: true ) ) ) )</body><body package="Store-UI">mainSpec	"Tools.UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 331 321 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 718 385 1356 860 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -25 0.45 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -55 1 -10 1 -30 1 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -55 1 0 1 ) 					#name: #blessingLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #BlessingC 						#defaultString: 'Blessing:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 0 0.45 0 1 ) 					#name: #commentLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #CommentC 						#defaultString: 'Comment:' 						#catalogID: #store ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.45 -10 1 -95 1 ) 					#name: #blessingComment 					#model: #blessingComment 					#tabRequiresControl: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#name: #binarySave 					#model: #binarySave 					#label: 'Publish Binary' ) ) ) )</body><body package="Store-UI">parcelSpec	"Tools.UIPainter new openOnClass: self andSelector: #parcelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 514 210 986 690 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 'Publish Parcel' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 'Parcel Path:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 -10 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Store options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.4 ) 							#name: #databaseLinks 							#model: #databaseLinks 							#label: 'With database links' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.333333 -5 0.5 75 0.333333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Source options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 'Save source file' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 'Hide source on load' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 'Pad source' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.583333 -5 0.5 80 0.583333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Miscellaneous Options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 'Republish' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 'Backup' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 'Overwrite existing files' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0.5 0 0.583333 -10 1 80 0.583333 ) ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 11 0 -55 1 0 1 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionStringColon 						#defaultString: 'Version String:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 -77 1 -145 1 -52 1 ) 					#name: #VersionString 					#flags: 40 					#model: #parcelVersionString ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -77 1 -11 1 -52 1 ) 					#name: #CopyFromPackage 					#flags: 40 					#model: #copyFromPackage 					#label: 					#(#{Kernel.UserMessage} 						#key: #CopyFromPackage 						#defaultString: 'Copy From Package' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI">publishSpec	"Tools.UIPainter new openOnClass: self andSelector: #publishSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 420 1192 900 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -75 1 ) 					#name: #itemsList 					#model: #items ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 -65 1 ) 					#name: #publishSelectedCheck 					#model: #publish 					#label: 'Publish currently selected item' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 -40 1 -10 1 -15 1 ) 					#name: #publishAllNo 					#model: #publishAllNo 					#label: 'Include Modified Only' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 -70 1 -10 1 -45 1 ) 					#name: #publishAllYes 					#model: #publishAllYes 					#label: 'Include All Items' 					#defaultable: true ) ) ) )</body><body package="Store-UI">versionSpec	"Tools.UIPainter new openOnClass: self andSelector: #versionSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 420 1192 900 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -40 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 0 1 ) 							#name: #versionStringBox 							#model: #versionString ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0 0 1 0 1 ) 							#name: #vStringLabel 							#label: 'Version:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -35 1 -95 1 -10 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#model: #allVersions 					#label: 'Apply to All' 					#defaultable: true ) ) ) )</body><body package="Store-UI">windowNotebookSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #windowLabel 			#min: #(#{Core.Point} 506 364 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 720 350 1270 900 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -265 1 -35 1 -180 1 -10 1 ) 					#name: #publishButton 					#model: #accept 					#label: 'Publish' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 -35 1 -90 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -35 1 -5 1 -10 1 ) 					#name: #helpButton 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -40 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#labels: #() ) ) ) )</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>resources</category><body package="Store-UI">filesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #filesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AddFileDots 					#defaultString: 'Add File...' 					#catalogID: #store ) 				#nameKey: #addFile 				#value: #addFile ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RemoveFile 					#defaultString: 'Remove File' 					#catalogID: #store ) 				#nameKey: #removeFile 				#value: #removeFile 				#enablementSelector: #fileIsSelected ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>interface specs</category><body package="Store-UI">mainSpec	"Tools.UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Bundle' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1178 876 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 25 0 0 1 ) 					#name: #versionLabel 					#label: 'Version:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -10 1 50 0 ) 					#name: #versionString 					#model: #versionString ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 75 0 0 1 ) 					#name: #levelLabel 					#label: 'Blessing level:' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 75 0 -10 1 100 0 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 125 0 -10 1 -40 1 ) 					#name: #blessingComment 					#model: #blessingComment 					#tabRequiresControl: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#name: #binarySave 					#model: #binarySave 					#label: 'Publish Binary' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 125 0 0 1 ) 					#name: #bCommentLabel 					#label: 'Blessing comment:' ) ) ) )</body><body package="Store-UI">parcelSpec	"Tools.UIPainter new openOnClass: self andSelector: #parcelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 601 247 1021 727 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 11 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 'Publish Parcel' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.129032 ) 							#label: 'Parcel Path:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 0 1 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 50 0 -11 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Source options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 'Save source file' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 'Hide source on load' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 'Pad source' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -80 0.5 5 0.3 80 0.5 85 0.3 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Miscellaneous Options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 'Republish' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 'Backup' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 'Overwrite existing files' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -80 0.5 0 0.583333 80 0.5 80 0.583333 ) ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 11 0 -55 1 0 1 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionStringColon 						#defaultString: 'Version String:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 -77 1 -145 1 -52 1 ) 					#name: #VersionString 					#flags: 40 					#model: #parcelVersionString ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -77 1 -11 1 -52 1 ) 					#name: #CopyFromPackage 					#flags: 40 					#model: #copyFromPackage 					#label: 					#(#{Kernel.UserMessage} 						#key: #CopyFromPackage 						#defaultString: 'Copy From Package' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>resources</category><body package="Store-UI">bundleImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #bundleImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 63 254 0 0 32 254 0 0 32 254 0 0 32 254 0 0 32 254 0 0 32 36 0 0 63 228 0 0 4 4 0 0 4 4 0 0 7 252 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">bundleImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #bundleImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue green; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 0 0 160 0 21 80 162 170 21 80 162 170 21 80 162 170 21 80 162 170 0 0 162 170 162 136 160 0 2 136 170 138 170 136 170 138 170 136 170 128 0 8 170 170 170 168 170 170 170 168])</body><body package="Store-UI">bundleImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #bundleImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 224 0 0 32 32 0 0 32 32 0 0 32 60 0 0 32 36 0 0 32 36 0 0 63 228 0 0 4 4 0 0 4 4 0 0 7 252 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">dbBundleImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbBundleImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 42 160 0 0 0 0 0 0 32 32 0 0 0 20 0 0 32 32 0 0 0 4 0 0 42 160 0 0 4 4 0 0 0 0 0 0 5 84 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">dbNonCodePackageImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbNonCodePackageImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 10 168 0 0 0 4 0 0 16 0 0 0 0 8 0 0 32 0 0 0 0 16 0 0 64 0 0 0 42 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">dbPackageImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbPackageImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 21 84 0 0 0 0 0 0 16 4 0 0 0 0 0 0 16 4 0 0 0 0 0 0 16 4 0 0 0 0 0 0 21 84 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">nonCodePackageImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 0 254 0 0 15 254 0 0 8 254 0 0 16 254 0 0 16 254 0 0 32 16 0 0 32 16 0 0 64 32 0 0 127 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">nonCodePackageImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue green; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 0 0 170 170 21 80 170 0 21 80 170 42 21 80 168 170 21 80 168 170 0 0 162 170 168 168 162 170 168 168 138 170 162 168 128 0 2 168 170 170 170 168 170 170 170 168 170 170 170 168])</body><body package="Store-UI">nonCodePackageImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 15 252 0 0 8 4 0 0 16 8 0 0 16 8 0 0 32 16 0 0 32 16 0 0 64 32 0 0 127 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">packageImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #packageImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 0 254 0 0 31 254 0 0 16 254 0 0 16 254 0 0 16 254 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 31 252 0 0 0 0 0 0 0 0 0 0 ])</body><body package="Store-UI">packageImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #packageImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 2 put: ColorValue green; at: 3 put: ColorValue black; at: 4 put: ColorValue white; yourself)) usingBits: #[255 255 255 252 255 255 0 0 255 255 21 80 252 0 21 80 252 255 21 80 252 255 21 80 252 255 0 0 252 255 255 204 252 255 255 236 252 255 255 204 252 255 255 204 252 0 0 12 255 255 255 252 255 255 255 252])</body><body package="Store-UI">packageImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #packageImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 31 252 0 0 0 0 0 0 0 0 0 0 ])</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>interface specs</category><body package="Store-UI">publishPackage	"UIPainter new openOnClass: self andSelector: #publishPackage"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{UserMessage} #key: #PublishingPackage #catalogID: #store #defaultString: 'Publishing Package') 			#min: #(#{Point} 381 377 ) 			#max: #(#{Point} 381 377 ) 			#bounds: #(#{Rectangle} 371 200 752 577 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{LabelSpec} 					#layout: #(#{Point} 12 47 ) 					#label: #(#{UserMessage} #key: #VersionC #catalogID: #store #defaultString: 'Version:') ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 103 0 45 0 -8 1 75 0 ) 					#name: #versionString 					#model: #versionString ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 43 82 ) 					#name: #binarySave 					#model: #binarySave 					#label: #(#{UserMessage} #key: #Binary #catalogID: #store #defaultString: 'Binary') ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 199 82 ) 					#name: #parcelSave 					#model: #parcelSave 					#label: #(#{UserMessage} #key: #Parcel #catalogID: #store #defaultString: 'Parcel') ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 17 0 8 0 -17 1 31 0 ) 					#flags: 0 					#model: #dialogTitle 					#tabable: false 					#alignment: #center 					#isReadOnly: false )				#(#{LabelSpec} 					#layout: #(#{Point} 15 122 ) 					#label: #(#{UserMessage} #key: #BlessinglevelC #catalogID: #store #defaultString: 'Blessing level:') ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -40 0.25 -40 1 41 0.25 -10 1 ) 					#name: #publish 					#model: #publish 					#label: #(#{UserMessage} #key: #Publish #catalogID: #store #defaultString: 'Publish') 					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -40 0.75 -40 1 40 0.75 -10 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#defaultable: true ) 				#(#{TextEditorSpec} 					#layout: #(#{LayoutFrame} 12 0 179 0 -14 1 -50 1 ) 					#name: #blessingComment 					#model: #blessingComment ) 				#(#{LabelSpec} 					#layout: #(#{Point} 15 148 ) 					#label: #(#{UserMessage} #key: #BlessingcommentC #catalogID: #store #defaultString: 'Blessing comment:') ) 				#(#{DividerSpec} 					#layout: #(#{LayoutFrame} 18 0 108 0 -12 1 112 0 ) ) 				#(#{MenuButtonSpec} 					#layout: #(#{LayoutFrame} 152 0 119 0 -15 1 148 0 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) ) ) )</body></methods><methods><class-id>Store.TextDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Definition Comparison">briefSpec	"Tools.UIPainter new openOnClass: self andSelector: #briefSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Definition Difference Browser' 			#min: #(#{Core.Point} 50 50 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1540 950 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00316957 2 0 0 0.496038 0 0.992126 ) 					#name: #text1Widget 					#model: #text1 					#menu: #customTextMenu 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.499208 2 0 0 0.99683 0 0.992126 ) 					#name: #text2Widget 					#model: #text2 					#menu: #customTextMenu 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 900 550 1100 750 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#flags: 15 					#model: #itemsInList 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.Glorp.BundleTreePane class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 900 550 1100 750 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#model: #itemsInList 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.Glorp.BundleTreePane class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SetBlessingLevelDots 								#defaultString: '&amp;Set Blessing Level...' 								#catalogID: #store ) 							#nameKey: #SetBlessingLevel 							#value: #setBlessingLevel 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOutSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Graph 								#defaultString: '&amp;Graph' 								#catalogID: #store ) 							#nameKey: #Graph 							#value: #graphSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_EnclosingBundles 								#defaultString: '&amp;Enclosing Bundles' 								#catalogID: #store ) 							#nameKey: #enclosingBundles 							#value: #enclosingBundles 							#enablementSelector: #onlyOneItemSelected ) ) #(3 2 2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>event driven</category><body package="Store-Code Comparison">button1Down	&lt;event: #Button1Down&gt;	self hasFocus ifFalse: [self takeKeyboardFocus]</body><body package="Store-Code Comparison">button2Down: event	&lt;event: #Button2Down&gt;	| menuView valueResult |	self hasFocus ifFalse: [ self takeKeyboardFocus ].	self hasMenu ifFalse: [ ^self ].	menuView := MenuView model: self menu.	valueResult := menuView openFromView: self event: event.	valueResult value ifNotNil: #value</body><body package="Store-Code Comparison">keyDown: aKeyDown	&lt;event: #KeyDown&gt;	Character cr = aKeyDown keyValue ifTrue: [self toggleExpansion].	Character space = aKeyDown keyValue		ifTrue: 			[self isExpanded				ifTrue: [self cycleThruChanges: aKeyDown]				ifFalse: [self toggleExpansion]].	((Array with: #Right with: Character tab) includes: aKeyDown keyValue)		ifTrue: [self expandDetails].	aKeyDown keyValue == #Left ifTrue: [self collapseDetails].	aKeyDown keyValue == #Down ifTrue: [self focusNext].	aKeyDown keyValue == #Up ifTrue: [self focusPrevious]</body></methods><methods><class-id>Tools.AbstractComparisonRollupView class</class-id> <category>method tags</category><body package="Store-Code Comparison">methodTags		&lt;pragmas: #instance&gt;	^#(#itemInMenu:position:)</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison">browseImageLeftMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^self leftImageReference		ifNotNil: 			[:bindingReference |			self hasSameImageObject				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: bindingReference toolListDisplayString))						value: [self browseImageObject: bindingReference];						yourself]]</body><body package="Store-Code Comparison">browseImageRightMenuItem	&lt;itemInMenu: #(#menu) position: 20.9&gt;	^self rightImageReference		ifNotNil: 			[:bindingReference |			self hasSameImageObject				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: bindingReference toolListDisplayString))						value: [self browseImageObject: bindingReference];						yourself]]</body><body package="Store-Code Comparison">browseImageSameMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^self hasSameImageObject		ifTrue: 			[(MenuItem labeled: #BrowseImage &lt;&lt; #IDE &gt;&gt; 'Browse Image')				value: [self browseImageObject: (self rightImageReference ifNil: [self leftImageReference])];				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison">browseStoreLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^self leftStoreObject		ifNotNil: 			[:storeClassInPackage |			(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText						, (self storeObjectVersionLabel: storeClassInPackage))				value: [self browseStoreObject: storeClassInPackage];				yourself]</body><body package="Store-Code Comparison">browseStoreRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.2&gt;	^self rightStoreObject		ifNotNil: 			[:storeClassInPackage |			(self leftStoreObject ifNotNil: #primaryKey)				= storeClassInPackage primaryKey					ifTrue: [nil]					ifFalse: 						[(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText									, (self storeObjectVersionLabel: storeClassInPackage))							value: [self browseStoreObject: storeClassInPackage];							yourself]]</body><body package="Store-Code Comparison">loadLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^self leftStoreObject		ifNotNil: 			[:storeObjectInPackage |			(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText						, (self storeObjectVersionLabel: storeObjectInPackage))				value: [self loadObject: storeObjectInPackage];				yourself]</body><body package="Store-Code Comparison">loadRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.6&gt;	^self rightStoreObject		ifNotNil: 			[:storeObjectInPackage |			(self leftStoreObject ifNotNil: #primaryKey) = storeObjectInPackage primaryKey				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText								, (self storeObjectVersionLabel: storeObjectInPackage))						value: [self loadObject: storeObjectInPackage];						yourself]]</body><body package="Store-Code Comparison">noImageWarningMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^(MenuItem		labeled: ((#NoImageVersionToBrowser &lt;&lt; #IDE &gt;&gt; 'Not in Image') asText				emphasizeAllWith: (Array with: #italic)))		enabled: [false];		visible: [self rightImageReference isNil and: [self leftImageReference isNil]];		yourself</body><body package="Store-Code Comparison">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 40.9&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visible: [self leftStoreObject notNil or: [self rightStoreObject notNil]];		value: [self openObjectVersions];		yourself</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison">storeExtensionWarningMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^(MenuItem		labeled: ((#StoreExtensionOnly &lt;&lt; #IDE &gt;&gt; 'Class Extension Only') asText				emphasizeAllWith: (Array with: #italic)))		enabled: [false];		visible: [self rightStoreObject isNil and: [self leftStoreObject isNil]];		yourself</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>interface specs</category><body package="Store-UI">mainSpec	"Tools.UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ResetBlessingLevelDots 				#defaultString: 'Reset Blessing Level...' 				#catalogID: #store ) 			#min: #(#{Core.Point} 471 480 ) 			#max: #(#{Core.Point} 471 480 ) 			#bounds: #(#{Graphics.Rectangle} 515 210 986 690 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -35 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundleAndComponents 						#defaultString: 'Bundle and Components' 						#catalogID: #store ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -10 1 -20 0.5 ) 					#name: #itemsList 					#flags: 15 					#model: #items 					#multipleSelections: false 					#selectionType: #checkMark ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 0 1 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #BlessinglevelC 								#defaultString: 'Blessing level:' 								#catalogID: #store ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -10 0.5 -10 1 15 0.5 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #BlessingcommentC 								#defaultString: 'Blessing comment:' 								#catalogID: #store ) ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 20 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 20 0.5 -10 1 -50 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #allBlessings 					#label: 					#(#{Kernel.UserMessage} 						#key: #SetGlobalBlessingLevelAndComment 						#defaultString: 'Set Global Blessing Level and Comment' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI">publishSpec	"Tools.UIPainter new openOnClass: self andSelector: #publishSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PublishPundles 				#defaultString: 'Publish Pundles' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 514 210 986 690 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -5 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundleAndComponents 						#defaultString: 'Bundle and Components' 						#catalogID: #store ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 35 0 -10 1 -160 1 ) 					#name: #itemsList 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #RestModifedPundles 								#defaultString: 'Reset Modified Pundles' 								#catalogID: #store ) ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 10 0 -5 0.5 ) 							#name: #publishAllYes 							#model: #publishAllYes 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetAll 								#defaultString: 'Reset All' 								#catalogID: #store ) 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 0.5 0.5 0 ) 							#name: #publishAllNo 							#model: #publishAllNo 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetOnlyModified 								#defaultString: 'Reset Only Modified' 								#catalogID: #store ) 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} -10 1 -5 0.5 1 0 ) 							#name: #resetBundleOnly 							#model: #resetBundleOnly 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetBundleOnly 								#defaultString: 'Reset Bundle Only' 								#catalogID: #store ) 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -150 1 -10 1 -80 1 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #CurrentSelection 								#defaultString: 'Current Selection' 								#catalogID: #store ) ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 10 0 -5 0.5 ) 							#name: #publishYes 							#model: #publish 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetSelection 								#defaultString: 'Reset Selection' 								#catalogID: #store ) 							#select: true ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} -10 1 -5 0.5 1 0 ) 							#name: #publishNo 							#model: #publish 							#label: 							#(#{Kernel.UserMessage} 								#key: #DoNotReset 								#defaultString: 'Do Not Reset' 								#catalogID: #store ) 							#select: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -70 1 -10 1 -20 1 ) ) ) ) ) )</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>interface specs</category><body package="Store-Repository Access">reconnectSpec	"UIPainter new openOnClass: self andSelector: #reconnectSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #StoreConnection #catalogID: #store #defaultString: 'Store Connection') 			#min: #(#{Core.Point} 298 234 ) 			#max: #(#{Core.Point} 391 378 ) 			#bounds: #(#{Graphics.Rectangle} 338 193 729 571 ) 			#flags: 8 			#menu: #menuBar 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 234 0 0 1 ) 					#label: #(#{UserMessage} #key: #Username #catalogID: #store #defaultString: 'Username:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 265 0 0 1 ) 					#label: #(#{UserMessage} #key: #Password #catalogID: #store #defaultString: 'Password:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 299 0 0 1 ) 					#label: #(#{UserMessage} #key: #EnvironmentC #catalogID: #store #defaultString: 'Environment:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 37 0 -10 1 156 0 ) 					#name: #messageBox 					#model: #message 					#alignment: #center 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#name: #title 					#label: #(#{UserMessage} #key: #ReconnectingToTheStoreDatabase #catalogID: #store #defaultString: 'Reconnecting to the Store database.') ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 213 0 -16 1 237 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #userName 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 243 0 -16 1 267 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #password 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 278 0 -16 1 302 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #environment 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 204 0 -35 1 286 0 -8 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Connect #catalogID: #store #defaultString: 'Connect') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -97 1 -35 1 -15 1 -8 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{UserMessage} #key: #Detach #catalogID: #store #defaultString: 'Detach') 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 183 ) 					#label: #(#{UserMessage} #key: #DatabaseConnect #catalogID: #store #defaultString: 'Database Connect:') ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 183 369 207 ) 					#name: #whichDriver 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #whichDriverModel ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 150 308 ) 					#name: #saveConnection 					#model: #saveConnection 					#label: #(#{UserMessage} #key: #SaveConnectionInformation #catalogID: #store #defaultString: 'Save Connection Information') ) ) ) )</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>menus</category><body package="StoreForGlorpVWUI">repositorySubmenu	&lt;submenu: #(#Repository #menus 'Repository')		nameKey: #repositoryMenu		menu: #(#menuBar)		position: 10.03&gt;</body><body package="StoreForGlorpVWUI">toggleLogging	&lt;menuItem: 'Log SQL' 		nameKey: #sqlLoggingToggle 		enablement: nil 		indication: #isLogging 		menu: #(#menuBar #repositoryMenu) 		position: 30.5&gt;	self logging: self isLogging not.	^self.</body><body package="StoreForGlorpVWUI">toggleLogin	&lt;menuItem: 'Connected To Repository'		nameKey: #repositoryLogginToggle		enablement: nil		indication: #loggedIn		menu: #(menuBar repositoryMenu)		position: 30.40&gt;	self loggedIn ifTrue: [ self logout ] ifFalse: [ self login ].</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>menu</category><body package="Store-UI">browseMenuItem	&lt;itemInMenu: #(#menu) position: 10.1&gt;	^(MenuItem labeled: #Browse &lt;&lt; #IDE &gt;&gt; 'Browse')		value: [self browseMenuTarget];		yourself</body><body package="Store-UI">compareMenuItem	&lt;itemInMenu: #(#menu) position: 40.2&gt;	^(MenuItem labeled: #Compare &lt;&lt; #IDE &gt;&gt; 'Compare')		visible: [self isSelectedPeerDifferent];		value: 				[| tool |				tool := PackageComparisonTool							compareFromAll: (Array with: self selectedCodeComponent)							toAll: (Array with: self selectedCodeComponentPeer).				self isLeftSideSelection ifFalse: [tool swapSides]];		yourself</body><body package="Store-UI">fileoutMenuItem	&lt;itemInMenu: #(#menu) position: 30.2&gt;	^(MenuItem		labeled: (#FileoutDifferencesFrom1s &lt;&lt; #IDE				&gt;&gt; 'File Out Differences from &lt;1s&gt;'					expandMacrosWith: self selectedCodeComponentPeer version))		visible: [self isSelectedPeerDifferent];		value: [self fileoutChangesToGetToMenuTarget];		yourself</body><body package="Store-UI">loadMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^(MenuItem labeled: #Load &lt;&lt; #IDE &gt;&gt; 'Load')		visibility: [self selectedCodeComponent isImageModel not];		value: 				[self selectedCodeComponent canLoadNewOrReplaceExistingVersion					ifTrue: 						[[self selectedCodeComponent loadSrc]							withStoreFeedbackOn: self topComponent]];		yourself</body><body package="Store-UI">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 10.5&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visibility: [self selectedCodeComponent isImageModel not];		value: [DefinitionForListTool				forPackages: self selectedCodeComponent allStoreVersions];		yourself</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>event states</category><body package="Store-UI">button2Down: aButton2DownEvent	&lt;event: #Button2Down&gt;	| menuView valueResult |	self mouseMoved: aButton2DownEvent.	targetView ifNil: [^self].	self isPressed: true.	menuView := MenuView model: self menu.	valueResult := menuView openFromView: self event: aButton2DownEvent.	valueResult value ifNotNil: [:block | block value].	self isPressed: false</body><body package="Store-UI">mouseExit	&lt;event: #MouseExit&gt;	isPressed ifFalse: [self targetView: nil]</body><body package="Store-UI">mouseMoved: aMouseMoveEvent	&lt;event: #MouseMoved&gt;	| myPoint |	myPoint := self globalPointToLocal: aMouseMoveEvent point.	self targetView: (self children				detect: [:each | each frame containsPoint: myPoint]				ifNone: [nil])</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView class</class-id> <category>method tags</category><body package="Store-UI">methodTags		&lt;pragmas: #instance&gt;	^#(#itemInMenu:position:)</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>interface specs</category><body package="Store-Broker-Obsolete">reconnectSpec	"UIPainter new openOnClass: self andSelector: #reconnectSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #StoreConnection #catalogID: #store #defaultString: 'Store Connection') 			#min: #(#{Core.Point} 298 234 ) 			#max: #(#{Core.Point} 391 378 ) 			#bounds: #(#{Graphics.Rectangle} 317 195 708 573 ) 			#flags: 8 			#menu: #menuBar 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 234 0 0 1 ) 					#label: #(#{UserMessage} #key: #Username #catalogID: #store #defaultString: 'Username:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 265 0 0 1 ) 					#label: #(#{UserMessage} #key: #Password #catalogID: #store #defaultString: 'Password:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 299 0 0 1 ) 					#label: #(#{UserMessage} #key: #EnvironmentC #catalogID: #store #defaultString: 'Environment:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 37 0 -10 1 156 0 ) 					#name: #messageBox 					#model: #message 					#alignment: #center 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#label: #(#{UserMessage} #key: #ReconnectingToTheStoreDatabase #catalogID: #store #defaultString: 'Reconnecting to the Store database.') ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 213 0 -16 1 237 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #userName 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 243 0 -16 1 267 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #password 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 278 0 -16 1 302 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #environment 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 204 0 -35 1 286 0 -8 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Connect #catalogID: #store #defaultString: 'Connect') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -97 1 -35 1 -15 1 -8 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{UserMessage} #key: #Detach #catalogID: #store #defaultString: 'Detach') 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 183 ) 					#label: #(#{UserMessage} #key: #DatabaseConnect #catalogID: #store #defaultString: 'Database Connect:') ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 183 369 207 ) 					#name: #whichDriver 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #whichDriverModel ) ) ) )</body></methods><methods><class-id>Tools.AbstractPropertyComparisonRollupView</class-id> <category>printing properties</category><body package="Store-Code Comparison">printLegacyPrerequisites: anArray	&lt;printProperty: #developmentPrerequisites&gt;	&lt;printProperty: #prerequisiteParcels&gt;	^anArray storeString</body><body package="Store-Code Comparison">printPrerequisites: anArray	&lt;printProperty: #prerequisiteDescriptions&gt;	&lt;printProperty: #disregardedPrerequisites&gt;	| output |	output := TextStream on: String new.	anArray do: 			[:eachPropertyArray |			| description |			description := PrerequisiteDescription new						propertyArray: eachPropertyArray.			output emphasis: #bold.			output nextPutAll: description name.			output emphasis: nil.			output cr.			(description properties keys sorted copyWithout: #name) do: 					[:eachKey |					| eachProperty |					eachProperty := description properties at: eachKey.					output						emphasis: (Array with: #color -&gt; SymbolicPaint inactiveForeground);						nextPutAll: '  -';						nextPutAll: eachKey;						nextPutAll: ': ';						emphasis: nil;						nextPutAll: (eachProperty isString									ifTrue: [eachProperty]									ifFalse: [eachProperty storeString]);						cr]].	^output contents</body></methods><methods><class-id>Tools.AbstractPropertyComparisonRollupView class</class-id> <category>method tags</category><body package="Store-Code Comparison">printPropertyTag	&lt;pragmas: #instance&gt;	^#(#printProperty:)</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>resources</category><body package="Store-UI">changeListMenu	"MenuEditor new openOnClass: self andSelector: #changeListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #FileInOut #catalogID: #store #defaultString: 'File in/out') 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #WriteFile #catalogID: #store #defaultString: 'Write file...') 							#value: #fileOut ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RevertAll #catalogID: #store #defaultString: 'Revert all') 				#nameKey: #replayAllMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #FromHere #catalogID: #store #defaultString: 'From here') 							#value: #doFromHere ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #FromTheTop #catalogID: #store #defaultString: 'From the top') 							#value: #doAll ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RemoveAll #catalogID: #store #defaultString: 'Remove All') 				#value: #removeAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RestoreAll #catalogID: #store #defaultString: 'Restore All') 				#value: #restoreAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #SpawnAll #catalogID: #store #defaultString: 'Spawn All') 				#value: #copyView ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Forget #catalogID: #store #defaultString: 'Forget') 				#value: #forgetAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RevertSelection #catalogID: #store #defaultString: 'Revert selection') 				#value: #doThis ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RemoveSelection #catalogID: #store #defaultString: 'Remove Selection') 				#value: #removeItem ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RestoreSelection #catalogID: #store #defaultString: 'Restore selection') 				#value: #restoreItem ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #SpawnSelection #catalogID: #store #defaultString: 'Spawn selection') 				#value: #spawnBrowserOnSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Conflicts #catalogID: #store #defaultString: 'Conflicts') 				#nameKey: #conflictsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #CheckConflictsSaveAs #catalogID: #store #defaultString: 'Check conflicts, save as...') 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #CheckWithSystemSaveAs #catalogID: #store #defaultString: 'Check with system, save as...') 							#value: #checkWithSystem ) ) #(2 ) nil ) ) ) #(1 4 1 4 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #WriteFile 								#defaultString: 'Write file...' 								#catalogID: #store ) 							#value: #fileOut ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Revert 					#defaultString: 'Revert' 					#catalogID: #store ) 				#nameKey: #revert 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: 'Selection' 								#catalogID: #store ) 							#value: #doThis ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromTheTop 								#defaultString: 'All from the top' 								#catalogID: #store ) 							#value: #doAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromHereOnDown 								#defaultString: 'All from here on down' 								#catalogID: #store ) 							#value: #doFromHere ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Remove 					#defaultString: 'Remove' 					#catalogID: #store ) 				#nameKey: #remove 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: 'Selection' 								#catalogID: #store ) 							#value: #removeItem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #All 								#defaultString: 'All' 								#catalogID: #store ) 							#value: #removeAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllAbove 								#defaultString: 'All Above' 								#catalogID: #store ) 							#value: #removeAllAbove ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllBelow 								#defaultString: 'All Below' 								#catalogID: #store ) 							#value: #removeAllBelow ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExchangeRemoved 								#defaultString: 'Exchange removed' 								#catalogID: #store ) 							#value: #exchangeRemoved ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSourceAsParent 								#defaultString: 'Same source as parent' 								#catalogID: #store ) 							#value: #removeSameSourceAsParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentCodeThanParent 								#defaultString: 'Different code than parent' 								#catalogID: #store ) 							#value: #removeConflictsWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MethodsNotInParent 								#defaultString: 'Methods not in parent' 								#catalogID: #store ) 							#value: #removeMethodsNotInParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #EverythingNotInParent 								#defaultString: 'Everything not in parent' 								#catalogID: #store ) 							#value: #removeEverythingNotInParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangesContainingString 								#defaultString: 'Changes containing string ...' 								#catalogID: #store ) 							#value: #removeChangesContainingString ) ) #(4 1 2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Forget 					#defaultString: 'Forget' 					#catalogID: #store ) 				#nameKey: #forget 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetThese 								#defaultString: 'Forget these' 								#catalogID: #store ) 							#value: #forgetThese ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetAll 								#defaultString: 'Forget all' 								#catalogID: #store ) 							#value: #forgetAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PurgeThese 								#defaultString: 'Purge these' 								#catalogID: #store ) 							#nameKey: #purgeThese 							#value: #purgeThese ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PurgeSelection 								#defaultString: 'Purge selection' 								#catalogID: #store ) 							#nameKey: #purgeSelection 							#value: #purgeSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreSelection 								#defaultString: 'Restore selection' 								#catalogID: #store ) 							#value: #restoreItem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreAll 								#defaultString: 'Restore All' 								#catalogID: #store ) 							#value: #restoreAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreChangesContainingString 								#defaultString: 'Restore changes containing string' 								#catalogID: #store ) 							#value: #restoreChangesContainingString ) ) #(2 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Find 					#defaultString: 'Find' 					#catalogID: #store ) 				#nameKey: #find 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindPackageDots								#defaultString: 'Find Package...' 								#catalogID: #store ) 							#nameKey: #findPackage 							#value: #findPackage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindClassDots 								#defaultString: 'Find Class...' 								#catalogID: #store ) 							#value: #findClass ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindProtocolDots 								#defaultString: 'Find Protocol ...' 								#catalogID: #store ) 							#value: #findProtocol ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindSelectorDots								#defaultString: 'Find Selector ...' 								#catalogID: #store ) 							#value: #findSelector ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnSelection 								#defaultString: 'Spawn selection' 								#catalogID: #store ) 							#value: #spawnBrowserOnSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnAll 								#defaultString: 'Spawn All' 								#catalogID: #store ) 							#value: #copyView ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnOverridesContainingString 								#defaultString: 'Spawn overrides containing string' 								#catalogID: #store ) 							#value: #spawnChangesContainingString ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassMatching 								#defaultString: 'Class matching' 								#catalogID: #store ) 							#nameKey: #classMatching 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #InstanceAndClass 											#defaultString: 'Instance and class' 											#catalogID: #store ) 										#nameKey: #groupClassAndMetaclass 										#value: #groupClassAndMetaclass 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SelectedClassOnly 											#defaultString: 'Selected class only' 											#catalogID: #store ) 										#nameKey: #ungroupClassAndMetaclass 										#value: #ungroupClassAndMetaclass 										#indication: true ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SamePackage 								#defaultString: 'Same package' 								#catalogID: #store ) 							#nameKey: #filterByPackage 							#value: #togglePackageFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameType 								#defaultString: 'Same type' 								#catalogID: #store ) 							#nameKey: #filterByType 							#value: #toggleTypeFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameClass 								#defaultString: 'Same class' 								#catalogID: #store ) 							#nameKey: #filterByClass 							#value: #toggleClassFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameProtocol 								#defaultString: 'Same protocol' 								#catalogID: #store ) 							#nameKey: #filterByProtocol 							#value: #toggleProtocolFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSelector 								#defaultString: 'Same selector' 								#catalogID: #store ) 							#nameKey: #filterBySelector 							#value: #toggleSelectorFilter 							#indication: true ) ) #(4 3 1 5 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show 					#defaultString: 'Show' 					#catalogID: #store ) 				#nameKey: #show 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowCodeComponents 								#defaultString: 'Show code components' 								#catalogID: #store ) 							#nameKey: #showComponent 							#value: #toggleShowComponent 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowProtocol 								#defaultString: 'Show protocol' 								#catalogID: #store ) 							#nameKey: #showProtocol 							#value: #toggleShowProtocol 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowConflicts 								#defaultString: 'Show Conflicts' 								#catalogID: #store ) 							#nameKey: #showConflicts 							#value: #toggleShowConflicts 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Conflicts 								#defaultString: 'Conflicts' 								#catalogID: #store ) 							#nameKey: #showConflicts 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #VerticalView 											#defaultString: 'Vertical view' 											#catalogID: #store ) 										#nameKey: #viewConflictsVertically 										#value: #viewConflictsVertically 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #HorizontalView 											#defaultString: 'Horizontal view' 											#catalogID: #store ) 										#nameKey: #viewConflictsHorizontally 										#value: #viewConflictsHorizontally 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SourceDifferences 											#defaultString: 'Source differences' 											#catalogID: #store ) 										#nameKey: #highlightSourceDifferences 										#value: #highlightSourceDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #CodeDifferences 											#defaultString: 'Code differences' 											#catalogID: #store ) 										#nameKey: #highlightCodeDifferences 										#value: #highlightCodeDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #EmphasiseInList 											#defaultString: 'Emphasise in list' 											#catalogID: #store ) 										#nameKey: #toggleListEmphasis 										#value: #toggleListEmphasis ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #IndicateSameMethods 											#defaultString: 'Indicate same methods' 											#catalogID: #store ) 										#nameKey: #toggleTypesIncludeSame 										#value: #toggleTypesIncludeSame ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #LineEndTreatment 											#defaultString: 'Line-end treatment' 											#catalogID: #store ) 										#nameKey: #lineEndTreatment 										#submenu: #(#{UI.Menu} #(												#(#{UI.MenuItem} 													#rawLabel: 													#(#{Kernel.UserMessage} 														#key: #AsInFile 														#defaultString: 'As in file' 														#catalogID: #store ) 													#nameKey: #lineEndsRaw 													#value: #lineEndsRaw 													#indication: true ) 												#(#{UI.MenuItem} 													#rawLabel: 													#(#{Kernel.UserMessage} 														#key: #ConvertedToCrs 														#defaultString: 'Converted to crs' 														#catalogID: #store ) 													#nameKey: #lineEndsTreated 													#value: #lineEndsTreated 													#indication: true ) ) #(2 ) nil ) ) ) #(2 2 3 ) nil ) ) ) #(3 1 ) nil ) ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #windowLabel 			#min: #(#{Core.Point} 300 400 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 504 200 984 700 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 179 0 -1 1 -1 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #standardText ) 				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -98 1 172 0 ) 					#name: #listView 					#model: #selectionInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#toggleRemoveForListController: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #changeListMenuHolder ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 30 0 ) 							#model: #changeTypeFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #type 								#defaultString: 'type' 								#catalogID: #store ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 60 0 ) 							#model: #classNameFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #class 								#defaultString: 'class' 								#catalogID: #store ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 90 0 ) 							#model: #protocolFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #protocol 								#defaultString: 'protocol' 								#catalogID: #store ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 120 0 ) 							#model: #selectorFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #selector 								#defaultString: 'selector' 								#catalogID: #store ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#model: #packageFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #package 								#defaultString: 'package' 								#catalogID: #store ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -92 1 17 0 -2 1 169 0 ) ) ) ) ) )</body></methods><methods><class-id>Store.ResolutionsListPane class</class-id> <category>interface specs</category><body package="Store-Merge Management">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1517 1028 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #ModSet 					#flags: 7 					#model: #list 					#tabable: true 					#menu: #modificationMenu ) ) ) )</body></methods><methods><class-id>Store.FileoutDifferencesDialog class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #FileOutDifferences 				#defaultString: 'File Out Differences' 				#catalogID: #IDE ) 			#bounds: #(#{Graphics.Rectangle} 739 474 939 574 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 50 0 15 0 1 0.5 ) 					#name: #FromLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #FromC 						#defaultString: 'From:' 						#catalogID: #IDE ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 50 0 45 0 1 0.5 ) 					#name: #ToLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ToC 						#defaultString: 'To:' 						#catalogID: #IDE ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -130 1 -40 1 -10 1 -10 1 ) 					#name: #fileoutButton 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #FileOutDots 						#defaultString: 'File Out...' 						#catalogID: #IDE ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -270 1 -40 1 -150 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #IDE ) 					#defaultable: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 1 15 0 -10 1 45 0 ) 					#name: #swapButton 					#flags: 0 					#component: #swapButton ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} 55 0 15 0 0 0.5 ) 					#name: #fromVersionLabel 					#label: #fromVersionLabel 					#style: #default ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} 55 0 45 0 0 0.5 ) 					#name: #toVersionLabel 					#label: #toVersionLabel 					#style: #default ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="StoreForGlorpBrowserUI">classHierarchyPackageTab	"Don't do for Store."	&lt;tabDescription: 2&gt;	^nil</body><body package="StoreForGlorpBrowserUI">namespaceHierarchyPackageTab	"Don't do for Store."	&lt;tabDescription: 3&gt;	^nil</body></methods><methods><class-id>Store.Glorp.MethodListPane class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOut 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithIma_ge 								#defaultString: 'Compare With Ima&amp;ge' 								#catalogID: #store ) 							#nameKey: #CompareWithImage 							#value: #compareWithImage 							#enablementSelector: #existsInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_Method 								#defaultString: 'Load &amp;Method' 								#catalogID: #store ) 							#nameKey: #LoadMethod 							#value: #loadMethod 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 3 1 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreBrowserCommentTool class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#shortcutKeyCharacter: $F 				#shortcutModifiers: 2 ) ) #(3 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="StoreForGlorpBrowserUI">instanceVariableTab	"Don't do this one for Store."	&lt;tabDescription: 7&gt;	^nil</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>event driven</category><body package="Store-Code Comparison">button2Down: event	&lt;event: #Button2Down&gt;	| valueResult menuView |	menuView := MenuView model: self menu.	valueResult := menuView openFromView: self event: event.	valueResult value ifNotNil: [:block | block value].	menuTarget := nil</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>menu</category><body package="Store-Code Comparison">browseMenuItem	&lt;itemInMenu: #(#menu) position: 10.1&gt;	^(MenuItem labeled: #Browse &lt;&lt; #IDE &gt;&gt; 'Browse')		value: [self browseMenuTarget];		yourself</body><body package="Store-Code Comparison">fileoutMenuItem	&lt;itemInMenu: #(#menu) position: 30.2&gt;	^(MenuItem		labeled: (#FileoutDifferencesFrom1s &lt;&lt; #IDE				&gt;&gt; 'File Out Differences from &lt;1s&gt;'					expandMacrosWith: self menuTargetCompliment version))		visibility: [self menuTargetCompliment notNil];		value: [self fileoutChangesToGetToMenuTarget];		yourself</body><body package="Store-Code Comparison">loadMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^(MenuItem labeled: #Load &lt;&lt; #IDE &gt;&gt; 'Load')		visibility: [menuTarget isImageModel not];		value: 			[menuTarget canLoadNewOrReplaceExistingVersion ifTrue: 				[[menuTarget loadSrc] withStoreFeedbackOn: self topComponent]];		yourself</body><body package="Store-Code Comparison">publishMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^(MenuItem labeled: #PublishDots &lt;&lt; #IDE &gt;&gt; 'Publish...')		visible: [menuTarget isImageModel];		value: [DbRegistry doIfOnlineImage: [menuTarget storeInDB]];		yourself</body><body package="Store-Code Comparison">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 10.5&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visibility: [menuTarget isImageModel not];		value: [Store.Glorp.DefinitionForListTool forPackages: menuTarget allStoreVersions];		yourself</body></methods><methods><class-id>Tools.PackageComparisonHeaderView class</class-id> <category>method tags</category><body package="Store-Code Comparison">methodTags		&lt;pragmas: #instance&gt;	^#(#itemInMenu:position:)</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>menu</category><body package="Store-Code Comparison">browseImageMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^(MenuItem labeled: #BrowseImage &lt;&lt; #IDE &gt;&gt; 'Browse Image')		visible: [self imageMethod notNil];		value: [self browseImageMethod: self imageMethod];		yourself</body><body package="Store-Code Comparison">browseStoreMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^self storeMethod		ifNotNil: 			[:storeMethodInPackage |			(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText						, (self storeObjectVersionLabel: storeMethodInPackage))				value: [self browseStoreMethod: storeMethodInPackage];				yourself]</body><body package="Store-Code Comparison">loadMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^self storeMethod		ifNotNil: 			[:storeMethodInPackage |			(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText						, (self storeObjectVersionLabel: storeMethodInPackage))				value: [self loadMethod: storeMethodInPackage];				yourself]</body><body package="Store-Code Comparison">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 40.9&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visible: [self storeMethod notNil];		value: [self openMethodVersions: (Array with: self storeMethod definition)];		yourself</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>status registration</category><body package="Store-UI">basicInfoStatus	&lt;tool: 10 width: #intrinsic&gt;	^status</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>interface specs</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 					#(#{Kernel.UserMessage} 						#key: #_Edit 						#defaultString: '&amp;Edit' 						#catalogID: #UIPainter)				#nameKey: #Edit 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&lt;new item&gt;' 							#value: #textMenu ) ) #(1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #listTitle 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1650 1050 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 1 -1 0.32 ) 					#name: #ListOfThings 					#minorKey: #listSpec 					#clientKey: #listOfThings ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0.32 -1 1 -26 1 ) 					#name: #DefinitionText 					#model: #definition 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -1 0.32 -1 1 1 0.32 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'ListOfThings' 					#belowWidgets: 'DefinitionText' ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 0 1 0 1 ) 					#name: #Status 					#flags: 0 					#component: #statusBar ) ) ) )</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>private</category><body package="Store-UI">statusPragmas	&lt;pragmas: #instance&gt;	^ToolBarView pragmas</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>resources</category><body package="Store-UI">textMenu	"Tools.MenuEditor new openOnClass: self andSelector: #textMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copySelection 				#value: #copySelection 				#enablementSelector: #atLeastOnePundleVersionSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #find 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #findNext 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAll 					#defaultString: 'Select All' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #selectEntireText 				#value: #selectEntireText ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>interface specs</category><body package="Store-Repository Access">stopSpec	"UIPainter new openOnClass: self andSelector: #stopSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Load  Analyzer' 			#bounds: #(#Rectangle 423 252 773 610 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -35 0.5 -38 1 35 0.5 -5 1 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) ) ) )</body><body package="Store-Repository Access">warningSpec	"UIPainter new openOnClass: self andSelector: #warningSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #LoadAnalyzer #catalogID: #store #defaultString: 'Load  Analyzer') 			#bounds: #(#{Graphics.Rectangle} 332 174 682 532 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 0.5 -38 1 -10 0.5 -5 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Proceed #catalogID: #store #defaultString: 'Proceed') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -38 1 80 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UserGroupPrivliges #catalogID: #store #defaultString: 'User / Group Privliges') 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1233 965 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 70 0.5 30 0 -3 1 220 0 ) 					#name: #packageID 					#model: #packageList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange 						#requestValueChangeSelector: #listChange ) 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 30 0 -70 0.5 220 0 ) 					#name: #userGroupListID 					#model: #userGroupList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 70 0.5 8 0 ) 					#name: #pundleLabel 					#label: #(#{UserMessage} #key: #PackageC #catalogID: #store #defaultString: 'Package:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 8 ) 					#name: #Label2 					#label: #(#{UserMessage} #key: #UserGroup #catalogID: #store #defaultString: 'User/Group:') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 37 0 60 0.5 72 0 ) 					#name: #assignOwner 					#model: #assignOwner 					#label: #(#{UserMessage} #key: #MakeOwner #catalogID: #store #defaultString: 'Make Owner') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 84 0 60 0.5 119 0 ) 					#name: #grantRead 					#model: #grantRead 					#label: #(#{UserMessage} #key: #GrantRead #catalogID: #store #defaultString: 'Grant Read') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 131 0 60 0.5 166 0 ) 					#name: #grantPublish 					#model: #grantPublish 					#label: #(#{UserMessage} #key: #GrantPublish #catalogID: #store #defaultString: 'Grant Publish') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 178 0 60 0.5 213 0 ) 					#name: #revokeRights 					#model: #revokeRights 					#label: #(#{UserMessage} #key: #RevokeRights #catalogID: #store #defaultString: 'Revoke Rights') 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 227 0 -3 1 0 0.978972 ) 					#name: #privilegeText 					#model: #privilegeText 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs">menuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(1 ) #(#closeRequest ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>interface specs</category><body package="Store-Repository Access">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ConnectToDatabase 				#defaultString: 'Connect to Database' 				#catalogID: #store ) 			#min: #(#{Core.Point} 426 245 ) 			#max: #(#{Core.Point} 626 245 ) 			#bounds: #(#{Graphics.Rectangle} 747 446 1173 691 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 46 0 -106 1 239 0 ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 14 0 -103 1 38 0 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 58 0 -113 1 79 0 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 88 0 -113 1 109 0 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 114 0 -113 1 138 0 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 143 0 -113 1 167 0 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 173 0 -113 1 196 0 ) 					#name: #tableOwnerCombo 					#model: #tableOwnerHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #tableOwnerChanged ) 					#isReadOnly: false 					#comboList: #tableOwnerListHolder ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 206 0 220 0 227 0 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Save 						#defaultString: 'Save...' 						#catalogID: #store ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -199 1 206 0 -113 1 227 0 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Delete 						#defaultString: 'Delete' 						#catalogID: #store ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'Connect' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #database ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 91 0 -10 1 109 0 ) 					#name: #browseFiles 					#model: #browseFiles 					#label: 					#(#{Kernel.UserMessage} 						#key: #BrowseFiles 						#defaultString: 'Browse Files' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 196 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #TableOwner 						#defaultString: 'Table Owner:' 						#catalogID: #store ) ) ) ) )</body></methods><methods><class-id>Store.SpinnerIcons class</class-id> <category>png imports</category><body package="Store-UI">spin0	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin0.png'&gt;	&lt;md5sum: #[251 167 206 183 73 100 24 141 251 114 71 219 234 213 150 34]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@70@@@K&lt;@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@E@@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J(@@@C*@@@@: @@@IP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@N(@@@C*@@@@:P@@@CH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@U@@@@EP@@@AT@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@3 @@@N(@@@C*@@@@-0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@D @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AN@@@@: @@@N(@@@C*@@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@U@@@@EP@@@AT@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DT@@@BF@@@@X @@@@ @@@@@@@@@@@@@@@@@@@B1@@@@: @@@N(@@@B)@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@AT@@@@U@@@@D@@@@@@@@@@@@@@@@@@@@@D@@@@T@@@@G @@@@8@@@@@@@@@@@@@@@@@@@@C@@@@20@@@MT@@@CU@@@@/@@@@D\@@@@@@@@@@@@@@B(@@@C_@@@@: @@@GD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@EP@@@AT@@@@H@@@@@@@@@@@@@@@N@@@@IP@@@B(@@@@*@@@@J@@@@@@@@@@@@@@@@@@@@@D@@@B9@@@@5P@@@MT@@@CU@@@@5P@@@JL@@@AS@@@@@@@@@AH@@@@*@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@ @@@@@@@@@H@@@@G0@@@B(@@@@*@@@@J @@@B(@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@BT@@@B*@@@@5@@@@MT@@@CU@@@@5P@@@MT@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@B @@@@*@@@@J @@@B(@@@@*@@@@F0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@) @@@MT@@@CU@@@@5P@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@J @@@B(@@@@*@@@@HP@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@R @@@HH@@@A#@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@G @@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@(@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@0@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@MP@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@P@@@@CT@@@B @@@@0@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@5@@@@P@@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@MP@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@;@@@@^ @@@D&lt;@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@@4@@@@G @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@!P@@@J(@@@B*@@@@* @@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@UP@@@ET@@@AU@@@@P @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@[@@@@J$@@@B*@@@@* @@@J(@@@B#@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@AU@@@@UP@@@ET@@@AU@@@@UP@@@DP@@@@O@@@@@@@@@@@@@@@@@@@@@P@@@H4@@@B*@@@@* @@@J(@@@B*@@@@_0@@@A&lt;@@@@@@@@@C@@@@A,@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@@H@@@@@@@@@BD@@@AA@@@@UP@@@ET@@@AU@@@@UP@@@D(@@@@@@@@@@@@@@@@@@@@B@@@@( @@@J(@@@B*@@@@% @@@C$@@@@@@@@@@@@@@C,@@@BU@@@@%P@@@DX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@Z @@@FT@@@@S@@@@@@@@@@@@@@@\@@@@R0@@@ET@@@AU@@@@TP@@@@D@@@@@@@@@@@@@@@@@@@@7@@@@^ @@@ED@@@@F@@@@@@@@@@@@@@@@@@@@\0@@@IT@@@BU@@@@W@@@@@@@@@@R@@@@Z0@@@F,@@@@R@@@@@@@@@D0@@@A*@@@@Z @@@E@@@@@@@@@@@@@@@@@@@@@C@@@@I0@@@CT@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CH@@@BU@@@@%P@@@IT@@@@6@@@@@@@@@D @@@B@@@@@ @@@@D @@@@@@@@@I @@@F(@@@A*@@@@Z @@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@ 0@@@IT@@@BU@@@@]@@@@@D@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@@@@@@T0@@@F(@@@A*@@@@WP@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DP@@@BU@@@@%P@@@IP@@@@ @@@@@@@@@@@@@@AK@@@@ @@@@H@@@@AK@@@@@@@@@@@@@@@W@@@@Z @@@F(@@@A*@@@@L0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W @@@IT@@@BU@@@@]P@@@@@@@@@@@@@@@@@@@D,@@@B@@@@@ @@@@D,@@@@@@@@@@@@@@@@@@@AC@@@@Z @@@F(@@@AM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@# @@@H@@@@@Z@@@@@@@@@@@@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@@@@@@@@@@@@(@@@AV@@@@YP@@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@A+@@@@Z0@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin1	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin1.png'&gt;	&lt;md5sum: #[209 78 166 28 104 234 241 108 35 124 73 233 218 65 106 74]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@3 @@@L8@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@H(@@@C5@@@@=P@@@H(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@5P@@@K\@@@@V@@@@@@@@@@@@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@@@@@@@@@@@@H@@@@I@@@@B @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@JL@@@C @@@@8@@@@H4@@@@@@@@@@@@@@@@@@@BP@@@@=P@@@OT@@@BP@@@@@@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z0@@@N@@@@C @@@@70@@@C@@@@@@@@@@@@@@@I@@@@C5@@@@=P@@@I@@@@@@@@@@@@@@@@H@@@@J@@@@B @@@@(@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@1P@@@N@@@@C @@@@+0@@@@D@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@8@@@@N@@@@C @@@@TP@@@@@@@@BJ@@@@=P@@@OT@@@BJ@@@@@@@@@@P@@@@J@@@@B @@@@(@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DH@@@A?@@@@WP@@@@\@@@@@@@@@@@@@@@@@@@B*@@@@8@@@@N@@@@B"@@@@@@@@@BH@@@CN@@@@3 @@@BH@@@@@@@@@A @@@@(@@@@J@@@@B@@@@@@@@@@@@@@@@@@@@@D@@@@O@@@@E0@@@@(@@@@@@@@@@@@@@@@@@@@B@@@@0@@@@L(@@@CJ@@@@, @@@DL@@@@@@@@@@@@@@B @@@CU@@@@8@@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B @@@@(@@@@D@@@@@@@@@@@@@@@K@@@@G@@@@B@@@@@ @@@@G @@@@@@@@@@@@@@@@@@@@D@@@B/@@@@2 @@@L(@@@CJ@@@@2 @@@I(@@@AN@@@@@@@@@AH@@@@(@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@F@@@@F@@@@B@@@@@ @@@@H@@@@B@@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@B!@@@@2P@@@L(@@@CJ@@@@2 @@@L(@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@A&lt;@@@@ @@@@H@@@@B@@@@@ @@@@E@@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@'' @@@L(@@@CJ@@@@2 @@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@H@@@@B@@@@@ @@@@FP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@Q0@@@G0@@@A^@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@E0@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@% @@@KT@@@B5@@@@-P@@@KT@@@B5@@@@-P@@@IX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@MP@@@B0@@@BV@@@@-P@@@KT@@@B5@@@@-P@@@KT@@@B5@@@@% @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@MP@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@K@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@8@@@@\0@@@D,@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@@-@@@@F @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@_P@@@J@@@@B @@@@(@@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@R @@@D(@@@AJ@@@@N @@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@Y @@@I&lt;@@@B @@@@(@@@@J@@@@BY@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@AJ@@@@R @@@D(@@@AJ@@@@R @@@C,@@@@M@@@@@@@@@@@@@@@@@@@@@P@@@HP@@@B @@@@(@@@@J@@@@B @@@@^@@@@A4@@@@@@@@@B0@@@A$@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@H@@@@@@@@@A4@@@@9@@@@R @@@D(@@@AJ@@@@R @@@D@@@@@@@@@@@@@@@@@@@@@B@@@@&amp;@@@@J@@@@B @@@@#P@@@CT@@@@@@@@@@@@@@C\@@@BJ@@@@" @@@DD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.@@@@X@@@@E,@@@@Q@@@@@@@@@@@@@@@Y@@@@PP@@@D(@@@AJ@@@@Q0@@@@D@@@@@@@@@@@@@@@@@@@@4@@@@\0@@@D0@@@@F@@@@@@@@@@@@@@@@@@@@Z0@@@H(@@@BJ@@@@UP@@@@@@@@@P@@@@X @@@FH@@@@P@@@@@@@@@DT@@@A @@@@X@@@@D$@@@@@@@@@@@@@@@@@@@@C@@@@H @@@B8@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@BJ@@@@" @@@H(@@@@2@@@@@@@@@DH@@@A5@@@@]P@@@DH@@@@@@@@@H0@@@F@@@@A @@@@X@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@^P@@@H(@@@BJ@@@@[@@@@@D@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@@@@@@R0@@@F@@@@A @@@@U@@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C&lt;@@@BJ@@@@" @@@H$@@@@^@@@@@@@@@@@@@@AE@@@@]P@@@GT@@@AE@@@@@@@@@@@@@@@U@@@@X@@@@F@@@@A @@@@K @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U0@@@H(@@@BJ@@@@[@@@@@@@@@@@@@@@@@@@@DT@@@A5@@@@]P@@@DT@@@@@@@@@@@@@@@@@@@@=@@@@X@@@@F@@@@AF@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@!@@@@G\@@@@X@@@@@@@@@@@@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@@@@@@@@@@@@$@@@AN@@@@V0@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AB@@@@]P@@@GT@@@AB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@A"@@@@X @@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin10	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin10.png'&gt;	&lt;md5sum: #[14 197 143 98 164 122 205 164 119 174 215 200 121 130 144 227]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@_P@@@G4@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@EP@@@BU@@@@%P@@@EP@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@^ @@@F @@@@M@@@@@@@@@@@@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@@@@@@@@@@@A8@@@BR@@@@( @@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E4@@@B@@@@@ @@@@ED@@@@@@@@@@@@@@@@@@@AX@@@@%P@@@IT@@@AX@@@@@@@@@@@@@@@@@@@@!P@@@J(@@@B*@@@@Z0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@OP@@@H@@@@B@@@@@_0@@@A0@@@@@@@@@@@@@@E @@@BU@@@@%P@@@E @@@@@@@@@@@@@@BT@@@B)@@@@* @@@J(@@@AN@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@\@@@@H@@@@B@@@@@Y@@@@@D@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@A@@@@!P@@@J(@@@B*@@@@%P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@ @@@@H@@@@B@@@@@K @@@@@@@@AT@@@@%P@@@IT@@@AT@@@@@@@@@C4@@@B*@@@@* @@@J(@@@@9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@AC@@@@LP@@@@P@@@@@@@@@@@@@@@@@@@A!@@@@ @@@@H@@@@A\@@@@@@@@@AP@@@A=@@@@_P@@@AP@@@@@@@@@ZP@@@J(@@@B*@@@@ 0@@@@@@@@@@@@@@@@@@@@\@@@A[@@@@" @@@C8@@@@@@@@@@@@@@@@@@@@A@@@@YP@@@F(@@@A*@@@@W @@@BL@@@@@@@@@@@@@@A\@@@A:@@@@ @@@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@* @@@J(@@@AC@@@@@@@@@@@@@@A@@@@@*P@@@L@@@@C@@@@@-0@@@@H@@@@@@@@@@@@@@@@@@@A\@@@@Z @@@F(@@@A*@@@@Z @@@ED@@@@)@@@@@@@@@@(@@@@W@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@_@@@@CP@@@@@@@@@#@@@@$@@@@L@@@@C@@@@@0@@@@L@@@@B_@@@@@P@@@@@@@@@@@@@@@@@@@AH@@@AT@@@@Z @@@F(@@@A*@@@@Z @@@F(@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@K @@@C@@@@@0@@@@L@@@@B?@@@@^ @@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@T0@@@F(@@@A*@@@@Z @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@0@@@@L@@@@C@@@@@% @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IP@@@DD@@@@1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AZ@@@@" @@@DL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@Q0@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@UP@@@D\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@5P@@@KD@@@AG@@@@UP@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@Q0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B1@@@@5P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@,P@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@K @@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@F4@@@BO@@@@T @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@L @@@D@@@@A@@@@@P@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@: @@@N(@@@C*@@@@-0@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@JP@@@D@@@@A@@@@@P@@@@D@@@@@=@@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@C*@@@@: @@@N(@@@C*@@@@:P@@@K(@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@CT@@@A@@@@@P@@@@D@@@@A@@@@@L@@@@@0@@@@@@@@@@0@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E,@@@B3@@@@: @@@N(@@@C*@@@@: @@@L,@@@@A@@@@@@@@@@@@@@@A@@@@OP@@@D@@@@A@@@@@N@@@@AT@@@@@@@@@@@@@@AD@@@@*@@@@J @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AN@@@@3 @@@N(@@@C*@@@@70@@@@L@@@@@@@@@@@@@@@@@@@@U@@@@K @@@A8@@@@B@@@@@@@@@@@@@@@@@@@@H@@@@B(@@@@*@@@@F @@@@@@@@@C@@@@D @@@AH@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@Z0@@@IL@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@@*@@@@J @@@B(@@@@O@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@IP@@@B(@@@@*@@@@HP@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@@*@@@@J @@@B(@@@@I@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@B(@@@@*@@@@HP@@@@@@@@@@@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@J@@@@BP@@@@G@@@@@@@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@R@@@@D @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin11	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin11.png'&gt;	&lt;md5sum: #[38 34 45 172 120 27 226 42 200 101 235 154 172 98 84 217]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@]@@@@GP@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D8@@@BJ@@@@" @@@D8@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@[0@@@E&lt;@@@@K@@@@@@@@@@@@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@@@@@@@@@@@A0@@@BI@@@@&amp;@@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ET@@@A5@@@@]P@@@D(@@@@@@@@@@@@@@@@@@@AQ@@@@" @@@H(@@@AQ@@@@@@@@@@@@@@@@@@@@_P@@@J@@@@B @@@@YP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@GT@@@A5@@@@]P@@@A$@@@@@@@@@@@@@@ED@@@BJ@@@@" @@@ED@@@@@@@@@@@@@@BL@@@B_@@@@(@@@@J@@@@AI@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@Y0@@@GT@@@A5@@@@V0@@@@@@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@A@@@@_P@@@J@@@@B @@@@#P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@''@@@@]P@@@GT@@@A5@@@@J @@@@@@@@AN@@@@" @@@H(@@@AN@@@@@@@@@C(@@@B @@@@(@@@@J@@@@@5@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@@&lt;@@@@K@@@@@L@@@@@@@@@@@@@@@@@@@AY@@@@]P@@@GT@@@AT@@@@@@@@@AL@@@A4@@@@]@@@@AL@@@@@@@@@X0@@@J@@@@B @@@@_@@@@@@@@@@@@@@@@@@@@@X@@@AV@@@@  @@@C,@@@@@@@@@@@@@@@@@@@@A@@@@V0@@@F@@@@A @@@@UP@@@B@@@@@@@@@@@@@@@AT@@@A/@@@@]P@@@C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@(@@@@J@@@@@?@@@@@@@@@@@@@@@&lt;@@@@(@@@@KT@@@B5@@@@+@@@@@H@@@@@@@@@@@@@@@@@@@AS@@@@X@@@@F@@@@A @@@@X@@@@D$@@@@%@@@@@@@@@@$@@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@]@@@@CP@@@@@@@@@!@@@@"@@@@KT@@@B5@@@@-P@@@KT@@@BV@@@@@P@@@@@@@@@@@@@@@@@@@AD@@@AL@@@@X@@@@F@@@@A @@@@X@@@@F@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C @@@J4@@@B5@@@@-P@@@KT@@@B4@@@@\0@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@R0@@@F@@@@A @@@@X@@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@-P@@@KT@@@B5@@@@#P@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H @@@C,@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AT@@@@  @@@C&lt;@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@O @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@R @@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@2 @@@J @@@@&gt;@@@@R @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@O @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@@2 @@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@*@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@I @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@F$@@@BI@@@@S @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@JP@@@CT@@@@5@@@@MP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@8@@@@N@@@@C @@@@+0@@@CD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@H @@@CT@@@@5@@@@MP@@@CT@@@@3@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@C @@@@8@@@@N@@@@C @@@@70@@@KH@@@@''@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@@5@@@@MP@@@CT@@@@5@@@@J@@@@@(@@@@@@@@@@0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@B0@@@@S@@@@@@@@@E\@@@B+@@@@8@@@@N@@@@C @@@@8@@@@LH@@@@A@@@@@@@@@@@@@@@A@@@@L0@@@CT@@@@5@@@@K0@@@AH@@@@@@@@@@@@@@@4@@@@ @@@@H@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A6@@@@=P@@@N$@@@@,@@@@@@@@@@@@@@AK@@@@1 @@@N@@@@C @@@@5P@@@@L@@@@@@@@@@@@@@@@@@@@Q@@@@I @@@A$@@@@B@@@@@@@@@@@@@@@@@@@@FP@@@B@@@@@ @@@@E@@@@@@@@@@A@@@@B@@@@@ @@@@A@@@@@@@@@KD@@@C5@@@@=P@@@K$@@@@@@@@@@@@@@@@@@@@H@@@@Y0@@@H4@@@AI@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@ @@@@H@@@@B@@@@@L@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@V@@@@OT@@@C5@@@@=P@@@EH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@G@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@A@@@@/0@@@OT@@@C5@@@@50@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@ @@@@H@@@@B@@@@@G@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@@@@@@5@@@@=@@@@OT@@@C5@@@@]P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@@@@@B[@@@@=P@@@OT@@@B2@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@G @@@A,@@@@F@@@@@@@@@@@@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@@@@@@@@@@@A @@@CH@@@@:P@@@D&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@H@@@@B@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin12	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin12.png'&gt;	&lt;md5sum: #[85 180 205 0 151 63 94 162 112 206 53 192 106 180 62 74]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@Z0@@@F,@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@B@@@@@ @@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@YP@@@EX@@@@J@@@@@@@@@@@@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@@@@@@@@@@@A(@@@B@@@@@# @@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D4@@@A*@@@@Z @@@DL@@@@@@@@@@@@@@@@@@@AK@@@@ @@@@H@@@@AK@@@@@@@@@@@@@@@@@@@@]P@@@IT@@@BU@@@@W @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L0@@@F(@@@A*@@@@Z @@@A\@@@@@@@@@@@@@@D,@@@B@@@@@ @@@@D,@@@@@@@@@@@@@@B@@@@BT@@@@%P@@@IT@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@WP@@@F(@@@A*@@@@T0@@@@@@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@A@@@@]@@@@IT@@@BU@@@@ 0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@Z @@@F(@@@A*@@@@I @@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@CX@@@BU@@@@%P@@@IT@@@@2@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@@5@@@@I0@@@@L@@@@@@@@@@@@@@@@@@@AP@@@@Z @@@F(@@@AL@@@@@@@@@AH@@@A+@@@@Z0@@@AH@@@@@@@@@W@@@@IT@@@BU@@@@\0@@@@@@@@@@@@@@@@@@@@X@@@AQ@@@@^ @@@C\@@@@@@@@@@@@@@@@@@@@A@@@@TP@@@ET@@@AU@@@@R0@@@A0@@@@@@@@@@@@@@AL@@@A%@@@@Z @@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AF@@@@%P@@@IT@@@@;@@@@@@@@@@@@@@@9@@@@% @@@J(@@@B*@@@@( @@@@H@@@@@@@@@@@@@@@@@@@AJ@@@@UP@@@ET@@@AU@@@@UP@@@DD@@@@!@@@@@@@@@@ @@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@[@@@@C@@@@@@@@@@_@@@@_0@@@J(@@@B*@@@@* @@@J(@@@BM@@@@@P@@@@@@@@@@@@@@@@@@@@&lt;@@@AD@@@@UP@@@ET@@@AU@@@@UP@@@ET@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@JL@@@B*@@@@* @@@J(@@@B)@@@@[@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@P @@@ET@@@AU@@@@UP@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@* @@@J(@@@B*@@@@!P@@@BT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G @@@CP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AO@@@@^ @@@C,@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@MP@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@P@@@@CT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@0@@@@J@@@@@5@@@@P@@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@MP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@@0@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@(@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@G @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@FL@@@BB@@@@R @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@HP@@@B(@@@@*@@@@J @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@5P@@@MT@@@CU@@@@) @@@B&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F0@@@B(@@@@*@@@@J @@@B(@@@@(@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@CU@@@@5P@@@MT@@@CU@@@@5@@@@J(@@@@%@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@@*@@@@J @@@B(@@@@*@@@@G0@@@@ @@@@@@@@@@ @@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@B(@@@@R@@@@@@@@@EL@@@B#@@@@5P@@@MT@@@CU@@@@5P@@@K$@@@@A@@@@@@@@@@@@@@@@@@@@J@@@@B(@@@@*@@@@IP@@@@8@@@@@@@@@@@@@@@ @@@@U@@@@EP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A1@@@@: @@@M&lt;@@@@*@@@@@@@@@@@@@@AG@@@@/@@@@MT@@@CU@@@@20@@@@L@@@@@@@@@@@@@@@@@@@@N@@@@G @@@AP@@@@A@@@@@@@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J$@@@C*@@@@: @@@KD@@@@@@@@@@@@@@@@@@@@H@@@@X @@@HX@@@AE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@U@@@@EP@@@AT@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@N(@@@C*@@@@: @@@D8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@D @@@AT@@@@U@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@-0@@@N(@@@C*@@@@3 @@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@U@@@@EP@@@AT@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@:P@@@N(@@@C*@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@AT@@@@U@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BT@@@@: @@@N(@@@B*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@E@@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@B?@@@@70@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin13	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin13.png'&gt;	&lt;md5sum: #[37 40 97 228 75 230 232 174 138 98 75 45 193 181 186 159]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@X @@@FH@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DH@@@A5@@@@]P@@@DH@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@V0@@@D8@@@@I@@@@@@@@@@@@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@@@@@@@@@@@A @@@A7@@@@!@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DX@@@A @@@@X@@@@C4@@@@@@@@@@@@@@@@@@@AE@@@@]P@@@GT@@@AE@@@@@@@@@@@@@@@@@@@@[@@@@H(@@@BJ@@@@U0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K @@@F@@@@A @@@@X@@@@AT@@@@@@@@@@@@@@DT@@@A5@@@@]P@@@DT@@@@@@@@@@@@@@A8@@@BI@@@@" @@@H(@@@@?@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@U@@@@F@@@@A @@@@R0@@@@@@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@A@@@@[@@@@H(@@@BJ@@@@^P@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@X@@@@F@@@@A @@@@H0@@@@@@@@AB@@@@]P@@@GT@@@AB@@@@@@@@@CH@@@BJ@@@@" @@@H(@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@.@@@@H @@@@L@@@@@@@@@@@@@@@@@@@AI@@@@X@@@@F@@@@AE@@@@@@@@@A@@@@A"@@@@X @@@A@@@@@@@@@@UP@@@H(@@@BJ@@@@Z0@@@@@@@@@@@@@@@@@@@@X@@@AL@@@@\0@@@CP@@@@@@@@@@@@@@@@@@@@A@@@@Q0@@@D(@@@AJ@@@@PP@@@A$@@@@@@@@@@@@@@AD@@@A[@@@@X@@@@B8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AA@@@@" @@@H(@@@@7@@@@@@@@@@@@@@@5@@@@#P@@@J@@@@B @@@@&amp;@@@@@H@@@@@@@@@@@@@@@@@@@A@@@@@R @@@D(@@@AJ@@@@R @@@C$@@@@]@@@@@@@@@@ @@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@Y@@@@B0@@@@@@@@@]@@@@^@@@@J@@@@B @@@@(@@@@J@@@@BD@@@@@P@@@@@@@@@@@@@@@@@@@@4@@@@;@@@@R @@@D(@@@AJ@@@@R @@@D(@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@I$@@@B @@@@(@@@@J@@@@B_@@@@Y @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@N @@@D(@@@AJ@@@@R @@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]@@@@(@@@@J@@@@B @@@@_P@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F @@@B4@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AK@@@@\0@@@C @@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@K@@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@MP@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@% @@@KT@@@B5@@@@-P@@@KT@@@B5@@@@-P@@@IX@@@@,@@@@MP@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@K@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BV@@@@-P@@@KT@@@B5@@@@-P@@@KT@@@B5@@@@% @@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@E0@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@E8@@@A&lt;@@@@Q0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@FP@@@B@@@@@ @@@@H@@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@2 @@@L(@@@CJ@@@@'' @@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@E@@@@B@@@@@ @@@@H@@@@B@@@@@_@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@CJ@@@@2 @@@L(@@@CJ@@@@2P@@@JD@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@@ @@@@H@@@@B@@@@@ @@@@F@@@@@X@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@B @@@@R@@@@@@@@@D8@@@BZ@@@@2 @@@L(@@@CJ@@@@2 @@@J&lt;@@@@A@@@@@@@@@@@@@@@@@@@@G @@@B@@@@@ @@@@G@@@@@,@@@@@@@@@@@@@@@P@@@@J@@@@B @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A,@@@@8@@@@MT@@@@(@@@@@@@@@@@@@@AC@@@@, @@@L(@@@CJ@@@@0@@@@@H@@@@@@@@@@@@@@@@@@@@J@@@@E0@@@@&lt;@@@@A@@@@@@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@A @@@@@@@@@"@@@@3 @@@L8@@@@"@@@@@@@@@JH@@@C @@@@8@@@@J(@@@@@@@@@@@@@@@@@@@@G@@@@WP@@@G&lt;@@@AB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@J@@@@B @@@@(@@@@D@@@@@@@@@H(@@@C5@@@@=P@@@H(@@@@@@@@@TP@@@N@@@@C @@@@8@@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@@(@@@@J@@@@B@@@@@@@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@A@@@@+0@@@N@@@@C @@@@1P@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@J@@@@B @@@@(@@@@B@@@@@@@@@@@@@@BP@@@@=P@@@OT@@@BP@@@@@@@@@@@@@@@0@@@@70@@@N@@@@C @@@@Z0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@(@@@@J@@@@B@@@@@@@@@@@@@@@@@@@@I@@@@C5@@@@=P@@@I@@@@@@@@@@@@@@@@@@@@BM@@@@8@@@@N@@@@B#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@B @@@@$@@@@B@@@@@@@@@@@@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@@@@@@@@@@@AX@@@B7@@@@5P@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BJ@@@@=P@@@OT@@@BJ@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@CN@@@@3 @@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin14	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin14.png'&gt;	&lt;md5sum: #[129 51 45 77 244 69 122 38 78 137 147 179 53 225 37 112]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@VP@@@E$@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@A*@@@@Z @@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@TP@@@DT@@@@H@@@@@@@@@@@@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@@@@@@@@@@@A\@@@A.@@@@^ @@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C8@@@AU@@@@UP@@@CX@@@@@@@@@@@@@@@@@@@@&gt;@@@@Z @@@F(@@@@&gt;@@@@@@@@@@@@@@@@@@@@Y@@@@H@@@@B@@@@@TP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@JP@@@ET@@@AU@@@@UP@@@AH@@@@@@@@@@@@@@C8@@@A*@@@@Z @@@C8@@@@@@@@@@@@@@A0@@@A?@@@@ @@@@H@@@@@;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@R0@@@ET@@@AU@@@@P @@@@@@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@A@@@@Y@@@@H@@@@B@@@@@\@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@UP@@@ET@@@AU@@@@G0@@@@@@@@@&lt;@@@@Z @@@F(@@@@&lt;@@@@@@@@@B8@@@B@@@@@ @@@@H@@@@@+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AT@@@@(@@@@GP@@@@H@@@@@@@@@@@@@@@@@@@A@@@@@UP@@@ET@@@@=@@@@@@@@@@&lt;@@@AY@@@@VP@@@@&lt;@@@@@@@@@S0@@@H@@@@B@@@@@X0@@@@@@@@@@@@@@@@@@@@T@@@AG@@@@Z0@@@C@@@@@@@@@@@@@@@@@@@@@A@@@@OP@@@D@@@@A@@@@@N@@@@AT@@@@@@@@@@@@@@@&lt;@@@AQ@@@@UP@@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@ @@@@H@@@@@3@@@@@@@@@@@@@@@2@@@@ 0@@@IT@@@BU@@@@# @@@@H@@@@@@@@@@@@@@@@@@@@7@@@@P@@@@D@@@@A@@@@@P@@@@CD@@@@Y@@@@@@@@@@\@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@W@@@@B @@@@@@@@@[@@@@\@@@@IT@@@BU@@@@%P@@@IT@@@A;@@@@@P@@@@@@@@@@@@@@@@@@@@,@@@@3@@@@P@@@@D@@@@A@@@@@P@@@@D@@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@H&lt;@@@BU@@@@%P@@@IT@@@BT@@@@W0@@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@L @@@D@@@@A@@@@@P@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@%P@@@IT@@@BU@@@@]@@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E @@@B\@@@@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AF@@@@Z0@@@CP@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@H0@@@B(@@@@*@@@@J @@@B(@@@@*@@@@J @@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#P@@@J(@@@B*@@@@* @@@J(@@@B*@@@@* @@@H4@@@@#@@@@J @@@B(@@@@*@@@@J @@@B(@@@@*@@@@H0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BM@@@@* @@@J(@@@B*@@@@* @@@J(@@@B*@@@@#P@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@C0@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@E(@@@A5@@@@P0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@D@@@@AT@@@@U@@@@EP@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@0@@@@L@@@@C@@@@@% @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@CP@@@AT@@@@U@@@@EP@@@AT@@@@T@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@C@@@@@0@@@@L@@@@C@@@@@/0@@@I$@@@@!@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@U@@@@EP@@@AT@@@@U@@@@D@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BX@@@@Q@@@@@@@@@D,@@@BS@@@@0@@@@L@@@@C@@@@@0@@@@JX@@@@A@@@@@@@@@@@@@@@@@@@@E@@@@AT@@@@U@@@@D0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A''@@@@5P@@@L,@@@@&amp;@@@@@@@@@@@@@@A@@@@@*P@@@L@@@@C@@@@@-0@@@@H@@@@@@@@@@@@@@@@@@@@G@@@@C0@@@@(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@1@@@@LP@@@@ @@@@@@@@@I(@@@CU@@@@5P@@@JD@@@@@@@@@@@@@@@@@@@@G@@@@V@@@@G @@@@&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@HP@@@C*@@@@: @@@HP@@@@@@@@@SP@@@MT@@@CU@@@@5P@@@D\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@A@@@@) @@@MT@@@CU@@@@.0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BJ@@@@: @@@N(@@@BJ@@@@@@@@@@@@@@@.@@@@5@@@@MT@@@CU@@@@Y @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H(@@@C*@@@@: @@@H(@@@@@@@@@@@@@@@@@@@BF@@@@5P@@@MT@@@B[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@@@@@@@@@@@AT@@@B.@@@@20@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BD@@@@: @@@N(@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@CD@@@@1@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin15	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin15.png'&gt;	&lt;md5sum: #[79 53 36 133 236 34 208 76 154 176 34 90 112 215 135 20]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@TP@@@ED@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CX@@@A @@@@X@@@@CX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@Q0@@@C0@@@@G@@@@@@@@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@@@@@@AT@@@A$@@@@[0@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CX@@@AJ@@@@R @@@B&lt;@@@@@@@@@@@@@@@@@@@@8@@@@X@@@@F@@@@@8@@@@@@@@@@@@@@@@@@@@W@@@@GT@@@A5@@@@R @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H0@@@D(@@@AJ@@@@R @@@A@@@@@@@@@@@@@@@C @@@A @@@@X@@@@C @@@@@@@@@@@@@@A$@@@A5@@@@]P@@@GT@@@@6@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@PP@@@D(@@@AJ@@@@N @@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@V0@@@GT@@@A5@@@@Y0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@R @@@D(@@@AJ@@@@F0@@@@@@@@@6@@@@X@@@@F@@@@@6@@@@@@@@@B(@@@A5@@@@]P@@@GT@@@@''@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@!@@@@F@@@@@H@@@@@@@@@@@@@@@@@@@@8@@@@R @@@D(@@@@5@@@@@@@@@@4@@@AQ@@@@TP@@@@4@@@@@@@@@R@@@@GT@@@A5@@@@V @@@@@@@@@@@@@@@@@@@@T@@@AA@@@@X0@@@B4@@@@@@@@@@@@@@@@@@@@A@@@@L0@@@CT@@@@5@@@@K0@@@AH@@@@@@@@@@@@@@@4@@@AG@@@@R @@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@]P@@@GT@@@@.@@@@@@@@@@@@@@@.@@@@^ @@@H(@@@BJ@@@@!@@@@@H@@@@@@@@@@@@@@@@@@@@.@@@@MP@@@CT@@@@5@@@@MP@@@B$@@@@U@@@@@@@@@@X@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@BP@@@@@@@@@Y@@@@Y0@@@H(@@@BJ@@@@" @@@H(@@@A2@@@@@P@@@@@@@@@@@@@@@@@@@@$@@@@*@@@@MP@@@CT@@@@5@@@@MP@@@CT@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@HP@@@BJ@@@@" @@@H(@@@BI@@@@V@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@JP@@@CT@@@@5@@@@MP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@" @@@H(@@@BJ@@@@[@@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@B@@@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A@@@@@X0@@@C@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@F0@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!P@@@J@@@@B @@@@(@@@@J@@@@B @@@@(@@@@HT@@@@[@@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BE@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@!P@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@A0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@EP@@@A/@@@@O0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B@@@@@(@@@@J@@@@B @@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@-P@@@KT@@@B5@@@@#P@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@A @@@@(@@@@J@@@@B @@@@(@@@@J@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@B5@@@@-P@@@KT@@@B5@@@@-@@@@I@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@J@@@@B @@@@(@@@@J@@@@A0@@@@H@@@@@@@@@D0@@@B0@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BP@@@@P@@@@@@@@@DX@@@BJ@@@@-P@@@KT@@@B5@@@@-P@@@I4@@@@A@@@@@@@@@@@@@@@@@@@@B @@@@(@@@@J@@@@BP@@@@L@@@@@@@@@@@@@@FD@@@C5@@@@=P@@@GL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A!@@@@2 @@@L@@@@@$@@@@@@@@@@@@@@@&lt;@@@@(@@@@KT@@@B5@@@@+@@@@@H@@@@@@@@@@@@@@@@@@@@C@@@@A0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@/P@@@OT@@@C5@@@@%0@@@@@@@@@_@@@@/@@@@K0@@@@_@@@@@@@@@IH@@@CJ@@@@2 @@@I$@@@@@@@@@@@@@@@@@@@@F@@@@T0@@@GH@@@@;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@EH@@@C5@@@@=P@@@OT@@@AX@@@@@@@@@G8@@@C @@@@8@@@@G8@@@@@@@@@RP@@@L(@@@CJ@@@@2 @@@DL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@50@@@OT@@@C5@@@@/0@@@@D@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@A@@@@'' @@@L(@@@CJ@@@@,P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@C5@@@@=P@@@OP@@@@5@@@@@@@@@@@@@@BD@@@@8@@@@N@@@@BD@@@@@@@@@@@@@@@,@@@@2P@@@L(@@@CJ@@@@XP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;0@@@OT@@@C5@@@@0@@@@@@@@@@@@@@@@@@@@HP@@@C @@@@8@@@@HP@@@@@@@@@@@@@@@@@@@B@@@@@2 @@@L(@@@BS@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AO@@@@:P@@@MH@@@@+@@@@@@@@@@@@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@@@@@@@@@@@AP@@@B%@@@@0@@@@DD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A&gt;@@@@8@@@@N@@@@A&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B&lt;@@@@/@@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin16	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin16.png'&gt;	&lt;md5sum: #[148 244 129 6 148 220 182 105 17 165 171 84 229 113 165 109]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@Q0@@@D\@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@AU@@@@UP@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@OP@@@CP@@@@F@@@@@@@@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@@@@@@AL@@@A[@@@@YP@@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@A@@@@@P@@@@B @@@@@@@@@@@@@@@@@@@@2@@@@UP@@@ET@@@@2@@@@@@@@@@@@@@@@@@@@T0@@@F(@@@A*@@@@P0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G0@@@D@@@@A@@@@@P@@@@@8@@@@@@@@@@@@@@CH@@@AU@@@@UP@@@CH@@@@@@@@@@@@@@A\@@@A*@@@@Z @@@F(@@@@1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@N@@@@D@@@@A@@@@@L @@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@T0@@@F(@@@A*@@@@WP@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@P@@@@D@@@@A@@@@@E0@@@@@@@@@0@@@@UP@@@ET@@@@0@@@@@@@@@BX@@@A*@@@@Z @@@F(@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@@Z@@@@D0@@@@D@@@@@@@@@@@@@@@@@@@@0@@@@P@@@@D@@@@@.@@@@@@@@@@0@@@AG@@@@Q0@@@@0@@@@@@@@@PP@@@F(@@@A*@@@@T @@@@@@@@@@@@@@@@@@@@T@@@@=@@@@W@@@@B(@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@B(@@@@*@@@@IP@@@@8@@@@@@@@@@@@@@@0@@@@=@@@@P@@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@Z @@@F(@@@@*@@@@@@@@@@@@@@@+@@@@\P@@@H@@@@B@@@@@^ @@@@H@@@@@@@@@@@@@@@@@@@@$@@@@J @@@B(@@@@*@@@@J @@@B@@@@@P@@@@@@@@@@T@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@B@@@@@@@@@@X@@@@X@@@@H@@@@B@@@@@ @@@@H@@@@A*@@@@@P@@@@@@@@@@@@@@@@@@@@\@@@@!@@@@J @@@B(@@@@*@@@@J @@@B(@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@G(@@@B@@@@@ @@@@H@@@@A?@@@@TP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@HP@@@B(@@@@*@@@@J @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@ @@@@H@@@@B@@@@@Y@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@A(@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@&lt;@@@@W@@@@B4@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@DP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@EP@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@%P@@@G0@@@@Q@@@@EP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@@%P@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@_@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@D&lt;@@@A(@@@@N0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@* @@@J(@@@B*@@@@!P@@@BT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@B*@@@@* @@@J(@@@B*@@@@*P@@@H\@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@B(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BL@@@@O@@@@@@@@@DH@@@BB@@@@* @@@J(@@@B*@@@@* @@@IL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E4@@@C*@@@@: @@@F8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A]@@@@0@@@@K\@@@@#@@@@@@@@@@@@@@@9@@@@% @@@J(@@@B*@@@@( @@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-P@@@N(@@@C*@@@@$@@@@@@@@@@]@@@@,0@@@KL@@@@]@@@@@@@@@H,@@@C@@@@@0@@@@ID@@@@@@@@@@@@@@@@@@@@F@@@@S @@@F,@@@@7@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D8@@@C*@@@@: @@@N(@@@AT@@@@@@@@@G @@@CU@@@@5P@@@G @@@@@@@@@QP@@@L@@@@C@@@@@0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@3 @@@N(@@@C*@@@@-0@@@@D@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@A@@@@% @@@L@@@@C@@@@@*P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F,@@@C*@@@@: @@@N$@@@@2@@@@@@@@@@@@@@A=@@@@5P@@@MT@@@A=@@@@@@@@@@@@@@@)@@@@/0@@@L@@@@C@@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@N(@@@C*@@@@.@@@@@@@@@@@@@@@@@@@@G4@@@CU@@@@5P@@@G4@@@@@@@@@@@@@@@@@@@A9@@@@0@@@@L@@@@BK@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@70@@@L$@@@@)@@@@@@@@@@@@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@@@@@@@@@@@AL@@@B]@@@@-0@@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@5P@@@MT@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@B3@@@@,0@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin17	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin17.png'&gt;	&lt;md5sum: #[77 140 38 6 0 173 144 31 134 135 36 157 10 187 155 197]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@O @@@C8@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@AJ@@@@R @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@L0@@@B,@@@@E@@@@@@@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@@@@@@AD@@@AR@@@@V0@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BX@@@@5@@@@MP@@@BD@@@@@@@@@@@@@@@@@@@@,@@@@R @@@D(@@@@,@@@@@@@@@@@@@@@@@@@@R0@@@F@@@@A @@@@OP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@FP@@@CT@@@@5@@@@MP@@@@,@@@@@@@@@@@@@@B0@@@AJ@@@@R @@@B0@@@@@@@@@@@@@@AT@@@A @@@@X@@@@F@@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@K0@@@CT@@@@5@@@@JP@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@R0@@@F@@@@A @@@@U@@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@MP@@@CT@@@@5@@@@D0@@@@@@@@@*@@@@R @@@D(@@@@*@@@@@@@@@BL@@@A @@@@X@@@@F@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@T@@@@C0@@@@D@@@@@@@@@@@@@@@@@@@@(@@@@MP@@@CT@@@@&amp;@@@@@@@@@@(@@@@&gt;@@@@O @@@@(@@@@@@@@@N0@@@F@@@@A @@@@R @@@@@@@@@@@@@@@@@@@@P@@@@8@@@@U@@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@G @@@B@@@@@ @@@@G@@@@@,@@@@@@@@@@@@@@@(@@@@3@@@@MP@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-@@@@X@@@@F@@@@@&amp;@@@@@@@@@@@@@@@''@@@@Y0@@@GT@@@A5@@@@[0@@@@D@@@@@@@@@@@@@@@@@@@@\@@@@H@@@@B@@@@@ @@@@H@@@@A @@@@L@@@@@@@@@@P@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@B@@@@@@@@@@V@@@@V@@@@GT@@@A5@@@@]P@@@GT@@@A!@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@Y@@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@G@@@@A5@@@@]P@@@GT@@@A5@@@@R @@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@FP@@@B@@@@@ @@@@H@@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@]P@@@GT@@@A5@@@@V0@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@AP@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@U@@@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@B@@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\0@@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@" @@@GL@@@@H@@@@B @@@@(@@@@J@@@@B @@@@(@@@@J@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A3@@@@" @@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@\0@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AV@@@@,@@@@GH@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@D,@@@A"@@@@N@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@6@@@@/0@@@OT@@@C5@@@@=P@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]@@@@(@@@@J@@@@B @@@@_P@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@''@@@@OP@@@C5@@@@=P@@@OT@@@C*@@@@D0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@B @@@@(@@@@J@@@@B @@@@''0@@@G&lt;@@@@\@@@@@@@@@@@@@@@@@@@@@P@@@L,@@@C5@@@@=P@@@OT@@@C5@@@@.@@@@B4@@@@@@@@@D @@@B @@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BD@@@@N@@@@@@@@@C8@@@A:@@@@(@@@@J@@@@B @@@@(@@@@H,@@@@A@@@@@@@@@@@@@@@C@@@@:P@@@OT@@@C5@@@@6@@@@EH@@@@@@@@@@@@@@E$@@@C @@@@8@@@@F$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AW@@@@-P@@@J0@@@@!@@@@@@@@@@@@@@@5@@@@#P@@@J@@@@B @@@@&amp;@@@@@H@@@@@@@@@@@@@@@@@@@AP@@@@,@@@@GP@@@@I@@@@@@@@@@@@@@@@@@@@+P@@@N@@@@C @@@@" @@@@@@@@@\@@@@* @@@J(@@@@\@@@@@@@@@HL@@@B5@@@@-P@@@H$@@@@@@@@@@@@@@@@@@@@F@@@@RP@@@FP@@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D,@@@C @@@@8@@@@N@@@@AQ@@@@@@@@@GH@@@CJ@@@@2 @@@GH@@@@@@@@@PP@@@KT@@@B5@@@@-P@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@1P@@@N@@@@C @@@@+0@@@@D@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@A@@@@#P@@@KT@@@B5@@@@''0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F\@@@C @@@@8@@@@M&lt;@@@@0@@@@@@@@@@@@@@A7@@@@2 @@@L(@@@A7@@@@@@@@@@@@@@@''@@@@-@@@@KT@@@B5@@@@U0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#P@@@N@@@@C @@@@,@@@@@@@@@@@@@@@@@@@@G\@@@CJ@@@@2 @@@G\@@@@@@@@@@@@@@@@@@@A2@@@@-P@@@KT@@@BC@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@5P@@@L@@@@@(@@@@@@@@@@@@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@@@@@@@@@@@AH@@@BT@@@@+@@@@C(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A2@@@@2 @@@L(@@@A2@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@B*@@@@* @@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin18	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin18.png'&gt;	&lt;md5sum: #[154 199 236 29 149 57 154 10 86 2 38 244 110 138 162 48]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@M @@@CX@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@A@@@@@P@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@J@@@@BH@@@@D@@@@@@@@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@@@@@@@&lt;@@@AI@@@@TP@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@*@@@@J @@@A,@@@@@@@@@@@@@@@@@@@@&amp;@@@@P@@@@D@@@@@&amp;@@@@@@@@@@@@@@@@@@@@P0@@@ET@@@AU@@@@M @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B(@@@@*@@@@J @@@@$@@@@@@@@@@@@@@BX@@@A@@@@@P@@@@BX@@@@@@@@@@@@@@AH@@@AU@@@@UP@@@ET@@@@''@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@IP@@@B(@@@@*@@@@HP@@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@P @@@ET@@@AU@@@@R0@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@J @@@B(@@@@*@@@@C0@@@@@@@@@$@@@@P@@@@D@@@@@$@@@@@@@@@A&lt;@@@AU@@@@UP@@@ET@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@M@@@@B @@@@D@@@@@@@@@@@@@@@@@@@@ @@@@J @@@B(@@@@^@@@@@@@@@@$@@@@6@@@@M @@@@$@@@@@@@@@M@@@@ET@@@AU@@@@P @@@@@@@@@@@@@@@@@@@@P@@@@2@@@@S@@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@AT@@@@U@@@@D0@@@@\@@@@@@@@@@@@@@@ @@@@(@@@@J @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@UP@@@ET@@@@"@@@@@@@@@@@@@@@#@@@@W @@@F(@@@A*@@@@YP@@@@D@@@@@@@@@@@@@@@@@@@@R@@@@EP@@@AT@@@@U@@@@EP@@@A@@@@@H@@@@@@@@@@L@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@A0@@@@@@@@@T@@@@S0@@@F(@@@A*@@@@Z @@@F(@@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@Q@@@@EP@@@AT@@@@U@@@@EP@@@AT@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@FT@@@A*@@@@Z @@@F(@@@A*@@@@P0@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@D@@@@AT@@@@U@@@@EP@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@Z @@@F(@@@A*@@@@T0@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@@4@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@1@@@@S@@@@BT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z @@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A*@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@Z @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AR@@@@*@@@@F4@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@DX@@@A[@@@@M@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@-0@@@N(@@@C*@@@@: @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@%P@@@IT@@@BU@@@@]@@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@%P@@@N$@@@C*@@@@: @@@N(@@@C @@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@BU@@@@%P@@@IT@@@BU@@@@%@@@@G\@@@@Z@@@@@@@@@@@@@@@@@@@@@P@@@LH@@@C*@@@@: @@@N(@@@C*@@@@+0@@@B,@@@@@@@@@DP@@@BX@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A&lt;@@@@M@@@@@@@@@C(@@@A2@@@@%P@@@IT@@@BU@@@@%P@@@HD@@@@A@@@@@@@@@@@@@@@C@@@@70@@@N(@@@C*@@@@3 @@@D8@@@@@@@@@@@@@@EP@@@CU@@@@5P@@@FP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AR@@@@* @@@JH@@@@_@@@@@@@@@@@@@@@2@@@@ 0@@@IT@@@BU@@@@# @@@@H@@@@@@@@@@@@@@@@@@@AL@@@@*@@@@F&lt;@@@@H@@@@@@@@@@@@@@@@@@@@)P@@@MT@@@CU@@@@ 0@@@@@@@@@Z@@@@(P@@@JD@@@@Z@@@@@@@@@G,@@@B*@@@@* @@@HD@@@@@@@@@@@@@@@@@@@@E@@@@Q@@@@E4@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D\@@@CU@@@@5P@@@MT@@@AM@@@@@@@@@F0@@@C@@@@@0@@@@F0@@@@@@@@@OP@@@J(@@@B*@@@@* @@@C$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@.0@@@MT@@@CU@@@@) @@@@D@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@A@@@@!P@@@J(@@@B*@@@@%P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@FH@@@CU@@@@5P@@@MP@@@@.@@@@@@@@@@@@@@A1@@@@0@@@@L@@@@A1@@@@@@@@@@@@@@@%@@@@*P@@@J(@@@B*@@@@TP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@! @@@MT@@@CU@@@@)0@@@@@@@@@@@@@@@@@@@GD@@@C@@@@@0@@@@GD@@@@@@@@@@@@@@@@@@@A+@@@@* @@@J(@@@A;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@20@@@K\@@@@&amp;@@@@@@@@@@@@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@@@@@@@@@@@AD@@@BK@@@@( @@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A,@@@@0@@@@L@@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@B!@@@@(P@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin19	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin19.png'&gt;	&lt;md5sum: #[30 223 135 192 160 12 92 161 196 129 117 228 207 110 239 113]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@K@@@@B0@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@5@@@@MP@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@G @@@A(@@@@C@@@@@@@@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@@@@@@@4@@@A@@@@@Q0@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@@ @@@@H@@@@AP@@@@@@@@@@@@@@@@@@@@_@@@@MP@@@CT@@@@_@@@@@@@@@@@@@@@@@@@@N @@@D(@@@AJ@@@@K0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@B@@@@@ @@@@H@@@@@\@@@@@@@@@@@@@@A&lt;@@@@5@@@@MP@@@A&lt;@@@@@@@@@@@@@@A@@@@AJ@@@@R @@@D(@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@G@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@N @@@D(@@@AJ@@@@PP@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@H@@@@B@@@@@ @@@@C@@@@@@@@@@^@@@@MP@@@CT@@@@^@@@@@@@@@A,@@@AJ@@@@R @@@D(@@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@F@@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@H@@@@B@@@@@W@@@@@@@@@@\@@@@,@@@@K@@@@@\@@@@@@@@@K @@@D(@@@AJ@@@@NP@@@@@@@@@@@@@@@@@@@@L@@@@.@@@@QP@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@B @@@@(@@@@J@@@@BP@@@@L@@@@@@@@@@@@@@@X@@@@^@@@@H@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@R @@@D(@@@@]@@@@@@@@@@@@@@@ @@@@UP@@@F@@@@A @@@@V0@@@@D@@@@@@@@@@@@@@@@@@@@I@@@@B @@@@(@@@@J@@@@B @@@@ @@@@D@@@@@@@@@@L@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@A @@@@@@@@@R@@@@R@@@@F@@@@A @@@@X@@@@F@@@@AO@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@H@@@@B @@@@(@@@@J@@@@B @@@@(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@E0@@@A @@@@X@@@@F@@@@A @@@@OP@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B@@@@@(@@@@J@@@@B @@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@X@@@@F@@@@A @@@@R0@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@X@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-@@@@QP@@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@3@@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@=P@@@L0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@XP@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@]P@@@FD@@@CL@@@@=P@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@3@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A!@@@@]P@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@XP@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AN@@@@(P@@@F$@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@D@@@@AT@@@@L@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@1@@@@+0@@@N@@@@C @@@@8@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@" @@@H(@@@BJ@@@@[@@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@# @@@M&lt;@@@C @@@@8@@@@N@@@@CV@@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@BJ@@@@" @@@H(@@@BJ@@@@"P@@@F8@@@@X@@@@@@@@@@@@@@@@@@@@@P@@@K$@@@C @@@@8@@@@N@@@@C @@@@*@@@@B$@@@@@@@@@D@@@@BP@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A4@@@@M@@@@@@@@@CX@@@A*@@@@" @@@H(@@@BJ@@@@" @@@G @@@@A@@@@@@@@@@@@@@@C@@@@5P@@@N@@@@C @@@@1 @@@D,@@@@@@@@@@@@@@E@@@@CJ@@@@2 @@@E&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AM@@@@(@@@@I @@@@]@@@@@@@@@@@@@@@.@@@@^ @@@H(@@@BJ@@@@!@@@@@H@@@@@@@@@@@@@@@@@@@AI@@@@(P@@@F(@@@@H@@@@@@@@@@@@@@@@@@@@''@@@@L(@@@CJ@@@@_@@@@@@@@@@Y@@@@&amp;@@@@I @@@@Y@@@@@@@@@GL@@@B @@@@(@@@@G$@@@@@@@@@@@@@@@@@@@@E@@@@O0@@@E\@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DL@@@CJ@@@@2 @@@L(@@@AI@@@@@@@@@FX@@@B5@@@@-P@@@FX@@@@@@@@@N @@@J@@@@B @@@@(@@@@CT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@,P@@@L(@@@CJ@@@@'' @@@@D@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@A@@@@_P@@@J@@@@B @@@@#P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E4@@@CJ@@@@2 @@@L$@@@@,@@@@@@@@@@@@@@A*@@@@-P@@@KT@@@A*@@@@@@@@@@@@@@@#@@@@''0@@@J@@@@B @@@@SP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@L(@@@CJ@@@@'' @@@@@@@@@@@@@@@@@@@F(@@@B5@@@@-P@@@F(@@@@@@@@@@@@@@@@@@@A%@@@@(@@@@J@@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AA@@@@0@@@@J4@@@@$@@@@@@@@@@@@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@@@@@@@@@@@A@@@@BC@@@@&amp;@@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A&amp;@@@@-P@@@KT@@@A&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@BX@@@@&amp;@@@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin2	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin2.png'&gt;	&lt;md5sum: #[38 243 25 201 152 122 245 92 117 37 27 157 121 61 11 205]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@1@@@@LP@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@HP@@@C*@@@@: @@@HP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@20@@@J8@@@@U@@@@@@@@@@@@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I,@@@CU@@@@5P@@@HX@@@@@@@@@@@@@@@@@@@BJ@@@@: @@@N(@@@BJ@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y @@@MT@@@CU@@@@5@@@@B8@@@@@@@@@@@@@@H(@@@C*@@@@: @@@H(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@.0@@@MT@@@CU@@@@) @@@@D@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AG@@@@5P@@@MT@@@CU@@@@SP@@@@@@@@BD@@@@: @@@N(@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C8@@@A8@@@@V@@@@@\@@@@@@@@@@@@@@@@@@@B!@@@@5P@@@MT@@@BZ@@@@@@@@@B@@@@CD@@@@1@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@J@@@@C0@@@@\@@@@@@@@@@@@@@@@@@@@B@@@@-0@@@L@@@@C@@@@@*P@@@D@@@@@@@@@@@@@@@BX@@@CK@@@@5P@@@F\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@D0@@@AT@@@@U@@@@E@@@@@@@@@@@@@@@@@@@@@D@@@B&amp;@@@@0@@@@L@@@@C@@@@@0@@@@IL@@@AK@@@@@@@@@AD@@@@&amp;@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@D@@@@AT@@@@U@@@@EP@@@AT@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@BD@@@BY@@@@/0@@@L@@@@C@@@@@0@@@@L@@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@AP@@@@U@@@@EP@@@AT@@@@U@@@@CP@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@% @@@L@@@@C@@@@@0@@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@EP@@@AT@@@@U@@@@D@@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@P0@@@GT@@@AZ@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@C0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@#P@@@J(@@@B*@@@@* @@@J(@@@B*@@@@* @@@H4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H0@@@B(@@@@*@@@@J @@@B(@@@@*@@@@J @@@BL@@@BM@@@@* @@@J(@@@B*@@@@* @@@J(@@@B*@@@@#P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@J @@@B(@@@@*@@@@J @@@B(@@@@*@@@@H0@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@4@@@@Z0@@@DX@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@''@@@@E @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@]@@@@IT@@@BU@@@@%P@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@P@@@@D@@@@A@@@@@L @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@W0@@@IP@@@BU@@@@%P@@@IT@@@BO@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@A@@@@@P@@@@D@@@@A@@@@@P@@@@CL@@@@K@@@@@@@@@@@@@@@@@@@@@P@@@G,@@@BU@@@@%P@@@IT@@@BU@@@@\@@@@A,@@@@@@@@@B @@@A\@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@G@@@@@@@@@A$@@@@1@@@@P@@@@D@@@@A@@@@@P@@@@C\@@@@@@@@@@@@@@@@@@@@B@@@@# @@@IT@@@BU@@@@ 0@@@CH@@@@@@@@@@@@@@CL@@@B@@@@@ @@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@UP@@@ED@@@@O@@@@@@@@@@@@@@@U@@@@N@@@@D@@@@A@@@@@OP@@@@D@@@@@@@@@@@@@@@@@@@@0@@@@Z0@@@D\@@@@E@@@@@@@@@@@@@@@@@@@@X0@@@H@@@@B@@@@@S0@@@@@@@@@O@@@@VP@@@E$@@@@O@@@@@@@@@C4@@@AU@@@@UP@@@D@@@@@@@@@@@@@@@@@@@@@B@@@@GP@@@B @@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B,@@@B@@@@@ @@@@H@@@@@.@@@@@@@@@C0@@@A*@@@@Z @@@C0@@@@@@@@@G0@@@ET@@@AU@@@@UP@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@\@@@@H@@@@B@@@@@Y@@@@@D@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@@@@@@P @@@ET@@@AU@@@@R0@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C,@@@B@@@@@ @@@@G&lt;@@@@\@@@@@@@@@@@@@@@&gt;@@@@Z @@@F(@@@@&gt;@@@@@@@@@@@@@@@R@@@@UP@@@ET@@@AU@@@@JP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TP@@@H@@@@B@@@@@Y@@@@@@@@@@@@@@@@@@@@C8@@@A*@@@@Z @@@C8@@@@@@@@@@@@@@@@@@@@6@@@@UP@@@ET@@@@&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@^ @@@F8@@@@W@@@@@@@@@@@@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@@@@@@@@@@@@ @@@AE@@@@TP@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@Z @@@F(@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@AY@@@@VP@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin20	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin20.png'&gt;	&lt;md5sum: #[75 225 64 91 192 72 97 162 58 11 20 245 194 163 238 149]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@H0@@@BL@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@*@@@@J @@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@E@@@@AD@@@@B@@@@@@@@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@@@@@@@,@@@@7@@@@OP@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@U@@@@EP@@@@4@@@@@@@@@@@@@@@@@@@@Y@@@@J @@@B(@@@@Y@@@@@@@@@@@@@@@@@@@@L @@@D@@@@A@@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@AT@@@@U@@@@EP@@@@T@@@@@@@@@@@@@@A$@@@@*@@@@J @@@A$@@@@@@@@@@@@@@@8@@@A@@@@@P@@@@D@@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@D @@@AT@@@@U@@@@D@@@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@L @@@D@@@@A@@@@@N@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@EP@@@AT@@@@U@@@@B@@@@@@@@@@X@@@@J @@@B(@@@@X@@@@@@@@@A\@@@A@@@@@P@@@@D@@@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@EP@@@AT@@@@O@@@@@@@@@@X@@@@#@@@@H0@@@@X@@@@@@@@@I0@@@D@@@@A@@@@@LP@@@@@@@@@@@@@@@@@@@@L@@@@(@@@@OP@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@T@@@@EP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@P@@@@D@@@@@Y@@@@@@@@@@@@@@@\@@@@R0@@@ET@@@AU@@@@TP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@AP@@@@@@@@@P@@@@P@@@@ET@@@AU@@@@UP@@@ET@@@AF@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@ED@@@AU@@@@UP@@@ET@@@AU@@@@M @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@UP@@@ET@@@AU@@@@P @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@OP@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@00@@@N(@@@C*@@@@: @@@N(@@@C*@@@@: @@@LL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@F(@@@A*@@@@Z @@@F(@@@A*@@@@Z @@@E @@@CC@@@@: @@@N(@@@C*@@@@: @@@N(@@@C*@@@@00@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@@Z @@@F(@@@A*@@@@Z @@@F(@@@A*@@@@V@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AJ@@@@&amp;P@@@FL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@C0@@@AN@@@@KP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@) @@@MT@@@CU@@@@5P@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@ @@@@H@@@@B@@@@@Y@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@!0@@@MP@@@CU@@@@5P@@@MT@@@CL@@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@B@@@@@ @@@@H@@@@B@@@@@_0@@@FX@@@@V@@@@@@@@@@@@@@@@@@@@@P@@@K@@@@CU@@@@5P@@@MT@@@CU@@@@(@@@@B\@@@@@@@@@C0@@@BL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A,@@@@L@@@@@@@@@CH@@@A"@@@@ @@@@H@@@@B@@@@@ @@@@F&lt;@@@@A@@@@@@@@@@@@@@@C@@@@20@@@MT@@@CU@@@@/@@@@D\@@@@@@@@@@@@@@D0@@@C@@@@@0@@@@E(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@%P@@@H8@@@@[@@@@@@@@@@@@@@@+@@@@\P@@@H@@@@B@@@@@^ @@@@H@@@@@@@@@@@@@@@@@@@AE@@@@&amp;P@@@FT@@@@H@@@@@@@@@@@@@@@@@@@@%@@@@L@@@@C@@@@@] @@@@@@@@@W@@@@#0@@@H&lt;@@@@W@@@@@@@@@F0@@@BU@@@@%P@@@GD@@@@@@@@@@@@@@@@@@@@E@@@@N0@@@E@@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@0@@@@L@@@@AE@@@@@@@@@F@@@@B*@@@@* @@@F@@@@@@@@@@M @@@IT@@@BU@@@@%P@@@CH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@*P@@@L@@@@C@@@@@% @@@@D@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@A@@@@]@@@@IT@@@BU@@@@ 0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E @@@C@@@@@0@@@@K&lt;@@@@)@@@@@@@@@@@@@@A$@@@@* @@@J(@@@A$@@@@@@@@@@@@@@@ @@@@%@@@@IT@@@BU@@@@Q0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^P@@@L@@@@C@@@@@%0@@@@@@@@@@@@@@@@@@@FP@@@B*@@@@* @@@FP@@@@@@@@@@@@@@@@@@@A^@@@@%P@@@IT@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@-0@@@JT@@@@"@@@@@@@@@@@@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@@@@@@@@@@@@&lt;@@@A:@@@@# @@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A @@@@* @@@J(@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@BO@@@@#0@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin21	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin21.png'&gt;	&lt;md5sum: #[200 27 50 26 192 76 12 223 206 166 19 120 44 56 172 49]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F0@@@A,@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@B @@@@ @@@@A@@@@@@@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@@@@@@@$@@@@.@@@@L0@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@@@@@@S@@@@H@@@@B@@@@@S@@@@@@@@@@@@@@@@@@@@J @@@CT@@@@5@@@@HP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@(@@@@J@@@@B @@@@H@@@@@@@@@@@@@@AL@@@@ @@@@H@@@@AL@@@@@@@@@@@@@@@,@@@@5@@@@MP@@@CT@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@@(@@@@J@@@@B@@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@JP@@@CT@@@@5@@@@K0@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@B @@@@(@@@@J@@@@A@@@@@@@@@@R@@@@H@@@@B@@@@@R@@@@@@@@@AL@@@@5@@@@MP@@@CT@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@BZ@@@@\@@@@@$@@@@@@@@@@@@@@@@@@@@H@@@@B @@@@(@@@@G@@@@@@@@@@P@@@@[@@@@F0@@@@P@@@@@@@@@HP@@@CT@@@@5@@@@JP@@@@@@@@@@@@@@@@@@@@L@@@@#@@@@MP@@@A @@@@@@@@@@@@@@@@@@@@C@@@@:P@@@OT@@@C5@@@@6@@@@EH@@@@@@@@@@@@@@@H@@@@J@@@@B @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@MP@@@CT@@@@U@@@@@@@@@@@@@@@Y@@@@PP@@@D(@@@AJ@@@@Q0@@@@D@@@@@@@@@@@@@@@D@@@CT@@@@=P@@@OT@@@C5@@@@=P@@@K,@@@A_@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@A@@@@@@@@@@N@@@@M0@@@D(@@@AJ@@@@R @@@D(@@@@=@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@CC@@@@=@@@@OT@@@C5@@@@=P@@@OT@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@D\@@@AJ@@@@R @@@D(@@@AJ@@@@K0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@6@@@@/0@@@OT@@@C5@@@@=P@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@R @@@D(@@@AJ@@@@N @@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@U @@@IX@@@A2@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@MP@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@. @@@N@@@@C @@@@8@@@@N@@@@C @@@@8@@@@K(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@E@@@@B:@@@@8@@@@N@@@@C @@@@8@@@@N@@@@C @@@@. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@X@@@@F@@@@A @@@@X@@@@F@@@@A @@@@T@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AG@@@@$P@@@E8@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C\@@@AH@@@@JP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@'' @@@L(@@@CJ@@@@2 @@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@]P@@@GT@@@A5@@@@V0@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@ @@@@L$@@@CJ@@@@2 @@@L(@@@CA@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@A5@@@@]P@@@GT@@@A5@@@@]P@@@E4@@@@T@@@@@@@@@@@@@@@@@@@@@P@@@J\@@@CJ@@@@2 @@@L(@@@CJ@@@@%0@@@BT@@@@@@@@@C @@@BD@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A$@@@@K@@@@@@@@@B4@@@AY@@@@]P@@@GT@@@A5@@@@]P@@@FT@@@@@@@@@@@@@@@@@@@@B@@@@0@@@@L(@@@CJ@@@@, @@@DL@@@@@@@@@@@@@@D @@@B5@@@@-P@@@ET@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AC@@@@" @@@HP@@@@Y@@@@@@@@@@@@@@@''@@@@Y0@@@GT@@@A5@@@@[0@@@@D@@@@@@@@@@@@@@@@@@@AB@@@@$P@@@F@@@@@G@@@@@@@@@@@@@@@@@@@@#@@@@KT@@@B5@@@@[0@@@@@@@@@V@@@@! @@@HX@@@@V@@@@@@@@@FP@@@BJ@@@@" @@@F @@@@@@@@@@@@@@@@@@@@D@@@@M @@@D$@@@@&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@B5@@@@-P@@@KT@@@AA@@@@@@@@@E(@@@B @@@@(@@@@E(@@@@@@@@@L @@@H(@@@BJ@@@@" @@@B8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@''0@@@KT@@@B5@@@@#P@@@@D@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@A@@@@[@@@@H(@@@BJ@@@@^P@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@EL@@@B5@@@@-P@@@KP@@@@''@@@@@@@@@@@@@@A^@@@@(@@@@J@@@@A^@@@@@@@@@@@@@@@^@@@@"P@@@H(@@@BJ@@@@P @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\ @@@KT@@@B5@@@@# @@@@@@@@@@@@@@@@@@@E8@@@B @@@@(@@@@E8@@@@@@@@@@@@@@@@@@@AW@@@@" @@@H(@@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@@@@+@@@@I,@@@@ @@@@@@@@@@@@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@@@@@@@@@@@@8@@@A1@@@@!@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AZ@@@@(@@@@J@@@@AZ@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@BF@@@@! @@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin22	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin22.png'&gt;	&lt;md5sum: #[138 217 82 221 102 111 168 220 14 111 54 32 226 158 46 243]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@D @@@AH@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@@@@@@@\@@@@$@@@@J@@@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@@@@@@@@@@@HP@@@B(@@@@*@@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@$@@@@*@@@@J @@@B(@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@HP@@@B(@@@@*@@@@IP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@&lt;@@@@*@@@@J @@@B(@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D0@@@BS@@@@Z0@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@R@@@@D @@@@L@@@@@@@@@F @@@B(@@@@*@@@@H@@@@@@@@@@@@@@@@@@@@@H@@@@^@@@@K @@@AT@@@@@@@@@@@@@@@@@@@@C@@@@70@@@N(@@@C*@@@@3 @@@D8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@J @@@B(@@@@Q@@@@@@@@@@@@@@@U@@@@N@@@@D@@@@A@@@@@OP@@@@D@@@@@@@@@@@@@@@D@@@CK@@@@: @@@N(@@@C*@@@@: @@@KL@@@A[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@@0@@@@@@@@@L@@@@L@@@@D@@@@A@@@@@P@@@@D@@@@@5@@@@@@@@@@@@@@@@@@@@@@@@@B @@@B:@@@@:P@@@N(@@@C*@@@@: @@@N(@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@C4@@@A@@@@@P@@@@D@@@@A@@@@@JP@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@-0@@@N(@@@C*@@@@: @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@P@@@@D@@@@A@@@@@L @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@T @@@H&lt;@@@A-@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@K @@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@,P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@5P@@@KD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q0@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@UP@@@D\@@@B1@@@@5P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@,P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AG@@@@UP@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@Q0@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AC@@@@" @@@E(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CD@@@AA@@@@IP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@% @@@L@@@@C@@@@@0@@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@Z @@@F(@@@A*@@@@T0@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@^ @@@K&lt;@@@C@@@@@0@@@@L@@@@B8@@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@A*@@@@Z @@@F(@@@A*@@@@Z @@@EP@@@@R@@@@@@@@@@@@@@@@@@@@@P@@@I&lt;@@@C@@@@@0@@@@L@@@@C@@@@@$@@@@BL@@@@@@@@@CP@@@A&lt;@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A\@@@@J@@@@@@@@@B$@@@AQ@@@@Z @@@F(@@@A*@@@@Z @@@E0@@@@@@@@@@@@@@@@@@@@B@@@@-0@@@L@@@@C@@@@@*P@@@D@@@@@@@@@@@@@@@DL@@@B*@@@@* @@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@ @@@@G(@@@@W@@@@@@@@@@@@@@@#@@@@W @@@F(@@@A*@@@@YP@@@@D@@@@@@@@@@@@@@@@@@@@&gt;@@@@" @@@E,@@@@G@@@@@@@@@@@@@@@@@@@@ 0@@@J(@@@B*@@@@ZP@@@@@@@@@T@@@@_P@@@G4@@@@T@@@@@@@@@E0@@@B@@@@@ @@@@FD@@@@@@@@@@@@@@@@@@@@D@@@@LP@@@DL@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C$@@@B*@@@@* @@@J(@@@@=@@@@@@@@@EP@@@BU@@@@%P@@@EP@@@@@@@@@K @@@H@@@@B@@@@@ @@@@B,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@%P@@@J(@@@B*@@@@!P@@@@D@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@A@@@@Y@@@@H@@@@B@@@@@\@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D8@@@B*@@@@* @@@J$@@@@%@@@@@@@@@@@@@@AX@@@@%P@@@IT@@@AX@@@@@@@@@@@@@@@\@@@@_0@@@H@@@@B@@@@@OP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z0@@@J(@@@B*@@@@!P@@@@@@@@@@@@@@@@@@@E @@@BU@@@@%P@@@E @@@@@@@@@@@@@@@@@@@AQ@@@@ @@@@H@@@@A]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@( @@@IH@@@@^@@@@@@@@@@@@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@@@@@@@@@@@@4@@@A(@@@@^ @@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AT@@@@%P@@@IT@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@A=@@@@_P@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin23	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin23.png'&gt;	&lt;md5sum: #[148 253 55 156 160 152 165 201 83 161 195 86 164 194 151 8]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@B@@@@@ @@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AO@@@@:P@@@L @@@@X@@@@@@@@@@@@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@@@@@@@@@@@@X@@@@[@@@@G @@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@KH@@@C5@@@@=P@@@I,@@@@@@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@@@@@@@@@@@FP@@@B@@@@@ @@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]P@@@OT@@@C5@@@@=@@@@CT@@@@@@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@\@@@@ @@@@H@@@@B@@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@50@@@OT@@@C5@@@@/0@@@@D@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@@@@@@FP@@@B@@@@@ @@@@G@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AR@@@@=P@@@OT@@@C5@@@@V@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@0@@@@ @@@@H@@@@B@@@@@K@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D$@@@BM@@@@Y0@@@@ @@@@@@@@@@@@@@@@@@@B9@@@@=P@@@OT@@@B1@@@@@@@@@@D@@@@H@@@@B@@@@@D@@@@@@@@@E@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@@@@@@@H@@@@Y@@@@I @@@AD@@@@@@@@@@@@@@@@@@@@C@@@@5P@@@N@@@@C @@@@1 @@@D,@@@@@@@@@@@@@@B0@@@C)@@@@=P@@@GX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@H@@@@B@@@@@M@@@@@@@@@@@@@@@R@@@@K0@@@CT@@@@5@@@@L0@@@@D@@@@@@@@@@@@@@@D@@@CB@@@@8@@@@N@@@@C @@@@8@@@@J,@@@AW@@@@@@@@@AL@@@@,@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@@0@@@@@@@@@J@@@@J@@@@CT@@@@5@@@@MP@@@CT@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@B\@@@B2@@@@70@@@N@@@@C @@@@8@@@@N@@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@CL@@@@5@@@@MP@@@CT@@@@5@@@@H @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@1@@@@+0@@@N@@@@C @@@@8@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@MP@@@CT@@@@5@@@@JP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@S @@@H$@@@A)@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@I @@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@*@@@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@2 @@@J @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@R @@@C8@@@B(@@@@2 @@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@R @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@O @@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@?@@@@  @@@EP@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B4@@@@;@@@@H @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@#P@@@KT@@@B5@@@@-P@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@X@@@@F@@@@A @@@@R0@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@\0@@@KP@@@B5@@@@-P@@@KT@@@B-@@@@C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@A @@@@X@@@@F@@@@A @@@@X@@@@D0@@@@Q@@@@@@@@@@@@@@@@@@@@@P@@@IX@@@B5@@@@-P@@@KT@@@B5@@@@"@@@@BD@@@@@@@@@CP@@@A4@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AT@@@@I@@@@@@@@@BT@@@AI@@@@X@@@@F@@@@A @@@@X@@@@EL@@@@@@@@@@@@@@@@@@@@B@@@@+@@@@KT@@@B5@@@@(@@@@C0@@@@@@@@@@@@@@C&lt;@@@B @@@@(@@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@@]P@@@F&lt;@@@@U@@@@@@@@@@@@@@@ @@@@UP@@@F@@@@A @@@@V0@@@@D@@@@@@@@@@@@@@@@@@@@;@@@@  @@@EX@@@@F@@@@@@@@@@@@@@@@@@@@_@@@@J@@@@B @@@@X0@@@@@@@@@S@@@@]@@@@GP@@@@S@@@@@@@@@EP@@@A5@@@@]P@@@E$@@@@@@@@@@@@@@@@@@@@C@@@@K@@@@C0@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CT@@@B @@@@(@@@@J@@@@@:@@@@@@@@@D8@@@BJ@@@@" @@@D8@@@@@@@@@J @@@GT@@@A5@@@@]P@@@B\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@#P@@@J@@@@B @@@@_P@@@@D@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@@@@@@V0@@@GT@@@A5@@@@Y0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D$@@@B @@@@(@@@@I&lt;@@@@#@@@@@@@@@@@@@@AQ@@@@" @@@H(@@@AQ@@@@@@@@@@@@@@@Y@@@@]P@@@GT@@@A5@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@YP@@@J@@@@B @@@@_P@@@@@@@@@@@@@@@@@@@ED@@@BJ@@@@" @@@ED@@@@@@@@@@@@@@@@@@@AJ@@@@]P@@@GT@@@AU@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@&amp;@@@@H$@@@@\@@@@@@@@@@@@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@@@@@@@@@@@@,@@@A_@@@@[0@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AN@@@@" @@@H(@@@AN@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@A4@@@@]@@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin3	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin3.png'&gt;	&lt;md5sum: #[13 220 48 211 26 134 238 79 241 167 97 172 105 37 95 13]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@/@@@@K0@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@G8@@@C @@@@8@@@@G8@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AA@@@@0@@@@JT@@@@T@@@@@@@@@@@@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@@@@@@@@@@@B,@@@CR@@@@:P@@@D&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IL@@@CJ@@@@2 @@@H@@@@@@@@@@@@@@@@@@@@BD@@@@8@@@@N@@@@BD@@@@@@@@@@@@@@@@@@@@0@@@@OT@@@C5@@@@&amp;0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@XP@@@L(@@@CJ@@@@2P@@@B0@@@@@@@@@@@@@@HP@@@C @@@@8@@@@HP@@@@@@@@@@@@@@CT@@@C4@@@@=P@@@OT@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@,P@@@L(@@@CJ@@@@'' @@@@D@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@A@@@@/0@@@OT@@@C5@@@@50@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AC@@@@2 @@@L(@@@CJ@@@@RP@@@@@@@@A&gt;@@@@8@@@@N@@@@A&gt;@@@@@@@@@E @@@C5@@@@=P@@@OT@@@AR@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C,@@@A2@@@@T0@@@@X@@@@@@@@@@@@@@@@@@@BY@@@@2 @@@L(@@@BR@@@@@@@@@A&lt;@@@B&lt;@@@@/@@@@A&lt;@@@@@@@@@%0@@@OT@@@C5@@@@/P@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@A0@@@@L@@@@@@@@@@@@@@@@@@@@B@@@@+@@@@KT@@@B5@@@@(@@@@C0@@@@@@@@@@@@@@BP@@@C@@@@@2 @@@FD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A3@@@@=P@@@OT@@@A!@@@@@@@@@@@@@@@C@@@@BP@@@@(@@@@J@@@@B @@@@@@@@@@@@@@@@@@@@D@@@B]@@@@-P@@@KT@@@B5@@@@-P@@@H(@@@AF@@@@@@@@@A@@@@@$@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@,@@@@D0@@@@@@@@@B@@@@A0@@@@(@@@@J@@@@B @@@@(@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@BP@@@@-@@@@KT@@@B5@@@@-P@@@KT@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@(@@@@J@@@@B @@@@(@@@@J@@@@A @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@#P@@@KT@@@B5@@@@-P@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B @@@@(@@@@J@@@@B@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@O0@@@F&lt;@@@AT@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@A0@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@!P@@@J@@@@B @@@@(@@@@J@@@@B @@@@(@@@@HT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@A,@@@BE@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@!P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F0@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@0@@@@X0@@@D@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@@ @@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@[@@@@H(@@@BJ@@@@" @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@MP@@@CT@@@@5@@@@JP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@V@@@@H$@@@BJ@@@@" @@@H(@@@BD@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@5@@@@MP@@@CT@@@@5@@@@MP@@@B(@@@@I@@@@@@@@@@@@@@@@@@@@@P@@@GH@@@BJ@@@@" @@@H(@@@BJ@@@@Y0@@@A$@@@@@@@@@BP@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@F@@@@@@@@@AT@@@@)@@@@MP@@@CT@@@@5@@@@MP@@@B8@@@@@@@@@@@@@@@@@@@@B@@@@!@@@@H(@@@BJ@@@@^ @@@B8@@@@@@@@@@@@@@B8@@@A5@@@@]P@@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@R @@@D\@@@@M@@@@@@@@@@@@@@@R@@@@K0@@@CT@@@@5@@@@L0@@@@D@@@@@@@@@@@@@@@@@@@@-@@@@X0@@@DD@@@@E@@@@@@@@@@@@@@@@@@@@V @@@GT@@@A5@@@@R@@@@@@@@@@M@@@@TP@@@ED@@@@M@@@@@@@@@CT@@@AJ@@@@R @@@C @@@@@@@@@@@@@@@@@@@@B@@@@F@@@@BD@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B\@@@A5@@@@]P@@@GT@@@@*@@@@@@@@@CX@@@A @@@@X@@@@CX@@@@@@@@@F0@@@D(@@@AJ@@@@R @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@Y0@@@GT@@@A5@@@@V0@@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@N @@@D(@@@AJ@@@@PP@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CX@@@A5@@@@]P@@@GT@@@@Y@@@@@@@@@@@@@@@8@@@@X@@@@F@@@@@8@@@@@@@@@@@@@@@P@@@@R @@@D(@@@AJ@@@@H0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R @@@GT@@@A5@@@@W@@@@@@@@@@@@@@@@@@@@C @@@A @@@@X@@@@C @@@@@@@@@@@@@@@@@@@@/@@@@R @@@D(@@@@6@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@[0@@@FP@@@@U@@@@@@@@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@@@@@@@\@@@@&lt;@@@@Q0@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@6@@@@X@@@@F@@@@@6@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@AQ@@@@TP@@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin4	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin4.png'&gt;	&lt;md5sum: #[92 9 195 196 144 131 53 153 239 3 182 62 232 132 198 22]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]@@@@,0@@@KL@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@G @@@CU@@@@5P@@@G @@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@-0@@@I4@@@@S@@@@@@@@@@@@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@@@@@@@@@@@B$@@@CI@@@@70@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H,@@@C@@@@@0@@@@G$@@@@@@@@@@@@@@@@@@@A=@@@@5P@@@MT@@@A=@@@@@@@@@@@@@@@@@@@@.@@@@N(@@@C*@@@@%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@L@@@@C@@@@@/0@@@B$@@@@@@@@@@@@@@G4@@@CU@@@@5P@@@G4@@@@@@@@@@@@@@CH@@@C)@@@@: @@@N(@@@A+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@*P@@@L@@@@C@@@@@% @@@@D@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@A@@@@-0@@@N(@@@C*@@@@3 @@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@0@@@@L@@@@C@@@@@QP@@@@@@@@A8@@@@5P@@@MT@@@A8@@@@@@@@@EP@@@C*@@@@: @@@N(@@@AN@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C\@@@A+@@@@S @@@@X@@@@@@@@@@@@@@@@@@@BQ@@@@0@@@@L@@@@BK@@@@@@@@@A4@@@B3@@@@,0@@@A4@@@@@@@@@$@@@@N(@@@C*@@@@-P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@( @@@J(@@@B*@@@@% @@@C$@@@@@@@@@@@@@@BL@@@B7@@@@0@@@@E4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A.@@@@: @@@N(@@@A]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@BS@@@@* @@@J(@@@B*@@@@* @@@HH@@@AB@@@@@@@@@@&lt;@@@@#@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@*@@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@BG@@@@*P@@@J(@@@B*@@@@* @@@J(@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@!P@@@J(@@@B*@@@@* @@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@N0@@@F @@@AO@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@_@@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@%P@@@G0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@EP@@@AD@@@A&lt;@@@@%P@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@EP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@DP@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@-@@@@W@@@@C0@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@Z@@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@Y@@@@H@@@@B@@@@@ @@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@J @@@B(@@@@*@@@@HP@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@TP@@@G&lt;@@@B@@@@@ @@@@H@@@@A:@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@*@@@@J @@@B(@@@@*@@@@J @@@BD@@@@G@@@@@@@@@@@@@@@@@@@@@P@@@F(@@@B@@@@@ @@@@H@@@@B@@@@@X@@@@A @@@@@@@@@B@@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@E@@@@@@@@@A@@@@@ @@@@J @@@B(@@@@*@@@@J @@@BP@@@@@@@@@@@@@@@@@@@@B@@@@^ @@@H@@@@B@@@@@\P@@@B,@@@@@@@@@@@@@@B(@@@A*@@@@Z @@@CH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@P@@@@C4@@@@L@@@@@@@@@@@@@@@N@@@@IP@@@B(@@@@*@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@W@@@@C4@@@@E@@@@@@@@@@@@@@@@@@@@T @@@F(@@@A*@@@@PP@@@@@@@@@L@@@@Q0@@@D\@@@@L@@@@@@@@@B8@@@A@@@@@P@@@@C@@@@@@@@@@@@@@@@@@@@@A@@@@D0@@@A(@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@A*@@@@Z @@@F(@@@@&amp;@@@@@@@@@C@@@@AU@@@@UP@@@C@@@@@@@@@@E0@@@D@@@@A@@@@@P@@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@WP@@@F(@@@A*@@@@T0@@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@L @@@D@@@@A@@@@@N@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CD@@@A*@@@@Z @@@F(@@@@W@@@@@@@@@@@@@@@2@@@@UP@@@ET@@@@2@@@@@@@@@@@@@@@N@@@@P@@@@D@@@@A@@@@@G0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P0@@@F(@@@A*@@@@T0@@@@@@@@@@@@@@@@@@@CH@@@AU@@@@UP@@@CH@@@@@@@@@@@@@@@@@@@@(@@@@P@@@@D@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@YP@@@E,@@@@S@@@@@@@@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@@@@@@@X@@@@4@@@@OP@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@UP@@@ET@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@AG@@@@Q0@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin5	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin5.png'&gt;	&lt;md5sum: #[182 222 198 221 30 132 188 4 30 126 39 33 229 186 201 75]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@* @@@J(@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@GH@@@CJ@@@@2 @@@GH@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@@@@+@@@@IP@@@@R@@@@@@@@@@@@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@@@@@@@@@@@B @@@C@@@@@5P@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@HL@@@B5@@@@-P@@@GH@@@@@@@@@@@@@@@@@@@A7@@@@2 @@@L(@@@A7@@@@@@@@@@@@@@@@@@@@,@@@@N@@@@C @@@@#P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U0@@@KT@@@B5@@@@-@@@@B\@@@@@@@@@@@@@@G\@@@CJ@@@@2 @@@G\@@@@@@@@@@@@@@C@@@@C_@@@@8@@@@N@@@@A''@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@''0@@@KT@@@B5@@@@#P@@@@D@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@A@@@@+0@@@N@@@@C @@@@1P@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@-P@@@KT@@@B5@@@@PP@@@@@@@@A2@@@@2 @@@L(@@@A2@@@@@@@@@ED@@@C @@@@8@@@@N@@@@AK@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@A$@@@@RP@@@@X@@@@@@@@@@@@@@@@@@@BI@@@@-P@@@KT@@@BC@@@@@@@@@A0@@@B*@@@@* @@@A0@@@@@@@@@" @@@N@@@@C @@@@+P@@@@@@@@@@@@@@@@@@@@$@@@A4@@@@,@@@@E@@@@@@@@@@@@@@@@@@@@@B@@@@&amp;@@@@J@@@@B @@@@#P@@@CT@@@@@@@@@@@@@@BD@@@B,@@@@-P@@@E\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A)@@@@8@@@@N@@@@AY@@@@@@@@@@@@@@AR@@@@6@@@@OT@@@C5@@@@:P@@@@L@@@@@@@@@@@@@@@D@@@BK@@@@(@@@@J@@@@B @@@@(@@@@G(@@@@&gt;@@@@@@@@@@8@@@@!@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@(@@@@D @@@@@@@@@-@@@@.@@@@OT@@@C5@@@@=P@@@OT@@@CK@@@@@P@@@@@@@@@@@@@@@@@@@A0@@@A?@@@@''0@@@J@@@@B @@@@(@@@@J@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D0@@@N(@@@C5@@@@=P@@@OT@@@C4@@@@''@@@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@_P@@@J@@@@B @@@@(@@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@=P@@@OT@@@C5@@@@/0@@@CX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@N@@@@FH@@@AK@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A2@@@@,@@@@EX@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@\0@@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@" @@@GL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@ @@@A3@@@@" @@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@\0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@B @@@@(@@@@J@@@@B @@@@(@@@@J@@@@B@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@U@@@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@T@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@V0@@@GT@@@A5@@@@]P@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@H@@@@B@@@@@ @@@@FP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@R @@@GT@@@A5@@@@]P@@@GT@@@A0@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@A$@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@FD@@@A5@@@@]P@@@GT@@@A5@@@@V@@@@AX@@@@@@@@@B@@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@D@@@@@@@@@@0@@@@X@@@@H@@@@B@@@@@ @@@@H@@@@A0@@@@@@@@@@@@@@@@@@@@A@@@@[0@@@GT@@@A5@@@@Y0@@@B\@@@@@@@@@@@@@@BX@@@A @@@@X@@@@B4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@MP@@@CL@@@@J@@@@@@@@@@@@@@@K@@@@G@@@@B@@@@@ @@@@G @@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@U@@@@C @@@@D@@@@@@@@@@@@@@@@@@@@R @@@F@@@@A @@@@N0@@@@@@@@@J@@@@O @@@C8@@@@J@@@@@@@@@BX@@@@5@@@@MP@@@B @@@@@@@@@@@@@@@@@@@@A@@@@C0@@@AP@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@A @@@@X@@@@F@@@@@#@@@@@@@@@B(@@@AJ@@@@R @@@B(@@@@@@@@@D0@@@CT@@@@5@@@@MP@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@U@@@@F@@@@A @@@@R0@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@JP@@@CT@@@@5@@@@K0@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@A @@@@X@@@@F@@@@@U@@@@@@@@@@@@@@@,@@@@R @@@D(@@@@,@@@@@@@@@@@@@@@K@@@@MP@@@CT@@@@5@@@@FP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@OP@@@F@@@@A @@@@R0@@@@@@@@@@@@@@@@@@@B0@@@AJ@@@@R @@@B0@@@@@@@@@@@@@@@@@@@@!@@@@MP@@@CT@@@@&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@V0@@@EH@@@@Q@@@@@@@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@@@@@@@T@@@@+@@@@L0@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@R @@@D(@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@&gt;@@@@O @@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin6	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin6.png'&gt;	&lt;md5sum: #[26 248 239 150 129 234 159 13 132 133 84 185 52 5 111 252]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@(P@@@JD@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@C@@@@@0@@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@( @@@H,@@@@Q@@@@@@@@@@@@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@@@@@@@@@@@BX@@@B7@@@@20@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G,@@@B*@@@@* @@@F,@@@@@@@@@@@@@@@@@@@A1@@@@0@@@@L@@@@A1@@@@@@@@@@@@@@@@@@@@)0@@@MT@@@CU@@@@! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TP@@@J(@@@B*@@@@*P@@@BT@@@@@@@@@@@@@@GD@@@C@@@@@0@@@@GD@@@@@@@@@@@@@@B8@@@CT@@@@5P@@@MT@@@A"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@%P@@@J(@@@B*@@@@!P@@@@D@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@A@@@@) @@@MT@@@CU@@@@.0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@9@@@@* @@@J(@@@B*@@@@OP@@@@@@@@A,@@@@0@@@@L@@@@A,@@@@@@@@@D4@@@CU@@@@5P@@@MT@@@AG@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@A]@@@@Q@@@@@T@@@@@@@@@@@@@@@@@@@BA@@@@* @@@J(@@@A;@@@@@@@@@A(@@@B!@@@@(P@@@A(@@@@@@@@@ 0@@@MT@@@CU@@@@)P@@@@@@@@@@@@@@@@@@@@ @@@A/@@@@*@@@@D0@@@@@@@@@@@@@@@@@@@@B@@@@# @@@IT@@@BU@@@@ 0@@@CH@@@@@@@@@@@@@@A&lt;@@@B"@@@@* @@@EH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@@5P@@@MT@@@AT@@@@@@@@@@@@@@AN@@@@3 @@@N(@@@C*@@@@70@@@@L@@@@@@@@@@@@@@@D@@@BA@@@@%P@@@IT@@@BU@@@@%P@@@GH@@@@:@@@@@@@@@@4@@@@_@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@&amp;@@@@DP@@@@@@@@@+@@@@+0@@@N(@@@C*@@@@: @@@N(@@@CB@@@@@P@@@@@@@@@@@@@@@@@@@A(@@@A7@@@@%@@@@IT@@@BU@@@@%P@@@IT@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@N@@@@C*@@@@: @@@N(@@@C)@@@@%P@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@]@@@@IT@@@BU@@@@%P@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@: @@@N(@@@C*@@@@-0@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@M@@@@E,@@@AF@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A-@@@@*@@@@EH@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z @@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A*@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@Z @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@S@@@@CD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@M@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@T0@@@F(@@@A*@@@@Z @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@EP@@@AT@@@@U@@@@D@@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@P0@@@F(@@@A*@@@@Z @@@F(@@@A%@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@U@@@@EP@@@AT@@@@U@@@@EP@@@AD@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@E @@@A*@@@@Z @@@F(@@@A*@@@@S0@@@AP@@@@@@@@@A0@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@C@@@@@@@@@@ @@@@P@@@@EP@@@AT@@@@U@@@@EP@@@AH@@@@@@@@@@@@@@@@@@@@A@@@@YP@@@F(@@@A*@@@@W @@@BL@@@@@@@@@@@@@@BH@@@AU@@@@UP@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@J @@@B @@@@H@@@@@@@@@@@@@@@G@@@@D0@@@AT@@@@U@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@S@@@@CH@@@@D@@@@@@@@@@@@@@@@@@@@P @@@ET@@@AU@@@@M@@@@@@@@@@I@@@@M @@@CX@@@@I@@@@@@@@@A8@@@@*@@@@J @@@B@@@@@@@@@@@@@@@@@@@@@A@@@@B @@@@4@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@AU@@@@UP@@@ET@@@@_@@@@@@@@@BP@@@A@@@@@P@@@@BP@@@@@@@@@C0@@@B(@@@@*@@@@J @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@R0@@@ET@@@AU@@@@P @@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@HP@@@B(@@@@*@@@@IP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B\@@@AU@@@@UP@@@ET@@@@R@@@@@@@@@@@@@@@&amp;@@@@P@@@@D@@@@@&amp;@@@@@@@@@@@@@@@I@@@@J @@@B(@@@@*@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M @@@ET@@@AU@@@@P0@@@@@@@@@@@@@@@@@@@BX@@@A@@@@@P@@@@BX@@@@@@@@@@@@@@@@@@@@[@@@@J @@@B(@@@@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@TP@@@D$@@@@O@@@@@@@@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@@@@@@@P@@@@"@@@@J@@@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@P@@@@D@@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@6@@@@M @@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin7	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin7.png'&gt;	&lt;md5sum: #[203 121 131 233 217 81 204 152 8 242 32 84 91 150 235 103]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@&amp;@@@@I @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@FX@@@B5@@@@-P@@@FX@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@&amp;@@@@HL@@@@P@@@@@@@@@@@@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@@@@@@@@@@@BP@@@B-@@@@0@@@@DD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@GP@@@B @@@@(@@@@FT@@@@@@@@@@@@@@@@@@@A*@@@@-P@@@KT@@@A*@@@@@@@@@@@@@@@@@@@@'' @@@L(@@@CJ@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SP@@@J@@@@B @@@@''0@@@BL@@@@@@@@@@@@@@F(@@@B5@@@@-P@@@F(@@@@@@@@@@@@@@B0@@@CI@@@@2 @@@L(@@@A]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@#P@@@J@@@@B @@@@_P@@@@D@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@A@@@@'' @@@L(@@@CJ@@@@,P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@5@@@@(@@@@J@@@@B @@@@N @@@@@@@@A&amp;@@@@-P@@@KT@@@A&amp;@@@@@@@@@D$@@@CJ@@@@2 @@@L(@@@AC@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B4@@@AW@@@@O0@@@@T@@@@@@@@@@@@@@@@@@@A9@@@@(@@@@J@@@@A3@@@@@@@@@A$@@@BX@@@@&amp;@@@@A$@@@@@@@@@_@@@@L(@@@CJ@@@@''@@@@@@@@@@@@@@@@@@@@@ @@@A*@@@@(P@@@D$@@@@@@@@@@@@@@@@@@@@B@@@@!@@@@H(@@@BJ@@@@^ @@@B8@@@@@@@@@@@@@@A4@@@BX@@@@(@@@@D4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A_@@@@2 @@@L(@@@AP@@@@@@@@@@@@@@AK@@@@1 @@@N@@@@C @@@@5P@@@@L@@@@@@@@@@@@@@@D@@@A8@@@@" @@@H(@@@BJ@@@@" @@@F(@@@@6@@@@@@@@@@4@@@@]@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@$@@@@D@@@@@@@@@@)@@@@*@@@@N@@@@C @@@@8@@@@N@@@@B9@@@@@P@@@@@@@@@@@@@@@@@@@A @@@A.@@@@"P@@@H(@@@BJ@@@@" @@@H(@@@@K@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@MX@@@C @@@@8@@@@N@@@@C_@@@@# @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@[@@@@H(@@@BJ@@@@" @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@8@@@@N@@@@C @@@@+0@@@CD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@L@@@@EP@@@A@@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A)@@@@(P@@@D8@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@XP@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@]P@@@FD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@=P@@@L0@@@A!@@@@]P@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@XP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CL@@@@=P@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@3@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@QP@@@B4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@F@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@R0@@@F@@@@A @@@@X@@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B @@@@(@@@@J@@@@B@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@OP@@@F@@@@A @@@@X@@@@F@@@@A\@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@J@@@@B @@@@(@@@@J@@@@B @@@@ @@@@B@@@@@@@@@@@@@@@@@@@@@@@@@D&lt;@@@A @@@@X@@@@F@@@@A @@@@R@@@@AH@@@@@@@@@A @@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@C@@@@@@@@@@P@@@@H@@@@B @@@@(@@@@J@@@@B @@@@$@@@@@@@@@@@@@@@@@@@@A@@@@V0@@@F@@@@A @@@@UP@@@B@@@@@@@@@@@@@@@A4@@@AJ@@@@R @@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@H@@@@A8@@@@F@@@@@@@@@@@@@@@C@@@@BP@@@@(@@@@J@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@_@@@@QP@@@B8@@@@C@@@@@@@@@@@@@@@@@@@@NP@@@D(@@@AJ@@@@K @@@@@@@@@G@@@@K@@@@B0@@@@G@@@@@@@@@A\@@@@ @@@@H@@@@A @@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@X@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@AJ@@@@R @@@D(@@@@[@@@@@@@@@A8@@@@5@@@@MP@@@A8@@@@@@@@@C@@@@B@@@@@ @@@@H@@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@PP@@@D(@@@AJ@@@@N @@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@FP@@@B@@@@@ @@@@G@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@AJ@@@@R @@@D(@@@@P@@@@@@@@@@@@@@@_@@@@MP@@@CT@@@@_@@@@@@@@@@@@@@@G@@@@H@@@@B@@@@@ @@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K0@@@D(@@@AJ@@@@N @@@@@@@@@@@@@@@@@@@A&lt;@@@@5@@@@MP@@@A&lt;@@@@@@@@@@@@@@@@@@@@T@@@@H@@@@B@@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@Q0@@@D@@@@@M@@@@@@@@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@@@@@@@L@@@@Z@@@@G @@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@MP@@@CT@@@@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@,@@@@K@@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin8	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin8.png'&gt;	&lt;md5sum: #[186 27 37 147 74 69 221 230 158 198 102 126 70 94 60 138]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@#0@@@H&lt;@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@B*@@@@* @@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@# @@@G(@@@@O@@@@@@@@@@@@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@@@@@@@@@@@BH@@@B%@@@@-0@@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@BU@@@@%P@@@E8@@@@@@@@@@@@@@@@@@@A$@@@@* @@@J(@@@A$@@@@@@@@@@@@@@@@@@@@%0@@@L@@@@C@@@@@^P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q0@@@IT@@@BU@@@@%@@@@B@@@@@@@@@@@@@@@FP@@@B*@@@@* @@@FP@@@@@@@@@@@@@@B$@@@B?@@@@0@@@@L@@@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@ 0@@@IT@@@BU@@@@]@@@@@D@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@A@@@@% @@@L@@@@C@@@@@*P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@%P@@@IT@@@BU@@@@M @@@@@@@@A @@@@* @@@J(@@@A @@@@@@@@@DT@@@C@@@@@0@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@AP@@@@N0@@@@T@@@@@@@@@@@@@@@@@@@A1@@@@%P@@@IT@@@A,@@@@@@@@@A\@@@BO@@@@#0@@@A\@@@@@@@@@] @@@L@@@@C@@@@@%@@@@@@@@@@@@@@@@@@@@@ @@@A%@@@@&amp;P@@@DT@@@@@@@@@@@@@@@@@@@@B@@@@^ @@@H@@@@B@@@@@\P@@@B,@@@@@@@@@@@@@@A,@@@BN@@@@%P@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AZ@@@@0@@@@L@@@@AL@@@@@@@@@@@@@@AG@@@@/@@@@MT@@@CU@@@@20@@@@L@@@@@@@@@@@@@@@D@@@A/@@@@ @@@@H@@@@B@@@@@ @@@@FH@@@@2@@@@@@@@@@0@@@@[@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@#@@@@C0@@@@@@@@@''@@@@(@@@@MT@@@CU@@@@5P@@@MT@@@B0@@@@@P@@@@@@@@@@@@@@@@@@@AX@@@A&amp;@@@@_0@@@H@@@@B@@@@@ @@@@H@@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DP@@@L0@@@CU@@@@5P@@@MT@@@CT@@@@!0@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@Y@@@@H@@@@B@@@@@ @@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@5P@@@MT@@@CU@@@@) @@@B&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@KP@@@D8@@@@&lt;@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A#@@@@&amp;P@@@D(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@V@@@@F(@@@A*@@@@Z @@@F(@@@A*@@@@Z @@@E @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@00@@@N(@@@C*@@@@: @@@N(@@@C*@@@@: @@@LL@@@AX@@@@Z @@@F(@@@A*@@@@Z @@@F(@@@A*@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CC@@@@: @@@N(@@@C*@@@@: @@@N(@@@C*@@@@00@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@OP@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@P @@@ET@@@AU@@@@UP@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@M @@@ET@@@AU@@@@UP@@@ET@@@AQ@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DX@@@AU@@@@UP@@@ET@@@AU@@@@P@@@@A@@@@@@@@@@AP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@TP@@@ET@@@AU@@@@R0@@@A0@@@@@@@@@@@@@@A$@@@A@@@@@P@@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@EP@@@AP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@OP@@@B @@@@C@@@@@@@@@@@@@@@@@@@@LP@@@D@@@@A@@@@@I0@@@@@@@@@F@@@@H0@@@BL@@@@F@@@@@@@@@@&lt;@@@@U@@@@EP@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AT@@@A@@@@@P@@@@D@@@@@W@@@@@@@@@A @@@@*@@@@J @@@A @@@@@@@@@B@@@@AT@@@@U@@@@EP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@N@@@@D@@@@A@@@@@L @@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@D @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A@@@@@P@@@@D@@@@@N@@@@@@@@@@@@@@@Y@@@@J @@@B(@@@@Y@@@@@@@@@@@@@@@E@@@@EP@@@AT@@@@U@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@D@@@@A@@@@@L @@@@@@@@@@@@@@@@@@@A$@@@@*@@@@J @@@A$@@@@@@@@@@@@@@@@@@@@M@@@@EP@@@AT@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@OP@@@C\@@@@K@@@@@@@@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@@@@@@@H@@@@Q@@@@E@@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@J @@@B(@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@#@@@@H0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI">spin9	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin9.png'&gt;	&lt;md5sum: #[16 222 9 249 20 9 239 26 21 132 94 34 77 70 246 144]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@! @@@HX@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@E(@@@B @@@@(@@@@E(@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@!@@@@GD@@@@N@@@@@@@@@@@@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@@@@@@@@@@@B@@@@B[@@@@+@@@@C(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@FP@@@BJ@@@@" @@@E\@@@@@@@@@@@@@@@@@@@A^@@@@(@@@@J@@@@A^@@@@@@@@@@@@@@@@@@@@# @@@KT@@@B5@@@@\ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P @@@H(@@@BJ@@@@"P@@@A8@@@@@@@@@@@@@@E8@@@B @@@@(@@@@E8@@@@@@@@@@@@@@B\@@@B4@@@@-P@@@KT@@@AS@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@^P@@@H(@@@BJ@@@@[@@@@@D@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@A@@@@#P@@@KT@@@B5@@@@''0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.@@@@" @@@H(@@@BJ@@@@L @@@@@@@@AZ@@@@(@@@@J@@@@AZ@@@@@@@@@DD@@@B5@@@@-P@@@KT@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BX@@@AI@@@@M @@@@P@@@@@@@@@@@@@@@@@@@A(@@@@" @@@H(@@@A$@@@@@@@@@AX@@@BF@@@@! @@@AX@@@@@@@@@[0@@@KT@@@B5@@@@#@@@@@@@@@@@@@@@@@@@@@\@@@A @@@@$P@@@DH@@@@@@@@@@@@@@@@@@@@A@@@@[0@@@GT@@@A5@@@@Y0@@@B\@@@@@@@@@@@@@@A$@@@BD@@@@" @@@DL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AU@@@@-P@@@KT@@@AH@@@@@@@@@@@@@@AC@@@@, @@@L(@@@CJ@@@@0@@@@@H@@@@@@@@@@@@@@@@@@@A%@@@@]P@@@GT@@@A5@@@@]P@@@E$@@@@-@@@@@@@@@@,@@@@Y@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@!@@@@C @@@@@@@@@%@@@@%0@@@L(@@@CJ@@@@2 @@@L(@@@B''@@@@@P@@@@@@@@@@@@@@@@@@@AP@@@A]@@@@]P@@@GT@@@A5@@@@]P@@@GT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@LD@@@CJ@@@@2 @@@L(@@@CI@@@@ @@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@V0@@@GT@@@A5@@@@]P@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@2 @@@L(@@@CJ@@@@'' @@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@JP@@@D @@@@7@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A^@@@@$P@@@D\@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@T@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@. @@@N@@@@C @@@@8@@@@N@@@@C @@@@8@@@@K(@@@AP@@@@X@@@@F@@@@A @@@@X@@@@F@@@@A @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B:@@@@8@@@@N@@@@C @@@@8@@@@N@@@@C @@@@. @@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@MP@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@GH@@@BV@@@@U @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@N @@@D(@@@AJ@@@@R @@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@=P@@@OT@@@C5@@@@/0@@@CX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@K0@@@D(@@@AJ@@@@R @@@D(@@@AG@@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@C5@@@@=P@@@OT@@@C5@@@@=@@@@LL@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@C4@@@AJ@@@@R @@@D(@@@AJ@@@@M0@@@@8@@@@@@@@@A@@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@E&lt;@@@B;@@@@=P@@@OT@@@C5@@@@=P@@@MP@@@@A@@@@@@@@@@@@@@@A@@@@Q0@@@D(@@@AJ@@@@PP@@@A$@@@@@@@@@@@@@@AT@@@@5@@@@MP@@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B @@@@(@@@@B@@@@@@@@@@@@@@AR@@@@6@@@@OT@@@C5@@@@:P@@@@L@@@@@@@@@@@@@@@@@@@@X@@@@MP@@@BL@@@@C@@@@@@@@@@@@@@@@@@@@JP@@@CT@@@@5@@@@HP@@@@@@@@@D@@@@F0@@@A,@@@@D@@@@@@@@@@\@@@@J@@@@B @@@@ @@@@@@@@@@@@@@@@@@@@I@@@@\@@@@I(@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@5@@@@MP@@@CT@@@@S@@@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@A@@@@@(@@@@J@@@@B @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@K0@@@CT@@@@5@@@@JP@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@5@@@@MP@@@CT@@@@K@@@@@@@@@@@@@@@S@@@@H@@@@B@@@@@S@@@@@@@@@@@@@@@B@@@@B @@@@(@@@@J@@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@HP@@@CT@@@@5@@@@J @@@@@@@@@@@@@@@@@@@AL@@@@ @@@@H@@@@AL@@@@@@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@L0@@@B8@@@@I@@@@@@@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@@@@@@@D@@@@H@@@@B @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@H@@@@B@@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@[@@@@F0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body></methods><methods><class-id>Store.RepositoryPropertiesDialog class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #RepositoryProperties 				#defaultString: 'Repository Properties' 				#catalogID: #store ) 			#min: #(#{Core.Point} 410 201 ) 			#max: #(#{Core.Point} 410 201 ) 			#bounds: #(#{Graphics.Rectangle} 756 420 1166 621 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 15 0 300 0 40 0 ) 					#name: #nameField 					#model: #nameHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 45 0 300 0 70 0 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 75 0 300 0 100 0 ) 					#name: #environmentField 					#model: #environmentHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 105 0 300 0 130 0 ) 					#name: #userNameField 					#model: #userNameHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 135 0 300 0 160 0 ) 					#name: #passwordField 					#model: #passwordHolder 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 165 0 300 0 190 0 ) 					#name: #tableOwnerField 					#model: #tableOwnerHolder ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #accept 					#model: #ok 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 40 0 0 1 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #NameC 						#defaultString: 'Name:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 70 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 130 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 160 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 100 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 190 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #TableOwner 						#defaultString: 'Table Owner:' 						#catalogID: #store ) ) ) ) )</body></methods><methods><class-id>Tools.StoreRepositoryListPage class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #store ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 791 424 1129 712 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines false #allowColumnResizing true #rowSize 25 #showVerticalLines false #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -30 1 ) 					#name: #repositoryListDataset 					#model: #repositoryListHolder 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing true ) 							#model: #'repositoryHolder name' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Name 								#defaultString: 'Name' 								#catalogID: #store ) 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false #allowResizing true ) 							#model: #'repositoryHolder environment' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Environment 								#defaultString: 'Environment' 								#catalogID: #store ) 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 -3 0.333333 0 1 ) 					#name: #addButton 					#model: #addRepository 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddDots 						#defaultString: 'Add...' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.333333 -25 1 -2 0.666666 0 1 ) 					#name: #removeButton 					#model: #removeRepository 					#label: 					#(#{Kernel.UserMessage} 						#key: #RemoveDots 						#defaultString: 'Remove...' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.666666 -25 1 0 1 0 1 ) 					#name: #propertiesButton 					#model: #repositoryProperties 					#label: 					#(#{Kernel.UserMessage} 						#key: #PropertiesDots 						#defaultString: 'Properties...' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.MergeToolHelp class</class-id> <category>interface specs</category><body package="Store-Merge Management">howToUseHelpSpec	"Tools.UIPainter new openOnClass: self andSelector: #howToUseHelpSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #HowToUseMergeTool #defaultString: 'How to Use Merge Tool' #catalogID: #store) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 720 300 1360 900 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -45 1 ) 					#name: #HelpText 					#model: #helpTextHolder 					#tabable: true 					#isReadOnly: false 					#tabRequiresControl: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #CloseButton 					#model: #closeRequest 					#label: #(#{Kernel.UserMessage} #key: #Close #defaultString: 'Close' #catalogID: #store) 					#defaultable: true ) ) ) )</body><body package="Store-Merge Management">iconHelpSpec	"Tools.UIPainter new openOnClass: self andSelector: #iconHelpSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #MergeToolIconsReference #defaultString: 'Merge Tool Icons Reference' #catalogID: #store) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1070 720 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -45 1 ) 					#name: #HelpIconList 					#flags: 12 					#model: #helpIconList 					#tabable: false 					#selectionType: #highlight 					#autoSelect: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #CloseButton 					#model: #closeRequest 					#label: #(#{Kernel.UserMessage} #key: #Close #defaultString: 'Close' #catalogID: #store) 					#defaultable: true ) ) ) )</body><body package="Store-Merge Management">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #MergeToolHelp #defaultString: 'Merge Tool Help' #catalogID: #store) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 698 278 1598 978 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #HelpText 					#model: #helpTextHolder 					#tabable: false 					#isReadOnly: false 					#tabRequiresControl: false ) ) ) )</body></methods><methods><class-id>Store.MethodDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Definition Comparison">briefSpec	"Tools.UIPainter new openOnClass: self andSelector: #briefSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Method Difference Browser' 			#min: #(#{Core.Point} 50 50 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1540 950 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -1 0.5 -25 1 ) 					#name: #text1Widget 					#model: #text1 					#menu: #customTextMenu 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 2 0 -2 1 -25 1 ) 					#name: #text2Widget 					#model: #text2 					#menu: #customTextMenu 					#tabRequiresControl: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -24 1 -1 0.5 -1 1 ) 					#name: #protocol1 					#model: #protocol1 					#style: #default 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 -24 1 -2 1 -1 1 ) 					#name: #protocol2 					#model: #protocol2 					#style: #default 					#isReadOnly: true 					#type: #text ) ) ) )</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>resources</category><body package="Store-UI">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ImportDots 								#defaultString: '&amp;Import...' 								#catalogID: #store ) 							#nameKey: #fileImport 							#value: #fileImport 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExportDots 								#defaultString: '&amp;Export...' 								#catalogID: #store ) 							#nameKey: #fileSave 							#value: #fileSave 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Close 								#defaultString: '&amp;Close' 								#catalogID: #store ) 							#nameKey: #fileClose 							#value: #fileClose ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Repository 					#defaultString: '&amp;Repository' 					#catalogID: #store ) 				#nameKey: #repository 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDots								#defaultString: '&amp;New...' 								#catalogID: #store ) 							#nameKey: #repositoryNew 							#value: #repositoryNew 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PropertiesDots								#defaultString: '&amp;Properties...' 								#catalogID: #store ) 							#nameKey: #repositoryProperties 							#value: #repositoryProperties 							#enablementSelector: #isRepositorySelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Remove 								#defaultString: '&amp;Remove...' 								#catalogID: #store ) 							#nameKey: #repositoryRemove 							#value: #repositoryRemove 							#enablementSelector: #isRepositorySelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Connect 								#defaultString: '&amp;Connect' 								#catalogID: #store ) 							#nameKey: #repositoryToggleConnection 							#value: #repositoryToggleConnection 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Published_Items 								#defaultString: 'Published &amp;Items' 								#catalogID: #store ) 							#nameKey: #repositoryPublishedItems 							#value: #repositoryPublishedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_MoreRecentItems 								#defaultString: '&amp;More Recent Items' 								#catalogID: #store ) 							#nameKey: #repositoryMoreRecentlyPublishedItems 							#value: #repositoryMoreRecentlyPublishedItems ) ) #(1 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorks 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #store ) 							#nameKey: #helpAbout 							#value: #helpAbout ) ) #(1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">repositoryListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #repositoryListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_NewDots #catalogID: #store #defaultString: '&amp;New...') 				#nameKey: #repositoryNew 				#value: #repositoryNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_PropertiesDots #catalogID: #store #defaultString: '&amp;Properties...') 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#enablementSelector: #isRepositorySelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_Remove #catalogID: #store #defaultString: '&amp;Remove...') 				#nameKey: #repositoryRemove 				#value: #repositoryRemove 				#enablementSelector: #isRepositorySelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_Connect #catalogID: #store #defaultString: '&amp;Connect') 				#nameKey: #repositoryToggleConnection 				#value: #repositoryToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Published_Items #catalogID: #store #defaultString: 'Published &amp;Items') 				#nameKey: #repositoryPublishedItems 				#value: #repositoryPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_MoreRecentItems #catalogID: #store #defaultString: '&amp;More Recent Items') 				#nameKey: #repositoryMoreRecentlyPublishedItems 				#value: #repositoryMoreRecentlyPublishedItems ) ) #(1 2 3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ImportDots 					#defaultString: '&amp;Import...' 					#catalogID: #store ) 				#nameKey: #fileImport 				#value: #fileImport 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ImportRepositoriesFromFile 					#defaultString: 'Import repositories from file' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ExportDots 					#defaultString: '&amp;Export...' 					#catalogID: #store ) 				#nameKey: #fileSave 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ExportRepositoriesToFile 					#defaultString: 'Export repositories to file' 					#catalogID: #store  ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDots					#defaultString: '&amp;New...' 					#catalogID: #store ) 				#nameKey: #repositoryNew 				#value: #repositoryNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #CreateANewRepository 					#defaultString: 'Create a new repository' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PropertiesDots 					#defaultString: '&amp;Properties...' 					#catalogID: #store ) 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#enablementSelector: #isRepositorySelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #EditRepositoryProperties 					#defaultString: 'Edit repository properties' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Connect 					#defaultString: '&amp;Connect' 					#catalogID: #store ) 				#nameKey: #repositoryToggleConnection 				#value: #repositoryToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ConnectOrDisconnectTheSelectedRepository 					#defaultString: 'Connect or disconnect the selected repository' 					#catalogID: #store ) ) ) #(2 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #StoreRepositories #catalogID: #store #defaultString: 'Store Repositories') 			#min: #(#{Core.Point} 492 188 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 526 384 956 584 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #toolbarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #allowSorting true #allowColumnReordering false #allowColumnResizing true #showVerticalLines false #rowSize 22 #showHorizontalLines false #rowLabelsAsButtons false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #repositoryDataset 					#flags: 13 					#model: #repositoryListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #repositorySelected 						#doubleClickSelector: #repositoryListDoubleClicked ) 					#menu: #repositoryListMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder isConnected' 							#label: '' 							#labelIsImage: false 							#width: 22 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder name' 							#label: #(#{UserMessage} #key: #Name #catalogID: #store #defaultString: 'Name') 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder environment' 							#label: #(#{UserMessage} #key: #Environment #catalogID: #store #defaultString: 'Environment') 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder userName' 							#label: #(#{UserMessage} #key: #User #catalogID: #store #defaultString: 'User') 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="StoreForGlorpBrowserUI">classesTab	&lt;tabDescription: 2&gt;	^(TabPartDescription new)		name: #Class &lt;&lt; #browser &gt;&gt; 'Class';		buildSelector: #buildClassesSubcanvas;		matchSelector: #alwaysEnabled:;		enabledSelector: #enabledExceptForShared:</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool class</class-id> <category>resources</category><body package="Store-UI">bundleMenu	"Tools.MenuEditor new openOnClass: self andSelector: #bundleMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllBundleVersions 				#enablementSelector: #bundleIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllBundleVersions 				#enablementSelector: #bundleIsSelected ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">bundleVersionsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #bundleVersionsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectForRemoval 					#defaultString: 'Select For Removal' 					#catalogID: #store ) 				#nameKey: #SelectForRemoval 				#value: #selectBundleVersionForRemoval 				#enablementSelector: #atLeastOneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractThisVersionForRemoval 					#defaultString: 'Retract Version Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractThisVersion 				#value: #retractThisBundleVersion 				#enablementSelector: #atLeastOneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllBundleVersions 				#enablementSelector: #bundleIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllBundleVersions 				#enablementSelector: #bundleIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ViewContainedItems 					#defaultString: 'View Contained Items' 					#catalogID: #store ) 				#nameKey: #ViewContainedItems 				#value: #viewContainedItems 				#enablementSelector: #oneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ViewEnclosingBundles 					#defaultString: 'View Enclosing Bundles' 					#catalogID: #store ) 				#nameKey: #ViewEnclosingBundles 				#value: #viewEnclosingBundles 				#enablementSelector: #oneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseBundle 					#defaultString: 'Browse Bundle' 					#catalogID: #store ) 				#nameKey: #BrowseBundle 				#value: #browseBundle 				#enablementSelector: #oneBundleVersionIsSelected ) ) #(2 2 2 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">packageMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packageMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllPackageVersions 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllPackageVersions 				#enablementSelector: #packageIsSelected ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">packageVersionsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packageVersionsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectForRemoval 					#defaultString: 'Select For Removal' 					#catalogID: #store ) 				#nameKey: #SelectForRemoval 				#value: #selectPackageVersionForRemoval 				#enablementSelector: #atLeastOnePackageVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractThisVersionForRemoval 					#defaultString: 'Retract Version Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractThisVersion 				#value: #retractThisPackageVersion 				#enablementSelector: #atLeastOnePackageVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllPackageVersions 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllPackageVersions 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ViewEnclosingBundles 					#defaultString: 'View Enclosing Bundles' 					#catalogID: #store ) 				#nameKey: #ViewEnclosingBundles 				#value: #viewEnclosingBundles 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowsePackage 					#defaultString: 'Browse Package' 					#catalogID: #store ) 				#nameKey: #BrowsePackage 				#value: #browsePackage 				#enablementSelector: #onePackageVersionIsSelected ) ) #(2 2 1 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">targetedPundlesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #targetedPundlesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractThisVersionForRemoval 					#defaultString: 'Retract Version Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractThisVersion 				#value: #retractThisPundleVersion 				#enablementSelector: #atLeastOnePundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllPundleVersions ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool class</class-id> <category>interface specs</category><body package="Store-UI">bundlesPage	"Tools.UIPainter new openOnClass: self andSelector: #bundlesPage"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 900 550 1401 914 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.4 -35 1 ) 					#name: #BundlesList 					#flags: 15 					#model: #bundles 					#helpText: #suppressTooltip 					#menu: #bundleMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 0 0 0 1 -35 1 ) 					#name: #BundleVersions 					#flags: 15 					#model: #bundleVersions 					#helpText: #suppressTooltip 					#menu: #bundleVersionsMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -210 1 -28 1 -110 1 -5 1 ) 					#name: #ClearFilter 					#model: #clearFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClearFilter 						#defaultString: 'Clear Filter' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -105 1 -28 1 -5 1 -5 1 ) 					#name: #EditFilter 					#model: #editFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #EditFilterDots 						#defaultString: 'Edit Filter...' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI">packagesPage	"Tools.UIPainter new openOnClass: self andSelector: #packagesPage"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 749 562 1250 926 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.4 -35 1 ) 					#name: #PackagesList 					#flags: 15 					#model: #packages 					#helpText: #suppressTooltip 					#menu: #packageMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 0 0 0 1 -35 1 ) 					#name: #PackageVersions 					#flags: 15 					#model: #packageVersions 					#helpText: #suppressTooltip 					#menu: #packageVersionsMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -210 1 -28 1 -110 1 -5 1 ) 					#name: #ClearFilter 					#model: #clearFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClearFilter 						#defaultString: 'Clear Filter' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -105 1 -28 1 -5 1 -5 1 ) 					#name: #EditFilter 					#model: #editFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #EditFilterDots 						#defaultString: 'Edit Filter...' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MarkPackagesBundlesForRemoval 				#defaultString: 'Mark Repository Packages &amp; Bundles For Removal' 				#catalogID: #store ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 882 309 1682 1009 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 1 0 0.6 ) 					#name: #PundleChooser 					#model: #pundleTabs 					#labels: #('Bundles' 'Packages' ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0.6 -2 1 -35 1 ) 					#name: #TargetedPundles 					#model: #targetedPundles 					#helpText: #suppressTooltip 					#menu: #targetedPundlesMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -570 1 -30 1 -410 1 -5 1 ) 					#name: #StartGarbageCollector 					#model: #startGarbageCollector 					#label: 					#(#{Kernel.UserMessage} 						#key: #GarbageCollectAllMarked 						#defaultString: 'Garbage-Collect all marked' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -405 1 -30 1 -275 1 -5 1 ) 					#name: #ApplyChanges 					#flags: 40 					#model: #applyChanges 					#label: 					#(#{Kernel.UserMessage} 						#key: #MarkDeleteInDB 						#defaultString: 'Mark ''To Delete'' in DB' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -270 1 -30 1 -140 1 -5 1 ) 					#name: #CancelChanges 					#flags: 40 					#model: #cancelChanges 					#label: 					#(#{Kernel.UserMessage} 						#key: #RevertMarkedInDB 						#defaultString: 'Revert marked in DB' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -30 1 -5 1 -5 1 ) 					#name: #Close 					#model: #closeWindow 					#label: 					#(#{Kernel.UserMessage} 						#key: #Close 						#defaultString: 'Close' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.CommentPrompt class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #BlessingLevel #catalogID: #store #defaultString: 'Blessing level') 			#bounds: #(#{Graphics.Rectangle} 512 384 958 629 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 11 ) 					#label: #(#{UserMessage} #key: #BlessinglevelC #catalogID: #store #defaultString: 'Blessing level:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 63 0 -9 1 -57 1 ) 					#model: #text 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 38 ) 					#label: #(#{UserMessage} #key: #CommentC #catalogID: #store #defaultString: 'Comment:') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -190 0.5 203 0 -126 0.5 233 0 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Accept #catalogID: #store #defaultString: 'Accept') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 126 0.5 203 0 190 0.5 233 0 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#isDefault: false 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 8 0 -9 1 33 0 ) 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) ) ) )</body></methods><methods><class-id>Store.RepositoryFilterDialog class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #RepositoryFilters 				#defaultString: 'Repository Filters' 				#catalogID: #store ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 525 358 975 543 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 15 30 ) 					#name: #ShowBundles 					#model: #showBundles 					#label: 					#(#{Kernel.UserMessage} 						#key: #ShowBundles 						#defaultString: 'Show Bundles' 						#catalogID: #store ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 15 55 ) 					#name: #ShowPackages 					#model: #showPackages 					#label: 					#(#{Kernel.UserMessage} 						#key: #ShowPackages 						#defaultString: 'Show Packages' 						#catalogID: #store ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 10 0 -4 0.3 -40 1 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #ComponentFilters 						#defaultString: 'Component Filters' 						#catalogID: #store ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0.3 10 0 -5 1 -40 1 ) 					#name: #GroupBox2 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionFilters 						#defaultString: 'Version Filters' 						#catalogID: #store ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0.3 30 0 ) 					#name: #OlderThanCheckBox					#model: #useOlderThanDate 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #DateOlderThanAndEqual 						#defaultString: 'Version date older than and equal to the specified date' 						#catalogID: #store ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #OlderThanColon 						#defaultString: 'Older Than :' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0.3 27 0 -50 1 50 0 ) 					#name: #OlderThanDate 					#model: #olderThanDate 					#type: #date 					#formatString: 'mm/dd/yyyy' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0.3 55 0 ) 					#name: #NewerThanCheckBox					#model: #useNewerThanDate 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #DateNewerThanAndEqual 						#defaultString: 'Version date newer than and equal to the specified date' 						#catalogID: #store ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #NewerThanColon 						#defaultString: 'Newer Than :' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0.3 52 0 -50 1 75 0 ) 					#name: #NewerThanDate 					#model: #newerThanDate 					#type: #date 					#formatString: 'mm/dd/yyyy' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0.3 90 0 ) 					#name: #GreaterThanComponents 					#model: #useGreaterThanBlessing 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #BlessingGreaterThanAndEqual 						#defaultString: 'Blessings greater than and equal to the selected blessing' 						#catalogID: #store ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BlessingsGreaterThanColon 						#defaultString: 'Blessings Greater Than :' 						#catalogID: #store ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0.3 87 0 -15 1 110 0 ) 					#name: #ComponentGreaterBlessing 					#model: #greaterThanBlessing 					#menu: #blessingMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0.3 115 0 ) 					#name: #LessThanComponents 					#model: #useLessThanBlessing 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #BlessingsLessThanAndEqual 						#defaultString: 'Blessings less than and equal to the selected blessing' 						#catalogID: #store ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BlessingsLessThanColon 						#defaultString: 'Blessings Less Than :' 						#catalogID: #store ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0.3 112 0 -15 1 135 0 ) 					#name: #ComponentLessBlessing 					#model: #lessThanBlessing 					#menu: #blessingMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -310 1 -31 1 -206 1 -8 1 ) 					#name: #ResetToDefaults 					#model: #resetToDefaults 					#label: 					#(#{Kernel.UserMessage} 						#key: #ResetToDefaults 						#defaultString: 'Reset To Defaults' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -183 1 -31 1 -93 1 -8 1 ) 					#name: #Cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -86 1 -31 1 -6 1 -8 1 ) 					#name: #Accept 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #Accept 						#defaultString: 'Accept' 						#catalogID: #dialogs ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Version Graph' 			#min: #(#Point 589 194 ) 			#bounds: #(#Rectangle 412 517 1001 819 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #'LensGraphView' 					#minorKey: #windowSpec 					#clientKey: #graphView ) ) ) )</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs">menuBarSkeleton	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_LoadDot 								#defaultString: '&amp;Load...' 								#catalogID: #store ) 							#value: #loadPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Merge 								#defaultString: '&amp;Merge' 								#catalogID: #store ) 							#value: #mergePundleVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'Set Blessing Level' 							#value: #setBlessingLevel ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOutDifferencesDots 								#defaultString: 'File Out Differences...' 								#catalogID: #store ) 							#value: #fileOutTwoPundleDiff ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Update 								#defaultString: 'Update' 								#catalogID: #store ) 							#value: #reloadVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #E_xit 								#defaultString: 'E&amp;xit' 								#catalogID: #store ) 							#value: #closeRequest ) ) #(2 1 2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Examine 					#defaultString: 'Examine' 					#catalogID: #store ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse 								#defaultString: 'Browse' 								#catalogID: #store ) 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ListContents 								#defaultString: 'List Contents' 								#catalogID: #store ) 							#value: #listBundleContents ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ListVersions 								#defaultString: '&amp;List Versions' 								#catalogID: #store ) 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithImage 								#defaultString: 'Compare with Image' 								#catalogID: #store ) 							#value: #diffPundleWithImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithParent 								#defaultString: 'Compare with Parent' 								#catalogID: #store ) 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareVersions 								#defaultString: 'Compare Versions' 								#catalogID: #store ) 							#value: #diffTwoPundles ) ) #(2 1 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Graph 					#defaultString: 'Graph' 					#catalogID: #store ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenOneOut 								#defaultString: 'Open One Out' 								#catalogID: #store ) 							#value: #openOneOut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenOneIn 								#defaultString: 'Open One In' 								#catalogID: #store ) 							#value: #openOneIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenFourOut 								#defaultString: 'Open Four Out' 								#catalogID: #store ) 							#value: #open4Out ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenFourIn 								#defaultString: 'Open Four In' 								#catalogID: #store ) 							#value: #open4In ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenAllOut 								#defaultString: 'Open All Out' 								#catalogID: #store ) 							#value: #openAllOut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenAllIn 								#defaultString: 'Open All In' 								#catalogID: #store ) 							#value: #openAllIn ) ) #(2 2 2 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector class</class-id> <category>interface specs</category><body package="Store-Merge Management">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #SelectVersionsToMerge 				#defaultString: 'Select Versions to Merge' 				#catalogID: #store ) 			#min: #(#{Core.Point} 500 200 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 317 512 1280 948 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -2 0.333 -45 1 ) 					#name: #PundleTree 					#model: #pundleList 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #other 					#iconSelectors: #(#toolListIcon ) 					#rootExpander: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.333 25 0 -45 0.666 -45 1 ) 					#name: #VersionList 					#model: #pundleVersions 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0.666 25 0 -10 1 -45 1 ) 					#name: #MergeList 					#model: #mergeList 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.666 50 0 40 0.666 75 0 ) 					#name: #AddButton 					#model: #add 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddRight 						#defaultString: 'Add &gt;' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.666 85 0 40 0.666 110 0 ) 					#name: #RemoveButton 					#model: #remove 					#label: 					#(#{Kernel.UserMessage} 						#key: #RemoveLeft 						#defaultString: '&lt; Remove' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #CancelButton 					#model: #closeRequest 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -180 1 -35 1 -100 1 -10 1 ) 					#name: #AcceptButton 					#flags: 40 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 25 0 0 1 ) 					#name: #pundleTreeLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundlesAndPackages 						#defaultString: 'Bundles and packages:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 2 0.333 25 0 0 1 ) 					#name: #versionListLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsC						#defaultString: 'Versions:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 45 0.666 25 0 0 1 ) 					#name: #mergeListLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #SelectedVersions 						#defaultString: 'Selected versions:' 						#catalogID: #store ) ) ) ) )</body></methods><methods><class-id>Store.StoreLoggingTool class</class-id> <category>resources</category><body package="Store-Base">windowMenu	"Tools.MenuEditor new openOnClass: self andSelector: #windowMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save...' 								#catalogID: #store ) 							#value: #saveOutput ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ClearLog 								#defaultString: '&amp;Clear log' 								#catalogID: #store ) 							#value: #clear ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #GoToClass 					#defaultString: 'Go to Class' 					#catalogID: #browser ) 				#nameKey: #'Navigate to Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseClassInNewWindow 					#defaultString: 'Browse Class in New Window' 					#catalogID: #browser ) 				#nameKey: #'Open Browser on Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseLocal_ImplementorsOfSelector 					#defaultString: 'Browse &amp;Local Implementors of Selector' 					#catalogID: #store ) 				#nameKey: #BrowseImageImplementorsOfSelector 				#value: #browseLocalSelectors 				#enablementSelector: #hasMessageNodeSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseImage_SendersOfSelector 					#defaultString: 'Browse Image &amp;Senders of Selector' 					#catalogID: #store ) 				#nameKey: #'Selected Message References' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseImage_ImplementorsOfSelector 					#defaultString: 'Browse Image &amp;Implementors of Selector' 					#catalogID: #store ) 				#nameKey: #'Selected Message Implementors' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#shortcutKeyCharacter: $F 				#shortcutModifiers: 2 ) ) #(5 3 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>resources</category><body package="Store-UI">repositoryMenu	"Tools.MenuEditor new openOnClass: self andSelector: #repositoryMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #PublishedItemsDots 					#defaultString: 'Published Items...' 					#catalogID: #store ) 				#nameKey: #repositoryPublishedItems 				#value: #repositoryPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RecentlyPublishedItems 					#defaultString: 'Recently Published Items...' 					#catalogID: #store ) 				#nameKey: #repositoryMoreRecentlyPublishedItems 				#value: #repositoryMoreRecentlyPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FilteredPublishedItems 					#defaultString: 'Filtered Published Items...' 					#catalogID: #store ) 				#nameKey: #repositoryPublishedItemsWithFilter 				#value: #repositoryPublishedItemsWithFilter ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FilteredRecentlyPublishedItems 					#defaultString: 'Filtered Recently Published Items...' 					#catalogID: #store ) 				#nameKey: #repositoryMoreRecentlyPublishedItemsWithFilter 				#value: #repositoryMoreRecentlyPublishedItemsWithFilter ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PropertiesDots 					#defaultString: '&amp;Properties...' 					#catalogID: #store ) 				#nameKey: #repositoryProperties 				#value: #repositoryProperties ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDots 					#defaultString: '&amp;New...' 					#catalogID: #store ) 				#nameKey: #repositoryNew 				#value: #repositoryNew ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ImportRepositoriesDots 					#defaultString: '&amp;Import Repositories...' 					#catalogID: #store ) 				#nameKey: #repositoryImport 				#value: #repositoryImport ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ExportRepositoriesDots 					#defaultString: '&amp;Export Repositories...' 					#catalogID: #store ) 				#nameKey: #repositoryExport 				#value: #repositoryExport ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_OpenRepositoryManager 					#defaultString: '&amp;Open Repository Manager' 					#catalogID: #store ) 				#nameKey: #openRepositoryManager 				#value: #openRepositoryManager ) ) #(5 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Store'			#layoutManagerClass: #{UI.UILayout.HorizontalLineLayoutManager}			#layoutManagerConfiguration: '[ :lm | lm verticalUseBaseline: false ]'			#bounds: #(#{Graphics.Rectangle} 840 525 1040 725 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 0.5 0.5 0.5 0.5 ) 					#name: #label )				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} 0 0 0.5 0.5 0.5 0.5 ) 					#name: #menuButtonImage					#label: #menuButtonImage					#hasCharacterOrientedLabel: false ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreCodeModel class</class-id> <category>tool registration</category><body package="StoreForGlorpBrowserUI">codeComponentToolClass	&lt;tool: 35&gt;	^StoreCodeComponentPropertiesTool</body><body package="StoreForGlorpBrowserUI">commentToolClass	&lt;tool: 30&gt;	^StoreBrowserCommentTool</body><body package="StoreForGlorpBrowserUI">compareSourceToolClass	&lt;tool: 22&gt;	^CompareCodeTool</body><body package="StoreForGlorpBrowserUI">copyrightToolClass	&lt;tool: 36&gt;	^CopyrightNoticeTool</body><body package="StoreForGlorpBrowserUI">definitionToolClass	&lt;tool: 40&gt;	^StoreBrowserDefinitionTool</body><body package="StoreForGlorpBrowserUI">overviewToolClass	&lt;tool: 1000&gt;	^StoreBrowserOverviewTool</body><body package="StoreForGlorpBrowserUI">sharedVariableToolClass	&lt;tool: 10&gt;	^StoreSharedVariableCodeTool</body><body package="StoreForGlorpBrowserUI">sourceToolClass	&lt;tool: 20&gt;	^StoreBrowserCodeTool</body></methods><methods><class-id>Store.Glorp.StoreCodeModel class</class-id> <category>status registration</category><body package="StoreForGlorpBrowserUI">basicInfoStatusClass	&lt;status: 10&gt;	^SelectionInfoStatus</body><body package="StoreForGlorpBrowserUI">packageStatusClass	&lt;status: 20&gt;	^SelectionPackageStatus</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOut 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_Shared 								#defaultString: 'Load &amp;Shared' 								#catalogID: #store ) 							#nameKey: #LoadShared 							#value: #loadShared 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 2 1 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>menus</category><body package="Store-UI">openFilterDialog	&lt;menuItem: #(#FilterDots #store 'Filter...')		nameKey: #filterDialog		enablement: true		indication: nil		shortcutKeyCharacter: $F		shortcutModifiers: 8		menu: #(#Packages #Packages)		position: 30.1&gt;	(RepositoryFilterDialog openUsing: self pundleFilter) ifTrue: 		[pundleFilter := PundleFilter lastAppliedFilter copy.		self refreshListAndSelections]</body><body package="Store-UI">resetFiltersMenu	&lt;menuItem: #(#ResetFilters #store 'Reset Filters')		nameKey: #resetFilterMenuItem		enablement: true		indication: nil		shortcutKeyCharacter: $R		shortcutModifiers: 8		menu: #(#Packages #Packages)		position: 30.2&gt;	self pundleFilter setFilterDefaults.	self refreshListAndSelections</body><body package="Store-UI">showBundlesFilter	&lt;menuItem: #(#ShowBundles #store 'Show Bundles')		nameKey: #showBundles		enablement: true		indication: #showBundlesIndicator		menu: #(#Packages #Packages)		position: 20.1&gt;	(self showPackagesIndicator not and: [self showBundlesIndicator])		ifTrue: [self toggleShowPackages].	self toggleShowBundles.	self refreshList</body><body package="Store-UI">showPackagesFilter	&lt;menuItem: #(#ShowPackages #store 'Show Packages')		nameKey: #showPackages		enablement: true		indication: #showPackagesIndicator		menu: #(#Packages #Packages)		position: 20.2&gt;	(self showBundlesIndicator not and: [self showPackagesIndicator])		ifTrue: [self toggleShowBundles].	self toggleShowPackages.	self refreshList</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #listTitle 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 375 200 1125 700 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 25 0 -1 1 -1 0.5 ) 					#name: #ListOfThings 					#flags: 0 					#minorKey: #listSpec 					#clientKey: #listOfThings ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 26 0.5 -1 1 0 1 ) 					#name: #DefinitionText 					#model: #definition 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 -1 0.5 -1 1 1 0.5 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'ListOfThings' 					#belowWidgets: 'commentLabel DefinitionText' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 1 0.4 2 0 ) 					#name: #versionsLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsC 						#defaultString: 'Versions:' 						#catalogID: #labels ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 1 0.4 3 0.5 ) 					#name: #commentLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #CommentC 						#defaultString: 'Comment:' 						#catalogID: #labels ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 25 0 -1 0.4 -1 1 ) 					#name: #selectionTool 					#clientKey: #searchModule ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 2 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundlesAndPackagesC 						#defaultString: 'Bundles and Packages:' 						#catalogID: #labels ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.4 25 0 1 0.4 -1 1 ) 					#name: #ResizingSplitter2 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionTool' 					#belowWidgets: 'versionsLabel ListOfThings commentLabel ResizingSplitter1 DefinitionText' ) ) ) )</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Components 					#defaultString: '&amp;Components' 					#catalogID: #store ) 				#nameKey: #Packages 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&lt;new item1&gt;' 							#value: #packagesMenu ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Co_mment 					#defaultString: 'Co&amp;mment' 					#catalogID: #store ) 				#nameKey: #Comment 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&lt;new item2&gt;' 							#value: #textMenu ) ) #(1 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">packagesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packagesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Refresh 					#defaultString: 'Refresh' 					#catalogID: #store ) 				#nameKey: #UpdatePundleItems 				#value: #refreshList ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison">browseImageLeftMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^self leftImageMethod		ifNotNil: 			[:imageMethod |			self rightImageMethod = imageMethod				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: imageMethod displayString))						value: [self browseImageMethod: imageMethod];						yourself]]</body><body package="Store-Code Comparison">browseImageRightMenuItem	&lt;itemInMenu: #(#menu) position: 20.9&gt;	^self rightImageMethod		ifNotNil: 			[:imageMethod |			self leftImageMethod = imageMethod				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: imageMethod displayString))						value: [self browseImageMethod: imageMethod];						yourself]]</body><body package="Store-Code Comparison">browseImageSameMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^(MenuItem labeled: #BrowseImage &lt;&lt; #IDE &gt;&gt; 'Browse Image')		visible: 				[self rightImageMethod notNil					and: [self leftImageMethod = self rightImageMethod]];		value: [self browseImageMethod: self rightImageMethod];		yourself</body><body package="Store-Code Comparison">browseStoreLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^self leftStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText						, (self storeObjectVersionLabel: storeMethodInPackage))				value: [self browseStoreMethod: storeMethodInPackage];				yourself]</body><body package="Store-Code Comparison">browseStoreRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.2&gt;	^self rightStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(self leftStoreMethod ifNotNil: #primaryKey)				= storeMethodInPackage primaryKey					ifTrue: [nil]					ifFalse: 						[(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText									, (self storeObjectVersionLabel: storeMethodInPackage))							value: [self browseStoreMethod: storeMethodInPackage];							yourself]]</body><body package="Store-Code Comparison">loadLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^self leftStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(self canRevertFrom: self rightImageMethod to: storeMethodInPackage)				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText								, (self storeObjectVersionLabel: storeMethodInPackage))						value: [self loadMethod: storeMethodInPackage];						yourself]]</body><body package="Store-Code Comparison">loadRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.6&gt;	^self rightStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(self canRevertFrom: self leftImageMethod to: storeMethodInPackage)				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText								, (self storeObjectVersionLabel: storeMethodInPackage))						value: [self loadMethod: storeMethodInPackage];						yourself]]</body><body package="Store-Code Comparison">revertLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^(self canRevertFrom: self rightImageMethod to: self leftStoreMethod)		ifTrue: 			[(MenuItem labeled: (#StoreRevertPrefix &lt;&lt; #IDE &gt;&gt; 'Revert ') asText						, (self storeObjectVersionLabel: self leftStoreMethod))				value: 						[#{Store.XChangeSet} value current							revertSelector: self rightImageMethod selector							class: self rightImageMethod implementingClass];				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison">revertRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.6&gt;	^(self canRevertFrom: self leftImageMethod to: self rightStoreMethod)		ifTrue: 			[(MenuItem labeled: (#StoreRevertPrefix &lt;&lt; #IDE &gt;&gt; 'Revert ') asText						, (self storeObjectVersionLabel: self rightStoreMethod))				value: 						[#{Store.XChangeSet} value current							revertSelector: self leftImageMethod selector							class: self leftImageMethod implementingClass];				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 40.9&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visible: [self leftStoreMethod notNil or: [self rightStoreMethod notNil]];		value: [self openMethodVersions];		yourself</body></methods><methods><class-id>Store.BlessingLevel class</class-id> <category>interface specs</category><body package="Store-User Management">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #ResetBlessingLevelAndComment #catalogID: #store #defaultString: 'Reset Blessing Level and Comment') 			#min: #(#{Core.Point} 331 321 ) 			#bounds: #(#{Graphics.Rectangle} 159 403 630 883 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -83 1 ) 					#label: #(#{UserMessage} #key: #BundleAndSubcomponents #catalogID: #store #defaultString: 'Bundle and Subcomponents') ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -41 1 -3 1 -39 1 ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -280 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: #(#{UserMessage} #key: #BlessingcommentC #catalogID: #store #defaultString: 'Blessing comment:') ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 19 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -220 1 -11 1 -90 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -50 1 0.5 1 ) 					#model: #allBlessings 					#label: #(#{UserMessage} #key: #SetGlobalBlessingLevelAndComment #catalogID: #store #defaultString: 'Set Global Blessing Level and Comment') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Ok #catalogID: #store #defaultString: 'Ok') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #store #defaultString: 'Help') 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1.0 0 1.0 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.08 ) 							#label: #(#{UserMessage} #key: #BlessinglevelC #catalogID: #store #defaultString: 'Blessing level:') ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 11 223 460 248 ) ) ) ) ) )</body></methods><methods><class-id>Store.ElementView class</class-id> <category>resources</category><body package="Store-UI-Graphs">emptyInImage	"UIMaskEditor new openOnClass: self andSelector: #emptyInImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 20 0 0 0 34 0 0 0 65 0 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs">emptyOutImage	"UIMaskEditor new openOnClass: self andSelector: #emptyOutImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 255 128 0 0 65 0 0 0 34 0 0 0 20 0 0 0 8 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs">fullInImage	"UIMaskEditor new openOnClass: self andSelector: #fullInImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 28 0 0 0 62 0 0 0 127 0 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs">fullOutImage	"UIMaskEditor new openOnClass: self andSelector: #fullOutImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 255 128 0 0 127 0 0 0 62 0 0 0 28 0 0 0 8 0 0 0 0 0 0 0])</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus -- Class</category><body package="Store-Difference Management">browseMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 10.1&gt;	^(MenuItem labeled: [#AmpBrowseVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Browse Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canActOnMainClass and: [self namespaceNotSelected]]];		value: #browseMainClass</body><body package="Store-Difference Management">browseOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 10.2&gt;	^(MenuItem labeled: [#B_rowseVersionIn1s &lt;&lt; #store &gt;&gt; 'B&amp;rowse Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canActOnOtherClass and: [self namespaceNotSelected]]];		value: #browseOtherClass</body><body package="Store-Difference Management">fileOutMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 20.1&gt;	^(MenuItem labeled: [#AmpFileOutVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;File Out Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canFileOutMainClass]];		value: #fileOutMainClass</body><body package="Store-Difference Management">fileOutOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 20.2&gt;	^(MenuItem labeled: [#F_ileOutVersionIn1s &lt;&lt; #store &gt;&gt; 'F&amp;ile Out Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canFileOutOtherClass]];		value: #fileOutOtherClass</body><body package="Store-Difference Management">loadMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 30.1&gt;	^(MenuItem labeled: [#AmpLoadVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Load Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		enablement: [self packageIsInImage and: [self classObjectIsSelected and: [self canActOnMainClass]]];		visible: [self mainPackageIsPseudo not];		value: #loadMainClass</body><body package="Store-Difference Management">loadOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 30.2&gt;	^(MenuItem labeled: [#L_oadVersionIn1s &lt;&lt; #store &gt;&gt; 'L&amp;oad Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		enablement: [self packageIsInImage and: [self classObjectIsSelected and: [self canActOnOtherClass]]];		visible: [self otherPackageIsPseudo not];		value: #loadOtherClass</body><body package="Store-Difference Management">packagesContainingMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 40.1&gt;	^(MenuItem labeled: [#AmpPackagesContainingVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Packages Containing Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self mainClassIsNotExtension]];		value: #packagesContainingMainObject</body><body package="Store-Difference Management">packagesContainingOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 40.2&gt;	^(MenuItem labeled: [#PackagesAmpContainingVersionIn1s &lt;&lt; #store &gt;&gt; 'Packages &amp;Containing Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self otherClassIsNotExtension]];		value: #packagesContainingOtherObject</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus -- Definition</category><body package="Store-Difference Management">fileOutMainDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 20.1&gt;	^(MenuItem labeled: [#AmpFileOutVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;File Out Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: #canFileOutMainDefinitions;		value: #fileOutMainDefinitions</body><body package="Store-Difference Management">fileOutOtherDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 20.2&gt;	^(MenuItem labeled: [#F_ileOutVersionIn1s &lt;&lt; #store &gt;&gt; 'F&amp;ile Out Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: #canFileOutOtherDefinitions;		value: #fileOutOtherDefinitions</body><body package="Store-Difference Management">loadMainDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 30.1&gt;	^(MenuItem labeled: [#AmpLoadVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Load Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		enablement: [self packageIsInImage and: [self canLoadMainDefinitions]];		visible: [self mainPackageIsPseudo not];		value: #loadMainDefinitions</body><body package="Store-Difference Management">loadOtherDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 30.2&gt;	^(MenuItem labeled: [#L_oadVersionIn1s &lt;&lt; #store &gt;&gt; 'L&amp;oad Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		enablement: [self packageIsInImage and: [self canLoadOtherDefinitions]];		visible: [self otherPackageIsPseudo not];		value: #loadOtherDefinitions</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus -- Package</category><body package="Store-Difference Management">browseMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 10.1&gt;	^(MenuItem labeled: [#AmpBrowseVersion1s &lt;&lt; #store &gt;&gt; '&amp;Browse Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #browseMainPackage</body><body package="Store-Difference Management">browseOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 10.2&gt;	^(MenuItem labeled: [#B_rowseVersion1s &lt;&lt; #store &gt;&gt; 'B&amp;rowse Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #browseOtherPackage</body><body package="Store-Difference Management">compareMainMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 30.10&gt;	^(MenuItem labeled: [#AmpCompareVersion1stoDots &lt;&lt; #store &gt;&gt; '&amp;Compare Version &lt;1s&gt; to...' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #compareMainPackage</body><body package="Store-Difference Management">compareOtherMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 30.20&gt;	^(MenuItem labeled: [#C_ompareVersion1stoDots &lt;&lt; #store &gt;&gt; 'C&amp;ompare Version &lt;1s&gt; to...' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #compareOtherPackage</body><body package="Store-Difference Management">fileOutDifferencesMainToOtherMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 30.10&gt;	^(MenuItem labeled: [#AmpDifferencesBetween1sand2s &lt;&lt; #store &gt;&gt; '&amp;Differences Between &lt;1s&gt; and &lt;2s&gt;' 		expandMacrosWith: self mainPackageVersionName		with: self otherPackageVersionName])			visible: [self otherPackageIsPseudo not and: [self mainPackageIsPseudo not]];			value: #fileOutMainToOtherPackageDifference</body><body package="Store-Difference Management">fileOutDifferencesOtherToMainMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 30.20&gt;	^(MenuItem labeled: [#Di_fferencesBetween1sand2s &lt;&lt; #store &gt;&gt; 'Di&amp;fferences Between &lt;1s&gt; and &lt;2s&gt;' 		expandMacrosWith: self otherPackageVersionName		with: self mainPackageVersionName])			visible: [self otherPackageIsPseudo not and: [self mainPackageIsPseudo not]];			value: #fileOutOtherToMainPackageDifference</body><body package="Store-Difference Management">fileOutMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 10.10&gt;	^(MenuItem labeled: [#AmpFileOutVersion1s &lt;&lt; #store &gt;&gt; '&amp;File Out Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #fileOutMainPackage</body><body package="Store-Difference Management">fileOutOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 10.20&gt;	^(MenuItem labeled: [#F_ileOutVersion1s &lt;&lt; #store &gt;&gt; 'F&amp;ile Out Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #fileOutOtherPackage</body><body package="Store-Difference Management">graphMainMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 20.10&gt;	^(MenuItem labeled: [#AmpGraphVersion1s &lt;&lt; #store &gt;&gt; '&amp;Graph Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #graphMainVersion</body><body package="Store-Difference Management">graphOtherMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 20.20&gt;	^(MenuItem labeled: [#G_raphVersion1s &lt;&lt; #store &gt;&gt; 'G&amp;raph Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #graphOtherVersion</body><body package="Store-Difference Management">loadMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.10&gt;	^(MenuItem labeled: [#AmpLoadVersion1s &lt;&lt; #store &gt;&gt; '&amp;Load Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		enablement: #canLoadMainPackage;		visible: [self mainPackageIsPseudo not];		value: #loadMainPackage</body><body package="Store-Difference Management">loadOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.20&gt;	^(MenuItem labeled: [#L_oadVersion1s &lt;&lt; #store &gt;&gt; 'L&amp;oad Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		enablement: #canLoadOtherPackage;		visible: [self otherPackageIsPseudo not];		value: #loadOtherPackage</body><body package="Store-Difference Management">mergeMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.30&gt;	^(MenuItem labeled: [#AmpMergeVersion1s &lt;&lt; #store &gt;&gt; '&amp;Merge Version &lt;1s&gt; Into Image' expandMacrosWith: self mainPackageVersionName])		enablement: #packageIsInImageButNotActualImage;		visible: [self mainPackageIsPseudo not];		value: #mergeMainIntoImage</body><body package="Store-Difference Management">mergeOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.40&gt;	^(MenuItem labeled: [#M_ergeVersion1s &lt;&lt; #store &gt;&gt; 'M&amp;erge Version &lt;1s&gt; Into Image' expandMacrosWith: self otherPackageVersionName])		enablement: #packageIsInImage;		visible: [self otherPackageIsPseudo not];		value: #mergeOtherIntoImage</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>interface specs</category><body package="Store-Difference Management">alternateSpec	"Tools.UIPainter new openOnClass: self andSelector: #alternateSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Compare Packages' 			#min: #(#{Core.Point} 400 300 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 917 438 1717 1038 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 0.3 -2 1 ) 					#name: #Packages 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 210 0.3 -10 0.45 ) 					#name: #SharedSelection 					#label: 'Shared Variables' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25 0.3 -10 0.45 ) 					#name: #InstanceSelection 					#label: 'Instance' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 120 0.3 -10 0.45 ) 					#name: #ClassSelection 					#label: 'Class' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.3 -12 0.45 0 1 -10 0.45 ) 					#name: #TopVsBottom 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'TopGroup' 					#belowWidgets: 'BottomGroup InstanceSelection ClassSelection SharedSelection' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.3 2 0 2 0.3 -2 1 ) 					#name: #PackagesVsEverything 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'Packages' 					#belowWidgets: 'TopGroup BottomGroup TopVsBottom InstanceSelection ClassSelection SharedSelection' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 							#name: #ClassesAndPseudo 							#useModifierKeys: true 							#selectionType: #highlight ) 						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 							#name: #MethodsOrProperties 							#useModifierKeys: true 							#selectionType: #highlight ) 						#(#{UI.ResizingSplitterSpec} 							#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 							#name: #TopSplitter 							#horizontal: false 							#minAboveSize: 30 							#minBelowSize: 30 							#aboveWidgets: 'ClassesAndPseudo' 							#belowWidgets: 'MethodsOrProperties' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 2 0.3 2 0 0 1 -15 0.45 ) 						#name: #TopGroup ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 -20 1 ) 							#name: #FromDefinition 							#tabRequiresControl: true ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 -20 1 ) 							#name: #ToDefinition 							#tabRequiresControl: true ) 						#(#{UI.ResizingSplitterSpec} 							#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 							#name: #BottomSplitter 							#horizontal: false 							#minAboveSize: 30 							#minBelowSize: 30 							#aboveWidgets: 'FromDefinition FromProtocol' 							#belowWidgets: 'ToDefinition ToProtocol' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 -20 1 -2 0.5 0 1 ) 							#name: #FromProtocol 							#isReadOnly: true 							#type: #text ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.5 -20 1 0 1 0 1 ) 							#name: #ToProtocol 							#isReadOnly: true 							#type: #text ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 2 0.3 15 0.45 -2 1 -2 1 ) 						#name: #BottomGroup ) ) ) ) )</body><body package="Store-Difference Management">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window: #(#{UI.WindowSpec}			#label: #(#{UserMessage}				#key: #ComparePackages				#catalogID: #store				#defaultString: 'Compare Packages')			#min: #(#{Core.Point} 300 300)			#max: #(#{Core.Point} 0 0)			#bounds: #(#{Graphics.Rectangle} 160 448 860 1148)			#flags: 4			#menu: #mainMenu)		#component: #(#{UI.SpecCollection}			#collection: #(#(#{UI.SequenceViewSpec}				#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 1 -36 0.2)				#name: #Packages				#model: #comparedPackages				#menu: #packageMenu				#useModifierKeys: true				#selectionType: #highlight) #(#{UI.ResizingSplitterSpec}				#layout: #(#{Graphics.LayoutFrame} 2 0 -36 0.2 -2 1 -32 0.2)				#name: #PackagesVsEverything				#horizontal: true				#minAboveSize: 30				#minBelowSize: 30				#aboveWidgets: 'Packages'				#belowWidgets: 'CompareGroup') #(#{UI.CompositeSpecCollection}				#collection: #(#(#{UI.RadioButtonSpec}					#layout: #(#{Graphics.LayoutOrigin} 13 0 -73 0.4)					#name: #InstanceSelection					#model: #selectionType					#label: #(#{UserMessage}						#key: #Instance						#catalogID: #store						#defaultString: 'Instance')					#select: #instance) #(#{UI.RadioButtonSpec}					#layout: #(#{Graphics.LayoutOrigin} 108 0 -73 0.4)					#name: #ClassSelection					#model: #selectionType					#label: 'Class'					#select: #class) #(#{UI.RadioButtonSpec}					#layout: #(#{Graphics.LayoutOrigin} 203 0 -73 0.4)					#name: #SharedSelection					#model: #selectionType					#label: #(#{UserMessage}						#key: #SharedVariables						#catalogID: #store						#defaultString: 'Shared Variables')					#select: #shared) #(#{UI.ResizingSplitterSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0 -75 0.4 0 1 -73 0.4)					#name: #TopVsBottom					#horizontal: true					#minAboveSize: 30					#minBelowSize: 30					#aboveWidgets: 'TopGroup'					#belowWidgets: 'BottomGroup InstanceSelection ClassSelection SharedSelection') #(#{UI.CompositeSpecCollection}					#collection: #(#(#{UI.SequenceViewSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1)						#name: #ClassesAndPseudo						#model: #classesAndProperties						#menu: #classesMenu						#useModifierKeys: true						#selectionType: #highlight) #(#{UI.SequenceViewSpec}						#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1)						#name: #MethodsOrProperties						#model: #methodsOrProperties						#menu: #methodsMenu						#multipleSelections: true						#useModifierKeys: true						#selectionType: #highlight) #(#{UI.ResizingSplitterSpec}						#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1)						#name: #TopSplitter						#horizontal: false						#minAboveSize: 30						#minBelowSize: 30						#aboveWidgets: 'ClassesAndPseudo'						#belowWidgets: 'MethodsOrProperties'))					#compositeSpec: #(#{UI.CompositeSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -79 0.4)						#name: #TopGroup)) #(#{UI.CompositeSpecCollection}					#collection: #(#(#{UI.TextEditorSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 -20 1)						#name: #FromDefinition						#model: #fromDefinition						#menu: #definitionMenu						#isReadOnly: false						#tabRequiresControl: true) #(#{UI.TextEditorSpec}						#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 -20 1)						#name: #ToDefinition						#model: #toDefinition						#menu: #definitionMenu						#tabRequiresControl: true) #(#{UI.ResizingSplitterSpec}						#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1)						#name: #BottomSplitter						#horizontal: false						#minAboveSize: 30						#minBelowSize: 30						#aboveWidgets: 'FromDefinition FromProtocol'						#belowWidgets: 'ToDefinition ToProtocol') #(#{UI.InputFieldSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 -20 1 -2 0.5 0 1)						#name: #FromProtocol						#model: #fromProtocol						#menu: #noMenu						#isReadOnly: true						#type: #text) #(#{UI.InputFieldSpec}						#layout: #(#{Graphics.LayoutFrame} 2 0.5 -20 1 0 1 0 1)						#name: #ToProtocol						#model: #toProtocol						#menu: #noMenu						#isReadOnly: true						#type: #text))					#compositeSpec: #(#{UI.CompositeSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 -53 0.4 0 1 0 1)						#name: #BottomGroup)))				#compositeSpec: #(#{UI.CompositeSpec}					#layout: #(#{Graphics.LayoutFrame} 2 0 -32 0.2 -2 1 -2 1)					#name: #CompareGroup)))))</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Unloadables Support">definitionSpec	"Tools.UIPainter new openOnClass: self andSelector: #definitionSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #store #defaultString: 'Unlabeled Canvas') 			#min: #(#{Core.Point} 434 226 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1134 751 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #text 					#menu: #readOnlyCodeMenu 					#tabRequiresControl: true ) ) ) )</body><body package="Store-UI-Unloadables Support">horizontalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #horizontalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnloadableDefinitionsForPackage #catalogID: #store #defaultString: 'Unloadable Definitions for package:') 			#bounds: #(#{Graphics.Rectangle} 679 105 1315 587 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 1 0.35 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.35 0 1 3 0.35 ) 					#name: #splitter 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'viewers' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 3 0.35 0 1 0 1 ) 					#name: #viewers 					#model: #viewerListHolder 					#labels: #() ) ) ) )</body><body package="Store-UI-Unloadables Support">verticalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #verticalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnloadableDefinitionsForPackage #catalogID: #store #defaultString: 'Unloadable Definitions for package:') 			#bounds: #(#{Graphics.Rectangle} 700 525 1336 1007 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.5 0 1 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 2 0.5 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'viewers' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #viewers 					#model: #viewerListHolder 					#labels: #() ) ) ) )</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>resources</category><body package="Store-UI-Unloadables Support">definitionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #definitionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Load 					#defaultString: 'Load' 					#catalogID: #store ) 				#nameKey: #loadDefinition 				#value: #loadDefinition 				#enablementSelector: #anyNotLoadedSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAsDots 					#defaultString: 'File Out As...' 					#catalogID: #store ) 				#nameKey: #fileOut 				#value: #fileOut 				#enablementSelector: #anySelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RemoveFromPackage 					#defaultString: 'Remove from Package' 					#catalogID: #store ) 				#nameKey: #removeFromPackage 				#value: #removeFromPackage 				#enablementSelector: #anySelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #LoadAll 					#defaultString: 'Load All' 					#catalogID: #store ) 				#nameKey: #loadAll 				#value: #loadAll ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAll 					#defaultString: 'File Out All...' 					#catalogID: #store ) 				#nameKey: #fileOutAll 				#value: #fileOutAll ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Unloadables Support">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Definition 					#defaultString: '&amp;Definition' 					#catalogID: #store ) 				#nameKey: #definition ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Help 								#defaultString: 'Help' 								#catalogID: #store ) 							#nameKey: #briefHelp 							#value: #briefHelp 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Topics 								#defaultString: 'Topics' 								#catalogID: #store ) 							#nameKey: #topics ) ) #(2 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Unloadables Support">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AcceptAnd_Load 					#defaultString: 'Accept and &amp;Load' 					#catalogID: #store ) 				#value: #acceptAndLoad 				#enablementSelector: #oneSelected 				#shortcutKeyCharacter: $s				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#shortcutKeyCharacter: $b 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#shortcutKeyCharacter: $c 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find 				#shortcutKeyCharacter: $f 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext 				#shortcutKeyCharacter: $g 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText 				#shortcutKeyCharacter: $a 				#shortcutModifiers: 2 ) ) #(1 3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#shortcutKeyCharacter: $F 				#shortcutModifiers: 2 ) ) #(3 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UserGroups #catalogID: #store #defaultString: 'User Groups') 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 310 212 843 652 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 229 0 -1 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #graphView ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 70 0.5 30 0 -3 1 220 0 ) 					#name: #userListID 					#model: #userList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 30 0 -70 0.5 220 0 ) 					#name: #groupListID 					#model: #groupList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 80 0.5 8 0 ) 					#label: #(#{UserMessage} #key: #GroupMember #catalogID: #store #defaultString: 'Group Member:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 8 ) 					#label: #(#{UserMessage} #key: #Group #catalogID: #store #defaultString: 'Group:') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 42 0 60 0.5 77 0 ) 					#name: #addToGroup 					#model: #addToGroup 					#label: #(#{UserMessage} #key: #Add #catalogID: #store #defaultString: 'Add') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 75 0 60 0.5 110 0 ) 					#name: #removeFromGroup 					#model: #removeFromGroup 					#label: #(#{UserMessage} #key: #Remove #catalogID: #store #defaultString: 'Remove') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 146 0 60 0.5 181 0 ) 					#name: #newUser 					#model: #newUser 					#label: #(#{UserMessage} #key: #NewUser #catalogID: #store #defaultString: 'New User...') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 179 0 60 0.5 214 0 ) 					#name: #newGroup 					#model: #newGroup 					#label: #(#{UserMessage} #key: #NewGroup #catalogID: #store #defaultString: 'New Group...') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs">menuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(1 ) #(#closeRequest ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.PackageListPane class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SetBlessingLevelDots 								#defaultString: '&amp;Set Blessing Level...' 								#catalogID: #store ) 							#nameKey: #SetBlessingLevel 							#value: #setBlessingLevel 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOutSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Graph 								#defaultString: '&amp;Graph' 								#catalogID: #store ) 							#nameKey: #Graph 							#value: #graphSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWith_Parent 								#defaultString: 'Compare with &amp;Parent' 								#catalogID: #store ) 							#nameKey: #CompareWithParent 							#value: #compareWithParent 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_EnclosingBundles 								#defaultString: '&amp;Enclosing Bundles' 								#catalogID: #store ) 							#nameKey: #enclosingBundles 							#value: #enclosingBundles 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ContainedI_tems 								#defaultString: 'Contained I&amp;tems' 								#catalogID: #store ) 							#nameKey: #ContainedItems 							#value: #containedItems 							#enablementSelector: #selectionIsBundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Load 								#defaultString: '&amp;Load' 								#catalogID: #menus ) 							#nameKey: #Load 							#value: #loadSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_MergeIntoImage 								#defaultString: '&amp;Merge Into Image' 								#catalogID: #store ) 							#nameKey: #Merge 							#value: #mergeIntoImage 							#enablementSelector: #atLeastOneVersionSelectedAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReconcileImageWithSelection 								#defaultString: '&amp;Reconcile Image with Selection' 								#catalogID: #store ) 							#nameKey: #Reconcile 							#value: #reconcile 							#enablementSelector: #oneItemAndInImage ) ) #(3 2 5 3 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.PackageListPane class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 160 568 360 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#flags: 15 					#model: #itemsInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #browseSelectedVersion ) 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Unloadables Support">horizontalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #horizontalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #store #defaultString: 'Unlabeled Canvas') 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1336 1007 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -2 0.33333 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.33333 0 1 2 0.33333 ) 					#name: #splitter 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.33333 0 1 0 1 ) 					#name: #text 					#model: #text 					#menu: #readOnlyCodeMenu 					#tabRequiresControl: true ) ) ) )</body><body package="Store-UI-Unloadables Support">verticalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #verticalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #store #defaultString: 'Unlabeled Canvas') 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1336 1007 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.33333 0 1 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.33333 0 0 2 0.33333 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.33333 0 0 0 1 0 1 ) 					#name: #text 					#model: #text 					#menu: #readOnlyCodeMenu 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>resources</category><body package="Store-UI-Unloadables Support">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertiesTool</class-id> <category>registered properties</category><body package="StoreForGlorpBrowserUI">miscProperties	&lt;property: 200&gt;	^StoreCodeComponentInspectPropertiesTool new codeModel: codeModel</body><body package="StoreForGlorpBrowserUI">summaryProperty		&lt;property: 10&gt;	^CodeComponentSummaryTool codeModel: codeModel</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>menus</category><body package="StoreForGlorpBrowserUI">toolsMenuToggleStatusBarItem	&lt;menuItemForCommand: #toggleStatusBar		nameKey: nil		enablement: #isStatusBarEnabled		indication: #showStatusBar		menu: #(#toolsMenu)		position: 50.20&gt;	self toggleStatusBar</body><body package="StoreForGlorpBrowserUI">toolsMenuToggleToolbarItem	&lt;itemInMenu: #(#toolsMenu) position: 50.10&gt;	^(MenuItem labeled: #Toolbar &lt;&lt; #browser &gt;&gt; 'Toolbar')		indication: [self showToolbar];		value: [self toggleToolbar]</body><body package="StoreForGlorpBrowserUI">zoomBrowserItem	&lt;menuItemForCommand: #zoom		nameKey: nil		enablement: nil		indication: #isZoomed		menu: #(#viewMenu)		position: 10.1&gt;	self toggleZoom</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI">findMenu	"Tools.MenuEditor new openOnClass: self andSelector: #findMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ClassVariableNamespaceDots 					#defaultString: '&amp;Class/Variable/Name Space...' 					#catalogID: #browser ) 				#nameKey: #'Find Global Name' 				#value: 				#action: 				#shortcutKeyCharacter: $l 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findClass ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_MethodDots 					#defaultString: '&amp;Method...' 					#catalogID: #browser ) 				#nameKey: #'Find Method' 				#value: 				#action: 				#shortcutKeyCharacter: $m 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ImplementorsMatchingDots 					#defaultString: 'Implementors Matching...' 					#catalogID: #browser ) 				#nameKey: #'Implementors Matching' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #MethodsWithStringsMatchingDots 					#defaultString: 'Methods with Strings Matching...' 					#catalogID: #browser ) 				#nameKey: #'Methods with Strings Matching' 				#value: 				#action: ) ) #(2 1 1 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI">helpMenu	"Tools.MenuEditor new openOnClass: self andSelector: #helpMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#commandID: #help 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SystemBrowser 					#defaultString: 'System Browser' 					#catalogID: #browser ) 				#nameKey: #'Context Help' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CreateBuffer 					#defaultString: 'Create Buffer' 					#catalogID: #browser ) 				#nameKey: #'Create Buffer' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #newView ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindClassVariableNameSpace 					#defaultString: 'Find Class/Variable/Name Space' 					#catalogID: #browser ) 				#nameKey: #'Find Global Name' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findClass ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindMethod 					#defaultString: 'Find Method' 					#catalogID: #browser ) 				#nameKey: #'Find Method' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Implementors 					#defaultString: 'Implementors' 					#catalogID: #browser ) 				#nameKey: #'Local Implementors' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) ) ) #(1 1 2 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI">toolsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CodeModelToolsMenu 					#defaultString: 'Code Model Tools Menu' 					#catalogID: #browser ) 				#nameKey: #'Code Model Tools Menu' 				#value: #dynamicMenu ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI">viewMenu	"Tools.MenuEditor new openOnClass: self andSelector: #viewMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'dummy' 				#visible: false 				#enabled: false ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewView 					#defaultString: '&amp;New View' 					#catalogID: #browser ) 				#nameKey: #'Create Buffer' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #newView ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RemoveCurrentView 					#defaultString: '&amp;Remove Current View' 					#catalogID: #browser ) 				#nameKey: #'Remove Buffer' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Buffers 					#defaultString: 'Buffers' 					#catalogID: #browser ) 				#nameKey: #Buffers 				#value: #dynamicMenu ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_MoreBuffers 					#defaultString: '&amp;More Buffers' 					#catalogID: #browser ) 				#nameKey: #'More Buffers' 				#value: 				#action: 				#enablementSelector: #has10orMoreCodeTools ) ) #(1 2 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser class</class-id> <category>interface specs</category><body package="StoreForGlorpBrowserUI">findWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #findWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #browser ) 			#bounds: #(#{Graphics.Rectangle} 680 435 970 465 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -315 1 13 0 1 0.5 ) 					#name: #findLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #FindC 						#defaultString: 'Find:' 						#catalogID: #browser ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} -310 1 0 0 0 1 25 0 ) 					#name: #find 					#model: #findHolder 					#tabable: true 					#isReadOnly: false 					#comboList: #findList ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} -180 0.5 12 0 0.5 0.5 ) 					#name: #storeLabelImage 					#label: #storeLabelImage 					#hasCharacterOrientedLabel: false ) ) ) )</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>interface specs</category><body package="Store-Merge Management">radioCompareSelectionSpec	"Tools.UIPainter new openOnClass: self andSelector: #compareWithRadios"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MergeTool 				#defaultString: 'Merge Tool' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 643 530 1235 908 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 0 0.5 0 0.5 ) 					#name: #CompareWithImageRadio 					#model: #compareWithHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #Image 						#defaultString: 'Image' 						#catalogID: #IDE ) 					#select: #conflictsWithImage ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 0 0.5 0.5 0.5 ) 					#name: #CompareWithResolutionRadio 					#model: #compareWithHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #Resolution 						#defaultString: 'Resolution' 						#catalogID: #IDE ) 					#select: #conflictsWithResolution ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 0 0.5 1 0.5 ) 					#name: #CompareWithBaseRadio 					#model: #compareWithHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #Base 						#defaultString: 'Base' 						#catalogID: #IDE ) 					#select: #conflictsWithBase ) ) ) )</body><body package="Store-Merge Management">sideBySideTextSpec	"Tools.UIPainter new openOnClass: self andSelector: #sideBySideTextSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MergeTool 				#defaultString: 'Merge Tool' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 840 525 1432 903 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 25 0 0 1 -20 1 ) 					#name: #displayTextID 					#model: #displayText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#validateTextOnExit: ) 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 -2 0.5 -20 1 ) 					#name: #conflictTextID 					#model: #conflictText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#validateTextOnExit: ) 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#conflictTextID radioCompareSelectionCanvas  ConflictProtocol' 					#belowWidgets: '#displayTextID  #SelectionProtocol' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 -20 1 0 1 0 1 ) 					#name: #SelectionProtocol 					#model: #selectionProtocol 					#style: #default 					#isReadOnly: true 					#type: #text ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -20 1 -2 0.5 0 1 ) 					#name: #ConflictProtocol 					#model: #conflictProtocol 					#style: #default 					#isReadOnly: true 					#type: #text ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 25 0 ) 					#name: #radioCompareSelectionCanvas 					#flags: 0 					#minorKey: #radioCompareSelectionSpec ) ) ) )</body><body package="Store-Merge Management">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MergeTool 				#defaultString: 'Merge Tool' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 400 1800 1100 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #toolbarMenuHolder ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.5 30 0.5 ) 					#name: #ModTabs 					#model: #resolutionListTabs 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #resolutionListTabsChanged ) 					#labels: #() ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 21 0 0 1 30 0.5 ) 					#name: #pkgListID 					#flags: 15 					#model: #packageList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #chooseAsResolution ) 					#tabable: true 					#menu: #versionMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 32 0.5 0 1 0 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #sideBySideTextSpec ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0.5 0 1 32 0.5 ) 					#name: #mainHorizontalSplitter 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#ModTabs #pkgListID #ResizingSplitter2' 					#belowWidgets: 'textCanvas' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.5 0 0 1 0.5 30 0.5 ) 					#name: #ResizingSplitter2 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#ModTabs' 					#belowWidgets: '#pkgListID VersionLabel' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 2 0.5 21 0 0 1 ) 					#name: #VersionLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsC 						#defaultString: 'Versions:' 						#catalogID: #store ) ) ) ) )</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>resources</category><body package="Store-Merge Management">menuBarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Packages 					#defaultString: '&amp;Packages' 					#catalogID: #store ) 				#nameKey: #packagesMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Se_lectPackages 								#defaultString: 'Se&amp;lect Packages...' 								#catalogID: #store ) 							#nameKey: #selectPackages 							#value: #selectPackages ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PublishPackages 								#defaultString: '&amp;Publish Packages...' 								#catalogID: #store ) 							#nameKey: #publishPackages 							#value: #publishPackages 							#enablementSelector: #couldPublishPackages ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Sho_wSummary 								#defaultString: 'Sho&amp;w Summary' 								#catalogID: #store ) 							#nameKey: #showStatus 							#value: #showStatus ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Publish_InformativeBlessingsOnly 								#defaultString: 'Publish &amp;Informative Blessings Only' 								#catalogID: #store ) 							#nameKey: #PublishInformativeBlessingsOnly 							#value: #toggleInformativeBlessingsOnly 							#indicationSelector: #informativeBlessingsOnly ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Close 								#defaultString: '&amp;Close' 								#catalogID: #store ) 							#nameKey: #exit 							#value: #exit ) ) #(2 1 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Resolution 					#defaultString: '&amp;Resolution' 					#catalogID: #store ) 				#nameKey: #resolutionMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Unresolve 								#defaultString: '&amp;Unresolve' 								#catalogID: #store ) 							#nameKey: #unresolve 							#value: #unresolve 							#enablementSelector: #canUnresolve 							#shortcutKeyCharacter: #F4 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #unresolved ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SelectAsResolution 								#defaultString: '&amp;Select as Resolution' 								#catalogID: #store ) 							#nameKey: #chooseAsResolution 							#value: #chooseAsResolution 							#enablementSelector: #canResolve 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #resolved ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectAndApply_Resolution 								#defaultString: 'Select and Apply &amp;Resolution' 								#catalogID: #store ) 							#nameKey: #applySelection 							#value: #applySelection 							#enablementSelector: #canResolve ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ApplyResolution 								#defaultString: '&amp;Apply Resolution' 								#catalogID: #store ) 							#nameKey: #applyResolution 							#value: #applyResolution 							#enablementSelector: #canApplyResolution 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applied ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ApplyA_llResolutions 								#defaultString: 'Apply A&amp;ll Resolutions' 								#catalogID: #store ) 							#nameKey: #applyResolved 							#value: #applyResolved 							#enablementSelector: #containsResolvedAndNotApplied 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applyAll ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoNotResolve 								#defaultString: '&amp;Do Not Resolve' 								#catalogID: #store ) 							#nameKey: #DoNotResolve 							#value: #doNotResolve 							#enablementSelector: #canChooseDoNotResolve 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #doNotResolve ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Au_toSelectResolution 								#defaultString: 'Au&amp;to Select Resolution' 								#catalogID: #store ) 							#nameKey: #toggleAutoSelectResolution 							#value: #toggleAutoSelectResolution 							#indication: true 							#indicationSelector: #autoSelectResolution ) ) #(1 3 1 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #store ) 				#nameKey: #viewMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_All 								#defaultString: 'Show &amp;All' 								#catalogID: #store ) 							#nameKey: #showAll 							#value: #showAll 							#indication: true 							#indicationSelector: #isShowAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_Conflicts 								#defaultString: 'Show &amp;Conflicts' 								#catalogID: #store ) 							#nameKey: #showConflicts 							#value: #showConflicts 							#indication: true 							#indicationSelector: #isShowConflicts ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_Unresolved 								#defaultString: 'Show &amp;Unresolved' 								#catalogID: #store ) 							#nameKey: #showUnresolved 							#value: #showUnresolved 							#indication: true 							#indicationSelector: #isShowUnresolved ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowSourceDifferences 								#defaultString: 'Show Source Differences' 								#catalogID: #store ) 							#nameKey: #ShowSourceDifferences 							#value: #showSourceDifferences 							#indication: true 							#indicationSelector: #isShowingSourceDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowCodeDifferences 								#defaultString: 'Show Code Differences' 								#catalogID: #store ) 							#nameKey: #ShowCodeDifferences 							#value: #showCodeDifferences 							#indication: true 							#indicationSelector: #isShowingCodeDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Use_FullNames 								#defaultString: 'Use &amp;Full Names' 								#catalogID: #store ) 							#nameKey: #toggleFullNames 							#value: #toggleFullNames 							#indication: true 							#indicationSelector: #isShowLongNames ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #E_xpandTree 								#defaultString: 'E&amp;xpand Tree' 								#catalogID: #store ) 							#value: #expandHierarchy 							#enablementSelector: #canExpandHierarchy ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ZoomTextViews 								#defaultString: '&amp;Zoom Text Views' 								#catalogID: #store ) 							#nameKey: #toggleZoomTextViews 							#value: #toggleZoomTextViews 							#indication: true 							#indicationSelector: #areTextViewsZoomed 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_Toolbar 								#defaultString: 'Show &amp;Toolbar' 								#catalogID: #store ) 							#nameKey: #toggleToolbar 							#value: #toggleToolbar 							#indication: true 							#indicationSelector: #isShowingToolbar ) ) #(3 2 1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Browse 					#defaultString: '&amp;Browse' 					#catalogID: #store ) 				#nameKey: #browseMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse_Senders 								#defaultString: 'Browse &amp;Senders' 								#catalogID: #store ) 							#nameKey: #browseSenders 							#value: #browseSenders 							#enablementSelector: #methodSelected 							#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #referenceMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse_Implementors 								#defaultString: 'Browse &amp;Implementors' 								#catalogID: #store ) 							#nameKey: #browseImplementors 							#value: #browseImplementors 							#enablementSelector: #methodSelected 							#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse_Versions 								#defaultString: 'Browse &amp;Versions' 								#catalogID: #store ) 							#nameKey: #browseSenders 							#value: #browseVersions 							#enablementSelector: #canBrowseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenComparisonWith_Base 								#defaultString: 'Open Comparison with &amp;Base' 								#catalogID: #store ) 							#nameKey: #compareWithBase 							#value: #compareWithBase 							#enablementSelector: #versionSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenComparisonWith_Res 								#defaultString: 'Open Comparison with &amp;Resolution' 								#catalogID: #store ) 							#nameKey: #compareWithResolution 							#value: #compareWithResolution 							#enablementSelector: #canCompareWithResolution ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenComparisonWithI_mage 								#defaultString: 'Open Comparison with I&amp;mage' 								#catalogID: #store ) 							#nameKey: #compareWithImage 							#value: #compareWithImage 							#enablementSelector: #versionSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Open_ComparisonOfSelected 								#defaultString: 'Open &amp;Comparison of Selected' 								#catalogID: #store ) 							#nameKey: #compare 							#value: #compare 							#enablementSelector: #twoVersionsSelected ) ) #(3 4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #helpMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_HowToUseMergeTool 								#defaultString: '&amp;How to Use Merge Tool' 								#catalogID: #store ) 							#nameKey: #openHelpHowToUse 							#value: #openHelpHowToUse 							#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_IconsReference 								#defaultString: '&amp;Icons Reference' 								#catalogID: #store ) 							#nameKey: #openIconHelp 							#value: #openIconHelp ) ) #(2 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="Store-Merge Management">modificationMenu	"Tools.MenuEditor new openOnClass: self andSelector: #modificationMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Unresolve 					#defaultString: '&amp;Unresolve' 					#catalogID: #store ) 				#nameKey: #unresolve 				#value: #unresolve 				#enablementSelector: #canUnresolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #unresolved ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Apply_Resolution 					#defaultString: 'Apply &amp;Resolution' 					#catalogID: #store ) 				#nameKey: #applyResolution 				#value: #applyResolution 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applied ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoNotResolve 					#defaultString: '&amp;Do Not Resolve' 					#catalogID: #store ) 				#nameKey: #DoNotResolve 				#value: #doNotResolve 				#enablementSelector: #canChooseDoNotResolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #doNotResolve ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_Senders 					#defaultString: 'Browse &amp;Senders' 					#catalogID: #store ) 				#nameKey: #browseSenders 				#value: #browseSenders 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #referenceMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_Implementors 					#defaultString: 'Browse &amp;Implementors' 					#catalogID: #store ) 				#nameKey: #browseImplementors 				#value: #browseImplementors 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_Versions 					#defaultString: 'Browse &amp;Versions' 					#catalogID: #store ) 				#nameKey: #browseVersions 				#value: #browseVersions 				#enablementSelector: #canBrowseVersions ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #E_xpandTree 					#defaultString: 'E&amp;xpand Tree' 					#catalogID: #store ) 				#nameKey: #expandHierarchy 				#value: #expandHierarchy 				#enablementSelector: #canExpandHierarchy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show_All 					#defaultString: 'Show &amp;All' 					#catalogID: #store ) 				#nameKey: #showAll 				#value: #showAll 				#indication: true 				#indicationSelector: #isShowAll ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show_Conflicts 					#defaultString: 'Show &amp;Conflicts' 					#catalogID: #store ) 				#nameKey: #showConflicts 				#value: #showConflicts 				#indication: true 				#indicationSelector: #isShowConflicts ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ShowUnresol_ved 					#defaultString: 'Show Unresol&amp;ved' 					#catalogID: #store ) 				#nameKey: #showUnresolved 				#value: #showUnresolved 				#indication: true 				#indicationSelector: #isShowUnresolved ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ShowSourceDifferences 					#defaultString: 'Show Source Differences' 					#catalogID: #store ) 				#nameKey: #showSourceDifferences 				#value: #showSourceDifferences 				#indication: true 				#indicationSelector: #isShowingSourceDifferences ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ShowCodeDifferences 					#defaultString: 'Show Code Differences' 					#catalogID: #store ) 				#nameKey: #showCodeDifferences 				#value: #showCodeDifferences 				#indication: true 				#indicationSelector: #isShowingCodeDifferences ) ) #(1 1 1 3 1 3 2 ) nil ) decodeAsLiteralArray</body><body package="Store-Merge Management">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Unresolve 					#defaultString: 'Unresolve' 					#catalogID: #store ) 				#nameKey: #unresolve 				#value: #unresolve 				#enablementSelector: #canUnresolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #bigUnresolve ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #UnresolveThisModification 					#defaultString: 'Unresolve this modification' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAsResolution 					#defaultString: 'Select as Resolution' 					#catalogID: #store ) 				#nameKey: #chooseAsResolution 				#value: #chooseAsResolution 				#enablementSelector: #canResolve 				#labelImage: #(#{UI.ResourceRetriever} #{MergeIcons} #bigResolve ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #GenKey25 					#defaultString: 'Select this version as the resolution' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Apply 					#defaultString: 'Apply' 					#catalogID: #store ) 				#nameKey: #applyResolution 				#value: #applyResolution 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #bigApply ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #GenKey24 					#defaultString: 'Apply the current resolution of this modification' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseSenders 					#defaultString: 'Browse Senders' 					#catalogID: #store ) 				#nameKey: #browseSenders 				#value: #browseSenders 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #referenceMethod ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #BrowseSendersOfThisMethod 					#defaultString: 'Browse senders of this method' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseImplementors 					#defaultString: 'Browse Implementors' 					#catalogID: #store ) 				#nameKey: #browseImplementors 				#value: #browseImplementors 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #GenKey23 					#defaultString: 'Browse implementors of this method' 					#catalogID: #store ) ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="Store-Merge Management">versionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #versionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Unresolve 					#defaultString: '&amp;Unresolve' 					#catalogID: #store ) 				#nameKey: #unresolve 				#value: #unresolve 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #unresolved ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_SelectAsResolution 					#defaultString: '&amp;Select as Resolution' 					#catalogID: #store ) 				#nameKey: #chooseAsResolution 				#value: #chooseAsResolution 				#enablementSelector: #canResolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #resolved ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAndApply_Resolution 					#defaultString: 'Select and Apply &amp;Resolution' 					#catalogID: #store ) 				#nameKey: #applySelection 				#value: #applySelection 				#enablementSelector: #canResolve ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ApplyResolution 					#defaultString: '&amp;Apply Resolution' 					#catalogID: #store ) 				#nameKey: #applyResolution 				#value: #applyResolution 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applied ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoNotResolve 					#defaultString: '&amp;Do Not Resolve' 					#catalogID: #store ) 				#nameKey: #DoNotResolve 				#value: #doNotResolve 				#enablementSelector: #canResolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #doNotResolve ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #OpenComparisonWith_Base 					#defaultString: 'Open Comparison with &amp;Base' 					#catalogID: #store ) 				#nameKey: #compareWithBase 				#value: #compareWithBase 				#enablementSelector: #versionSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #OpenComparisonWith_Res 					#defaultString: 'Open Comparison with &amp;Resolution' 					#catalogID: #store ) 				#nameKey: #compareWithResolution 				#value: #compareWithResolution 				#enablementSelector: #canCompareWithResolution ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #OpenComparisonWith_Image 					#defaultString: 'Open Comparison with &amp;Image' 					#catalogID: #store ) 				#nameKey: #compareWithImage 				#value: #compareWithImage 				#enablementSelector: #versionSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Open_ComparisonOfSelected 					#defaultString: 'Open &amp;Comparison of Selected' 					#catalogID: #store ) 				#nameKey: #compare 				#value: #compare 				#enablementSelector: #twoVersionsSelected ) ) #(1 3 1 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI">classMenu	"Tools.MenuEditor new openOnClass: self andSelector: #classMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVersions 					#defaultString: 'Browse Versions' 					#catalogID: #browser ) 				#nameKey: #'Store Browse Class Versions' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CompareWithDots 					#defaultString: 'Compare With...' 					#catalogID: #browser ) 				#nameKey: #'Store Compare Class Version' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #browser ) 				#nameKey: #'Spawn Class' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAsDots 					#defaultString: 'File Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Global' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Hardcopy 					#defaultString: 'Hardcopy' 					#catalogID: #browser ) 				#value: #printOutClass 				#enablementSelector: #isClassSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#nameKey: #InspectClasses 				#value: #inspectClasses 				#enablementSelector: #isClassSelected ) ) #(2 4 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI">protocolMenu	"Tools.MenuEditor new openOnClass: self andSelector: #protocolMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindMethodDot 					#defaultString: '&amp;Find Method...' 					#catalogID: #browser ) 				#nameKey: #'Find Method' 				#value: 				#action: 				#shortcutKeyCharacter: $m 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{BrowserIcons} #findMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #browser ) 				#nameKey: #'Spawn Protocol' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #File_OutAsDots 					#defaultString: 'File &amp;Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Protocol' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Hardcopy 					#defaultString: 'Hardcopy' 					#catalogID: #browser ) 				#value: #printOutProtocol 				#enablementSelector: #isProtocolSelected ) ) #(1 3 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI">pundleMenu	"Tools.MenuEditor new openOnClass: self andSelector: #pundleMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #LoadVersionDots 					#defaultString: 'Load Version' 					#catalogID: #browser ) 				#nameKey: #'Store Load Pundle' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#nameKey: #InspectPundle 				#value: #inspectPundle 				#enablementSelector: #isCodeComponentSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Store 					#defaultString: 'Store' 					#catalogID: #browser ) 				#nameKey: #Versions 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseVersions 								#defaultString: 'Browse Versions' 								#catalogID: #browser ) 							#nameKey: #'Store Browse Pundle Versions' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithDots 								#defaultString: 'Compare With...' 								#catalogID: #browser ) 							#nameKey: #'Store Compare Pundle Versions' 							#value: 							#action: ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindPackageDots 					#defaultString: 'Find Package...' 					#catalogID: #browser ) 				#nameKey: #'Find Package' 				#value: 				#action: 				#shortcutKeyCharacter: $P 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindNamespaceDots 					#defaultString: 'Find Namespace...' 					#catalogID: #browser ) 				#nameKey: #'Find Name Space' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindClassDots 					#defaultString: '&amp;Find Class...' 					#catalogID: #browser ) 				#nameKey: #'Find Class' 				#value: 				#action: 				#shortcutKeyCharacter: $l 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{BrowserIcons} #findClass ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindSharedVariableDots 					#defaultString: 'Find Shared Variable...' 					#catalogID: #browser ) 				#nameKey: #'Find Shared Variable' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAsDots 					#defaultString: 'File Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Package' 				#value: 				#action: ) ) #(2 1 4 1 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI">selectorMenu	"Tools.MenuEditor new openOnClass: self andSelector: #selectorMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #LocalImplementors 					#defaultString: '&amp;Local Implementors' 					#catalogID: #store ) 				#nameKey: #'Local Implementors' 				#value: 				#action: 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Implementors 								#defaultString: 'Implementors' 								#catalogID: #browser ) 							#nameKey: #'Local Implementors' 							#value: 							#action:methodName: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LocalImplementors 								#defaultString: 'Local Implementors' 								#catalogID: #browser ) 							#nameKey: #'Local Implementors Actions' 							#value: #dynamicMenu ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Image_Implementors 					#defaultString: 'Image &amp;Implementors' 					#catalogID: #store ) 				#nameKey: #'Global Implementors' 				#value: 				#action: 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Implementors 								#defaultString: 'Implementors' 								#catalogID: #browser ) 							#nameKey: #'Global Implementors' 							#value: 							#action:methodName: 							#shortcutKeyCharacter: #F7 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{BrowserIcons} #definitionsMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GlobalImplementors 								#defaultString: 'Global Implementors' 								#catalogID: #browser ) 							#nameKey: #'Global Implementors Actions' 							#value: #dynamicMenu ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Store 					#defaultString: 'Store' 					#catalogID: #browser ) 				#nameKey: #Store 				#value: #rbItem 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseVersions 								#defaultString: 'Browse Versions' 								#catalogID: #browser ) 							#nameKey: #'Store Browse Method Versions' 							#value: 							#action: 							#enablementSelector: #isMethod ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseVersions 								#defaultString: 'Browse Versions' 								#catalogID: #browser ) 							#nameKey: #'Store Browse Shared Variable Versions' 							#value: 							#action: 							#enablementSelector: #isData ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithDots 								#defaultString: 'Compare With...' 								#catalogID: #browser ) 							#nameKey: #'Store Compare Method Versions' 							#value: 							#action: 							#enablementSelector: #isMethod ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithDots 								#defaultString: 'Compare With...' 								#catalogID: #browser ) 							#nameKey: #'Store Compare Shared Variable Versions' 							#value: 							#action: 							#enablementSelector: #isData ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #browser ) 				#nameKey: #'Spawn Method' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#nameKey: #InspectSelected 				#value: #inspectSelected 				#enablementSelector: #isSelectorOrSharedVariableSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #File_OutAsDots 					#defaultString: 'File &amp;Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Method' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Hardcopy 					#defaultString: 'Hardcopy' 					#catalogID: #browser ) 				#value: #printOutMessage 				#enablementSelector: #isDefinitionSelected ) ) #(1 1 1 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.ClassListPane class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOut_OnlyClassDefinition 								#defaultString: 'File &amp;Out Only Class Definition' 								#catalogID: #store ) 							#nameKey: #FileOutOnlyClassDefinition 							#value: #fileOutOnlyClassDefinition 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutClass 								#defaultString: '&amp;File Out Class' 								#catalogID: #store ) 							#nameKey: #FileOutClass 							#value: #fileOutClass 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LoadOnlyClass_Definition 								#defaultString: 'Load Only Class &amp;Definition' 								#catalogID: #store ) 							#nameKey: #LoadOnlyClassDefinition 							#value: #loadOnlyClassDefinition 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_Class 								#defaultString: 'Load &amp;Class' 								#catalogID: #store ) 							#nameKey: #LoadClass 							#value: #loadClass 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 2 2 2 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.ClassListPane class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 160 568 360 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#flags: 15 					#model: #itemsInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #browseSelectedVersion ) 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.PrerequisiteSelector class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PrerequsiteSelection 				#defaultString: 'Prerequisite Selection' 				#catalogID: #store ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1344 794 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 30 0 -5 1 -40 1 ) 					#name: #PrereqList 					#flags: 15 					#model: #selections 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #useSelection ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#name: #PromptLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ChoosePackagePrereq 						#defaultString: 'Choose a Package version to fullfill prerequiste:' 						#catalogID: #store ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -30 1 113 0 -5 1 ) 					#name: #ActionButton1 					#model: #quitLoading 					#label: 					#(#{Kernel.UserMessage} 						#key: #QuitLoading 						#defaultString: 'Quit Loading' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 -30 1 224 0 -5 1 ) 					#name: #TryParcel 					#model: #tryParcel 					#label: 					#(#{Kernel.UserMessage} 						#key: #TryParcel 						#defaultString: 'Try Parcel' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 228 0 -30 1 334 0 -5 1 ) 					#name: #ActionButton3 					#model: #skipPrerequisite 					#label: 					#(#{Kernel.UserMessage} 						#key: #SkipPrerequisite 						#defaultString: 'Skip Prerequisite' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 338 0 -30 1 -5 1 -5 1 ) 					#name: #ActionButton4 					#model: #useSelection 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseSelection 						#defaultString: 'Use Selection' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-02 keyboard accelerators</category><body package="Store-Code Comparison">_0599Gap	&lt;paragraph&gt;	^PixelSpace height: 15</body><body package="Store-Code Comparison">_0600Header	&lt;paragraph&gt;	^self		sectionHeader: #comparisonHelpKeyboardHeader &gt;&gt; 'Keyboard Accelerators'				&lt;&lt; #IDE</body><body package="Store-Code Comparison">_0605ShiftClickHeader	&lt;paragraph&gt;	^self graphic: (self				keyboardOne: 'Shift'				two: nil				clickOver: ComparisonIcons seePackage)		explanation: #comparisonHelpKeyboardShiftClickHeader				&gt;&gt; 'Enable the selected package only; disable all other packages in the header band.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison">_0606ShiftClick	&lt;paragraph&gt;	^self graphic: (self				keyboardOne: 'Shift'				two: nil				clickOver: ComparisonIcons collapsed)		explanation: #comparisonHelpKeyboardShiftClick				&gt;&gt; 'Toggles not only the current element''s expansion, but causes all elements at the same level and in same section to match the end state of the target. Handy for show/hide all the changes in given block.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison">_0607ShiftOptionClick	&lt;paragraph&gt;	^self		graphic: (VisualRow withAll: (Array						with: (self keyboardGraphic: 'Shift')						with: (self keyboardGraphic: 'Alt')						with: (VisualStack with: ComparisonIcons collapsed								with: ComparisonIcons mouseClick)))		explanation: #comparisonHelpKeyboardShiftAltClick				&gt;&gt; 'Toggles not only the current element''s expansion, but causes all visible elements at the same level to match the end state of the target. Handy to show/hide everything in one click.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison">_0610DownArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Down' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardDownArrow				&gt;&gt; 'Advances focus to the next downward visible element.' &lt;&lt; #IDE</body><body package="Store-Code Comparison">_0611UpArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Up' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardUpArrow				&gt;&gt; 'Advances focus to the next upward visible element.' &lt;&lt; #IDE</body><body package="Store-Code Comparison">_0612RightArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Right' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardRightArrowOrTab				&gt;&gt; 'Expands the current element, if it is collapsed.' &lt;&lt; #IDE</body><body package="Store-Code Comparison">_0613LeftArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Left' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardLeftArrow				&gt;&gt; 'Collapses the current element, if it is expanded.' &lt;&lt; #IDE</body><body package="Store-Code Comparison">_0614Tab	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Tab' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardRightArrowOrTab				&gt;&gt; 'Expands the current element, if it is collapsed.' &lt;&lt; #IDE</body><body package="Store-Code Comparison">_0615Return	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Enter' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardReturn				&gt;&gt; 'Toggles the current element''s expanded state.' &lt;&lt; #IDE</body><body package="Store-Code Comparison">_0616Space	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Space' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardSpace				&gt;&gt; 'Cycle to next change. Advances focus to next expandable element and expands it, collapses the current if expanded.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison">_0617ShiftSpace	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Shift' two: 'Space' clickOver: nil)		explanation: #comparisonHelpKeyboardShiftSpace				&gt;&gt; 'Cycle to previous change. Advances focus to previous expandable element and expands it, collapses the current if expanded.'					&lt;&lt; #IDE</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-10 general icons</category><body package="Store-Code Comparison">_0699Gap	&lt;paragraph&gt;	^PixelSpace height: 15</body><body package="Store-Code Comparison">_0700Header	&lt;paragraph&gt;	^self sectionHeader: #comparisonHelpIconHeader &lt;&lt; #IDE &gt;&gt; 'Icon Reference'</body><body package="Store-Code Comparison">_0710Modify	&lt;paragraph&gt;	^self graphic: ComparisonIcons modify		explanation: #comparisonHelpIconGeneralModify &lt;&lt; #IDE				&gt;&gt; 'Methods, package properties, or shared variable initializers that were changed.'</body><body package="Store-Code Comparison">_0720Add	&lt;paragraph&gt;	^self graphic: ComparisonIcons add		explanation: #comparisonHelpIconGeneralAdd &lt;&lt; #IDE				&gt;&gt; 'Methods, package properties, or shared variable initializers that were added.'</body><body package="Store-Code Comparison">_0730Remove	&lt;paragraph&gt;	^self graphic: ComparisonIcons remove		explanation: #comparisonHelpIconGeneralRemove &lt;&lt; #IDE				&gt;&gt; 'Methods, package properties, or shared variable initializers that were removed.'</body><body package="Store-Code Comparison">_0740Category	&lt;paragraph&gt;	^self graphic: ComparisonIcons moveCategory		explanation: #comparisonHelpIconGeneralMoveCategory &lt;&lt; #IDE				&gt;&gt; 'Methods or shared variables which were moved to a different category.'</body><body package="Store-Code Comparison">_0750Package	&lt;paragraph&gt;	^self graphic: ComparisonIcons movePackage		explanation: #comparisonHelpIconGeneralMovePackage &lt;&lt; #IDE				&gt;&gt; 'Methods, classes, namespaces, or shared variables which were moved to a different package.'</body><body package="Store-Code Comparison">_0760MoreInfo	&lt;paragraph&gt;	^self graphic: ComparisonIcons moreInfoHandle		explanation: #comparisonHelpIconGeneralMoreInfo &lt;&lt; #IDE				&gt;&gt; 'More info in popup which shows category/namespace/package information, when mouse rests over this icon.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-15 code component icons</category><body package="Store-Code Comparison">_1300Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconCodeComponents &lt;&lt; #IDE				&gt;&gt; 'Code Component Icons'</body><body package="Store-Code Comparison">_1310PackageProperties	&lt;paragraph&gt;	^self graphic: ComparisonIcons packageProperties		explanation: #comparisonHelpIconPackageProperties &lt;&lt; #IDE				&gt;&gt; 'Grouping icon for one or more property changes to a given package.'</body><body package="Store-Code Comparison">_1320BundleProperties	&lt;paragraph&gt;	^self graphic: ComparisonIcons bundleProperties		explanation: #comparisonHelpIconBundleProperties &lt;&lt; #IDE				&gt;&gt; 'Grouping icon for one or more property changes to a given bundle.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-13 class icons</category><body package="Store-Code Comparison">_1000Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconClassHeader &lt;&lt; #IDE				&gt;&gt; 'Class Specific Icons'</body><body package="Store-Code Comparison">_1010Superclass	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifySuperclass		explanation: #comparisonHelpIconModifySuperclass &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class''s superclass.'</body><body package="Store-Code Comparison">_1020BehaviorType	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyBehaviorType		explanation: #comparisonHelpIconModifyBehaviorType &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class''s type (e.g. #none, #objects, #ephemeron, #bytes, etc).'</body><body package="Store-Code Comparison">_1030InstanceVariables	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyInstanceVariables		explanation: #comparisonHelpIconModifyInstanceVariables &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in the class''s instance variables.'</body><body package="Store-Code Comparison">_1040ClassInstanceVariables	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyClassInstanceVariables		explanation: #comparisonHelpIconModifyClassInstanceVariables &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in the class''s class instance variables.'</body><body package="Store-Code Comparison">_1050Attributes	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyClassAttributes		explanation: #comparisonHelpIconModifyClassAttributes &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class''s attributes array.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-11 binding icons</category><body package="Store-Code Comparison">_0800Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconAllObjects &lt;&lt; #IDE				&gt;&gt; 'Class/Namespace/Shared Variable Icons'</body><body package="Store-Code Comparison">_0810IsPrivate	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyIsPrivate		explanation: #comparisonHelpIconModifyIsPrivate &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in an object''s private status.'</body><body package="Store-Code Comparison">_0820Add	&lt;paragraph&gt;	^self graphic: ComparisonIcons addedBindingOverlay		explanation: #comparisonHelpIconAddOverlay &lt;&lt; #IDE				&gt;&gt; 'Placed over some icons when the class/share/namespace is entirely new.'</body><body package="Store-Code Comparison">_0830Remove	&lt;paragraph&gt;	^self graphic: ComparisonIcons removedBindingOverlay		explanation: #comparisonHelpIconRemoveOverlay &lt;&lt; #IDE				&gt;&gt; 'Placed over some icons when the class/share/namespace is entirely removed.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-14 shared variable icons</category><body package="Store-Code Comparison">_1100Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconSharedVariableHeader &lt;&lt; #IDE				&gt;&gt; 'Shared Variable Specific Icons'</body><body package="Store-Code Comparison">_1110IsConstant	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyIsConstant		explanation: #comparisonHelpIconModifyIsConstant &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a shared variable''s constant status.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-12 namespace icons</category><body package="Store-Code Comparison">_0900Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconClassAndNamespaceHeader &lt;&lt; #IDE				&gt;&gt; 'Class &amp; Namespace Specific Icons'</body><body package="Store-Code Comparison">_0910Comment	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyComment		explanation: #comparisonHelpIconModifyComment &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class or namespace''s comment.'</body><body package="Store-Code Comparison">_0920Imports	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyImports		explanation: #comparisonHelpIconModifyImports &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class or namespace''s imports.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-01 overview</category><body package="Store-Code Comparison">_0400Header	&lt;paragraph&gt;	^self sectionHeader: #comparisonHelpOverviewHeader &gt;&gt; 'Overview' &lt;&lt; #IDE</body><body package="Store-Code Comparison">_0410Explanation	&lt;paragraph&gt;	^self graphic: (PixelSpace extent: 16)		explanation: #comparisonHelpOverviewExplanation &lt;&lt; #IDE				&gt;&gt; 'The comparison tool is broken into two parts.A header band at the top of the comparison tool shows the packages for which actual differences were found. In some cases, this may be a smaller subset than the original inputs specified. The green check/red disable icon to the left of each row can be used to enable whether changes for that packages are shown in the main comparison area.The main comparison area below the header band shows code changes, grouped by classes, and other code structuring elements. They may be expanded and collapsed to show/hide more details.'</body></methods><methods><class-id>Tools.ComparisonUsersManual class</class-id> <category>tags</category><body package="Store-Code Comparison">paragraphTag	&lt;pragmas: #instance&gt;	^#(#paragraph)</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOut 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_NameSpace 								#defaultString: 'Load &amp;NameSpace' 								#catalogID: #store ) 							#nameKey: #LoadNameSpace 							#value: #loadNameSpace 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 2 1 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.DeletionToolFilterTool class</class-id> <category>interface specs</category><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #DeletionToolFilters 				#defaultString: 'Deletion Tool Filters' 				#catalogID: #store ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1200 714 1800 954 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 55 0 ) 					#name: #PackageBundleGroupBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #PackageBundleList 						#defaultString: 'Package/Bundle List' 						#catalogID: #store ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 65 0 -5 1 -35 1 ) 					#name: #VersionsListGroup 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsList 						#defaultString: 'Versions List' 						#catalogID: #store ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.3 24 0 1 0 ) 					#name: #NameLikeCheck 					#model: #nameLikeCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #NameLikeColon 						#defaultString: 'Name Like:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 20 0 -50 1 45 0 ) 					#name: #PundleName 					#flags: 40 					#model: #pundleName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.3 91 0 1 0 ) 					#name: #AfterDateCheck 					#model: #afterDateCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #AfterDateColon 						#defaultString: 'After Date:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 88 0 100 0.3 111 0 ) 					#name: #AfterDate 					#flags: 40 					#model: #afterDate 					#type: #date 					#formatString: 'm/d/yy' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.7 91 0 1 0 ) 					#name: #BeforeDateCheck 					#model: #beforeDateCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #BeforeDateColon 						#defaultString: 'Before Date:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.7 88 0 100 0.7 111 0 ) 					#name: #BeforeDate 					#flags: 40 					#model: #beforeDate 					#type: #date 					#formatString: 'm/d/yy' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.301667 131 0 1 0 ) 					#name: #BlessingGreaterThanCheck 					#model: #blessingGreaterThanCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #BlessingGreaterThanColon 						#defaultString: 'Blessing Greater Than:' 						#catalogID: #store ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 128 0 130 0.3 151 0 ) 					#name: #BlessingGreaterThan 					#flags: 40 					#model: #blessingGreaterThan 					#menu: #blessingMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.701667 131 0 1 0 ) 					#name: #BlessingLessThanCheck 					#model: #blessingLessThanCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #LessThanColon 						#defaultString: 'Less Than:' 						#catalogID: #store ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.7 128 0 130 0.7 151 0 ) 					#name: #BlessingLessThan 					#flags: 40 					#model: #blessingLessThan 					#menu: #blessingMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.3 172 0 1 0 ) 					#name: #VersionLikeCheck 					#model: #versionLikeCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionLikeColon 						#defaultString: 'Version Like:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 165 0 -50 1 190 0 ) 					#name: #VersionLike 					#flags: 40 					#model: #versionLike ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 -28 1 -90 1 -5 1 ) 					#name: #Cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -28 1 -5 1 -5 1 ) 					#name: #Ok 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #Ok 						#defaultString: 'Ok' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.ResolutionsTreePane class</class-id> <category>interface specs</category><body package="Store-Merge Management">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1517 1028 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #ModSet 					#flags: 7 					#model: #list 					#menu: #modificationMenu 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #other 					#iconSelectors: #(#resolutionIcon #typeIcon ) 					#rootExpander: true ) ) ) )</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>menu</category><body package="Store-UI">compareBundleStructuresItem	&lt;itemInMenu: #(#listMenu) position: 60.9&gt;	^(MenuItem		labeled: #CompareBundleStructure &gt;&gt; 'Compare Bundle Structure' &lt;&lt; #IDE)		visible: [self hasTwoBundlesSelected];		value: [self compareBundleStructures]</body></methods><methods><class-id>Store.Glorp.PundleVersionPane class</class-id> <category>resources</category><body package="Store-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#visible: false 				#visibilitySelector: #atLeastOnePundleSelected 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ContainedI_tems 								#defaultString: 'Contained I&amp;tems' 								#catalogID: #store ) 							#nameKey: #ContainedItems 							#value: #containedItems 							#enablementSelector: #selectionIsBundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_EnclosingBundles 								#defaultString: '&amp;Enclosing Bundles' 								#catalogID: #store ) 							#nameKey: #enclosingBundles 							#value: #enclosingBundles 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Load 								#defaultString: '&amp;Load' 								#catalogID: #menus ) 							#nameKey: #Load 							#value: #loadSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_MergeIntoImage 								#defaultString: '&amp;Merge Into Image' 								#catalogID: #store ) 							#nameKey: #Merge 							#value: #mergeIntoImage 							#enablementSelector: #atLeastOneVersionSelectedAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReconcileImageWithSelection 								#defaultString: '&amp;Reconcile Image with Selection' 								#catalogID: #store ) 							#nameKey: #Reconcile 							#value: #reconcile 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SetBlessingLevelDots 								#defaultString: '&amp;Set Blessing Level...' 								#catalogID: #store ) 							#nameKey: #SetBlessingLevel 							#value: #setBlessingLevel 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOutSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOut_DifferencesDots 								#defaultString: 'File Out &amp;Differences...' 								#catalogID: #store ) 							#value: #fileOutDifferences 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenVersionsList 								#defaultString: '&amp;Open Versions List' 								#catalogID: #store ) 							#value: #openVersionsList 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Graph 								#defaultString: '&amp;Graph' 								#catalogID: #store ) 							#nameKey: #Graph 							#value: #graphSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_UpdateVersionsList 								#defaultString: '&amp;Update Versions List' 								#catalogID: #store ) 							#value: #updateVersionsList 							#enablementSelector: #atLeastOnePundleSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CompareWithImage 								#defaultString: '&amp;Compare with Image' 								#catalogID: #store ) 							#value: #compareWithImage 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWith_Parent 								#defaultString: 'Compare with &amp;Parent' 								#catalogID: #store ) 							#value: #compareWithParent 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) ) #(4 3 1 4 1 4 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 650 350 850 550 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#clientKey: #listOfThings ) ) ) )</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>event states</category><body package="Store-Code Comparison">mouseWheel: aMouseWheel	&lt;event: #MouseWheel&gt;	self scroller		ifNotNil: 			[:scroller |			| delta |			delta := scroller scrollOffsetHolder grid.			scroller				scrollBy: (aMouseWheel up ifTrue: [delta negated] ifFalse: [delta])]</body></methods><methods><class-id>Store.MergeIcons class</class-id> <category>png imports</category><body package="Store-Merge Management">add	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'add.png'&gt;	&lt;md5sum: #[71 51 229 168 198 120 205 222 117 116 146 100 74 123 200 40]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@PAA0EKA4@G"@1.CJH[  :ZCWPM[0%PBRDCG0L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@HSP# LIPP?&lt;S%//?9?/''????????????+&gt;.#&lt; LE.)@-(B1P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G0JW0+&gt;SZ(S?&gt;K87_?Z==W?0.67?;[**/&gt;9:*??3_KD?&gt;[;8/&gt;08J[_CGHLH0@@@@@@@@@@@@@@@@@@@E$HR #&gt;DY(Q?:S!%_&gt;R7G3?X\\V?5N6EO="-#/?X+T:?5C@E_=:4U''?)NJT?6;DR]\JX@(L@@@@@@@@@@(@@ C(CW(M?4^7EO=[01W?MK$T?1R3EO=7/6C???????G4;?&lt;R)QK?EKXT?4.?E_=%1"/?DY(Q 0L]@0@@@@A^A# F?0&gt;MC?&lt;(,AO?EKLT?1N.D?&lt;S+!O?[+5Q???????0=N??D*DR?1N-D?&lt;S,AO?K[LT?1J$D.\KX0,J@@@@(@)[B/&lt;P#1C?D*DR?1F D_=P*1O?R*4S?9?L%_??????&gt;_+8?4&amp;''D/=M+AO?Q:TR?1J$D/&lt;Q&amp;1G?CW0MNP@@@K8JW@+?C8$O?1BSDO=@(1K??????????????????????????????????????=_&amp;5_&lt;P$1C?DH&lt;P?05:CU,@@@B:BULI?0:BC/&lt;O" ??MY0Q???????????????????????????????????????T9MK?C8$O?0&gt;IC?&lt;M]@5\@@@@%@T0A_&lt;M^ 7?C(PN?0:DC/&lt;N!@;?C8 O?6Z-S???????&lt;OS/?09?C/&lt;O! ??C(DN?0:EC/&lt;N P;&gt;B6$KN0@@@D(@@@C?CF4L?0:@C/&lt;N P;?C8XO?0&gt;LC?=[+C''??????&gt;?3;/&lt;N!@;?C8(O?0:DC/&lt;N @;?CW(M8@]@A1T@@@@C@@@@40]BA?&lt;M^ 7?CW0M?09&gt;C/&lt;N  ;?TJH_??+:&gt;/?$:^O?CW0M?0:AC/&lt;M_@7?CW0M?01+CHT@@@@A@@@@@@@@@C(@@@C7B%8J?09&gt;C/&lt;N_ ;?C''&lt;N?05:C_&lt;M]@7?CWXM?09&gt;C/&lt;N_P;?C(@N?054C\,EJ0TZ@@@@@@@@@@@@@@@@@@@@UP@@@OLJW@+?C''8N?0:EC/&lt;N!@;?C(LN?0:DC/&lt;N!P;?C(PN?012CL&lt;EK0T0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@.0T+A_,KYP/?CWXM?09=C/&lt;M^ 7?CF&lt;L:0!NBIX@@@@!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@/@@@@[@@@@H$@@@BE@@@@W @@@BX@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-Merge Management">applied	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'applied.png'&gt;	&lt;md5sum: #[92 255 20 177 35 92 101 89 8 170 228 172 221 7 84 248]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???2[XM/&gt;@75/?,&gt;U&lt;?&gt;[*%_?&amp;;I;?,&gt;*U?8C%_O&lt;&amp;75/?@O???0C???&lt;@????@O???0C???&lt;@????@\$@&gt;WCSGO?664_??&gt;M1???+&amp;_??&lt;+/???WL???2.???:9''?=.M1?7C[Q?&lt;A413?@O???0C???&lt;@????@[0@:[WJ@O/?5BK??=5N???%^/??;*[???[R???=&gt;_??=-K??&gt;:&amp;???%^/??7T;?-]P"?0GJ@O,@????@O???7B;@N#?2PC9?=L_???\R/??9GW??&gt;2^???31O??==_???OD???,''/??:9+??=9U???SG?=02PC9@O???2Z+@]O6.PC%?&lt;X@=_?QD???6S/??&gt;A"???''!O??;I???&gt;:*???,''???:9#???;;???=&lt;???64''?=,X@=RZ9@NV@)0GN?;PA7/?A@N??3PC&gt;?=P$???[Q_??8FK??&gt;Q6???&amp;__??9G_???#Z????????==_??&lt;8E?/?A@N=?-@G^,:DB1?&gt;-@][?. C&amp;?&lt;T@=O?OA/??5BO??=$:???\R/??7T???&gt;*T?????????//??= 4???E@OS?. C&amp;,:4A5.ZZ@+;?) GM?;DA6?&gt;;@N#?32;6?&lt;4@?/?QD_??41;??= 9???&lt;&lt;/???????&gt;Z@???E@OS?.0C(?;DA6&gt;Z&amp;@\7&amp;$ J4?94B0_&gt;''@\??-!G\??//?_?]]?[?1 C5?&lt;$@&gt;_?.+/7???????SP?_?AA^;?.PC%?;DA6/&gt;''@\?&amp;''PKA,8$C*O&gt;S@+W?''@KA?&lt;EQ7O???????????=]0;??PTN????????;:???ELN#?,0G]?:4A5_&gt;%@\3?''@KA,9LB-XA?@93?"@N(?9DB,?&gt;Y@+7?4HG"????????????&gt;/C=???????V N+?* GR?:XA3_&gt; @,W?&amp;PJ=?9DB,7&gt;H@: &amp;^0NW=''4C&amp;/&gt;E@:S?#PN-?9LB-_?L ]7????????????-4OS?(@_D?90B0O&gt;X@+/?$0J5?84C+_ZE@:P&amp;_PNZ@O???7A;@9_?^0NW?8@C''_&gt;E@:S?" N*?&lt;ZA5??=&gt;/7?)SK@?9@B,_&gt;M@:;?" N*?8TC)O&gt;@@950^0NW@O???0C???&lt;A^0NW-W,C%?=;@9_?^0NW?70C&amp;_=?@93?&amp;3^3?8HC(O&gt;A@9??_0N\?70C&amp;_=;@9^5^0NW@W,C%0C???&lt;@????@O???0E;@9]0^0NW='',C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?Y;@9]0^0NW@W,C%0C???&lt;@????@O???0C???&lt;@????@O???2Y;@9^@^0NW,7,C%&gt;Y;@9_&amp;^0NW,7,C%8A;@9\&amp;^0NW@O???0C???&lt;@????@O???0@a')))] once</body><body package="Store-Merge Management">applyAll	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'applyAll.png'&gt;	&lt;md5sum: #[145 206 119 52 193 243 145 188 149 70 17 242 37 0 15 225]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????N-HV?:?^T??%:H_?9^2^?:?(!?&lt;:7%O?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????^LP@&lt;?7VJ/??87C???B4???:9???&lt;KS??^M0?7#VJ/&lt;@????@O???0C???&lt;@????@O???0C???&lt;:41[?0]%K&gt;??$^_;?:)K??&gt;Y&gt;???*%/??=\;??&gt;&gt;0???41/?=6#??N,P@&lt; C???&lt;@????@O???0C???=81@C2?]X*???#\O??&lt;KS???+''???0-O??87C??==[???53_???N7??=L\?:&gt;=@N(@????@O???3+RE/?A6T/;?&gt;Q9?/?*$/??9'';??&gt;*U???53/??;;C???SF???ZPO??&lt;,W&lt;?==Z???C@OK%, G\@O???7#D@OO=5"+??&gt;M0???0-O??&gt;._???B4???#\O??75/???WM???&lt;;_??413??&lt;04&lt;O&gt;?@N3?, G]9ZLB2S*-@][=1@C2?=T%???"Z/??;*''???WN???/,O??=L[??=)@???21_3?75+??&lt;L@&lt;/&gt;3@=7?* GR?9&lt;B1Z&gt;R@+R/*@GO?;4@:/?PB???64W??&gt;Q3???''!/??=\7???3-???SGO??23S0?;&lt;@;O&gt;2@]7?( KH?9PB-?6K@:0: @N]9Y8B0?&gt;2@]3?11C3?=DP???WL_??87K????????_V/??00C2?;LC7O&gt;*@]K?''0KE?84B+?5&gt;@9-8^0NW@O???&gt;VR@+S?(0KI?&gt;BW&lt;_?%%?_?2P+7??#^?/?+)_3?/0C,?;HA7_&gt;"@,#?%@J7?8,C+LE&lt;@9$:^0NW@O???0C???&gt;/ 0N!?9HB-O&gt;:R]W??_#&gt;??OX&gt;_?89?3?-1O]?:(A4/&gt;_@,W?#PJ.?W8C&amp;7!;@)\@????@O???0C???&lt;@????N'',C%?6@@97?"0N,?;II2??&lt;=?7?.5GT?9(B//&gt;T@+_?"0N,0W0C&amp;#);AIT@????@O???0C???&lt;@????@O???0C???=8^0NW?W,C%?=&gt;@9/?%".0?8TC(?&gt;C@:G=_ N[^G,C%0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???3);@9^/^0NW9W,C%&gt;U;@9^/^0NWN'',C%0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0@a')))] once</body><body package="Store-Merge Management">bigApply	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'bigApply.png'&gt;	&lt;md5sum: #[250 19 222 247 79 187 80 28 16 208 28 103 218 247 16 229]&gt;	^[AlphaCompositedImage image: ((Image extent: 24@24 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???1[]S?=K8V_?_&gt;U&lt;?;K)#/?&amp;:9+?9.2^?;K+&amp;/=?:X;?R&gt;U&lt;?1[!Y?&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;D5R[?_])B??+ W/??9W#??&gt;&amp;P???-)/??&lt;[[???J=???1-/??;Z[??&gt;&amp;P??+%^O==8E;?AM)B?0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???2''QD_?J5";??=1J???!Y???98S??&gt;2_???1./??=-C???#[???64O??&lt;[+??&gt;2_???''!O??8V_?2-1J?2''VK/&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????W,(@&gt;?_QD???53G??=5N???"[O??:H''??&gt;:&amp;???31O??&gt;^G???79???98_??&lt;&lt;S??&gt;:&amp;???("_??8&amp;3??=5N??_WL_=^4QO?@O???0C???&lt;@????@O???0C???&lt;)0PC.=&lt;(@&gt;/?QD/??52???=1L???"Z/??:H_??&gt;6#???2/???==''???+&amp;???76_??&lt;+???&gt;6#???(!???8&amp;+??=1L???WK??74QK?J\(@&gt; C???&lt;@????@O???0R6@^GJ0@C-?&lt;$@&gt;O?PC_??5"+??=-F??? X/??9''7??&gt;.W???/+???&lt;&lt;G???SH???30_??;:???&gt;.W???'' /??&lt;[+??&gt;A ???VJ/??4@7?2,$@&gt;@S@@N4@????@O???764@]??/PC*?&lt;X@=_?NA_??5BC??=$;???^U_??86;??&gt;^D???+%???;ZW??&gt;:*???-)_??:9_??&gt;^D???2/_?????????=???/+O??4QO??&lt;X@=W6=@N(@????E* A4O*1@]/?. C&amp;?&lt;L@&lt;_?K@O3?4QO??=X,???[QO??75/??&gt;M.???&amp;_/??:H#??&gt;"L???("O??9'';??&gt;"J?????_?????????????30???20G&lt;?&lt;L@&lt;_*:@NXV,PG[R:TA3O&gt;.@]_?- G!?;&lt;@;O?G@O[?3 O??=LZ???WLO??64S??=9U??? X/??8&amp;/??&gt;M.???"Z???8FS???''^??????????????75???TIO??10C6?;&lt;@;O&gt;6@^EK+ GW_:DB1?&gt;)@]G?, G\?;(@9/?A@N??2PC8?&lt;&lt;F???SF/??5"3??=$:???[Q/??7D7??=5O???\S_??:9+??????????????????&gt;M.???I@O#?0PC/?;(@9/&gt;2@]1?*PGQ,)0B0_&gt;$@\/?+@GU?;PA7/&gt;;@N#?0 C0?&lt;$@&gt;O?N@/??4QK??=P_???VJ_??52???=\1???\R????__?????????????&lt;;???&lt;$A&gt;O?B@OC?.0C(?;PA7/&gt;,@]V2)@GK9)\B.?&gt;_@,S?)0GN?:8A5?&gt;5@]??.0C''?=MK=O?MG/[?20C;?&lt;8C???PCO??4QG??=DS???3/??????????????==O??3RG6?&lt;D@;?&gt;;@N_?-PG_?:8A5?&gt;''@\;&amp;''0KD9)HB-O&gt;Y@+7?(@KF?:\A3?&gt;.@]_?-PW_??W\&gt;??66?3?2A+2?&lt;X@=_?H@O#?2 C:?=9^?O?????????????????[Z/[?/ C+?;$@9_&gt;4@];?+ GW?:\A3?&gt; @,[&amp;&amp;PJ=,(0C+O&gt;S@+W?&amp; J&gt;?:@B1/&gt;&amp;@\7?26G$????????????=M_;?&lt;HV:?&gt;?@N3?1QS/??+,?/???????????&gt;:&gt;&gt;_&gt;9@^W?-PG ?;DA6?&gt;,@]S?) GM?:@B1/&gt;Z@+:2$0J5_8TC)O&gt;L@:7?$0J5?9$B/O&gt;_@,S?3WW"??????????????????KS&gt;_&gt;;ENK?9ZS4?????????????OS&gt;?;4"8_&gt;0@]+?+PGU?:$A4O&gt;$@,+?''0KD?9$B/O&gt;S@+U?#@N-R7&lt;C''O&gt;E@:S?"0N,?9DB,?&gt;V@++?&amp;0K@?=BA8/?????????????????47/''?????????????????36/&amp;?:(A4/&gt;''@\;?)@KJ?:@B1_&gt;[@,C?% J:?9DB,?&gt;K@:1K!PN$E'',C%?)&gt;@9/?!@N"?8$C*_&gt;N@:??$0J5?9\B.??M ]?????????????????????????????(/?G?( OH?:@B1/&gt;^@,O?&amp;0J??9\B.?&gt;S@+W?# N/?8$C*_*D@:HV_ N[@O???75;@9_?_@NX?8DC''?&gt;F@:W?" N*?88C+?&gt;R@+S?2(G[??????????????????/4?O&gt;''H&lt;[?&amp;PJ&lt;?9\B./&gt;U@+_?$ J4?88C+?&gt;J@:+?! N%?8DC''75&lt;@9 @????@O???0Q;@9_J^0NW?7,C%?=&gt;@9+?  N ?8TC)O&gt;I@:#?"0N,?&lt;ZA5????????????;9+4/&gt;P@+G?#0N0?84C+/&gt;K@:3?"PN(?8TC)O&gt;B@:C?_ NZ2'',C%0Q;@9\@????@O???0C???&lt;)^0NW=7,C%?=;@9_?^0NW?70C&amp;_=?@97?  N ?8PC(/?B ]K?8K?(?8\D)/&gt;F@:W?!PN$?8PC(/&gt;B@:C?_0N]?70C&amp;_=;@9_7^0NWJW,C%0C???&lt;@????@O???0C???&lt;@????W'',C%?];@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=&lt;@9#?!AB^?74C&amp;/==@9''?_@NX?7,C%?=;@9_?^0NW?7,C%?];@9]^^0NW@O???0C???&lt;@????@O???0C???&lt;@????@O???2%;@9_J^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW2'',C%2%;@9\@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;D^0NW_W,C%?);@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?);@9]=^0NWAG,C%0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???1Y;@9]K^0NW_7,C%;I;@9_&amp;^0NW9'',C%;I;@9]?^0NWR7,C%1Y;@9\@????@O???0C???&lt;@????@O???0C???&lt;@????')))] once</body><body package="Store-Merge Management">bigResolve	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'bigResolve.png'&gt;	&lt;md5sum: #[179 110 167 90 101 102 45 196 132 249 142 26 78 28 253 43]&gt;	^[AlphaCompositedImage image: ((Image extent: 24@24 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???=E"X&amp;LRCH2L C???&lt;C@J+?P0"7?70F*_=.A9''?N0RJ?0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???4I4]GS?.K";?5=_XG EM%[HA*+??0":??&lt;G+O??A)3??0VM?&lt;DD_/&lt;1AV7?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???55EQT_?''):!?8:N$N,$UW+?A:[??0"6??&lt;H,O??A:C??0VP??&lt;D _?=@7G?&amp;@I!?1H@U_&lt;@????@O???1L@T_&gt;8@V_?LPU8?0C???&lt;@????@O???0C???&lt;@????@O???0  HBC''[6=2?;2&lt;/?="X6W"BI[+?0"2??&lt;H-O??A:S??0ZU??&lt;E!_??AGW??0I&amp;??TAU/?H@D_?/ AD?? AT???@&amp;O?,@M2?0C???&lt;@????@O???0C???&lt;@????@O???0C???=3PDAC?9.[''_&gt;Q$YO''I51=?0".??&lt;H.O??A:#??0ZX??&lt;E"_??AG''??0M*??&lt;BV/??@D/??0A@??&lt;AS???@%???0M/?3DE__&lt;@????@O???0C???&lt;@????@O???0C???&lt;KE1\W:65-[/&gt;?/&lt;K?Y&amp;])8P"^;O&lt;H./??A:3??0Z\??&lt;E#_??AG7??0M.??&lt;BW/??@T;??0@???&lt;ASO??@%/??0M+?;@D^/&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????^38&gt;O/&gt;W%9+?%YVW9B!! _&lt;H-/??BKC??0^ ??&lt;E$_??AHG??0M2??&lt;BX/??@UO??0AC??&lt;@RO??@U_??0I''??&lt;D]/&lt;1AX_?@O???0C???&lt;@????@O???0C???&lt;@????C1DQD_A)ZV/?0,KE?6%*[M&lt;H).;?BKS??0^$??&lt;F%_??AXW??0Q6??&lt;BY/??@U[??0AG??&lt;@QO??@UO??0I#??&lt;C\/&gt;0AHK?@O???0C???&lt;@????@O???0C???&lt;@????@O???8L:N#+?%IRV?9"X&amp;-&lt;+Y8S?BK#??0^(??&lt;F&amp;_??AX''??0Q:??&lt;CZ/??@%+??0AK??&lt;@PO??@T???0I_??&lt;C[/??AG;?LPVM?0C???&lt;@????@O???0C???&lt;@????@O???1LMCP73YVU''?;&gt;?0/=-[''C^BJ?/?0^,?&lt;@G''_&gt;JA(3?-0Q=??&lt;C[/??@%;??0EO??&lt;@O???@T/??0I[??&lt;CZ/??AG+?,@RJ?0C???&lt;@????@O???0C???&lt;@????@O???0C???&gt;KM3\9?9BP$?&gt;[&amp;9;[K&amp;2E] &amp;/?0C???&lt;@????@O???3XE\_&gt;4@VK??0ES??&lt;@P???@D_??0EW??&lt;BY/??AG[??0VF?2&lt;E$/&lt;@????@O???0C???&lt;@????@O???0C???&lt;XB0,K=6I"X?&gt;;.;;?\WE2Q1XVE C???&lt;@????@O???0C???&lt;@????O0AU?=@@Q???@DO??0ES??&lt;BX??-@7K?\0RC?0X@ O&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????$3H2MO&gt;M#X??''9&gt;"1DUER@C???&lt;@????@O???0C???&lt;@????@O???0H@ O&lt;:@C;?V@AN?4HDX_&lt;D@HC?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????GP$IB_%^W&amp;C?.K";?7Q4]$@\GA0@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???9,0LCC?"X&amp;K?:J")[5IRT(@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???2L@@@C&lt;V5-\?;R4-?=8^G$9G1&lt;_@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&gt;#KB0-?8ZF"O&gt;&amp;)*&amp;6ST5N@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;)@@@@?U]WV_&gt;1,[S?^7-=L2L#H0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????*2 (J/&gt;B (S?***,+5APT C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????L@TEA_=TUEW?+Z60?(B@ Q0$IBP@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???:\%IR[?_7&gt;A;:6-,@9[V5,@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0L@@@A]TEARK*2,+@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????')))] once</body><body package="Store-Merge Management">bigUnresolve	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'bigUnresolve.png'&gt;	&lt;md5sum: #[1 41 95 129 190 190 86 13 34 167 223 132 32 105 222 109]&gt;	^[AlphaCompositedImage image: ((Image extent: 24@24 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???1 =OS5NOS4= 34=O[ =OS70O#8&gt;&lt;C8&gt;O+ =OS6COS4=S#4=OQ =OS4@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;FOS4=!34=O_4=OS7?OS4=?#&lt;?O?5QTUG?Y6]''?6]''Y?5QTUG&gt;O3&lt;??34=O_4=OS6GOS4=A#4=OPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???2&lt;=OS7TO#8&gt;?34=O_=(ZF#?"8.K?9*Z&amp;/&gt;\''I3?&amp;9.[?9.[&amp;?&gt;[&amp;9/?&amp;Y&amp;Y?8.K"?=&amp;Y&amp;[?OS4=5C8&gt;O"&lt;=OS4@????@O???0C???&lt;@????@O???0C???&lt;@????Y#4=O_,&gt;O#;&lt;RD!H?8NC ?&gt;Z&amp;)+?&amp;I"X?9^W%?&gt;U%YW?%YVU?9VU%_&gt;U%YW?%YVU?9ZV%/&gt;X&amp;I#? (JB?D]GQ?,&gt;O#9&amp;OS4=@O???0C???&lt;@????@O???0C???&lt;/OS4=&gt;38&gt;O/=[V5/?%IRT?9"X&amp;O&gt;V%)[?%IRT?9JR$/&gt;#(:O?,[F1?;J2,/&gt;$)JS?$)JR?9JR$/&gt;T%IS?%)ZV?9JR$/=ZV%+;O#8&gt;K34=OPC???&lt;@????@O???0X=OS7TO#8&gt;?D!HRO&gt;V%)[?&amp;)*Z?9"X&amp;O&gt;V%)[?.[&amp;9??[6=/??????????????????????&lt;/K2?;V5-_&gt;T%IS?%)ZV?9"X&amp;O&gt;T%IS&lt;RD!H5C8&gt;O X=OS4@????@O???8\=OS7?OS4=?8"H"O&gt;_''9??''Y6]?9.[&amp;?&gt;Y&amp;Y''?2&lt;/K?????????????_7=??????????????????3&lt;?O&gt;(*J#?&amp;Y&amp;Y?9.[&amp;?&gt;]''Y7?!(ZF?34=OX\=OS4@????FC4=O_4=OS7?Z6-+?:R$)O&gt;"(*K?(ZF!?9&gt;_''?&gt;^'');?3L3L?=+Z6/&gt;/+:??''Y6]?:2,+O?9&gt;_''????????????G1&lt;_?''):^?9&gt;_''?&gt;!(ZG?(:N#?6-+Z?4=OS4XOS4=S#4=O_&lt;=OS7?%9^W?:&amp;)*_&gt;''):_?)*Z&amp;?:V%)_&gt;$)JS?)JR$?:J"(/&gt;"(*K?(*J"?:F!(_?''9&gt;_????????????K2&lt;/?)JR$?:V%)_&gt;&amp;)*[?*J"(?9ZV%/&lt;=OS5NOS4= 34=O_9@PDC?+J2,?::.+/&gt;-+Z7?+J2,?:.+*?&gt;***+?*Z&amp;)?:&amp;)*_&gt;)*Z''?*J"(?;&gt;?/??&gt;?/;???????;&gt;?/&gt;9.[''?****?:.+*?&gt;,+J3?+Z6-?:.+*?9@PDBCOS4=.C4=O_5XVE#?-KR4?;N3,?&gt;3,;O?,+J2?;F1,_&gt;0,KC?,KB0?:&gt;/+?&gt;/+:??0&lt;OC??3&lt;?O???????????=ST5O&gt;0,KC?,KB0?;F1,_&gt;2,+K?,;N3?;N3,?5WU5^8OS4=&lt;C8&gt;O/=5]WW?.+*:?;&amp;9._&gt;8.K#?.K"8?;^7-?&gt;7-;_?-+Z6?;Z6-/?@0LC?&gt;/+:????????????7]7]?;Z6-/&gt;6-+[?-;^7?;^7-?&gt;8.K#?.[&amp;9?;&amp;9._=5]WW0O#8&gt;&lt;C8&gt;O/=9^W''?0LC@?;&gt;?/?&gt;?/;??/+:&gt;?;6=/_&gt;=/[7?/[6=?;2&lt;/O? 8NC????????????,;N3?/K2&lt;?;2&lt;/O&gt;=/[7?/[6=?;6=/_&gt;&gt;/+;?/;&gt;??&lt;C@0O=8^G#0O#8&gt;.C4=O_5]WU7?1,[F?&lt;[F1/?E1\W?1LSD?&lt;SD1O?C0&lt;O?0&lt;OC?&lt;KB0/?Z6-+?9^W%?&gt;W%9_?S4=O?0,KB?&lt;OC0??C0&lt;O?0&lt;OC?&lt;SD1O?D1LS?1\WE?&lt;[F1/5]WU68OS4= 34=O_9@PDC?2,+J?&lt;3L3O?K2&lt;/?2&lt;/K?&lt;+J2/?J2,+?2\''I?&lt;''I2_?N3,;?4MCP?=CP4O?L3L3?2\''I?&lt;''I2_?J2,+?2,+J?&lt;+J2/?K2&lt;/?3L3L?&lt;''I2_9@PDBCOS4=S#4=O_&lt;=OS7?/[6=?=KR4/?R4-K?4]GQ?=GQ4_?P4MC?4MCP?=CP4O?0&lt;OC????????????&amp;9.[?4MCP?=CP4O?P4MC?4]GQ?=GQ4_?Q4]G?4-KR?;2&lt;/O&lt;=OS5NOS4=FC4=O_4=OS7?"X&amp;I?=#X6O?X6M#?5=_W?=_W5??W5=_?5=_W?=_W5??2&lt;/K????????????):^''?5=_W?=_W5??W5=_?5=_W?=_W5??X6M#?6M#X?8&amp;I"_4=OS4XOS4=@O???8\=OS7?O#8&gt;?;&gt;?/??^7-;?7-;^?=;^7/?]7]7?7]7]?=7]7_?4=OS????????????-;^7?7]7]?=7]7_?]7]7?7]7]?=;^7/?^7-;?/;&gt;??38&gt;O(\=OS4@????@O???0X=OS7TO#8&gt;?EYVU/?_7=??9^W%?&gt;S$9O?$9NS?9NS$?&gt;O#8??#8&gt;O?8&gt;O#?&gt;O#8??#8&gt;O?8&gt;O#?&gt;S$9O?$9NS?9NS$?&gt;S$9O?^7-;&lt;U%YV5C8&gt;O X=OS4@????@O???0C???&lt;/OS4=&gt;38&gt;O/=?_7??8.K"?&gt;#(:O?(:N#?:N#(?&gt;#(:O?(:N#?:N#(?&gt;#(:O?(:N#?:N#(?&gt;#(:O?(:N#?:N#(?&gt;K"8/=?_7?;O#8&gt;K34=OPC???&lt;@????@O???0C???&lt;@????Y#4=O_,&gt;O#;&lt;U5]W?&lt;#H2O?*:.+?:.+*?&gt;+*:/?*:.+?:.+*?&gt;+*:/?*:.+?:.+*?&gt;+*:/?*:.+?2L#H?E]WU?,&gt;O#9&amp;OS4=@O???0C???&lt;@????@O???0C???&lt;@????@O???2&lt;=OS7TO#8&gt;?38&gt;O/&gt;T%IS?4=OS?&gt;''):_?+:&gt;/?:&gt;/+?&gt;/+:??+:&gt;/?:^'')?=OS4?&gt;T%IS?O#8&gt;5C8&gt;O"&lt;=OS4@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;FOS4=!34=O_4=OS7?OS4=?$IBP/5)ZV''?$)JR?9JR$/5)ZV''&gt;P$IB?34=O_4=OS6GOS4=A#4=OPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???1 =OS5NOS4= 34=O[ =OS70O#8&gt;&lt;C8&gt;O+ =OS6COS4=S#4=OQ =OS4@????@O???0C???&lt;@????@O???0C???&lt;@????')))] once</body><body package="Store-Merge Management">modify	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'modify.png'&gt;	&lt;md5sum: #[72 3 131 105 145 49 119 189 151 180 108 206 108 233 77 0]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@P@FB1K@D*H"@AL2*H\Y-6Z@C/I[0AW''2H@J48@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ED@VZO PH72?&lt;;&amp;???????????????????2&gt;_?&lt;$\[?)@AS01T@BQD@@@@@@@@@@@@@@@@@@@@@@@@@@G4@Z\C&gt;ZZ;??&gt;75???)&lt;???5&gt;/??&lt;;&amp;???Q9???7.;???K8???B7??_@D/PI@@@@@@@@@@@@@@@@@@@@E(@U)7&gt;NH/??;?]??&gt;55???&amp;L#??8N;??=;-???_[_??87B??&gt;%3???0];??9CD?=\@U+4L@@@@@@@@@@,@E2+)@FS(?7R3??&gt;N0/??\;G??56$??=R&amp;???SY_??4&gt;Y??=W''???Y:+??8F:??&gt;Q0???KXC? 0@*SP@@@@A_@DZ@?0A\??=Y(_??VZG???????=A#/??N8''??3&gt;M??&lt;?#_??PH;??4NQ????????X*_??3NC?&gt; @[LTJ@@@@(PA%._&lt;@X???BUW??4^W?_???????????4^W?_=G%?7?Q9_=?4^W?_???????????2!9??&lt;@UO??@G_-NP@@@K8@Z\C?@HO??0A0??=X''N;?????????????????^+S4?7*4=O????????????????&lt;@ZO??@G[??0BB;%,@B@&gt;:@FJ4?0BH&gt;O&lt;@"???PH/+?????????????????0A=9O&lt;@_^S?????????????????@H#9?0BK?/&lt;@_.Y\@@@@$0@&gt;\/&lt;@ .7?@H#9?0BC&lt;O???????????0A=9O&lt;@_^W?@G7$?0A=9_???????????0BH&gt;O&lt;@!?[&gt;@GWVN0@@@D$@C1/?@G_Z?0BD&lt;_&lt;@!_O??????0BG=?&lt;@!?_?@H_7?0BG=?&lt;@"O#?@H_6??????&lt;@!OG?@HG,70AO$AP@@@@C@@@@4PAP$?&lt;@_._?@HG,?0BB;_&lt;@ ?C?@HS2?0BD&lt;_&lt;@!OK?@HO0?0BB;/&lt;@ .7?@HK-?0A658L@C!$A@@@@@@@@@C @@@C6@F"??0BA:?&lt;@ .7?@HG+?0BB;_&lt;@ .7?@HK-?0BB;_&lt;@ ^/?@HK-?0A:7&lt;$@NFXX@@@@@@@@@@@@@@@@@@@@TP@@@OD@YK_?@G7%?0BC&lt;O&lt;@ ?C?@HK.?0BC&lt;O&lt;@ ?C?@HK-?0A76\0@NV$.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@- @3W/$@Z,K?@G_Y?0A:8O&lt;@^M3?@GOS:@AT&amp;YH@DR@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@*@@@@Y @@@HP@DA9?@@8YV@@@@BL@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-Merge Management">move	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'move.png'&gt;	&lt;md5sum: #[237 46 53 216 42 68 14 118 233 146 53 136 217 138 240 217]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@A&lt;UA@@_EPP@G1TD@A&lt;UA@P/G0UKX$DJ"H9^C*J([1FZ''6$P[7!OCBENM@ @G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UAEA3S@3 )&amp;8Q??[V(_?;;=/??_#/??;9&lt;_?;;][&lt;;J(&gt;)IQ"C1R"Z1@@G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UAG1:TP3&gt;-'' R??+(2??99LC?=L:N??SM#_?54IS?==2/??/,4/?32(__''V PH&gt;*"K@@_EPP@G1TD@A&lt;UAE%5SP3&gt;*F&lt;Q??KD]??/.E7?4(,U?&gt;:3T_?&gt;&gt;/O?&lt;K-#?&lt;^DEO?+)#W?&lt;,Q9?&gt;&amp;\G]^WY@&lt;L:*@%@A&lt;UA@(5H0[(#%8N?;=&gt;D?&gt;&lt;_AO?-G\R?:52D_?*(BW??/3:??;&lt;&gt;O?21G''?.G(R?&lt;&amp;EEO?N"AW?*F&lt;Q &gt;BTE @_EPQ^ZDTK?9%%C?&gt;+\QG?$&amp;DO?9I!C?&gt;RXP??:*@%??;&lt;&gt;/?&gt;?O+??/38??[W)O&gt;1]QK?/78S?:=4D.^LWP8J:*H,(HAUC_&gt;]ZAC?''6$P??;9&lt;_?&gt;?O+??/38??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+?&gt;.#K?:-1D_&gt;([1G?#E4NN_B;X;:@UP7?%VLO?9I!C??&gt;&gt;_G??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&lt;&lt;&gt;S?)&amp;8Q?8%[C%/-+TR: ETM?9I!C?&gt;LWP;??_#/??;&lt;&gt;O?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+?==2/?9Q"C?&gt;CU05\;J-@%II!C?&gt;IV0;?!U M??;9&lt;_?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O#?&lt;,Q9?89^C/&gt;PW0;&gt;^D&lt;LN?G@[$+J!QS?_EHM?8UXC_&gt;LWP;?#E4N?81]C/&gt;*\AG??/3:??;&lt;&gt;/?&gt;&gt;?[?::T2?81]C/&gt;NW ;?"U,N8GMLCAW/-% C%VLO48AUC_&gt;GVP;?"U,N?81]C/&gt;PW0;?*7DQ??;&lt;&gt;/?==./?)&amp;8Q?81]C/&gt;LWP;?#E4N?7)QCHWJ!QPA''V P@A&lt;UAC+-+4''7^D&lt;L?81]C/&gt;LWP;?#E4N?:)0D_?::\;?%VLO?81]C/&gt;LWP;?#%8N?8MWC\-3S@0Z&lt;,Q9@A&lt;UA@@_EPP@G1TDU^6/Q?M8S03?#E4N?9I!C?&gt;YYP??$&amp;DO?9I!C?&gt;RXP??$&amp;DO?8EUC\=3S@00&lt;,U:@A&lt;UA@@_EPP@G1TD@A&lt;UA@@_EPP2&lt;K1%.8UXC_-8S03?!U M?81]C/&gt;IV0;? ETM:7UMCIZ+\QD!&lt;,Y&lt;@A&lt;UA@@_EPP@G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UA@WN"AT/&lt;[=,[N*!I8''J!QRE4(,UW.2)N2[21G\E3( U@A&lt;UA@@_EPP@G1TD@A&lt;UA@@a')))] once</body><body package="Store-Merge Management">remove	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'remove.png'&gt;	&lt;md5sum: #[102 212 105 10 137 195 5 220 107 214 246 119 240 125 68 194]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@PDABYKG05&lt;"DT1.JI%VMZZVT/M[2&lt;Q''BDSBU\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@%DIO XEGX?&lt;3J&gt;O?6=_;?&gt;/''&gt;??''9?/?*:_3&lt;&amp;YO,)C8U01QOSGX@@@@@@@@@@@@@@@@@@@@@@@@@@G0#D:/&gt;^F7(?&gt;_&amp;?O?#8_/?4=G:?&lt;7J&gt;_?N2?''?6='';?&gt;+)?O?B/?#_R"7PH8VC*0@@@@@@@@@@@@@@@E$&amp;DI_&gt;U#?"?;&gt;;=?&gt;3,N_?)JC!?9BE&lt;_&gt;I_?G?#HK1?9NK&lt;/&gt;4,-''?/[''7?9&amp;R&lt;=]CE,,L XBK@@@@@@(EAR;(JQ[J?8M9&lt;O&gt;W$.S?:N#.??S4=?&gt;A^]3?ZUW,?6!V;O&gt;:.NG??/;&gt;?;:&lt;7/&gt;W#?K?TSG% 7)33P@]GQ5^G@:C?3\X7O=0X^7?$X3W??7=?_??????=OS7?7]/4_&gt;4,.C??/;&gt;???????]7N3?]F#%?5\::^\.E\DJ!(ZG(A$T,?&lt;1F^G?RQ''%?5@,9?&gt;F MW??_7=???????=?_7??/;&gt;???????[6./?VT_X?5@(9?&lt;&gt;F^W?E![MNZV$0K8TEK#?FA#\?2XY8?&lt;5F^W?MA''#?7973??&gt;?/;????????????\6&gt;+?O1_N?3\Y9_&lt;/F^S?FQ''#?1XV3U.P#\N:EAR4?1\W5_&lt;XFM3?FA#^?1\W5O&gt;()]7??/;&gt;????????????=OS7?5QC2?&lt;XFM7?FA#]?1 X6/&lt;UE\Q\#X*&lt;%C$T._&lt;VE,+?E1_U?1XV3O&gt;!''-/??/;&gt;???????_7&gt;+??O3&lt;???????3&lt;?[?PAWC?1\W5_&lt;WE=O&gt;EAR6N:*)/T) V);?EAR;?1\W3?=#V\''??/;&gt;???????Q3&gt;''?EQW@?5YH1??&lt;?O7??????&gt;7-=O&lt;TEK/?E![J8ADQ''!V (J@CRT!M41LS,O&lt;VE,#?EQW@?:Z#7O?M2&gt;#?EQV&gt;?1\W3?&lt;VE,7?SC#D??W4&gt;O&lt;8E[3?E![I?1PT-8U!WJLASD1L@@@@@C*O#[''7D1N.?1XV2_&lt;UE\C?EQV=?1XV2/&lt;VE,+?E![J?1XV2_&lt;TEK[?E![I?1TU/&lt;,PDILZ,;N3@@@@@@@@@@@@E1\WUX:K0?LSD:/?EQWD?1\W3/&lt;WE&lt;;?E![M?1XV3O&lt;VE,7?E![J?1PT.,&lt;PDIH0,+J8@AXVE @@@@@@@@@@@@@@@@@]GQ42)JJ:.2$R(?,SD:3?EAR:?1TU0O&lt;UE[??EAR5:1DQ''IYNQ9X!-+V7@A8^G @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U*Z&amp;(/*Z"6[G-8,H%]U:ZEX%2$W(^E*"Z1,[LEZ&amp;)*@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-Merge Management">resolved	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'resolved.png'&gt;	&lt;md5sum: #[197 163 36 206 221 192 224 49 179 30 219 122 236 239 12 45]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&gt;-0&lt;OF-#8&gt;O$$I)_*9BK[?9P^_?8 E"O&lt;''@7C?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????6''1&lt;_/&gt;C 8W^A9W*?0"9??&lt;G)_??AX;??0Q6?&lt;LBW?= @D#?S0AK?&lt;4BX/&lt;4AG''?@O???0C???&lt;@????@O???6L6M#[?/[7@8"9  /&lt;H,???A:/??0ZT??&lt;D_O??@&amp;W??0EN??&lt;@Q_??@%3?-@M4?0C???&lt;@????@O???0C???&lt;E@@@@8W]7^_&gt;H"H+\BJC+?0"1??&lt;F&amp;/??AHK??0M+??&lt;AT???@C???0EV??&lt;C[/&lt;4AXW?@O???0C???&lt;@????@O???6(0LCO?.K":7SE("O&lt;H-???A9???0VH??&lt;C\_??@%''??0AB??&lt;ATO??@6#?-@Q??0C???&lt;@????@O???0C???&lt;GIBP$9WI2]O&gt;M#YCZBJ3-?0^%??&lt;E#/??AG_??0I_??&lt;@RO??@D+??0I"??&lt;D^_&lt;4AYC?@O???0C???&lt;@????@O???7@+J2;?,+J56CU0"8TG*?&lt;LA)S?NPQ=?;,BY_??@T;??0AD??&lt;BWO??@7O?,0VJ?0C???&lt;@????@O???0C???&lt;JF!(Z:V5-[?&gt;R$)UDB0,K@O???0C???&lt;@????Q0ET?&lt; @O/?$@U[?% M-?2$E!O&lt;@????@O???0C???&lt;@????@O???7\''I2_?+Z600EIRT C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;MI2\'';V]''Z_&gt;X&amp;I(&lt;DQDQ@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???78"H"K?*J"*.E]WVPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;PHB@ &lt;VI"Y_&gt;]''Z@4FQ$Y@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???8P[F17?(*J%*%5]W0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;SJB (3E5]W(J#(:T@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0@a')))] once</body><body package="Store-Merge Management">unresolved	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'unresolved.png'&gt;	&lt;md5sum: #[214 166 157 2 216 133 105 9 111 185 28 101 158 232 223 30]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???2T=OS6EO#8&gt;1TIBP/I@PDC2PDA@1TIBP(T&gt;O#8%OS4=@O???0C???&lt;@????@O???0C???&lt;@????@#4=OWP?O3?5P$IB&gt;65-[_&gt;B (K?%YVU?9RT%O&gt;B (K;[F1,=TIBP''P?O3&lt;BOS4=@O???0C???&lt;@????@#4=O\QAPTG4UEQT?8&gt;O#?&gt;Y&amp;Y''?%9^W?9VU%_&gt;U%YW?%YVU?9ZV%/&gt;M#X74T5MS1DEAPPH=OS4@????@O???7P?O3?4UEQT?9*Z&amp;/&gt;X&amp;I#?):^''?=+Z6/?-;^7?9&gt;_''?&lt;''I2_&gt;]''Y7?%YVU?9^W%?QST5M4O3&lt;?@O???2T=OS75P$IB?9RT%O&gt;^'');?&amp;9.[?;6=/_?9&gt;_''?8NC ??C0&lt;O??????6]''Y?9"X&amp;O&gt;[&amp;9/?$)JR=TIBP"T=OS6EO#8&gt;&gt;7I2\/&gt;&amp;)*[?)JR$?:J"(/&gt;+*:/?)JR$?9&gt;_''?&gt;0,KC???????+:&gt;/&gt; (JC?(*J"?:R$)O-1\WFEO#8&gt;1TIBP/&gt;P$IC?+*:.?:2,+O&gt;+*:/?*Z&amp;)?:&amp;)*_&gt;)*Z''?8NC ???????!8^G?*Z&amp;)?:.+*?&gt;,+J3?#8&gt;O1TIBP/I@PDC?+Z6-?;Z6-/&gt;5-[W?-KR4?;N3,?&gt;3,;O?7=?_???????0&lt;OC?-;^7?;N3,?&gt;4-KS?-[V5?:.+*?I@PDC2PDA@?;V5-_&gt;?/;??/+:&gt;?;6=/_&gt;=/[7?0\GA????????????0&lt;OC?;2&lt;/O&gt;=/[7?/[6=?;:&gt;//&gt;4-KS2PDA@1TIBP/&gt;&amp;)*[?2\''I?&lt;#H2O?G1&lt;_?1,[F?&lt;_G1??O3&lt;??3&lt;?O?&lt;[F1/?F1,[?1&lt;_G?&lt;_G1??H2L#?)ZV%1TIBP(T&gt;O#;&lt;#X6M?=KR4/?Q4]G?4]GQ?=CP4O?V5-[????????????P4MC?4MCP?=CP4O?Q4]G?4-KR?H6M#XT&gt;O#8%OS4==TYFQ/?L3L3?6=/[?=+Z6/?Z6-+?7=?_????????????6]''Y?=+Z6/?Z6-+?6=/[?&lt;3L3OUFQ$X%OS4=@O???7P?O3?6[6=/?&gt;O#8??$9NS?9NS$?&gt;O#8??#8&gt;O?8&gt;O#?&gt;O#8??$9NS?9NS$?&gt;O#8?Y/[6=4O3&lt;?@O???0C???&lt;BOS4=1DEAP_Y1\WG?6]''Y?&gt;''):_?):^''?:^'')?&gt;''):_?):^''?:^'')?=''Y6_Y1\WGDPTEA@#4=OPC???&lt;@????@O???0H=OS54O3&lt;?=T]GQ?6]''Y7?0,KB?=?_7??_7=??0,KB?Y6]''_UGQ4]4O3&lt;?@#4=OPC???&lt;@????@O???0C???&lt;@????@O???2T=OS6EO#8&gt;1TIBP/I@PDC2PDA@1TIBP(T&gt;O#8%OS4=@O???0C???&lt;@????@O???0@a')))] once</body></methods><methods><class-id>Store.MergeIcons class</class-id> <category>resources</category><body package="Store-Merge Management">doNotResolve	"UIMaskEditor new openOnClass: self andSelector: #doNotResolve"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7291 7098)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4497 2344)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 7034 7034)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7548 7548 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7163 6231)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7998 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 8191 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 8191 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 8094 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4400 4207 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5267 4689 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 7227 7227)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 8062 8062)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 4914 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7291 7452 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 8191 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7869 7612)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6263 6295 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4207 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7420 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 8158 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7901 7869 7837)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7869 7869 7869)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4336 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7966 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6713 6713)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7387 6617)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@8B@ HB@ D@@@@@@@@@@@HBG@@@@@XB@ P@@@@@@@HPD!DQDQDQF TB@0@@@@HPDQDHB@ HBADQD@HK@A\BB@ HB@ HB@ HBADPC@@BDA@P@@ HB@ HB@@PD@HX@!@PD1LSD1LSD1LSD1@P@ HPA1L@@@@@@@@@@ALGA0HBA1@S@@@@@@@@@@@SD@\B@ \PD1LSD1LSD1LSD1@G@ HGDA@PDA@PDA@PDA@PDATI@ \PDA@PDA@PDA@PD@(V@@HPDA@PDA@PDA@PD@HU@@@@@!@PDA@GDA@PD@H[@@@@@@@B@ \GA0\GD@HM@@@@@@@@@A BC1PY@ HX@@@@@@@a'))))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 224 0 0 28 120 0 0 63 252 0 0 127 254 0 0 255 254 0 0 247 239 0 0 255 255 0 0 240 15 0 0 240 15 0 0 255 255 0 0 255 255 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0])))</body><body package="Store-Merge Management">unapplied	"UIMaskEditor new openOnClass: self andSelector: #unapplied"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7677 8062)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7709 8030)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(803 803 803)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 6970 6970)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7998 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7773 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5749 5749 5749)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7773 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 8030 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 3276 3276)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2055 2055 2055)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8062 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7934 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8030 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7901 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7805 8126)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'C0&lt;OC0PDB@ IA@PIC0&lt;OC0&lt;ODPPLB@PDA@PDB@PQC0&lt;ODP KC@ DBPTDA@ KBADOC0 MCP0HA@PDA@PHB04HC0$KCP4MC@ HB@ HC!HMCPPKCP4MCP,LC@ HA@8DCP4HB04MCP4KB0,LB@8NC@4MB04MCP4MB0,KB0\NB@4MCP4@@@@L@P KB0 NA@0C@04CB0@@C@8NC@0ND@0C@0LCC@ @@@@HC 8BC  C@0LCB0 I@@@@@@ NC PL@0LC@0,DC0 @@@@LB@(L@@@@@@,HC0&lt;QB0@@@@@@@@@@@@,KDP&lt;OC1DHB0@@@@@@@@,HDP&lt;OC0&lt;OC0$HC@,KC@ IC0&lt;OC0@a'))))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 223 0 0 255 223 0 0 255 191 0 0 243 127 0 0 249 127 0 0 252 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0])))</body><body package="Store-Merge Management">unapplyable	"UIMaskEditor new openOnClass: self andSelector: #unapplyable"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5332 5267 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4689 4625 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3372 3372)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4818 4818 4753)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7773 7452)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6488 6488 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6199 6199 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4529 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5910 5910 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4946 4882 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4368 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5974 5910 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 3983 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4689 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 7741 7612)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5717 5717)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7452 7452 7323)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 3886 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4561 4561 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6584 6552 6488)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5107 5043 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3404 3404)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7773 7644)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6809 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 4207 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4561 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 3950 3918)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7580 7580 7484)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 3629 3629)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7644 7644 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 4240 4175)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4432 4368 4368)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5396 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6070 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7516 7516 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4272 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5010 4272 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 3693 3661)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5203 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 3950 2409)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5396 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5524 5524 5460)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LZJ@@@@@@#@0LC@0LC@0LCGA,@@@@@@@@@@@@#@0LC@20$H0@@@@@@@@@@A@LC@0LYCRH#@@@@@@@@@@@#@0LC@0DNJ"L@@@@@@@@@A@LC@0LQF0$D@@@@@@@@@@@#@0LC@1\RI2LFA@@@@@@@A@LC@0L EA@J@0LCA@@@ABLC@0LC@0TLGPLC@0LC@0LC@0LC@0L^G0,H@0LC@0LC@0LC@0LC@1T#HPLC@0LC@0LC@0LC@0L%FA\G@0LC@0LC@0LC@0LC@2X)@ LC@0LC@0LC@0LC@0LSC1XC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0@a'))))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 0 0 0 127 248 0 0 127 248 0 0 127 252 0 0 63 252 0 0 63 254 0 0 31 254 0 0 30 62 0 0 14 0 0 0 15 0 0 0 7 0 0 0 7 128 0 0 3 128 0 0 3 128 0 0 0 0 0 0])))</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>glorp</category><body package="Store-Repository Access">glorpStoreDatabasePlatformClass	^nil</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>store</category><body package="Store-Repository Access">connection	"Answer the opened connection or nil if the dialog was cancelled."	^self openConnectionUsing: self connectionProfileClass lastUsedProfile</body><body package="Store-Repository Access">openConnectionUsing: aProfile	"Open the dialog with aProfile and then open the database connection that was selected.	Answer the opened connection or nil if the dialog was cancelled."	| profile connection |	profile := aProfile.	[ ( profile := self openProfile: profile ) == nil		ifTrue: [ ^nil ].	connection := self connect: profile.	connection == nil.	] whileTrue.	^connection.</body><body package="Store-Repository Access">openProfile: aProfileOrNil	^self chooseProfileInitially: aProfileOrNil copy</body></methods><methods><class-id>Kernel.CodeComponent class</class-id> <category>signals</category><body package="Store-Repository Access">errorSignals	^DBAccess errorSignals</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>utilities-store</category><body package="Store-Repository Access">errorSignals	^self class errorSignals</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="StoreForGlorpBrowserUI">notifyStoreBrowser	"StoreRefactoringBrowser has an interest in #earlySystemInstallation.   When that event occurs,	 it will clear out any open browsers."	&lt;triggerAtSystemEvent: #earlySystemInstallation&gt;	#{Store.Glorp.StoreRefactoringBrowser} ifDefinedDo: [:value | value cleanUpObsoleteInstances]</body><body package="StoreForGlorpVWUI">notifyGlorpWorkbook	"StoreWorkbook has an interest in #earlySystemInstallation.   When that event occurs,	 it will clear out any open workbooks."	&lt;triggerAtSystemEvent: #earlySystemInstallation&gt;	#{Glorp.UI.GlorpWorkbook} ifDefinedDo: [:value | value cleanUpObsoleteInstances]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="StoreForGlorpVWUI">storeClassChangesIn	&lt;itemInMenu: #(#classMenu #Store) position: 10.02&gt;	^(MenuItem labeled: #BrowseAllMethodChanges &lt;&lt; #store &gt;&gt; 'Browse All Method Changes')		value: #storeClassChanges;		enablement: #isClassSelected</body><body package="StoreForGlorpVWUI">storeLoadPackageOrBundle	&lt;itemInMenu: #(#pundleMenu) 	position: 20.009&gt;	^(MenuItem labeled: #LoadPackageOrBundleDots &lt;&lt; #store &gt;&gt; 'Load Package or Bundle...')		value: 			[self dbRegistry doIfOnlineImage: 				[InputState default ctrlDown					ifTrue: [Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesWithFilter]					ifFalse: [Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesUnfiltered]]]</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-Merge Management">alwaysOpenMergeToolForReview	&lt;setting: #(#store #mergePolicy #alwaysOpenMergeToolForReview)&gt;	^(BooleanSetting on: Store.Glorp.MergeTool aspect: #alwaysOpenMergeTool)		default: true;		label: #alwaysOpenMergeToolUI &lt;&lt; #store &gt;&gt; 'Always open Merge Tool before performing Merge';		helpText: #alwaysOpenMergeToolUIHelp &lt;&lt; #store &gt;&gt; 'This setting determines whether merging is performed as a One-Step Merge or always opens the Merge Tool allowing changes to be reviewed before performing the merge.'</body><body package="Store-Merge Management">mergeBranchBlessingCommentHistoryPolicy	&lt;setting: #(#store #mergePolicy #includeBranchBlessingCommentHistoryPolicy)&gt;	^(BooleanSetting on: Store.Policies aspect: #includeBranchBlessingCommentHistory)		default: true;		label: #IncludeBranchBlessingCommentHistory &lt;&lt; #store &gt;&gt; 'Include branch blessing comment history';		helpText: #includeBranchBlessingCommentHistoryPolicy &lt;&lt; #store &gt;&gt; 'This setting determines if the branch blessing comments are included in the blessing comment of the final merged package.'</body><body package="Store-Merge Management">mergeToolMaxInitialTreeSizePolicy	&lt;setting: #(#store #mergePolicy #mergeToolMaxInitialTreeSizePolicy)&gt;	^(((IntegerSetting min: 1)) 		on: Store.Policies aspect: #mergeToolMaxInitialTreeSize)		label: #MergeToolMaxTreeLabel &lt;&lt; #store &gt;&gt; 'Merge Tool initial tree size';		helpText: #mergeToolMaxInitialTreeSize &lt;&lt; #store &gt;&gt; 'This setting is used to determine the number of items to display in the merge tool modifications tree view when the modifications list size is changed.'</body><body package="Store-Merge Management">mergeToolWarnsBeforeClosing	&lt;setting: #(#store #mergePolicy #warnBeforeAbandoningUnpublished)&gt;	^(BooleanSetting on: Store.Glorp.MergeTool aspect: #warnBeforeAbandoningUnpublished)		default: true;		label: #warnBeforeAbandoningUnpublished &lt;&lt; #store &gt;&gt; 'Warn before abandoning unpublished merge results';		helpText: #warnBeforeAbandoningUnpublishedHelp &lt;&lt; #store &gt;&gt; 'This setting determines if closing the merge tool prior to publishing brings up a warning about unpublished changes.'</body><body package="Store-Merge Management">storeIntegratedBlessingChangePolicy	&lt;setting: #(#store #mergePolicy #integratedBlessingChangePolicy)&gt;	^((EnumerationSetting 			choices: #(#dontChange #change)			labels: (Array with: (#DontChangeBlessingLevel &lt;&lt; #store &gt;&gt; 'Don''t change the blessing level') with: (#ChangeBlessingLevel &lt;&lt; #store &gt;&gt; 'Change blessing level to "Integrated"' )))		on: Store.Policies aspect: #integratedBlessingChangePolicy)		label: #IntegratedBlessingChangePolicyLabel &lt;&lt; #store &gt;&gt; 'Integrated Blessing Change Policy';		helpText: #integratedBlessingChangePolicy &lt;&lt; #store &gt;&gt; 'This setting determines if the blessing level of an integrated version is changed to "Integrated" or left unchanged when the merge tool publishes merged packages.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-Merge Management">storeMergePolicyPage	&lt;settingsPage: #(store mergePolicy)&gt;	^ModularSettingsPage new		label: #MergePolicy &lt;&lt; #store &gt;&gt; 'Merge Policy';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store mergePolicy))</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>testing</category><body package="Store-UI">hasStoreProgressOverlay	^component isKindOf: StoreProgressOverlay</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Store-UI">applied16x16	"UIMaskEditor new openOnClass: self andSelector: #applied16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 7131 7388)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3501 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 7227 7549)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 3212 4690)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 3276 4754)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1767 2409 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7003 7163 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 7195 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 3212 4658)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7067 7259 7581)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 3244 4754)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2827 3855 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3533 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 2377 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2473 3405 4979)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2249 3084 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7003 7195 7484)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2152 2955 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 3276 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7099 7292 7613)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 2698 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2184 3019 4401)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3662 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1767 2409 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 3694 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2795 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1799 2473 3598)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 3758 5493)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2249 3052 4465)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 2570 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2891 4208)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1542 2088 3052)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3533 5172)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1478 2024 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 2666 3887)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3630 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1992 2730 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2762 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1574 2184 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 2216 3244)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2281 3148 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 2538 3726)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1927 2666 3855)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 2377 3469)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2216 3019 4401)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@PDA@PDA@PDA@PDA@PDA@PDA@PDADA@PDA@A@PDA@PDA@PD-A@HYCA$BAB4A@PDA@PDRB2P\GA0\GBPKD DA@PDAGP4WE1\WE1\TCQ4A@PDAF $!HRD!HRDJB (IF DA@QTSC0LOC0&lt;C@0LOD1TA@PD^AP HBALHB@ SD0T^@PDAF24)DQDQDQD)JR$-F0DA@R0%E!XGA0\VE!XVIR0A@PDAFA(_G0@_G1&lt;_F! A@PDA@R\NH2X&amp;I"X&amp;H08''@PDA@PDAHB FJ",*A"  @PDA@PDA@PDAH"H"H"HA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P@a'))</body><body package="Store-UI">applied16x16mask	"UIMaskEditor new openOnClass: self andSelector: #applied16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 31 240 0 0 63 248 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 63 248 0 0 63 248 0 0 31 240 0 0 7 192 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">classMethod16x16	"UIMaskEditor new openOnClass: self andSelector: #classMethod16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1349 1574)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 6585 7099)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2281 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 6232 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 4626 5782)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 5043 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3309 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 1959 2313)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2987 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1445 1638 1927)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3855 3855 3855)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4915 5429 6328)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 4015 4722)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3598 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 2666 3116)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5846 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 4240 5525)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 3887 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3373 3822 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(996 1124 1317)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6585 6842 7292)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ ,B@ HBCPHB@ HB@ HB@ ,BB0HBD1TS@ HB@ HB@ ,B@ HKC DA@P8B@ HB@ ,B@ HBA0PBA@HDA0HB@ ,B@ HBBQ@B@ HB@!@I@ ,B@ HBC00LC@HL@ 0LC@&lt;BB0HB@ HCA HB@ HBA LB@ HK@ HB@  E@ TBAP B@ HB@ ,B@ HKB!DQDP(B@ HB@ HBB0HK@ H@D @B@ HB@ HB@ HK@ HB@!PB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @a'))</body><body package="Store-UI">classMethod16x16mask	"UIMaskEditor new openOnClass: self andSelector: #classMethod16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 4 32 0 0 14 112 0 0 31 248 0 0 63 252 0 0 127 254 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 14 112 0 0 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">instanceMethod16x16	"UIMaskEditor new openOnClass: self andSelector: #instanceMethod16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1349 1574)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 6585 7099)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2281 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 6232 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 4626 5782)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 5043 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3309 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 1959 2313)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2987 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1445 1638 1927)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3855 3855 3855)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4915 5429 6328)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 4015 4722)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3598 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 2666 3116)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5846 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 4240 5525)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 3887 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3373 3822 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(996 1124 1317)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6585 6842 7292)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ 4B@ HBB0HB@ HB@ HB@!LUD0HBB0HK@ HB@ HB@ 8A@PDNB0HB@ ,B@ HB@ \D@ PBA@\B@ HBB0HB@ $P@ HB@ HPBPHB@ HK@ &lt;LC@0BC@HLC@0O@ HB@ ,B@0XB@ HB@ XC@ HB@ ,B@ HHAPHE@ TH@ HB@ ,B@ HB@ (QDQDJB0HB@ ,B@ HB@ HB@AH@@ HK@ ,B@ HB@ HB@ HT@ HB@ ,B@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @a'))</body><body package="Store-UI">instanceMethod16x16mask	"UIMaskEditor new openOnClass: self andSelector: #instanceMethod16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 4 32 0 0 14 112 0 0 31 248 0 0 63 252 0 0 127 254 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 14 112 0 0 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">modificationAdd16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationAdd16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 3019 3630)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1767 3148)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 3630 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1670 2281 3341)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3212 3694)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(964 1574 3052)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2152 2795 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(771 1349 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 4112 6585)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 3180 6232)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 6135 7388)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1927 2538 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5236 6553 7549)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1413 2024 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 5204 7035)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3341 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 5686 7227)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 4658 6810)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'APTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEDA@PD@TEAPTEAPTEAPTEAPPMCPPEAPTEAPTEAPTEAPT@B0,@APTEAPTEAPTEA0\GA1DQA0\GA0TEAPTEAP0OC0&lt;OC0&lt;OC00EAPTEAPTCD!HRD!HRD!HCAPTEAPTEC 8NC $IC 8NC TEAPTEAPTEAPDB@ DEAPTEAPTEAPTEAPTFB (FAPTEAPTEAPTEAPTEB@ HB@TEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAP@a'))</body><body package="Store-UI">modificationAdd16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationAdd16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 3 192 0 0 3 192 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 3 192 0 0 3 192 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">modificationChange16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationChange16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 835 835)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 3565 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2827 1735 1735)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 1124 1124)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7581 5686 5686)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 1413 1413)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3148 2505 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 2827 2827)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 578 578)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3212 2698 2698)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 1992 1992)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7324 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 2281 2281)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 26 17 17 17 17 161 17 17 30 225 17 17 30 225 17 17 30 94 17 17 229 225 17 17 27 221 177 27 221 177 17 17 19 204 195 60 204 49 17 17 22 34 97 22 34 97 17 17 20 132 17 17 72 65 17 17 16 1 17 17 16 1 17 17 25 17 17 17 17 145 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17])</body><body package="Store-UI">modificationChange16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationChange16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 16 8 0 0 24 24 0 0 28 56 0 0 30 120 0 0 31 248 0 0 30 120 0 0 28 56 0 0 24 24 0 0 16 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">modificationMove16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationMove16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2281 2827 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3919 6521)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5975 7324 7870)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(835 1349 2634)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 6071 7356)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 2249 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1124 1638 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1413 1959 2859)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2505 3084 3309)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3276 3373)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2538 3084)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 3244 6264)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5429 6746 7613)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4112 5396 7099)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(578 1092 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 4658 6810)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0(J@0LC@0LC@0LC@0LC@0LI@ $I@0LC@0LC@0LC@0LC@@4MCP@@@0LC@0LC@0LC@0XEAPTEAPXF@0LC@0LC@0LFC 8NC 8NC XC@0LC@0LCBA@PDA@PB@ C@0LC@0LC@0\A@PDGA0LC@0LC@0LC@0LDC@PD@0LC@0LC@0LC@0LCC0&lt;C@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0@a'))</body><body package="Store-UI">modificationMove16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationMove16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 12 0 0 0 15 0 0 0 15 192 0 0 15 240 0 0 15 248 0 0 15 240 0 0 15 192 0 0 15 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">modificationRemove16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationRemove16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2249 1670 1670)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1992 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2281 1767 1767)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2313 1863 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 3565 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 739 739)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2184 1542 1542)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7549 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2056 1221 1221)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7356 5139 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 3019 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 4626 4626)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 5942 5942)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1927 899 899)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 2505 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 1992 1992)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 4112 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1767 482 482)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1799 578 578)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 1381 1381)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LCA@LC@0LCA@LC@0LC@0LC@ 4B@0LC@ 4B@0LC@0LC@@ HB@@C@@ HB@@C@0LC@0LGB (JA0(JB \C@0LC@0LC@1PLC@0LCAPC@0LC@0LC@0LCBQDQDP$C@0LC@0LC@0LCBPTEAPTEBPLC@0LC@0LCC ,KB08KB0,N@0LC@0LCA &lt;OC0XCA &lt;OC0XC@0LC@0LSDALC@0LSDALC@0LC@0LC@1HC@0LC@1HC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0@a'))</body><body package="Store-UI">modificationRemove16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationRemove16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 8 32 0 0 28 112 0 0 62 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 15 224 0 0 31 240 0 0 62 248 0 0 28 112 0 0 8 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">resolved16x16	"UIMaskEditor new openOnClass: self andSelector: #resolved16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 5846 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 6296 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3084 5043 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2827 4658 2795)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 5589 3341)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 6199 3726)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 5332 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4336 7131 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2762 4561 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 7292 4369)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3983 6553 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 5686 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 4369 2634)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 4979 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3373 5525 3309)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 6456 3887)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 7388 4433)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 8030 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 4947 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4626 7613 4561)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4112 6746 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3855 6360 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4144 6842 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 5043 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 4240 2570)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3662 6039 3630)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3148 5172 3116)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 5782 3469)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4079 6713 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 5396 3244)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4658 7645 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4144 6778 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3887 6424 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4690 7741 4626)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4176 6874 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 5621 3373)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 7870 4722)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@PDA@PDA@PDA@PDA@PDA@PDA@PDADA@PDA@A@PDA@PDA@PDVEP("D"HJEQXA@PDA@PDFHAP%IRT%IQP A DA@PDAHQD_G1&lt;_G1&lt;_DRDA@PDA@A4QDQDQDQDQDQD]@@DA@RP#B@ HB@ HB@ HH2PA@PD^E2L#H2L#H2L#H1\^@PDAF0HKB0,KB0,KB0,BF0DA@QLL@ HB@ HB@ HBCALA@PDAF@@ZF!(ZF!(Z@A A@PDA@P$NAQ0\GA0\AP8I@PDA@PDACPPXA0&lt;GF@PM@PDA@PDA@PDAFQ$YFQ$A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P@a'))</body><body package="Store-UI">resolved16x16mask	"UIMaskEditor new openOnClass: self andSelector: #resolved16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 31 240 0 0 63 248 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 63 248 0 0 63 248 0 0 31 240 0 0 7 192 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI">unresolved16x16	"UIMaskEditor new openOnClass: self andSelector: #unresolved16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7067 7067 7067)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6328 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6938 7035)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7581 7613)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7870 7870 7870)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 3533 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7934 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 4144 4401)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 5396 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6456 6456 6456)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7259 7324)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6007 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8159 8159 8159)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 3244 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7420 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7870 7902)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 3855 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 4465 4690)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 5075 5268)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 5718 5846)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'APTEAPTEAPTEAPTEAPTEAPTEAPTEB0,KB0,EAPTEAPTEAPTKBQ@DC PPBP,EAPTEAPTK@@\MD1HJC@\@B0TEAPTEBP\MC0&lt;FC1HEA0$EAPTEB1@ED0&lt;MAP O@PTPB0TEAP,DAP0BDPLRC00EA@,EAPTKC TEAPLFC1PEAP8KAPTEB0PEAPTUC1PEAPTDB0TEAP,PAPTE@!TCAPTED@,EAPTEBP\EAQLO@ TEA0$EAPTEAP,@A0TSC0HEA0@KAPTEAPTEB0$PA@8DD@$KAPTEAPTEAPTEB0,KB0,EAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAP@a'))</body><body package="Store-UI">unresolved16x16mask	"UIMaskEditor new openOnClass: self andSelector: #unresolved16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 31 240 0 0 63 248 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 63 248 0 0 63 248 0 0 31 240 0 0 7 192 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - store</category><body package="Store-UI">storeBrowseClassByNameCommand	&lt;command: #storeBrowseClassByName&gt;	^Command		label: (#BrowseClassByName &lt;&lt; #store &gt;&gt; 'Browse Class By Name')		group: #store		bindings: #()</body><body package="Store-UI">storeBrowseNamespaceByNameCommand	&lt;command: #storeBrowseNamespaceByName&gt;	^Command		label: (#BrowseNamespaceByName &lt;&lt; #store &gt;&gt; 'Browse Namespace By Name')		group: #store		bindings: #()</body><body package="Store-UI">storeBrowseSelectorByNameCommand	&lt;command: #storeBrowseSelectorByName&gt;	^Command		label: (#BrowseSelectorByName &lt;&lt; #store &gt;&gt; 'Browse Selector By Name')		group: #store		bindings: #()</body><body package="Store-UI">storeBrowseSharedVariableByNameCommand	&lt;command: #storeBrowseSharedVariableByName&gt;	^Command		label: (#BrowseSharedVariableByName &lt;&lt; #store &gt;&gt; 'Browse Shared Variable By Name')		group: #store		bindings: #()</body><body package="Store-UI">storeBrowseUnpackagedCommand	&lt;command: #storeBrowseUnpackaged&gt;	^Command		label: (#Browse_Unpackaged &lt;&lt; #store &gt;&gt; 'Browse Unpackaged')		group: #store		bindings: #()</body><body package="Store-UI">storeCheckConsistencyCommand	&lt;command: #storeCheckConsistency&gt;	^Command		label: (#CheckConsistency &lt;&lt; #store &gt;&gt; 'Check Consistency')		group: #store		bindings: #()</body><body package="Store-UI">storeCollectGarbageCommand	&lt;command: #storeCollectGarbage&gt;	^Command		label: (#GarbageCollection &lt;&lt; #store &gt;&gt; 'Garbage Collect Database')		group: #store		bindings: #()</body><body package="Store-UI">storeManageBundleOwnershipCommand	&lt;command: #storeManageBundleOwnership&gt;	^Command		label: (#BundleOwnership &lt;&lt; #store &gt;&gt; 'Manage Bundle Ownership')		group: #store		bindings: #()</body><body package="Store-UI">storeManagePackageOwnershipCommand	&lt;command: #storeManagePackageOwnership&gt;	^Command		label: (#PackageOwnership &lt;&lt; #store &gt;&gt; 'Manage Package Ownership')		group: #store		bindings: #()</body><body package="Store-UI">storeManageUsersAndGroupsCommand	&lt;command: #storeManageUsersAndGroups&gt;	^Command		label: (#UserGroupManagement &lt;&lt; #store &gt;&gt; 'User/Group Management')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenFilteredLoadedItemsCommand	&lt;command: #storeOpenFilteredLoadedItems&gt;	^Command		label: (#FilteredLoadedItems &lt;&lt; #store &gt;&gt; 'Filtered Loaded Items...')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenFilteredPublishedItemsCommand	&lt;command: #storeOpenFilteredPublishedItems&gt;	^Command		label: (#FilteredPublishedItems &lt;&lt; #store &gt;&gt; 'Filtered Published Items...')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenFilteredRecentlyPublishedItemsCommand	&lt;command: #storeOpenFilteredRecentlyPublishedItems&gt;	^Command		label: (#FilteredRecentlyPublishedItems &lt;&lt; #store &gt;&gt; 'Filtered Recently Published Items...')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenLoadedItemsCommand	&lt;command: #storeOpenLoadedItems&gt;	^Command		label: (#LoadedItemsDots &lt;&lt; #store &gt;&gt; 'Loaded Items...')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenMergeToolCommand	&lt;command: #storeOpenMergeTool&gt;	^Command		label: (#OpenMergeTool &lt;&lt; #store &gt;&gt; 'Open Merge Tool')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenPublishedItemsCommand	&lt;command: #storeOpenPublishedItems&gt;	^Command		label: (#PublishedItemsDots &lt;&lt; #store &gt;&gt; 'Published Items...')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenRecentlyPublishedItemsCommand	&lt;command: #storeOpenRecentlyPublishedItems&gt;	^Command		label: (#RecentlyPublishedItems &lt;&lt; #store &gt;&gt; 'Recently Published Items...')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenSettingsCommand	&lt;command: #storeOpenSettings&gt;	^Command		label: (#OpenSettings &lt;&lt; #store &gt;&gt; 'Open Store Settings')		group: #store		bindings: #()</body><body package="Store-UI">storeOpenWorkbookCommand	&lt;command: #storeOpenWorkbook&gt;	^Command		label: (#OpenWorkbook &lt;&lt; #store &gt;&gt; 'Open Store Workbook')		group: #store		bindings: #()</body><body package="Store-UI">storeRemoveDatabaseLinksCommand	&lt;command: #storeRemoveDatabaseLinks&gt;	^Command		label: (#RemoveDatabaseLinks &lt;&lt; #store &gt;&gt; 'Remove Database Links...')		group: #store		bindings: #()</body><body package="Store-UI">storeRenameBundleInDatabaseCommand	&lt;command: #storeRenameBundleInDatabase&gt;	^Command		label: (#RenameBundleInDatabase &lt;&lt; #store &gt;&gt; 'Rename Bundle in Database...')		group: #store		bindings: #()</body><body package="Store-UI">storeRenamePackageInDatabaseCommand	&lt;command: #storeRenamePackageInDatabase&gt;	^Command		label: (#RenamePackageInDatabase &lt;&lt; #store &gt;&gt; 'Rename Package in Database...')		group: #store		bindings: #()</body><body package="Store-UI">storeSetCurrentPackageCommand	&lt;command: #storeSetCurrentPackage&gt;	^Command		label: (#CurrentPackage &lt;&lt; #store &gt;&gt; 'Current Package...')		group: #store		bindings: #()</body><body package="Store-UI">storeSwitchDatabasesCommand	&lt;command: #storeSwitchDatabases&gt;	^Command		label: (#SwitchDatabases &lt;&lt; #store &gt;&gt; 'Switch Databases')		group: #store		bindings: #()</body><body package="Store-UI">storeToggleConnectionCommand	"In actual use, this is dynamic"	&lt;command: #storeToggleConnection&gt;	^Command 		label: 'Toggle Connection' 		group: #store 		bindings: #()</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI">store01StoreIIDebug	"&lt;setting: #(store storeIIPage storeIIDebug)&gt;"	^(BooleanSetting on: #{Store.Glorp.StoreObject.DebugStoreII})		label: #debugStoreII &lt;&lt; #labels &gt;&gt; 'Debug Store II';		default: false;		helpText: #storeDebugStoreII &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store II will throw a Dialog before it attempts to convert a Store II object into a Store I object'</body><body package="Store-UI">store05ParcelDirectory	&lt;setting: #(store parcelDirectory)&gt;	^(DirectorySetting on: PundleAccess aspect: #parcelDirectory)		default: Filename currentDirectory asLogicalFileSpecification asString;		label: #ParcelDirectory &lt;&lt; #store  &gt;&gt; 'Parcel Directory';		helpText:  #ParcelDirectoryHelp &lt;&lt; #store  &gt;&gt; 'When publishing a pundle, one can optionally choose to publish a parcel for the pundle.  This setting is the directory that will be those parcels are published.  When loading a bundle that has been published binary into the database, this directory is also used to create a subdirectory store the parcel sources file. The name of the subdirectory will be the database identifier for the database that the pundle was loaded from.'</body><body package="Store-UI">store10FilesLoadingPromptPolicy	&lt;setting: #(store files promptingPolicy)&gt;	^((EnumerationSetting 				choices: #(#always #never #prompt)				labels: (Array 							with: (#DownloadWithoutPrompting &lt;&lt; #store &gt;&gt; 'Download without prompting')							with: (#NeverDownload &lt;&lt; #store &gt;&gt; 'Never Download')							with: (#PromptWhenDownloading &lt;&lt; #store &gt;&gt; 'Prompt when downloading')))			on: Policies filePolicy aspect: #downloadPreference)		label: #WhenLoadingBundlesLabel &lt;&lt; #store &gt;&gt;'When loading bundles that have files';		helpText: #FileLoadingPromptPolicy &lt;&lt; #store &gt;&gt; 'When a bundle has files associated with it, you have three choices on what to do with those files.  You can download the files without being asked, never download files or be asked which files you want downloaded.'</body><body package="Store-UI">store14UseNewCompareTool	&lt;setting: #(#store #useNewCompareTool)&gt;	^(BooleanSetting on: ComparePackages aspect: #useNewCompareTool)		label: #UseNewCompareTool &lt;&lt; #labels &gt;&gt; 'Use New Compare Tool';		helpText: #useNewCompareToolHelp &lt;&lt; #store &gt;&gt; 'When checked, use the latest compare tool which uses an disclosure tree style presentation of differences as opposed to the previous, browser style tool.'</body><body package="Store-UI">store15FilesLoadingUseDownloadDirectory	&lt;setting: #(store files useDownloadDirectory)&gt;	^(BooleanSetting on: Policies filePolicy aspect: #useDownloadDirectory)		label: #UseDownloadDirectory &lt;&lt; #store &gt;&gt; 'Use Download Directory';		default: Filename currentDirectory asLogicalFileSpecification;		helpText: #UseDownloadDirectoryHelp &lt;&lt; #store &gt;&gt; 'If checked use the download directory.'</body><body package="Store-UI">store15UseFastComparison	&lt;setting: #(store useFastComparison)&gt;	^(BooleanSetting on: PundleModel aspect: #useChangeSetsForCompare)		label: #UseFastComparison &lt;&lt; #labels &gt;&gt; 'Use fast comparison';		helpText: #store15UseFastComparison &lt;&lt; #dialogs &gt;&gt; 'This option chooses how Store determines changes that need to be published.  When on, Store uses change sets, when off, it compares code in the image with the database.Usually fast comparison should be turned on.  This results in much faster performance when publishing and when comparing a loaded package with a version in the database.Occasionally you may encounter a bug that causes the change set of a package to enter an incorrect state.  In this case, publishing the package may not publish all changed definitions, and comparing the in-image package with a database version may likewise fail to compute the correct result.To cause the publish and compare operations to ignore the damaged change set, turn this setting off.  This forces these operations to compare the in-image version directly with the database version rather than consulting the change set to find out what has changed since the package was loaded.'</body><body package="Store-UI">store20FilesLoadingDownloadDirectory	&lt;setting: #(store files downloadDirectory)&gt;	^(DirectorySetting on: Policies filePolicy aspect: #downloadDirectory)		label: #DownloadDirectory &lt;&lt; #store &gt;&gt; 'Download Directory';		default: Filename currentDirectory asLogicalFileSpecification;		helpText: #DownloadDirectoryHelp &lt;&lt; #store &gt;&gt; 'This the directory that where files that are downloaded from a bundle are stored.  If the files being downloaded have use a SystemVariable (for example: ''$(VARIABLE)/file.txt'') then the variable will be ignored, and the download directory will be used instead.'</body><body package="Store-UI">store20WarnOnNewerPundle	&lt;setting: #(#store #publishingPolicy #warnOnNewer)&gt;	^(BooleanSetting on: #{Store.Glorp.StoreObject} value aspect: #warnIfNewerVersionPublished)		label: #WarnOnNewerVersionPublished &lt;&lt; #labels &gt;&gt; 'Display a warning when publishing if a newer version exists';		default: false;		helpText: #WarnOnNewerVersionPublishedHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled, if a newer version of the item you are about to publish exists in the repository, a dialog will open allowing you to choose whether or not to proceed to publish your version. This gives you the opportunity to examine the changes in the newer version before publishing your work should you choose to not proceed.'</body><body package="Store-UI">store50NewClassPackage	&lt;setting: #(store packageDefaults newClassPackage)&gt;	^((EnumerationSetting 		keys: #(#current #prompt)		choices: #(true false)		labels: (Array with: (#Current &lt;&lt; #store &gt;&gt; 'Current') with: (#Prompt &lt;&lt; #store &gt;&gt; 'Prompt'))) 			on: (StoreSettings preferenceModelFor: #newClassUseCurrent)) 			label: #ForANewClass &lt;&lt; #store &gt;&gt; 'For a new class'</body><body package="Store-UI">store50UseShadowLoading	&lt;setting: #(store #loadingPolicy useShadowLoading)&gt;	^(BooleanSetting on: DBAccess aspect: #useAtomicLoader)		default: true;		label: #useAtomicLoader &lt;&lt; #labels &gt;&gt; 'Use the atomic loader';		helpText: #useAtomicLoaderHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will load use the atomic loader when loading packages and bundles from a database.  The atomic loader allows you to load code that might otherwise not be loadable under normal loading.'</body><body package="Store-UI">store51UseAnalysisLoader	&lt;setting: #(store #loadingPolicy useAnalysisLoader)&gt;	^(BooleanSetting on: DBAccess aspect: #useAnalysisLoader)		default: true;		label: #useAtomicAnalysisLoader &lt;&lt; #labels &gt;&gt; 'Use the atomic analysis loader';		helpText: #useAtomicAnalysisLoaderHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled along with the atomic loader, Store will load use an analysis loader, which will analyze the component(s) being loaded, and attempt to process all the definitions in as few passes as possible'</body><body package="Store-UI">store52NewMethodPackage	&lt;setting: #(store packageDefaults newMethodPackage)&gt;	^((EnumerationSetting 		choices: #(#currentINAU #currentINUTCP #useTCP #useTCPIC #useTCPICON #alwaysAsk)		labels: (Array 				with: (#Current &lt;&lt; #store &gt;&gt; 'Current') 				with: (#CurrentOrClassPackage &lt;&lt; #store &gt;&gt; 'Current or class package') 				with: (#ClassPackage &lt;&lt; #store &gt;&gt; 'Class package') asString) , 					(Array 						with: (#ClassIfSameAsCurrent &lt;&lt; #store &gt;&gt; 'Class if same as current') 						with: (#ClassIfSameAsCurrentOrNone &lt;&lt; #store &gt;&gt; 'Class if same as current or none') 						with: (#AlwaysPrompt &lt;&lt; #store &gt;&gt; 'Always prompt') )) 			on: (StoreSettings preferenceModelFor: #methodPlacement)) 			label: #ForANewMethod &lt;&lt; #store &gt;&gt; 'For a new method'</body><body package="Store-UI">store54NewSharedPackage	&lt;setting: #(store packageDefaults newSharedPackage)&gt;	^((EnumerationSetting 		choices: #(#currentINAU #currentINUTCP #useTCP #useTCPIC #useTCPICON #alwaysAsk)		labels: (Array 				with: (#Current &lt;&lt; #store &gt;&gt; 'Current') 				with: (#CurrentOrClassPackage &lt;&lt; #store &gt;&gt; 'Current or class package') 				with: (#ClassPackage &lt;&lt; #store &gt;&gt; 'Class package') asString) , 					(Array 						with: (#ClassIfSameAsCurrent &lt;&lt; #store &gt;&gt; 'Class if same as current') 						with: (#ClassIfSameAsCurrentOrNone &lt;&lt; #store &gt;&gt; 'Class if same as current or none')						with: (#AlwaysPrompt &lt;&lt; #store &gt;&gt; 'Always prompt'))) 			on: (StoreSettings preferenceModelFor: #datumPlacement)) 			label: #ForANewVariable &lt;&lt; #store &gt;&gt; 'For a new variable'</body><body package="Store-UI">store58WarnOnUpdatingUnchangedPackage	&lt;setting: #(store packageDefaults warnOnUpdatingUnchanged)&gt;	^(BooleanSetting 		on: Policies packagePolicy		aspect: #warnOnFirstModification)			label: #warnOnUpdatingUnchangedPackage &lt;&lt; #labels &gt;&gt; 'Warn before updating an unchanged package';			default: false;			helpText: #warnOnUpdatingUnchangedPackageHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will ask you if you wish to change an unchanged package during load. Otherwise it will simply make the change and continue loading'</body><body package="Store-UI">store60AllowBinaryLoading	&lt;setting: #(store loadingPolicy allowBinaryLoading)&gt;	^(BooleanSetting on: Policies publishPolicy aspect: #allowBinaryLoading)		label: #allowBinaryLoading &lt;&lt; #labels &gt;&gt; 'Allow binary loading';		helpText: #store60AllowBinaryLoading &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will load binary all packages that were saved binary. When disabled, Store will load source code in all cases.'</body><body package="Store-UI">store61WriteLoadRecord	&lt;setting: #(store #loadingPolicy writeLoadRecords)&gt;	^(BooleanSetting on: DBAccess aspect: #shouldWriteLoadRecords)		default: true;		label: #writeLoadRecords &lt;&lt; #labels &gt;&gt; 'Record pundle loads in LoadRecord table';		helpText: #writeLoadRecordsHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will write a record to the LoadRecord table containing the the following information about the load action: the user name, pundle name, pundle type (bundle or package), the version, and the timestamp of the completed load.'</body><body package="Store-UI">store80IncludePackageIntoFileout		&lt;setting: #(#store #includePackageIntoFileout)&gt;	| adaptor |	adaptor := (PluggableAdaptor on: (StoreSettings preferenceModelFor: #fileoutOption))		getBlock: [:model | model value]		putBlock:			[:model :value | 			model value: value.			value == #always 				ifTrue: [Registry installCallBacksForFileout] 				ifFalse: [Registry removeCallBacksForFileout]]		updateBlock: [:model :aspect :parameter | true].	^((EnumerationSetting		choices: #(#never #storeOnly #always)		labels: (Array 			with: #Never &lt;&lt; #store &gt;&gt; 'Never' 			with: #ForPackageFileouts &lt;&lt; #store &gt;&gt; 'For package fileouts' 			with: #Always &lt;&lt; #store &gt;&gt; 'Always'))				on: adaptor) label: #FileOutPackageInformation &lt;&lt; #store &gt;&gt; 'File out package information'</body><body package="Store-UI">store80ReconnectOnRestart	&lt;setting: #(#store #reconnectOnRestart)&gt;	^((EnumerationSetting 			choices: #(#disconnect #prompt #reconnect)			labels: (Array					with: (#DisconnectOption &lt;&lt; #store &gt;&gt; 'Do not reconnect to the Store database')					with: (#PromptOption &lt;&lt; #store &gt;&gt; 'Prompt to reconnect with last saved profile' )					with: (#ReconnectOption &lt;&lt; #store &gt;&gt; 'Automatically reconnect with last saved profile' )))		on: StoreDevelopmentSystem aspect: #reconnectAction)		label: #ReconnectOnRestart &lt;&lt; #store &gt;&gt; 'Reconnect action on restart';		helpText: #ReconnectOnRestartHelpText &lt;&lt; #store &gt;&gt; 'This setting determines what action Store takes on restarting an image that was connected to a Store database when saved.  There are three options, disconnect, prompt, and reconnect.  If the setting is "disconnect," Store will remain disconnected.  If the setting is "reconnect," Store will attempt to reconnect using the same profile as the saved connection.  If the setting is "prompt," Store will prompt the user to reconnect, using as default the same profile as the saved connection.'</body><body package="Store-UI">store80StoreIILoadFailOption	&lt;setting: #(store loadingPolicy storeIILoadFailOption)&gt;	^((EnumerationSetting 			choices: #(#loadButNotify #load #displayDialog #fail)			labels: (Array					with: (#LoadButNotifyOption &lt;&lt; #store &gt;&gt; 'Complete the load but open a tool to manage errors')					with: (#LoadOption &lt;&lt; #store &gt;&gt; 'Ignore errors and load what can be loaded' )					with: (#DisplayDialogOption &lt;&lt; #store &gt;&gt; 'Open a dialog to ask what to do')					with: (#FailOption &lt;&lt; #store &gt;&gt; 'Load only if there are no errors' )))		on: Store.AbstractPundleLoader.LoadFailedOption)		label: #FailOptionPrompt &lt;&lt; #store &gt;&gt; 'How should load errors be handled?';		helpText: #FailOptionText &lt;&lt; #store &gt;&gt; 'This setting controls what will happen when errors are encountered in the process of loading a package or bundle.  The first two options WILL modify the system.  The third option will allow you to decide what to do before the system is changed.  The last option will leave the system unchanged.'</body><body package="Store-UI">store90UseRecursionIfSupported	&lt;setting: #(#store #storeMayRecurse)&gt;	^(BooleanSetting on: Store.Glorp.StoreDescriptorSystem aspect: #useRecursionIfSupported)		label: #UseRecursionIfSupported &lt;&lt; #labels &gt;&gt; 'Read long methods (&gt;32k source) faster';		helpText: #useRecursionIfSupported &lt;&lt; #store &gt;&gt; 'When checked, Store reads all of the source of long methods in a single round trip (if the database supports recursive SQL).  This speeds the reading of methods with more than 32k of source, which are usually very rare but might be common in a given application, at the possible cost of slightly complicating the reading of other methods.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI">storeFilesDownloadingPage	&lt;settingsPage: #(store files)&gt;	|directory useDownload|	directory := DirectorySettingModule on: (self settingWithId: #(store files downloadDirectory)).	useDownload := BooleanSettingModule on: (self settingWithId: #(store files useDownloadDirectory)).	^ModularSettingsPage new		label: #FilesDownloadingPolicy &lt;&lt; #labels &gt;&gt; 'Files Downloading';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		addAllSettings: (self settingsWithPrefix: #(store files)					except: #(useDownloadDirectory downloadDirectory));		addModule: useDownload;		addModule: directory;		when: useDownload valueHolder valueSatisfies: [:v | v = true] enable: directory</body><body package="Store-UI">storeIIPage	"&lt;settingsPage: #(#store #storeIIPage)&gt;"	^ModularSettingsPage new		label: #StoreIIPage &lt;&lt; #store &gt;&gt; 'Store II';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store storeIIPage))</body><body package="Store-UI">storeLoadingPolicy	&lt;settingsPage: #(#store #loadingPolicy)&gt;	^ModularSettingsPage new		label: #LoadingPolicyLoading &lt;&lt; #store &gt;&gt; 'Loading Policies';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store loadingPolicy))</body><body package="Store-UI">storePackageDefaultPage	&lt;settingsPage: #(store packageDefaults)&gt;	^ModularSettingsPage new		label: #StoreDefaultPackage &lt;&lt; #labels &gt;&gt; 'Default Package';		icon: (ListIconLibrary visualFor: #store);		settings: (self settingsWithPrefix: #(store packageDefaults))</body><body package="Store-UI">storePage	&lt;settingsPage: #(store)&gt;	^ModularSettingsPage new		label: #Store &lt;&lt; #labels &gt;&gt; 'Store';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI">storePrerequisitesBlessingLevel	&lt;setting: #(#store #prerequisites #blessingLevel ) position: 10  &gt;	| levels choices labels keys |	levels := Policies blessingPolicy blessings asSortedCollection.	choices := levels collect: [:each | each level].	labels := levels collect: [:each | each name].	keys := levels collect: [:each | each level printString asSymbol].	^((EnumerationSetting		keys: keys		choices: choices		labels: labels)		on: Policies prerequisitePolicy aspect: #blessingLevel)		label: #WithBlessingLevelAtLeast &lt;&lt; #store &gt;&gt; '...with blessing level at least'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI">storePrerequisitesPage	&lt;settingsPage: #(store prerequisites)&gt;	| version level |	version := EnumerationSettingRadioModule 				on: (self settingWithId: #(#store #prerequisites #versionSelection)).	level := EnumerationSettingModule 				on: (self settingWithId: #(#store #prerequisites #blessingLevel)).	^(ModularSettingsPage new)		label: #Prerequisites &lt;&lt; #labels &gt;&gt; 'Prerequisites';		icon: (ListIconLibrary visualFor: #store);		addModule: version;		addModule: level;		when: version valueHolder valueSatisfies: [:v | v = #latest] enable: level;		useRadioButtonsForEnumerations;		addAllSettings: (self settingsWithPrefix: #(#store #prerequisites)					except: #(#versionSelection #blessingLevel))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI">storePrerequisitesSeachOrder	&lt;setting: #(store prerequisites searchOrder) position: 20 &gt;	^((EnumerationSetting choices: #(#pundlesFirst #parcelsFirst)		labels: (Array 				with: (#SearchBundlesAndPackagesFirst &lt;&lt; #store &gt;&gt; 'Search bundles and packages first')				with: (#SearchParcelsFirst &lt;&lt; #store &gt;&gt; 'Search parcels first'))) 			on: Policies prerequisitePolicy			aspect: #searchOrder) 			label: #ToLoadAnyPrerequisite &lt;&lt; #store &gt;&gt; 'To load #any prerequisite'</body><body package="Store-UI">storePrerequisitesVersionSelection	&lt;setting: #(store prerequisites versionSelection) position: 30 &gt;	^((EnumerationSetting choices: #(#ask #latest)		labels: (Array with: (#AlwaysPromptForVersion &lt;&lt; #store &gt;&gt; 'Always prompt for version') with: (#LoadLatestVersion &lt;&lt; #store &gt;&gt; 'Load latest version...'))) 			on: Policies prerequisitePolicy			aspect: #versionSelection) 			label: #WhenLoadingAPrerequisite &lt;&lt; #store &gt;&gt; 'When loading a prerequisite'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI">storePublishingPolicy	&lt;settingsPage: #(store publishingPolicy)&gt;	^ModularSettingsPage new		label: #PublishingPolicy &lt;&lt; #labels &gt;&gt; 'Publishing Policy';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store publishingPolicy))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI">storeRepositories	&lt;setting: #(store repositories)&gt;	^StoreRepositoryListSetting new</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI">storeRepositoriesPage	&lt;settingsPage: #(store repositories)&gt;	^StoreRepositoryListPage new		label: #StoreRepositories &lt;&lt; #labels &gt;&gt; 'Repositories';		icon: (ListIconLibrary visualFor: #store);		setting: (self settingWithId: #(store repositories))</body><body package="Store-UI">storeTableSpacesPage	&lt;settingsPage: #(store tableSpaces)&gt;	^ModularSettingsPage new		label: #StoreTableSpaces &lt;&lt; #labels &gt;&gt; 'Table Spaces';		icon: (ListIconLibrary visualFor: #store);		settings: (self settingsWithPrefix: #(store tableSpaces))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI">tableSpaces20ForBlobs	&lt;setting: #(store tableSpaces tableSpaces20ForBlobs)&gt;	^(StringSetting on: Policies tableSpacePolicy aspect: #blobTableSpace)		label: #TableSpaceForBlobs &lt;&lt; #store &gt;&gt; 'Blobs';		helpText: #TableSpaceForBlobsHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which Blob and Binary Blob objects are stored'</body><body package="Store-UI">tableSpaces30ForMethods	&lt;setting: #(store tableSpaces tableSpaces30ForMethods)&gt;	^(StringSetting on: Policies tableSpacePolicy aspect: #methodsTableSpace)		label: #Methods &lt;&lt; #store &gt;&gt; 'Methods';		helpText: #TableSpaceForMethodsHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which Methods are stored'</body><body package="Store-UI">tableSpaces40ForUserInfo	&lt;setting: #(store tableSpaces tableSpaces40ForUserInfo)&gt;	^(StringSetting on: Policies tableSpacePolicy aspect: #userAndOwnershipTableSpace)		label: (#TableSpaceForUserInfo &lt;&lt; #store &gt;&gt; 'Ownership and Privileges');		helpText: #TableSpaceForUserPrivHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which user privileges and owerhship information is stored'</body><body package="Store-UI">tableSpaces50Other	&lt;setting: #(store tableSpaces #tableSpaces50Other)&gt;	^(StringSetting on: Policies tableSpacePolicy aspect: #defaultTableSpace)		label: #TableSpaceOther &lt;&lt; #store &gt;&gt; 'All Other Tables';		helpText: #TableSpaceDefaultHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which all tables are created other than the ones that are specified'</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>Store feedback</category><body package="Store-UI">withStoreFeedbackOn: aWindow	^StoreProgressOverlay subsume: aWindow while: self</body></methods><methods><class-id>UI.MultiSelectionSequenceView</class-id> <category>text length calculation</category><body package="Store-UI">fontForEmphasis: emphasisSymbol	^self graphicsContext		findFont: (self textStyle fontAt: emphasisSymbol for: self textStyle defaultFontPolicy)</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="Store-UI">notifyDefinitionForListTool	"DefinitionForListTool has an interest in #earlySystemInstallation.   When that event occurs,	 it will clear out any open browsers."	&lt;triggerAtSystemEvent: #earlySystemInstallation&gt;	#{Store.Glorp.DefinitionForListTool} ifDefinedDo: [:value | value cleanUpObsoleteInstances]</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>system information</category><body package="Store-UI">printBundlesOn: aStream	&lt;systemInformation: 2.1&gt;	aStream nextPutAllText: (#Bundles &lt;&lt; #store &gt;&gt; 'Bundles:') asText allBold.	self printNamesAndVersionsOf: Registry allBundles on: aStream.	aStream cr</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>private</category><body package="Store-UI">printNamesAndVersionsOf: pundleCollection on: aStream	(pundleCollection asSortedCollection: [:a :b | a name &lt;= b name]) do:		[:pundle |		aStream 			crtab; 			nextPutAll: pundle name, ' ', pundle versionString]</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>system information</category><body package="Store-UI">printPackagesOn: aStream	&lt;systemInformation: 2.2&gt;	aStream nextPutAllText: (#PackagesC &lt;&lt; #store &gt;&gt; 'Packages:') asText allBold.	self printNamesAndVersionsOf: Registry allPackages on: aStream.	aStream cr</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>file name list</category><body package="Store-UI">fileIntoPackage	"Prompt for the package to read into. 	Read the entire file into the selected package."	| pkg file |	pkg := PackageChooser chooseOrAddOnCancelDo: [^self].	file := fileName asFilename withEncoding: self currentFileEncoding.	Notice show: (#FilingIntoN1S &lt;&lt; #dialogs &gt;&gt; 'Filing into&lt;n&gt;&lt;1s&gt;'				expandMacrosWith: pkg name)		while: 			[Policies packagePolicy forcePackage: pkg				while: 					[[file fileIn] on: RedefinitionNotification						do: [:note | note installOverrideIfNecessary]]]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - store</category><body package="Store-UI">areAttached	^DbRegistry isConnected</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Store-UI">browseClassDefinitions	| name list matches targetName session |	name := Dialog request: (#ClassNameMatching &lt;&lt; #store &gt;&gt; 'Class name matching') asString.	name isEmpty ifTrue: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Gathering for: name) started.	matches := Store.Glorp.StoreClassDefinition allNamesMatching: name in: session.	(Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	matches isEmpty ifTrue: 		[^self noItemsOfType: (#ClassName &lt;&lt; #store &gt;&gt; 'Class name') asString match: name].	(targetName := self selectNameFrom: matches chooseTitle: (#ClassName &lt;&lt; #store &gt;&gt; 'Class name') asString) ifNil: [^self].	[(Gathering for: targetName) started.	list := Store.Glorp.StoreClassDefinitionInPackage allVersionsWithName: targetName in: session.	(Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	list isEmpty ifTrue: 		[^Dialog warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.' expandMacrosWith: targetName)].	Store.Glorp.DefinitionForListTool forClasses: list</body><body package="Store-UI">browseNameSpaceDefinitions	| name list session matches targetName |	name := Dialog request: (#NameSpaceNameMatching &lt;&lt; #store &gt;&gt; 'NameSpace name matching') asString.	name isEmpty ifTrue: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Gathering for: name) started.	matches := Store.Glorp.StoreNameSpace allNamesMatching: name in: session.	(Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	matches isEmpty ifTrue: 		[^self noItemsOfType: (#NameSpaceName &lt;&lt; #store &gt;&gt; 'NameSpace name') asString match: name].	(targetName := self selectNameFrom: matches chooseTitle: (#NameSpaceName &lt;&lt; #store &gt;&gt; 'NameSpace name') asString) ifNil:		[^self].	[(Gathering for: targetName) started.	list := Store.Glorp.StoreNamespaceInPackage allVersionsWithName: targetName in: session.	(Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	list isEmpty 		ifTrue: 			[^Dialog warn: ((#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.') expandMacrosWith: targetName)].	Store.Glorp.DefinitionForListTool forNameSpaces: list</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI">browseSelector	| name list classes className session matches targetName |	name := Dialog request: (#SelectorNameMatching &lt;&lt; #store &gt;&gt; 'Selector name matching') asString.	name isEmpty ifTrue: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Gathering for: name) started.	matches := Store.Glorp.StoreMethod allNamesMatching: name in: session.	(Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	matches isEmpty ifTrue: 		[^self noItemsOfType: (#SelectorName &lt;&lt; #store &gt;&gt; 'Selector name') asString match: name].	(targetName := self selectNameFrom: matches chooseTitle: (#SelectorName &lt;&lt; #store &gt;&gt; 'Selector name') asString) ifNil: [^self].	[(Gathering for: targetName) started.	list := Store.Glorp.StoreMethodInPackage allVersionsWithName: targetName in: session.	classes := list collect: [:each | each classNameWithMeta asSymbol].	classes := classes asSet asSortedCollection asOrderedCollection.	(Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	className := classes size == 1		ifTrue: [classes first]		ifFalse: 			[Dialog 				choose: ((#_1sInWhichClassDots &lt;&lt; #store &gt;&gt; '#&lt;1s&gt; in which class...') expandMacrosWith: targetName)				fromList: classes 				values: classes				lines: 10 				cancel: [^nil]				for: self mainWindow].	[(Gathering for: className) started.	list := Store.Glorp.StoreMethodInPackage allVersionsWithName: targetName inClass: className in: session.	(Gathering for: className) finished] withStoreFeedbackOn: self mainWindow.	Store.Glorp.DefinitionForListTool forMethods: list.</body><body package="Store-UI">browseStatic	| name list owners owner session matches targetName typeString |	name  := Dialog request: (#SharedVariableNameMatching &lt;&lt; #store &gt;&gt; 'Shared Variable name matching') asString.	name isEmpty ifTrue: [ ^self ].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Gathering for: name) started.	matches := Store.Glorp.StoreSharedVariable allNamesMatching: name in: session.	(Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	typeString := (#SharedVariableName &lt;&lt; #store &gt;&gt; 'Shared Variable name') asString.	matches isEmpty ifTrue: 		[^self noItemsOfType: typeString match: name].	(targetName := self selectNameFrom: matches chooseTitle: typeString) ifNil: [^self].	[(Gathering for: targetName) started.	list := Store.Glorp.StoreSharedVariableInPackage allVersionsWithName: targetName in: session.	owners := list collect: [:each | each absoluteOwnerName asSymbol].	owners := owners asSet asSortedCollection asOrderedCollection.	(Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	owner := owners size == 1		ifTrue: [owners first]		ifFalse: 			[Dialog 				choose: ((#_1sInWhichClassOrNameSpaceDots &lt;&lt; #store &gt;&gt; '#&lt;1s&gt; in which Class or NameSpace...')  expandMacrosWith: name )				fromList: owners 				values: owners				lines: 10 				cancel: [^nil]				for: self mainWindow ].	[(Gathering for: owner) started.	list := Store.Glorp.StoreSharedVariableInPackage allVersionsWithName: targetName inOwner: owner in: session.	(Gathering for: owner) finished] withStoreFeedbackOn: self mainWindow.	Store.Glorp.DefinitionForListTool forSharedVariables: list.</body><body package="Store-UI">browseUnpackaged	PundleAccess moveUnpackagedToNullPackage.	Refactory.Browser.RefactoringBrowser openOnEnvironment:  (Refactory.Browser.PundleEnvironment new pundles: (List with: Registry nullPackage))</body><body package="Store-UI">bundleOwnershipManagement	DbRegistry 		doIfImageAdministrator: [Store.BundlePrivilegeGraph open]		label: (#manageBundleOwnership &lt;&lt; #store &gt;&gt; 'manage bundle ownership') asString</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Store-UI">checkConsistency	| strm warning |	strm := WriteStream on: String new.	Cursor wait showWhile: [Registry checkConsistencyOn: strm].	warning := strm contents.	Dialog warn: 			(warning size = 0 				ifTrue: 					[#EverythingChecksOutFine &lt;&lt; #store &gt;&gt; 'Everything checks out fine']				ifFalse: [warning])</body><body package="Store-UI">currentPackage	| pkg |	pkg := Registry currentPackage.	pkg := PackageChooser 				chooseOrAdd: (#CurrentPackage1s &lt;&lt; #store &gt;&gt; 'Current Package: &lt;1s&gt;' 						expandMacrosWith: pkg name)				withDefault: pkg				onCancelDo: [^self].	Registry currentPackage: pkg</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - store</category><body package="Store-UI">menuItemBrowseClassDefinitions	&lt;menuItemForCommand: #storeBrowseClassByName		icon: nil 		nameKey: #browseClassDefinitions 		enablement: #areAttached 		indication: nil 		menu: #(#menuBar #store #browseDefinitions) 		position: 90.04&gt;	^self browseClassDefinitions</body><body package="Store-UI">menuItemBrowseNameSpaceDefinitions	&lt;menuItemForCommand: #storeBrowseNamespaceByName		icon: nil		nameKey: #browseNameSpaceDefinitions		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.10&gt;	^self browseNameSpaceDefinitions</body><body package="Store-UI">menuItemBrowseSelector	&lt;menuItemForCommand: #storeBrowseSelectorByName		icon: nil		nameKey: #browseSelector		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.06&gt;	^self browseSelector</body><body package="Store-UI">menuItemBrowseStatic	&lt;menuItemForCommand: #storeBrowseSharedVariableByName		icon: nil		nameKey: #browseStatic		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.08&gt;	^self browseStatic</body><body package="Store-UI">menuItemBrowseUnpackaged	&lt;menuItemForCommand: #storeBrowseUnpackaged		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 20.07&gt;	^self browseUnpackaged</body><body package="Store-UI">menuItemBundleOwnershipManagement	&lt;menuItemForCommand: #storeManageBundleOwnership		icon: nil		nameKey: #bundleOwnershipManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.04&gt;	^self bundleOwnershipManagement</body><body package="Store-UI">menuItemCheckConsistency	&lt;menuItemForCommand: #storeCheckConsistency		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 90.99&gt;	^self checkConsistency</body><body package="Store-UI">menuItemCurrentPackage	&lt;menuItemForCommand: #storeSetCurrentPackage		icon: nil 		nameKey: #currentPackage		menu: #(#menuBar #store)		position: 50.05&gt;	^self currentPackage</body><body package="Store-UI">menuitemOpenGarbageCollectionDialog	&lt;menuItemForCommand: #storeCollectGarbage		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.99&gt;	^self openGarbageCollectionDialog</body><body package="Store-UI">menuItemOpenLoadedItems	&lt;menuItemForCommand: #storeOpenLoadedItems		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 20.01&gt;	^self openLoadedItems</body><body package="Store-UI">menuItemOpenNewMergeTool	&lt;menuItemForCommand: #storeOpenMergeTool		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store )		position: 20.17&gt;	Store.Glorp.MergeTool open.</body><body package="Store-UI">menuItemOpenPublishedItems	&lt;menuItemForCommand: #storeOpenPublishedItems		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 20.02&gt;	^self openPublishedItems</body><body package="Store-UI">menuItemOpenRecentPublishedItems	&lt;menuItemForCommand: #storeOpenRecentlyPublishedItems		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 20.05&gt;	^self openRecentPublishedItems</body><body package="Store-UI">menuItemOpenStoreForGlorpWorkbook	&lt;menuItemForCommand: #storeOpenWorkbook		nameKey: nil		menu: #(#menuBar #store)		position: 21.5&gt;	Glorp.UI.StoreWorkbook openRequestingDatabase.</body><body package="Store-UI">menuItemOpenUISettings	&lt;menuItemForCommand: #storeOpenSettings		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 50.01&gt;	SettingsManager 		openOrRaise: VisualWorksSettings 		selectPage: #(#store)</body><body package="Store-UI">menuItemPackageOwnershipManagement	&lt;menuItemForCommand: #storeManagePackageOwnership		icon: nil		nameKey: #packageOwnershipManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.05&gt;	^self packageOwnershipManagement</body><body package="Store-UI">menuItemRemoveDatabaseLinks	&lt;menuItemForCommand: #storeRemoveDatabaseLinks		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 90.10&gt;	^self removeDatabaseLinks</body><body package="Store-UI">menuItemRenameBundleInDatabase	&lt;menuItemForCommand: #storeRenameBundleInDatabase		icon: nil		nameKey: #renameBundle		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.10&gt;	^self renameBundleInDatabase</body><body package="Store-UI">menuItemRenamePackageInDatabase	&lt;menuItemForCommand: #storeRenamePackageInDatabase		icon: nil		nameKey: #renamePackage		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.11&gt;	^self renamePackageInDatabase</body><body package="Store-UI">menuItemSwitchDatabases	&lt;menuItemForCommand: #storeSwitchDatabases		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 90.08&gt;	self switchDatabases</body><body package="Store-UI">menuItemToggleStoreRepositoryConnection	"Dynamic menu label overrides static label in Command."	&lt;menuItemForCommand: #storeToggleConnection		label: #toggleStoreConnectionItemLabel		nameKey: nil		menu: #(#menuBar #store)		position: 10.5&gt;	self toggleStoreRepositoryConnection</body><body package="Store-UI">menuItemUserGroupManagement	&lt;menuItemForCommand: #storeManageUsersAndGroups		icon: nil		nameKey: #userGroupManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.03&gt;	self userGroupManagement</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>status registration</category><body package="Store-UI">miniRepositoryManager	&lt;tool: 20.1 width: #intrinsic&gt;	^SubCanvasView		client: Store.MiniRepositoryManager new		spec: Store.MiniRepositoryManager windowSpec</body><body package="Store-UI">miniRepositoryManagerGap	&lt;toolgap: 20 width: #fill&gt;</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - store</category><body package="Store-UI">noItemsOfType: aTypeString match: aString		Dialog warn: (#No1sMatching2s &lt;&lt; #store &gt;&gt; 'No &lt;1s&gt; matching &lt;2s&gt;' expandMacrosWith: aTypeString with: aString)</body><body package="Store-UI">notAttached	^self areAttached not</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Store-UI">openFilteredLoadedItems		DbRegistry doIfOnlineImage: [ Store.Glorp.PublishedPundleVersionsTool openOnAllLoadedPundlesWithFilter ]</body><body package="Store-UI">openFilteredPublishedItems	DbRegistry doIfOnlineImage: [ Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesWithFilter ]</body><body package="Store-UI">openFilteredRecentPublishedItems	DbRegistry doIfOnlineImage: [ Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItemsWithFilter ]</body><body package="Store-UI">openGarbageCollectionDialog	DbRegistry connectedProfile isNil		ifFalse: [Store.MarkPundlesForDeletionTool open]		ifTrue: 			[Dialog warn: #YouMustBeConnectedForGarbageCollection &lt;&lt; #store						&gt;&gt; 'You must be connected to a repository in order to open the garbage collection tool']</body><body package="Store-UI">openLoadedItems	DbRegistry doIfOnlineImage: 			[Store.Glorp.PublishedPundleVersionsTool openOnAllLoadedPundlesUnfiltered]</body><body package="Store-UI">openPublishedItems	DbRegistry doIfOnlineImage: [ Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundlesUnfiltered ]</body><body package="Store-UI">openRecentPublishedItems	DbRegistry doIfOnlineImage: [ Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItemsUnfiltered ]</body><body package="Store-UI">openUISettings	SettingsManager 		openOrRaise: VisualWorksSettings 		selectPage: #(#store)</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI">packageOwnershipManagement	DbRegistry 		doIfImageAdministrator: [Store.PrivilegeGraph open]		label: (#manageOwnership &lt;&lt; #store &gt;&gt; 'manage ownership') asString</body><body package="Store-UI">removeDatabaseLinks	Registry removeDatabaseLinks.</body><body package="Store-UI">renameBundleInDatabase	DbRegistry 		doIfImageAdministrator: 			[(Dialog confirm: (#RenamingABundleInTNttttttttContinue &lt;&lt; #store &gt;&gt; 'Renaming a bundle in the database will require all existing images to rename to match.&lt;nttttttt&gt;Continue?') expandMacros) ifFalse: [^self].			Store.Glorp.StoreBundle rename]		label: (#renameBundles &lt;&lt; #store &gt;&gt; 'rename bundles') asString</body><body package="Store-UI">renamePackageInDatabase	DbRegistry 		doIfImageAdministrator: 			[(Dialog confirm: (#RenamingAPackageInNttttttttContinue &lt;&lt; #store &gt;&gt; 'Renaming a package in the database will require all existing images to rename to match.&lt;nttttttt&gt;Continue?') expandMacros) ifFalse: [^self].			Store.Glorp.StorePackage rename]		label: (#renamePackages &lt;&lt; #store &gt;&gt; 'rename packages') asString</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - store</category><body package="Store-UI">selectNameFrom: aCollection chooseTitle: aString		^Dialog		choose: (#ChooseA1s &lt;&lt; #store &gt;&gt; 'Choose a &lt;1s&gt;' expandMacrosWith: aString)		fromList: aCollection		values: aCollection		lines: 12		cancel: nil.</body><body package="Store-UI">storeRepositoryLabelPart	| profileName |	profileName := (#Repository &lt;&lt; #store &gt;&gt; 'Repository') asString.	DbRegistry connectedProfile ifNotNil: 		[:profile | 		profile name ifNotNil: 			[:name | profileName := name]].	^profileName</body><body package="Store-UI">submenuAdministration	&lt;submenu: #(#_Administration #store '&amp;Administration')		nameKey: #administration		menu: #(#menuBar #store)		position: 90.01&gt;</body><body package="Store-UI">submenuBrowseDefinitions	&lt;submenu: #(#Browse_Definitions #store 'Browse &amp;Definitions')		nameKey: #browseDefinitions		menu: #(#menuBar #store)		position: 20.09&gt;</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI">switchDatabases	Registry switchDatabases.</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - store</category><body package="Store-UI">toggleStoreConnectionItemLabel	^DbRegistry isConnected 		ifTrue: 			[#DisconnectFrom1s &lt;&lt; #store &gt;&gt; 'Disconnect from &lt;1s&gt;' expandMacrosWith: self storeRepositoryLabelPart]		ifFalse: 			[(#ConnectToRepository &lt;&lt; #store &gt;&gt; 'Connect to Repository...') asString]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Store-UI">toggleStoreRepositoryConnection	DbRegistry isConnected		ifTrue: [DbRegistry disconnect]		ifFalse: [DbRegistry restoreConnection]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - store</category><body package="Store-UI">topMenuStore	&lt;vwPrivileged&gt;	&lt;submenu: #(#St_ore #menus 'St&amp;ore')		nameKey: #store		menu: #(#menuBar)		position: 50.0&gt;	^self</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI">userGroupManagement	DbRegistry 		doIfImageAdministrator: [Store.GroupGraph open]		label: (#manageUserGroups &lt;&lt; #store &gt;&gt; 'manage user/groups') asString</body></methods><initialize><class-id>Store.StorePublishDialog</class-id></initialize><initialize><class-id>Store.PublishPundleDialog</class-id></initialize><initialize><class-id>Store.PublishPackageDialog</class-id></initialize><initialize><class-id>Store.AbstractTool</class-id></initialize><initialize><class-id>Store.BlessingDialog</class-id></initialize><initialize><class-id>Store.DBAccess</class-id></initialize><initialize><class-id>Store.StoreSettings</class-id></initialize><initialize><class-id>Store.SQLBroker</class-id></initialize><initialize><class-id>Store.Glorp.StorePundle</class-id></initialize><initialize><class-id>Store.PrivilegeGraph</class-id></initialize><initialize><class-id>Store.PublishMergeDialog</class-id></initialize><initialize><class-id>Store.PublishPundlesDialog</class-id></initialize><initialize><class-id>Store.VersionGraph</class-id></initialize><initialize><class-id>Store.MiniRepositoryManager</class-id></initialize><initialize><class-id>Store.ElementView</class-id></initialize><initialize><class-id>Store.UnloadableDefinitionsViewer</class-id></initialize><initialize><class-id>Store.GroupGraph</class-id></initialize><initialize><class-id>Store.RecordVersionsViewer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>AbstractBrowserEnvironment</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label generalSearchStrings specificSearchStrings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-Environments</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SelectorNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ComponentChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType componentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>ComponentDefinitionChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionName definitionChange </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>BrowserDefinitionTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>DatabaseConnectionInformation</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle dbIdentifier dbTrace dbTimestamp dbVersion dbUsername changeSet versionString mergeInformation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DatabaseConnectionBundleInformation</name><environment>Store</environment><super>Store.DatabaseConnectionInformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentDescriptions fileDescriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ComponentDescription</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbIdentifier id componentName fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>MultiSelectionSequenceView</name><environment>UI</environment><super>UI.SequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections lastSelectionIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Workbook</name><environment>Tools</environment><super>Tools.AbstractWorkspace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pageHolder lastInstalledPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><class><name>GlorpError</name><environment>Glorp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>AlphaBlendedIcons</name><environment>Smalltalk</environment><super>Core.Assets</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Resources</package></attributes></class><class><name>PundleEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleNames packageNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>ConnectionProfile</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name driverClassName environment userName password originalName </inst-vars><class-inst-vars>lastUsedProfile </class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><class><name>RefactoryChange</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><class><name>SharedVariableProtocolNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>CodeComponentTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>BrowserOverviewTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserDocumentTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-SourceCodeUI</package></attributes></class><class><name>GeneralMethodDefinition</name><environment>Tools</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>InitializerDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameSpace key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>RBInitializerDefinition</name><environment>Refactory.Browser</environment><super>Tools.InitializerDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-Environments</package></attributes></class><class><name>Override</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenMethod</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>AbstractRefactoringBrowser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator toolbarMenuHolder findHolder findList toolsetsList dispatcher </inst-vars><class-inst-vars>showToolbarHolder </class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ClassAndMethodTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors methods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>DatabasePlatform</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types converters useBinding reservedWords functions characterEncoding </inst-vars><class-inst-vars>converterRepository </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>OraclePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>OverridenClass</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>NameSpaceItemTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type showProtocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>SourceFileFormat</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectProperties methodProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>XMLSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state docName cachedFile cachedParser </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Kernel-Support</category><attributes><package>XML-source</package></attributes></class><class><name>SQLite3Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Navigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment state dispatcher parts partsDictionary menus showOnlyFiltered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>AbstractBrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Navigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>AbstractChangeList</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value listName changes selectionIndex list filter removed filterList filterKey changeDict checkSystem fieldList selectionInList verticalConflicts differencesMode classesDistinct menuBar menus </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.MalformedSignal			</imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><class><name>ChangeSet</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectChanges objectRemoves componentChanges specialDoIts initializationOrder </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ChunkSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>AbstractNavigatorState</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundles objectNameReferences type protocols definitions properties nameSpaceName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>CodeWriter</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects classes extendedClasses extensionMethods exclusionset definedBindings scopeZones currentClass objectSpace analysisTracer symbolNum stringNum byteArrayNum floatNum doubleNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbObjectNum arbClassNum stream sourceStream sourceName hideOnLoad pointer currentKey properties prerequisites namedObjects newSourceKeys dateString timeString scratchDictionary codeComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpaceChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Model</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageModelSubModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DefNameSpaceModel</name><environment>Store</environment><super>Store.PackageModelSubModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package name environmentString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PostgresPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charactersThatNeedEscaping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>List</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents collection limit collectionSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>Access</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingPolicy mergePolicy packagePolicy versionPolicy publishPolicy ownershipPolicy prerequisitePolicy filePolicy tableSpacePolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>AbstractCodeModel</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator lockPolicy state isZoomed tabList statusPanel tools </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>PundleAccess</name><environment>Store</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages bundles modelDictionary currentPackage nullPackage containedItemsCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>CannotFindSession</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMisc</package></attributes></class><class><name>CodeReader</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream pointer format parcelName versionString dateString timeString numNamedObjects numClasses numExtensionMethods definedObjects definedBindings definedExternals classes classSelectors categories packageEnvironment packageUndeclared extensionMethods objectSpaceSize objectSpace symbolNum twoByteSymbolNum stringNum twoByteStringNum byteArrayNum floatNum doubleNum fixedNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbClassNum arbObjectNum messageSendIndices properties userStringsNum namedObjects namedObjectsNum postLoadObjects streamDir sourceFile hideSource importMaps overriddenExtensions versionSelectionBlock warningSuppressionBlock preReadBlock currentSuperclass mustRecompile lateOperations updates tempSourceFile compilationManager </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>Parcel</name><environment>Kernel</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects definedClasses definedBindings classSelectors namedObjects dirty loaded </inst-vars><class-inst-vars>parcels classParcelMap parcelFileInfoCache parcelFileDirectoryCache dependents </class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>Login</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>database username password connectString name schema secure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>XChangeSet</name><environment>Store</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>other properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>XMainChangeSet</name><environment>Store</environment><super>Store.XChangeSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>reorganizeSystem specialDoIts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>StoreError</name><environment>Store</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>CodeComponentPropertiesTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertiesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-CodeComponentUI</package></attributes></class><class><name>VariableBinding</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value usage category environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>RefactoryChangeManager</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>undo redo isPerformingRefactoring </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><class><name>OverridenNameSpace</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LDMIndentedListBuilder</name><environment>Lens</environment><super>Lens.LDMAbstractVisualBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bottom referenceConnections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>BindingReference</name><environment>Kernel</environment><super>Kernel.GeneralBindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseClass environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>AssemblerCodeStream</name><environment>Kernel</environment><super>Kernel.ByteCodeStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodClass needsFrame hybrid forContext method innerBlocks allowNewLiterals copiedVars segments owner outerStream </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Assembler</package></attributes></class><class><name>HintedCodeStream</name><environment>Kernel</environment><super>Kernel.AssemblerCodeStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>finalNumTemps forNonImmediate forNonSubclassable allSourceMaps blockIndex nextBlockIndex makeFullBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>DB2Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>NameSpaceOfClass</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>SelectorEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classSelectors metaClassSelectors initializers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>MethodDefinitionEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>NamedChangeSet</name><environment>Tools</environment><super>Kernel.ChangeSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeSetName lastChange lastFileOut lastFileOutName dirty comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ComponentStaticChange</name><environment>Kernel</environment><super>Kernel.ComponentSubDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>LDMElementView</name><environment>Lens</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents element hasIn hasOut povIcons firstPovIconX touchFlag selected label recycle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues supportsUnboundRowCount canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>ClassDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullClassName meta cachedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>LoggingTool</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><class><name>ClassEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceBehaviorNames classBehaviorNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>ConnectionDialog</name><environment>Database</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionProfileListHolder connectionProfileHolder databaseListHolder databaseHolder environmentListHolder environmentHolder userNameListHolder userNameHolder passwordHolder currentProfileHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><class><name>SelectorProtocolNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>DatumDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey nameSpaceName className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>LogicalFilename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>PortableFilename</name><environment>OS</environment><super>OS.LogicalFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>LensBrowsingToolModel</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>LDM-Framework</package></attributes></class><class><name>BundleDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>ClassChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodChanges metaMethodChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SharedVariableNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>ClassNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CodeComponentInspectPropertiesTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inspector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-CodeComponentUI</package></attributes></class><class><name>ComponentSelectorChange</name><environment>Kernel</environment><super>Kernel.ComponentSubDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>DBProfilePropertiesDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileHolder acceptTrigger databaseListHolder databaseHolder environmentHolder userNameHolder passwordHolder nameHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-VW</category><attributes><package>Database</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>DefClassModel</name><environment>Store</environment><super>Store.PackageModelSubModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package fullClassSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SequenceHoverAssistant</name><environment>UI</environment><super>UI.HoverHelpAssistant</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Interface-Hoverhelp</package></attributes></class><class><name>ClassBuilder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>records </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>FileBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName list myPattern selectionState autoRead lastModified currentFileEncoding defaultEncodings patternAspect menuBar showFullPath isDirty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>MethodDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol fullClassName meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>ComponentLoadedChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>GenericSettingDescriptor</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id position definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>CodeComponentInspectorField</name><environment>Refactory.Browser</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-CodeComponentUI</package></attributes></class><class><name>PartListAbstractInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driver segmentListHolder fieldListHolder dragController undoHistory documentHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>MethodInstallationRecord</name><environment>Tools</environment><super>Tools.MethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><class><name>FirebirdPlatform</name><environment>Glorp</environment><super>Glorp.OcelotPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>AccessPlatform</name><environment>Glorp</environment><super>Glorp.SQLServerPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>BehaviorBuilderRecord</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instVarNames instVarMap newClass oldSuperclass superclass targetClass archive newSubclassList oldSubclassList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Label</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text attributes width offset needsScan fontPolicy verticalAlignment forceBold </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>PundleNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.HierarchyPundleNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>DatabaseAccessor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection currentLogin logging logger logOnly reusePreparedStatements deniedCommands mutex dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ProtocolEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass protocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>SourceNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>BrowserCommentTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>LogEnvironment</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debugStream debugCategories debugClasses trace logFileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><class><name>PackageDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>Panel</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layoutAlgorithm isInUpdate cachedPreferredExtent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>PropertyChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>NameSpaceDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class></st-source>