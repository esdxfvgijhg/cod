<?xml version="1.0"?><st-source><!-- Name: DLLCCNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This is the C Programmer's Object Kit, also known as DLL and C Connect. It contains the capability to write C declarations as a pragma inside Smalltalk methods of a subclass of ExternalInterface.See the DLL and C Connect User's Guide for more information.DbIdentifier: bear73DbTrace: 498841DbUsername: trobinsonDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'AT Parser Compiler' ''))PackageName: DLLCCParcel: #('DLLCC')ParcelName: DLLCCPrerequisiteDescriptions: #(#(#name 'AT Parser Compiler' #applicability #store))PrintStringCache: (8.3 - 2,trobinson)Version: 8.3 - 2Pre-Unload Block: 	[:pkg| CScanner preUnloadFor: pkg ]Date: 1:29:15 PM March 3, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (mar17.1) of March 3, 2017 on March 3, 2017 at 1:29:15 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CScanner</name><environment>External</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestor failBlock reservedWords sourceUsesCRLF </inst-vars><class-inst-vars>typeTable reservedWords methodInfo </class-inst-vars><imports></imports><category>DLLCC-CParsing</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>External.CScanner</class-id><body>Copyright © 1993-1999 ObjectShare, Inc., All Rights Reserved.The class CScanner break an input stream into tokens suitable for use by C language parsers.  It puts each token found into token and its type (a Symbol) into tokenType.Note that the mark (start of current token) and prevEnd (end of previous token) are 1-origin character indices (in a text or string object), not a 0-origin stream position.  While this may cause some confusion, it seems preferable to the alternative.Instance Variables:	requestor			&lt;CompilerErrorHandler | nil&gt; object from which parsing was invoked.  If not nil, this object will be sent #notify: prior to evaluating the failBlock	failBlock				&lt;BlockContext&gt; to be evaluated in case of parse errors	reservedWords		&lt;Dictionary | false&gt;	sourceUsesCRLF	&lt;Boolean&gt; is true if the receiver is scanning a stream that uses CRLF line-end conventions, otherwise false.Class Instance Variables	typeTable		&lt;ScannerTable | nil&gt; maps characters to Symbols, which identify the type of token the character may introduce	reservedWords	&lt;Dictionary | false | nil&gt; a collection of all the reserved words found in the grammar expressions	methodInfo		&lt;(Dictionary keys: Symbol values: (Array new: 3)) | nil&gt;</body></comment><class><name>CParser</name><environment>External</environment><super>External.CScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>declarations stack backupStack </inst-vars><class-inst-vars>cachedParser </class-inst-vars><imports></imports><category>DLLCC-CParsing</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>External.CParser</class-id><body>The abstract class CParser is an abstract class for C preprocessing and parsing.  CParser contains a dictionary of symbols which define the current parsing environment.  A preprocessor uses this environment to store #define symbols, while a parser uses this environment to declaration names.  Please consult the subclass comments for further details on C preprocessing and parsing.  You should not create direct instances of CParser.Subclasses must implement the following messages:	class protocol		class accessing			preprocessorClassInstance Variables:	declarations		&lt;ExternalDictionary&gt; used to contain environment symbols (accumulated dynamically)	stack			&lt;OrderedCollection&gt;  used by generated parsers to hold partially completed parse trees; see the documentation in ParserCompiler class for details	backupStack	&lt;OrderedCollection&gt;  holds backup information that is needed whenever the parser must abandon the current grammar rule and return to an alternative oneClass Instance Variables:	cachedParser &lt;CParser | nil&gt; a cached parser so that initialization is faster.</body></comment><class><name>CExpressionParser</name><environment>External</environment><super>External.CParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-CParsing</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>External.CExpressionParser</class-id><body>The class CExpressionParser is used to parse C language expressions.  The current scope of expression evaluation is constrained to expressions that evaluate to constants (i.e. Numbers and Strings).  This parser should be expanded to include general C language expressions.  Uses of this class are for run-time debuggers that may wish to evaluate an expression in the context of a particular environment.  For example: '*(int *) &amp;someVariable' would evaluate to the integer pointed to by someVariable (after coercion).</body></comment><class><name>CDeclarationParser</name><environment>External</environment><super>External.CExpressionParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-CParsing</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>External.CDeclarationParser</class-id><body>The class CDeclarationParser provides the ability to parse a token sequence (usually generated by the CPreprocessor class) into a set of C language declaration objects (typically instances of CType).  These objects are contained in the parser's declaration dictionary, which may be retrieved after the parse completes.  This class implements the full C language syntax for variable and type declarations.  It does not support parsing arbitrary C language source code (we leave this to the yet unwritten CStatementParser class).</body></comment><class><name>ExtendedCompiler</name><environment>Kernel</environment><super>Kernel.Compiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>external </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Parsing</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>Kernel.ExtendedCompiler</class-id><body>The class ExtendedCompiler is used in conjunction with ExtendedParser.  Together they implement the extended syntax for external declarations ('&lt;C: ...&gt;').  ExtendedCompiler is responsible for constructing the proper CompiledMethod once the ExtendedParser has parsed the declaration syntax.Instance Variables:	external	&lt;ExternalObject | CType | CMacroDefinition|nil&gt; The external that is being parsed, or nil if there is none.</body></comment><class><name>CPreprocessor</name><environment>External</environment><super>External.CExpressionParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>includeDirectories includeStack directiveTakenStack saveReservedWords skipLevel ignoreSkipLevel inMacroScan lastDefine outputStream saveDefines assertDefines continuationCount dontStepPastEnd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-CParsing</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>External.CPreprocessor</class-id><body>The class CPreprocessor is used to preprocess an input string or stream into a sequence of C language tokens.  All C preprocessor directives are executed.  The following grammar for the preprocessor simply summarizes the control line structure.  It cannot be used for mechanized parsing and hence the difference between what is stated here and the implementation within this class:	&lt;controlLine&gt; ::=		#if &lt;identifier&gt; tokenSequence		#define &lt;identifier&gt; $( &lt;identifier&gt;, ..., &lt;identifier&gt; $) &lt;tokenSequence&gt;		#undef &lt;identifier&gt;		#include $&lt; &lt;filename&gt; $&gt;		#include $" &lt;filename&gt; $"		#include &lt;tokenSequence&gt;	*Not supported*		#line &lt;constant&gt; $" &lt;filename&gt; $"	*Parsed but not supported*		#line &lt;constant&gt;	*Parsed but not supported*		#error &lt;tokenSequence&gt;		#pragma &lt;tokenSequence&gt;	*Parsed but not supported*		#		#assert &lt;predicate&gt;(&lt;tokenSequence&gt;)		#assert &lt;predicate&gt;		#unassert &lt;predicate&gt;(&lt;tokenSequence&gt;)		#unassert &lt;predicate&gt;		&lt;preprocessorConditional&gt;	&lt;preprocessorConditional&gt; ::=		&lt;ifLine&gt; &lt;text&gt; &lt;elifParts&gt; [&lt;elsePart&gt;] # endif	&lt;ifLine&gt; ::=		# if &lt;constantExpression&gt;		# ifdef &lt;identifier&gt;		# ifndef &lt;identifier&gt;	&lt;elifParts&gt; ::=		&lt;elifLine&gt; &lt;text&gt;		[&lt;elifParts&gt;]	&lt;elifLine&gt; ::=		# elif &lt;constantExpression&gt;	&lt;elsePart&gt; ::=		&lt;elseLine&gt; &lt;text&gt;	&lt;elseLine&gt; ::=		# elseNote that the current implementation uses an include stack to save state when encountered #include directives.  This stack should really contain instances of this class rather than stream information.  This may change in future implementations.Instance Variables:	"The following are set at instance initialization."	includeDirectories	&lt;SequenceableCollection of: String&gt;  directories for #include searching	"The following are changed dynamically."	includeStack		&lt;OrderedCollection of: Array&gt;  save state for #include	directiveTakenStack	&lt;OrderedCollection&gt; A collection of Boolean indicating if directive conditionals evaluated to true or not.	saveReservedWords	&lt;Dictionary&gt;  save reserved words / macros while processing a directive	skipLevel			&lt;Integer&gt;  depth of nesting in false conditionals	ignoreSkipLevel		&lt;Integer&gt;  skip over tokens while skipLevel &gt; ignoreSkipLevel	inMacroScan		&lt;Boolean&gt;	true if the parser is currently scanning a macro's arguments.	lastDefine			&lt;CMacroDefinition&gt;	the last #define processed.	dontStepPastEnd	&lt;Boolean&gt;	is true when the look-ahead machinery should not step past the end of a stream and re-install the previous stream.  This is used when streams are stacked during preprocessing.	outputStream	&lt;Stream&gt;	the stream where all preprocessor output is to be placed.	saveDefines	&lt;Dictionary&gt; whenever a #define overrides a delcaration, the declaration is placed here so it can be reinstated when the #define is #undef'ined.	assertDefines	&lt;Dictionary&gt; the repository for all assertions declared using #assert.	continuationCount	&lt;Integer&gt; a count of the number of continuation character ($\) encountered since the last time the variable was set.  This is typically used to recalculate character counts on platforms that use CRLF line-end conventions.We define the reservedWords instance variable to hold a Dictionary in which the keys are the names of reserved words or macros (the latter overriding the former), and the value is true for a reserved word, or the definition for a macro.Class Variables:	ATypeTable	&lt;Array|nil&gt;  an alternate typeTable for parsing macro arguments	DTypeTable	&lt;Array|nil&gt;  an alternate typeTable for parsing directives</body></comment><class><name>ExternalInterfaceTypeDefinitionCompiled</name><environment>Kernel</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Interface</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>Kernel.ExternalInterfaceTypeDefinitionCompiled</class-id><body>This notification is raised by the ExtendedCompiler when, after pragma parsing is complete, a type definition is detected.  The point of this notification is so that the compiling class can infer the need to recompile its methods after a type definition is compiled.</body></comment><class><name>ExtendedParser</name><environment>Kernel</environment><super>Kernel.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>externals external </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Parsing</category><attributes><package>DLLCC</package></attributes></class><comment><class-id>Kernel.ExtendedParser</class-id><body>I specialize in dealing with &lt;C:..&gt; constructs and, in the future, possibly with similar constructs for other external languages. I invoke an external language parser to parse what's inside &lt;C: .. &gt;.  When the external language parser is missing, as in a runtime environment, I skip the &lt;C:..&gt; construct or generate an error message, whichever is more appropriate.Instance Variables:	externals	&lt;ExternalDictionary&gt; the dictionary of externals owned by the parser's class.	external	&lt;ExternalObject | CType | CMacroDefinition | Association &gt; the external that was generated during the parse.</body></comment><shared-variable><name>DTypeTable</name><environment>External.CPreprocessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC</package></attributes></shared-variable><shared-variable><name>ATypeTable</name><environment>External.CPreprocessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC</package></attributes></shared-variable><methods><class-id>External.CScanner</class-id> <category>private-scanning</category><body package="DLLCC">scanChar	"Scan a C character, possibly an escape.  Accumulate the decoded character(s)."	| theChar code |	theChar := hereChar.	self step.	"True if there are two backslashes, iff hereChar is a backslash, or if neither character is a backslash."	(theChar ~~ $\ or: [hereChar == $\])		ifTrue:			[buffer nextPut: theChar.			"If we have two adjacent backslashes, then write one to the buffer			and advance the stream." 			theChar == $\				ifTrue:[self step].			^true].	hereChar isDigit ifTrue:		[code := hereChar digitValue.		self step.		hereChar isDigit ifTrue:			[code := code * 8 + hereChar digitValue.			self step.			hereChar isDigit ifTrue:				[code := code * 8 + hereChar digitValue.				self step]].		buffer nextPutAll: ((ByteArray with: code) asStringEncoding: #default).		^true].	hereChar = $x ifTrue:		[self step.		code := hereChar digitValue.		self step.		hereChar = $'			ifTrue: [buffer nextPutAll: ((ByteArray with: code) asStringEncoding: #default). ^true]			ifFalse: [code := code * 16 + hereChar digitValue].		buffer nextPutAll: ((ByteArray with: code) asStringEncoding: #default).		self step.		^true].	(code := 'ntvbrfa\?''"' indexOf: hereChar) &gt; 0 ifTrue:		[buffer nextPut: (#(8r12 8r11 8r13 8r10 8r15 8r14 8r07 $\ $? $' $") at: code) asCharacter.		self step.		^true].	^false</body><body package="DLLCC">scanToken	"Scan the input stream for a single token."	| skipped |	[skipped := 0.	[hereChar == nil		ifTrue:  "end of input"			["skipLevel &gt; 0				ifTrue: [self offEnd: 'Unterminated conditional']."			prevEnd := source position.			mark := prevEnd + 1.			tokenType := #doIt.			^token := nil].	(tokenType := typeTable at: hereChar asInteger) == #xDelimiter]		whileTrue:  "Skip delimiters fast, there almost always is one."			[skipped := skipped + 1.			"open code step for speed"			[hereChar := source next.			hereChar == $\ and: [source peekFor: Character cr]]				whileTrue: [skipped := skipped + 1]].	mark := source position.	"The following is a hack for platforms that support CRLF - the mark should be adjusted."	(hereChar == Character cr and: [sourceUsesCRLF]) ifTrue: [mark := mark - 1].	prevEnd := mark - skipped - 1.	tokenType isSymbol		ifTrue:  "single-character token"			[token := hereChar.			self step]		ifFalse:			[buffer reset.			[tokenType isSymbol]				whileFalse:					[buffer nextPut: hereChar.					self step.					tokenType := tokenType value at: hereChar ifAbsent: [tokenType key]].			(tokenType at: 1) == $x				ifTrue: [self perform: tokenType]				ifFalse: [token := buffer contents]].	tokenType isNil]		whileTrue.  "loop until we have a real token"	^token</body><body package="DLLCC">sourcePosition	"return the source position of here"	^mark - 1</body><body package="DLLCC">sourcePosition: pos	"set the source position of here"	source position: pos.	self step.  "fill character buffer"	self scanToken.  "fill scanner buffer"</body><body package="DLLCC">step	"Override the super class implementation handle line-splicing with \."	| aChar |	[aChar := hereChar.	hereChar := source next.	hereChar == $\ and: [source peekFor: Character cr]]		whileTrue.	^aChar</body><body package="DLLCC">xCR	"We just saw a CR - skip any whitespace."	self skipWhitespace.	tokenType := nil.	^self</body><body package="DLLCC">xCharacter	"Parse a character constant (possibly a multi-character constant).  Answer the receiver.  A side effect is to set the token to either a Character (for a character constant) or an Integer (for a mulit-character constant) and the tokenType to #character or #number."	buffer reset.	[self scanChar.	hereChar = $'] whileFalse.	self step.	token := self numberFromString: buffer contents.	tokenType := #number</body><body package="DLLCC">xComment	"Skip a (non-nested) C comment.  hereChar is the initial *.  The initial / is in the buffer."	| prev |	hereChar := nil.	[prev := hereChar.	self step.	hereChar == nil ifTrue: [^self expected: '*/'].	prev == $* and: [hereChar == $/]]		whileFalse.	self step.	tokenType := nil</body><body package="DLLCC">xComment1	"Skip a one-line C comment.  hereChar is the second /.  The initial / is in the buffer."	| cr |	cr := Character cr.	[hereChar == nil or: [(source peek == cr) or: [hereChar := source next. false]]] whileFalse.	hereChar == nil ifFalse: [hereChar := source next].	tokenType := nil</body><body package="DLLCC">xHexadecimal	"Parse a hexadecimal constant.  If the constant contains leading zeros, answer a LargePositiveInteger containing the leading zeros.  Although this integer may be compressed into a SmallInteger, we use it as a container for initializers where the leading zeros are important."	token := ''.	[hereChar := source next.	hereChar notNil and: [hereChar digitValue between: 0 and: 15]]		whileTrue: [token := token copyWith: hereChar].	hereChar == nil		ifFalse:			[hereChar asUppercase == $U				ifTrue:					[hereChar := source next.					(hereChar notNil and: [hereChar asUppercase == $L])						ifTrue: [hereChar := source next]]				ifFalse:					[hereChar asUppercase == $L						ifTrue:							[hereChar := source next.							(hereChar notNil and: [hereChar asUppercase == $U])								ifTrue: [hereChar := source next]]]].	token := self hexNumberFromString: token.	tokenType := #number.	hereChar == nil ifTrue: [self step]</body><body package="DLLCC">xInteger	"Handle an integer constant.  We don't distinguish unsigned or long yet, but for correct expression evaluation, we will have to."	| tokenSize |	token := buffer contents.	(token = '0' and: [hereChar == $x]) ifTrue: [^self xHexadecimal].	(token first == $0 and: [hereChar ~~ $.]) ifTrue: [^self xOctal].	tokenSize := token size.	(token at: tokenSize) asUppercase == $U		ifTrue:			[tokenSize := tokenSize - 1.			(token at: tokenSize) asUppercase == $L ifTrue: [tokenSize := tokenSize - 1]]		ifFalse:			[(token at: tokenSize) asUppercase == $L ifTrue: [tokenSize := tokenSize - 1].			(token at: tokenSize) asUppercase == $U ifTrue: [tokenSize := tokenSize - 1]].	token := token copyFrom: 1 to: tokenSize.	(hereChar notNil and: ['.eEdD' includes: hereChar])		ifTrue: [token := self xLimitedPrecisionReal: token]		ifFalse: [token := Integer readFrom: token readStream].	tokenType := #number</body><body package="DLLCC">xLetter	"form a word, keyword, or reserved word"	| type char |	buffer reset.	buffer nextPut: hereChar.	[char := source next.	char notNil and:		[type := typeTable at: char asInteger.		type == #xLetter or: [type == #xDigit]]]		whileTrue:			[buffer nextPut: char].	tokenType := #word.	hereChar := char.	token := buffer contents.	reservedWords == false ifFalse:		[(reservedWords includes: token)			ifTrue: [tokenType := token asSymbol]]</body><body package="DLLCC">xLimitedPrecisionReal: prefixToken	"Answer a token that represents a limited precision real number (float or double).	 The integral part of the number is represented by the argument.  If the parse	 fails or results in an invalid real, the argument is answered."	| realToken prevChar |	realToken := prefixToken.	(hereChar = $. or: [realToken isEmpty]) ifTrue:		[| fractionExists |		fractionExists := false.		hereChar = $.			ifTrue:				[prevChar := hereChar.				realToken := realToken copyWith: hereChar.				hereChar := source next]			ifFalse: [realToken := '0.' copy].		[hereChar notNil and: [hereChar digitValue between: 0 and: 9]] whileTrue:			[fractionExists := true.			realToken := realToken copyWith: hereChar.			hereChar := source next].		fractionExists ifFalse: [realToken := realToken copyWith: $0]].	(hereChar notNil and: ['eEdD' includes: hereChar]) ifTrue:		[realToken := realToken copyWith: $e.		prevChar := hereChar.		hereChar := source next.		(hereChar notNil		 and: [('+-' includes: hereChar)		 and: [(hereChar ~~ $+) or: [('dD' includes: prevChar) not]]]) ifTrue:			[hereChar = $+ ifFalse: [realToken := realToken copyWith: hereChar].			hereChar := source next].		[hereChar notNil and: [hereChar digitValue between: 0 and: 9]] whileTrue:			[realToken := realToken copyWith: hereChar.			hereChar := source next]].	(hereChar notNil	and: ['fF' includes: hereChar])		ifTrue:			[hereChar := source next.			^[(Float readFrom: realToken readStream) asFloat]				on: ArithmeticValue rangeErrorSignal				do: [:ex1 |					ex1 return:						([(Double readFrom: realToken readStream) asDouble]							on: ArithmeticValue rangeErrorSignal							do: [:ex2 | ex2 return: prefixToken])]]		ifFalse:			[(hereChar notNil and: ['lL' includes: hereChar]) ifTrue: [hereChar := source next]].	^[(Double readFrom: realToken readStream) asDouble]		on: ArithmeticValue rangeErrorSignal		do: [:ex | ex return: prefixToken]</body><body package="DLLCC">xOctal	"Handle an octal constant.  We don't handle unsigned and long constants, but we will have to for correct expression evaluation."	| tokenSize |	tokenSize := token size.	(token at: tokenSize) asUppercase == $U		ifTrue:			[tokenSize := tokenSize - 1.			(token at: tokenSize) asUppercase == $L ifTrue: [tokenSize := tokenSize - 1]]		ifFalse:			[(token at: tokenSize) asUppercase == $L ifTrue: [tokenSize := tokenSize - 1].			(token at: tokenSize) asUppercase == $U ifTrue: [tokenSize := tokenSize - 1]].	token :=token copyFrom: 1 to: tokenSize.	token do: [:aChar |		(aChar digitValue between: 0 and: 7) ifFalse: [^self expected: (#octalConstant &lt;&lt; #dllcc &gt;&gt; 'octal constant')]].	token := Integer readFrom: token readStream radix: 8.	tokenType := #number</body><body package="DLLCC">xOperator	"Make an operator into a symbol."	token := buffer contents asSymbol.	(token == #/ and: [hereChar == $=]) ifTrue: [self step. token := #/=].	token == #'||' ifTrue: [tokenType := #'||'] ifFalse: [	token == #| ifTrue: [tokenType := #verticalBar] ifFalse: [	token == #'^' ifTrue: [tokenType := #upArrow] ifFalse: [	tokenType := #binary]]].  "not really binary, but this is what the ParserGenerator expects"</body><body package="DLLCC">xPeriod	"A period ($.) was encountered in the input stream.  Answer the correct token, which may be a #number (limited precision reals may start with a period with no 0 prefix), or a #period."	(hereChar notNil and: [hereChar digitValue between: 0 and: 9])		ifTrue:			[token := self xLimitedPrecisionReal: ''.			^tokenType := #number].	token := $..	^tokenType := #period</body><body package="DLLCC">xString	"Handle a string constant."	[[hereChar == $"]		whileFalse:			[hereChar == nil ifTrue: [self notify: (#UnmatchedQuote &lt;&lt; #dllcc &gt;&gt; 'Unmatched "').  ^self scanToken].			self scanChar].	self step.	self skipWhitespace.	hereChar == $" and: [self step. true]]		whileTrue.	buffer nextPut: $".	token := buffer contents.	"scanChar converts escaped backslashes (\\) to a single backslash.	 Within the string they must be restored to double backslashes."		(token includes: $\) ifTrue:		[token := token copyReplaceAll: '\' with: '\\'].	tokenType := #string</body><body package="DLLCC">xWord	"Handle a word."	| tokenSymbolOrNil |	token := buffer contents.	((tokenSymbolOrNil := Symbol findInterned: token) ~~ nil	and: [(reservedWords at: tokenSymbolOrNil ifAbsent: [nil]) == true])		ifTrue: [tokenType := tokenSymbolOrNil]		ifFalse: [tokenType := #word]</body></methods><methods><class-id>External.CScanner</class-id> <category>private</category><body package="DLLCC">fastInit	"Provide a fast initialization feature.  The default is to do nothing; clients should override."	sourceUsesCRLF := false.	^self</body><body package="DLLCC">hexNumberFromString: aString	"Answer an Integer number whose bytes consists of the character encodings found in the argument.  The first character in the argument is the most significant byte of the answered number.  If the hexadecimal constant contains leading zeros remember them also by creating an uncompressed LargePositiveInteger object to use as a container."	| hexNumber  byteIndex stringSize |	stringSize := aString size.	byteIndex := 0.	hexNumber := LargePositiveInteger basicNew: stringSize + 1 // 2.	stringSize to: 1 by: -2 do:		[:i | | byte |		byte := (aString at: i) digitValue.		i &gt; 1 ifTrue: [byte := byte + ((aString at: i - 1) digitValue bitShift: 4)].		hexNumber basicAt: (byteIndex := byteIndex + 1) put: byte].	^hexNumber</body><body package="DLLCC">init: streamOrString notifying: req failBlock: aBlock	"Initialize the scanner.  Return the initial position	in the source stream, so that we can back up	over an initial scan if necessary."	| sourceStream startPos |	(streamOrString isKindOf: Stream)		ifTrue:	[startPos := streamOrString position.				sourceStream := streamOrString]		ifFalse:	[startPos := 1.				sourceStream := streamOrString asString readStream].	requestor := req.	failBlock := aBlock.	self scan: sourceStream.	^startPos</body><body package="DLLCC">numberFromString: aString	"Answer an Integer number whose bytes consists of the character encodings found in the argument.  The first character in the argument is the most significant byte of the answered number."	| multiChar stringSize bytes |	bytes := aString asByteArrayEncoding: #default.	stringSize := bytes size.	multiChar := Integer new: stringSize neg: false.	1 to: stringSize do:		[:i | multiChar digitAt: stringSize - i + 1 put: (bytes at: i)].	^multiChar compressed</body><body package="DLLCC">printHexNumber: aLargePositiveInteger on: aStream	"Print a representation of the the argument, aLargePositiveInteger, onto the argument aStream.  If the number's most significant digit is zero, print a hexadecimal representation of the receiver, including any leading zeros, on aStream.  This method will ensure hexadecimal constants with leading zeros are maintained."	| digitLength |	digitLength := aLargePositiveInteger digitLength.	(aLargePositiveInteger digitAt: digitLength) isZero		ifTrue:			[| hexCodes |			hexCodes := '0123456789ABCDEF'.			aStream nextPutAll: '0x'.			"'aLargePositiveInteger printOn: aStream radix: 16' doesn't quite do the right thing."			aLargePositiveInteger digitLength to: 1 by: -1 do: [:i | | byte |				byte := aLargePositiveInteger digitAt: i.				aStream					nextPut: (hexCodes at: (byte bitShift: -4) + 1);					nextPut: (hexCodes at: (byte bitAnd: 16rf) + 1)]]		ifFalse: [aLargePositiveInteger printOn: aStream]</body><body package="DLLCC">skipWhitespace	"Skip any whitespace."	[hereChar notNil and: [(tokenType := typeTable at: hereChar asInteger) == #xDelimiter]]		whileTrue: [self step]</body><body package="DLLCC">source: sourceStream	"Set the current scanner source stream to the argument."	source := sourceStream.	sourceUsesCRLF := self streamUsesCRLF: sourceStream</body><body package="DLLCC">tokensFrom: string	"Answer a collection of tokens scanned from the argument."	| result | 	self on: (ReadStream on: string).	result := OrderedCollection new.	[hereChar = nil]		whileFalse:			[self scanToken.			result addLast: (Array with: tokenType with: token)].	^result</body></methods><methods><class-id>External.CScanner</class-id> <category>accessing</category><body package="DLLCC">endOfLastToken	"Answer the position of end of last expression parsed."	^prevEnd</body><body package="DLLCC">requestor	^requestor</body><body package="DLLCC">requestor: aRequestor	requestor := aRequestor</body><body package="DLLCC">resetSourceToLastToken	source position: self endOfLastToken.</body><body package="DLLCC">streamUsesCRLF: aStream	"Answer true if the argument has a CRLF line-end convention, otherwise answer false."	^(aStream respondsTo: #lineEndConvention) and: [			aStream lineEndConvention = (IOConstants at: #LineEndCRLF)]</body></methods><methods><class-id>External.CScanner</class-id> <category>initialize-release</category><body package="DLLCC">initScanner	super initScanner.	typeTable := self class typeTable.	reservedWords := self class reservedWords copy.	self fastInit</body><body package="DLLCC">on: inputStream 	"Redefine this to preload a CR."	self source: inputStream.	hereChar := Character cr.	prevEnd := 0</body></methods><methods><class-id>External.CScanner</class-id> <category>error handling</category><body package="DLLCC">abort	| exitBlock |	exitBlock := failBlock.	failBlock := nil.	^exitBlock value</body><body package="DLLCC">expected: aString 	"Notify a problem at token 'here'"	^self notify: (#syntaxErrorHere &lt;&lt; #dllcc &gt;&gt; 'syntax error -&gt;') at: mark</body><body package="DLLCC">notify: aString 	"Notify problem at token before 'here'"	^self notify: aString at: source position</body><body package="DLLCC">notify: stringOrUserMessage at: location	"A syntax error has occurred -- display string at location in the current stream."	|string|	string := stringOrUserMessage asString.	requestor == nil		ifTrue:			[SyntaxError				errorInClass: nil				withCode: 					((source reset; contents)						copyReplaceFrom: location						to: location - 1						with: string)				errorString: string]		ifFalse: [requestor syntaxError: string at: location].	self abort</body><body package="DLLCC">offEnd: aString 	" notify a problem beyond 'here' (in lookAhead token).  Don't be offEnded!"	^ self notify: aString at: mark</body><body package="DLLCC">unexpectedError	self notify: #syntaxError &lt;&lt; #dllcc &gt;&gt; 'syntax error'</body></methods><methods><class-id>External.CScanner class</class-id> <category>private-parser compiler</category><body package="DLLCC">abandonParserCompiler	"CScanner abandonParserCompiler"	| parserCompilerCategory |	parserCompilerCategory := #'private-parser compiler'.	self withAllSubclasses do: [:aClass |		(aClass compilerClass respondsTo: #isGrammarExpression:) ifTrue: [			aClass selectors do: [:sel | | src |				(aClass compilerClass isGrammarExpression:					(src := (aClass compiledMethodAt: sel) getSource))					ifTrue:						[| tree |						tree := aClass compilerClass new parse: src in: aClass notifying: nil.						tree := tree node.						src := tree printString.						aClass							compile: src							classified: (aClass organization categoryOfElement: sel)]]]].	self class compile: self generateComputeBasicTablesMethod			classified: #private.	self withAllSubclasses do: [:aClass |		(aClass class organization listAtCategoryNamed: parserCompilerCategory) do: [:sel |			aClass class removeSelector: sel].		aClass class organization removeCategory: parserCompilerCategory].	methodInfo := nil.	self computeTables.</body><body package="DLLCC">computeBasicTables	"Compute the character type, reserved word tables, and	keyword flag from the information associated with each method."	| words types info typeInfo |	words := Set new.	types := TypeTable "copy".	self methodInfo keys do:		[:selector |		"(methodDict includesKey: selector)			ifTrue:				["info := methodInfo at: selector.				words addAll: (info at: 1).				typeInfo := info at: 2.				typeInfo isEmpty ifFalse:					[types == TypeTable ifTrue:						[types := types copy].					typeInfo associationsDo:						[:char |						types at: char key asInteger							put: char value]]"]			ifFalse:				[methodInfo removeKey: selector]"].	reservedWords := words isEmpty ifTrue: [false] ifFalse: [words].	typeTable := types.</body><body package="DLLCC">generateComputeBasicTablesMethod	"CScanner generateComputeBasicTablesMethod"	| str |	self computeBasicTables.	str := String new writeStream.	str nextPutAll: 'computeBasicTables'.	str crtab; nextPutAll: '"Compute the character type, reserved word tables, and'.	str crtab; nextPutAll: 'keyword flag from the information associated with each method."'.	str cr;		crtab;		nextPutAll: 'reservedWords := ';		store: reservedWords asArray;		nextPutAll: '.'.	str crtab; nextPutAll: 'typeTable := TypeTable copy.'.	1 to: 255 do:		[:i |		(typeTable at: i) = (TypeTable at: i)			ifFalse:	[str crtab;						nextPutAll: 'typeTable at: ';						print: i;						nextPutAll: ' put: ';						store: (typeTable at: i);						nextPutAll: '.']].	^str contents</body><body package="DLLCC">methodInfo	methodInfo == nil ifTrue: [methodInfo := Dictionary new].	reservedWords := typeTable := nil.  "Clear cache"	^methodInfo</body><body package="DLLCC">methodInfo: aDictionary	methodInfo := aDictionary</body></methods><methods><class-id>External.CScanner class</class-id> <category>binary storage</category><body package="DLLCC">binaryInitializationMessagesFor: sourceMode	"Answer a list of message sends used to initialize the receiver."	| list |	list := super binaryInitializationMessagesFor: sourceMode.	"We make a direct reference to CScanner to avoid subclasses also initializing methodInfo."	name == #CScanner ifTrue:		[list add: (MessageSend					receiver: self					selector: #methodInfo:					argument: self methodInfo)].	^list</body><body package="DLLCC">codeWriterTraceOnto: tracer	super codeWriterTraceOnto: tracer.	tracer trace: typeTable.	tracer trace: reservedWords.	tracer trace: methodInfo.</body><body package="DLLCC">readInitializationObjectsOn: aBinaryCodeReader	super readInitializationObjectsOn: aBinaryCodeReader.	typeTable := aBinaryCodeReader readObject.	reservedWords := aBinaryCodeReader readObject.	methodInfo := aBinaryCodeReader readObject.</body><body package="DLLCC">storeInitializationObjectsOn: aBinaryCodeWriter	aBinaryCodeWriter trace: typeTable.	aBinaryCodeWriter trace: reservedWords.	aBinaryCodeWriter trace: methodInfo.</body></methods><methods><class-id>External.CScanner class</class-id> <category>private</category><body package="DLLCC">computeTables	"Compute the character type, reserved word tables, and	keyword flag from the information associated with each method."	"CScanner computeTables."	self computeBasicTables.	"Construct the type table.  This is not a simple mapping from characters to symbols:	it is more like a finite-state machine description."	typeTable at: 26 "^Z" put: #xDelimiter. "Window EOF"	self initReservedWords.	self initIdentifiers: typeTable.	self initNumbers: typeTable.	self initOperators: typeTable.	self initCharsAndStrings: typeTable.	self initComments: typeTable.	self initCR: typeTable.	self initMacroTokens: typeTable</body><body package="DLLCC">decode: tree	| dict |	^tree isSymbol		ifTrue: [tree]		ifFalse:			[dict := IdentityDictionary new.			2 to: tree size do: [:i | dict at: (tree at: i) first put: (self decode: (tree at: i) last)].			(self decode: tree first) -&gt; dict]</body><body package="DLLCC">in: tree digits: next	'0123456789' do: [:char | tree at: char put: next]</body><body package="DLLCC">initCR: newTypeTable	"CR -- for detecting preprocessor directives."	newTypeTable at: Character cr asInteger put: (self decode: #(xCR)).</body><body package="DLLCC">initCharsAndStrings: newTypeTable	"Characters and strings."	newTypeTable at: $' asInteger put: (self decode: #(xCharacter)).	newTypeTable at: $" asInteger put: (self decode: #(xString)).</body><body package="DLLCC">initComments: newTypeTable	"Comments."	newTypeTable at: $/ asInteger put: (self decode: #(xOperator ($* xComment) ($/ xComment1)))</body><body package="DLLCC">initIdentifiers: newTypeTable	"Identifiers"	| id |	id := #xWord -&gt; (IdentityDictionary new: 128).	(($a asInteger to: $z asInteger), ($A asInteger to: $Z asInteger)		copyWith: $_ asInteger) do:		[:ascii |		newTypeTable at: ascii put: id.		id value at: (Character value: ascii) put: id].	self in: id value digits: id.</body><body package="DLLCC">initMacroTokens: newTypeTable	"Tokens used in macros for stringization and concatenation."	newTypeTable at: $# asInteger put: (self decode: #(xOperator ($# (xOperator)))).	newTypeTable at: $\ asInteger put: (self decode: #(xOperator ($# (xOperator)))).</body><body package="DLLCC">initNumbers: newTypeTable	"numbers - only decimal integers for now"	| num |	num := self decode: #(xInteger ($l (xInteger)) ($L (xInteger)) ($u (xInteger ($l (xInteger)))) ($U (xInteger ($L (xInteger))))).	self in: num value digits: num.	newTypeTable atAll: ($0 asInteger to: $9 asInteger) put: num.	newTypeTable at: $. asInteger put: (self decode: #(xPeriod))</body><body package="DLLCC">initOperators: newTypeTable	"Operators"	#(	($% (xOperator ($= (xOperator))))		($^ (xOperator ($= (xOperator))))		($&amp; (xOperator ($&amp; (xOperator)) ($= (xOperator))))		($* (xOperator ($= (xOperator))))		($- (xOperator ($- (xOperator)) ($= (xOperator)) ($&gt; (xOperator))))		($+ (xOperator ($= (xOperator)) ($+ (xOperator))))		($&lt; (xOperator ($= (xOperator)) ($&lt; (xOperator ($= (xOperator))))))		($= (xOperator ($= (xOperator))))		($! (xOperator ($= (xOperator))))		($&gt; (xOperator ($= (xOperator)) ($&gt; (xOperator ($= (xOperator))))))		($~ (xOperator ($= (xOperator))))		($| (xOperator ($| (xOperator)) ($= (xOperator))))	) do: [:op | newTypeTable at: op first asInteger put: (self decode: op last)]</body><body package="DLLCC">initReservedWords	"Change the reservedWords to a Dictionary."	| rWords |	rWords := Dictionary new.	reservedWords == false ifFalse: [reservedWords do: [:rw | rWords at: rw asSymbol put: true]].	reservedWords := rWords</body></methods><methods><class-id>External.CScanner class</class-id> <category>flushing</category><body package="DLLCC">flushCache	"Flush any cached information."	reservedWords := nil</body><body package="DLLCC">flushCaches	"Flush any cached information."	self withAllSubclasses do: [:ea| ea flushCache]	"CScanner flushCaches"</body></methods><methods><class-id>External.CScanner class</class-id> <category>class initialization</category><body package="DLLCC">initialize	"Perform any class-specific initialization.  Answer the receiver."	"CScanner initialize"	ChangeSet current addPatch: self version</body></methods><methods><class-id>External.CScanner class</class-id> <category>parcel load/unload</category><body package="DLLCC">preUnloadFor: theDLLCCParcel	"Close any open applications implemented by this parcel.	 Remove the DLLCC patch Id form the system patches."	ApplicationModel checkUnloadOfApplicationsDefinedBy: theDLLCCParcel.	[ChangeSet patches includes: self version] whileTrue:		[ChangeSet patches remove: self version]</body></methods><methods><class-id>External.CScanner class</class-id> <category>accessing</category><body package="DLLCC">reservedWords	reservedWords == nil ifTrue: [self computeTables].	^reservedWords</body><body package="DLLCC">typeTable	typeTable == nil  ifTrue: [self computeTables].	^typeTable</body><body package="DLLCC">version	"Answer the current version of the receiver."	^'CScanner Release 3.2'</body></methods><methods><class-id>External.CScanner class</class-id> <category>scanning</category><body package="DLLCC">tokensFrom: aString	"CScanner tokensFrom: 'typedef struct point_s { int x, y; } point;'"	^self new tokensFrom: aString</body></methods><methods><class-id>External.CParser</class-id> <category>initialize-release</category><body package="DLLCC">declarations: aDictionary	"Initialize the receiver to contain the predefined declarations contained in the argument.  The argument is typically an ExternalDictionary containing predefined macros and types.  All macro definitions found in the argument are added to the receiver's reserved word list.  Answer the receiver."	declarations := aDictionary.	declarations reverseDo: [:dec |		dec class == CMacroDefinition			ifTrue: [reservedWords at: dec name put: dec]]</body><body package="DLLCC">parse: aStringOrStream as: construct notifying: aRequestor	"Parse the argument, aStringOrStream, for the construct, aConstruct.  The construct can be one of the many declaration constructs found in the receiver's types-syntax and declarations-syntax protocol.  It is typically one of #Cfile or #declaration.  Answer the receiver."	self init: aStringOrStream notifying: aRequestor failBlock: nil; perform: construct.	^self</body></methods><methods><class-id>External.CParser</class-id> <category>private-scanning</category><body package="DLLCC">peekForType: aType	"Test to see if tokenType matches aType. If so, advance to the next token, pushing the old token on the stack"	^tokenType == aType		ifTrue: 			[stack addLast: token.			self scanToken.			true]		ifFalse: [false]</body><body package="DLLCC">peekForType: aType value: trialValue 	"Test to see if tokenType matches aType and token equals trialValue. If so, advance to the next token"	^(tokenType == aType and: [token = trialValue])		ifTrue: 			[self scanToken.			true]		ifFalse: [false]</body><body package="DLLCC">peekForTypeNoPush: aType	"Test to see if tokenType matches aType. If so, advance to the next token, leaving the stack unchanged"	^tokenType == aType		ifTrue: 			[self scanToken.			true]		ifFalse: [false]</body></methods><methods><class-id>External.CParser</class-id> <category>backing up</category><body package="DLLCC">backupDiscard	"Discard the backup state on success.  Answer true."	backupStack removeLast.	backupStack removeLast.	^true</body><body package="DLLCC">backupRestore	"Restore the saved state on failure.  Answer false."	self popStackTo: backupStack removeLast.	self sourcePosition: backupStack removeLast.	^false</body><body package="DLLCC">backupSave	"Save the current state for backing up.  Answer the receiver."	backupStack		addLast: self sourcePosition;		addLast: stack size</body></methods><methods><class-id>External.CParser</class-id> <category>stack operations</category><body package="DLLCC">combineStackTo: oldSize 	"Make the items down to oldSize into an array,  and replace them with it."	|  size |	size := stack size.	oldSize = size ifTrue: [^stack addLast: #()].	(oldSize &gt; size or: [oldSize &lt; 0]) ifTrue:		[self error: #invalidStackSize &lt;&lt; #dllcc &gt;&gt; 'Invalid size for combining stack'].	stack addLast: (stack removeLast: size - oldSize)</body><body package="DLLCC">popStackTo: newSize	newSize &gt; stack size ifTrue: [^false].	stack size - newSize timesRepeat: [stack removeLast].  "pop and nil elements"	^true</body><body package="DLLCC">replaceStackTop: anElement	"This is only generated in cases where it is known that the stack is not empty."	^stack at: stack size put: anElement</body></methods><methods><class-id>External.CParser</class-id> <category>private</category><body package="DLLCC">declarationsPut: aDictionary	"Force the receiver's declarations to be the argument.  Do not place macros contained in the argument into the receiver's reserved word dictionary -- use #declarations: for that purpose."	declarations := aDictionary</body><body package="DLLCC">fastInit	stack := OrderedCollection new: 20.	backupStack := OrderedCollection new.	super fastInit</body></methods><methods><class-id>External.CParser</class-id> <category>accessing</category><body package="DLLCC">declarations	"Answer all declarations found in the parse up to the time this message is sent.  The answered object will be an ExternalDictionary containing macro and type entries."	^declarations</body><body package="DLLCC">result	stack isEmpty ifTrue: [^nil].	^stack first</body></methods><methods><class-id>External.CParser</class-id> <category>error handling</category><body package="DLLCC">expected: aString 	"Override CScanner implementation in order to include the header 	file that contains the error."	| __file__ |	__file__ := (declarations at: #__FILE__				ifAbsent: [^super expected: aString]) valuePrintString.	^self notify: ((#syntaxErrorInFileHere &lt;&lt; #dllcc 				&gt;&gt; '"&lt;1s&gt;:" syntax error -&gt;' ) expandMacrosWith: __file__)		at: mark</body></methods><methods><class-id>External.CParser class</class-id> <category>private-parser compiler</category><body package="DLLCC">compile: code notifying: requestor ifFail: failBlock 	"Compile the argument, code, as source code in the context of the receiver and install the result in the receiver's method dictionary.  Override the superclass implementation to warn that a special parser is required."	#{ParserCompiler} isDefined ifFalse:		[^self error: (#CParserRequiresParserCompiler &lt;&lt; #dllcc &gt;&gt; 'The CParser class hierarchy requires a specialized ParserCompiler which is in the AT Parser Compiler parcel. Please load the parcel, otherwise contact Cincom Systems, Inc.')].	^super compile: code notifying: requestor ifFail: failBlock</body><body package="DLLCC">compilerClass	"Answer a compiler class appropriate for source methods of this class."	 ^#{ParserCompiler} valueOrDo: [super compilerClass]</body><body package="DLLCC">methodInfo	"Override to flush our cached parser."	CScanner withAllSubclasses do: [:sc| sc flushCache].	^CScanner methodInfo</body></methods><methods><class-id>External.CParser class</class-id> <category>flushing</category><body package="DLLCC">flushCache	"Flush any cached information."	reservedWords := cachedParser := nil</body></methods><methods><class-id>External.CParser class</class-id> <category>parsing</category><body package="DLLCC">parseIncludeFiles: fileNames declarations: declarationDictionary includeDirectories: directoryStringArray requestor: aRequestor	"Parse the contents of a collection of public include files. Perform preprocessing on the files before the parse.  Use the declarationsDictionary argument as the cache of predefined types and defines.  Use the argument, directoryStringArray, as an Array of String directory paths to search when include directives are encountered. Notify aRequestor of any syntax errors.  Answers an instance of the receiver whose declaration dictionary is loaded."	| aStream |	aStream := ReadWriteStream on: (String new: 20).	aStream nextPut: Character cr.	fileNames do: [:aFileName | aStream nextPutAll: '#include "', aFileName, '"'; nextPut: Character cr].	aStream reset.	^self		parseWithPreprocess: aStream		as: #Cfile		declarations: declarationDictionary		includeDirectories: directoryStringArray		requestor: aRequestor</body><body package="DLLCC">parseWithNoPreprocess: aStringOrStream as: construct declarations: declarationDictionary requestor: aRequestor	"Parse aStringOrStream as a construct in the C language.  Do not perform any preprocessing on the argument aStringOrStream before the parse.  Use the declarationsDictionary argument as the cache of predefined types and defines.  Notify aRequestor of any syntax errors.  Answer the new instance of the receiver that performed the parse.  You can send #result to obtain the result of the parse or #declarations to extract the updated declaration dictionary."	| parser |	parser := cachedParser.	(parser notNil and:		[parser declarations backup = declarationDictionary backup])			ifTrue: [parser fastInit; declarationsPut: declarationDictionary]			ifFalse: [parser := cachedParser := self new declarations: declarationDictionary].	^parser parse: aStringOrStream as: construct notifying: aRequestor</body><body package="DLLCC">parseWithPreprocess: aStringOrStream as: construct declarations: declarationDictionary includeDirectories: directoryStringArray requestor: aRequestor	"Parse aStringOrStream as a construct in the C language.  Perform preprocessing on the argument aStringOrStream before the parse.  Use the declarationsDictionary argument as the cache of predefined types and defines.  Use the String Array, directoryStringArray, as a collection of directory paths to search when include directives are encountered. Notify aRequestor of any syntax errors.  Answers an instance of the receiver whose declaration dictionary is loaded."	| preprocessedStream |	preprocessedStream :=		self preprocessorClass			preprocess: aStringOrStream			declarations: declarationDictionary			includeDirectories: directoryStringArray.	^self		parseWithNoPreprocess: preprocessedStream reset		as: construct		declarations: declarationDictionary		requestor: aRequestor</body></methods><methods><class-id>External.CParser class</class-id> <category>class accessing</category><body package="DLLCC">preprocessorClass	"Answer the class to be used to preprocess the input stream before parsing.  Subclasses must override."	^self subclassResponsibility</body></methods><methods><class-id>External.CParser class</class-id> <category>private</category><body package="DLLCC">reservedWords	^self superclass reservedWords</body><body package="DLLCC">typeTable	^self superclass typeTable</body></methods><methods><class-id>External.CExpressionParser</class-id> <category>types-actions</category><body package="DLLCC">checkEnum	| anEnum |	anEnum := declarations declarationAt: stack removeLast asSymbol ifAbsent: [^false].	(anEnum isKindOf: CEnumerationType) ifFalse: [^false].	stack addLast: anEnum.	^true</body><body package="DLLCC">embedArray: aBlock size: size	^[:t | aBlock value:			(CArrayType				defaultPointer referentType: t;				numElements: size)]</body><body package="DLLCC">embedDeclarand: specifiers ofName: name typeBlock: typeBlock	"Leaves name and type constructor block on stack."	stack removeLast.	stack addLast: name.	stack addLast: name.	^[:arg | | declarand |		declarand := typeBlock value: arg.		specifiers do: [:aSpecifier |			(aSpecifier notNil and: [declarand respondsTo: aSpecifier])				ifTrue: [declarand := declarand perform: aSpecifier]].		declarand].</body><body package="DLLCC">embedPointer: realPointer platformQualifiers: platformQualifiers qualifiers: qualifiers ofName: name typeBlock: typeBlock	"The argument 'realPointer' indicates if this pointer may accept Smalltalk objects.  The argument specifier indicates a type specifier - one of _near, _far, _huge, or _based.  The argument argSpecifier is ingored.  The argument isConstant is the symbol #const if the pointer is a constant pointer."	stack removeLast.	stack addLast: name.	stack addLast: name.	^[:t | | aType pointerClass |		aType := nil.		pointerClass := CType defaultPointerTypeClass.		(platformQualifiers includes: #beNear) ifTrue: [aType := pointerClass nearPointer].		(platformQualifiers includes: #beFar) ifTrue: [aType := pointerClass farPointer].		aType isNil ifTrue: [aType := pointerClass defaultPointer].		aType referentType: t.		platformQualifiers do: [:aQualifier | aType perform: aQualifier].		"Don't bother with the volatile qualifier."		(qualifiers includes: #beConstant) ifTrue: [aType := aType beConstant].		realPointer notNil ifTrue: [aType bePointer].		typeBlock value: aType]</body><body package="DLLCC">embedProcedure: aBlock args: args	^[:t | | cProcedureType |		args size == 0			ifTrue:				[cProcedureType := CProcedureType					resultType: t					argumentTypes: Array new					argumentNames: nil.				cProcedureType beVarArg]			ifFalse:				[| firstArg |				(args size == 1 and: [((firstArg := (args at: 1) value) isKindOf: CType) and: [firstArg isVoid]])					ifTrue:						[cProcedureType := CProcedureType							resultType: t							argumentTypes: Array new							argumentNames: nil]					ifFalse:						[| argumentAssocs procedureArgs isVarArg argNames |						isVarArg := false.						(args at: args size) value == #varArg							ifTrue:								[isVarArg := true.								argumentAssocs := args copyFrom: 1 to: args size - 1]							ifFalse: [argumentAssocs := args].						procedureArgs := argumentAssocs							collect: [:theType | | theValue |								(theValue := theType value) isVoid									ifTrue:										[backupStack := OrderedCollection new.										self notify: #voidMustBeEntireList &lt;&lt; #dllcc &gt;&gt; '''void'' in parameter list must be the entire list'].								theValue].						argNames := #().						argumentAssocs							detect: [:a | a key notNil]							ifNone: [argNames := nil].						argNames isNil							ifFalse:								[| count |								count := 0.								argNames := argumentAssocs collect: [:assoc |										assoc key isNil											ifTrue: [count := count + 1. '_arg', count printString]											ifFalse: [assoc key]]].						cProcedureType := CProcedureType							resultType: t							argumentTypes: procedureArgs							argumentNames: argNames.						isVarArg ifTrue: [cProcedureType beVarArg]]].		t isPascal ifTrue: [cProcedureType bePascal].		aBlock value: cProcedureType]</body><body package="DLLCC">embedType: aType	"A nameless type was encountered.  Answer an array of one association that represents this unamed typed (the key is nil, the value is the type)."	^Array with: nil-&gt;aType</body><body package="DLLCC">embedType: baseType in: firstDecl andList: declList	"Answer an Array of CTypes that were formed from the baseType and the declaration blocks."	| realBaseType |	^(Array with: (((firstDecl at: 1) -&gt;		(realBaseType :=			(firstDecl at: 2) == nil ifTrue: [baseType] ifFalse: [(firstDecl at: 2) value: baseType])))),		(self			embedType: realBaseType			inList: declList)</body><body package="DLLCC">embedType: baseType inList: declList	^declList collect:		[:decl2 |  "name, type block"		(decl2 at: 1) -&gt;			((decl2 at: 2) isNil ifTrue: [baseType] ifFalse: [(decl2 at: 2) value: baseType])]</body><body package="DLLCC">embedTypeName: baseType name: shouldBeNil declarator: declaratorBlock	^[:environment | declaratorBlock value: baseType]</body><body package="DLLCC">emptyBlock	^[:t | t]</body><body package="DLLCC">makeCompositeName: aName members: members metaType: metaType	"name == nil means an anonymous structure.	members == nil means a structure referred to by name only."	| aCompositeType name |	aName notNil		ifTrue: [name := aName asSymbol].	(members isNil and: [name notNil]) ifTrue:		[^declarations compoundAt: name ifAbsent:				["Create a dummy structure."				declarations					declareAt: name					put: (CCompositeType new name: name; metaType: metaType)]].	aCompositeType := CCompositeType new name: name; metaType: metaType.	members do: [:memberAssoc |		memberAssoc key == nil			ifFalse: [aCompositeType at: memberAssoc key asSymbol put: 0 -&gt; memberAssoc value]].	aCompositeType align.	^name notNil		ifTrue: [declarations declareAt: name put: aCompositeType]		ifFalse: [aCompositeType]</body><body package="DLLCC">makeEnumName: memberName firstMember: firstMember restOfMembers: otherMembers	"Answer a new CEnumerationType named aName with the given members.  As a side effect, if aName is not nil the enumeration is added to the declarations dictionary."	"To allow a trailing comma for the last enumeration, the parser is structured to push the first enumeration constant onto the stack followed by the remaining constants.  We combine all those constants into a single array before creating the enumeration object.  This is done to simplify the implementation of makeEnumName:members:."	^self		makeEnumName: memberName		members:			(firstMember isNil ifTrue: [#()] ifFalse: [(Array with: firstMember)]) ,				(otherMembers isNil ifTrue: [#()] ifFalse: [otherMembers])</body><body package="DLLCC">makeEnumName: aName members: members	"Answer a new CEnumerationType named aName with the given members.  As a side effect, if aName is not nil the enumeration is added to the declarations dictionary."	| value anEnumType name |	value := 0.	aName notNil ifTrue: [name := aName asSymbol].	anEnumType := CEnumerationType new name: name.	(name notNil and: [members isNil or: [members isEmpty]])		ifTrue: [^declarations compoundAt: name ifAbsent:					["Create a dummy structure."					declarations						declareAt: name						put: anEnumType]].	members notNil		ifTrue:			[members do: [:nameAndOffset |			nameAndOffset value notNil				ifTrue: [value := nameAndOffset value].			anEnumType at: nameAndOffset key asSymbol put: value.			value := value + 1]].	^name notNil		ifTrue: [declarations declareAt: name put: anEnumType]		ifFalse: [anEnumType]</body><body package="DLLCC">makeOopClass: className	| oopClass |	oopClass := className asQualifiedReference valueOrDo:			[self expected: (#SmalltalkClassName &lt;&lt; #dllcc &gt;&gt; 'Smalltalk class name')].	^COopType new referentClass: oopClass</body><body package="DLLCC">makeStructName: name members: members	^self makeCompositeName: name members: members metaType: #struct</body><body package="DLLCC">makeUnionName: name members: members	^self makeCompositeName: name members: members metaType: #union</body><body package="DLLCC">prefixQualifiers: prefixQualifiers forType: aType postfixQualifiers: postfixQualifiers	"Answer a CQualifiedType object that qualifies the argument, aType.  The qualifications are indicated by the arguments prefixQualifiers and postfixQualifiers.  The C language syntax allowse type specifiers to appear before or after the type specification itself.  The specifier arguments are arrays of unary symbols that can be send to a qualified type to give itself the desired attribute.  If both of the specifier arrays are empty answer aType."	| qualifiedType |	(prefixQualifiers isEmpty and: [postfixQualifiers isEmpty]) ifTrue: [^aType].	qualifiedType := CQualifiedType new type: aType.	prefixQualifiers do: [:aSpecifier | qualifiedType perform: aSpecifier].	postfixQualifiers do: [:aSpecifier | qualifiedType perform: aSpecifier].	^qualifiedType</body><body package="DLLCC">typedefName	| aDec typeName |	tokenType == #word ifFalse: [^false].	typeName := token asSymbol.	aDec := declarations declarationAt: typeName ifAbsent: [nil].	aDec class == CTypedefType ifFalse: [^false].	stack addLast: aDec.	self scanToken. 	^true</body></methods><methods><class-id>External.CExpressionParser</class-id> <category>expressions-syntax</category><body package="DLLCC">abstractDeclarator =	@((#'_pointer' [#bePointer]) | [nil]) (platformSpecifiers | [nil])		#* typeQualifier (abstractDeclarator | [nil] [self emptyBlock])			[embedPointer:platformQualifiers:qualifiers:ofName:typeBlock:] |	@(platformSpecifiers | [nil])		[nil] [self emptyBlock] abstractDeclaratorModifier [embedDeclarand:ofName:typeBlock:] |	"Following must use @ in case the next thing is actually a procedure argument list"	@ $( abstractDeclarator $) abstractDeclaratorModifier*!</body><body package="DLLCC">abstractDeclaratorModifier =	"Following must use @ in case the next thing is a formal parameter list for a procedure definition."	@ $( paramList $) [embedProcedure:args:] |	$[ (expression | [nil]) $] [embedArray:size:]</body><body package="DLLCC">exprBlock =	"Answer a block which, when evaluated with an environment, produces the value of the expression in that environment."	parseCond</body><body package="DLLCC">expression =	"Answer the result of evaluating the block returned by #exprBlock in the current environment."	exprBlock [eval:]</body><body package="DLLCC">macro =	(scanString | expression) sourceAtEnd</body><body package="DLLCC">parseAdd =	parseMultiplication	(	#+ [x:] parseMultiplication [x:] [exprBinary:op:#+with:] |		#- [x:] parseMultiplication [x:] [exprBinary:op:#-with:]	)*!</body><body package="DLLCC">parseAnd =	parseBitOr (#&amp;&amp; [x:] parseBitOr [x:] [exprAnd:with:])*!</body><body package="DLLCC">parseBitAnd =	parseEq (#&amp; [x:] parseEq [x:] [exprBinary:op:#bitAnd: with:])*!</body><body package="DLLCC">parseBitOr =	parseBitXor (#| [x:] parseBitXor [x:] [exprBinary:op:#bitOr: with:])*!</body><body package="DLLCC">parseBitXor =	parseBitAnd ($^ [x:] parseBitAnd [x:] [exprBinary:op:#bitXor: with:])*!</body><body package="DLLCC">parseCast =	@$( typeName $) parseCast [x:] [exprCast:expression:] |	parseUnary</body><body package="DLLCC">parseCond =	parseOr ($? [x:] parseOr $: [x:] parseCond [x:] [exprCond:ifTrue:ifFalse:] | )</body><body package="DLLCC">parseEq =	parseRel	(	#== [x:] parseRel [x:] [exprRelation:op:#=with:] |		#!= [x:] parseRel [x:] [exprRelation:op:#~=with:]	)*!</body><body package="DLLCC">parseMultiplication =	parseCast	(	#* [x:] parseCast [x:] [exprBinary:op:#*with:] |		#/ [x:] parseCast [x:] [exprBinary:op:#//with:] |		#% [x:] parseCast [x:] [exprBinary:op:#\\with:]	)*!</body><body package="DLLCC">parseOr =	parseAnd (#'||' [x:] parseAnd [x:] [exprOr:with:])*!</body><body package="DLLCC">parsePostfix =	parsePrimary	(	$[ expression $] [exprArray:index:] |		"$( expression \ $, $) [exprProcedureCall:arguments:] |"		$. variableName [exprCompositeReference:member:] |		#-&gt; variableName [exprCompositeReference:member:] |		#++ [exprPostfixIncrement:] |		#'--' [exprPostfixDecrement:]	)*!</body><body package="DLLCC">parsePrimary =	variableName [exprVariable:] |	number [compressNumber:] | character [:asInteger] | scanString |	$( expression $)</body><body package="DLLCC">parseRel =	parseShift	(	#&lt; [x:] parseShift [x:] [exprRelation:op:#&lt;with:] |		#&gt; [x:] parseShift [x:] [exprRelation:op:#&gt;with:] |		#&lt;= [x:] parseShift [x:] [exprRelation:op:#&lt;=with:] |		#&gt;= [x:] parseShift [x:] [exprRelation:op:#&gt;=with:]	)*!</body><body package="DLLCC">parseShift =	parseAdd	(	#&lt;&lt; [x:] parseAdd [x:] [exprBinary:op:#bitShift: with:] |		#&gt;&gt; [x:] parseAdd [x:] [exprUnary:op:#negated] [exprBinary:op:#bitShift: with:]	)*!</body><body package="DLLCC">parseUnary =	#+ parseCast [x:] [exprUnary:op:#yourself] |	#- parseCast [x:] [exprUnary:op:#negated]  |	#! parseCast [x:] [exprNot:] |	#~ parseCast [x:] [exprUnary:op:#bitInvert] |	#&amp; parseCast [exprReference:] |	#* parseCast [exprDereference:] |	word=#sizeof ($( typeName $) | parseUnary) [x:] [exprSizeof:] |	parsePostfix</body><body package="DLLCC">scanOneByteString	^tokenType == #string 		ifTrue: 			[stack addLast: (token copyFrom: 2 to: token size - 1).			self scanToken.			true]		ifFalse: [false]</body><body package="DLLCC">scanString	^(tokenType == #word and: [token = 'L']) 		ifTrue: [self scanTwoByteString]		ifFalse: [self scanOneByteString]</body><body package="DLLCC">scanTwoByteString	self scanToken.	^tokenType == #string 		ifTrue: 			[stack addLast: (token copyFrom: 2 to: token size - 1) asTwoByteString.			self scanToken.			true]		ifFalse: [false]</body><body package="DLLCC">sourceAtEnd	^token isNil</body></methods><methods><class-id>External.CExpressionParser</class-id> <category>types-syntax</category><body package="DLLCC">afterParamGroup	^token = $, or: [token = $)]</body><body package="DLLCC">declMod =	"Following must use @ in case the next thing is a formal parameter list for a procedure definition."	@ $( paramList $) [embedProcedure:args:] |	$[ (expression | [nil]) $] [embedArray:size:]</body><body package="DLLCC">declWithName =	"Leaves name and type constructor block on the stack."	@((#'_pointer' [#bePointer]) | [nil]) (platformSpecifiers | [nil])		#* typeQualifier declarator			[embedPointer:platformQualifiers:qualifiers:ofName:typeBlock:] |	@(platformSpecifiers | [nil])		declarand [self emptyBlock] declMod*! [embedDeclarand:ofName:typeBlock:] |	"Following must use @ in case the next thing is actually a procedure argument list"	@ $( declarator $) declMod*!</body><body package="DLLCC">declarand =	variableName</body><body package="DLLCC">declarator =	"Leaves name and type constructor block on stack"	declWithName |	@ [nil] [self emptyBlock] declMod*!</body><body package="DLLCC">declaratorWithName =	"Leaves name and type constructor block on the stack."	declWithName |	"No name, must have declMod."	@ [nil] [self emptyBlock] declMod declMod*!</body><body package="DLLCC">emptyType	| aDec typeName |	tokenType == #word ifFalse: [^false].	typeName := token asSymbol.	aDec := declarations declareAt: typeName put:		(CTypedefType new name: typeName; type: CPointerType uniqueDefaultPointer).	stack addLast: aDec.	self scanToken. 	^true</body><body package="DLLCC">guaranteedSpecifierQualifier =	"Parse a type specification; a base type specifier and its type qualifiers. Do not allow undeclared types to be automatically declared. Please see the comments in the method #specifierQualifier for futher details."	(@typeQualifier typeSpecifier) typeQualifier [prefixQualifiers:forType:postfixQualifiers:]</body><body package="DLLCC">isAnonymousType	^(stack last at: 1) == nil</body><body package="DLLCC">paramGroup =	(#register | )	specifierQualifier	[Array] declarator [:with:with:]		"we can't apply the same type to multiple names if there is no name"	 	( isAnonymousType [#()]   "Leave empty list of additional parameters"		| (@ $, [Array] declaratorWithName [:with:with:] afterParamGroup)* )	[embedType:in:andList:]</body><body package="DLLCC">paramList =	paramGroup (@ $, (paramGroup | $.$.$. [Array with: nil -&gt; #varArg]) [:,])*! |	$.$.$. [Array with: nil -&gt; #varArg] |	[#()]</body><body package="DLLCC">specifierQualifier =	"Parse a type specification; a base type specifier and its type qualifiers.  Note that the C language syntax allows for type qualifiers to appear before or after the base type specification as in 'const int', or 'int const' or 'const int const' (where the latter is usually a warning).  Place on the top of the stack the CType object."	"Note the backtracking symbol @ that appears before the specification sequence.  This is to allow the object pushed onto the stack by the first typeSpecifier to be popped if baseTypeSpec fails."	(@typeQualifier (typeSpecifier | emptyType)) typeQualifier [prefixQualifiers:forType:postfixQualifiers:]</body><body package="DLLCC">typeName =	guaranteedSpecifierQualifier (abstractDeclarator | [nil] [self emptyBlock]) [embedTypeName:name:declarator:]</body><body package="DLLCC">typeQualifier =	"Answer an array of Symbols that indicate the type qualifiers found for the current type specification.  If no type qualifiers are found answer an empty array.  The elements of the array should be unary message selectors that can be sent to instances of CType to convert them into a type with the indicated qualification attribute."	(#pascal [#bePascal] |	#const [#beConstant] |	#volatile [#beVolatile] ) *</body><body package="DLLCC">typeSpecifier =	"Place on top of the parse stack a type specifier, one of enum, struct, union, typedef, or scalar type. Fail if a valid type specifier is not present on the input token stream."	enum	| struct	| union	| #void [CVoidType void]	| #float [CLimitedPrecisionRealType float]	| #double [CLimitedPrecisionRealType double]	| #extended [CLimitedPrecisionRealType extended]	| #unsigned		((#char | #'__int8') [CIntegerType unsignedChar] 		| (#short | #'__int16') ((#int | ) [CIntegerType unsignedShort]) 		| #long 			( #long (#int | ) [CIntegerType unsignedLongLong] 				| (#int | ) [CIntegerType unsignedLong]) 		| #'__int64' [CIntegerType unsignedLongLong] 		| (#int | #'__int32' | ) [CIntegerType unsignedInt])	| #signed		((#char | #'__int8') [CIntegerType signedChar] 		| (#short | #'__int16') ((#int | ) [CIntegerType signedShort]) 		| #long 			(#long (#int | ) [CIntegerType signedLongLong] 				| (#int | ) [CIntegerType signedLong]) 		| #'__int64' [CIntegerType signedLongLong] 		| (#int | #'__int32' | ) [CIntegerType signedInt])	| (#'_bool' | #'__bool')		((#char | #'__int8') [CIntegerType booleanChar] 		| (#short | #'__int16') ((#int | ) [CIntegerType booleanShort]) 		| #long 			(#long [CIntegerType booleanLongLong]				| (#int | ) [CIntegerType booleanLong] ) 		| #'__int64' [CIntegerType booleanLongLong] 		| (#int | #'__int32' | ) [CIntegerType booleanInt])	| (#'_hresult' | #'__hresult') (#long [CIntegerType hResultLong])	| (#'_syscall' | #'__syscall') (#unsigned #long [CIntegerType syscallLong])	| (#'_wincall' | #'__wincall') (#unsigned #long [CIntegerType wincallLong])	| (#char | #'__int8') [CIntegerType char] 	| (#short | #'__int16') ((#int | ) [CIntegerType short]) 	| #long 		(#unsigned (#double [CLimitedPrecisionRealType longDouble]			| #long (#int | ) [CIntegerType unsignedLongLong] 			| (#int | ) [CIntegerType unsignedLong] )		| (#signed | ) (#double [CLimitedPrecisionRealType longDouble]			| #long  (#int | ) [CIntegerType signedLongLong] 			| (#int | ) [CIntegerType signedLong] ))	| (#int | #'__int32') [CIntegerType int] 	| #'__int64' [CIntegerType signedLongLong] 	| #'_segment' [CIntegerType short]	| #'_oop' ( $( word $) | [#Object]) [makeOopClass:]	| typedefName</body></methods><methods><class-id>External.CExpressionParser</class-id> <category>types-syntax-basic</category><body package="DLLCC">compositeSpec =	${ [nil] members $} | word (${ members $} | [nil] )</body><body package="DLLCC">enum =	#enum enumSpec</body><body package="DLLCC">enumMember =	declarand (#= expression | [nil]) [:-&gt;]</body><body package="DLLCC">enumSpec =	"Parse an enumeration specification.  Answer true if a valid enumeration was encountered, otherwise answer false.  If a valid enumeration is found, the top element of the stack is the enumeration object."	${ [nil] enumMember (@$, enumMember)* ($, | ) $}		[makeEnumName:firstMember:restOfMembers:] |	word ((${ enumMember (@$, enumMember)* ($, | ) $} | [nil] [nil])		[makeEnumName:firstMember:restOfMembers:] | checkEnum)</body><body package="DLLCC">memberDecl =	declaratorWithName ($: expression | [nil]) [stack removeLast: 3]	| $: [Array] expression [: with: nil with: nil with:]</body><body package="DLLCC">memberGroup =	(specifierQualifier | emptyType) ($; [embedType:] | (memberDecl \ $,) $; [embedType:inList:])</body><body package="DLLCC">members =	memberGroup (memberGroup [:,])*!</body><body package="DLLCC">platformSpecifiers =	"Parse any platform specific specifiers.  If a specifier is found, send a conversion	 message to the argument on the top of stack informing it of the specifier.  Most of	 the specifiers in this method are parsed but simply ignored in order to avoid syntax	 errors.  Please consult the documentation for a list of supported specifiers."	((#'_near' | #'__near') [#beNear] |	(#'_far' | #'_Far16' | #'__far' | #'_huge' | #'__huge') [#beFar] |	(#'_based' | #'__based') $(		(($( (#'_segment' | #'__segment') $) | ) variableName. |		(#'_segname' | #'__segname') $( scanString. $)) $) [#yourself] |	(#'_Seg16') [#beSeg16] |	(#'_pascal' | #'__pascal' | #'_Pascal') [#bePascal] |	(#'_fortran' | #'__fortran') [#beFortran] |	(#'_cdecl' | #'__cdecl' | #'_Cdecl' ) [#beCdecl] |	(#'_stdcall' | #'__stdcall') [#beStdcall] |	(#'_saveregs' | #'__saveregs' |		#'_interrupt' | #'__interrupt' |		#'_export' | #'__export' |		#'_Export' | #'_Inline' | #'_System' | #'_Far32' |		#'_loadds' | #'__loadds' |		#'_self' | #'__self') [#yourself] |	(#'_fastcall' | #'__fascall' | #'_Fastcall' | #'_Optlink') [#yourself] |	(#'_nocallback') [#beNoCallback] |	(#'_longcomp') [#beLongcomp] |	(#'_oopref') [#beOopRef] |	(#'_threaded' | #'__threaded') [#beThreaded] |	(#'_hresult' | #'__hresult') [#beHResult] |	(#'_syscall' | #'__syscall') [#beSyscall] |	(#'_wincall' | #'__wincall') [#beWincall])*</body><body package="DLLCC">struct =	#struct compositeSpec [makeStructName:members:]</body><body package="DLLCC">union =	#union compositeSpec [makeUnionName:members:]</body></methods><methods><class-id>External.CExpressionParser</class-id> <category>expressions-actions</category><body package="DLLCC">compressNumber: aNumber	"Answer the compress the argument if it is an integer, otherwise answer the argument."	aNumber isInteger ifTrue: [^aNumber compressed].	^aNumber</body><body package="DLLCC">eval: exprBlock	"Evaluate the exprBlock (a block that accepts one argument) with an environment in which all undefined variables are defined as 0 (the preprocessor has supposedly replaced all defined variables with their values).  Answer the argument if it is not a block closure."	^(exprBlock isKindOf: BlockClosure)		ifTrue: [exprBlock value: declarations]		ifFalse: [exprBlock]</body><body package="DLLCC">exprAnd: left with: right	^[:envt | (left value: envt) = 0 ifTrue: [0] ifFalse: [right value: envt]]</body><body package="DLLCC">exprArray: expressionBlock index: indexBlock	^[:environment | (expressionBlock value: environment) at: (indexBlock value: environment)]</body><body package="DLLCC">exprBinary: left op: selector with: right	^[:envt | (left value: envt) perform: selector with: (right value: envt)]</body><body package="DLLCC">exprCast: baseType expression: expression	^[:environment | (baseType value: environment) cast: (expression value: environment)]</body><body package="DLLCC">exprCompositeReference: compositeBlock member: member	^[:environment |		(compositeBlock value: environment) memberAt: (environment at: member asSymbol)]</body><body package="DLLCC">exprCond: cond ifTrue: expr1 ifFalse: expr2	^[:envt | (cond value: envt) ~= 0 ifTrue: [expr1 value: envt] ifFalse: [expr2 value: envt]]</body><body package="DLLCC">exprDereference: expressionBlock	^[:environment | (expressionBlock value: environment) contents]</body><body package="DLLCC">exprNot: operand	^[:envt | (operand value: envt) = 0 ifTrue: [1] ifFalse: [0]]</body><body package="DLLCC">exprOr: left with: right	^[:envt | (left value: envt) ~= 0 ifTrue: [1] ifFalse: [right value: envt]]</body><body package="DLLCC">exprPostfixDecrement: expressionBlock	^[:environment | |expression |		expression := expressionBlock value: environment.		(expression isKindOf: Number)			ifTrue: [expression - 1]			ifFalse: [expression decrement]]</body><body package="DLLCC">exprPostfixIncrement: expressionBlock	^[:environment | |expression |		expression := expressionBlock value: environment.		(expression isKindOf: Number)			ifTrue: [expression + 1]			ifFalse: [expression increment]]</body><body package="DLLCC">exprProcedureCall: procedureBlock arguments: argumentsBlock	^[:environment |		(procedureBlock value: environment) callWith: (argumentsBlock value: environment)]</body><body package="DLLCC">exprReference: expressionBlock	"The following is not correct.  The value of expression will need to be an object that knows how to answer the reference of the expression is contains.  For example, the address of a structure member obtained from an expression of the form '&amp;aStruct-&gt;member' should answer a pointer to the member (i.e. aStruct refMemberAt: #member)."	^[:environment | | expression |		expression := expressionBlock value: environment]</body><body package="DLLCC">exprRelation: left op: selector with: right	^[:envt | ((left value: envt) perform: selector with: (right value: envt)) ifTrue: [1] ifFalse: [0]]</body><body package="DLLCC">exprSizeof: typeBlock	^[:environment | | type |		type := typeBlock value: environment.		(type isKindOf: CType) ifFalse: [type := type baseCType].		type sizeof]</body><body package="DLLCC">exprUnary: left op: selector	^[:envt | (left value: envt) perform: selector]</body><body package="DLLCC">exprVariable: varName 	"Answer a block that when evaulated will answer the value of the argument, varName, within the environment passed as an argument to the block.  The block's argument will be an ExternalDictionary.  If the variable is not declared the default is to answer zero."	^	[:environment | 	| defn |	defn := environment at: varName asSymbol ifAbsent: [0].	((defn isKindOf: CMacroDefinition) and: [defn name == varName asSymbol]) 		ifTrue: [0]		ifFalse: [defn value]]</body><body package="DLLCC">variableName	| aDec |	tokenType == #word ifFalse: [^false].	aDec := declarations declarationAt: token asSymbol ifAbsent: [nil].	(aDec notNil and: [aDec class == CTypedefType])		ifTrue: [^false].	stack addLast: token.	self scanToken.	^true</body><body package="DLLCC">x: top	"Coerce a value to a block if necessary."	^((top isKindOf: Number) or: [top isString])		ifTrue: [[:envt | top]]		ifFalse: [top]</body></methods><methods><class-id>External.CExpressionParser class</class-id> <category>class accessing</category><body package="DLLCC">preprocessorClass	"Answer the class to be used to preprocess the input stream before parsing.  Subclasses must override."	^CPreprocessor</body></methods><methods><class-id>External.CDeclarationParser</class-id> <category>declarations-syntax</category><body package="DLLCC">Cfile =	"Parse an entire C file."	declaration*!</body><body package="DLLCC">compoundTypeOnStack	"Answer true if there is a compound C type on the stack, otherwise answer false.  We allow allow structs, unions and enums to appear.  In addition, the compound type may appear without a name.  Clients should be prepared to handle these nameless objects."	"We reference the C compound type class directly rather than adding a new method (isCompoundType) to the CType hierarchy."	^stack last isKindOf: CCompoundType</body><body package="DLLCC">declList =	(initDecl \ $, | . compoundTypeOnStack [#()]) $;</body><body package="DLLCC">declaration =	"Parse a single declaration."	(typedef |	@typeStorageSpec declList [declare:list:]).</body><body package="DLLCC">initDecl =	[Array] declaratorWithName (initializer | [nil]) [:with:with:with:]</body><body package="DLLCC">initializer =	"If the top object on the stack is a BlockClosure that creates a procedure type, parse an initializer as an inline function definition.  The inline function defintion has the form:	&lt;procedureDeclaration&gt; ::=		&lt;returnType&gt; &lt;procedureName&gt; (&lt;arguments&gt;) = { &lt;number&gt;* } | &lt;number&gt;	Otherwise, skip the initializer list (we do not support aggregate initialization)."	[self isPossibleInlineProcedure] ? (#= (${ (number \ $,) $} | number) | [nil]) |	#= (${ skipList $} | expression.) [nil]</body><body package="DLLCC">singleTypedef =	#typedef		( @ specifierQualifier initTypeDecl [defineType:declarator:]		| @ emptyType initTypeDecl [defineType:declarator:]		| [CIntegerType int] initTypeDecl [defineType:declarator:])</body><body package="DLLCC">skipList =	"Skip over an arbitrary list of tokens enclosed in (balanced) {}s.  We have already read the initial {."	( ${ skipList $} | notRightBrace )*!</body><body package="DLLCC">storageSpec =	#auto [#auto] | #static [#static] |	#extern [#extern] | #register [#register]</body><body package="DLLCC">typeStorageSpec =		specifierQualifier (storageSpec . | )	| storageSpec . (specifierQualifier | [CIntegerType int])	| [CIntegerType int]</body><body package="DLLCC">typedef =	"Push a CTypedefType object onto the stack if a typedef declaration appears next in the input stream and answer true, otherwise answer false."	#typedef		(specifierQualifier | [CIntegerType int]) typeDeclList [defineType:list:]</body></methods><methods><class-id>External.CDeclarationParser</class-id> <category>method-syntax</category><body package="DLLCC">closeBracket	token == #&gt; ifTrue: [source position: mark. ^true].	^false</body><body package="DLLCC">defineOrSingleDeclaration =	(singleTypedef	| (@ word #=  | [nil])		(typeStorageSpec (@initDecl [declare:declarator:] | compoundTypeOnStack)) [:-&gt;]	) closeBracket</body><body package="DLLCC">singleDeclaration =	typeStorageSpec (@ initDecl [declare:declarator:] |)</body></methods><methods><class-id>External.CDeclarationParser</class-id> <category>declarations-actions</category><body package="DLLCC">declare: aType declarator: aDeclarator	"Declare a new ExternalObject from the base type, aType.  Register the new type in the declarations dictionary.  The argument, aDeclarator, is an array of three elements.  The first element is a String or Symbol indicating the name of the type and it will be used to key the new type into the declarations dictionary.  The second element is a BlockClosure accepting one argument that will construct the new type based on the the base type, aType.  The third element is the type's initializer.  Answer the new external."	| key type external |	key := aDeclarator at: 1.	type := (aDeclarator at: 2) value: aType.	key isNil ifTrue: [^type].	key := key asSymbol.	external := type external: key.	external initializer: (aDeclarator at: 3).	^declarations declareAt: key put: external</body><body package="DLLCC">declare: aType list: declList	"Answer a collection of associations.  Each association's key is the name of the declaration.  Each association's value is another association whose key is the declaration's type and whose value is an optional initializer.  The initializer is type specific.  Examples include an Integer or Integer Array for inline code procedure types and nil for most other types.  A side effect of this method is to add each declaration into the receiver's declarations dictionary."	| list |	list := self embedInitializerType: aType inList: declList.	list do: [:nameAndTypeAndInitializer | | name type initializer external |		name := nameAndTypeAndInitializer key.		type := nameAndTypeAndInitializer value key.		initializer := nameAndTypeAndInitializer value value.		name notNil ifTrue:			[name := name asSymbol.			(external := type external: name) notNil ifTrue:				[external initializer: initializer.				declarations declareAt: name put: external]]].	^list</body><body package="DLLCC">defineType: aType declarator: declarator	"A typedef declaration was parsed.  The argument aType is the base type of the type declaration.  The argument declarator is an array of two elements.  The first element is a String or Symbol indicating the name of the typedef; the second element is a BlockClosure accepting one argument that is used to build the type from the base type, aType.  Answer a new typedef type built from the elements in declarator."	| key type external |	key := declarator at: 1.	key isNil ifTrue: [^aType].	key := key asSymbol.	type := (declarator at: 2) value: aType.	external := CTypedefType new name: key; type: type.	^declarations declareAt: key put: external</body><body package="DLLCC">defineType: aType list: declList	"A type declaration was parsed. The argument aType is the base type of the type declaration and declList is a list of objects defined to be the type aType.  Answer a list of associations whose key is the type name and whose value is the object's type."	| list key type external |	list := self embedType: aType inList: declList.	list do: [:nameType |		nameType key notNil ifTrue:			[key := nameType key asSymbol.			type := nameType value.			external := CTypedefType new name: key; type: type.			declarations declareAt: key put: external]].	^list</body><body package="DLLCC">isPossibleInlineProcedure	"Answer true if the top stack object is a BlockClosure that creates a	 procedure type.  We need to check this in order that inline procedure	 initialization code is parsed only when defining a procedure."	^([stack last value: CIntegerType int]		on: Object errorSignal		do: [:ex | nil]) isKindOf: CProcedureType</body><body package="DLLCC">notRightBrace	"Consume tokens until a right brace is encountered."	^(token == $} or: [token == nil])		ifTrue: [false]		ifFalse: [self scanToken.  true]</body></methods><methods><class-id>External.CDeclarationParser</class-id> <category>types-syntax</category><body package="DLLCC">initTypeDecl =	[Array] typeDeclaratorWithName (initializer | [nil]) [:with:with:with:]</body><body package="DLLCC">typeDeclList =	"Parse a type declaration list and place the declarations on the stack. Answer true if the declaration was parsed, otherwise answer false."	(initTypeDecl \ $, | . compoundTypeOnStack [#()]) $;</body><body package="DLLCC">typeDeclWithName =	"Leaves name and type constructor block on the stack."	@((#'_pointer' [#bePointer]) | [nil]) (platformSpecifiers | [nil])		#* typeQualifier typeDeclarator			[embedPointer:platformQualifiers:qualifiers:ofName:typeBlock:] |	@(platformSpecifiers | [nil])		typeDeclarand [self emptyBlock] declMod*! [embedDeclarand:ofName:typeBlock:] |	"Following must use @ in case the next thing is actually a procedure argument list"	@ $( typeDeclarator $) declMod*!</body><body package="DLLCC">typeDeclarand	tokenType == #word		ifFalse: [^false].	stack addLast: token.	self scanToken.	^true</body><body package="DLLCC">typeDeclarator =	"Leaves name and type constructor block on stack"	typeDeclWithName |	@ [nil] [self emptyBlock] declMod*!</body><body package="DLLCC">typeDeclaratorWithName =	"Leaves name and type constructor block on the stack."	typeDeclWithName |	"No name, must have declMod."	@ [nil] [self emptyBlock] declMod declMod*!</body></methods><methods><class-id>External.CDeclarationParser</class-id> <category>types-actions</category><body package="DLLCC">embedInitializerType: baseType inList: declList	"Answer a collection of associations.  Each association's key is the name of the declaration.  Each association's value is another association whose key is the declaration's type and whose value is an optional initializer.  The initializer is type specific.  Examples include an Integer or Integer Array for inline code procedure types and nil for most other types."	^declList collect:		[:decl3 |  "name, type block, initializer"		(decl3 at: 1) -&gt;			((decl3 at: 2) isNil				ifTrue: [baseType -&gt; (decl3 at: 3)]				ifFalse: [((decl3 at: 2) value: baseType) -&gt; (decl3 at: 3)])]</body></methods><methods><class-id>Kernel.ExtendedCompiler</class-id> <category>accessing</category><body package="DLLCC">external	"Answer the external object the receiver is compiling."	^external</body><body package="DLLCC">external: anExternal	"Remember the external object the receiver is compiling."	external := anExternal</body><body package="DLLCC">methodClass	"Answer the class to be used for creating methods."	"We delegate this responsibility to the external object which can determine the type of method to use."	external isNil		ifTrue: [^super methodClass]		ifFalse: [^external methodClassIn: self targetClass]</body><body package="DLLCC">targetClass	"Answer the target interface class the receiver is compiling code for."	^targetClass instanceBehavior</body></methods><methods><class-id>Kernel.ExtendedCompiler</class-id> <category>private</category><body package="DLLCC">translate: aStream noPattern: noPattern ifFail: failBlock needSourceMap: mapFlag handler: handler	"noPattern is true for evaluation, false for compilation"	"Make special provisions for compiling methods in classes that still use the old parser."	| methodNode holder codeStream method parser strongPointers |	parser := class parserClass new.	methodNode := parser				parse: aStream				class: class				environment: self environment				noPattern: noPattern				context: context				notifying: handler				builder: ProgramNodeBuilder new				saveComments: mapFlag				ifFail: [^failBlock value].	(BlockAnalyzer new analyze: methodNode inClass: class context: context) storeHintsForStandardSmalltalk.	handler selector: methodNode selector.	"save selector in case of error"	codeStream := self newCodeStream.	strongPointers := OrderedCollection new.	self external: parser external.	self external notifyCompilationOfTypeDefinitionFromClass: class.	parser externals notNil		ifTrue: 			[| targetClassExternals |			targetClassExternals := self targetClass externals.						[parser externals ownKeysAndValuesDo: 					[:key :anExternal |					| existingAssociation |					"keep a strong reference to the existing external in case					the garbage collector throws it out between the next two					statements"					existingAssociation := targetClassExternals associationAt: key ifAbsent: [nil].					targetClassExternals installAt: key put: anExternal.					strongPointers add: (targetClassExternals associationAt: key).					existingAssociation yourself.		"to keep the compiler happy"					targetClassExternals weakenAt: key]]					on: Object errorSignal					do: 						[:ex |						UserNotification raiseSignal: ex description.						failBlock value]].	codeStream		class: targetClass outerScope: (self scopeForMethod: methodNode);		requestor: handler.	mapFlag ifTrue: [codeStream saveSourceMap].	noPattern ifTrue: [methodNode emitValue: codeStream inContext: context] ifFalse: [methodNode emitEffect: codeStream].	method := codeStream makeMethod: methodNode.	"The following seems like a hack but there doesn't seem to be a clean way	to initialize the new method given the current external unless CompiledMethod	is taught about externals which doesn't seem right either."	[method for: (self targetClass externals associationAt: self external name) selector: methodNode selector]		on: Object messageNotUnderstoodSignal		do: [:ex | ex return].	"WE NO LONGER:	 Generate methods for implicit externals, such as for 'bar' in 'typedef struct bar {..} foo'.	 But be careful not to overwrite methods that have yet to be compiled, i.e. as happens	 on recompiling Parcel loads."	"strongPointers do: [:assoc |		assoc key ~~ self external name ifTrue:			[(self targetClass includesSelector: assoc key) ifFalse:			 	[self targetClass generateMethodsForExternal: assoc value]]]."	"If the method contains an attribute, reset the method to be an AnnotatedMethod.	 Note that AnnotatedMethods are mutually exclusive with ExternalMethods -- one	 can't have both yet."	method := method withAdditionalPropertiesFrom: methodNode.	holder := self newMethodHolder.	holder node: methodNode.	holder method: method.	mapFlag ifTrue: [holder sourceInfo: codeStream sourceInfo].	^holder</body></methods><methods><class-id>Kernel.ExtendedCompiler class</class-id> <category>parsing</category><body package="DLLCC">preferredParserClass	^ExtendedParser</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>#directives-syntax</category><body package="DLLCC">directive	"Handling of directives depends on skip level."	^skipLevel &gt; 1		ifTrue: [self directive2]		ifFalse:			[skipLevel = 1				ifTrue: [self directive1]				ifFalse: [self directive0]]</body><body package="DLLCC">directive0 =	"When skipLevel=0, pay attention to all directives."	word=#if expression [if:]. |	word=#else [self enterSkip]. |	word=#elif [self enterSkip]. |	word=#pragma [self skipDirective]. |	word=#error [self preprocessorError]. |	word=#line [self skipDirective]. |	word=#indent [self skipDirective]. |	word=#assert assertDirective |	word=#unassert unassertDirective |	$# [self skipDirective]. |	word=#endif		[directiveTakenStack last ifFalse: [self exitSkip].		directiveTakenStack removeLast.		self skipDirective]. |	[self saveReservedWords]. word=#undef [self restoreReservedWords]. word [undef:]. |	word=#ifdef [self restoreReservedWords]. word [defined:] [if:]. |	word=#ifndef [self restoreReservedWords]. word [defined:] [ifnot:]. |	[dontStepPastEnd := true]. word=#define defineExpression [dontStepPastEnd := false]. |	[dontStepPastEnd := false]. [self restoreReservedWords]. word=#include [self include] |	[self skipDirective].</body><body package="DLLCC">directive1 =	"When skipLevel=1, pay attention to all conditional directives."	word=#else [directiveTakenStack last ifFalse: [directiveTakenStack removeLast; addLast: true. self exitSkip]]. |	word=#elif [self exitSkip]. expression [elif:]. |	directive2</body><body package="DLLCC">directive2 =	"When skipLevel &gt; 1, only pay attention to if and endif."	[self saveReservedWords].	(word=#if | word=#ifdef | word=#ifndef) [directiveTakenStack addLast: false. self enterSkip]. [self restoreReservedWords]. |	[self restoreReservedWords]. word=#endif [directiveTakenStack removeLast. self exitSkip. self skipDirective].</body><body package="DLLCC">macroArg =	"Handle a macro argument. Remember the current state of the input stream by pushing the look-ahead character, the current source stream, and the current index within the stream.  Parse the argument, then construct the argument as a String and push it onto the stack."	[self source] &lt;&lt; ($( (nestedMacroArg | $,)*! $) | notArgEnd)*! [self pushMacroArg]</body><body package="DLLCC">macroArgList =	"To avoid premature lookahead, we don't recognize the final ), but leave that to the caller."	$( macroArg ($, macroArg )*!</body><body package="DLLCC">macroArguments: numArgs	"Collect and return the arguments for a preprocessor macro.  Answer an empty array if the argument, numArgs, is nil (i.e. don't bother scanning for arguments).  Answer nil if the argument numArgs is greater than 0 but the next token is not an open parenthesis.  Otherwise, scan the stream for the macro arguments and answer an array of those arguments."	| depth args |	numArgs isNil ifTrue: [^#()].  "no args"	depth := stack size.	self beginDirective.	typeTable := ATypeTable.  "cr is whitespace"	self backupSave.	self scanToken.	(numArgs &gt; 0 and: [tokenType ~~ #leftParenthesis])		ifTrue: [self backupRestore. self endDirective. ^nil].	self backupDiscard.	self macroArgList ifFalse: [self error: (#InvalidMacroCall &lt;&lt; #dllcc &gt;&gt; 'Invalid macro call.')].	token == $) ifFalse: [self error: (#InvalidMacroCall &lt;&lt; #dllcc &gt;&gt; 'Invalid macro call.')].	args := stack removeLast: stack size - depth.	((numArgs = 0 and: [args size = 0 or: [args size = 1 and: [(args at: 1) isEmpty]]])		or: [args size = numArgs])		ifFalse: [self error: (#WrongOfArgsForMacro &lt;&lt; #dllcc &gt;&gt; 'Wrong # of args for macro.')].	self endDirective.	^args</body><body package="DLLCC">nestedMacroArg =	"Handle a nested macro argument."	$( (nestedMacroArg | $,)*! $) | notArgEnd</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>#directives-actions</category><body package="DLLCC">define: aName argNames: argNames	"Define a macro named aName with argument names argNames."	| defn dict start positions index end body name |	name := aName asSymbol.	defn := CMacroDefinition new name: name argNames: argNames.	dict := Dictionary new: 10.	argNames ~~ nil ifTrue:		[1 to: argNames size do: [:i |			dict at: (argNames at: i) put: i]].	"Scan the definition, noting positions of arguments.	 The continuation count must be reset since the definition will be rescanned."	continuationCount := 0.	start := mark.	positions := (Array new: 20) writeStream.	[tokenType == #cr	 or: [hereChar == nil and: [token == nil]]] whileFalse:		[(tokenType == #word and: [(index := dict at: token ifAbsent: [nil]) notNil]) ifTrue:			[sourceUsesCRLF				ifTrue: [positions nextPut: mark - continuationCount - start -&gt; index]				ifFalse: [positions nextPut: mark - start -&gt; index]].		 self scanToken].	"Back up and copy the entire definition."	hereChar == nil		ifTrue:			[token ~~ Character cr				ifTrue: [end := source position + 1]				ifFalse: [end := prevEnd + 1]]		ifFalse: [end := prevEnd + 1]. "1-origin, and 1 char too far back"	source position: start - 1.  "1-origin"	body := source next: ((end - start) &lt; 0							ifTrue: [0]							ifFalse: [sourceUsesCRLF										ifTrue: [end - continuationCount - start]										ifFalse: [end - start]]).	source position: (source atEnd		ifTrue:[mark - 1 "at end of file and no cr"]		ifFalse:[mark "skip over cr"]).	"Now the definition has been read its ok to step past the end (i.e. pop the include stack if required)"	dontStepPastEnd := false.	self step.	defn definition: body substitutions: positions contents.	declarations at: name put: defn.	self restoreReservedWords.	lastDefine := defn.	reservedWords at: name put: defn</body><body package="DLLCC">defineAssert: predicate value: tokenSequence	"An assertion with predicate and tokenSequence was parsed.  Register this assertion."	| previousPredicate predicateSymbol |	predicateSymbol := predicate asSymbol.	previousPredicate := assertDefines at: predicateSymbol ifAbsent: [nil].	previousPredicate == nil		ifTrue:			[assertDefines				at: predicateSymbol				put: (OrderedCollection with: tokenSequence)]		ifFalse:			[(previousPredicate includes: tokenSequence)				ifFalse: [previousPredicate add: tokenSequence]]</body><body package="DLLCC">defined: key	"Answer 1 if the argument is already defined, otherwise answer 0."	| definition |	definition := declarations at: key asSymbol ifAbsent: [nil].	^(definition notNil and: [definition class == CMacroDefinition])		ifTrue: [1]		ifFalse: [0]</body><body package="DLLCC">elif: condition	"If the argument is false (0), enter directive skip."	condition = 0		ifTrue: [self enterSkip]		ifFalse: [directiveTakenStack removeLast; addLast: true]</body><body package="DLLCC">enterSkip	skipLevel := skipLevel + 1</body><body package="DLLCC">exitSkip	skipLevel &gt; 0 ifTrue: [skipLevel := skipLevel - 1]</body><body package="DLLCC">if: condition	"If the argument is false (0), enter directive skip."	condition = 0		ifTrue: [self enterSkip. directiveTakenStack addLast: false]		ifFalse: [directiveTakenStack addLast: true]</body><body package="DLLCC">ifnot: condition	condition = 0		ifTrue: [directiveTakenStack addLast: true]		ifFalse:			[self enterSkip.			directiveTakenStack addLast: false]</body><body package="DLLCC">include	"Handle an include directive."	| fileName local file |	token == #&lt;		ifTrue:			[| fstr |			fstr := (String new: 40) writeStream.			[hereChar = $&gt;]				whileFalse:					[(hereChar = Character cr or: [hereChar == nil])						ifTrue: [^false].					fstr nextPut: hereChar.					self step].			self step.			fileName := fstr contents.			local := false]		ifFalse:			[tokenType == #string				ifTrue:					[fileName := String new.					[tokenType ~~ #cr and: [token ~~ nil and: [tokenType == #string]]]						whileTrue:							[fileName := fileName,								(token copyFrom: 2 to: token size -1).							self scanToken].					local := true]				ifFalse: [^false]].	"Skip to the end of the line."	[tokenType == #cr or: [token == nil]] whileFalse: [self scanToken].	file := local		ifTrue: [self read: fileName localOrInDirectories: includeDirectories]		ifFalse: [self read: fileName inDirectories: includeDirectories].	file lineEndAuto.	"The following should really create a new CPreprocessor and stack it	rather than changing the current one to parse the new header file."	self pushIncludeStack.	self endDirective.  "restore scanner tables to normal state"	self on: file.	tokenType := nil.	hereChar := source next.	^true</body><body package="DLLCC">preprocessorError	"A #error preprocessor error was encountered.  Scan to the end-of-line and display the error message in the transcript."	Transcript show: self scanErrorString; cr</body><body package="DLLCC">pushMacroArg	"Answer a string representing the currently parsed macro argument.  The top stack entry is the start index for the macro argument string, the second stack entry is the stream associated with startIndex, the third stack entry is the look-ahead character for the stream that was pushed onto the stack just prior."	| startIndex aStream oldPosition aMacroArg argLen |	startIndex := stack removeLast.	aStream := stack removeLast.	oldPosition := aStream position.	argLen := oldPosition - 1 - startIndex.	hereChar isNil ifTrue: [argLen := argLen+1].	(hereChar == Character cr and: [self streamUsesCRLF: aStream]) ifTrue: [argLen := argLen - 1].	aStream position: startIndex - 1.	aMacroArg := (aStream next: argLen) replaceAll: Character cr with: $ .	aStream position: oldPosition.	^aMacroArg</body><body package="DLLCC">restoreReservedWords	"Restore the current reserved word dictionary."	saveReservedWords == nil		ifFalse:			[reservedWords := saveReservedWords.			saveReservedWords := nil]</body><body package="DLLCC">saveReservedWords	"Save the current reserved word dictionary and reset it to an empty dictionary."	saveReservedWords := reservedWords.	reservedWords := Dictionary new.</body><body package="DLLCC">scanErrorString	"Answer a string consisting of the tokens following an #error directive, up to the end-of-line marker."	| cr errorStream |	cr := Character cr.	errorStream := WriteStream on: String new.	token isString		ifTrue: [errorStream nextPutAll: token; nextPut: Character space]		ifFalse: [errorStream print: token].	[hereChar == nil or: [hereChar == cr]]		whileFalse: [			errorStream nextPut: hereChar. 			hereChar := source next].	hereChar == nil ifFalse: [hereChar := source next].	tokenType := nil.	^errorStream contents</body><body package="DLLCC">source	"Answer the current parser's source stream."	^source</body><body package="DLLCC">undef: key	"Handle the #undef directive.  Undefine the argument."	| rwords name |	name := key asSymbol.	declarations removeKey: name ifAbsent: [nil].	"If the macro shadowed a reserved word, undo this now."	rwords := self class reservedWords.	(rwords includesKey: name)		ifTrue: [reservedWords at: name put: true]		ifFalse: [reservedWords removeKey: name ifAbsent: []]</body><body package="DLLCC">undefineAssert: predicate value: tokenSequence	"An unassertion with predicate and tokenSequence was parsed.  Undefiner this assertion."	| predicateSymbol |	predicateSymbol := predicate asSymbol.	tokenSequence isEmpty		ifTrue: [assertDefines removeKey: predicateSymbol ifAbsent: [nil]]		ifFalse:			[| previousPredicate |			previousPredicate := assertDefines at: predicateSymbol ifAbsent: [nil].			previousPredicate == nil				ifFalse: [previousPredicate remove: tokenSequence]]</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>preprocessing</category><body package="DLLCC">outputToken: aToken type: aTokenType lastWasString: lastWasString on: aStream	"Place the argument, aToken, of type aTokenType (a Symbol indicating the type of token) on the argument aStream. Answer true if the last token placed on the stream was a String so the appropriate space can be added, otherwise answer false."	(aToken isKindOf: Character)		ifTrue:			[aStream nextPut: aToken.			^false].	(lastWasString and: [(aTokenType == #binary) not])		ifTrue: [aStream nextPut: $ ].	(aToken isKindOf: String)		ifTrue: [aStream nextPutAll: aToken]		ifFalse:			[aToken class == LargePositiveInteger				ifTrue: [self printHexNumber: aToken on: aStream]				ifFalse:					[aStream nextPutAll: aToken printString.					"We don't use isKindOf: for speed."					(aToken  class == Float) ifTrue: [aStream nextPut: $f]]].	^(aTokenType == #binary) not</body><body package="DLLCC">preprocess	"Answer a string representing aStream with all pre-processing directives stripped and evaluated."	| lastTokenWasStringy |	lastTokenWasStringy := false.	[stack isEmpty ifFalse: [stack removeLast].	token == nil		ifTrue: [true]		ifFalse:			["Inlined for speed."			"lastTokenWasStringy :=				self outputToken: token				type: tokenType				lastWasString: lastTokenWasStringy				on: outputStream."			(token isKindOf: Character)				ifTrue:					[lastTokenWasStringy := false.					outputStream nextPut: token]				ifFalse:					[(lastTokenWasStringy and: [(tokenType == #binary) not])						ifTrue: [outputStream nextPut: $ ].					(token isKindOf: String)						ifTrue: [outputStream nextPutAll: token]						ifFalse:							[token class == LargePositiveInteger								ifTrue: [self printHexNumber: token on: outputStream]								ifFalse:									[outputStream nextPutAll: token printString.									"We don't use isKindOf: for speed."									(token  class == Float) ifTrue: [outputStream nextPut: $f]]].					lastTokenWasStringy := (tokenType == #binary) not].			self scanToken == nil and: [includeStack isEmpty]]]		whileFalse.	^outputStream</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>private-scanning</category><body package="DLLCC">scanToken	"Scan the input stream for a single token."	| skipped isWideLiteral |	isWideLiteral := tokenType == #word					and: [token = 'L'					and: [hereChar == $' or: [hereChar == $"]]].	[skipped := 0.	[hereChar == nil		ifTrue:  "end of input"			["skipLevel &gt; 0				ifTrue: [self offEnd: 'Unterminated conditional']."			prevEnd := source position.			mark := prevEnd + 1.			tokenType := #doIt.			^token := nil].	(tokenType := typeTable at: hereChar asInteger) == #xDelimiter]		whileTrue:  "Skip delimiters fast, there almost always is one."			[skipped := skipped + 1.			"open code step for speed"			[hereChar := source next.			hereChar == nil ifTrue: [self stepPastEnd].			hereChar == $\ and: [source peekFor: Character cr]]				whileTrue: [skipped := skipped + 1. continuationCount := continuationCount + 1]].	mark := source position.	"The following is a hack for platforms that support CRLF - the mark should be adjusted."	(hereChar == Character cr and: [sourceUsesCRLF]) ifTrue: [mark := mark - 1].	prevEnd := mark - skipped - 1.	tokenType isSymbol		ifTrue:  "single-character token"			[token := hereChar.			self step]		ifFalse:			[buffer reset.			[tokenType isSymbol]				whileFalse:					[buffer nextPut: hereChar.					self step.					tokenType := tokenType value at: hereChar ifAbsent: [tokenType key]].			(tokenType at: 1) == $x				ifTrue: [self perform: tokenType]				ifFalse: [token := buffer contents]].	tokenType isNil or: [skipLevel &gt; ignoreSkipLevel]]		whileTrue.  "loop until we have a real token"	(isWideLiteral	and: [token isString]) ifTrue:		[token := token asTwoByteString].	^token</body><body package="DLLCC">step	"Override the super class implementation handle line-splicing with \, and to handle #includes and macros.  If the end of an include file is encountered, we step back one level to the previous include file before continuing."	| aChar |	[aChar := hereChar.	hereChar := source next.	hereChar == nil ifTrue: [self stepPastEnd].	hereChar == $\ and: [source peekFor: Character cr]]		whileTrue: [continuationCount := continuationCount + 1].	^aChar</body><body package="DLLCC">stepPastEnd	"We just ran off the end of the source, while attempting to refill hereChar.  If we are in an #include or a macro, pop the stack. "		[includeStack isEmpty]		whileFalse:			[dontStepPastEnd				ifTrue: [^self]				ifFalse:					[self popIncludeStack.					hereChar := source next.					hereChar notNil ifTrue: [^self]]].	"No more input."	hereChar := nil</body><body package="DLLCC">xCR	"We just saw a CR.  Look ahead for a preprocessor directive."	[self skipWhitespace.	 (hereChar == $# or: [token == $#]) ifFalse: [tokenType := nil.  ^self].	 hereChar == $# ifTrue: [self step].	 [self beginDirective.	  self scanToken.	  self directive]	 	ensure: [self endDirective]] repeat</body><body package="DLLCC">xWord	"Handle a word, may be reserved or a macro."	| defn args currentMacroScan macroExpansion tokenSymbolOrNil |		token := buffer contents.	(inMacroScan	 or: [skipLevel &gt; 0	 or: [(tokenSymbolOrNil := Symbol findInterned: token) == nil	 or: [(defn := reservedWords at: tokenSymbolOrNil ifAbsent: [nil]) == nil]]])		ifTrue:			[tokenType := #word. ^self].	defn == true ifTrue:		[tokenType := tokenSymbolOrNil. ^self].  "reserved word"	"Token is a preprocessor macro.  Expand it."	currentMacroScan := inMacroScan.	inMacroScan := true.	args := self macroArguments: defn numArgs.	args == nil ifTrue:		[inMacroScan := currentMacroScan.		token := tokenSymbolOrNil asString.		tokenType := #word.		^self].	macroExpansion := defn expandWithArguments: args.		macroExpansion = '' ifTrue:		[inMacroScan := currentMacroScan.		token := ''. tokenType := #word.		^self].	macroExpansion asSymbol == defn name		ifTrue:			[inMacroScan := currentMacroScan.			token := macroExpansion.			tokenType := #word.			^self].	"The following should really create a new CPreprocessor and	 stack it rather than changing the current one."	self pushIncludeStack.	self on: macroExpansion readStream.	inMacroScan := currentMacroScan.	tokenType := nil.	hereChar := source next</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>initialize-release</category><body package="DLLCC">predefine: aName as: aString	"Define the argument, aName, to be the string, aString.	 Disallow redefinition of already declared names."	| defn name |	name := aName asSymbol.	(declarations includesKey: aName) ifFalse:		[defn := CMacroDefinition new.		 defn name: name argNames: nil.		 defn definition: aString substitutions: #().		 declarations at: name put: defn.		 reservedWords at: name put: defn]</body><body package="DLLCC">preprocess: stringOrStream declarations: predefinedDeclarations includeDirectories: directoryArray	^self		preprocess: stringOrStream		declarations: predefinedDeclarations		includeDirectories: directoryArray		outputStream: (ReadWriteStream on: String new)</body><body package="DLLCC">preprocess: stringOrStream declarations: predefinedDeclarations includeDirectories: directoryArray outputStream: aStream	self declarations: predefinedDeclarations.	self predefineNames.	self includeDirectories: directoryArray.	self init: stringOrStream notifying: nil failBlock: nil.	self outputStream: aStream.	^self preprocess</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>private</category><body package="DLLCC">fastInit	inMacroScan := false.	skipLevel := ignoreSkipLevel := 0.	includeStack := OrderedCollection new.	directiveTakenStack := OrderedCollection new.	lastDefine := nil.	dontStepPastEnd := false.	saveDefines := IdentityDictionary new.	assertDefines := IdentityDictionary new.	continuationCount := 0.	super fastInit</body><body package="DLLCC">includeDirectories: anOrderedCollection	includeDirectories := anOrderedCollection</body><body package="DLLCC">popIncludeStack	"The current source stream was just exhausted.  Pop the topmost stream information set off the include stack."	| sourcePosition |	source close.	mark := includeStack removeFirst.	sourcePosition := includeStack removeFirst.	self source: includeStack removeFirst.	source position: sourcePosition.</body><body package="DLLCC">predefineNames	"Predefine all the ANSI preprocessor identifiers.  We do not guard against them being undefined or redefined.  Answer the receiver."	self		predefine: #'__LINE__' as: '0';		predefine: #'__FILE__' as: '';		predefine: #'__DATE__' as: '"', Date today printString, '"';		predefine: #'__TIME__' as: '"', Time now printString, '"';		predefine: #'__STDC__' as: '1'</body><body package="DLLCC">pushIncludeStack	"Place on the include stack all the stream information required to parse a new source stream and when complete, re-install the current stream for further processing."	hereChar notNil ifTrue: [source skip: -1].  "back up 1 char"	includeStack addFirst: source.	includeStack addFirst: source position.	includeStack addFirst: mark</body><body package="DLLCC">read: aFileTail inDirectories: aDirectoryNames 	"Look for file in directories and return a ReadStream if found."	| filename |	filename := nil.	aDirectoryNames detect: 			[:eachDir | 			filename := eachDir asFilename construct: aFileTail.			filename exists and: [filename isReadable]]		ifNone: 			[self error: (#CantFindFile1s &lt;&lt; #dllcc &gt;&gt; 'Can''t find file: &lt;1s&gt;' 						expandMacrosWith: aFileTail)].	declarations removeKey: #__FILE__ ifAbsent: [].	"we have to remove it so we can predefine it"	self predefine: #__FILE__ as: filename asResolvedString.	^filename readStream</body><body package="DLLCC">read: aFileTail localOrInDirectories: aDirectoryNames 	"Look for file in local directory and directories and return a ReadStream if found."	^self read: aFileTail inDirectories: #('.') , aDirectoryNames</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>#directives-parsing</category><body package="DLLCC">assertDirective =	"A #assert directive was encountered.  Parse the remainder of the assertion.  An assertion takes the following form:	#assert predicate(tokenSequence) |	#assert predicate	Assertion predicates are in a different namespace than macros."	word ($( notRightParenthesisWithPush* $) | [#()]) [defineAssert:value:]</body><body package="DLLCC">beginDirective	typeTable := DTypeTable.  "cr is now a real token"	ignoreSkipLevel := SmallInteger maxVal.  "don't skip tokens"	continuationCount := 0 "starting a new directive resets the continuationCount"</body><body package="DLLCC">defineExpression =	"Answer a define expression."		word (@ noSpace $( word \ $, $) | @ noSpace $( $) [#()] | [nil]) [define:argNames:].</body><body package="DLLCC">endDirective	"A directive has been successfully parsed.  Cleanup the effects of #beginDirective."	typeTable := self class typeTable.	ignoreSkipLevel := 0</body><body package="DLLCC">hashToken	^token = #'#' and: [self scanToken. true]</body><body package="DLLCC">noSpace	"Test whether the current token immediately followed the previous one."	^mark = (prevEnd + 1)</body><body package="DLLCC">notArgEnd	"Answer true if the end of a macro argument is reached, false otherwise."	^(token == $, or: [token == $) or: [token == nil]])		ifTrue: [false]		ifFalse: [self scanToken.  true]</body><body package="DLLCC">notRightParenthesisWithPush	"Consume a token if a right brace is not encountered and push the token on the stack"	^(token == $) or: [token == nil])		ifTrue: [false]		ifFalse: [stack addLast: token. self scanToken.  true]</body><body package="DLLCC">skipDirective	"Skip the rest of an unrecognized directive."	[(hereChar == nil) not and: [token ~= Character cr or: [token == $\]]]		whileTrue: [self scanToken]</body><body package="DLLCC">unassertDirective =	"A #unassert directive was encountered.  Parse the remainder of the unassertion.  An unassertion takes the following form:	#unassert predicate(tokenSequence) |	#unassert predicate	Assertion/unassertion predicates are in a different namespace than macros."	word ($( notRightParenthesisWithPush* $) | [#()]) [undefineAssert:value:]</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>expressions-actions</category><body package="DLLCC">exprAssert: key value: tokenSequenceArray	"Answer a block accepting a single argument, the current declaration environment, that when evaluated will answer 1 if the assertion key with arguments tokenSequenceArray is asserted."	^[:environment | | tokenCollection |			tokenCollection := assertDefines at: key asSymbol ifAbsent: [nil].			tokenCollection == nil				ifTrue: [0]				ifFalse:					[(tokenCollection						detect: [:tokenSequence | tokenSequence = tokenSequenceArray]						ifNone: [nil]) == nil						ifTrue: [0]						ifFalse: [1]]]</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>accessing</category><body package="DLLCC">defineOrSingleDeclaration        "The single define was parsed and created during the initial scan of the input stream so simply answer the receiver."        ^self</body><body package="DLLCC">lastDefine	"Answer the last macro definition encountered in the current parse."	^lastDefine</body><body package="DLLCC">outputStream: aStream	"Set the stream the receiver is to place all preprocessing output into.  Answer the receiver."	outputStream := aStream</body></methods><methods><class-id>External.CPreprocessor</class-id> <category>expressions-syntax</category><body package="DLLCC">parsePrimary =	[self saveReservedWords].	word=#defined		(( $( variableName [self restoreReservedWords]. $) ) |		variableName [self restoreReservedWords]. )		 [defined:] |	hashToken word $( notRightParenthesisWithPush + $)		[self restoreReservedWords]. [exprAssert:value:] |	[self restoreReservedWords].	variableName [exprVariable:] |	number [compressNumber:] | character [:asInteger] | scanString |	$( expression $)</body></methods><methods><class-id>External.CPreprocessor class</class-id> <category>private</category><body package="DLLCC">computeTables: aTypeTable	"Compute the cached type tables used during preprocessing.  Please see the class comments for more details.  Answers the receiver."	| newTypeTable |	newTypeTable := aTypeTable copy.	newTypeTable		at: Character cr asInteger		put: #cr.  "cr is a token within directives"	DTypeTable := newTypeTable.	newTypeTable := newTypeTable copy.	newTypeTable		at: Character cr asInteger		put: #xDelimiter.  "cr is whitespace in macro arguments"	ATypeTable := newTypeTable</body><body package="DLLCC">typeTable	"Answer the type table for the receiver.  We currently share the	 same type table with the superclass CScanner.  If this type table	 has changed, recompute the cached preprocessing type tables,	 otherwise simply answer the old table."	| aTypeTable |	aTypeTable := superclass typeTable.	(aTypeTable == typeTable	and: [ATypeTable notNil	and: [DTypeTable notNil]])		ifTrue: [^typeTable]		ifFalse:			[self computeTables: aTypeTable.			^typeTable := aTypeTable]</body></methods><methods><class-id>External.CPreprocessor class</class-id> <category>preprocessing</category><body package="DLLCC">preprocess: stringOrStream	"Preprocess the data contained in the argument.  The argument can be a String object, in which case the String is preprocessed.  The argument can also be a Stream, in which case the contents of the stream are preprocessed.  This method uses an empty symbol environment dictionary.  Use the method #preprocess:declarations: if you need to supply your own pre-declared symbols.  Answers a Stream containing the preprocessed source with the stream set to the end."	^self preprocess: stringOrStream declarations: ExternalDictionary new</body><body package="DLLCC">preprocess: stringOrStream declarations: declarationDictionary	"Preprocess the data contained in the argument.  The argument can be a String object, in which case the String is preprocessed.  The argument can also be a Stream, in which case the contents of the stream are preprocessed.  This method uses the environment dictionary indicated by the argument declarationDictionary which should be an ExternalDictionary.  Use the method #preprocess: if you do not need to supply your own pre-declared symbols.  Answers a Stream containing the preprocessed source with the stream set to the end."	^self preprocess: stringOrStream declarations: declarationDictionary includeDirectories: #()</body><body package="DLLCC">preprocess: stringOrStream declarations: declarationDictionary includeDirectories: includeDirectoriesStringArray	"Preprocess the data contained in the argument stringOrStream.  The argument can be a String object, in which case the String is preprocessed.  The argument can also be a Stream, in which case the contents of the stream are preprocessed.  This method uses the environment dictionary indicated by the argument declarationDictionary which should be an ExternalDictionary.  Include file directives found in the input source will be searched in the directories indicated by the argument, includeDirectoriesStringArray.  It is an Array of String objects, each String specifying a directory path.  Answers a Stream containing the preprocessed source with the stream set to the end."	^self new		preprocess: stringOrStream		declarations: declarationDictionary		includeDirectories: includeDirectoriesStringArray</body><body package="DLLCC">preprocess: stringOrStream includeDirectories: includeDirectoriesStringArray	"Preprocess the data contained in the argument stringOrStream.  The argument can be a String object, in which case the String is preprocessed.  The argument can also be a Stream, in which case the contents of the stream are preprocessed.  This method uses an empty environment dictionary.  Include file directives found in the input source will be searched in the directories indicated by the argument, includeDirectoriesStringArray.  It is an Array of String objects, each String specifying a directory path.  Answers a Stream containing the preprocessed source with the stream set to the end."	^self		preprocess: stringOrStream		declarations: ExternalDictionary new		includeDirectories: includeDirectoriesStringArray</body></methods><methods><class-id>Kernel.ExtendedParser</class-id> <category>externals</category><body package="DLLCC">external	^external</body><body package="DLLCC">externalCCallWithArguments: argNames	"Invoke a CParser on source, which parses a C declaration until and including the $&gt; token.  Set the source pointer back to the point right after this token for subsequent parsing of the failure code by self (the Smalltalk parser).  Generate and return Smalltalk code (as a stream) that calls the C function, to be subsequently parsed by self.  argNames, the method's arguments, are used as arguments for the C call."	| interfaceClass assignedName |	self resetSourceToLastToken.	interfaceClass := self interfaceClass.	externals := interfaceClass tempExternals.	external := self parseDefineOrSingleDeclaration: externals.	(external isKindOf: Association)		ifTrue:			[assignedName := external key.			external := external value].	^external callStreamArgs: argNames assign: assignedName interface: interfaceClass</body><body package="DLLCC">externalCallWithArguments: argNames	"Generate an external language declaration using the external function argument names indicated by the argument.  Answer nil if the generation failed, otherwise answer a Stream containing the contents of the external declaration."	"Currently only &lt;C: &gt; syntax is supported."	ExternalInterface externalCompilerClass isNil ifTrue:		[(requestor isKindOf: SilentCompilerErrorHandler)			ifTrue: [self skipPrimitive. ^'' readStream] "doing explain"			ifFalse: [^ExternalInterface externalCompilerMissingError]].	(self matchToken: 'C:') ifTrue: [^self externalCCallWithArguments: argNames].	^nil</body><body package="DLLCC">externals	^externals</body><body package="DLLCC">skipPrimitive	[token == #&gt;] whileFalse: [self scanToken]</body></methods><methods><class-id>Kernel.ExtendedParser</class-id> <category>statements</category><body package="DLLCC">statements	| stmts returnStart |		stmts := OrderedCollection new.	[tokenType == #upArrow		ifTrue: 			[returnStart := mark.			self scanToken.			self expression				ifFalse: [^self expected: 'Expression to return'].			self addComment.			parseNode := builder newReturnValue: parseNode.			parseNode sourcePosition: (returnStart to: self endOfLastToken).			stmts addLast: parseNode.			self match: #period.  "allow optional trailing . after ^"			false]		ifFalse: 			[self expression				ifTrue: 					[self addComment.					stmts addLast: parseNode.					self match: #period]				ifFalse: 					[self addComment.					false]]]		whileTrue: [].	^stmts</body><body package="DLLCC">statementsArgs: argNodes temps: oldTemps statements: oldStatements	"oldTemps is nil if temps should be parsed.	This is for compatibility with the old language,	so that temps can be parsed before the	primitive specification."	| tempNodes stmts start blockComment returnStart |	tempNodes := oldTemps isNil		ifTrue: [self temporaries]		ifFalse: [oldStatements isNil					ifTrue: [oldTemps]					ifFalse: [oldTemps, self temporaries]].	stmts := oldStatements isNil ifTrue: [OrderedCollection new] ifFalse: [oldStatements].	"give initial comment to block, since others trail statements"	blockComment := currentComment.	currentComment := nil.	start := endTemps.	[tokenType == #upArrow		ifTrue: 			[returnStart := mark.			self scanToken.			self expression				ifFalse: [^self expected: 'Expression to return'].			parseNode := builder newReturnValue: parseNode.			self addComment.			parseNode sourcePosition: (returnStart to: self endOfLastToken).			stmts addLast: parseNode.			self match: #period.  "allow optional trailing . after ^"			false]		ifFalse: 			[self expression				ifTrue: 					[self addComment.					stmts addLast: parseNode.					self match: #period]				ifFalse: [false]]]		whileTrue.	self addComment.	(stmts size = 1 and: [blockComment == nil and: [parseNode := stmts first.  parseNode sourcePosition == nil and: [tempNodes isEmpty]]])		ifTrue:			["No point in building a sequence"]		ifFalse:			[parseNode := builder newSequenceTemporaries: tempNodes statements: stmts.			parseNode addComment: blockComment].	parseNode sourcePosition: (start to: self endOfLastToken+1).	parseNode := builder newBlockArguments: argNodes body: parseNode</body></methods><methods><class-id>Kernel.ExtendedParser</class-id> <category>public access</category><body package="DLLCC">parseArgsAndTemps: aString notifying: req 	"For the explainer, parse the string and answer with an Array of Strings (the arg and temp names)."	^self		initPattern: aString		notifying: req		saveComments: false		return: [:pattern |			(self matchToken: #&lt;)				ifTrue: [self skipPrimitive].  "skip primitive if any"			self temporaries collect: [:param | param name asString]]</body></methods><methods><class-id>Kernel.ExtendedParser</class-id> <category>scanning</category><body package="DLLCC">resetSourceToLastToken	source position: self endOfLastToken.</body></methods><methods><class-id>Kernel.ExtendedParser</class-id> <category>expression types-^value/error</category><body package="DLLCC">pragmaKeywords	"Answer an Array of Symbols that identify the method pragma keywords supported by the receiver."	^super pragmaKeywords, #(#C:)</body></methods><methods><class-id>Kernel.ExtendedParser</class-id> <category>private</category><body package="DLLCC">interfaceClass	"Answer the class that represents the external interface for the receiver's parsed code."	^requestor theClass instanceBehavior</body><body package="DLLCC">parseDefineOrSingleDeclaration: declarationDictionary	"Parse a single #define or single declaration.  Answer the declaration."	| preprocessor savedPosition isStream |	isStream := source isCharacters not.	isStream ifTrue: [savedPosition := source position].	preprocessor := CPreprocessor		parseWithNoPreprocess: source		as: #defineOrSingleDeclaration		declarations: declarationDictionary		requestor: requestor.	preprocessor lastDefine isNil ifFalse: [^preprocessor lastDefine].	isStream ifTrue: [source position: savedPosition].	^(CDeclarationParser		parseWithNoPreprocess: source		as: #defineOrSingleDeclaration		declarations: declarationDictionary		requestor: requestor) result</body></methods><methods><class-id>Kernel.ExtendedParser</class-id> <category>method</category><body package="DLLCC">method: fromDoIt context: ctxt	"pattern [ | temporaries ] block =&gt; MethodNode"	| start pat block  messageComment methodNode tempNodes statementNodes externalCallStream   |	start := mark.	pat := fromDoIt			ifTrue: 				[ctxt == nil					ifTrue: [Array with: #DoIt with: #()]					ifFalse:						[Array							with: #DoItIn: 							with: (Array with: (builder newParameterVariable:												(builder newVariableName: 'DOITCONTEXT')))]]			ifFalse:				[self pattern].	"pat={selector, arguments}"	messageComment := currentComment.	currentComment := nil.	"Parse temporaries before primitive, to allow for old language."	methodNode := builder newMethodSelector: (pat at: 1).	tempNodes := tokenType == #verticalBar		ifTrue: [self temporaries]		ifFalse:			[newLanguage				ifTrue: [nil]				ifFalse: [#()]].	(fromDoIt not and: [self matchToken: #&lt;])		ifTrue:			["First try external declaration"			| argNames |			argNames := (pat at:2) collect: [:arg | arg name].			externalCallStream := [self externalCallWithArguments: argNames]									on: Object errorSignal									do: [:ex | ^self notify: (ex messageText size &gt; 0																ifTrue: ['syntax error, ', ex messageText]																ifFalse: ['syntax error'])].			externalCallStream notNil				ifTrue:					[ | oldSource atomicMethod |					oldSource := source.					self scan: externalCallStream.					atomicMethod :=						self readStandardPragmas: methodNode temps: tempNodes.					atomicMethod isNil ifTrue: [						tempNodes := self temporaries.						statementNodes := self statements].					self scan: oldSource.					self external addBasePragmaTo: methodNode.					atomicMethod isNil ifFalse: [tempNodes := self temporaries]]				ifFalse: 					["Now try regular primitive"					self privateReadStandardPragmas: methodNode temps: tempNodes]].	self statementsArgs: (pat at: 2) temps: tempNodes statements: statementNodes.	block := parseNode.	tokenType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode block: block.	methodNode addComment: messageComment.	methodNode sourcePosition: (start to: self endOfLastToken).	^methodNode</body></methods><methods><class-id>External.ExternalObject</class-id> <category>code generating</category><body package="DLLCC">methodClassIn: anInterfaceClass	"Answer the class used to create methods when compiling the receiver in the given class."	^CompiledMethod</body></methods><methods><class-id>External.ExternalObject</class-id> <category>compiling</category><body package="DLLCC">notifyCompilationOfTypeDefinitionFromClass: aClass	^self</body></methods><methods><class-id>External.ExternalProcedure</class-id> <category>code generating</category><body package="DLLCC">callStreamArgs: argNames assign: assignee interface: aClass	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	aClass isVirtual ifTrue: [virtuals := #()].	self owner: aClass.	^aClass procedureCallStream: self args: argNames assign: assignee</body><body package="DLLCC">methodClassIn: anInterfaceClass	"Answer the class used to create methods when compiling the receiver in the given class."	^anInterfaceClass externalMethodClass</body></methods><methods><class-id>External.CMacroDefinition</class-id> <category>code generating</category><body package="DLLCC">callStreamArgs: args assign: assignee interface: aClass	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	^aClass macroCallStream: self args: args assign: assignee</body><body package="DLLCC">methodClassIn: targetClass	"Answer the class used to create methods of the receiver's type."	^CompiledMethod</body></methods><methods><class-id>External.CMacroDefinition</class-id> <category>compiling</category><body package="DLLCC">notifyCompilationOfTypeDefinitionFromClass: aClass	^self</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private-code generating</category><body package="DLLCC">errorCodeVariableName	"Answer a string that represents the name of the error code variable used when generating interface methods."	^'_errorCode'</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>public develop</category><body package="DLLCC">generateMethodsFrom: newExternals	"Generate an accessing method for each new external object	whose name matches the name of a current external object"	self updateExternalsWith: newExternals.	self externals do: [:ext |		(ext isKindOf: ExternalObject)			ifTrue: [ext owner: self]].	self generateMethods</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>testing</category><body package="DLLCC">includesExternal: aSymbol	" Answer a boolean indicating whether my or my superclasses externals include a value with a key same as &lt;aSymbol&gt;. "	(self externals includesKey: aSymbol) ifTrue: [^true].	self == ExternalInterface ifTrue: [^false].	^superclass includesExternal: aSymbol</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private-code generating</category><body package="DLLCC">macroCallStream: macro args: args assign: assignee	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	| callStream numArgs macroNumArgs |	numArgs := args size.	(macroNumArgs := macro numArgs) == nil ifTrue:		[macroNumArgs := 0].	numArgs ~= macroNumArgs ifTrue:		[self error: 'wrong number of arguments'].	callStream := ReadWriteStream on: String new.	numArgs = 0 ifTrue:		[[macro valueIn: self tempExternals args: nil]			on: Object errorSignal			do: [:ex | ].		^callStream nextPutAll: '^', macro name, ' value'; reset].	callStream nextPutAll:		'| __args | __args := Array new: ', numArgs printString, '. '.	1 to: numArgs do: [:i |		callStream nextPutAll: '__args at: ', i printString, ' put: ', (args at: i), '. '].	callStream nextPutAll: '^[', macro name, ' valueIn: self externals args: __args] on: Object errorSignal do: [:ex| ex return: ex]'.	^callStream reset</body><body package="DLLCC">methodPrimitiveCallNumber	"Answer the primitive number used to compile fully optimized external procedure methods."	^self externalMethodClass methodPrimitiveCallNumber</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>binary storage</category><body package="DLLCC">parcelClasses: aClassCollection toParcel: aParcel	"Add the classes in aClassCollection to aParcel.  Use the	 current interface version identifier as the Parcel's version."	"| parcel |	parcel := Parcel name: 'SomeName'.	SomeInterfaceClass parcelClasses: SomeInterfaceClass withAllSubclasses toParcel: parcel.	parcel saveParcelDialogFor: nil"	aClassCollection do: [:aClass |		(aClass isKindOf: ExternalInterface class) ifTrue: [aClass flushAllCaches]].	aClassCollection do: [:aClass| aParcel addClassAndAllSelectors: aClass].	aParcel propertyAt: #version put: self version</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private-code generating</category><body package="DLLCC">procedureAtomicCallStream: procedure args: argNames	"Answer a stream containing expressions for optimized invocation of an external procedure within the receiver."	| nrArgs type |	type := procedure type.	nrArgs := type argumentTypes size.	(type argumentNames size ~= nrArgs	and: [argNames size ~= nrArgs])		ifTrue: [self error: 'wrong number of arguments'].	^ReadStream on: '&lt;primitive: ', self methodPrimitiveCallNumber printString,		' errorCode: ', self errorCodeVariableName, '&gt;'</body><body package="DLLCC">procedureCallStream: procedure args: argNames assign: assignee	"Answer a stream containing expressions used to invoke the external function &lt;procedure&gt; within the receiver. "	((procedure type isVarArg and: [argNames size &gt; 0])		or: [assignee notNil		or: [procedure type argumentNames notNil			and: [argNames ~= procedure type argumentNames]]])		ifTrue: [^self procedureComplexCallStream: procedure args: argNames assign: assignee]		ifFalse:			[self optimizationLevel = self fullOptimizationLevel				ifTrue: [^self procedureAtomicCallStream: procedure args: argNames]				ifFalse: [^self procedureComplexCallStream: procedure args: argNames assign: assignee]]</body><body package="DLLCC">procedureComplexCallStream: procedure args: argNames assign: assignee	"Answer a stream containing expressions for debug-mode invocation of an external procedure within the receiver."	| callStream nrArgs args type errorCodeName |	type := procedure type.	nrArgs := type isVarArg		ifTrue: [argNames size min: 1]		ifFalse: [type argumentTypes size].	type argumentNames size = nrArgs		ifTrue: [args := type argumentNames]		ifFalse:			[argNames size ~= nrArgs				ifTrue: [self error: 'wrong number of arguments'].			args := argNames].		type argumentNames == nil ifFalse: [		type argumentNames do: [:each |			(argNames includes: each) ifFalse: [self error: 'unknown argument: ', each]]].	callStream := ReadWriteStream on: String new.	callStream		nextPutAll: '| ';		nextPutAll: (errorCodeName := self errorCodeVariableName);		nextPutAll: ' | self '; nextPutAll: #externalAccessFailedSignal; cr;		nextPutAll: 'handle: [:ex | ';		nextPutAll: errorCodeName;		nextPutAll: ' := ex parameter. ex returnWith: ';		nextPutAll: errorCodeName;		nextPutAll: '] do: ['.	type isVarArg		ifTrue:			[callStream nextPut: $^.			assignee isNil				ifTrue: [callStream nextPut: $(]				ifFalse: [callStream nextPutAll: assignee; nextPutAll: ' := ('].			callStream				nextPutAll: procedure name;				nextPutAll: ') callFrom: self withArguments:';				nextPutAll: (argNames size = 1 ifTrue: [(argNames at: 1)] ifFalse: ['#()']);				nextPutAll: ']. ']		ifFalse:			[callStream				nextPutAll: ' | __args | __args := Array new: ';				print: nrArgs;				nextPutAll: '. '.			1 to: nrArgs do: [:i |				callStream					nextPutAll: '__args at: ';					print: i;					nextPutAll: ' put: ';					nextPutAll: ((args at: i) isEmpty ifTrue: [argNames at: i] ifFalse: [args at: i]);					nextPutAll: '. '].			callStream nextPut: $^.			assignee isNil				ifTrue: [callStream nextPut: $(]				ifFalse: [callStream nextPutAll: assignee; nextPutAll: ' := ('].			callStream				nextPutAll: procedure name;				nextPutAll: ') callFrom: self withArguments: __args]. '].	^callStream reset</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>public develop</category><body package="DLLCC">regenerateMethods	"Parse my includeFiles, then regenerate my current accessing methods."	| newExternals |	"Parse includeFiles"	newExternals := self		externals: self newExternals		includeFiles: includeFiles		includeDirectories: includeDirectories.	ObjectMemory garbageCollect. "To finalize externals of removed methods"	self generateMethodsFrom: newExternals</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>generating methods</category><body package="DLLCC">tempExternals	| tempExternals |	tempExternals := ExternalDictionary new addBackup: self externals.	self allSharedPools do: [:pool |		(pool isKindOf: ExternalDictionary)			ifTrue: [tempExternals addBackup: pool]].	^tempExternals</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private-code generating</category><body package="DLLCC">typeCallStream: type args: argNames assign: assignee	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	"This method should actually only be used with type arguments that are instances of CType subclasses that maintain a notion of a 'name'.  For now we provide a default implementation of 'name' in CType to answer nil (which results in an error)."	| callStream |	argNames isEmpty ifFalse: [self error: 'wrong number of arguments'].	type name isNil ifTrue: [self error: 'Unnamed types not supported'].	callStream := ReadWriteStream on: String new.	callStream nextPutAll: '^', type name.	^callStream reset</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private</category><body package="DLLCC">undefinedExternals	" Answer a collection of associations with external type definitions that are not present in this class. Scan both instance AND class side methods."	| undefined addBlock |	undefined := Set new.	addBlock :=			[:ingoredSelector :method |			method isExternalMethod				ifTrue: [undefined addAll: method undefinedExternals]].	self selectorsAndMethodsDo: addBlock.	self class selectorsAndMethodsDo: addBlock.	^undefined</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>generating methods</category><body package="DLLCC">updateExternalsWith: newExternals	"Modify the receiver's external dictionary with elements from the argument,	newExternals. Answer the receiver."	| myExternals selections |	myExternals := self externals.	selections := IdentitySet new.	newExternals ownKeysAndValuesDo: [:key :ext |		(myExternals ownDetect: [:myExt | myExt name = ext name] ifNone: [nil]) notNil			ifTrue:				[selections add: ext.				"Also add types, that ext transitively depends on"				(ext respondsTo: #type)					ifTrue: [selections addAll: ext type namedTypes]]].	selections do: [:sel | myExternals installAt: sel name asSymbol put: sel]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private-code generating</category><body package="DLLCC">variableCallStream: variable args: argNames assign: assignee	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	| callStream |	argNames size &gt; 1 ifTrue: [self error: 'wrong number of arguments'].	callStream := ReadWriteStream on: String new.	callStream nextPut: $^.	assignee isNil ifFalse:		[callStream nextPutAll: assignee; nextPutAll: ' := '].	callStream		nextPut: $(;		nextPutAll: variable accessString;		nextPutAll:  ') contents'.	argNames size = 1 ifTrue:		[callStream			nextPutAll:  ': ';			nextPutAll: argNames first].	^callStream reset</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>compiling</category><body package="DLLCC">notifyCompilationOfTypeDefinitionFromClass: aClass	^self</body></methods><methods><class-id>External.ExternalMethod class</class-id> <category>private-code generating</category><body package="DLLCC">methodPrimitiveCallNumber	"Answer the primitive number used to compile fully optimized external methods."	^395</body></methods><methods><class-id>External.ExternalMethod</class-id> <category>initialize-release</category><body package="DLLCC">for: anExternalAssociation selector: aSelector	"Initialize the receiver to be a method for the given external and the given method selector.  Answer the receiver."	self for: anExternalAssociation.	methodSelector := aSelector.	^self</body></methods><methods><class-id>External.ExternalMethod</class-id> <category>accessing</category><body package="DLLCC">undefinedExternals	" Answer a collection of typedefinitions (externals) referenced in he receiver that are not defined in its metaclass. "	| parser answer |	parser := mclass parserClass new.	parser		parse: self getSource readStream		class: mclass		environment: mclass environment		noPattern: false		context: nil		notifying: ((SilentCompilerErrorHandler new)				class: mclass;				failBlock: 						[self halt.						^#()])		builder: ProgramNodeBuilder new		saveComments: false		ifFail: 			[self halt.			^#()].	parser externals ifNil: [^#()].	answer := OrderedCollection new.	parser externals ownKeysAndValuesDo: 			[:key :anExternal |			(anExternal == parser external or: [mclass instanceBehavior includesExternal: key])				ifFalse: [answer add: anExternal]].	^answer</body></methods><methods><class-id>External.CType</class-id> <category>code generating</category><body package="DLLCC">callStreamArgs: argNames assign: assignee interface: aClass	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	^aClass typeCallStream: self args: argNames assign: assignee</body><body package="DLLCC">methodClassIn: targetClass	"Answer the class used to create methods of the receiver's type."	^CompiledMethod</body></methods><methods><class-id>External.CType</class-id> <category>compiling</category><body package="DLLCC">notifyCompilationOfTypeDefinitionFromClass: aClass	^ExternalInterfaceTypeDefinitionCompiled raiseRequestWith: aClass</body></methods><methods><class-id>External.ExternalVariable</class-id> <category>code generating</category><body package="DLLCC">accessString	"Answer a String that is used to access the receiver in a compiled method."	^self isVirtual		ifTrue: [name, ' asPointer: self class']		ifFalse: [name]</body><body package="DLLCC">callStreamArgs: argNames assign: assignee interface: aClass	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	aClass isVirtual ifTrue: [virtuals := #()].	self owner: aClass.	^aClass variableCallStream: self args: argNames assign: assignee</body></methods><initialize><class-id>External.CScanner</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalObject</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name ordinal handle type virtuals owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ExternalProcedure</name><environment>External</environment><super>External.ExternalObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Scanner</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source mark prevEnd hereChar token tokenType saveComments currentComment buffer typeTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>ExternalVariable</name><environment>External</environment><super>External.ExternalObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ExternalMethod</name><environment>External</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>handle specifierFlags argumentKinds structArgSize structReturnSize datumClass resultType virtuals methodSelector external </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>CMacroDefinition</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name argNames fragments cachedValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>CType</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specifierFlags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class></st-source>