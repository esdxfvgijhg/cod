<?xml version="1.0"?><st-source><!-- Name: THAPIExampleNotice: Copyright © 1999,2000 Cincom Systems, Inc. All Rights ReservedComment: This parcel contains the THAPI example code from http://www.parcplace.com/products/thapi/.  It demonstrates non-blocking calls on a pipe via threads.DbIdentifier: bear73DbTrace: 13618DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))PackageName: THAPIExamplePackageName:: THAPIExampleParcel: #($e "16r0065")ParcelName: THAPIExamplePrintStringCache: (5i.4 - 0.4,bobw)Version: 5i.4 - 0.4Date: 6:05:58 AM August 5, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 6:05:58 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NonBlockingPipeInterface</name><environment>Examples</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>infd outfd generator writer readers results running </inst-vars><class-inst-vars></class-inst-vars><imports>			private Examples.NonBlockingPipeInterfaceDictionary.*			</imports><category>ExternalInterface-THAPI Example</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libc.so</item> <item>libc.sl</item> <item>msvcrt40.dll</item></libraryFiles><libraryDirectories><item>/lib</item> <item>/usr/shlib</item> <item>/usr/lib</item> <item>$(windir)\system</item> <item>$(windir)\system32</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>THAPIExample</package></attributes></class><comment><class-id>Examples.NonBlockingPipeInterface</class-id><body>This class provides a simple test of the threaded API.  Two + N processes cooperate to print the results of an nfib computation in the system transcript.One process opens a transcript, opens a pipe, forks off a writer process and N reader processes and then computes a series of nfib benchmark times which it writes to its transcript and puts into a shared queue.The writer process gets items from the shared queue and does a blocking write of each item as a string to the pipe.Each of the N reader processes loops doing blocking reads from the pipe and writing the result of the read to the system transcript.When its running one sees results of the nfib computation written to the interface's private transcript followed by the same information written to the system transcript from each reader.The writer process is an unnecessary frill.Some example doits:	"10 readers. ctrl-y to terminate"	NonBlockingPipeInterface new readers: 10	"10 readers in the background.	 Inspect the nbpi and send it terminate when you get bored."	| nbpi |	nbpi := NonBlockingPipeInterface new.	[nbpi readers: 10]	forkAt: Processor activePriority - 1.	nbpiPlease be aware of a bug on Solaris.  If one of the threads in a multi-threaded process attempts to read from a closed pipe the entire process locks-up (the reading LWP is looping on the read in the kernel) and no signal delivery happens.  Only kill -9 pid will terminate the program.  Sun are aware of the bug and are working on it....Instance Variables:infd		&lt;SmallInteger&gt;			read-side pipe file descriptoroutfd		&lt;SmallInteger&gt;			write-side pipe file descriptorgenerator	&lt;Process&gt;				generator process (useful for debugging)writer		&lt;Process&gt;				writer process (useful for debugging)readers	&lt;Array of Process&gt;	reader process(es) (useful for debugging)results		&lt;SharedQueue&gt;		queue to buffer results between generator &amp; writerrunning	&lt;Boolean&gt;				flag tested by writer and readers to see if they should continueClass Variables:TranscriptProtect	&lt;Semaphore&gt;	mutex for readers writing to Transcript</body></comment><class><name>FSNBPI</name><environment>Examples</environment><super>Examples.NonBlockingPipeInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Examples.FSNBPIDictionary.*			</imports><category>ExternalInterface-THAPI Example</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>THAPIExample</package></attributes></class><comment><class-id>Examples.FSNBPI</class-id><body>This class does exactly what its superclass NonBlockingPipeInterface does, except that instead of using buffers allocated on the C heap it uses normal Smalltalk objects in FixedSpace.Some example doits:	"10 readers. ctrl-y to terminate"	FSNBPI new readers: 10	"10 readers in the background.	 Inspect the nbpi and send it terminate when you get bored."	| nbpi |	nbpi := FSNBPI new.	[nbpi readers: 10]	forkAt: Processor activePriority - 2.	nbpi</body></comment><shared-variable><name>NonBlockingPipeInterfaceDictionary</name><environment>Examples</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>THAPIExample</package></attributes></shared-variable><shared-variable><name>FSNBPIDictionary</name><environment>Examples</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>THAPIExample</package></attributes></shared-variable><shared-variable><name>O_BINARY</name><environment>Examples.NonBlockingPipeInterface</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>THAPIExample</package></attributes></shared-variable><shared-variable><name>TranscriptProtect</name><environment>Examples.NonBlockingPipeInterface</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>THAPIExample</package></attributes></shared-variable><methods><class-id>Examples.NonBlockingPipeInterface</class-id> <category>initialize-release</category><body package="THAPIExample" selector="openPipes">openPipes	"Create the pipe.  Note that pipe in the MSVC run-time library is different	 from the standard unix pipe."	| fds |	fds := CIntegerType int gcMalloc: 2.	(OSHandle currentOS == #win32			ifTrue: [self pipe: fds ofSize: 1024 mode: O_BINARY]			ifFalse: [self pipe: fds]) &lt; 0		ifTrue: [self error: 'pipe open failed.'].	infd := fds at: 0.	outfd := fds at: 1.</body><body package="THAPIExample" selector="terminate">terminate	"Terminate all the relevant processes and close the pipe."	running ifFalse: [^self].	running := false.	generator == Processor activeProcess ifFalse: [generator terminate].	"Write sufficient data to the pipe so that all readers will get data and	 hence by checking running will stop."	readers size * 2 timesRepeat: [results nextPut: 'so long!'].	"Delay until the results have been written by the writer and then kill the writer.	 Yield doesn't work if terminate has a higher priority than the writer."	[results isEmpty] whileFalse: [(Delay forMilliseconds: 20) wait].	writer terminate.	self close: infd; close: outfd</body></methods><methods><class-id>Examples.NonBlockingPipeInterface</class-id> <category>server</category><body package="THAPIExample" selector="reader:">reader: id	"Read from the pipe as long as running is true.  Print what ever's	 read from the pipe to the Transcript tagged with the reader id."	| buffer count |	"Allocate a buffer on the C heap to receiver characters from the read call."	buffer := CIntegerType char gcMalloc: 1025.	"Continue until running is false."	[running] whileTrue:		["Make a blocking read call on its own thread."		count := self read: infd with: buffer with: 1024.		"Write results to the transcript.  Use a Semaphore to ensure other reader		 processes don't collide when accessing the un-thread-safe Transcript."		TranscriptProtect critical:			[Transcript cr; print: id; tab.			(count &gt;= 1024 or: [count &lt; 0])				ifTrue: [Transcript nextPutAll: 'READ RETURNED '; print: count]				ifFalse:					[buffer at: count put: 0.					Transcript nextPutAll: buffer copyCStringFromHeap].			Transcript endEntry]]</body><body package="THAPIExample" selector="startReader:">startReader: id 	"Place an exception handler around the reader: method to catch ou-of-thread exceptions."	self externalAccessFailedSignal		handle:			[:ex |			ex localErrorString == #'out of threads'				ifTrue: 					[TranscriptProtect critical:						[Transcript							cr; print: id;							nextPutAll: ' CANNOT PROCEED. OUT OF THREADS';							endEntry].				Processor activeProcess terminate]			ifFalse: [ex reject]]		do: [self reader: id]</body><body package="THAPIExample" selector="writer">writer	"Loop writing strings from the results queue to the pipe."	| result buffer writeCount |	"Allocate a buffer on the C heap to pass characters to the write call."	buffer := CIntegerType char gcMalloc: 1024.	[true] whileTrue:		["Get the next result from the results shared queue. This process		  will wait until one is available. Convert the result to a ByteArray		  since the type of the buffer is char (an integer)."		result := results next asByteArray.		"Copy the characters from the result into the buffer."		buffer copyAt: 0 from: result size: result size startingAt: 1.		"Write the buffer's contents to the pipe."		writeCount := self write: outfd with: buffer with: result size.		"Check the write operation succeeded."		writeCount ~= result size ifTrue:			[TranscriptProtect critical:				[Transcript					cr;					nextPutAll: 'WRITE RETURNED '; print: writeCount;					nextPutAll: ' EXPECTED '; print: result size;					nextPut: $!; endEntry]]]</body></methods><methods><class-id>Examples.NonBlockingPipeInterface</class-id> <category>public access</category><body package="THAPIExample" selector="readers:">readers: n	"Run the example with n reader processes."	results := SharedQueue new.	self openPipes.	generator := Processor activeProcess.	"running flag is polled by other processes to make them terminate when we're done."	running := true.	"Fork a writer process to write data to the pipe.  Its priority is higher than the generator	 to ensure writes happen promptly.  It needs to reserve its own thread because there may	 be more readers than available threads, and if the writer can't get a thread because they	 have been used up by the readers the example will deadlock, since the readers will get	 no data unless some is written."	writer := [self writer] forkAt: generator priority + 1.	writer attachToThread.	"Fork n readers at a higher priority so that results will get read and displayed."	readers := (1 to: n) collect: [:i|								[Processor yield.								self startReader: i] forkAt: generator priority + 1].	"Generate some data.  Use a benchmark the author	 is excessively fond of.  But anything would do."	[| i r t s nfibs |	s := String new writeStream.	i := 0.	[t := Time millisecondsToRun: [r := i nfib].	s reset.	nfibs := Number errorSignal handle: [:ex| '??'] do: [(r * 1000.0 / t) rounded].	s		nextPutAll: 'nfib '; print: i; nextPutAll: ' = '; print: r;		tab; tab;		nextPutAll: 'nfibs '; print: nfibs;		nextPutAll: ' ('; print: t / 1000.0; nextPutAll: ' seconds)'.	"Put datum in results shared queue for the writer to consume."	results nextPut: s contents.	"Increase the value from which we compute nfib, limiting	 it to a value that takes 30 seconds or less to compute."	i := t &gt; 30000 ifTrue: [0] ifFalse: [i + 1]] repeat]		ensure:			[self terminate]</body></methods><methods><class-id>Examples.NonBlockingPipeInterface class</class-id> <category>class initialization</category><body package="THAPIExample" selector="initialize">initialize	"Initialize the mutex used to serialise access to the Transcript,	 and the flags used to open the pipe."	TranscriptProtect := Semaphore forMutualExclusion.	O_BINARY := 16r8000. "from msvc20\include\fcntl.h"	"self initialize"</body></methods><methods><class-id>Examples.NonBlockingPipeInterface class</class-id> <category>private</category><body package="THAPIExample" selector="libraryFilesSearchSignals">libraryFilesSearchSignals	"Answer a SignalCollection used to handle exceptions raised when scanning for library files. The 	signals answered by this method will result in those signals being ignored by the library search 	machinery. Clients should not answer signals they wish to receive."	^ExternalLibraryHolder libraryNotFoundSignal</body></methods><methods><class-id>Examples.FSNBPI</class-id> <category>server</category><body package="THAPIExample" selector="reader:">reader: id	"Read from the pipe as long as running is true.  Print what ever's	 read from the pipe to the Transcript tagged with the reader id."	| buffer count |	"Use a normal Smalltalk string, but allocate it in FixedSpace."	buffer := String defaultPlatformClass newInFixedSpace: 1024.	[running] whileTrue:		["Make a blocking read call on its own thread."		count := self read: infd with: buffer with: buffer size.		"Write results to the transcript.  Use a Semaphore to ensure other reader		 processes don't collide when accessing the un-thread-safe Transcript."		TranscriptProtect critical:			[Transcript cr; print: id; tab.			(count &gt; buffer size or: [count &lt; 0])				ifTrue: [Transcript nextPutAll: 'READ RETURNED '; print: count]				ifFalse: [1 to: count do: [:i| Transcript nextPut: (buffer at: i)]].			Transcript endEntry]]</body><body package="THAPIExample" selector="writer">writer	"Loop writing strings from the results queue to the pipe."	| result writeCount |	[true] whileTrue:		["Get the next result from the results shared queue.		  This process will wait until one is available."		result := results next.		"Write the contents of the string to the pipe."		writeCount := self write: outfd with: result with: result size.		"Check the write operation succeeded."		writeCount ~= result size ifTrue:			[TranscriptProtect critical:				[Transcript					cr;					nextPutAll: 'WRITE RETURNED '; print: writeCount;					nextPutAll: ' EXPECTED '; print: result size;					nextPut: $!; endEntry]]]</body></methods><methods><class-id>Examples.NonBlockingPipeInterface</class-id> <category>procedures</category><body package="THAPIExample" selector="access:with:">access: name with: mode	"Unix access creation function."	&lt;C: unsigned long __syscall _threaded access(char *, int)&gt;	^self externalAccessFailedWith: _errorCode	"self basicNew access: 'e252.cha' with: 0"	"self basicNew access: 'notOnYourNellie' with: 0"</body><body package="THAPIExample" selector="close:">close: fd	"Close the file descriptor fd"	&lt;C: unsigned long __syscall close(int fd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="THAPIExample" selector="pipe:">pipe: arg	"Unix pipe creation function."	&lt;C: unsigned long __syscall pipe(int [])&gt;	^self externalAccessFailedWith: _errorCode</body><body package="THAPIExample" selector="pipe:ofSize:mode:">pipe: arg ofSize: size mode: textMode	"NT pipe creation function."	&lt;C: unsigned long __syscall pipe(int arg[], unsigned int size, int textMode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="THAPIExample" selector="read:with:with:">read: fd with: buffer with: size	"Invoke the read system call on its own thread and hence avoid blocking the ObjectEngine."	&lt;C: unsigned long __syscall _threaded read(int fd, _oopref *buffer, unsigned long size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="THAPIExample" selector="write:with:with:">write: fd with: buffer with: size	"Invoke the read system call on its own thread and hence avoid blocking the ObjectEngine."	&lt;C: unsigned long __syscall _threaded write(int fd, _oopref *buffer, unsigned long size)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><initialize><class-id>Examples.NonBlockingPipeInterface</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class></st-source>