<?xml version="1.0"?><st-source><!-- Name: DLLCC-ToolsNotice: Copyright 2011-2014 Cincom Systems, Inc.  All rights reserved.Comment: This is the C Programmer's Object Kit, also known as DLL and C Connect. It contains tools for generating external interfaces that allow interoperation with C and the underlying operating system.See the DLL and C Connect User's Guide for more information.DbIdentifier: bear73DbTrace: 437371DbUsername: smichaelDbVersion: 8.0 - 5DevelopmentPrerequisites: #(#(#any 'DLLCC' '') #(#any 'Browser-BaseUI' '') #(#any 'Browser-BrowserUI' '') #(#any 'BOSS' ''))PackageName: DLLCC-ToolsParcel: #('DLLCC-Tools')ParcelName: DLLCC-ToolsPrerequisiteDescriptions: #(#(#name 'DLLCC' #componentType #package) #(#name 'Browser-BaseUI' #componentType #package) #(#name 'Browser-BrowserUI' #componentType #package) #(#name 'BOSS' #componentType #package))PrerequisiteParcels: #(#('DLLCC' '') #('Browser-BaseUI' '') #('Browser-BrowserUI' '') #('BOSS' ''))PrintStringCache: (8.0 - 5,smichael)Version: 8.0 - 5Date: 3:35:19 PM June 20, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jun14.3) of June 20, 2014 on June 20, 2014 at 3:35:19 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ExternalInterfaceClassFinder</name><environment>Tools</environment><super>Tools.ClassFinder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isOptimized isVirtual </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Interface</category><attributes><package>DLLCC-Tools</package></attributes></class><class><name>ExternalInterfaceFinder</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>externalList categoryList classNameList externalInterfaceHolder filter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Interface</category><attributes><package>DLLCC-Tools</package></attributes></class><comment><class-id>Tools.ExternalInterfaceFinder</class-id><body>The class ExternalInterfaceFinder is a specialized browser for ExternalInterface classes.  The lefthand (class) pane of the finder shows only these classes.  The list can be further filtered according to whether the classes are user-defined or were recently browsed.  The menu in this pane and under the 'View' button on the menu bar provides for selecting among these filters, and for updating the list of classes after filing or defing classes via Browser, FileList or ChangeList tools.  The pane is automatically updated as new interfaces are installed, added, or removed via the finder.Instance Variables	externalList			&lt;SelectionInList&gt;	The model behind the external pane	categoryList			&lt;SelectionInList&gt;	The model behind the category pane	classNameList			&lt;SelectionInList&gt;	The model behind the class pane	externalInterfaceHolder	&lt;ExternalInterfaceHolder&gt;	The object that understands accessing protocol for external interface dictionaries	filter					&lt;Symbol&gt; What sorts of application classes are to be shown in the class paneClass Variables	ClassListMenu				&lt;Menu&gt;	Used when no class is selected	ExternalInterfaceClasses	&lt;Set of: Symbol&gt; All external interfaces known in the system	ExternalListMenu			&lt;Menu&gt; Used when no external is selected	MenuBarMenu				&lt;Menu&gt; The menu bar when no class is selected	RecentlyVisitedClasses 		&lt;OrderedCollection of: Symbol&gt; The last &lt;n&gt; classes visited</body></comment><class><name>ExternalInterfaceBuilder</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>categoryList currentSubCanvas externalMultiSelectionSubCanvas externalSingleSelectionSubCanvas externalSingleSelectionList externalMultiSelectionList externalSelectionDictionary includeFiles includeDirectories externalInterfaceHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Interface</category><attributes><package>DLLCC-Tools</package></attributes></class><comment><class-id>Tools.ExternalInterfaceBuilder</class-id><body>The class ExternalInterfaceBuilder provides a visual interface to the CDeclarationParser; the tool that is used to parse C language header files and generate an ExternalInterface class from those declarations.  The parser tool is divided into two panes.  The first pane contains a list of categories.  The first two categories are configurable by the user and are used to specify the C language include file names and the directories those files are contained in respectively.  The second pane is used to display the entries from the first pane.The 'Parse Files' button is used to parse the specified header files and build the declaration entries.  The 'Define Class' button is used to build the interface class using the selected declarations.  The right hand pane contains a multi-selection in list view that you can use to select the various declarations that should be included in your interface class.  The tool will automatically traverse a particular declaration in order to select any dependent declarations.This builder can be opened from the ExternalInterfaceFinder, or as a separate tool using 'ExternalInterfaceBuilder open'.Instance Variables:	categoryList	&lt;SelectionInList&gt; The list of categories that comprise a header file declaration	currentSubCanvas	&lt;Symbol&gt; Define as #single if the right-hand pane is a selection in list view, otherise the right-hand pane is a multi-selection in list view	externalMultiSelectionSubCanvas	&lt;UISpecification&gt; The right-hand pane canvas when in multi-selection mode	externalSingleSelectionSubCanvas	&lt;UISpecification&gt; The right-hand pane canvas when in single-selection mode	externalSingleSelectionList	&lt;SelectionInList&gt; The right-hand pane model when in single-selection mode	externalMultiSelectionList	&lt;MultiSelectionInList&gt; The right-hand pane model when in multi-selection mode	externalSelectionDictionary	&lt;IdentityDictionary key: Symbol value: (Association key: List value: Set)&gt; A mapping between the C language declarations and the actual declarations that were parsed from a file	includeFiles	&lt;List of: String&gt; A list of include file names	includeDirectories	&lt;List of: String&gt; A list of include directory names	externalInterfaceHolder	&lt;ExternalInterfaceHolder&gt; The holder for the ExternalDictionary that was generated from parsing a header fileClass Variables:	MenuBarMenu	&lt;Menu&gt;	The menu bar menu for the main builder window.</body></comment><class><name>ExternalInterfaceHolder</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>externalInterface externalDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Interface</category><attributes><package>DLLCC-Tools</package></attributes></class><comment><class-id>External.ExternalInterfaceHolder</class-id><body>The class ExternalInterfaceHolder is used to hold either an ExternalInterface or an ExternalDictionary.  This holder provides common protocol to both objects.  It is used by the external interface browser classes when requesting and setting information in an ExternalDictionary.  Please see the accessing protocol for a description of the messages this class understands.Instance Variables	externalInterface	&lt;ExternalInterface class | nil&gt; The interface the receiver contains; nil if the holder contains only a dictionary.	externalDictionary	&lt;ExternalDictionary&gt; The dictionary the receiver contains.  This is either externalInterface's dictionary if externalInterface is not nil, otherwise it is simply an arbitrary dictionary.</body></comment><shared-variable><name>MenuBarMenu</name><environment>Tools.ExternalInterfaceBuilder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC-Tools</package></attributes></shared-variable><shared-variable><name>ExternalInterfaceClasses</name><environment>Tools.ExternalInterfaceFinder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC-Tools</package></attributes></shared-variable><shared-variable><name>ExternalListMenu</name><environment>Tools.ExternalInterfaceFinder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC-Tools</package></attributes></shared-variable><shared-variable><name>ClassListMenu</name><environment>Tools.ExternalInterfaceFinder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC-Tools</package></attributes></shared-variable><shared-variable><name>RecentlyVisitedClasses</name><environment>Tools.ExternalInterfaceFinder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>OrderedCollection new</initializer><attributes><package>DLLCC-Tools</package></attributes></shared-variable><shared-variable><name>MenuBarMenu</name><environment>Tools.ExternalInterfaceFinder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC-Tools</package></attributes></shared-variable><methods><class-id>Tools.ExternalInterfaceClassFinder</class-id> <category>interface opening</category><body package="DLLCC-Tools">postBuildWith: aBuilder 	self setSuperclassTypes: #(#{ExternalInterface}).	self isOptimized value: true.	classCategory value: 'ExternalInterface-New'.	normalSuperclass value: #{ExternalInterface}</body></methods><methods><class-id>Tools.ExternalInterfaceClassFinder</class-id> <category>private</category><body package="DLLCC-Tools">createAttributesArray	| oc |	oc := OrderedCollection new.	oc add: #(#includeFiles #()).	oc add: #(#includeFiles #()).	oc add: #(#includeDirectories #()).	oc add: #(#libraryFiles #()).	oc add: #(#libraryDirectories #()).	oc add: (Array with: #beVirtual with: self isVirtual value).	oc add: (Array with: #optimizationLevel with: self optimizationLevel).	^oc asArray</body><body package="DLLCC-Tools">optimizationLevel	^self isOptimized value		ifTrue: [#full]		ifFalse: [#debug]</body></methods><methods><class-id>Tools.ExternalInterfaceClassFinder</class-id> <category>finding</category><body package="DLLCC-Tools">createClass	| ns cls |	(self requestedSuperclass value includesBehavior: ExternalInterface) ifFalse:		[^Dialog			warn: #mustBeExternalInterfaceSubclass &lt;&lt; #dllcc &gt;&gt; 'The superclass must be a subclass of ExternalInterface.'			for: self builder window].	ns := self currentNameSpace.	cls := ns				defineClass: self localClassName value				superclass: self requestedSuperclass				indexedType: #none				private: false				instanceVariableNames: ''				classInstanceVariableNames: ''				imports: ''				category: self classCategory value				attributes: self createAttributesArray.	cls asNameSpace addImport: cls poolImportDefinition.	candidateClassName value: cls fullName</body></methods><methods><class-id>Tools.ExternalInterfaceClassFinder</class-id> <category>aspects</category><body package="DLLCC-Tools">isOptimized	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^isOptimized isNil		ifTrue:			[isOptimized := false asValue]		ifFalse:			[isOptimized]</body><body package="DLLCC-Tools">isVirtual	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^isVirtual isNil		ifTrue:			[isVirtual := false asValue]		ifFalse:			[isVirtual]</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>private</category><body package="DLLCC-Tools">addDefineForInterface: defineInterfaceSpec	"Open a dialog to confirm or collect the basic information required to create	 a new access method for a #define that is either a constant or macro (that	 accepts arguments).	 Answer a two element array. The first element is the CMacroDefiniton object	 (or nil), the second argument is a Boolean indicating if the macro should be	 browsed after creation."	| dialog externalName db doBrowse newMacro macroValue define |	doBrowse := false.	dialog := SimpleDialog new.	db := dialog builder.	db aspectAt: #externalName put: (externalName := '' asValue).	db aspectAt: #macroValue put: (macroValue := '' asValue).	db		aspectAt: #doAbort		put: [dialog close. ^#(nil nil)].	db		aspectAt: #doOK		put: [externalName value isEmpty				ifTrue: [(dialog builder componentAt: #externalNameField) flash]				ifFalse: [dialog close]].	db		aspectAt: #doBrowse		put: [externalName value isEmpty				ifTrue: [(dialog builder componentAt: #externalNameField) flash]				ifFalse: [doBrowse := true. dialog close]].	dialog allButOpenFrom: (self class interfaceSpecFor: defineInterfaceSpec).	"Make CR behave like tab in name field"	db openDialog.	dialog cancel value ifTrue: [^#(nil nil)].	externalName := externalName value.	macroValue := macroValue value.	(define := String new writeStream)		nextPutAll: '#define ';		nextPutAll: externalName;		nextPut: Character space;		nextPutAll: macroValue;		nextPut: Character cr.	define := define contents.	newMacro := [	| preprocessor |					preprocessor := CPreprocessor new.					preprocessor						preprocess: define						declarations: externalInterfaceHolder externalInterface tempExternals						includeDirectories: #().					preprocessor lastDefine]						on: Object errorSignal						do: [:ex | Dialog warn: #syntaxError &lt;&lt; #dllcc &gt;&gt; 'syntax error' for: builder window. nil].	^Array with: newMacro with: doBrowse</body><body package="DLLCC-Tools">changedClassName	"A class name was selected or deselected. Update all views, menus, and buttons."	self hasClassSelected		ifFalse: [self updateClassNotSelected]		ifTrue:			[self updateClassSelected.			externalInterfaceHolder := ExternalInterfaceHolder on: (self selectedClassOrDo: [^self classGone])].	categoryList list: self computeCategoryList</body><body package="DLLCC-Tools">changedExternal	"An external was selected or deselected. Update all views, menus, and buttons."	(self external notNil		and: [self isRemoveableCategory: self category])		ifTrue: [self updateExternalSelected]		ifFalse: [self updateExternalNotSelected]</body><body package="DLLCC-Tools">classGone	"Inform the user that the current class no longer exists, then remove any notion the receiver has of the class. Answer the receiver."	| classID |	Dialog 		warn: (#class1sNoLongerExists &lt;&lt; #dllcc &gt;&gt; 'class &lt;1s&gt; no longer exists'			expandMacrosWith: (classID := self classID) asString)		for: builder window.	ExternalInterfaceClasses remove: classID ifAbsent: [].	RecentlyVisitedClasses remove: classID ifAbsent: [].	ExternalInterfaceFinder changed: #externalInterfaceClasses.	#(#browseButton #removeButton #regenerateButton) do: [:n | (builder componentAt: n) disable]</body><body package="DLLCC-Tools">pruneRemovedClasses	"Update the internal interface class caches maintained by the receiver such that removed classes are fogotten. Answer the receiver."	| deaders |	deaders := OrderedCollection new.	ExternalInterfaceClasses do:		[:classID |		classID isDefined ifFalse: [deaders add: classID]].	deaders isEmpty		ifFalse:			[deaders do:				[:ddr |				ExternalInterfaceClasses remove: ddr.				RecentlyVisitedClasses remove: ddr ifAbsent: []].			ExternalInterfaceFinder changed: #externalInterfaceClasses]</body><body package="DLLCC-Tools">removeClass: aClass	"Prompt the user to confirm removal of a class. If the removal is confirmed, actually remove the class from the system."	| classID |	classID := aClass fullyQualifiedReference.	(Dialog		confirm: ((#certainRemoveClass &lt;&lt; #dllcc &gt;&gt; 'Are you certain that you want to remove&lt;n&gt;class &lt;1p&gt; from the system?')			expandMacrosWith: aClass)		for: builder window) ifFalse: [^self].	(aClass subclasses isEmpty	 or: [Dialog			confirm: ((#classHasSubclassesQueryProceed &lt;&lt; #dllcc &gt;&gt; '&lt;1p&gt; has subclasses.&lt;n&gt;Proceed with removal?')			expandMacrosWith: aClass)			for: builder window])		ifTrue:			[aClass removeFromSystem.			ExternalInterfaceClasses remove: classID.			RecentlyVisitedClasses remove: classID ifAbsent: [].			self update]</body><body package="DLLCC-Tools">showClasses: aSet	"Given a set of external interface classes defined by the argument, update the class list view to display the new classes. Remember the current selection sequence. Answer the receiver."	| oldClassName oldCategory oldExternal |	oldClassName := self classNameList selection.	oldCategory := self category.	oldExternal := self external.	classNameList list: (List withAll:		(aSet asSortedCollection: [:x :y | x asString &lt; y asString])).	oldClassName notNil ifTrue: [classNameList selection: oldClassName].	oldCategory notNil ifTrue: [categoryList selection: oldCategory].	oldExternal notNil ifTrue: [externalList selection: oldExternal]</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>interface dialogs</category><body package="DLLCC-Tools">addDefine	"Open a dialog to confirm or collect the basic information required to create a new access method."	| define macro doBrowse |	define := self addDefineForInterface: #defineMethodCreationDialog.	macro := define at: 1.	doBrowse := define at: 2.	macro isNil ifTrue: [^nil].	macro numArgs notNil ifTrue:		[Dialog			warn: #defineTakesNoArguments &lt;&lt; #dllcc &gt;&gt; 'The #define should accept no arguments.'			for: builder window.		^self addDefine].	externalInterfaceHolder externalInterface generateMethodsForExternal: macro.	self update.	doBrowse ifTrue:		[self browseAccessMethodsFor: macro name wildcard: true]</body><body package="DLLCC-Tools">addEnum	"Open a dialog to collect the basic information required to create a new access method, create the method, and if specified open a browser. The latter allows the user to fine tune the access method."	| enumName newEnum |	enumName := Dialog request: #addEnum &lt;&lt; #dllcc &gt;&gt; 'Enum Name:' for: builder window.	(enumName isNil or: [enumName isEmpty]) ifTrue: [^self].	enumName := enumName asSymbol.	newEnum := CEnumerationType new name: enumName.	newEnum at: #red put: 10.	newEnum at: #white put: 20.	newEnum at: #blue put: 30.	externalInterfaceHolder externalInterface generateMethodsForExternal: newEnum.	self browseAccessMethodsFor: enumName wildcard: false.	self update</body><body package="DLLCC-Tools">addIncludeDirectory	"Open a dialog to collect the basic information required to add a 	new include directory to the list of directories that are searched 	when parsing header files."	| directory interface |	directory := Dialog request: #addIncludeDirectory &lt;&lt; #dllcc &gt;&gt; 'Include Directory:' for: builder window.	(directory isNil or: [directory isEmpty]) ifTrue: [^self].	interface := externalInterfaceHolder externalInterface.	interface includeDirectories: (interface includeDirectoriesArray copyWith: directory).	self update</body><body package="DLLCC-Tools">addIncludeFile	"Open a dialog to collect the basic information required to add a 	new include file to the list of files that can be parsed to generate 	interface externals."	| file interface |	file := Dialog request: #addIncludeFile &lt;&lt; #dllcc &gt;&gt; 'Include File:' for: builder window.	(file isNil or: [file isEmpty]) ifTrue: [^self].	interface := externalInterfaceHolder externalInterface.	interface includeFiles: (interface includeFiles copyWith: file).	self update</body><body package="DLLCC-Tools">addLibraryDirectory	"Open a dialog to collect the basic information required to add a 	new include directory to the list of directories that are searched 	when attempting to load a dynamic-link library."	| directory interface |	directory := Dialog request: #addLibraryDirectory &lt;&lt; #dllcc &gt;&gt; 'Library Directory:' for: builder window.	(directory isNil or: [directory isEmpty])  ifTrue: [^self].	interface := externalInterfaceHolder externalInterface.	interface libraryDirectories: (interface libraryDirectoriesArray copyWith: directory).	self update</body><body package="DLLCC-Tools">addLibraryFile	"Open a dialog to collect the basic information required to add a 	new library file to the list of files that can dynamically loaded by 	an interface class."	| file interface |	file := Dialog request: #addLibraryFile &lt;&lt; #dllcc &gt;&gt; 'Library File:' for: builder window.	(file isNil or: [file isEmpty]) ifTrue: [^self].	interface := externalInterfaceHolder externalInterface.	interface libraryFiles: (interface libraryFilesArray copyWith: file).	self update</body><body package="DLLCC-Tools">addMacro	"Open a dialog to collect the basic information required to create a new access method, create the method, and if specified open a browser. The latter allows the user to fine tune the access method "	| define macro doBrowse |	define := self addDefineForInterface: #macroMethodCreationDialog.	macro := define at: 1.	doBrowse := define at: 2.	macro isNil ifTrue: [^nil].	macro numArgs isNil ifTrue:		[Dialog			warn: #defineTakesArguments &lt;&lt; #dllcc &gt;&gt; 'The #define macro should accept arguments.'			for: builder window.		^self addMacro].	externalInterfaceHolder externalInterface generateMethodsForExternal: macro.	self update.	doBrowse ifTrue:		[self browseAccessMethodsFor: macro name wildcard: true]</body><body package="DLLCC-Tools">addProcedure	"Open a dialog to collect the basic information required to create a new	 procedure call method, create the method, and if specified open a browser.	 The latter allows the user to fine tune the access method."	| conventions conventionsMenu callingConvention dialog externalName db	  argumentTypes argumentNames returnType	  newCProcedureType newExternalProcedure doBrowse	  returnTypeString argumentTypeString argumentNamesList	  currentArgumentIndex argCount argTypes acceptBlock |	conventions := Array						with: #isCdecl -&gt; (#isCdecl &lt;&lt; #dllcc &gt;&gt; 'C 32-bit') asString						with: #isStdcall -&gt; (#isStdcall &lt;&lt; #dllcc &gt;&gt; 'C Stdcall 32-bit') asString						with: #isFar -&gt; (#isFar &lt;&lt; #dllcc &gt;&gt; 'C 16-bit') asString						with: #isPascal -&gt; (#isPascal &lt;&lt; #dllcc &gt;&gt; 'Pascal 16-bit') asString.	conventionsMenu := MenuBuilder new.	conventions do: [:assoc| conventionsMenu add: assoc value -&gt; assoc key].	conventionsMenu := conventionsMenu menu.	conventions := Dictionary withAll: conventions.	doBrowse := false.	argumentTypes := Array new: 15.	argumentNames := OrderedCollection new.	argTypes := OrderedCollection new.		dialog := SimpleDialog new.	db := dialog builder.	db aspectAt: #externalName put: (externalName := '' asValue).	db aspectAt: #callingConvention put: (callingConvention := (conventions at: #isCdecl) asValue).	db aspectAt: #typeMenu put: self typeMenu.	db aspectAt: #returnTypeString put: (returnTypeString := nil asValue).	db aspectAt: #argumentTypeString put: (argumentTypeString := nil asValue).	db aspectAt: #argumentNamesList		put: (argumentNamesList :=			SelectionInList with: ((1 to: 15) collect: [:i| #arg &lt;&lt; #dllcc &gt;&gt; 'argument &lt;1p&gt;' expandMacrosWith: i])).	argumentNamesList selectionIndexHolder compute:		[:v |		currentArgumentIndex := v.		argumentTypeString value: 			((v = 0 or: [(argumentTypes at: v) isNil])				ifTrue: ['']				ifFalse: [(argumentTypes at: v) printString])].	returnTypeString compute:		[:aString |		returnType := [returnType := (CDeclarationParser										parseWithNoPreprocess: aString										as: #singleDeclaration										declarations: externalInterfaceHolder														externalInterface tempExternals										requestor: self) result]						on: Object errorSignal						do: [:ex | ex return: nil].		(returnType isKindOf: CType) ifFalse:			[(dialog builder componentAt: #returnTypeField) flash. returnType := nil]].		argumentTypeString compute:		[:aString |		currentArgumentIndex = 0 ifFalse:			[currentArgumentIndex isNil				ifTrue: [Dialog warn: 'No argument selected' for: builder window]				ifFalse:					[argumentTypes						at: currentArgumentIndex						put:							(aString isEmpty								ifTrue: [nil]								ifFalse:									[| result |									result := [result := (CDeclarationParser												parseWithNoPreprocess: aString												as: #singleDeclaration												declarations: externalInterfaceHolder																externalInterface tempExternals												requestor: self) result]												on: Object errorSignal												do: [:ex | ex return: nil].									(result isKindOf: CType)										ifTrue: [result]										ifFalse: [(dialog builder componentAt: #argumentTypeField) flash.												nil]])]]].		db aspectAt: #callingConventionMenu put: conventionsMenu.	db		aspectAt: #doAbort		put: [dialog close. ^nil].	acceptBlock :=		[| accept |		accept := true.		externalName value isEmpty			ifTrue: [(dialog builder componentAt: #externalNameField) flash. accept := false]			ifFalse: [(accept := (returnType == nil) not)					ifFalse: [(dialog builder componentAt: #returnTypeField) flash]].		accept ifTrue: [dialog close].		accept].	db		aspectAt: #doOK		put: acceptBlock.	db		aspectAt: #doBrowse		put: [acceptBlock value ifTrue: [doBrowse := true]].	dialog allButOpenFrom: (self class interfaceSpecFor: #procMethodCreationDialog).	"Make CR behave like tab in name field"	db openDialog.	dialog cancel value ifTrue: [^nil].	externalName := externalName value.	callingConvention := callingConvention value.	argCount := argumentTypes findLast: [:t | t notNil].	1 to: argCount do: [:i |		argTypes add: ((argumentTypes at: i) notNil			ifTrue: [argumentTypes at: i]			ifFalse: [CIntegerType int]).		argumentNames add: ('arg', i printString)].	returnType isNil		ifTrue: [returnType := CIntegerType int].	newCProcedureType := CProcedureType		resultType: returnType		argumentTypes: argTypes		argumentNames: argumentNames.	callingConvention =  (conventions at: #isPascal)		ifTrue: [newCProcedureType beFar; bePascal].	callingConvention = (conventions at: #isStdcall)		ifTrue: [newCProcedureType beStdcall].	callingConvention = (conventions at: #isFar)		ifTrue: [newCProcedureType beFar].	newExternalProcedure := ExternalProcedure new		name: externalName;		type: newCProcedureType.	externalInterfaceHolder externalInterface generateMethodsForExternal: newExternalProcedure.	ObjectMemory quickGC.	self update.	doBrowse ifTrue:		[self browseAccessMethodsFor: newExternalProcedure name wildcard: true]</body><body package="DLLCC-Tools">addStruct	"Open a dialog to collect the basic information required to create a new access method, create the method, and if specified open a browser. The latter allows the user to fine tune the access method "	| structName newStruct |	structName := Dialog request: #addStruct &lt;&lt; #dllcc &gt;&gt; 'New Struct Name:' for: builder window.	(structName isNil or: [structName isEmpty]) ifTrue: [^self].	structName := structName asSymbol.	newStruct := CCompositeType new beStructure name: structName.	newStruct at: #firstMember put: 0-&gt;CIntegerType int.	newStruct at: #secondMember put: 1-&gt;CIntegerType char.	newStruct at: #thirdMember put: 2-&gt;CIntegerType long.	externalInterfaceHolder externalInterface generateMethodsForExternal: newStruct.	self browseAccessMethodsFor: structName wildcard: false.	self update</body><body package="DLLCC-Tools">addTypedef	"Open a dialog to collect the basic information required to create a new	 typedef method, create the method, and if specified open a browser.	 The latter allows the user to fine tune the access method."	| dialog externalName db doBrowse type typeString newExternalVariable acceptBlock |	doBrowse := false.	dialog := SimpleDialog new.	db := dialog builder.	db aspectAt: #externalName put: (externalName := '' asValue).	db aspectAt: #typeMenu put: self typeMenu.	db aspectAt: #typeString put: (typeString := nil asValue).	typeString compute:		[:aString |		type := [(CDeclarationParser						parseWithNoPreprocess: aString						as: #singleDeclaration						declarations: externalInterfaceHolder externalInterface tempExternals						requestor: self) result]					on: Object errorSignal					do: [:ex | ex return: nil].		(type isKindOf: CType) ifFalse:			[(dialog builder componentAt: #typeField) flash. type := nil]].	db		aspectAt: #doAbort		put: [dialog close. ^nil].	acceptBlock :=		[| accept |		accept := true.		externalName value isEmpty			ifTrue: [(dialog builder componentAt: #externalNameField) flash. accept := false]			ifFalse: [type == nil					ifTrue: [(dialog builder componentAt: #typeField) flash. accept := false]].		accept ifTrue: [dialog close].		accept].	db		aspectAt: #doOK		put: acceptBlock.	db		aspectAt: #doBrowse		put: [acceptBlock value ifTrue: [doBrowse := true]].	dialog allButOpenFrom: (self class interfaceSpecFor: #typedefMethodCreationDialog).	"Make CR behave like tab in name field"	db openDialog.	dialog cancel value ifTrue: [^nil].	externalName := externalName value.	type isNil ifTrue: [type := CVoidType void].	newExternalVariable := CTypedefType new							name: externalName;							type: type.	externalInterfaceHolder externalInterface generateMethodsForExternal: newExternalVariable.	self update.	doBrowse ifTrue:		[self browseAccessMethodsFor: newExternalVariable name wildcard: true]</body><body package="DLLCC-Tools">addUnion	"Open a dialog to collect the basic information required to create a new access method, create the method, and if specified open a browser. The latter allows the user to fine tune the access method "	| unionName newUnion |	unionName := Dialog request: #addUnion &lt;&lt; #dllcc &gt;&gt; 'New Union Name:' for: builder window.	(unionName isNil or: [unionName isEmpty]) ifTrue: [^self].	unionName := unionName asSymbol.	newUnion := CCompositeType new beUnion name: unionName.	newUnion at: #firstMember put: 0-&gt;CIntegerType int.	newUnion at: #secondMember put: 1-&gt;CIntegerType char.	newUnion at: #thirdMember put: 2-&gt;CIntegerType long.	externalInterfaceHolder externalInterface generateMethodsForExternal: newUnion.	self browseAccessMethodsFor: unionName wildcard: false.	self update</body><body package="DLLCC-Tools">addVariable	"Open a dialog to collect the basic information required to create a new	 access method, create the method, and if specified open a browser.	 The latter allows the user to fine tune the access method."	| dialog externalName db doBrowse type typeString newExternalVariable acceptBlock |	doBrowse := false.	dialog := SimpleDialog new.	db := dialog builder.	db aspectAt: #externalName put: (externalName := '' asValue).	db aspectAt: #typeMenu put: self typeMenu.	db aspectAt: #typeString put: (typeString := nil asValue).	typeString compute:		[:aString |		type := [(CDeclarationParser						parseWithNoPreprocess: aString						as: #singleDeclaration						declarations: externalInterfaceHolder externalInterface tempExternals						requestor: self) result]					on: Object errorSignal					do: [:ex | ex return: nil].		(type isKindOf: CType) ifFalse:			[(dialog builder componentAt: #typeField) flash. type := nil]].	db		aspectAt: #doAbort		put: [dialog close. ^nil].	acceptBlock :=		[| accept |		accept := true.		externalName value isEmpty			ifTrue: [(dialog builder componentAt: #externalNameField) flash. accept := false]			ifFalse: [type == nil ifTrue: [(dialog builder componentAt: #typeField) flash. accept := false]].		accept ifTrue: [dialog close].		accept].	db		aspectAt: #doOK		put: acceptBlock.	db		aspectAt: #doBrowse		put: [acceptBlock value ifTrue: [doBrowse := true]].	dialog allButOpenFrom: (self class interfaceSpecFor: #varMethodCreationDialog).	"Make CR behave like tab in name field"	db openDialog.	dialog cancel value ifTrue: [^nil].	externalName := externalName value.	type isNil ifTrue: [type := CVoidType void].	newExternalVariable := ExternalVariable new							name: externalName;							type: type.	externalInterfaceHolder externalInterface generateMethodsForExternal: newExternalVariable.	self update.	doBrowse ifTrue:		[self browseAccessMethodsFor: newExternalVariable name wildcard: true]</body><body package="DLLCC-Tools">browseAccessMethodsFor: aString wildcard: aBoolean	"Open a list browser on the access methods matchingaString in the receiver's interface."	self		openListBrowserOnSelectorsMatching: (aBoolean ifTrue: [aString, '*'] ifFalse: [aString])		label: #accessMethod &lt;&lt; #dllcc &gt;&gt; 'Access method'</body><body package="DLLCC-Tools">openListBrowserOnSelectorsMatching: aString label: labelString	"Open a list browser on every method that matches aString in the receiver's interface.  If there is no match, answer the receiver."	| interface selectors |	interface := externalInterfaceHolder externalInterface.	interface isNil ifTrue: [^self].	selectors := interface selectors asArray select: [:sel | aString match: sel].	selectors isEmpty ifTrue: [^self].	MethodCollector new		openListBrowserOn: (selectors collect: [:sel | MethodDefinition class: interface selector: sel])		label: labelString		initialSelection: nil</body><body package="DLLCC-Tools">removeIncludeDirectory	"Remove the currently selected include directory from the 	interface's include directory list. If no include directory is 	selected, do nothing. Update the receiver's views. Answer the 	receiver."	| directory interface |	directory := self external.	interface := externalInterfaceHolder externalInterface.	interface includeDirectories: (interface includeDirectoriesArray copyWithout: directory).	self update</body><body package="DLLCC-Tools">removeIncludeFile	"Remove the currently selected include file from the interface's 	include file list. If no include file is selected, do nothing. Update 	the receiver's views. Answer the receiver."	| file interface |	file := self external.	interface := externalInterfaceHolder externalInterface.	interface includeFiles: (interface includeFiles copyWithout: file).	self update</body><body package="DLLCC-Tools">removeLibraryDirectory	"Remove the currently selected library directory from the 	interface's library directory list. If no library directory is 	selected, do nothing. Update the receiver's views. Answer the 	receiver."	| directory interface |	directory := self external.	interface := externalInterfaceHolder externalInterface.	interface libraryDirectories: (interface libraryDirectoriesArray copyWithout: directory).	self update</body><body package="DLLCC-Tools">removeLibraryFile	"Remove the currently selected library file from the interface's 	library file list. If no library file is selected, do nothing. Update 	the receiver's views. Answer the receiver."	| file interface |	file := self external.	interface := externalInterfaceHolder externalInterface.	interface libraryFiles: (interface libraryFilesArray copyWithout: file).	self update</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>private-category</category><body package="DLLCC-Tools">addExternalForCategory: aCategory	"Given the selected category, prompt the user for the required information in order to create a new external for that category. Answer the receiver."	| categorySymbol |	categorySymbol := aCategory asSymbol.	categorySymbol == #procedures ifTrue: [^self addProcedure].	categorySymbol == #variables ifTrue: [^self addVariable].	categorySymbol == #typedefs ifTrue: [^self addTypedef].	categorySymbol == #structs ifTrue: [^self addStruct].	categorySymbol == #unions ifTrue: [^self addUnion].	categorySymbol == #enums ifTrue: [^self addEnum].	categorySymbol == #defines ifTrue: [^self addDefine].	categorySymbol == #macros ifTrue: [^self addMacro].	categorySymbol == #'include files' ifTrue: [^self addIncludeFile].	categorySymbol == #'include directories' ifTrue: [^self addIncludeDirectory].	categorySymbol == #'library files' ifTrue: [^self addLibraryFile].	categorySymbol == #'library directories' ifTrue: [^self addLibraryDirectory].</body><body package="DLLCC-Tools">categories	"Answer a list of symbols that will appear in the receiver's category list pane."	^#(		#'include files'		#'include directories'		#'library files'		#'library directories'		#procedures		#variables		#typedefs		#structs		#unions		#enums		#defines		#macros	) copy</body><body package="DLLCC-Tools">changedCategory	"A new category was selected or deselected, update the views accordingly."	| category |	(category := self category) isNil		ifTrue:			[self updateCategoryNotSelected.			externalList list: List new.			^self].	self updateCategorySelected.	externalList list: (self listAtCategory: category)</body><body package="DLLCC-Tools">computeCategoryList	"Answer the list of objects that will appear in the receiver's category list pane. This includes italicizing certain entries."	| categories |	self hasClassSelected ifFalse: [^List new].	categories := self categories.	1 to: 4 do: [:i | | aCategory |		aCategory := categories at: i.		categories at: i put: (aCategory asText emphasizeFrom: 1 to: aCategory size with: #italic)].	^List withAll: categories</body><body package="DLLCC-Tools">isRemoveableCategory: category	"Answer true if the argument contains removable externals, otherwise answer false."	| categorySymbol |	categorySymbol := category asSymbol.	^categorySymbol == #'include files'		or: [categorySymbol == #'include directories'		or: [categorySymbol == #'library files'		or: [categorySymbol == #'library directories']]]</body><body package="DLLCC-Tools">listAtCategory: category	"Answer a List of externals at the given category."	| categorySymbol list |	categorySymbol := category asSymbol.	list := externalInterfaceHolder externalsAtCategory: category.	(categorySymbol == #'include files' or: [	categorySymbol == #'include directories' or: [	categorySymbol == #'library files' or: [	categorySymbol == #'library directories']]])		ifTrue: [^list copy]		ifFalse: [^list]</body><body package="DLLCC-Tools">removeExternalForCategory: aCategory	"Remove the currently selected external in the given category. If the category does not contain removable externals, do nothing. Answer the receiver."	| categorySymbol |	categorySymbol := aCategory asSymbol.	categorySymbol == #'include files' ifTrue: [^self removeIncludeFile].	categorySymbol == #'include directories' ifTrue: [^self removeIncludeDirectory].	categorySymbol == #'library files' ifTrue: [^self removeLibraryFile].	categorySymbol == #'library directories' ifTrue: [^self removeLibraryDirectory].</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>actions</category><body package="DLLCC-Tools">bossOutClass	"Open a dialog to confirm or collect the basic information required to BOSS-out an external interface."	| dialog fileName db bossOutHierarchy className class |	(className := self className) isNil ifTrue: [^self].	class := Smalltalk at: className asSymbol ifAbsent: [^self].	(class isKindOf: ExternalInterface class) ifFalse: [^self].	dialog := SimpleDialog new.	db := dialog builder.	db aspectAt: #fileName put: (fileName := '' asValue).	db aspectAt: #hierarchy put: (bossOutHierarchy := false asValue).	db		aspectAt: #doCancel		put: [dialog close. ^self].	db		aspectAt: #doOK		put: [fileName value isEmpty				ifTrue: [(dialog builder componentAt: #fileName) flash]				ifFalse: [dialog close]].	dialog allButOpenFrom: (self class interfaceSpecFor: #bossOutDialog).	"Make CR behave like tab in name field"	db openDialog.	fileName := fileName value.	Cursor execute showWhile: [		bossOutHierarchy value			ifTrue: [class bossOutHierarchy: fileName sourceMode: #keep]			ifFalse: [class bossOut: fileName sourceMode: #keep]].</body><body package="DLLCC-Tools">browseClass	"Open a browser on the currently selected class. Use the current user-preference browser. If no class is selected, do nothing. Answer the receiver."	| cl |	self hasClassSelected ifFalse: 			[(builder componentAt: #ClassNameList) flash.			^self].	cl := self selectedClassOrDo: [^self classGone].	ExternalInterfaceFinder visited: cl.	SmalltalkWorkbench browseClass: cl</body><body package="DLLCC-Tools">browseExternal: anExternal 	"Open a browser on anExternal. Answer the receiver."	self openListBrowserOnSelectorsMatching: anExternal name , '*'		label: #ExternalMethod &lt;&lt; #dllcc &gt;&gt; 'External method'</body><body package="DLLCC-Tools">browseSelection	"Browse the currently selected object. This could be a class or an external object. If no object is selected, do nothing. Answer the receiver."	|anExternal|	self hasClassSelected ifFalse: [^self].	anExternal := self external.	(anExternal isNil or: [anExternal isCharacters]) ifTrue: [^self browseClass].	^self browseExternal: anExternal</body><body package="DLLCC-Tools">fileOutClass	"File out the given class. Prompt for the resulting file name.	 If no class is selected, do nothing. Answer the receiver."	| cl fileName fileManager |	cl := self selectedClassOrDo: [^self classGone].	fileName := Dialog					requestNewFileName: #FileOutOn &lt;&lt; #dllcc &gt;&gt; 'File out on'					default: (Filename filterFilename: cl printString, '.st')					for: builder window.	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName.	[fileManager timeStamp.	 cl fileOutSourceOn: fileManager.]		ensure: [fileManager close].</body><body package="DLLCC-Tools">forgetRecentlyVisitedClasses	"Force the receiver to forget all recently visited classes. Answer the receiver."	self class resetRecentlyVisited</body><body package="DLLCC-Tools">helpContents	"Open a help browser displaying the top-most book for the DLL and C Connect kit. Answer the receiver."	^self class helpContents</body><body package="DLLCC-Tools">newBuilder	"Open a new external interface builder tool. Answer the receiver."	| interfaceBuilder |	interfaceBuilder := ExternalInterfaceBuilder.	self hasClassSelected		ifFalse: [interfaceBuilder open]		ifTrue:			[| class |			class := self selectedClassOrDo: [nil].			class isNil				ifTrue: [interfaceBuilder open]				ifFalse: [interfaceBuilder openOn: (interfaceBuilder on: class)]]</body><body package="DLLCC-Tools">newClass	"Prompt the user for all relevant information to build a new interface class and actually build the class if all the information is valid. Update the receiver's views so that the new class selected. Answer the receiver."	| finder newClass |	finder := ExternalInterfaceClassFinder new.	finder createMode.	finder findClass.	newClass := finder selectedClass.	newClass isNil ifTrue: [^self].	(newClass inheritsFrom: ExternalInterface) ifFalse:		[^Dialog			warn: #mustBeExternalInterfaceSubclass &lt;&lt; #dllcc &gt;&gt; 'The superclass must be a subclass of ExternalInterface.'			for: self builder window].	self class addClass: newClass fullyQualifiedReference.	self classNameList selection: newClass fullyQualifiedReference.</body><body package="DLLCC-Tools">newExternal	"Prompt the user for information relevant for adding a new external based on the currently selected category. If the information is correct, add the new external to the category's external list, otherwise do nothing."	^self addExternalForCategory: self category</body><body package="DLLCC-Tools">newInterface	"Prompt the user for information relevant for adding a new interface based on the currently selected category. If the information is correct, add the new external to the category's external list, otherwise do nothing. If no category is selected, prompt for the creation of a new interface class."	self category isNil ifTrue: [^self newClass].	^self newExternal</body><body package="DLLCC-Tools">parcelOutClass	"Open a dialog to confirm or collect the basic information required to Parcel-out an external interface."	| parcelOutHierarchy class useBossInstead |	class := self selectedClassOrDo: [^self].	(class isKindOf: ExternalInterface class) ifFalse: [^self].	class subclasses isEmpty ifFalse: [parcelOutHierarchy := true asValue].	useBossInstead := false asValue.	useBossInstead compute:		[:v|		v == true ifTrue: [^self bossOutClass].		v value].	(Parcel name: class name)		saveParcelDialogFor: nil		preOpen:			[:dialog|			nil == parcelOutHierarchy ifFalse:				[dialog					addCheckLabels: (Array with: #hierarchy &lt;&lt; #dllcc &gt;&gt; 'hierarchy')					values: (Array with: parcelOutHierarchy)					equalize: true					columns: 1].			dialog				addCheckLabels: (Array with: #useBOSS &lt;&lt; #dllcc &gt;&gt; 'use BOSS')				values: (Array with: useBossInstead)				equalize: true				columns: 1]		preSave: [:parcel|			useBossInstead value ifTrue: [^self bossOutClass].			class parcelClasses: (parcelOutHierarchy value										ifTrue: [class withAllSubclasses]										ifFalse: [Array with: class])				toParcel: parcel]</body><body package="DLLCC-Tools">regenerate	"For the current interface class, parse its include files and recompile	 all existing access methods. If any error occurs during the parse or	 recompilation and warning dialog is displayed and regeneration stops.	 Answer the receiver." 	Cursor execute showWhile:		[[externalInterfaceHolder externalInterface regenerateMethods.		  ObjectMemory quickGC.		  self update]			on: Object errorSignal			do: [:ex | | output |				output := String new writeStream.				output nextPutAll: (#FollowingRegenerationError &lt;&lt; #dllcc &gt;&gt; 'The following error occurred during regeneration:') asString;					nextPut: Character cr;					nextPutAll: ex description.				Dialog warn: output contents for: builder window.				ex return: nil]]</body><body package="DLLCC-Tools">remove	"Remove the currently selected external. If no external is selected, attempt to remove the currently selected class. If no class or external is selected, do nothing. Answer the receiver."	self external isNil ifTrue: [^self removeClass].	^self removeExternal</body><body package="DLLCC-Tools">removeClass	"Prompt the user to remove the currently selected class. If the user concers, remove the class, otherwise do nothing. Answer the receiver."	| cl |	cl := self selectedClassOrDo: [^self classGone].	self removeClass: cl</body><body package="DLLCC-Tools">removeExternal	"Remove the currently selected external if it is one that may be removed. Answer the receiver."	^self removeExternalForCategory: self category</body><body package="DLLCC-Tools">renameClass	"Prompt the user for the currently selected class' new name and rename it to such. Answer the receiver."	| cl clName aString newName |	cl := self selectedClassOrDo: [^self classGone].	aString := Dialog request: (#EnterNewClassName &lt;&lt; #dllcc &gt;&gt; 'Enter new ClassName') initialAnswer: cl printString for: builder window.	aString isEmpty ifTrue: [^self].	newName := SystemUtils			validateClassName: aString			for: builder window.	newName == nil ifTrue: [^self].	clName := cl fullyQualifiedReference.	SmalltalkWorkbench		rename: cl		to: newName		do: 			[:cls :nm | 			ExternalInterfaceClasses remove: clName.			ExternalInterfaceClasses add: cls fullyQualifiedReference.			RecentlyVisitedClasses remove: clName ifAbsent: [].			RecentlyVisitedClasses add: cls fullyQualifiedReference.			self class changed: #externalInterfaceClasses.			self classNameList selection: cls fullyQualifiedReference]		for: builder window		browser: nil</body><body package="DLLCC-Tools">showAllClasses	"Set the current class view pane to show all external interfaces in the system. Answer the receiver."	filter := #showAllClasses.	(builder componentAt: #ClassNameListLabel)  labelString: (#Class &lt;&lt; #dllcc &gt;&gt; 'Class').	self showClasses: ExternalInterfaceClasses</body><body package="DLLCC-Tools">showRecentlyVisitedClasses	"Set the current class view pane to show all recently visited external interfaces in the system. Answer the receiver."	filter := #showRecentlyVisitedClasses.	(builder componentAt: #ClassNameListLabel) widget labelString: (#RecentlyVisitedClass &lt;&lt; #dllcc &gt;&gt; 'Recently Visited Class').	self showClasses: RecentlyVisitedClasses</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>accessing</category><body package="DLLCC-Tools">category	"Answer the currently selected category from the receiver's category pane."	^self categoryList selection</body><body package="DLLCC-Tools">classID	"Answer the currently selected class from the receiver's class list pane."	| sel |	sel := self classNameList selection.	^sel == nil		ifTrue: [nil]		ifFalse: [sel asQualifiedReference]</body><body package="DLLCC-Tools">className	"Answer the currently selected class from the receiver's class list pane."	| sel |	sel := self classNameList selection.	^sel == nil		ifTrue: [nil]		ifFalse: [sel asSymbol]</body><body package="DLLCC-Tools">external	"Answer the currently selected external from the receiver's external pane."	^self externalList selection</body><body package="DLLCC-Tools">hasClassSelected	^self classNameList selection notNil</body><body package="DLLCC-Tools">selectedClassOrDo: aBlock	| sel |	sel := self classNameList selection.	^sel == nil		ifTrue: [aBlock value]		ifFalse: [sel asQualifiedReference valueOrDo: aBlock]</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>private-updating</category><body package="DLLCC-Tools">updateCategoryNotSelected	"A category was deselected, update all views, menus, and buttons."	| subMenu |	(ExternalListMenu menuItemAt: 1) disable.	subMenu := (MenuBarMenu menuItemAt: 3) submenu.	(subMenu menuItemAt: 1) disable.	self hasClassSelected ifTrue: 			[(builder componentAt: #removeButton) enable.			(builder componentAt: #ExternalListLabel) labelString: (#Externals &lt;&lt; #dllcc &gt;&gt; 'Externals')]</body><body package="DLLCC-Tools">updateCategorySelected	"A category was selected, update all views, menus, and buttons."	| subMenu |	(ExternalListMenu menuItemAt: 1) enable.	subMenu := (MenuBarMenu menuItemAt: 3) submenu.	(subMenu menuItemAt: 1) enable.	(self hasClassSelected and: [self category notNil])		ifTrue:			[| label |			label := self category copy asString.			label at: 1 put: label first asUppercase.			(builder componentAt: #removeButton) disable.			(builder componentAt: #ExternalListLabel) labelString: label]</body><body package="DLLCC-Tools">updateClassNotSelected	"A class was deselected, update all views, menus, and buttons."	| subMenu |	subMenu := (MenuBarMenu menuItemAt: 2) submenu.	3 to: 8 do: [:menuItemIndex | (subMenu menuItemAt: menuItemIndex) disable].	5 to: 10 do: [:menuItemIndex | (ClassListMenu menuItemAt: menuItemIndex) disable].	#(#browseButton #removeButton #regenerateButton)		do: [:name | (builder componentAt: name) disable].</body><body package="DLLCC-Tools">updateClassSelected	"A category was selected, update all views, menus, and buttons."	| subMenu |	subMenu := (MenuBarMenu menuItemAt: 2) submenu.	3 to: 8 do: [:menuItemIndex | (subMenu menuItemAt: menuItemIndex) enable].	5 to: 10 do: [:menuItemIndex | (ClassListMenu menuItemAt: menuItemIndex) enable].	#(#browseButton #removeButton #regenerateButton)		do: [:name | (builder componentAt: name) enable].</body><body package="DLLCC-Tools">updateExternalNotSelected	"An external was deselected, update all views, menus, and buttons."	| subMenu |	(ExternalListMenu menuItemAt: 2) disable.	subMenu := (MenuBarMenu menuItemAt: 3) submenu.	(subMenu menuItemAt: 2) disable.	self category notNil ifTrue: [(builder componentAt: #removeButton) disable]</body><body package="DLLCC-Tools">updateExternalSelected	"An external was selected, update all views, menus, and buttons."	| subMenu |	(self isRemoveableCategory: self category) ifTrue: [(ExternalListMenu menuItemAt: 2) enable].	subMenu := (MenuBarMenu menuItemAt: 3) submenu.	(subMenu menuItemAt: 2) enable.	(self isRemoveableCategory: self category) ifTrue: [(builder componentAt: #removeButton) enable]</body><body package="DLLCC-Tools">updateHelpAvailable	"Check if help is available."	| helpAvailable |	helpAvailable := #{HelpBrowser} isDefined.	(MenuBarMenu menuItemAt: 4) enabled: helpAvailable.	((MenuBarMenu menuItemAt: 4) submenu menuItemAt: 1) enabled: helpAvailable.</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>aspects</category><body package="DLLCC-Tools">categoryList	"Answer the List of categories in the category pane."	^categoryList</body><body package="DLLCC-Tools">classNameList	"Answer the List of objects in the class pane."	^classNameList</body><body package="DLLCC-Tools">externalList	"Answer the List of externals in the external pane."	^externalList</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>menus</category><body package="DLLCC-Tools">classNameListMenu	"Answer the pop-up menu for the class list pane."	^ClassListMenu</body><body package="DLLCC-Tools">externalListMenu	"Answer the pop-up menu for the external list pane."	^ExternalListMenu</body><body package="DLLCC-Tools">menuBar	"Answer the menu bar menu for the receiver's view."	^MenuBarMenu</body><body package="DLLCC-Tools">typeMenu	"Answer a menu consisting of a few often used standard types and some user-defined types"	| mb maxUserDefined userDefinedCount |	mb := MenuBuilder new.	mb			add: 'char'-&gt;'char'; add: 'short'-&gt;'short'; add: 'int'-&gt;'int';			add: 'float'-&gt;'float'; add: 'double'-&gt;'double';			add: 'unsigned char'-&gt;'unsigned char'; add: 'unsigned short'-&gt;'unsigned short';			add: 'unsigned int'-&gt;'unsigned int';			add: 'char *'-&gt;'char *'.	maxUserDefined := 15.	userDefinedCount := 1.	externalInterfaceHolder externalDictionary do: [:ext |		(ext isKindOf: CType)			ifTrue:				[userDefinedCount := userDefinedCount + 1.				mb add: ext printString-&gt; ext printString.				userDefinedCount = maxUserDefined					ifTrue:						[^mb menu]]].	^mb menu</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>interface opening</category><body package="DLLCC-Tools">error: type with: message at: position	"Intercept error message to display a 'syntax error' message."	self error: #syntaxError &lt;&lt; #dllcc &gt;&gt; 'syntax error'</body><body package="DLLCC-Tools">postOpenWith: aBuilder	"Delay adding ourselves to ExternalInterfaceFinder's dependents until the very last possible moment."	ExternalInterfaceFinder addDependent: self.	self updateHelpAvailable.	self changedClassName.	^super postOpenWith: aBuilder</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>initialize-release</category><body package="DLLCC-Tools">initialize	super initialize.	ExternalInterfaceFinder dependents isEmpty ifTrue: [self class computeExternalInterfaceClasses].	(classNameList := SelectionInList new) list: (List withAll: (ExternalInterfaceClasses asSortedCollection: [:x :y | x asString &lt; y asString])).	categoryList := SelectionInList new.	externalList := SelectionInList new.	externalInterfaceHolder := nil.	filter := #showAllClasses.	classNameList selectionIndexHolder onChangeSend: #changedClassName to: self.	categoryList selectionIndexHolder onChangeSend: #changedCategory to: self.	externalList selectionIndexHolder onChangeSend: #changedExternal to: self</body><body package="DLLCC-Tools">release	ExternalInterfaceFinder removeDependent: self.	^super release</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>events</category><body package="DLLCC-Tools">windowEvent: anEvent from: aWindow	"Intercept #close and #release events so the receiver can be released. Answer the receiver."	super windowEvent: anEvent from: aWindow.	(#(#close #release) includes: anEvent key) ifTrue: [self release]</body></methods><methods><class-id>Tools.ExternalInterfaceFinder</class-id> <category>updating</category><body package="DLLCC-Tools">update	"Update the class view pane. Answer the receiver."	self class computeExternalInterfaceClasses</body><body package="DLLCC-Tools">update: anAspect with: aParameter from: anObject 	"Watch for updated recently visited classes and updated external interface classes and update views accordingly. Answer the value of the superclass #update:with:from: method."	| class |	anAspect == #recentlyVisited ifTrue: [		filter == #showRecentlyVisitedClasses ifTrue: [self showRecentlyVisitedClasses].		class := aParameter at: 1.		class == nil ifFalse: [class := class fullyQualifiedReference].		(classNameList list includes: class) not ifTrue: [self perform: filter].		"(self classID == class			and: ((aParameter at: 2) notNil			and: [(self selectorList list includes: (aParameter at: 2)) not]))			ifTrue: [self showSelectors: self computeSelectorList]."		^self].	anAspect == #externalInterfaceClasses ifTrue: [self perform: filter].	^super		update: anAspect		with: aParameter		from: anObject</body></methods><methods><class-id>Tools.ExternalInterfaceFinder class</class-id> <category>class initialization</category><body package="DLLCC-Tools">initialize	"ExternalInterfaceFinder initialize"	| showMenu |	RecentlyVisitedClasses isNil		ifTrue: [RecentlyVisitedClasses := OrderedCollection new]		ifFalse: [RecentlyVisitedClasses removeAllSuchThat: [:cl | true]].	self changed: #recentlyVisited with: (Array with: nil).	self computeExternalInterfaceClasses.	(showMenu := Menu new)		addItem: (MenuItem						labeled: #ShowAllClasses &lt;&lt; #dllcc &gt;&gt; 'Show All Classes')						value: #showAllClasses;		addItem: (MenuItem						labeled: #ShowRecentlyVisitedClasses &lt;&lt; #dllcc &gt;&gt; 'Show Recently Visited Classes')						value: #showRecentlyVisitedClasses.	ExternalListMenu := Menu new			addItem: ((MenuItem labeled: #NewDot &lt;&lt; #dllcc &gt;&gt; 'New...') shortcutKeyCharacter: $N) value: #newExternal;			addItem: (MenuItem labeled: #Remove &lt;&lt; #dllcc &gt;&gt; 'Remove') value: #remove.	ClassListMenu := Menu new			addItem: ((MenuItem labeled: #Show &lt;&lt; #dllcc &gt;&gt; 'Show') submenu: showMenu);			addItem: (MenuItem labeled: #Update &lt;&lt; #dllcc &gt;&gt; 'Update') value: [:ctrlr | ctrlr performer update];			addItemGroup: (Array				with: (MenuItem labeled: #NewDot &lt;&lt; #dllcc &gt;&gt; 'New...')				with: (MenuItem labeled: #Builder &lt;&lt; #dllcc &gt;&gt; 'Builder')				with: (MenuItem labeled: #RenameAsDot &lt;&lt; #dllcc &gt;&gt; 'Rename As...')				with: (MenuItem labeled: #Remove &lt;&lt; #dllcc &gt;&gt; 'Remove'))				values: #(#newClass #newBuilder #renameClass #removeClass);			addItemGroup: (Array				with: (MenuItem labeled: #FileOutAsDot &lt;&lt; #dllcc &gt;&gt; 'File Out As ...')				with: (MenuItem labeled: #ParcelOutAsDot &lt;&lt; #dllcc &gt;&gt; 'Parcel Out As ...')				with: (MenuItem labeled: #Browse &lt;&lt; #dllcc &gt;&gt; 'Browse'))				values: #(#fileOutClass #parcelOutClass #browseClass);			addItemGroup: (Array				with: (MenuItem labeled: #Regenerate &lt;&lt; #dllcc &gt;&gt; 'Regenerate'))				values: #(#regenerate).	MenuBarMenu := Menu new			addItem: ((MenuItem labeled: #View &lt;&lt; #dllcc &gt;&gt; 'View') submenu: (Menu new				addItemGroup: (Array					with: ((MenuItem labeled: #ShowAllClasses &lt;&lt; #dllcc &gt;&gt; 'Show All Classes') shortcutKeyCharacter: $A)					with: (MenuItem labeled: #ShowRecentlyVisitedClasses &lt;&lt; #dllcc &gt;&gt; 'Show Recently Visited Classes'))					values: #(#showAllClasses #showRecentlyVisitedClasses);				addItemGroup: (Array					with: (MenuItem labeled: #ForgetRecentlyVisitedClasses &lt;&lt; #dllcc &gt;&gt; 'Forget Recently Visited Classes')					with: (MenuItem labeled: #Update &lt;&lt; #dllcc &gt;&gt; 'Update'))					values: #(#forgetRecentlyVisitedClasses #update)));			addItem: ((MenuItem labeled: #Class &lt;&lt; #dllcc &gt;&gt; 'Class') submenu: (Menu new				addItemGroup: (Array					with: ((MenuItem labeled: #NewDot &lt;&lt; #dllcc &gt;&gt; 'New...') shortcutKeyCharacter: $N)					with: (MenuItem labeled: #Builder &lt;&lt; #dllcc &gt;&gt; 'Builder')					with: ((MenuItem labeled: #RenameAsDot &lt;&lt; #dllcc &gt;&gt; 'Rename As...') disable)					with: ((MenuItem labeled: #RemoveDot &lt;&lt; #dllcc &gt;&gt; 'Remove...') disable))					values: #(#newClass #newBuilder #renameClass #removeClass);				addItemGroup: (Array					with: ((MenuItem labeled: #FileOutAsDot &lt;&lt; #dllcc &gt;&gt; 'File Out As ...') disable)					with: ((MenuItem labeled: #ParcelOutAsDot &lt;&lt; #dllcc &gt;&gt; 'Parcel Out As ...') disable)					with: (((MenuItem labeled: #Browse &lt;&lt; #dllcc &gt;&gt; 'Browse') shortcutKeyCharacter: $B) disable))					values: #(#fileOutClass #parcelOutClass #browseClass);				addItemGroup: (Array					with: ((MenuItem labeled: #Regenerate &lt;&lt; #dllcc &gt;&gt; 'Regenerate') disable))					values: #(#regenerate)));			addItem: ((MenuItem labeled: #External &lt;&lt; #dllcc &gt;&gt; 'External') submenu: (Menu new				addItem: ((MenuItem labeled: #NewDot &lt;&lt; #dllcc &gt;&gt; 'New...') disable) value: #newExternal;				addItem: ((MenuItem labeled: #Remove &lt;&lt; #dllcc &gt;&gt; 'Remove') disable) value: #remove));			addItem: ((MenuItem labeled: #Help &lt;&lt; #dllcc &gt;&gt; 'Help') submenu: (Menu new				addItemGroup: (Array					with: (MenuItem labeled: #Contents &lt;&lt; #dllcc &gt;&gt; 'Contents'))					values: #(#helpContents)))</body></methods><methods><class-id>Tools.ExternalInterfaceFinder class</class-id> <category>class accessing</category><body package="DLLCC-Tools">externalInterfaceClass	"Answer the class that defines the root of all external interface classes."	^ExternalInterface</body><body package="DLLCC-Tools">helpBookName	"Answer a String representing the the receiver's help book name. Please see the HelpBrowser class comments for further information on help books."	^#dcc</body><body package="DLLCC-Tools">helpContents	"Open a help browser displaying the top-most book for the DLL and C Connect kit. Answer the receiver."	(#{HelpBrowser} valueOrDo: [^self error: (#helpUnavailable &lt;&lt; #dllcc &gt;&gt; 'help unavailable')])		openTo: self helpBookName</body></methods><methods><class-id>Tools.ExternalInterfaceFinder class</class-id> <category>accessing</category><body package="DLLCC-Tools">addClass: fullyQualifiedReference 	ExternalInterfaceClasses add: fullyQualifiedReference.	self changed: #externalInterfaceClasses</body></methods><methods><class-id>Tools.ExternalInterfaceFinder class</class-id> <category>statistics</category><body package="DLLCC-Tools">recentlyVisitedClasses	"Answer a copy of the collection of recently visited interface classes."	^RecentlyVisitedClasses copy</body><body package="DLLCC-Tools">resetRecentlyVisited	"Prompt the user to confirm forgetting all recently visited interface	 classes.  If the result is yes, forget the classes, otherwise do nothing.	 Answer the receiver."	(Dialog		confirm: (#reallyForgetWhichClasses &lt;&lt; #dllcc &gt;&gt; 'Really forget which classes&lt;n&gt;have recently been visited?') expandMacros)		ifTrue: 			[RecentlyVisitedClasses := OrderedCollection new.			self changed: #recentlyVisited with: (Array with: nil)]</body><body package="DLLCC-Tools">visited: class 	"Used to collect an impression of what classes the user has been working with."	| clName |	clName := class fullyQualifiedReference.	(RecentlyVisitedClasses includes: clName) ifTrue:		[RecentlyVisitedClasses remove: clName].	RecentlyVisitedClasses addFirst: clName.	RecentlyVisitedClasses size &gt; 10 ifTrue: [RecentlyVisitedClasses removeLast].	self changed: #recentlyVisited with: (Array with: class)</body></methods><methods><class-id>Tools.ExternalInterfaceFinder class</class-id> <category>private</category><body package="DLLCC-Tools">computeExternalInterfaceClasses	"Answer a collection of all the interface classes defined in the system. Update the receiver's notion of these classes, and recently visited classes, based on new and removed interfaces."	| deadRecents |	ExternalInterfaceClasses := Set new.	self externalInterfaceClass allSubclasses do: [:aClass |		ExternalInterfaceClasses add: aClass fullyQualifiedReference].	deadRecents := RecentlyVisitedClasses select: [:classID | (ExternalInterfaceClasses includes: classID) not].	deadRecents isEmpty ifFalse: [RecentlyVisitedClasses removeAll: deadRecents].	self changed: #externalInterfaceClasses.	^ExternalInterfaceClasses</body></methods><methods><class-id>Tools.ExternalInterfaceFinder class</class-id> <category>interface opening</category><body package="DLLCC-Tools">open	"Open a view on the receiver."	"ExternalInterfaceFinder open"	| bldr inst |	bldr := (inst := self new) openInterface: #windowSpec.	#(#browseButton #removeButton #regenerateButton ) do: [:n | (bldr componentAt: n) disable].	inst builder: bldr.	(bldr window) application: inst; sendWindowEvents: #(#close #release)</body><body package="DLLCC-Tools">openOnClass: aClass	"Open a view of the receiver editing the given class."	"ExternalInterfaceFinder openOnClass: SomeClass"	| bldr inst |	bldr := (inst := self new) openInterface: #windowSpec.	inst builder: bldr.	inst classNameList selection: aClass fullyQualifiedReference.	(bldr window) application: inst; sendWindowEvents: #(#close #release)</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>aspects</category><body package="DLLCC-Tools">categoryList	"Answer the selection-in-list object that contains the builder's categories."	^categoryList isNil ifTrue: [categoryList := SelectionInList new] ifFalse: [categoryList]</body><body package="DLLCC-Tools">externalMultiSelectionList	"Answer the external pane's multi-selection-in-list. The list's contents change depending on the selected category, but will typically contain external declaration objects."	^externalMultiSelectionList</body><body package="DLLCC-Tools">externalSingleSelectionList	"Answer the external pane's single-selection-in-list. This list typically contains the builders include files and directories."	^externalSingleSelectionList</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>private-updating</category><body package="DLLCC-Tools">updateCategoryNotSelected	"Update the receiver's view state (buttons and menus) when a category is deselected. Answer the receiver."	| menu |	currentSubCanvas == #single		ifTrue: [externalSingleSelectionList list: List new]		ifFalse: [externalMultiSelectionList list: List new].	#(#addButton #removeButton)		do: [:name | (builder componentAt: name) disable].	menu := ((builder aspectAt: #menuBar) menuItemAt: 3) submenu.	1 to: 4 do: [:i | (menu menuItemAt: i) disable]</body><body package="DLLCC-Tools">updateCategorySelected	"Update the receiver's view state (buttons and menus) when a category is selected. Answer the receiver."	| selection widget menu |	selection := self category asSymbol.	widget := (self builder componentAt: #ExternalSubCanvas) widget.	(selection == #'include files' or: [selection == #'include directories'])		ifTrue:			[selection == #'include files'				ifTrue: [externalSingleSelectionList list: includeFiles]				ifFalse: [externalSingleSelectionList list: includeDirectories].			currentSubCanvas == #single				ifFalse: [					widget client: self spec:externalSingleSelectionSubCanvas.					currentSubCanvas := #single].			self external isNil ifFalse: [(builder componentAt: #removeButton) enable].			(builder componentAt: #addButton) enable.			menu := ((builder aspectAt: #menuBar) menuItemAt: 3) submenu.			(menu menuItemAt: 1) enable.			(menu menuItemAt: 3) disable.			(menu menuItemAt: 4) disable.]		ifFalse:			[selection := externalSelectionDictionary at: self category ifAbsent: [^self].			externalMultiSelectionList list: selection key.			externalMultiSelectionList selectionIndexes: selection value.			currentSubCanvas == #multi				ifFalse: [					widget client: self spec: externalMultiSelectionSubCanvas.					currentSubCanvas := #multi].			#(#addButton #removeButton)				do: [:name | (builder componentAt: name) disable].			menu := ((builder aspectAt: #menuBar) menuItemAt: 3) submenu.			(menu menuItemAt: 1) disable.			(menu menuItemAt: 3) enable.			(menu menuItemAt: 4) enable]</body><body package="DLLCC-Tools">updateClassDefined	"Update the receiver's view state (buttons and menus) when a class is defined. Answer the receiver."	| button menu |	button := builder componentAt: #addMethodsButton.	menu := ((builder aspectAt: #menuBar) menuItemAt: 2) submenu.	(externalInterfaceHolder isNil or: [externalInterfaceHolder externalInterface isNil])		ifTrue:			[button disable.			(menu menuItemAt: 2) disable.			(menu menuItemAt: 3) disable]		ifFalse:			[button enable.			(menu menuItemAt: 2) enable.			(menu menuItemAt: 3) enable]</body><body package="DLLCC-Tools">updateExternalLabel	"Update the receiver's external view pane label when a new category is selected. Answer the receiver."	| label selection |	selection := self category.	selection isNil		ifTrue: [(builder componentAt: #ExternalListLabel) labelString: (#Externals &lt;&lt; #dllcc &gt;&gt; 'Externals')]		ifFalse:			[selection := selection asSymbol.					label := selection asString.			label at: 1 put: (label first asUppercase).			(builder componentAt: #ExternalListLabel) labelString: label]</body><body package="DLLCC-Tools">updateHelpAvailable	"Check if help is available."	| helpAvailable |	helpAvailable := #{HelpBrowser} isDefined.	(MenuBarMenu menuItemAt: 4) enabled: helpAvailable.	((MenuBarMenu menuItemAt: 4) submenu menuItemAt: 1) enabled: helpAvailable.</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>accessing</category><body package="DLLCC-Tools">category	"Answer the String representing the currently selected category."	^self categoryList selection</body><body package="DLLCC-Tools">external	"Answer the currently selected external. If no external is selected, answer nil. The external can be a String (include file or include directory), ExternalObject, or CMacroDefinition."	^self externalSingleSelectionList selection</body><body package="DLLCC-Tools">menuBar	"Answer the receiver's interface menu bar."	^MenuBarMenu</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>actions</category><body package="DLLCC-Tools">add	"Add an object to the currently selected category. The behavior of this message changes depending on the category. Answer the receiver."	^self addExternalForCategory: self category</body><body package="DLLCC-Tools">addDirectory	"Add a directory to the list of directories that will be searched when parsing header files."	^self addExternalForCategory: #'include directories'</body><body package="DLLCC-Tools">addFile	"Add a file to the list of header files that are parsed when building the external objects."	^self addExternalForCategory: #'include files'</body><body package="DLLCC-Tools">addMethods	"Prompt the user for a interface class name.  Compile into that class methods for the current type selection set."	| class  defaultClassName |	(externalInterfaceHolder isNil	 or: [externalInterfaceHolder externalDictionary isNil]) ifTrue:		[^Dialog			warn: #MustParseHeadersFirst &lt;&lt; #dllcc &gt;&gt; 'You must parse header files first.'			for: builder window].	defaultClassName := externalInterfaceHolder externalInterface notNil		ifTrue: [externalInterfaceHolder externalInterface fullName]		ifFalse: [''].	defaultClassName := Dialog							request: (#ClassName &lt;&lt; #dllcc &gt;&gt; 'Class name:')							initialAnswer: defaultClassName							for: builder window.	defaultClassName isEmpty ifTrue: [^self].	class := defaultClassName asQualifiedReference valueOrDo: [nil].	(class isNil	 or: [(class inheritsFrom: ExternalInterface) not]) ifTrue:		[^Dialog 			warn: (#sNotAnExternalClass &lt;&lt; #dllcc &gt;&gt; '&lt;1s&gt; is not an ExternalInterface class'						expandMacrosWith: defaultClassName)			for: builder window].	Cursor execute showWhile:		[class			generateMethodsFrom: self declarations			selectedKeys: self selectedKeys].	ObjectMemory quickGC</body><body package="DLLCC-Tools">browseClass	"Open a browser on the class currently associated with the receiver. If no class is defined, simply do nothing. Answer the receiver."	(externalInterfaceHolder isNil or: [externalInterfaceHolder externalInterface isNil]) ifTrue:		[^Dialog			warn: #noInterfaceClass &lt;&lt; #dllcc &gt;&gt; 'No interface class has been defined.'			for: builder window].	SmalltalkWorkbench browseClass: externalInterfaceHolder externalInterface</body><body package="DLLCC-Tools">defineClass	"Prompt the user for relevant information to define a new ExternalInterface class and compile that class into the system. Answer the receiver."	| finder newClass |	finder := ExternalInterfaceClassFinder new.	finder createMode.	finder findClass.	newClass := finder selectedClass.	newClass isNil ifTrue: [^self].	(newClass inheritsFrom: ExternalInterface) ifFalse:		[^Dialog			warn: #mustBeExternalInterfaceSubclass &lt;&lt; #dllcc &gt;&gt; 'The superclass must be a subclass of ExternalInterface.'			for: self builder window].	ExternalInterfaceFinder addClass: newClass fullyQualifiedReference.	externalInterfaceHolder isNil		ifTrue: [self declarations: newClass]		ifFalse: [externalInterfaceHolder externalInterface: newClass].	includeDirectories notNil ifTrue:		[newClass includeDirectories addAll: includeDirectories].	includeFiles notNil ifTrue:		[newClass includeFiles addAll: includeFiles].	Cursor execute showWhile:		[newClass generateMethodsFrom: self declarations selectedKeys: self selectedKeys].	ObjectMemory quickGC.	self updateClassDefined</body><body package="DLLCC-Tools">deselectAllExternals	"Deselect all the externals in the externals pane of the receiver's view associated with the current category. If no category is selected, do nothing. Answer the receiver."	| externals category |	(category := self category) isNil ifTrue: [^self].	externals := externalSelectionDictionary at: category ifAbsent: [^self].	externals value: Set new.	self categoryChange</body><body package="DLLCC-Tools">helpContents	"Open a help browser displaying the top-most book for the DLL and C Connect kit. Answer the receiver."	^ExternalInterfaceFinder helpContents</body><body package="DLLCC-Tools">parse	"Parse the current set of include files. Search for those files in the	 current set of incude directories. Add all the externals found in	 those files to the receiver's externals collection and update all views.	 Display an error dialog if any problems occur during the parse."	| declarations |	includeFiles isEmpty ifTrue:		[^Dialog			warn: #pleaseParse &lt;&lt; #dllcc &gt;&gt; 'Please add the include files to parse.'			for: builder window].	declarations := ExternalDictionary new.	Cursor execute showWhile:		[([CDeclarationParser				parseIncludeFiles: includeFiles				declarations: declarations				includeDirectories: includeDirectories				requestor: nil]			on: Object errorSignal			do: [:ex | | output |				(output := String new writeStream)					nextPutAll: (#followingErrorOccurred &lt;&lt; #dllcc &gt;&gt; 'The following error occurred during the parse:') asString;					nextPut: Character cr;					nextPutAll: ex description.				Dialog warn: output contents for: builder window.				ex return: nil]) notNil			ifTrue:				[self declarations: declarations.				 (builder componentAt: #defineButton) enable.				 (builder componentAt: #addMethodsButton) enable]]</body><body package="DLLCC-Tools">remove	"Remove the currently selected external which is typically an include file or directory. Answer the receiver."	^self removeExternalForCategory: self category</body><body package="DLLCC-Tools">selectAllExternals	"Select all the externals in the externals pane of the receiver's view associated with the current category. If no category is selected, do nothing. Answer the receiver."	| externals category selected |	(category := self category) isNil ifTrue: [^self].	externals := externalSelectionDictionary at: category ifAbsent: [^self].	selected := externals value.	1 to: externals key size do: [:i | selected add: i].	self categoryChange</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>initialize-release</category><body package="DLLCC-Tools">initialize	"Initialize a new instance of the receiver. Answer the receiver."	super initialize.	externalInterfaceHolder := nil.	categoryList := SelectionInList new.	categoryList list: self computeCategoryList.	categoryList selectionIndexHolder onChangeSend: #categoryChange to: self.	currentSubCanvas := #single.	includeFiles := List new.	includeDirectories := List new.	externalSingleSelectionList := SelectionInList new.	externalSingleSelectionList selectionIndexHolder onChangeSend: #externalChange to: self.	externalMultiSelectionList := MultiSelectionInList new.	externalMultiSelectionSubCanvas :=		UISpecification			readFromClass: self class			methodName: #externalMultiSelectionSubCanvas.	externalSingleSelectionSubCanvas :=		UISpecification			readFromClass: self class			methodName: #externalSingleSelectionSubCanvas.	self initializeSelections</body><body package="DLLCC-Tools">on: anInterface	"Answer an initialized instance of the receiver. The receiver can optionally modify the argument, as opposed to requiring a class definition action."	self initialize.	self declarations: anInterface.	includeFiles addAll: anInterface includeFiles.	includeDirectories addAll: anInterface includeDirectories</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>interface dialogs</category><body package="DLLCC-Tools">addIncludeDirectory	"Prompt the user for an include directory name and add it to the builder's list of include directories that are searched when parsing an include file. Answer the receiver."	| directory external |	directory := Dialog request: #addIncludeDirectory &lt;&lt; #dllcc &gt;&gt; 'Include Directory:' for: builder window.	(directory isNil or: [directory isEmpty]) ifTrue: [^self].	external := self external.	external isNil		ifTrue: [includeDirectories addLast: directory]		ifFalse: [includeDirectories add: directory before: external]</body><body package="DLLCC-Tools">addIncludeFile	"Prompt the user for an include file name and add it to the builder's list of include files that can be parsed to build the list of external objects that can be added to an interface class. Answer the receiver."	| file external |	file := Dialog request: #addIncludeFile &lt;&lt; #dllcc &gt;&gt; 'Include File:' for: builder window.	(file isNil or: [file isEmpty]) ifTrue: [^self].	external := self external.	external isNil		ifTrue: [includeFiles addLast: file]		ifFalse: [includeFiles add: file before: external].	(builder componentAt: #parseButton) enable</body><body package="DLLCC-Tools">removeIncludeDirectory	"Remove the currently selected include directory from the list of directories the receiver searches when parsing an include file. If no include directory is selected do nothing. Answer the receiver."	| external |	external := self external.	external isNil ifTrue: [^self].	includeDirectories remove: external</body><body package="DLLCC-Tools">removeIncludeFile	"Remove the currently selected include file from the list of files the receiver can parse to produce the list of externals that can be added to an interface class. If no include file is selected do nothing. Answer the receiver."	| external |	external := self external.	external isNil ifTrue: [^self].	includeFiles remove: external.	includeFiles isEmpty ifTrue: [(builder componentAt: #parseButton) disable]</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>private</category><body package="DLLCC-Tools">addExternalForCategory: aCategory	"Prompt the user for information to add to the given category. If it is not a category where information can be added, do nothing. Answer the receiver."	| categorySymbol |	categorySymbol := aCategory asSymbol.	categorySymbol == #'include files' ifTrue: [^self addIncludeFile].	categorySymbol == #'include directories' ifTrue: [^self addIncludeDirectory]</body><body package="DLLCC-Tools">categories	"Answer an array of symbols that define the values in the receiver's category view pane."	^#(		#'include files'		#'include directories'		#procedures		#variables		#typedefs		#structs		#unions		#enums		#defines		#macros	) copy</body><body package="DLLCC-Tools">categoryChange	"A category in the receiver's category pane was selected or deselected. Update the receiver's view based on this new selection. Answer the receiver."	| selection |	selection := self category.	selection isNil		ifTrue: [^self updateCategoryNotSelected]		ifFalse: [selection := selection asSymbol].	self updateCategorySelected.	self updateExternalLabel</body><body package="DLLCC-Tools">computeCategoryList	"Answer a List of categories that should appear in the receiver's category pane. Modify the include file and include directory items to be italicized text."	| categories |	categories := self categories.	1 to: 2 do: [:i | | aCategory |		aCategory := categories at: i.		categories at: i put: (aCategory asText emphasizeFrom: 1 to: aCategory size with: #italic)].	^List withAll: categories</body><body package="DLLCC-Tools">declarations	"Answer the ExternalDictionary of declarations the receiver is currently building. If no externals have been parsed answer nil."	externalInterfaceHolder isNil ifTrue: [^nil].	^externalInterfaceHolder externalDictionary</body><body package="DLLCC-Tools">declarations: declarations	"Set the receiver's declarations to the argument. Update the category selection list based on these declarations. Answer the receiver."	self externalInterface: declarations.	externalSelectionDictionary := IdentityDictionary new.	#(procedures variables typedefs structs unions enums defines macros) do: [:category |		externalSelectionDictionary at: category put: (self listAtCategory: category)-&gt;Set new]</body><body package="DLLCC-Tools">externalChange	"An external in the receiver's external pane was selected or deselected. Update the receiver's view based on this new selection. Answer the receiver."	| removeButton menu |	removeButton := builder componentAt: #removeButton.	menu := ((builder aspectAt: #menuBar) menuItemAt: 3) submenu.	self external isNil		ifTrue:			[removeButton disable.			(menu menuItemAt: 2) disable]		ifFalse:			[removeButton enable.			(menu menuItemAt: 2) enable]</body><body package="DLLCC-Tools">externalInterface: anInterface	"Inform the receiver to be building an interface for the given argument. Answer the receiver."	externalInterfaceHolder isNil		ifTrue: [externalInterfaceHolder := ExternalInterfaceHolder on: anInterface]		ifFalse: [externalInterfaceHolder on: anInterface]</body><body package="DLLCC-Tools">initializeSelections	"Initialize the external selections that appear in the receiver's external view pane."	externalSelectionDictionary := IdentityDictionary new.	externalSelectionDictionary		at: #procedures put: List new -&gt; Set new;		at: #variables put:  List new -&gt; Set new;		at: #typedefs put:  List new -&gt; Set new;		at: #structs put:  List new -&gt; Set new;		at: #unions put:  List new -&gt; Set new;		at: #enums put:  List new -&gt; Set new;		at: #defines put:  List new -&gt; Set new;		at: #macros put:  List new -&gt; Set new.</body><body package="DLLCC-Tools">listAtCategory: category	"Answer the list of externals at the given category -- typically a classification of external object like procedure, typedef, struct, etc. If no category is selected, do nothing. If the receiver is not editing an interface, do nothing."	| externals |	externalInterfaceHolder isNil ifTrue: [^List new].	externals := externalInterfaceHolder externalsAtCategory: category.	^externals reject: [:anExternal | anExternal isCharacters]</body><body package="DLLCC-Tools">removeExternalForCategory: aCategory	"Remove the currently selected external from the given category. If the category is not one where externals can be removed, do nothing. Answer the receiver."	| categorySymbol |	categorySymbol := aCategory asSymbol.	categorySymbol == #'include files' ifTrue: [^self removeIncludeFile].	categorySymbol == #'include directories' ifTrue: [^self removeIncludeDirectory]</body><body package="DLLCC-Tools">selectedKeys	"Answer an IdentitySet of externals that are selected in the reciever's external view pane."	| selectedKeys |	selectedKeys := IdentitySet new.	externalInterfaceHolder isNil ifTrue: [^selectedKeys].	#(defines macros typedefs structs unions enums variables procedures)		do: [:category | | selections externals |			selections := (externalSelectionDictionary at: category) value.			selections isEmpty ifFalse: [				externals := externalInterfaceHolder externalsAtCategory: category.				selections do: [:anIndex | selectedKeys add: (externals at: anIndex) name]]].	^selectedKeys</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder</class-id> <category>interface opening</category><body package="DLLCC-Tools">postOpenWith: aBuilder	"After the receiver's view is open, update all menu and button states depending on the receiver's current set-up. Answer the value of the superclass #postOpenWith: method."	| parseButton |	parseButton := builder componentAt: #parseButton.	includeFiles isEmpty		ifTrue: [parseButton disable]		ifFalse: [parseButton enable].	self updateCategoryNotSelected.	self updateClassDefined.	self updateHelpAvailable.	^super postOpenWith: aBuilder</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder class</class-id> <category>instance creation</category><body package="DLLCC-Tools">on: anInterface	"Answer a new instance of the receiver used to build external interfaces. The argument specifies the ExternalInterface class that the builder can modify."	^self new on: anInterface</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder class</class-id> <category>class initialization</category><body package="DLLCC-Tools">initialize	"ExternalInterfaceBuilder initialize"	MenuBarMenu := Menu new			addItem: ((MenuItem labeled: #Builder &lt;&lt; #dllcc &gt;&gt; 'Builder') submenu: (Menu new				addItemGroup: (Array					with: (MenuItem labeled: #AddIncludeFilesDot &lt;&lt; #dllcc &gt;&gt; 'Add Include File...')					with: (MenuItem labeled: #AddIncludeDirectoryDot &lt;&lt; #dllcc &gt;&gt; 'Add Include Directory...'))					values: #(#addFile #addDirectory);				addItemGroup: (Array					with: (MenuItem labeled: #ParseFiles &lt;&lt; #dllcc &gt;&gt; 'Parse Files'))					values: #(#parse)));			addItem: ((MenuItem labeled: #Class &lt;&lt; #dllcc &gt;&gt; 'Class') submenu: (Menu new				addItemGroup: (Array					with: (MenuItem labeled: #DefineDot &lt;&lt; #dllcc &gt;&gt; 'Define...')					with: (MenuItem labeled: #AddMethodsToDot &lt;&lt; #dllcc &gt;&gt; 'Add Methods To...'))					values: #(#defineClass #addMethods);				addItemGroup: (Array					with: ((MenuItem labeled: #Browse &lt;&lt; #dllcc &gt;&gt; 'Browse')  shortcutKeyCharacter: $B))					values: #(#browseClass)));			addItem: ((MenuItem labeled: #Externals &lt;&lt; #dllcc &gt;&gt; 'Externals') submenu: (Menu new				addItemGroup: (Array					with: (MenuItem labeled: #AddDot &lt;&lt; #dllcc &gt;&gt; 'Add...')					with: (MenuItem labeled: #Remove &lt;&lt; #dllcc &gt;&gt; 'Remove'))					values: #(#add #remove);				addItemGroup: (Array					with: (MenuItem labeled: #SelectAll &lt;&lt; #dllcc &gt;&gt; 'Select All')					with: (MenuItem labeled: #DeselectAll &lt;&lt; #dllcc &gt;&gt; 'Deselect All'))					values: #(#selectAllExternals #deselectAllExternals)));			addItem: ((MenuItem labeled: #Help &lt;&lt; #dllcc &gt;&gt; 'Help') submenu: (Menu new				addItemGroup: (Array					with: (MenuItem labeled: #Contents &lt;&lt; #dllcc &gt;&gt; 'Contents'))					values: #(#helpContents)))</body></methods><methods><class-id>External.ExternalInterfaceHolder</class-id> <category>accessing</category><body package="DLLCC-Tools">defines	"Answer a list of all #define externals held by the receiver."	| aList |	aList := SortedCollection sortBlock: [:x :y | x name &lt;= y name].	externalDictionary ownDo: [:anExternal |		((anExternal isKindOf: CMacroDefinition)			and: [anExternal numArgs isNil or: [anExternal numArgs == 0]])				ifTrue: [aList add: anExternal]].	^List withAll: aList</body><body package="DLLCC-Tools">enums	"Answer a list of all enumeration type externals held by the receiver."	| aList |	aList := SortedCollection sortBlock: [:x :y | x name &lt;= y name].	externalDictionary ownDo: [:anExternal |		(anExternal isKindOf: CEnumerationType) ifTrue: [aList add: anExternal]].	^List withAll: aList</body><body package="DLLCC-Tools">externalDictionary	"Answer the ExternalDictionary held by the receiver."	^externalDictionary</body><body package="DLLCC-Tools">externalInterface	"Answer the ExternalInterface held by the receiver."	^externalInterface</body><body package="DLLCC-Tools">externalInterface: anExternalInterface	"Set what external interface the receiver holds."	externalInterface := anExternalInterface</body><body package="DLLCC-Tools">externalsAtCategory: category	"Answer a List of externals that conform to a particular category defined by the argument. The current list of categories are: #(procedures variables typedefs structs unions enums defines macros #'include files' #'include directories')."	| categorySymbol |	categorySymbol := category asSymbol.	categorySymbol == #procedures ifTrue: [^self procedures].	categorySymbol == #variables ifTrue: [^self variables].	categorySymbol == #typedefs ifTrue: [^self typedefs].	categorySymbol == #structs ifTrue: [^self structs].	categorySymbol == #unions ifTrue: [^self unions].	categorySymbol == #enums ifTrue: [^self enums].	categorySymbol == #defines ifTrue: [^self defines].	categorySymbol == #macros ifTrue: [^self macros].	categorySymbol == #'include files' ifTrue: [^self includeFiles].	categorySymbol == #'include directories' ifTrue: [^self includeDirectories].	categorySymbol == #'library files' ifTrue: [^self libraryFiles].	categorySymbol == #'library directories' ifTrue: [^self libraryDirectories].	^List new</body><body package="DLLCC-Tools">includeDirectories	"Answer a list of all include directories held by the receiver."	^externalInterface isNil		ifTrue: [^nil]		ifFalse: [^externalInterface includeDirectories]</body><body package="DLLCC-Tools">includeFiles	"Answer a list of all include files held by the receiver."	^externalInterface isNil		ifTrue: [^nil]		ifFalse: [^externalInterface includeFiles]</body><body package="DLLCC-Tools">libraryDirectories	"Answer a list of all library directories held by the receiver."	^externalInterface isNil		ifTrue: [^nil]		ifFalse: [^externalInterface libraryDirectories copy]</body><body package="DLLCC-Tools">libraryFiles	"Answer a list of all library files held by the receiver."	^externalInterface isNil		ifTrue: [^nil]		ifFalse: [^externalInterface libraryFiles collect: [:aFile | aFile name]]</body><body package="DLLCC-Tools">macros	"Answer a list of all #define macro externals held by the receiver."	| aList |	aList := SortedCollection sortBlock: [:x :y | x name &lt;= y name].	externalDictionary ownDo: [:anExternal |		((anExternal isKindOf: CMacroDefinition)			and: [anExternal numArgs notNil and: [anExternal numArgs &gt; 0]])				ifTrue: [aList add: anExternal]].	^List withAll: aList</body><body package="DLLCC-Tools">procedures	"Answer a list of all procedure externals held by the receiver. If the receiver holds onto an optimized interface, scan the interface's methods to extract the procedure prototype from the source code -- answer a String as opposed to a procedure external in this case."	| aList |	aList := SortedCollection sortBlock: [:x :y |		(x isCharacters ifTrue: [x] ifFalse: [x name]) &lt;= (y isCharacters ifTrue: [y] ifFalse: [y name])].	externalDictionary ownDo: [:anExternal |		(anExternal isKindOf: ExternalProcedure) ifTrue: [aList add: anExternal]].	(externalInterface notNil and: [		externalInterface externals == externalDictionary and: [		externalInterface optimizationLevel == #full]]) ifTrue: [			externalInterface selectorsAndMethodsDo: [:selector :method | | source range |				((method isKindOf: ExternalMethod)					and: [method primitiveNumber notNil]) ifTrue: [					source := externalInterface sourceCodeForMethod: method at: selector.					range := source						findString: '*&lt;C:*&gt;'						startingAt: 1						ignoreCase: false						useWildcards: true.					(range first = 0 and: [range last = 0]) ifFalse: [| prototype index length |						prototype := ((source copyFrom: range first + 3 to: range last - 1)									copyWithout: Character tab) copyWithout: Character cr.						length := prototype size.						index := 1.						[index &lt;= length and: [(prototype at: index) isSeparator]]							whileTrue: [index := index + 1].						aList add: (prototype copyFrom: index to: length)]]]].	^List withAll: aList</body><body package="DLLCC-Tools">structs	"Answer a list of all structure type externals held by the receiver."	| aList |	aList := SortedCollection sortBlock: [:x :y | x name &lt;= y name].	externalDictionary ownDo: [:anExternal |		((anExternal isKindOf: CCompositeType)			and: [anExternal isStructure]) ifTrue: [aList add: anExternal]].	^List withAll: aList</body><body package="DLLCC-Tools">typedefs	"Answer a list of all typedef type externals held by the receiver."	| aList |	aList := SortedCollection sortBlock: [:x :y | x name &lt;= y name].	externalDictionary ownDo: [:anExternal |		(anExternal isKindOf: CTypedefType) ifTrue: [aList add: anExternal]].	^List withAll: aList</body><body package="DLLCC-Tools">unions	"Answer a list of all union type externals held by the receiver."	| aList |	aList := SortedCollection sortBlock: [:x :y | x name &lt;= y name].	externalDictionary ownDo: [:anExternal |		((anExternal isKindOf: CCompositeType)			and: [anExternal isUnion]) ifTrue: [aList add: anExternal]].	^List withAll: aList</body><body package="DLLCC-Tools">variables	"Answer a list of all variable externals held by the receiver."	| aList |	aList := SortedCollection sortBlock: [:x :y | x name &lt;= y name].	externalDictionary ownDo: [:anExternal |		(anExternal isKindOf: ExternalVariable) ifTrue: [aList add: anExternal]].	^List withAll: aList</body></methods><methods><class-id>External.ExternalInterfaceHolder</class-id> <category>initialize-release</category><body package="DLLCC-Tools">on: anExternalInterface	"Initialize the receiver to hold the argument. If the argument is an interface class,	 initialize the receiver's external dictionary based on the argument's external	 dictionary. If the argument is an external dictionary, simply remember that	 dictionary but do not disturb the interface class."	(anExternalInterface isKindOf: ExternalInterface class) ifTrue:		[externalInterface := anExternalInterface.		 externalDictionary := externalInterface externals.		 ^self].	(anExternalInterface isKindOf: ExternalDictionary) ifTrue:		[externalDictionary := anExternalInterface.		 ^self].	^self error: (#canOnlyHoldExternals &lt;&lt; #dllcc &gt;&gt; '&lt;1p&gt; can only hold ExternalInterface or ExternalDictionary objects'			expandMacrosWith: self class).</body></methods><methods><class-id>External.ExternalInterfaceHolder class</class-id> <category>instance creation</category><body package="DLLCC-Tools">on: anExternalDictionary	"Answer a new instance of the receiver holding onto the argument."	^self new on: anExternalDictionary</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private</category><body package="DLLCC-Tools">generateMissingTypeDefinitions	| defineTypes newSelectors newState |	defineTypes := self				promptForTypeDefinitions: self undefinedTypeDefinitions.	newSelectors := Set new.	defineTypes do: 			[:each |			each methods do: 					[:methodCodeString |					newSelectors						add: (self selectedClass compile: methodCodeString classified: each category)]].	newState := state copy.	newState definitions: (newSelectors				collect: [:each | MethodDefinition class: self selectedClass selector: each]).	self updateWithState: newState</body><body package="DLLCC-Tools">promptForTypeDefinitions: externals	| wrappers listModel dialog spec listWrapper resultHolder |	wrappers := OrderedCollection new.	listModel := (MultiSelectionInList new)				list: externals;				selectAll;				yourself.	dialog := SimpleDialog new.	spec := dialog interfaceSpecFor: #emptySpec.	dialog initializeBuilderFor: builder window.	(dialog builder)		add: spec window;		add: spec component.	dialog		initializeWindowFor: builder window;		setInitialGap;		addMessage: #TypesToDefineC &gt;&gt; 'Define the following types:' &lt;&lt; #IDE			centered: true;		addGap: 10.	listWrapper := dialog				addMultiList: listModel				lines: 10				validation: [true].	listWrapper widget displayStringSelector: #name.	dialog addGap: 5.	wrappers add: (dialog				addLabels: (Array with: #DefineExternals &gt;&gt; 'Define' &lt;&lt; #IDE						with: #Cancel &gt;&gt; 'Cancel' &lt;&lt; #IDE)				values: #(#define #cancel)				default: #define				storeInto: (resultHolder := #define asValue)				takeKeyboard: true				equalize: true).	dialog addGap: 5.	dialog bottomAlignLowerEdge: listWrapper.	dialog bottomAlign: wrappers.	dialog preOpen.	dialog builder		openDialogWithExtent: dialog builder window displayBox extent.	resultHolder value = #cancel ifTrue: [^Array new].	resultHolder value = #define ifTrue: [^listModel selections].	self shouldNotImplement</body><body package="DLLCC-Tools">showGenerateUndefinedTypes	^self selectedClass notNil and: 			[(self selectedClass instanceBehavior includesBehavior: ExternalInterface)				and: [self selectedClass instanceBehavior undefinedExternals notEmpty]]</body><body package="DLLCC-Tools">undefinedTypeDefinitions	" Select all typedef types from the selected class's undefined externals and sort them in alphabetical order. "	^self selectedClass instanceBehavior undefinedExternals		asSortedCollection: [:a :b | a name &lt;= b name]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>public boss</category><body package="DLLCC-Tools">bossIn: fileNameString	"BOSS in the ExternalInterface class contained in the file specified by the argument.  The argument must be a String indicating the BOSS file's path.  Answers the receiver.  If the file indicated by the argument could not be found or the file is not in a valid BOSS format, an exception is raised.  This method is typically used on files generated by the ExternalInterface class methods bossOutHierarchy: or bossOutSubclasses:."	"ExternalInterface bossIn: 'SomeInterfaceClasses.bos'"	| bos classes |	bos := AbstractBinaryObjectStorage onOld: (fileNameString asFilename withEncoding: #binary) readStream.	[classes := bos nextClasses.	bos atEnd		ifTrue: [self compatibilityBossIn: classes version: nil]		ifFalse: [self compatibilityBossIn: classes version: bos next]]		ensure: [bos close]</body><body package="DLLCC-Tools">bossOut: fileNameString sourceMode: sourceMode	"Write a BOSS format version of the receiver in the file indicated by the argument.  The argument must be a String indicating the BOSS file's path.  Answers the receiver.  If the file indicated by the argument could not be created for writing or the receiver could not be properly BOSS'ed out, an exception is raised.  This method is typically used to generate the file read by the method ExternalInterface class&gt;&gt;bossIn:.  The argument, sourceMode, can be one of #keep, #reference, or #discard and indicates whether the method's source code is written to the BOSS file, source code references are written to the BOSS file (assuming the same changes file will be available), or source code is simply discarded."	"SomeExternalInterface bossOut: 'SomeExternalInterface.bos' sourceMode: #keep"	| bos |	bos := BinaryObjectStorage onNew: (fileNameString asFilename withEncoding: #binary) writeStream.	[self flushAllCaches.	bos sourceMode: sourceMode.	bos nextPutClasses: (Array with: self).	bos nextPut: self version]		ensure: [bos close]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private boss</category><body package="DLLCC-Tools">bossOutClasses: aClassCollection onFile: aFile sourceMode: sourceMode	"Place the class collection onto aFile.  In addition, append the current interface version identifier."	| bos |	bos := BinaryObjectStorage onNew: (aFile asFilename withEncoding: #binary) writeStream.	[aClassCollection do: [:aClass |		(aClass isKindOf: ExternalInterface class) ifTrue: [aClass flushAllCaches]].	bos sourceMode: sourceMode.	bos nextPutClasses: aClassCollection.	bos nextPut: self version]		ensure: [bos close]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>public boss</category><body package="DLLCC-Tools">bossOutHierarchy: fileNameString sourceMode: sourceMode	"Write a BOSS format version of the receiver and all it's subclasses in the file indicated by the argument.  The argument must be a String indicating the BOSS file's path.  Answers the receiver.  If the file indicated by the argument could not be created for writing or the receiver and its subclasses could not be properly BOSS'ed out, an exception is raised.  This method is typically used to generate the file read by the method ExternalInterface class&gt;&gt;bossIn:.  The argument, sourceMode, can be one of #keep, #reference, or #discard and indicates whether the method's source code is written to the BOSS file, source code references are written to the BOSS file (assuming the same changes file will be available), or source code is simply discarded."	"SomeExternalInterface bossOutHierarchy: 'SomeExternalInterfaceHierarchy.bos' sourceMode: #keep"	^self bossOutClasses: self withAllSubclasses onFile: fileNameString sourceMode: sourceMode</body><body package="DLLCC-Tools">bossOutSubclasses: fileNameString sourceMode: sourceMode	"Write a BOSS format version of the receiver's subclasses in the file indicated by the argument.  The argument must be a String indicating the BOSS file's path.  Answers the receiver.  If the file indicated by the argument could not be created for writing or the receiver and its subclasses could not be properly BOSS'ed out, an exception is raised.  This method is typically used to generate the file read by the method ExternalInterface class&gt;&gt;bossIn:.  The argument, sourceMode, can be one of #keep, #reference, or #discard and indicates whether the method's source code is written to the BOSS file, source code references are written to the BOSS file (assuming the same changes file will be available), or source code is simply discarded."	"SomeInterface bossOutSubclasses: 'ExternalInterfaceSubclasses.bos' sourceMode: #keep"	"ExternalInterface bossIn: 'ExternalInterfaceSubclasses.bos'"	^self bossOutClasses: self allSubclasses onFile: fileNameString sourceMode: sourceMode</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private boss</category><body package="DLLCC-Tools">compatibilityBossIn: classCollection version: versionID	"Perform any necessary operations on the classes contained in the argument, classCollection.  The versionID argument is a string indicating which version of BOSS file loaded the classes."	versionID isNil		ifTrue:			[classCollection do: [:aClass |				(aClass isKindOf: ExternalInterface class)					ifTrue: [aClass libraryFiles do: [:aFile | aFile owner: aClass]]]].	versionID = 'ExternalInterface Release 2.0'		ifTrue:			[classCollection do: [:aClass |				(aClass isKindOf: ExternalInterface class)					ifTrue:						[aClass externals do: [:ext |							(ext isKindOf: CType) ifTrue: [								ext transDo: [:aType |									(aType isKindOf: CCompositeType)										ifTrue: [aType updateKindsCache]]]]]]]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="DLLCC-Tools">openExternalFinder	self openApplicationForClassNamed: #{ExternalInterfaceFinder}</body></methods><methods><class-id>Tools.ExternalInterfaceClassFinder class</class-id> <category>interface specs</category><body package="DLLCC-Tools">createSpec	"UIPainter new openOnClass: self andSelector: #createSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #dllcc) 			#bounds: #(#{Graphics.Rectangle} 654 356 1074 636 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 40 0 -2 0.4 -4 1 ) 					#name: #nameSpaces 					#model: #nameSpaces 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #expandCollapse ) 					#useModifierKeys: true 					#selectionType: #normalSelection ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 6 ) 					#label: #(#{Kernel.UserMessage} #key: #Location #defaultString: 'Location' #catalogID: #dllcc) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0.4 40 0 -4 1 70 0 ) 					#model: #localClassName ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0.4 75 0 -4 1 105 0 ) 					#model: #classCategory ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 8 0.4 120 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Superclass #defaultString: 'Superclass:' #catalogID: #dllcc) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 8 0.4 42 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #dllcc) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 8 0.4 77 0 ) 					#label: #(#{Kernel.UserMessage} #key: #CategoryC #defaultString: 'Category:' #catalogID: #dllcc) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0.4 155 0 -4 1 185 0 ) 					#model: #normalSuperclass 					#menu: #superclassOptions ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0.4 190 0 -4 1 220 0 ) 					#name: #superclassID 					#flags: 0 					#minorKey: #nameOnlySpec 					#clientKey: #superclassID ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 205 234 ) 					#model: #isVirtual 					#label: #(#{Kernel.UserMessage} #key: #Virtual #defaultString: 'Virtual' #catalogID: #dllcc) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 297 234 ) 					#model: #isOptimized 					#label: #(#{Kernel.UserMessage} #key: #Optimized #defaultString: 'Optimized' #catalogID: #dllcc) ) ) ) )</body></methods><methods><class-id>Tools.ExternalInterfaceFinder class</class-id> <category>interface specs</category><body package="DLLCC-Tools">bossOutDialog	"UIPainter new openOnClass: self andSelector: #bossOutDialog"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'BOSS Out As' 			#min: #(#Point 231 147 ) 			#max: #(#Point 640 147 ) 			#bounds: #(#Rectangle 63 221 320 368 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 10 32 ) 					#label: 'File Name:' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 8 0 0.5 0 ) 					#label: 'BOSS Out As' ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 16 0 56 0 -10 1 80 0 ) 					#name: #fileName 					#model: #fileName ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 85 ) 					#model: #hierarchy 					#label: 'Hierarchy' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #doOK 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #doCancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body><body package="DLLCC-Tools">defineMethodCreationDialog	"UIPainter new openOnClass: self andSelector: #defineMethodCreationDialog"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 288 134 ) 			#max: #(#Point 640 134 ) 			#bounds: #(#Rectangle 771 376 1080 510 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 3 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #NewDefine #defaultString: 'New Define' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 83 0 0 1 ) 					#name: #typeLabel 					#label: #(#{Kernel.UserMessage} #key: #Value #defaultString: 'Value:' #catalogID: #dllcc) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 32 0 -10 1 56 0 ) 					#name: #externalNameField 					#model: #externalName 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 61 0 -10 1 85 0 ) 					#model: #macroValue 					#type: #string ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -136 0.5 -35 1 -70 0.5 -5 1 ) 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #dllcc) 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -62 0.5 -35 1 62 0.5 -5 1 ) 					#model: #doBrowse 					#label: #(#{Kernel.UserMessage} #key: #OK_Browse #defaultString: 'OK &amp; Browse' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 70 0.5 -35 1 136 0.5 -5 1 ) 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) ) ) )</body><body package="DLLCC-Tools">macroMethodCreationDialog	"UIPainter new openOnClass: self andSelector: #macroMethodCreationDialog"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 282 134 ) 			#max: #(#Point 640 134 ) 			#bounds: #(#Rectangle 330 393 640 527 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 3 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #NewMacro #defaultString: 'New Macro' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 83 0 0 1 ) 					#name: #typeLabel 					#label: #(#{Kernel.UserMessage} #key: #Value #defaultString: 'Value:' #catalogID: #dllcc) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 32 0 -10 1 56 0 ) 					#name: #externalNameField 					#model: #externalName 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 61 0 -10 1 85 0 ) 					#model: #macroValue 					#type: #string ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -136 0.5 -35 1 -70 0.5 -5 1 ) 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #dllcc) 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -62 0.5 -35 1 62 0.5 -5 1 ) 					#model: #doBrowse 					#label: #(#{Kernel.UserMessage} #key: #OK_Browse #defaultString: 'OK &amp; Browse' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 70 0.5 -35 1 136 0.5 -5 1 ) 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) ) ) )</body><body package="DLLCC-Tools">procMethodCreationDialog	"UIPainter new openOnClass: self andSelector: #procMethodCreationDialog"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 532 237 850 539 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 86 0 -10 1 -79 1 ) 					#label: #(#{Kernel.UserMessage} #key: #ArgumentTypes #defaultString: 'Argument Types: ' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 3 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #NewProcedure #defaultString: 'New Procedure' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 58 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 86 0 0 1 ) 					#name: #typeLabel 					#label: #(#{Kernel.UserMessage} #key: #ReturnType #defaultString: 'Return Type:' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 -46 1 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #CallingConvention #defaultString: 'Calling convention:' #catalogID: #dllcc) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 32 0 -10 1 56 0 ) 					#name: #externalNameField 					#model: #externalName 					#type: #string ) 				#(#ComboBoxSpec 					#layout: #(#LayoutFrame 147 0 60 0 -10 1 84 0 ) 					#name: #returnTypeField 					#model: #returnTypeString 					#isReadOnly: false 					#comboList: #typeMenu ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 20 0 114 0 -15 0.5 -89 1 ) 					#model: #argumentNamesList ) 				#(#ComboBoxSpec 					#layout: #(#LayoutFrame -5 0.5 114 0 -18 1 138 0 ) 					#name: #argumentTypeField 					#model: #argumentTypeString 					#isReadOnly: false 					#comboList: #typeMenu ) 				#(#ComboBoxSpec 					#layout: #(#LayoutFrame 186 0 -72 1 -10 1 -48 1 ) 					#model: #callingConvention 					#comboList: #callingConventionMenu ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -136 0.5 -35 1 -70 0.5 -5 1 ) 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #dllcc) 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -62 0.5 -35 1 62 0.5 -5 1 ) 					#model: #doBrowse 					#label: #(#{Kernel.UserMessage} #key: #OK_Browse #defaultString: 'OK &amp; Browse' #catalogID: #dllcc) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 70 0.5 -35 1 136 0.5 -5 1 ) 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #dllcc) 					#defaultable: true ) ) ) )</body><body package="DLLCC-Tools">typedefMethodCreationDialog	"UIPainter new openOnClass: self andSelector: #typedefMethodCreationDialog"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 279 135 ) 			#max: #(#Point 640 135 ) 			#bounds: #(#Rectangle 20 244 328 379 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#LayoutOrigin 107 0 0 0 ) 					#label: #(#{Kernel.UserMessage} #key: #NewTypedef #defaultString: 'New Typedef' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 59 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 87 0 0 1 ) 					#name: #typeLabel 					#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type:' #catalogID: #dllcc) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 32 0 -10 1 57 0 ) 					#name: #externalNameField 					#model: #externalName 					#type: #string ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 74 61 224 85 ) 					#name: #typeField 					#model: #typeString 					#isReadOnly: false 					#comboList: #typeMenu ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -136 0.5 -35 1 -70 0.5 -5 1 ) 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #dllcc) 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -62 0.5 -35 1 62 0.5 -5 1 ) 					#model: #doBrowse 					#label: #(#{Kernel.UserMessage} #key: #OK_Browse #defaultString: 'OK &amp; Browse' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 70 0.5 -35 1 136 0.5 -5 1 ) 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) ) ) )</body><body package="DLLCC-Tools">varMethodCreationDialog	"UIPainter new openOnClass: self andSelector: #varMethodCreationDialog"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 273 134 ) 			#max: #(#Point 640 134 ) 			#bounds: #(#Rectangle 25 431 332 565 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 107 0 ) 					#label: #(#{Kernel.UserMessage} #key: #NewVariable #defaultString: 'New Variable' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 59 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 87 0 0 1 ) 					#name: #typeLabel 					#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type:' #catalogID: #dllcc) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 32 0 -10 1 57 0 ) 					#name: #externalNameField 					#model: #externalName 					#type: #string ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 74 61 224 85 ) 					#name: #typeField 					#model: #typeString 					#isReadOnly: false 					#comboList: #typeMenu ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -136 0.5 -35 1 -70 0.5 -5 1 ) 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #dllcc) 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -62 0.5 -35 1 62 0.5 -5 1 ) 					#model: #doBrowse 					#label: #(#{Kernel.UserMessage} #key: #OK_Browse #defaultString: 'OK &amp; Browse' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 70 0.5 -35 1 136 0.5 -5 1 ) 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #dllcc) 					#isDefault: false 					#defaultable: true ) ) ) )</body><body package="DLLCC-Tools">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 				#(#UserMessage 					#key: #finderLabel 					#defaultString: 'External Interface Finder'					#catalogID: #dllcc)			#min: #(#{Core.Point} 20 20 ) 			#bounds: #(#{Graphics.Rectangle} 583 472 989 710 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0.3 58 0 0 1 ) 					#label: #(#UserMessage 								#key: #Category								#defaultString: 'Category'								#catalogID: #dllcc) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.6 58 0 0 1 ) 					#name: #ExternalListLabel 					#label: #(#UserMessage 								#key: #Externals								#defaultString: 'Externals'								#catalogID: #dllcc) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 56 0 5 0.3 -10 1 ) 					#name: #ClassNameList 					#model: #classNameList 					#menu: #classNameListMenu ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.3 56 0 -5 0.6 -10 1 ) 					#name: #CategoryList 					#model: #categoryList ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.6 56 0 -10 1 -10 1 ) 					#name: #ExternalList 					#flags: 15 					#model: #externalList 					#menu: #externalListMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.25 32 0 ) 					#name: #browseButton 					#model: #browseSelection 					#label: #(#UserMessage 								#key: #Browse								#defaultString: 'Browse'								#catalogID: #dllcc) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.25 0 0 0 0.5 32 0 ) 					#name: #regenerateButton 					#model: #regenerate 					#label: #(#UserMessage 								#key: #Regenerate								#defaultString: 'Regenerate'								#catalogID: #dllcc)  ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 0 0.75 32 0 ) 					#name: #newButton 					#model: #newInterface 					#label: #(#UserMessage 								#key: #New								#defaultString: 'New'								#catalogID: #dllcc) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.75 0 0 0 1 32 0 ) 					#name: #removeButton 					#model: #remove 					#label: #(#UserMessage 								#key: #Remove								#defaultString: 'Remove'								#catalogID: #dllcc) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 58 0 0 1 ) 					#name: #ClassNameListLabel 					#label: #(#UserMessage 								#key: #Class								#defaultString: 'Class'								#catalogID: #dllcc) ) ) ) )</body></methods><methods><class-id>Tools.ExternalInterfaceBuilder class</class-id> <category>interface specs</category><body package="DLLCC-Tools">externalMultiSelectionSubCanvas	"UIPainter new openOnClass: self andSelector: #externalMultiSelectionSubCanvas"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: #(#WindowSpec #label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #dllcc) #min: #(#Point 50 50 ) #bounds:#(#Rectangle 251 196 451 396 ) ) #component: #(#SpecCollection #collection: #(#(#SequenceViewSpec#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) #name: #ExternalMultiSelectionList #flags: 15 #model:#externalMultiSelectionList #multipleSelections: true ) ) ) )</body><body package="DLLCC-Tools">externalSingleSelectionSubCanvas	"UIPainter new openOnClass: self andSelector: #externalSingleSelectionSubCanvas"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: #(#WindowSpec #label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #dllcc) #min: #(#Point 50 50 ) #bounds:#(#Rectangle 243 192 443 392 ) ) #component: #(#SpecCollection #collection: #(#(#SequenceViewSpec#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) #name: #ExternalSingleSelectionList #flags: 15 #model:#externalSingleSelectionList ) ) ) )</body><body package="DLLCC-Tools">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label:				#(#UserMessage 					#key: #builderLabel 					#defaultString: 'External Interface Builder'					#catalogID: #dllcc)			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 475 163 987 434 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 4 0 28 0 -2 0.333333 -40 1 ) 					#model: #categoryList ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 26 0 0 1 ) 					#label: #(#UserMessage 								#key: #Category								#defaultString: 'Category'								#catalogID: #dllcc) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 6 0.333333 26 0 0 1 ) 					#name: #ExternalListLabel 					#label:  #(#UserMessage 								#key: #Externals								#defaultString: 'Externals'								#catalogID: #dllcc) ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 2 0.333333 28 0 -4 1 -40 1 ) 					#name: #ExternalSubCanvas 					#flags: 0 					#majorKey: #ExternalInterfaceBuilder 					#minorKey: #externalSingleSelectionSubCanvas ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 2 0 -35 1 -1 0.23 -5 1 ) 					#name: #parseButton 					#model: #parse 					#label:  #(#UserMessage 								#key: #ParseFiles								#defaultString: 'Parse Files'								#catalogID: #dllcc) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 1 0.23 -35 1 -1 0.48 -5 1 ) 					#name: #addMethodsButton 					#model: #addMethods 					#label:  #(#UserMessage 								#key: #AddMethods								#defaultString: 'Add Methods'								#catalogID: #dllcc)					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 1 0.48 -35 1 -1 0.72 -5 1 ) 					#name: #defineButton 					#model: #defineClass 					#label:  #(#UserMessage 								#key: #DefineClass								#defaultString: 'Define Class'								#catalogID: #dllcc)					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 1 0.72 -35 1 -1 0.83 -5 1 ) 					#name: #addButton 					#model: #add 					#label:  #(#UserMessage 								#key: #Add								#defaultString: 'Add'								#catalogID: #dllcc)					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 1 0.83 -35 1 -3 1 -5 1 ) 					#name: #removeButton 					#model: #remove 					#label:   #(#UserMessage 								#key: #Remove								#defaultString: 'Remove'								#catalogID: #dllcc)					#defaultable: true ) ) ) )</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="DLLCC-Tools">menuItemGenerateMissingTypeDefinitions	&lt;itemInMenu: #(#classMenu) position: 300.5&gt;	^(MenuItem		labeled: #GenerateTypeDefs &gt;&gt; 'Generate Missing Type Definitions' &lt;&lt; #IDE)		visible: [self showGenerateUndefinedTypes];		value: #generateMissingTypeDefinitions</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>resources</category><body package="DLLCC-Tools">BWExtFinder24	"UIMaskEditor new openOnClass: self andSelector: #BWExtFinder24"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 0 128 0 1 0 191 255 253 0 148 42 21 0 159 255 253 0 152 0 5 0 144 15 5 0 146 31 133 0 146 25 133 0 146 24 5 0 146 24 5 0 146 24 5 0 146 24 5 0 158 25 133 0 154 31 133 0 154 15 5 0 254 0 5 0 211 255 197 0 240 0 29 0 144 0 1 0 159 255 253 0 128 0 1 0 255 255 255 0 0 0 0 0 ])</body><body package="DLLCC-Tools">BWExtFinder32	"UIMaskEditor new openOnClass: self andSelector: #BWExtFinder32"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[0 0 0 0 63 255 255 254 95 255 255 254 111 255 255 254 112 0 0 6 117 245 87 214 112 0 0 6 115 255 255 246 119 255 255 246 119 126 3 246 119 124 1 246 119 124 1 246 119 124 113 246 119 124 127 246 119 124 127 246 119 124 127 246 119 124 127 246 119 124 113 246 116 124 1 246 117 124 1 246 117 126 3 246 68 127 255 246 87 127 255 246 87 0 1 246 71 255 255 134 119 255 255 254 119 255 255 254 112 0 0 6 127 255 255 250 127 255 255 252 0 0 0 0 255 255 255 255 ])</body><body package="DLLCC-Tools">CGExtFinder24	"UIMaskEditor new openOnClass: self andSelector: #CGExtFinder24"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 9) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 5 put: ColorValue cyan; at: 6 put: ColorValue lightGray; at: 7 put: ColorValue yellow; at: 8 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); at: 9 put: ColorValue red; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@ADQDQDQDQDQDQDQ@@0@@@@@@@@@@@@A@@2@ H"HB@ H"HBA@@2@@@@@@@@@@@@A@AR@FI"X&amp;I"X&amp;I"A@@2@RX&amp;I"]7]"X&amp;A@@2@3@RX'']7]6I"A@AR@2@!I''\&amp;]2X&amp;A@@2@2@2D'']"X&amp;I"A@@2@2@#HW\&amp;I"X&amp;A@AR@2@2T'']"X&amp;I"A@@2@2@#H7\&amp;I"X&amp;A@@2@@@2L''\R]6I"A@AR@H@#H7]7]2X&amp;A@@2@H@2L#]7\&amp;I"A@@@@@@#H2L%HRX&amp;A@@H@Q@@@@@@@@I"A@@@@2DQDQDQDQD@A@@Q@5L3L3L3L3L3Q@@2@@@@@@@@@@@@A@@3DQDQDQDQDQDQE@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L3'))</body><body package="DLLCC-Tools">CGExtFinder32	"UIMaskEditor new openOnClass: self andSelector: #CGExtFinder32"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 9) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 5 put: ColorValue cyan; at: 6 put: ColorValue lightGray; at: 7 put: ColorValue yellow; at: 8 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); at: 9 put: ColorValue red; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@ADQDQDQDQDQDQDQDQDQD@CADQDQDQDQDQDQDQDQDQ@@3ADQDQDQDQDQDQDQDQDP@L2@@@@@@@@@@@@@@@@AD@CL HBH"HB@ HB@"H"@ Q@@3H@@@@@@@@@@@@@@@@DP@T2@FI"X&amp;I"X&amp;I"X&amp;I"AD@CL HVI"X&amp;I"X&amp;I"X&amp;I Q@@3HBL0E"X&amp;]7]7]&amp;X&amp;HDP@L2@#HCE"Y7]7]7]"X&amp;AD@EL H2@#E"]7]7]7I"X Q@@3HBL L#E'']6I'']6I"XDP@L2@#HBL#E7\&amp;I"X&amp;I"AD@CL H2@2L#]7X&amp;I"X&amp;I Q@ASHBL H2T'']2X&amp;I"X&amp;XDP@L2@#HCH2M7]"X&amp;I"X&amp;AD@CL H2@#H2]7E"]7I"X Q@@3HB@@L#H7]7]7]6I"XDP@T2@  BT#I7]7]7\&amp;I"AD@CL HH@2L#I7]7]2X&amp;I Q@@0@B@@H2T#H2L#E"X&amp;HDP@LH@!DCH2L%H2T#E"X&amp;AD@CB@H2@@@@@@@@@@I"X Q@@0@BL1DQDQDQDQDQD@@DP@LQ@#L1DQDQDQDQDQDTQD@CL H5L3L3L3L3L3L1DTQ@@3H@@@@@@@@@@@@@@@@DP@L3DQDQDQDQDQDQDQDQDD@CMSL3L3L3L3L3L3L3L3L@@@@@@@@@@@@@@@@@@@@@@EUUUUUUUUUUUUUUUUUUUUTb'))</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - dllcc</category><body package="DLLCC-Tools">menuItemOpenExternalFinder	&lt;vwPrivileged&gt;	&lt;itemInMenu: #(#launcherToolBar) position: 30.3&gt;	&lt;itemInMenu: #(#menuBar #tools) position: 10.5&gt;	^(MenuItem forCommand: #openExternalInterfaceFinder)		labelImage: GeneralIcons browseExternalInterfaces;		helpText: #DLLAndCConnect &lt;&lt; #dllcc &gt;&gt; 'DLL and C Connect';		value: [self openExternalFinder];		yourself</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="DLLCC-Tools">openExternalInterfaceFinderCommand	&lt;command: #openExternalInterfaceFinder&gt;	^Command		label: (#BrowseExternals &lt;&lt; #dllcc &gt;&gt; 'Browse External Interfaces')		group: #launcher		bindings: #()</body></methods><initialize><class-id>Tools.ExternalInterfaceFinder</class-id></initialize><initialize><class-id>Tools.ExternalInterfaceBuilder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>ClassFinder</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class className candidateClassName pages nameSpaces realNameSpaces classNames classPattern finished localClassName classCategory normalSuperclass superclassOptions superclassID dialog clientData canBeFutureClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock transcriptView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>